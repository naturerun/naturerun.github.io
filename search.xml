<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;left_sibling = run-&gt;left_sibling; right_sub_heap-&gt;right_sibling = run; run-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap; left_sub_heap-&gt;first_child = right_sub_heap; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;left_sibling = t; right_sub_heap-&gt;right_sibling = run; t-&gt;right_sibling = right_sub_heap; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap-&gt;first_child-&gt;left_sibling; t-&gt;right_sibling = right_sub_heap; right_sub_heap-&gt;left_sibling = t; right_sub_heap-&gt;right_sibling = left_sub_heap-&gt;first_child; left_sub_heap-&gt;first_child-&gt;left_sibling = right_sub_heap; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;left_sibling = run-&gt;left_sibling; left_sub_heap-&gt;right_sibling = run; run-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;left_sibling-&gt;right_sibling = left_sub_heap; right_sub_heap-&gt;first_child = left_sub_heap; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;left_sibling = t; left_sub_heap-&gt;right_sibling = run; t-&gt;right_sibling = left_sub_heap; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* t = right_sub_heap-&gt;first_child-&gt;left_sibling; t-&gt;right_sibling = left_sub_heap; left_sub_heap-&gt;left_sibling = t; left_sub_heap-&gt;right_sibling = right_sub_heap-&gt;first_child; right_sub_heap-&gt;first_child-&gt;left_sibling = left_sub_heap; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; cur-&gt;left_sibling = run-&gt;first_child-&gt;left_sibling; cur-&gt;right_sibling = run-&gt;first_child; run-&gt;first_child-&gt;left_sibling = cur; cur-&gt;left_sibling-&gt;right_sibling = cur; run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269#include "stdafx.h"#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define TYPE intenum ColorFlag &#123;RED, BLACK&#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode *left; RBTreeNode *right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; RBTreeNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; RBTreeNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt; *root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *ptr = root; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *DelRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt; *p = root; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt; *parent = nullptr; RBTreeNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *InsertRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; RBTreeNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt; *q = nullptr; RBTreeNode&lt;T&gt; *g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt; *ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; int last; memory(RBTreeNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入"&lt;&lt; *p &lt;&lt;endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008#include "stdafx.h"#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode *left; AVLNode *right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; AVLNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; AVLNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt; *root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; temp minmax; int lh= 0; //节点左子树高度 int rh= 0; //节点右子树高度 memory(AVLNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *ptr = root; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *DelAVL(AVLNode&lt;T&gt; *root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt; *p = root; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt; *parent = nullptr; AVLNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *InsertAVL(AVLNode&lt;T&gt; *root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; AVLNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = new AVLNode&lt;T&gt;(0, key); //新节点插入并调整父节点平衡因子 --stackforflashback.top()-&gt;bf; &#125; else &#123; stackforflashback.top()-&gt;right = new AVLNode&lt;T&gt;(0, key); ++stackforflashback.top()-&gt;bf; &#125; if (stackforflashback.top()-&gt;bf == 0) &#123; return root; //已平衡结束,返回根节点 &#125; else &#123; p = stackforflashback.top(); stackforflashback.pop(); if (stackforflashback.empty() == false) &#123; AVLNode&lt;T&gt; *parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if(parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125; else &#123; return p; //原AVL树已平衡,返回根节点,结束 &#125; &#125; &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt; *ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; int last; memory(AVLNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt;ptr-&gt;data&lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last ==2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt;"("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data&lt;&lt;"("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; AVLNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
