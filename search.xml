<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; if (cur_value == *cur-&gt;max) &#123; return true; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fnaturerun%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fnaturerun%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fnaturerun%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fnaturerun%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fnaturerun%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fnaturerun%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fnaturerun%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fnaturerun%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fnaturerun%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fnaturerun%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R(根据深度优先搜索的白色路径定理,R必定存在)，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fnaturerun%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;random&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode* p = nullptr; vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt;* ptr, pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt;* root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt;* p; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt;* p, const pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt;* ptr = root; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; result; if ((result = SerachBTreeNode(ptr, d)) == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* interval = nullptr; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (result != pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = result.first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;left, const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T&amp; key, vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;&amp; list)&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* InsertBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.push_back(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(scankey, make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.push_back(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;; ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); current-&gt;keyptrmap.erase(current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); ptr-&gt;p = current-&gt;keyptrmap.back().second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = current; root-&gt;keyptrmap.push_back(make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); return root; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = stackforback.top().first-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* DelBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树删除函数&#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt;* q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; scankey-&gt;first = q-&gt;keyptrmap.front().first; q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;keyptrmap.front().first; ptr-&gt;p = ptr-&gt;keyptrmap.front().second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(current-&gt;keyptrmap.end(), temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), make_pair(temp-&gt;first, current-&gt;p)); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = ptr-&gt;keyptrmap.end() - 1; current-&gt;p = left-&gt;second; temp-&gt;first = left-&gt;first; ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 45; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则同样交换g和p,r的颜色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则同样交换g和p,r颜色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (q == g-&gt;left) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 10; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;random&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; struct BranchNode &#123; BTreeNode* p; vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt; keyptrmap; //节点数据域和指针域 BranchNode() :keyptrmap(), p(nullptr) &#123;&#125; &#125;; union &#123; vector&lt;T&gt; *leaf_data; BranchNode* branch_data; &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BTreeNode(flag type_of_node) &#123; NodeFlag = type_of_node; if (type_of_node == branch) &#123; branch_data = new BranchNode(); &#125; else &#123; leaf_data = new vector&lt;T&gt;(); &#125; &#125; ~BTreeNode() &#123; if (NodeFlag == branch) &#123; delete branch_data; &#125; else &#123; delete leaf_data; &#125; &#125;&#125;;template &lt;typename T&gt;pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; SearchBTreeNode(BTreeNode&lt;T&gt;* ptr, pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;branch_data-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;branch_data-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;branch_data-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;branch_data-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt;* root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt;* p; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt;* p, const pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt;* ptr = root; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d; if (ptr-&gt;NodeFlag != BTreeNode&lt;T&gt;::flag::leaf) &#123; d.first = ptr-&gt;branch_data-&gt;keyptrmap.end(); d.second = true; &#125; BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; result; if (ptr-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::leaf ? true : (result = SearchBTreeNode(ptr, d)) == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;leaf_data-&gt;size() &amp;&amp; ptr-&gt;leaf_data-&gt;size() &lt;= M - 1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;branch_data-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;leaf_data-&gt;size() &amp;&amp; ptr-&gt;leaf_data-&gt;size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;leaf_data-&gt;begin()); arrange.top().minmax.min = *(ptr-&gt;leaf_data-&gt;begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;leaf_data-&gt;end(); --it; arrange.top().minmax.max = *it; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; typename vector&lt;T&gt;::iterator it = ptr-&gt;leaf_data-&gt;end(); --it; arrange.top().minmax.nodemax = *(it); arrange.top().minmax.min = *(ptr-&gt;leaf_data-&gt;begin()); arrange.top().minmax.max = *it; &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;leaf_data-&gt;begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;leaf_data-&gt;end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;branch_data-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* interval = nullptr; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true)) &#123; if (result != pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SearchBTreeNode(ptr, d))); interval = ptr-&gt;branch_data-&gt;p; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = result.first; if (d.first == ptr-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;branch_data-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BTreeNode&lt;T&gt;::flag::leaf) &#123; d = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true); &#125; &#125; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T&amp; key, vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;&amp; list)&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt;&amp; list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* InsertBTree(BTreeNode&lt;T&gt;* root, const T&amp; key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::leaf); root-&gt;leaf_data-&gt;push_back(key); return root; &#125; else &#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::branch) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;branch_data-&gt;keyptrmap); if (scankey != current-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;branch_data-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;branch_data-&gt;p; &#125; &#125; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; scankey = BinarySearch(*current-&gt;leaf_data, current-&gt;leaf_data-&gt;begin(), current-&gt;leaf_data-&gt;end() - 1, key); if (scankey.first) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; current-&gt;leaf_data-&gt;insert(scankey.second, key); &#125; if (current-&gt;leaf_data-&gt;size() &lt;= M - 1) &#123; return root; &#125; else &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;leaf_data-&gt;insert(ptr-&gt;leaf_data-&gt;end(), current-&gt;leaf_data-&gt;end() - M / 2, current-&gt;leaf_data-&gt;end()); current-&gt;leaf_data-&gt;erase(current-&gt;leaf_data-&gt;end() - M / 2, current-&gt;leaf_data-&gt;end()); if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::branch); root-&gt;branch_data-&gt;p = current; root-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(current-&gt;leaf_data-&gt;back(), ptr)); current-&gt;leaf_data-&gt;pop_back(); return root; &#125; else &#123; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;leaf_data-&gt;back(), ptr)); current-&gt;leaf_data-&gt;pop_back(); if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; while (true) &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::branch); ptr-&gt;branch_data-&gt;keyptrmap.insert(ptr-&gt;branch_data-&gt;keyptrmap.end(), current-&gt;branch_data-&gt;keyptrmap.end() - M / 2, current-&gt;branch_data-&gt;keyptrmap.end()); current-&gt;branch_data-&gt;keyptrmap.erase(current-&gt;branch_data-&gt;keyptrmap.end() - M / 2, current-&gt;branch_data-&gt;keyptrmap.end()); ptr-&gt;branch_data-&gt;p = current-&gt;branch_data-&gt;keyptrmap.back().second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::branch); root-&gt;branch_data-&gt;p = current; root-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(current-&gt;branch_data-&gt;keyptrmap.back().first, ptr)); current-&gt;branch_data-&gt;keyptrmap.pop_back(); return root; &#125; else &#123; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;branch_data-&gt;keyptrmap.back().first, ptr)); current-&gt;branch_data-&gt;keyptrmap.pop_back(); if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* DelBTree(BTreeNode&lt;T&gt;* root, const T&amp; key) //B树删除函数&#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; bool replace = false; while (current-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::branch) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;branch_data-&gt;keyptrmap); if (scankey != current-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt;* q = scankey-&gt;second; while (q-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::branch) &#123; stackforback.push(make_pair(q, q-&gt;branch_data-&gt;keyptrmap.begin())); q = q-&gt;branch_data-&gt;p; &#125; scankey-&gt;first = q-&gt;leaf_data-&gt;front(); q-&gt;leaf_data-&gt;erase(q-&gt;leaf_data-&gt;begin()); current = q; replace = true; break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;branch_data-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;branch_data-&gt;p; &#125; &#125; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; if (replace == false) &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; scankey = BinarySearch(*current-&gt;leaf_data, current-&gt;leaf_data-&gt;begin(), current-&gt;leaf_data-&gt;end() - 1, key); if (scankey.first == true) &#123; current-&gt;leaf_data-&gt;erase(scankey.second); &#125; else &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; &#125; if (current == root) &#123; if (current-&gt;leaf_data-&gt;empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;leaf_data-&gt;size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;leaf_data-&gt;size() &gt;= (M + 1) / 2) &#123; current-&gt;leaf_data-&gt;push_back(temp-&gt;first); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;leaf_data-&gt;front(); ptr-&gt;leaf_data-&gt;erase(ptr-&gt;leaf_data-&gt;begin()); return root; &#125; else &#123; current-&gt;leaf_data-&gt;push_back(temp-&gt;first); current-&gt;leaf_data-&gt;insert(current-&gt;leaf_data-&gt;end(), temp-&gt;second-&gt;leaf_data-&gt;begin(), temp-&gt;second-&gt;leaf_data-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;branch_data-&gt;p; &#125; if (ptr-&gt;leaf_data-&gt;size() &gt;= (M + 1) / 2) &#123; current-&gt;leaf_data-&gt;insert(current-&gt;leaf_data-&gt;begin(), temp-&gt;first); typename vector&lt;T&gt;::iterator left = ptr-&gt;leaf_data-&gt;end() - 1; temp-&gt;first = *left; ptr-&gt;leaf_data-&gt;erase(left); return root; &#125; else &#123; ptr-&gt;leaf_data-&gt;push_back(temp-&gt;first); ptr-&gt;leaf_data-&gt;insert(ptr-&gt;leaf_data-&gt;end(), current-&gt;leaf_data-&gt;begin(), current-&gt;leaf_data-&gt;end()); delete current; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;branch_data-&gt;p)); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;branch_data-&gt;keyptrmap.front().first; ptr-&gt;branch_data-&gt;p = ptr-&gt;branch_data-&gt;keyptrmap.front().second; ptr-&gt;branch_data-&gt;keyptrmap.erase(ptr-&gt;branch_data-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;branch_data-&gt;p)); current-&gt;branch_data-&gt;keyptrmap.insert(current-&gt;branch_data-&gt;keyptrmap.end(), temp-&gt;second-&gt;branch_data-&gt;keyptrmap.begin(), temp-&gt;second-&gt;branch_data-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;branch_data-&gt;p; &#125; if (ptr-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;branch_data-&gt;keyptrmap.insert(current-&gt;branch_data-&gt;keyptrmap.begin(), make_pair(temp-&gt;first, current-&gt;branch_data-&gt;p)); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = ptr-&gt;branch_data-&gt;keyptrmap.end() - 1; current-&gt;branch_data-&gt;p = left-&gt;second; temp-&gt;first = left-&gt;first; ptr-&gt;branch_data-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, current-&gt;branch_data-&gt;p)); ptr-&gt;branch_data-&gt;keyptrmap.insert(ptr-&gt;branch_data-&gt;keyptrmap.end(), current-&gt;branch_data-&gt;keyptrmap.begin(), current-&gt;branch_data-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 45; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fnaturerun%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fnaturerun%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fnaturerun%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fnaturerun%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fnaturerun%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fnaturerun%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，但是仍然可以继续化简，注意到代码四第25行k==0为真时完全可以继续执行k=next[k],最后会在21行执行next[++j]==0,效果和第25行为真时执行next[++j]=0完全相同，故25-28行可统一写为k=next[k],从而得到形式最为简洁的代码五 1234567891011121314151617181920212223242526272829303132333435package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 这(代码五)就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fnaturerun%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fnaturerun%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fnaturerun%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fnaturerun%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fnaturerun%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fnaturerun%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fnaturerun%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fnaturerun%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fnaturerun%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fnaturerun%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fnaturerun%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fnaturerun%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个2的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void selectPushedObject(int &amp;x1, int &amp;x2, int ScaleOfProblems, int *&amp;p, int &amp;i)&#123; if ((x1 != ScaleOfProblems) &amp;&amp; (x1 + x2 + 1 != 2 * ScaleOfProblems)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125;&#125;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int* p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int*)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = 0; x1 = 1; x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count p[i] = 1; //首次入栈，栈空,关键变量值已在上方确定,1首先入栈,x1自增1 while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; //非首次入栈栈不空 if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; selectPushedObject(x1, x2, n, p, i); &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; selectPushedObject(x1, x2, n, p, i); &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
</search>
