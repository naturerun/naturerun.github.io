<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
