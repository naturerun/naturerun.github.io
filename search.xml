<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
