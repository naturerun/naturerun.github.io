<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
