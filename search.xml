<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! U2FsdGVkX1+vg7sGK38TVuqBa73FYDqrRjqdAdlrz70vqumNSLPBN7OwQNBBwM6Stx0ioFTeB2vGTkQgDslPGeHJY9ceWIw/78x+s76EcLDGl+2r+/8f25pOKaAJja/gfKieS77d7mu2w0hJbBkgExkf9VvonsX4bfHj7FJJ+7QioyoevuBiRwY/JcLNr0ml4nnApYAfg1Tjw+ulfDmmu/VGWQweVm6uI/YHGsfrAF/xinffqzVMeOfSfwGwGSXNwe/Pj+wi8rd5rl/svkUZVIAwF1JjVNAJNNGXGTRg/miqJPL6pCjmP1EHV088/y/Ho6TglMJbTNJaidcqTwYhxn6pBWjjfE1BosEvmueveeqEbvjmyEWu1E3SBCd6fz6rB4ayoLxT4u565c8fAXmdHM7uSr6SGVKUfq0pFRebZpTfATc30xtK9z9Ajh7K+Kp+Ax6ACSQ+zcoZA7NEFHsm+EREMtJjF3BftQOkVyfnR25xQXeor8y+3b5JbngRGekDUq86tG9fXhg+7/9wUWGR/d/GjOGkEgYdGrGmMJJtcVav5za0Un1L62yyi0JOBoxnCyyg0Rr2hEcIcLT0w2iahmir3RaIF9U5UHl0Sfq5KYEL1dNAcHA8VTGj+J/yIqbgiAbYSshgbQ3h8xo3eV5IaRIP5zbl+sxuYlnvp8439TXS616orzFswNQUy6ED1Dt4CW3d1tpx/GdFqxk90+i5vXzirR8LQ7ezg4ogUHN+aom4/ykgbBvumzuo3R0cE8Yv2d+v0SoqyMpv5XoHqvB1eoYOTTl1c6+0FF2jGwGmgeP2P5QcNxIjzRvVywW+NBOtdBq8dwC4d9ts8BYsDHjYn2+tWRhulQ37obrBkBqg4/vlLhtF3r7bqOXOnZWjnIMYItOQPQYdd4VaRwzLNeMedpWlpg66dEIj4B4tAuH3F6wcHygA+DmmWu3xPgP6nrfWoSxvoQE8RqtUh9fdZKpWFCo/89S4d3QpKWlkW9LpraEN+dfrSdGdYEPTXHaOu2ELCoBnvHOxhKJkpanmZ4Kr4G0vJoNzSgq67Qwiv3xpAu3CeGlTWevPkdgGMXYQg7EzERqcc+jRXu8F11j8RJkTkte6Cd5+CXs94kcse/blUSSkARVkeY6sKF/YFP0LtjbCEKgDVZ1qTDmwXtCQElNt2lxCgFj8dy7rAhemnj6iUFfxmwGfAu3IUQAx4eEK7c4Ecji+CjrN9nmSBlfCwLUU8veLNzFW3oL6bYfYW9jnIv3t5HyMXCm6JdMKL0FyUGmT0hNjZWwbU+/g5EURbTh6QWsMIRUFWaZzGl8+9BRC9PtQQzy4jFjL+UHWKvfbY0Ginye5zFEyyTg5yVTfeIuQeCsqZc5K2WocHeCjb6nhntq+2jYduwx+oWOTUMYs9pE8le65BGAcWV++qFY9co/FvkCqKDHb4F32EMRsaiApwOPqtTbrUpzOTJIusXzJ4Qye2gqylTORGDwNBFS6nC1J3o1oIfEMRZEy5udrr8vDkrpFlZyOhfvLp0IOECs48piysRFC1+yek/ihsRoxF49WtyseDqHVT2HF6d8taKPNyyTyoaGGSyh+sOkAHVkxJP+6UilBhy4BLPAFnKdWZOqMpW1t+k1TTjOTGj5thyiv86rMc9N5tBx39fDnhZzWLYGFKtd3k1Q7juKUSH8Dh/lNb+WQg9YjCo4lyfFIYhtr4qQ2ubqKnRpr/HyoOdZ8ONoNknd1jMQlL4w7wlDwcL9+PbCACybfnNl5PL693dPmlZt6Wd6m92b5tiXQzLx3zo1lpVVI3a3jKKBgM3Hjx0tS9wasIdUSabeP5FMjxs3IY+nsD79whOUK7KUbKbUGB9InqWw12U2LzpJqg5daUSt3A/nqRUDcUKKEqAqmLU2l6u2fd6roFONBJWvjRx2ClFHBVBsSLpe1VIKbwgqic0wv1JuF4XwTz80XYPQKDxuIrdytOeHF+JtMKPI0jrHxCNJnnSaGrvwHEHlCBlzv6JS/1O/u4xbOoylPi8qRxWg6A3P+xY15HKtW7hEEJ/27aWZ3NRJw7gnYn2zKan2ggDWRsajRMl38kXXiKw78BY3UWY5lx6PgBqYqXUQT69KdF0PbVJUdpCFS1WUvAdvfAC8CPnlsb2BUjf8yaaTMa/4COApKo73h9mDqs5dyTNq0rO5JCr6m+SoxAmyUS485i3XbgeYdr2MKtsobwM6gVsEiN9DiPyc17L3t9ZjLdSe49N21pNslBiy9Cot8lJ0Zz84ZbyytwpW9jx5DZrfTQv5YsBybz9+mgLp5CfVrW8ekUhp7u//e7D7BMxoVjIb+HsUIAT9/Xo+6bQlCiKg4QWQxlK9R9rWyAILsJdYO74B4o70iAgzQbe3GhvdRSHydSYEj0CYv37NFNBPccrHOW6DBKS8tWCityK5h1n+O4wZJv6FEFk260yjEDC62TGi/kLvkqfsuigqzMngaXjmfodWZB94W5P3Md2EsbuYKUKpkEpM95TyK+kvA+fjk5kDd8GckZbJkmhAGp7RkU8xLPcbSGja9+MxzzN0spN/uEgQYilwfUq84SlChoicvqWuMadYZ7TvXJcV+1QVHfnQdfuc6Yaaae28e3OTiJb8bAAUSk/LjddlTndRPxgyNWAToFBPecf0DiAUJnPVE39sCFPpa+Nz9ZlaxT0PXX8O6TPZrODzfm7Dk0kjrpSXFC5bydH+MjQewhjuqC8p9TbaZ71K4mBSGXldLHijcpUSX/iPpWl/lwkQDSD56S+/ujLYtnMdcDRQzKVsVHkgHbmXANzGEc6GHhHPpsGbIECd6iCbfrfpdXUmEhd7JdD8yPhxcKQlGXOYsn3OBL4x6F0mvvrhe/8UAR/EFsaa0LbrORzCuEGiZ3JLLViGjlo+u3zaQWWsFNoz+zPAamteHb1QkAzzFWstIjQIwDsyUYabtae8gFI6yPepqoSQQeDjMMFZCz1x995o3vSLc9wINKG0AuazYR3i2ixzsWH/iHKHvpeYuJL9ufyQEMI62rg8kJG2L60t2jr3e1KeR/Jz76d/MFYdL/bsDbEtquqYgYyMe0E5Bolv9uzousmfSxKxsrBG1Fnc4RDOT4oRpxd2FoumbgdGL1/R7QhgqIbDtco6otZPvYxjr+3wu0cTPtlnjCoJlTXnn6t1Hg7nVIHHhzzV0q0uzR43z6yE+pD46LLKHVixZcIJQkHA9wqoRJ8Hy1nFR5Ep2wCQRL83FoUskNiAaxiQCzAh9oMTP2QB+2dHa958YNwiKnu+uetx+ABr3Qg8Ves80CS/ftcU+3TcVgUbainvy2RCrB0q5s5k6hixn5dAAi1zhq3GRFM9uD8eeORrjl/z++cP6vj4+MhRiQzZEQA7+HPHg8PJujNvRbmLfPifzH/hxYGRoETh7bDItyGLU4vD2ejmtrVAtho+PKOAccg+bz/473zVlOeSYxiX25OybuN8h7+zO0w+w32JngoOGe2L77ynvDBqsVnYFFp7Zh0wgyJn4TetDfqOLn2FwfkJOe7faS6bRHIMO2/Tzv/cjMif2H1mJoqzll6JtPbUGT/nS6v5q1Y5O9xHXbNGf21RNa1Dug0dK4AsShV7f4G0HbNCV1uQ6Z7h/zehwo8g6OaO/XrLnaohV+uCNmvgOcTnYRoJlAuuvorroYuvnlAR0Td+oZYVdz02e/fd9t0ZBM7zYKGtrav20nYT+jWHpjNG1CKFpTGYalXPuvaZu9mGlE1jMD9q3RXk50Qbfy6YCl559ZZPkp10ze1b83kNCobQn37DqeU4ShvJcVhK1OsYk6YYOctJAfJmjJh/yq348f+luIzu4KzRIfDyNe71vhnR5cMXOxQkloZM3NaSOep6M1rY2c/C4k6GkSzXQJM32Agoo6ybggBEoaCnGOyCO3mD6iNRyVi4KEtpM5epmxAhOjqXxMVOmBo42A9cSUBDQp+yj/5BqftnfoRLwoK8aBX/iUwODYouYVboBlIquU2oBj+ImN76kFvirz9aqJN6qSryGHDmewzcO/FSsEx+F77f5wAAsU6+fbVYQFqU/zyCbeSHwT5AdKvlfgbNKl7WVszHXyH/5GlbDnpG/j3WO2jW35JdMQbKC5pIhKOXbJ0Ex3hk8aOU11O/6gCYbtBzXlqzw7QTzjYhwUfKn4xV23KVcg+p1nV2LQ/irJnRwNPqmg/d6RFE/5yzLCZzj4tbeF9FIYPQWYFNI+tUc5QTvTeoffG2K1hPggwxQ4cnupqzUut7Y91kj+sfsd4u2Uuv/aZlaDwhCy9XdWLRN2a/iEeKaNcI7pk+CFvCD6jFv+hwvyH58euMdkCk8PVUEZUqFV+ij1xngW3tufkeuhvu+NcevHfTElIH6oo/KO0h6ungiBy/nvcb+kzgtJjOhFoJEWyZHcAwr8Jr8PCYfi9uxGh3gCSAPYJRzAsryGsSK+yRJ2ht/HIkU2MKG7xxKTgSZI+ffVeVGv1Y3fbe/JQtJrvHFJErgWntVNCxBPTh/pUuCJfS56XZaJ196WO60oMCQ4mWwBZWQzgvmxspOUvZP91vToH8unYyAnoXDievfJwOxT7YdVREbQDONtiRIRshAZgD3P86+pdJFQf4jwWdxe5ee33uczT29IttCOteExQe9yxyRWBd3+ly8Tw68LgN5gx4xr/qsaTwhGMS4vCJ0F5WEKqKepxi1ey5p6EWW8NT1D/Jjdcrnk14UQ4vJ9lJjcOLMsU5h4a1vdB5i16nSHaajXCzvFKX6BixL+kcSQPlqOP+TkrJCImnB7fhx6dbwiipx89x/jd4iUbMJPVb87qnsQ25btKIXfxi40rDhnCJV1fZIjcy8I2hXGj0gD8yVqtQQAOSlS+XSCycqgIOUWurUkNb9eAcE13PAeSe9do0O5sfODN7KLisJ9tgH4XWFv12IQWPJEq2rUespTnvUUeTbYvLRICnZekAyCIPYJtSL2WKdWlhp5YLASgBDcbZ6MMuWpSBzX3oYEvTUjGaw+8Et0sC3QEY9bqcY0hOsWexlClGezxnUiT6VbbqSQH0OU8TTjZQO3QZPZhqZClqu9LA3YKEOY5inJU03B9U8Ww+xOawNkvUhpohzcpNxCtg1caTybFICL/VJla/UKx1bnc+lmkUo/N8LghjGEHGqtArvuUI8vrsfFQDA5oygPMfKIECmUOIoYlZ87RaRD9r6LjwLm0MRYNlHtClNtb/YYWgLEZ+L0p9WwWKk16hDB1F1fFv9NvB09uNEPIjbmu2cq4bvryPT1NsGHFsIoPTWkCuipyRkmalQnnKTJ0xChhE8fLRAy1NLaPRzm5PoeBurEwDGTYR0JhdOngY3RZ3kiE7XuCinP2KVpMuVSCYLzZiFD4RjDbhgLiCZAsZxBgjs7Nqjr6UAECZ9+/eENKvHIYTB/9BzT8gKtuCFCzfd4LJ6ww7rO//ZMvX6kiuH/FOnzOXSTnV81f/no1urzR8oZIxaSvC7w0kaHiewB1Len55i1kRF3r/ANdaglxJFv33Pnt7I/0gPCkcQINXGKwbDqxTsqu5rNrbiXxZYfVGMJdU0/4XvmYYZXg6PvPr7SneXhPcVmY6UfB4arx/W7A3TY9Kk6/dluyiyOAvcXgdVhlw0g1kFUrjvV4+Yl3epaL8Cw3tNAFI9gV7EIrPIMRMA9DxlVV53Kj18HJbtzQpqKwNCU97M/WY12oJ3TjnhabTc+1cO39tXs47BC/DgKEgJPY7xLtSSSCCaNNk8yEClGpJXHpfigm6pqbjFc3+0A7tAg/ydPD9d+VaRBIMdbzyLJWstOAkG6aF7g5VDAT3ciubV1b7kc6qqAuvZlAfW44BnDPuuqsTYInvXUfhclGROsF3G7J+da2vo548RlH2Net0+5KD9XO1Iuz5OtjlQ94JdZic+A4INUtL2TK6TKjo2Ava/pHaKGKqWjgN4GoS8BKEuCNzsB89J94/JePxzujwa2CMIJWNSo/dFzxpSteJd10eRCJnFGMTC2XNpJ9cf3gYQOGBiVkUzdhKxrQZChF5LR+ncPwvYFHjhDzTWa7qu848FuKNCxQWdmO4xvd02jdOibQOaYXrKfcSamkp83LtmyIWGFih5GOrxBOaCGmOnYdh9XBEJjNJtKD8z5SYNxRgRsScbCDqESgYsKA26WMDtpiZZQkaMOgQBd5vbZxyHCQcMo0isfsrVV9KKvLWuzrrjXH+j4bP7Pp4JtLHUfh056IgQ+JF+UjiTw/q7SPdJVolIbHxGXyRXw/5VfWNUERkQy2gpt8EN9tSRwFRaa7ulq1a92szFqCwLMmeRkwmEHOrek/xebtUgJQIInkz7ivwLnyn45gjrvQtFkkYI221SLaBVFbr8+xbvTY3gxxe0ACddPaN+WvFbGLMglTsO5S4HmqATvTM+mgzNILjz5AlSv+spjwxe4mLHlya0cO/koPUhgXkCVXcA7RFgwCN77etC5O3cRFomUDQxWNSKwj+uobUw9KJFClM/c4gJfJxw+nyGTDSRSoWT2rhOYBvXy1MHZI51U5VoAEgQW8NbtTHpBBnzlHGfsJQVATe7D9rwVqC36pXbweELxd4ydvQG+Q/FYIAK+C9ysmWKxJkbm+MGX0l72Jz+yoXxj87mXCYK0dE2ktATaWd8lOLFhjvjrlJsXC3/A3VDd/UEvm3ofMZGlnHVusiSMBLQ5BvIthBoB7WPIZE3vte3l6HUQqudol/N0zDElMRa8tbbN2J2hw2fiqVW3Fhh6PkgGvEDsXWdrJJI7Szv1/N7/Wz6ErwG2pW9AV2dYJI1gBXsfBbQRk886gRNos22fpFJkjl6+yXo/gEhtKQD3kQ1F5Y/rQn6GKRwNS3mt9evdrF+btmF15IETYXd9Ly34ZjPwKcli1gt3kHY1iaZCZzs7JNh2RzMhOXPBWwIR00yd8iCJEpWshqH///ZAUfaoy2gfFAW+2vpeMDpf/iTOTw92SAh3WTKrPp+ZfgYh6TFqYmN5JmTmma/oiFbZK0IxbFv97clv8rydShcsTofxse6s/o19U05TekQE2ngkNyVUqoz4KaFwwg1reBuDmmpW5kZwF5UR+aUTqozrGs5VAZ+FzNLsLsoepfHt0hkU9h47qmAxIqLk2h+jWI1ypysJ4XQ6l4rNJfh3NTcKGKv1Sz92PPfHYeUBN2Laamuqc+bDj3OLVpjhry/hKPNUXWbj6e2yy9VaHTpBvTzM4JwEywMxkvNOyEXwXSqy8KnGmqd/1CGpYvc+lIUWhU+fredSoI5uFQIJsagsPOH3TfcE2c4/X0sTK3Gp2vyVIy/7UbPJO8WshoN7mDuAI9L4ZI4LOx6qT6+7rj4ANUTAbBl+597ae192f5OCEtV8ZOE5rO9ntOWiaQzIX8YXndWbf5MEI6TW+pYzjVbAe43h+NVFBrbqIk6zIwtbXkIC4dtw9PRheJx6uhcdmV1qoVHWs/gQeE+E3cX133QYGs/PMZ9Yq3d1Eivx3Z1jQnxa+rUE65EpBY/Wjl4ras0YUTf0Wfr04BC56RE50R6qbQwW3eaq2Aa1wQts3b+4OXMtMg1cR0Dj9ffu+z/fuTW99KGxeHqHIJVjXisw7bfC+FSLT4RFl1PrlpboFHJ1JHPq5Swaz9iF9BPWsgNVI9zfFc+DpAPjOjMh4Uqayn/gqTrhN//FNWK5IZN19L9geyfYJGDkVBjiH91uj20nZCSk1hAu229liZ+V9/QvAGhAjHjoZfmA2NVoC5WB4HMVnUT5/2DQk53r1nRr6oCj3sbDXoyAuqxhs27BFaVF2mwfT/F8cfJplm3tIdSEiFttDllx3777SW1DrB83SEohjaaB0w355oxVrAwsGfDLQLP7BpoErB6wQ7imapurEEBTT0fWR0oGaW1UtPAoDjxBIPmOBzi5P1051Q6KwkGxypEqUb8l11HRe6/LenmgocmU8e7bzbQOng6u6DpCTMzWE+VLYeprSe8bOO6MosKAht5XuOqAUJnKAQytcWsIbffZOiovyWkg+Y61z1LAmhZNBn9ZyWX5lOhawGTX/mKJdSBYREIweAX3gjX2mjE6fY+SNpkh184LIuO6cxjMZz7VBuj8zXiAMp6GoFDPAmt3mvUUd3fhex2PXaUYx9KAIs5lxSSMZ/CuaVrH+f/W7WlBT79DFKAbZIkbyNrmTcIblgnpLT70S+5y75MkyuBcF/YMer+H0xtww81bpTLQVnoQZEILxAMJ5WIkhkU32jGXVc7uTevmGt0MjkmsouBUqbfoWL5sxvj2G+2NNoLAi6nwM16qyp9uOBazIhuXgPHZjjIoIhrKVsYI1xTLuJnEvrw4mXqveQC0jAxYFg1qLbtY+3yvPCacbjOnQCl5pXw7L3JGLSUl+GsB3wGENrNedlOsiQq3ioBAkA1/dtMxSQN+4C9R/IzFkXppXwaRtBMDlh5th0ZUfPjwK8SQtoLytyXs2x/gyvqt67/fFXbuFHENfPeI6ZGUe3LLMEICs1uXXRD6Ksr7f9pKE1qd8MogGa25HGXFaHGYNqNoGEVm5WinExMzjHq+TLcBScugSOUo87JeK5sCa4RrGJlD38zq7mznAgDHhT654eaK9u4IY/G64XbdPdeaGwuW9sLznvx0b50sQ9JRPi+K3/gsebrM66lR57r/+F8QQeJVmv/NgOjmFSQ0EI+6ZiXLyJz054Xb7Rw3SS6Tv3VW7yHTYngTdNw2zhkVpbWSqwVNQdz6Vh6YiK55SF5jWQn7hKUnZjcKLYlNh32FLhxND/bwvptLx5QOT+qu/2sL7dp9kNcFS4IDG1Unwe9Sn8w9VT9K8XgHXezayAXkRfOUJDoAWsZYvv/lEJ9S54D/g09XzqhNFgxHzK7dTosY5DqnsALuG0PMAgA41eeTwMHadhymWO8kAtqkGWnnWrKzLEPMJjEcpGtMORYOSD34+/gkL+q4ENlQRIAaONZF5B5eZYj89xZsm0vIKZN7vemcsbG4f5+0IBROFaYq455LqMHFN4vxOlPmJY/MtWOMzRlx5Td91BMV2uXYBk3xBNCjXB1q+2SVO/ljsk+e52nPLRU3Hla2tKuZTP9ClxP+XxkaMF0VsJ3sJBI7gUwzjvzcCx6rwyqMW7I4yFy5+/WXcziDn70uZ4LyRY+BtzeJgRAd/WHFFX5AV+0kSvmEPKJPEU9jye8wIu6eObjz4pufDiw4STDt1S8bw4b55sNazMQlenKJGV3gQcjy33P2UfcNbagHg4h+wnyn4iC1wFDvjd17BGi8z6qRV0IVxiTXo/gofOOJI9WiVZ3L69c/YEIIrLDxL3EBMI9L6ZKMDcDJGtErZYF12tgY/jKoQV9tgi7H20A/yV7/ziS+e6yOJdrmLY/JzyNvalybypjczhqx7NOUw6TFKTOPma1QkVaL4op5jwK4TsagyE+Ei0u/RfyUuDJoj3YjvtSzTC/uKwothjwtDy6UnPzOQNIFu+zxqSF7AGedZ5FpzaWWEJYwOreO43+VptGB515h4s78n8wcxXB2AwxOs/AiSvakI3lhTTRxvBZZvNStuWODz5dk//H413hFkr3zFRYIyxOKPrqAUEhPmVB0YU3mKVVVzwN8JiKyX8oM4dvPUfGmZ6EKa7SDYSZq+/ovEgQg043hzjkpbewJunmm7annwuA+F3zQIe85/Git1B8Y8kxRnN6AxCVRkTbc663gjx4KhxMaT5/fqoM9A1xyNSrhlUPetaqn3ZIoy4EZ5DDcnNzjFvf+Jdjjtq8Pz+CrfL2MvOqdPYQq/ALtwMi+62geBLUE9DzNIcgyknqd2q5Yr86NhmYXwZYQQ8fDiicoCBHNLi4CxelsNvVedvS4ykzbyf10BjgDZucTHFpVzU50Cwo/axUA8j2zs/QgWiigXc/o1T/bqM+yGjGNGItS680vLjHxW74yeizPyjJZC7RYMmPsJ7J1Y0WHQIQgL/y/U43jiu6kvZEBTAsaEw5TANWv7roQQ5Kqf5LZ0TDxhMWU4BJSAe+qlpSH5+NRQLCPfwa/wI2zuYfbukNPeAkitA6Lj8oddcL0jwsCqanNTGRT+1OcfiUv51J5lD3fBsFdWPvtLOzufCwWkBTc5tzRv9dF6Qt8Qv59U2AnPLVbTRkBoOaTahVKojXrP8bIU8BV1ZLWWnOXpnHyaPemPwRw9d26bOj3c6d+XAOxX5cCZjBgzAskMK3Nc4P0nSQw02zVT+mPqy9ht8zORu466T0SU/ryaQU0eoDvdXgB7gX4n0YINy3Smmhv1Cpz/iwOsRfHjSeIQtosajvBCSgC8tv0KsV/1zhSgtHJQmCw6Zc9X/UqgIMxAq0OBC+1+DS7JqP0UrszXx+G2NXGTYuEpH0PF2M82/2HmpL8c4nbzSvcsgHpL/xsgJJYuPeIlQAlZbtBcC/cmg/OnW62cYt+URs1q92hHnnoWJAvFcLJSs/SWHuYBe6LjLgEamT7kcoG6KV/nffePGNDpU/rOmGWH1Di41b1DXreYs+RrY8g9KL8tjjJZ8QFaKVdQIhTs/iSQfkPovo6hZVisjEJhbtwiH4Fn1MbgzT7hRvb7Ot9plC/JX83wlyfKXvid1xwubz9upKBPZWRbp4wLQ1gTKDS5U0rorE6CMudmEbE5JQtJIEiVONxpUNn7CK+c6HpL9GeITWn+KX2QI5U1nr9qa7zpwb9kyFINHioqiRIhOhwLnFrNFoPjlE5lUcH4lQN8UekoqZ8qS4Iae3rkkUjEo3MkpeqytMKs00fMwhAKS7QZLmNm6mp3M951tbNGkl14HsxXbxTl1MX17wj+FAPk0Vpob2ctSAAkBSCkS+/IOqs1Aggp40LbRw3tdhbb5UMEjRngaQ9rsZvpDHqdygCTYlnWiOOis0kadr2XRBYbsuO5m8J41B3dANXsD8vTgfotMlR/o0cn1nPpvYWhvRvuyQPfZ9Bf4jSatQv7vakImiaNdIUYBCZ0x6ZxXUsi+buY/ALDyBawupJEEsGeTk5hWAKE9e5vCQ4locF6O1INo3Qk5tWKvHCptZRx80UT+8OEROS36wdr9lhfvq7MnmPrdxky5T4nt1usO5NicUJUmVk+gdi8Ge+7RmDLrkGyqiymsKRKgzjYoudH5/IpdlIqUJcPvaNb4jygg1XBv4pAixmwvPriNXwW/xkwekJG9R2W5Jszw2SSQXB2fK3OZvtSVpl1rfnvnmSnv/J4Ifw+gprs97DR2g4GN1Jrhn+jReE+7cLPyraoDtLPwIlT12YVTk/T29thE8dOIEdVxFrMown5U+jgmMWmzgNVjdYymNzsZGFgxBgqgs6iYi23JDANkgSaIIBdTy6Uqfwpjv3yJdMCeYGq4lKXag5dreomP0/yFU6u8obcFeuXdSwi1OnytT/bxvQQj6kF/8++/DH/Uam+VCLf1scJkIyebDbiLLczphHUTW7SZRwp7K/2gZdEEsJ3n8m8wy5wAeeex1dE5/SnIiqys2MZNFNnGZ9AJyhNBOxPppq/OFBw4PpEN1PDSOa7rGpn10yFyVgaYTK6NcE86pcaWLzAjGtiKmMzroc5M8BGbeXPZvIz+vdQjW7/cLD5ohVbcsrs+ARDep1ftxq8Br7Hjt42F9X/Sy87B+4iK+HVX2Xv1q5PK5N05M2Zxt0l8Dqy/gYpA67i3WH55+7EE6jdd7Qlb1KNpCr9hECuc4wiHjWvcgo6q4rrRUkIcQVa4BGShmNbLbD1p3VRF8Ou8K5/km8k2HVDlVFroqzwFc+Y+dY7F3FKBoaMZ2UYf/RytXe6xzwKb8p1Sc28Z+x0Ax4/AxJ2Pj/csHu6jxKrEcU9Ttwax15lS7a/KoaqqH7lJUDqDOxfrHytBq8tYsw5Ma0MaI8wlOl1KJjO6cSQePGb368MaFNHY+ZOlRRjvFBhTbn1qw1N1WghB745y/xvwEIor/GBV/XuIb7MkyWDvcZf3dT2xi4tl8vwLvepvMeEhssgzz7rrH6MjbmxqOCyb2lqy+tSHzMOb/E6s30LEJ33ZnnMC5jliNh5R9blHNz3TuqIqR7MiDBokrrq2/yNnadOZdgTCgOlzjCgkE2RC/PWrZ5YQpjZhAvpsT+fYPcCEuHWiVoUs/A1gdDWZ3RugJqjkosntLzuQo9wHsEk4eFc44ic1x9GwGXbYz75FOAHGsucbqidXMCM3UXybNFPFjqbWbZ6Qpd4J6euGbgmtjMGTro+8DxF0A8neYrXW+A1Wb7kaMLCnyjQLGCGDvUCgW+IMknVQcVr/PoF/PVvZeJ7OKyNLWh8NOn54vA12I68tmf1mlsNNREjPXihvaW5dwKxZRDAMP4k2ADPDZZcLTh7v6c4PqYSHNGVbx9xw5/xVYObnmP1d7/5VZ/p868fNvfcpxK1E4ILkBj6XFHSedCB0I7JJnoqD1wS06ugV+cKJZPbgkqYcVMaSJc3xJw6fdtrY/raGUCgNLuI5IpTMRx0vnxQhWQlOTTB+h4d8r7de4f2nwb1LBrYK6Jfaeg+SF2KtS9YpDNPrmmSMY5sYQyjdh5KwFKjd0AnsQoVfkLEd9FJxqijrSXhEXyJzeP1fXSxUQY3Nj7Pfr/FwArl2oJ7Oth799rtDfICrsT+P/1ByS0UcdUXm9/h/SV3cO0Spuez6ZimLE7jZoeg5M4CeciC8+ev46xXy2tSWHeyG2h7K+/xp8pQKF1V77ztNTWETunhMjD53HscG8xJe3Z44O4W+Ca+Ba5fyH5UVstkZfZYzW26SHVatfF9X99kr+jLDggobf1spjMjKj42T68HVYw2nv7cQLk1R/RWFPSiwjX/JgUZXqut/oHwTEI0Ae3lvPiA7Cc1/mgSmaprXx8NWDR15aYCyA0GVgX6ygqvE8NUgT6a2N+NaIyLUEK1JNYkbA/tCRkHvEKZRIGSc1FjW8Kc3gIp4P5MOELzeRRTQ/qDuV0C858CZeA0m9uzsQWKzIqlJoiq7nkgRa+WGaWKzbkBllX/B2x/g7HwWEsWe09L62XPfwqk7YlKRuyaDfyMCVj97Z84x/UUQiw4s+GLWfP63xwCOab0q0TOpSazDAi9VcAdBFSmWuFB00JQKXhyAJY+xyJjPyKe5hMF23KT/qrX+KZElxD0Axj0oqxIOx+WHUi546LMGcJ4jsbVSmgxDdP691T4kMFCzlh+LMux6smNSQZptywEniOVM89zp1uJPnLvayVNPVK/5BjCc5NBVRW4r9yQh3P+V4f+S1TsM4lJ9U1nVpWbe4Af4+xR8fWh+3xqBGH4sqtudUROFc2iJItzRow+AdTQsmi/J/GTuUcaLBlhqJas7MNkf8L6PYHSYtYnaBTzae3so6KYMtTvXrL3UN3AG81SKo+qZlhvX9Rty0M1K1YFVyTUsaDUpBYFqoseunuu7VbekhGtlplIWGbVV/LO1ybETcBPPVbIHfx0DAhawikg3cyjcFbnqI+B99Fl3iNYQmTAjuB+W3+yeXoTA8bxv4mjd9aCoUmJ++eA5rKRNYdDraU14N/5jRlfufYvMBD8foK/dUPoP1kJnBt9iiEbml2YXYG4rdDzCkHb+uirvFsbk83/RkZrGJ5gLqIOVapXOrdRjA+0rr8jBYAhTcpDH0gGXOyCy6gpMofWOUeSCZ9JDGmAcm35bSe+bK2BtpPOpH8vqAJqIzA8bufeoY5vp4tArFQLuVFwP7yDdfUDrneAV8wXkQGXmQVYUa/qs8eSNMRbqsDuJxkM9XKKmBinYA3xT4s9cWY/Us20rO8qmx4Q4SArqsQvQuInvTZFngkefqsK+sv66GFG//FRiVh0LBfPXPyjRPxg+p/0ZSvM9xi1QjKHMvTvCOZJPYq2LlOly3J6u+WxvylUkeliiv2T1YPMevGrfkm35ccAkBdWYgeIbEed6Bc2vJ4HOuFrij097QaaP7pqGQ42o0Jn4ZMMei0bDL2C1AecvLzMCaniBOQtEyfu9IfyfZ1FemqD7vf1fuRe0dGnYsGEvPeTUtV61zcmPvPgq00pcKoRp2eWB4tI85+sccMzvmL5cIxnQcl6ThZy5L0e98Zh0BnkkL/wTPxtyJN4MzQvyG+b4dITVMTVXaashBntWAcO+Ozj+6ckpP81QEn7T7i2V6B6j5W9OlFh7lio/5smcKh4LBfS6LbZlkJhTY70MHgCzEfhKhN4gS/6DknL3/7XTYFI2+TB7PzwGHZVXnsKvlGmP7Iwq/brxI+fw4YjRJcGaG2BxVZRs25lMNOZMcruNguG8rZazNOp5O7b7w5iFuAbaRdYuDpEelQfiLEamefG7xrjwdU+QKBHEm1lJHCpihU2hRRnavYG5QE/2CjCrVzeYE5fnAbk6o3clZYn3X1V/u9MkwIjRPkngR4rE/i6m8SZRmy/hpY2aaxbK1O5s6tnhnjmhN4f0vJu+irUY1dRfK5vPeymLzds7Bmbmq8Ch6xtgozMRBxpvg3UHTCdLObCXAbGKKcViZWNCLk0AwMtkeIFNzyKgJJQPjQ++vQCjXGNklIjAIVb0oAw+4Rwa6x7ppsR5s4jRMowXZcjER/OUH/RSRJqGMqQUVbo5GfOQcLl8fmQcqB+2zXsT+fPm7UXAhEkbfbgWnVil2znj5K8wQlRbJnVYGaIhdn9bj9weMahWFdqg1YjiY76wJVvlUF9T2TdCYOCsOonLdBZFgQvYqsMMZcu5TuffiJ4YHfLf92MOhC9cvDAZk6KyhH+IirsYJ2MppLyfMZCE805r9uunjhs7dxp6dFVZLtbrONXRE4IegIxAWfL91H5y94uR6B0agt4EW5Z5ht04jp2jLm0GFw1UCmIEaEdAqMmyZFk/APUUHD2hSNHqF3ymasAwo0WxPgH3F5IIhRAhJ8+o3U9TxKqxKbWXOJ39BQc086YFzdoyc1GPPxXOyv3codNreKQHFExY8jhCOE4T6vwL1gEl5ei/BL0SyPn0f4BfnqD7e7KLJuOCYnzdkSqU1DuOCzLHPG/TLBxPywwXTHinkjzvEB0g8w/1ycW8gOyEhKezz7abfIVncrf6P8YxKP3hIvF4rr1h68RwpRBXpHWGhf7W210XTkjoqumzZuqz8v3gGxo/pBhW5KDXXcbCzQDW94SoEq/AZcEWQUabpRhNnu+076lHae5hZZ/29frX/9fLmYS2MUb0t89NXLq+l6QxI1jtdRI1iz7w4FtNUm4MiiNDSVXPbghbh09mBdLtmsPdhLDICUml8/lzMpkRdXkyYPLOjYLp1x66vnD//5uVUee2N5/lFucLh1rFrj43zJm4K6oSNuqAVb9WBHQozbrh+w/ecAxTUZcyEegbuBOHOdNlV9R21OGY/ZAvaYmrMBXnWrzpUDTpm59ZI8pcQdurwkXp8GQCqIJc9SvXmu09gMLJOsddtQnpxGTdbkyCAWE9BewyVsAU4Q/yjJuK3bjRG/YF5YP67oGUKBk9r/kTbxaK0iftADxt7sCpxN3MrkxJkkcR64II0sjbKft8pj5fj27WCOdZc4nE6LzUNOFkmzaHOKg+PvMaq7KiTmz1irafWUWRPmvdSKA3LdQ+6pAtBiGGKSje6wX6Tw7WTrm4q9Xy4F+rNg+b4nNFHQccGT6xdbrFtx5o1680C0Isk6cCphEZQw0jPEjw+OLDrvk5JGUm2dCtV5Ew3btZioyGGe7H9D87pGTQ8agb5JE7dIXXEcy6m6Kaw8wruOPTW2I6zSYQ8NWq03iY2OoktpFv73W4oVNSen2AQ3A/Ea1KrN9mqeNwxe08qkNp2qoU5tpdDopgC5f6hMRgh6kh/zRcCMZOoQe1cUwtRk3Y+lyHIhP96lOgfPmAOaihCQx2vP8PZSzTxM+bjWt6pvr6wnwyAr/9Z+ekd3HPVEbm/NJhd1sVUq2j2pmHrFVCpZCyLnGIFUb3vPYqzKIOJjWmvpmTsuw8WSGNDMiVyBMocC8LU6fAWku1gAPVGEZ5FagsShhoHZCCOp2cqW0uaHgWk9QbFljrcg+hYq7bHAkf+H+5bj0XJoYxAd/rDN1miO7USSD+/Y/BUjZ4Gfx+iQVJputRQMZQfTYA+q4LGHG971WcQkRuUuaNPtjnkTwcj0WwHZhRMk7UeTWnupuJOie8Thl4FsTp8WJbPnKGTC7srVA3fx3feUwXBxwC021tYKIfUmJKSm/S3SIbaBNFAO/C+PHT7lHOjjBkjMOD69h7UFqkAEUmQNWWJMLO6XSM0rHd5n/OQ9cbPCUtdpvE5REUKdLmbsFsSRNpTWshSRqk1qkMKeibK6SDW0xUfr3EMqLa7vgTS39IBREfxHsix4Okvzg99w3M0rtnEmZX6ghShk9jL68OXZBNodz6xnjxRVICLli659t+Owet8FvYejdU143GHp8vt/H5Nq9Zx8LaQc9yXncQkKycQRwQAqpZP08fsLPxhw+1v8/qH0cGuEaD7yOj55FfYgJfeEWRV9GOHoYChS2xGruexkRrHNs3uo/JundJXwYSEycS5Tpkc4+8Gd8pNngLPKJWJDvyhnl4zg0U6O76dIKP7WfMExyiU3bEWi5aqLPa2XCrw0yaFqFkSOPF+mXdPL5QOdAUg7gwsETdyJl3gEVT0hviNfrd9AnAzhRnUzSgQwkAbo2Uchkh6JcmWzya91XJMAak6izgx/9WxkDnsB0gA5cZUrt+g/p8cyAYi901qTGimgnyrqsYbQFIGLX+RWpSEyVa26A7lI2flC0HvBfmF5CYj0QIP+tH8awSlTq3/sx2Hu8fLIaqr2hHUMaeTt6guXGy2B414XYe2iVG8LUSAoFub3vUXuxCw3njC4gFIE5/lg+ydm+LL4uo5hjAQcNbptbep9fR9szvqy1QTC9ZCzFfomrDI22v3aC+oE/wELAcjmCnAPpdIJQ/Q/bQcmDQDvNTnt1wn4A7bYoYJgImfHHRYu1PDFRjGgKW3dQGO1uE7dHKjplouxzvqrXDi+8ER9FKE4xcLisE7orX5culKPxkmf4vLLNBA+Hh19TeDA8EVnnEJ73LT9ERN76Avn+SAFHB4ZaDq6qCeaQUaMlkT5EGzqY9x12wEf5R2DBIvEEZRsirklohexdmHBcfnLq/lkTNQqybmMojr38Sw80Zmx+5htVKa9ydzM8U3oX34XIyEiH9LJbYeStEO5/RPKGWbPrTd/NcYTEaKIbznCjeXbkEEqbCUSGSr9WXfef0OC48wnq8yClVAVIRTtqD7nKDyONTT27tA26nQt/GtUPKBqrQQ24zn8VNPVXr/bLznqoQMczpnLG7Aw95rR1j8SMeRThN+QK/XfUYqduiwgVdXBBabN9DKTikYY+ovXy/AYX1fV+sJYgqivgkkOY/p0ySy51DmpQ4884h1dgxJ67Ocicll77KyaWSjoiF/cKKH63aCHg0hlPdBZ9vyef8VQ2WO4oNIjW62rmILkGhUSlYhsE1GJLot5dcOZBPiBmA2BPwT5TksXgK+XmY+Dagy+N3XiiQRHuSuO4uvm5F9SYyek82iMTZ8esyF9GnToDAdjVAY85GZdOXwzY6N1z7B97w5GKDl56cTVHD7WW84rrlJx9r76JT7PoPVCupihn9EJMdzHlhDy8QOgisrZaSTGI4c+jvNiNFTorIlr2IfWSKQNb085Reqah7r6Uit1hQU9mpBljdNd/zczwo71cKsXgZRZXpyVFA8tDwQhGbjsqduv4NR5A3ph0l5p2Xt6eURWOnwUUwTN/aURP2aFKmiz4un8w8JxvgdIIykc9+j2HfYpaZLlmlTtOZPjA1/OyWwytEfHVT3EeOLEiFTv+BtfnCvPZIegz34Z+XwN8Ub6iJVQeifS1BNyNC3f4gkS7V/+JzQ6ac53+Mr5qKBpV6OHIcS/ZXD/58GDlN9GCBiOTTlaKwgAvUZ2yBn0W/A0KoxPvegab9R0wkKQVfDdyFl1on0qXdT/63na2CGC6VQJZ9aS6rzW52MCD6FZwS3vrQI27RpcQOv1q8VgRYMLcu1iJy7JWZALaLEJqUYPYMQmr/06XUkUMgnNiaUPN5+bpeAHYaiR9dbK9HpbSClp+oG6SBfldx9bwOkT7XpBe0ktSuFkQJTr8rZnPxqBxjSL79a6G7YE/gkq6vlRRQbhIiBrUyQfDLJS4aQTT79Q6sbGJvx9XKEAzr4j9Hj3Yx4JEPMdfUJqb2LuNV9ekCnm/Lt9tP4BDbIVLLF2Y/YfmVr1bv+89k9hRBauOB27nMeHmhndY6HqTpafWFu0KXiZdNzWM4n6iiP3e2Vi5SLO4CGEJs4vYo1oiPrm3XTN97u8TpXA8C+c+vqnt6K+4CWPihhqe6SDQH9cAAa8ihYYsP0fcIqrEJALFLm5XrWRqbiRqH9zKyShUdfJHY4PanjJ2gwsng/O504KpSS+cdYnkvw9LNrefdZfPqm/4RhwAapmOJkqhfP2M816TypTp4rV5G0m29fPVaocFdg30MJYEyqbg3skyGXiDNlDjHbEG4hqjyvb4q+8cgeOe046wtHjGSaJatNoa7lUOyP++RDXf0R4hapO2FO7kfEnx9+6AvJFEDXl8wJ9itfRt8mGZXf9s+HBveZQ2IlzmYPbeapk9eq20IpBFRD6gSMzxQgk1h8UU5vmEjgFc9iCkQn1yqhoig44Kz+u0o7rby07U2Us9GcJxMOBrz1wA+XEamBhj75kFfQ79R/mrFERb9n//AjGo5g6kEQBi0VTZid4L7XuFw9vwB5Tq0ZTN+9YwFX80POwPW7YZcvNEuyHN0hq0oy8dhSYqshh4Ft3z3LmdlwwG1z3ShZHiiaH7LVUBtB1uHZleEarp5o2wzZBF1saRT/fhIX2badLHGCrJncU4t7lC61NBkFPUfHi8fjhIJ/+c8jIXdU6bXZFtOiWD+U70Y+mdJOyteb8JGsts72G301TOyjkSGEqUnz7Kh1Quet6kZrH+VZUuK7/YOtSJqgaJ/FKsOQZOi4BdS2LjCKPDYozMYwTp8KkYximQQf/L6hNEBVNZgObcTBFqqQouEvf8LiMiqytBwjljPYw6pM+fgfDGE6a/mT3xyCPcbtlhrfH0fBBiz/I8CU6o1frRp5Izv3Fr//kzuNUuqKjRn/JQfWDFR+yjV58je5NTNOGm7o1eIPVFDH8DyWyRD3376OUlqHt3p8wmY2lakp7tgq8K/05TN2FrKLIhSIdGAxj7pQ0pMLMY6oztWSl6XmE5akkcKcsr5kGV/POxQmv1N3Nxwa853Pm8ITmqF13SvVgQA/isn0f96WVAb4ITV40hQXKemgVC+PYFZSWZ+D4RpBklG0q8kt/CScxLiO389dvuB+vJ8yzcNXbCfqTFghZ6wuFhZJFSs7Mzzp7XbRckXnsa+35VpM4J1IF8dxJcq0MSx4S8FF9rh1jSDhgZZd6/bQI8iKDYoKAecATn41wDI6ydbgKiPxiCoJx+xn2yp0vy/i6Ircq7vI/Zsh7MIITQi14D5H7B5AeKv9f3xFBUCRocsZlEA3quF8u/zVNoH/kRLd758zlwQoPnXqZKNRMGdJZlbA4ZevWeJucPzG6n1uiYf1I1Ws48OeH1Blowf7mQJuX7tlpnChrSB7lpGlcoyBvQ5vIYy4mGIsdTWQ8lo5nJuds2l+0CDGH2ZcWUkFBbvDxGqnIyIOWpP2N42JK3hndC3V79TxHgmkxJuyD8Wl/vcQaQgdCI+w+Dc1X+mazKeB0iFZcXyGcTP2ioY5j+htdcT7zILKqadWXEbobrbyHTKZ2TDaMgTnHcZmy9n93PNTqM+06Qjm55BCqovppKy+bfmFdERSofrvG27w577+8pFhIbWNEMLg6h4w1OnlcBJo/orFKD62s/xyXEymC1QRLNxgMpdLBNTPsbYJYxU/HCkDVzMctIgjQd09xPZEtQYXhFFy1IO9XWK4pExTSar9i89eT8XEsObaQkkHjswDIhjxP+UhovJBFuOc+SoqhlB42Ky/PtsHqnqMngI1QX+7/ZnrheMRfMn6OsgpuXqYCxApyHiVwB5+zEtE9/C8L7wj8Za73lKR7GIpAVxdc8YebyX6+mF/EcKRSBieHfuIRlap1GOAGgJmOTQi2OCV+1T09Oqluhi3Bu4ek+4117WCCXMMyjm7Q+kE1NwtpPt4j+tXWqvYOeTYqx7cg6kUZlNXvTjlYcp1ZUtCeJ0874uFqq/rZDOnzjw6C02e1xk5Cex2estFsT/E44mWXXCyKJzCgG6tjs55MkPixLTCmKLBd3W51VH1xMnCNLxIKegv7BadkHVdFEoUeKY9xNRPQ1Li1nWwOc6j8sKB71f1KADhOWHQAt9YQrHEQOYiQLd9Ueu8gLZujzVIPqWzSX43ZR1euB/1fnpp6D330JnY77oatpmsQi53XmXzISIhG34sZxDpssOXWrTAUJyPKVQNExoEuzO1/gtoGspKWBKQ67UMdnZr1zNHdcOUp/D8Qa0fXRvKbFJZSX2lWxvSmu/z84aOgdc4PyAu6KhFRjGjuGwbFymdWHMC55dx2Z/2y0eBJGRiNIVuwaYwUxErGsbePVCH8mQz74f5xC3jfdPu7K3u9guSEhXJ3/fdDfmtCMtjrWbNYuNgP0f+5jPRydFcRsRoVw5pPRDe6hB/CcxsWIEPejbHGRQlhZNKc8689LbU0M17ZWtfnWZHw2gMfF2DPNiE1KjKOFVahldZih1PAFq9LC1y9dwXlECDIay1GgKGMmt/fglfwsMe7C9oM+W6RDV7BlIojm2N8ypEzQ/hsXSWj5BZeGajqGzkhrp4a9UcvtJV2IvmBiMEWPrDWJow/8cmujpyw8FMK3eg1OdOQ9ATMXH2Ak+9jWfOY4tkF0mUQqt1USCGO/sAMAA+/BkVQfqDsoBxhCuWEusEwQe6wJ125+xwKO1XRjAXc8Cw38LN60KEAQ4T3tn4yUeexX7GCV4G7s4XBeMLyF5V8NU88Kqb4MsDeDY4TK0MbcG5znSisq8i4oMxoUnu3+tvUpjWW5UyRUoHe+ufsBL5xZoyG2g+ToYl7d3yz0rcwZbEUObkEP7Em45eoZEs34vYXkqbAyK9ilKCSU4Jm/TlJOz6im21Dhk/EfE7tJ4Q31tFrF277N7cfDejOFTZ5uV8UrE+waDoloq4d3bkKITK+jxtWt1ixAmxlkoJN/GOOP6lGonQWrvi5ydF8Z4tBi0yHLANOhP9NAM5sS4w/hQz+2dgJCsFl9DoZPeFZpTR0gokcGadLxkhcmKnQJMyK6L/b5gJrILWz5de6Hm5uOIAMbjMw0le+buOLZrz0C9tJZqwbVfHPcA1dfzouC9cKj7TnMmtLfkRkVcRZhZ0fACc3NYZDNpYiPmCaj5RafFGvQCzrpoVReLB9LvpO9h4O50eg4LLOEtcTRrRsikMyZwldUOOcLr+T0fWbY8j8mrZBH4p4Pw9uaitH6Lraewl5DOMX/R8h+tymbE46dtJgmCrwDsTlmYLIns7i9m6Yz0gt0ApvcROQgIG4S/ct6SPOdh4LRgRg5ypqLDq1V7YkFVHnP3NFxjgoXydE82wMTO7eUWe/UvCK+oRfAqlsy0iioxM2LWMwVuokYw9W+GWQ3kRkEEOxWpE7QnD1XVuLAnb0ISJ9E7Muy8ArZW1sBGOI6v2kmPK6a/zYZzePsAymwRRRp4BzP9JXAuIVJITQ1Adnjqtj4w6i7TCVx+tz6BABp+eOX+ipXRuZ4F/IeLHV1aXiDPOpSNEg5kT46r+9uGw9GoQavAPcL0TMSF495F4Xv12l1fXE4SSrC7sjnxWWotLOrmPYQ9IC46+9UpiDOmd9CXZGDARx+8GH1tw+LS2oJXqi0Hy5B8CidvZ/mub0T/Qru1NpyccRK78RCs2dVCz6Ibj8irJukBK5W7FV9PAqSIeAFqjzKxQYW5/mDzKi87rPqCqG3EqXI/fp6vRsK1dR0ifewlQ6UDf7iz1Eb0s3kgyQyy5ibuhxhx0Fk+3uMbA2mXlelJg9ya88QG6qKwDWcJ4X0TWlw9aXsjK7rz6CN1ftWtGXHu7k5b2mERHt/UDha8B6ByHT4Z5n4tdl5WRNx9422B0ZYKhxJe/USj/rvpyScGj9DWZxU1nAkrwneGEDxp8UWoU35x6ee6I/IMo4omS5CK7cLmYi/vLhF0QBbVQmwkMhsaOFS8c0hOH73OnTptNEzewTUFhnwEREbCeuS9yX0nYBtG8qhz2Eslrs5ptdyzaRMZx0JVyP/0HCME/sd+Ykyzu0HNmzzqCSZVRMrjziMJU3xJVzObNwT8GSbNDIIReYd1/FOHm9l3/KOF3YM7Zr9BmENXDfb0WjqeQl+AcqOwhicwhsgnezrEk2rerWwUCUrIUdZ/02I8DCsyBxbrCTxkczM9zzrmETXKod6QdKQprDKHO347y7gCFubwe1cl7+hJVM9LHFrTguGEMBzCgN3PxvSyJdrpbdKqQI0jMWdDTdwrRJZBBfWKKSccG+oyD2ZTlMbKiIDY07mlc9+7QVk6xM0B0nHMHE3fylrRCVkA+qGdNlaHvT5EL6Y2lMN77uX/AY1nMw65s3N6oFOSXYyFKcNUHqBHygix9uVBdb1cIO8POx3r3eR/HM5dJYYsljCWCTbFl+DdxzVRoTHWCFqNpRUGuqx3bI9/cAIVgxgTQb1cG4U0eblWV5aq9NyhFo5ZlL3SqmHbNPytTRDFez/TKbQDpKnBMepFtGMqdrn1lP0dj2tRcmhhAt0DuvfcGSmPRmf8GaDtwgjQnEcWrvcZtb8j1fwrlOxPllqN8CMiy8YE6qQFHfe4imIiUqG9y0wneGQU+mxxK1eBsTdOOFIp0CcxqpMnw2t6tvY7rGcdGwX1JjpS/O7M7GVHUuoxsEGAviN+ns20zwdS8BUJMSCnLtp2Lky6QtihQVjrTKepZj3OknZglu8cff+MpAenOvINcKNenyiMIDPJ4amGX6fijU6Mr6nB/YBuK4FDs1HDizDFFE0NqqLxgDNCJy86WSw+os5Ym5IhRczxox8rk4CxkMMnm1Ql7vtYyNgH/yS0FDCvJPQue44Xe7hWPPBm2dx96a3qjwbTRoBarOozbudcbNXw0ifnQIhN+ePRPm2E6Br+LgthV/jRy2t1Ugg6ynSPAIOm570LefzEhFI9pgjPhf3S3bY5X4MCCxl5brrOcm1UFEPSDF7wL8kNR83kdIu6qv0+6TSnY5ic9ymA1e5+5Op71vLfqiJJnOCoXYZE0MKJx1qXqbUcTTXpCoOCY/NPSNT/83rYWodGDgoYP4WFjax4yP2kIqbKFt0frOE4hugm6ZFMV/r0N8UWVae8DRtuaLkvEpymVAR/HjYvBbEhGJWl26OHEZBXtiivIdlrZvQLOyItCpj+mN6aiQdd6RaNa/7z8Uh/fRMaTwgBc0+CSnFJxK9fJeJ2um/vLiPikrDzPvsXj9K85+4ZvNknTgk3Cn/Rg/d/Wx+WeSIf4ZatoNaXdmcBoVJdEHBUSKqLKzf0UBhZCpbGwB0laug7WJe86PFAPEkBZjAkT/A26kVSjRVu1R7hNbgxER/Y1PWKhZxHo+/fF+KrkY+2dllqLpG36ZiLOrZdWA7rVHzd0qlnlxvFbsmuIJSR/APCHOVzivYJJhInAFuIBLaasE7k4nnSvMftUuc9nDXo1euEsPRXI6G0Lw7Uowb6NHvuMZSs9Zfb8MjVCTGvNjiliS9YHiach1G4Zu4tSAJNAStkK+JsXsj3N9OuCtpJarCmeNMj0h+QY1Z9CJbSIIcnIiyA6R6s1gVuhTM4x6e2YphbdFlTxEE+8ZeqKy24Pix8xPauMrpqkyuuwp8VjT9mNKN+JTmtUGH27djIDJT9W0/72aMYmxuNyywcuqJvVPN29m75/BGT90NKMcNDXRKfAxv56hUmB9Q1ThCCf8OiTRWa+J4jd0PqDt52E81MuwPpYplZhBB2QeP0wD7g+vrRldUUNDUtBxc9tHqJ7XEd12eJNlEFLtm57JEOTyP17es7iBE91OaZEDboLlFmGM7BIKU9+6IVnUoEvjIj9DXgpCG7pNsV5iVonqS0rlTT/6QNTMobd8/qIEa/lnvobENzzYfLhKrdLqzKUSbkas4/tFUUKrqKV6kLM9Ea0T2DdzTgbjLMvKqx1XsEDRlqsy0h9sQDbJyzxbGR8TzZ5IWoxOLhw50JWEoCnhy8IE8xth+StZfhM/12ulLbls4JpbeWbjXRxQNub5UKQy8D9JeHy72AZfHbCD0zPxF3JymstREiFAKY7P10PV6ZudzoLShAwrlOknTJoP5al+kTkCM+UwN7ZvGVFown6kBlRLMS8A49vl/Fy/UOdeep1pqiEAuWJMT3QrpRgtlUM70ZCfyX0lxfE9EwGKM/Ypo3n3cKziCG+K2th89AR8NnZyyJVtuMkeIsLQ2v/xTXBmhywmySb+GnVGGSr8hqckSu6PZ0zk4QYB2BsDBhqSAbn/FCqeymW9+nScLEewXWGR/lcRExQDVtTiMLJBE/rStbxh2iQANXuPkupZf11p6IqFOw79x0j2RMSAWxW33uprJLDM/lvtcj56eJfM4rWLe4tAKvuP7yXPlutwaAq5eA1qwv+ebHfcodwhNflgnfpHQDRu4PAisJ0Yn88nXzeJUaJDY6am8QxZIoHLVjftvcSXNB3bR7bdkC1H4jSg88a2W2OR7ethpzFYQ/2wJS9/smQfh2QZfukgPm6i/AdSOpArMOPGmM8lByND/RwHsjXG6Bb9qNLNDL8FYyCg+5L836/MgTxrCv36YDVjz4HXEoxJghnzZIV3EIEQFWXD8IWejZGwjtidY+Y6MHxFN/9bM6Flk8SdlRBBsgZ4dw0h3Gf/7jaVFj2nsUWgIxIvLt9xEjR0TcAMcLI4Mhbkr8/QFEIiooXivfeIv/nho7sDKNkodlDWsp0ufKE7kion4LEmvkRGZ3WKGMGBAS1lb70T57kESLH43n+fdO1+aB+rs8U2zE5/cK33ICOsMYfR9Ggz2CJeSfPXW6+F7Ip5lHyF+nOCjw4ncU1BDmfK0FUhi1hON78LafZuT4wv6dhU06O0KP9LSg7GRKHr1tutUj9EeCH8ZbTcKzWz/cDd4wsEn0KZMMIZHDRz+g+hDBgzfz/pHBng1DfWa/BX80zb2L7ALJovKZRo9VQXAQ4OLsbcM7U5ygx6nmFdCUOCQc14rMUpSS9K6/YuEksUsTCC02LxJPbl1OwL1eiiEQUZIwbpq9EKiuvlUO/TUYCtpKj5xdYoFXxLYRMY17gqwYty8n/Xl3z9lTZnac5sgoz45KR8zXDEsUeJie2QOhs4ImTIkLR9GcZF7kHYrAs7CIQXroeUYKPev+K7muXyktWYEKa0pxELa62vgULOzfBjaWl0VskDasOQCuEPi1LgEDsxdH+hzcoRB5wxo5Nyig9zGbZ/TizuWvU/RNY6ZdRP6hOJ3XQjPJFFsh+PFV4bM0rcbhG7DTgcSACvQYY51zTbqBiBHdSc5iAbUGeiWcMOQ1w8hf8N9NpRFQ5Xsm5nInSb1WvOTxXEEpYQzys9f5GYzb3Td+oRSA+NdoBgLgZPYXDYC7zHeU3JymoobrhLxD+qvuw9UvO+gFboLXivLvtVsn2gz1aXzxZ7kYfEvXYzNjyYJt12cdJXCV3+82VMgo4cXg1PRF5qkj9sTTj9Xzq+yq3/92Qjoln2ZKM2ZoJmWTTpErJcPK4EMSA90arlG4c9xSo8EaH0J1L6cu0ZjpxLsbNAk5OwZVKLlbSp1NMpENFnEcnkwBfTFsUWjM8uXSrP2j+80Vjz5yROse+tU92EpCbQQcHrryebF2PuqFOsMm7RHx/k85ScPI+7HnlOX4TAdE5b9fSJt5nnm5/XWOh+WM7GcXTp90S/1DRGxTMiw1iQQryd7HrlP9UD+gmm/ZEHiyruMKGZGZBZKyoGgOv6u7WIoxQU/rK6NbReXR+fcQ4RrdL/CjK2jNgazqwwE5gWvTBDnrqTb/j4tfo/8PaAe9H3PlHZKvEgGJX+ZmVLgpY2wUdlKrwXcqTmQTCz49WUVns4cUIQ8Ez3IrH0Y6kUqALyNKL0/IKv+3vq8JR3dB4YL9A1IRnbHVMF6sVvBoEG4DRJSpfArur2fe9SpweuDf682Dsd81L0M7fvDpvd0EaR9zhbDBvIvlJOLl65giAqm8gA07tg1zl7xJM9kD5qoakKUA6NR5cqy7Tv5vJUNstd2lOABcMJm8Iya35F+WRp48bKRoYE2c2QdpQzOdFX3HP/ByFyUTjd4A1ReBTZsOCfeGsRD4q7SFTZ5OHK1YBMCfX7UnoUhKTqTq2ejFbEfwJ0ih2dLpcW0Y0WwJ5Qkt3nKB7Iq6rFkeKU27LBAYIA8qzcaChhMCxDITfpdEv930l4VBKF2N5ckWYy6Y78RxKaT16odOYdXQqcufHYk6iJAajKRfne/Qwi28h/IqpyIK7b5vVc9f07iDPrgsAf480uHo2Y4E43dzD1pPyqcmhBc0jP96AUbeNp+Ddy/vZUD0btySGzwjwF7bMtC46Ec9LKdbwc02miTjjYVaYf5/xgN6YE5VyrQLeY9Eoi/cB4ZPHq0PKU4qqDWqYRK29lfmRCfZPkKLndsSdiCVlBdWe7IV7azgA/E25mxr3v1IjDSorPGWgtkhP4Y5rX5g3SubeWhXrJYZ1TkiGWyFT1WspyoXEwUu6s982uuOCDzFMHOzX1XC4ODklBiVB85NI551RZ/WDNyGsBaRyCUgeeGRav13KpS+a7Eoo4c8VrYNVyfXhPoy//RU3vUiQBSgQeen1DpDMVkBEk96WtMsPtB1H5jDPoZ98nAyaevc+ety7QtZJP/KMaRne8U8+MLtTbyhKY/UY50AhFQAtRZMO8T8XipX41IiVRYSjV0slzqfSzDCfgL2GDn8wrv9eATDlvazTXUkFa0zY5e0AO2U76Se4bfX7nZAJsHVnrxp9oJpUUbtWKCFQ5a0pMOyMC5GBLdXfGC5nF+NNTHWJHE0AAriTQx9ARuMPqc5c+NkULtXmtYTQAACimju3UxGUv0G6avFfX5LtNhQrna+QmsJp26U9nTqgRlC7iPR+WN03NkV4KRlm/A60YjyBfEIfJcck5vrGttMgETr0GhqfazHG9N7m0qE4wdbgqN9aa+l7+S9VjnHAAd0WrjXVmpVp7sQ73nU4Bq1pSkjCUHcc0xD75oUyNMu7Y3EuFu1I17KZ7xD6XvVRrqx2CcnUdytIwFSB7YDsLUVIxUwz7HCyrTGeEm0GDOHydAm1NUjUhUGtL0Vdq8id/JSpywqv/5eTAocELrwJLkpM+Afu2UqT9/3+M/QUBPpHW44LesWWOA6fmiIvevWxWkXMSxFkbx3i6Oi87nPVmJ6sXUveEBr6t92crjyW851mgpcIpa9B3eZJP3OvRC1WNAbwY9ioYfLlUQ2cV1zX0o4cZyeYiQvjsmYHOP/7EUVeW43zqojftr6T+fVJ/6YMA2rxtiXl3CUWXFs4pVP9Vskf+mY5EEBKskgvtLoudyshCdwt5KcgBe5CwRbxxzr+aQ4SQyE/pwrj6vw/cqFIH/EZWxZRQ3Fs+lu07HZrM3CuiSFAXwyeK+jBjNkbW7ExmYGwsUlc4fiMAQfeEBsXc2Npcd4oR1aPOK+Zsx1jniN4oe4pLEJUMyg4RE6Pkov151Gix41R+yUwjHTyqm6Um8ejkfDS4DQpSzwSNLEy3T48RptVm49umTR4z3R61QSXUsDne0NJlTnGV3Oiyc4HJHxcKohwrOMaLWS+qR+ag495m1oGD+g+fIP+EH1M47AwJVMXQtFEMaIFpJn6ePJYQxGWaz8dMORuCGu/4saE4wPpkONnVJEp+9kjGi/UxearNRvhONsej7ZXBmBVlyUhtLgt+FEodwPHOFpS+ZD+Z8c/GrCZmQCKYTuMxxk6Bfvz339zLEHQWpFWi6mALc0CeAWrbqdhjDSlV4RIvPK+YKw5OmeOlhsJDx+EyIzzzT5t2pZZKNYu2vblxc4Himz4RlXVwnROifHIRdyX2WDCkUPdx7u8I3sx0HCazuVCiU28mw0eAgj+V3JA0Xe0M5anYZgFN8JbHxo2TrkW9azdExFdPXOUHxjGP1uJ26GYncEVGgTxSh8CiJAhvjCn5EyH8f4zH7T3fvMx9/BULOWCVToSSDF9syUtdC+ccXEubFEkiwubViD9sPjvW7D9POJQoxMFGhlmaN+rCeEPDtwbLTcuSdGGfax9TMBwMbnTBpYkFFFIH0V+MD25fS/QWwEz89bNuWss8mRkuhoOAQy3cay6r4jEUDrRxjKNIt330nA6knFlQrm3/b8ngCFiw181CFa2231b+XUwLiuhwvKn12CvM18SEXm+BhHN/6NVH1lXCP/y1geCX6SJ22YcAp6sfraIw5GgPVsiYHhOo1qwYOZp/6Yl4UlRa8TTi3luw8XM4iXohbkeSLakF0bZsMDuujFdg2lMJevx7Z0ZbktXgl8DOGPgrTC22zPVekLChStza0YGA2ebi1CaAIihdtjyuLgeNKbSc/CsfuuaVkC6wvWxn5lpzqoMlDHh4h85fdXyD8pQmSOpBma9YAdnFkG5ZLvr8V5oXNENTRUQVXmdMEiblPmeNCIqdP4lNvaMG5f2NCaV8AjgXbuka9iVHBITnFbzS4Sejii87pgir5fT99pTMoUwjmCpau2BPIf0P4xtQhThQjac9Rsf/kXY+FxW2V+bpHcelSDfKLIhNSb+kJGx+0IOLuMiCOb2gp6/kie5lGxjt1bCG5gdX+EQEGvEiVV/IGAmR+cty2Wo7h0HX31vTsLD7bx9BfCj2tFknast3lTNzwwBPlGaqC/vM1VSaAeDnbCUp7VBUfXvjxTf6Ud/ho+x41eqoycBJf+AANb8XOpu2e02zGxF8wTOepNnjNs77qomLbN1ngzdvSWrXYHsRcl4skmy6k9ohzJ+8EQMBsqFF1BRzTtyUYp9etfO7tASm3i2j6l8CpMnZEbfpAuakkzXw9Xq+db0MjQWZ1anITxDdDFHM8YkGOraL/Va3pRp2Km2HVuH9QboaF07fdRQ4BAIAax3+9XmJ2xYk8eP73zqlMX33QPGp/eZHYx09+GIAeso+UEOm38DVjPpTU8sh3LIaq496iTH7H29Bqis/zdGK17aKdIsm5qmd+U6AXsSnfh043kKj0NFlbm1NaXRTHR1+xq5UxBtuPOG1OB8gNxb1S7t4PiCxr0vs/ddBYR+kg0VqKFD+KLkdmCzXCzxDxx5l5F9aALaS1IMKDG37cQcKyX0eg55sD+aM1sgJPfYoGLE4ab5Iyt3Wj9YnR/MzOW9+ipvDc3GLB2LMOCvJ/Lza2ilyk417AHpzxk5v3XGDI4vTPADtothd83d+sPqicwNDHW7T8MoxiDAc6I6xiiGLLNkrCwbY72oRcm3D7Tln4h6yEiIfr5ve+2dA8YXZ/ixvmuTdPgTqnpHvwvfn2GJtOpe3upwwmOE3N1lsqokKK+zlLTYnwIzSh3DukNSOt/M73uSEC9TLE7MyIM0dr4CjxIjlItfpdUgmubdkkA9VS9FzckO3UdWmZa0/8CrteZHqJQ1FFVxPnVnNUySxREm7UFjTH9p08IBdj9Asn+6+XjyJQ62QWhmuCe7HNKS87l2cJ3MxizE1cA/W+3Mmboo8tUyYsEcospSCiRxwZXadzQ3uutR8zbgA2lcWCKLVTNwQ2LQ9x6YJWLfF4eSFx9zRG5UgutEYyBxZwGI/AgpLkjUReKZywLNGW4IOXVYU4kH0u8fZt8ZKTvr0ntzPBQ4z8NecVMkhutE9SmXB2Yu0vulgB+uV0Ba78vDmFsq2BQjl1Ue5xApluXwyfRr4qa7nzoRh4iWBVahfLTnb+4F2STpl80xj5GPYR960znCNVHVuRASclwe3VwXHQFr49vWQzV9/Y8gGKGTOd4y25IIT7mzLwIow4xT0iYgcP+IDLSE+TAv3IoBAQC6X4lfEI38QXpvW8QxbNmIe0rkFfD0qp6V9Zpf1bDc/revniDT7Kh2waqclvd9zfQcoOFuycT27SpSMjv8ow8MHWsSdLKP96QpEa7xEyOzeawDYaFG2ydM9zOuUY+R/EsDLD4rAOA04z+ZBNsvNXWW+1TQuhDQaXW+eh2mdWxlaZOZx472JAwj7uMac7SXidb4dh+r7Kcn61goDXo6MJt2aLyRQo+W0S6ArzjooqOwX6MJA07EM6oubKmJicEuoFwI6XNWGyr2ETkmIIVRRDER7Dew4NBlpF6894ITWlE+wxOXyDWZ90+aHNNGLwgIQYcjXp7liSC+xguKm2dLh835KT7eSntbbwXnI9gwQyW2TOjEOPIj1l2QZ898w/hN0gNis7KZ6bI0Vt37AWOKv/rz4Whgfv5B0XAPJdN332orFAAZEdIb382rsb2mevtphtuVWHjlt6HMmZIQRbLFptkJYwIOWJ4zpEMAZpGsZDULMg6Wmrl+WaowjH5mzJ1NNW3vJEKMX/iLoE1jmthE7Zht8W99VtotqfJZjLVyZmituVBoH/1xo5fFXj/BKp8/BGsUhFVWfT1cSOQtRq8Ounm9AsXeJOoL3mDuvaih6+bqE8/x9oal2K01eRklU3otSHi6cfGAJTXQFRVTMJcxAwNiHyDMmfgxhAYRCwJkwWzDukAuSFuH2/V+7T1N42m8MhzPOx92PtKs+ngFPo7RUhe7YwS8r7uA+2eb8vE84JGo1BYWOX/9G4bw6p68fvIee4IbFgiiJueNMlOlLo1aS4sMz0qg9VlJUx2aQJmzS6rlwy6PA9OduxeIqSBpfqJvDXcWnzzJRMcvzkSGWAXc1ww4Gye70dwVSY6fmoAcPcuH1KXat/zBDN1Rx3yHxy+e2r1QnHrsYe48gxxKqW8fHEauxOUavm8ZiAvHVx5mo5bY9IShiZLqjnAegXZ5Xm62lDJmvJPt+ijLxVgwpvZD1nldouAMi5jxtO5pwgRcdW0ghPlzDLVJOx7+sPAcWDbTEe5CTEBhPqd2/PI/UjR0Sf1a8fsxpkK4P4bPsmKsiCppO5DlQWP+j0kCS6l2m5nGgTtQL+hVEVAqvAjGo6xBeDq9QwOJkb38ptuy2oZcWWEt+UQV2bPUg1VRJJKP/nm5tl8zJB/8dkVe8X7P3P78Vl9ARXER/InUyqsFAecAgdcsMWB2DTt/RpdpHchHk1mH5rWmYImmUE3iNbigd9pUNZFVFEKVnt/e/Q7Xqu+aqyWS8dsa3npURPEB7FfjK/aM/KnYFkgEZLKRomi442XEtmZnvUke15YNu8CtZx07r0F8DJTn1rn/lbv9CtxSI/4SvYeKrVTG9ncTR1FYGsAA9B1CxWM+KXI5VzbFRIvDJRwXqsB7+8O4WPX+Paq+dpaMFibFWCITGXlh5Tz+nIAQ+AnY5Os8aWjcWXTbSiDzwZh6DqlMhexZ/bW0ds4E57Vt8eGzM6P1Qb0/MSfrdi3q/4EpaANt+7SezjKuJb9NQq6+WOTJQegISXQ3zZ3ighEh4BVSwUDXCLboXM9IkxY324UI4rHL6Knmqk75HTSkR5Jx5AbGtcSOyqKaj59L3UQ1vCT8GtQGfdJJIbAisbjClEfTGwWQhth90oF0eyZKufOHzQkCztihYUoG7FOQk0trhgFQTCEuoN6QFIJphV1NQ1QU7A64oIqORzR1agVLaON/X6L3tN1CscSR1xY7+CtcNYaInw/9TMzwuZecvZayXQ+uAYMVFnOFdwMGVt+cvLDoAIuurrlUoZxcoXN9wkQAxlAmNEzQJcf85IQl8g+yjhHN/qLgH/LYoWguafGvUDH4YH0y9l0A3L7X4khI7XyKlYLo54lp2yN+YCBqeDnmIRLsb8sIMiaomBMQTg7FH2d3v53IZyWDKf8pkpWFXzTOC5Q+b6tfg8CArGHTF0i3HRSUP+oq8ky9tHQXFW0L8Y35d6z5dyayhewkzY29wZ9NQ08jqdEZ11ULEax5yuio4DqL0iiE2c4qLgfp7MJP1MCUAPbDi4rQUXz43UkVRShr31jM9d5dgNuPnu8Q5zjCOihlqySXUoznfhvvrm3R14/QcnIK+Di+BGhWPOekc7rQY+hj0/WnV5efbq1kLFK9a/YpkbCEEZ5xxa5gn2IwueLNpjSkxz6bThaVHF/etbs4RTTyRUJVPdAJ9kk5TGRth1BTpE4AXBLgWc8NyprrbzKziXItpm/PyoW9NBDmUNxf55fbDaZM9FM/ekHF4wmF4zCM2M1lSB1gWWOYWgwDkiz5lH6FhMqcVOwywKgKs8PzEoYiAw7pqumwsHshpR6b6K0r4WBBiBskGA+JVXXKhGHqZmGMXtcXmI2ArfEeyHUeP58s0L0t3wss7Sh3D8FxSbEGxcBb7L2ivGHUNFHWsfWcMVEy7sEz6k0pj62JKn59Q4Arr6QbEdhbkQ4tPc/pn0+RcY4CuaLRvuWFjcbH9MfzLphgDL/IoHyhFvDmYuTkVN0Qz8RO5Qc6qoNsbCvfNIUG8+5Bo1j6G/u0dCc1WuBevjQwxTHLeBWksAQL57+uy53m38sAcgDGnBoZ/8akxkMGt57AY/RyjTAt39Mp+hMMXOQbJ27zhWh7KRlkdrftPaRuLjN3DBXCcrTXQS5Cb9PHYJSeQfku2s4t3GKI/mRzFQ7XrVXzFcx8vKyvXIhmdc9tkDdSnVCsqz98ArFbIez6Q03IBmSnaCEN+YC+YDV5BluTwikYCeU6Acax7r1+JhXGTM/5HEJwDEcI0SJZZvlcA9ZVdB2QcOf9oVVmPLSARz/+FyLt1fM/DK0Qg5CnGDhREzB2/C/3P7nllx6UuVKRs2u/ahe9LMMzcrKxxZIfiS8RrcNLzxtl/kUfULaAjyz/zw0D4wonEjAEFVkXX/07aQulJUT2sW32hxAoyZs0n/4HBLrKt2Kb36tKnE/wBxHjDp1QJ+CFuvw7xDZtfXUp33nZdaIc8ezpX6bbGfq70YPVEeqOhvuT5pdM9lYMvBOGn/c78G8kGa7ynnTNgDwsxlo85LiJHwyuBnQlA9YDgycTStNKumsmGF0fJJJfCKtYCSVnF1V0rDhaeRGTJUVDQR5axB4+7CuYBZg+WN5GacyRVX97t9W+usqRfG6Nb8rmRhjVedWCf9WRJhIuAyhoUye96uNfrA49ZkBg41213GsZta0JkxO5eOZVCha8Hw1+QLH1Xe4lpJz5onKC+Pvcw7PMwFotsGPuOxAQY1y+WYX35CWkldhKqtgmQAx70OWa3mC6AjC4uZB9Oz3o2BAocvlFxnGS8IX77TT3Bvm/a/OJh9pGMs0qxOVcqATXT4ufe+pNh/QUB6BGlInkbTUqYeu8zPmrl/MBoNUDq2I5IDwAXXelD92zYvUgqS0FpNmDO6BMhVv6X24TarCR27aiuTk6sLBUlchhz2nPlyHoqcPA98oxZRCpNxuiBj/0d3kbHfEPGV0KacUis8ndUnNta6O1fX0zRG0poWJYucGZuXQHUgsBmthDonuDrdVIWiA7figab2b0sgbQWLq9gGf/22Z7KpvSDoZW0lw3TA8C9fjpn02n1ehjl1CfXnREGifr2FVVYY1sgqTRiHbUMlAhA3IQBa9bB9bk3Qp/KdR8NEncEHud//dflso0IrS8WrdAcK3ouYPX1Wbnpm9h3SbYG7mhkZTuRC5gy+Qj0xYZnMUEhlib1AhfwKxyMdg2ORuIAdPYhIvTI7zXYSspukQ9UJD/0qU/Sa39QcHLTbx9WCKFmgdupc5/IFZDZbMEnx9tns6PD4Tg7o7KFL5mKJCS1sYls07MRLieoTYujmMsi9sjE6crBx7Bs2Ky3LhaQpRq1axThVoSA1N5s3aE6KHx75bOM94ld5cF0WrnHMXA4d+W7xlC54hQ541cQ2SElnBSe+OnCM2O+2i/ALIym8dAZxFCwHKTAaRRvcOySgeKbx8EKhUKqwyHHhLzs80mwTgQUO3uhk44Q4TuidSZVxhDz5OscHol+cGCzIzJ7XyIfQRQbLTyF5zwOg1ocgk5GX2P88xihAnwlF+ThutN7Wp+6UXbAYGi4iWzQawYh//g2yYb0cCJmh7SIiaPp8i6qKULtlqz96J2MCUq6o1XTmI4BeYcKUYYALUkJsHsZowpJDcH/+GhbwwF6dUKWB2DurLhZev7/MhwER+JtuAo5BmZaDHrggnOJvEI0VXCQjbwH8C1sThYiHXVeAuZs3VHGHErFbX/fG2Jn5sOKpmXd6H2HOKqB+jb1Q4vQLndMCynIGUPdK7IdI1XgWRdGqO3OLuvLZ9hzBtb16BJa4WV0I2pSl14ZuJCxf+rEwt14YcTVdRjkMWXqOKNtvP7eCcC+RSlRZnViStYH9CW/Mq5ts8XLQ9ga1pKeDF3HwcO0818/O0ow18uJvIsc3KA0/pkAUjIoP1JWIIDSo/cNgdB+Kgi2gHV2ZUBnJwsWwCmBsVL0ipQQnSClnaQPV8DrQg67Z+NV/c2Kcigw/7V8wVttz62xFQlCLzIiHySs4Wwtj/oAF+PnCgj+3WqD8naw4C/2UXj+C3fCTyeEBo4TSddg8gQI9DOSgD3aCgvLbpBuEUXmUK75qSOarxZgg05MdUKQp6nf9RUxley1nd7muBQETDZP6Yqx8dG+ebu1RvLSo8YmKAUE/uF9OrU6BNH4E1yRKPriAkRd+vXJb4oiiSRr3ypvC9YWLgYWo3KvPS+T50+p46aAaKgeQcABuTAq0xWvO8bXtfz/uloBiwo5R00VMwKcC+w3zh62JMjqqNvnNHjNcI8Qgk9L4QkdJWEFPxu/XINR7Nfl+6D7NLyiEhnoJTkgMaxGt+KpwtGOC1RGJnmYOoinJUpCY4Yvl6Pg+IkghQp+clmjQvMl7u1XQelW9y3eTQ7+24pUEMrWEmh5upCLx9fvbsibZ+dODD7KNiB65ufSPg6ULdOYXaX2XBPAP3F4BV06agt6t/9ikrlytvM19FeFXH5b5YrQp3hCYCTKGuksbjhMrMAocqPiM3OY72eCxj8C/8A4x1fSvvfb5YAPxSE1bwMI+LgCcxpptyVkkDmBLv4Z0BCcsEwDC3ND2rhn/COc4OBFX8TbxDXjPCTpYrW5izlvlZB2u1ANm0XAXl3m5O0ZX55CtSgUXM2ZukycofY7yx9GjNxL/BRsBtm/OUd/Sqjxtq37jvHoOsgzrkHcg6BgUBujndM4v63lzw6wU0FQf6ETNGrxZpGUJjgevTNB2WcoTgMkwqj7pwrSHBSC6tH/W9fUlbqkBiSLvm4aN0Jc+nsbBqNCJKj4FjtZat5gcHG+NRSmEGZnQP4OxwUTPpwqr3LPn5Ui4a0gr+ZQu1PcQBzt84+CAvgpJmwgpFv4QYz6xBLH2NONieyoDxAd8G+lrJ75boMzjzeAbmbvobp6DadIxu92YqxLbP/kjbLRaw+mEdjDAZ2eE9i1veGumEmN1H1tOtlcr/jWnmT2y9HXumJXfU1UzVNWT724jf2zcZkB6r2h09/lpU0vNQq1tFg9fr4QhwBMzcZ4u+4GtGUZnr4zqRHUwr3MeqxDtF6oX9nd8PFjiw0NrXmJyVBR2gEeeHBfOjcO61GcQBF/S+e4V508NX6dAzsIU3QUGZdfdYQBUoaajDVwO/5Yc8zRS3A3DPyFy7igo83Umr6RqXKVQvonRFmwdMelQ6TLn+DDJcZDrMw2iJJuqwGKKcs6KbopSRq4YuWV2PX59LaxE/dLYZpJj0bsluC12zhrFwEWCVyGAYb60PoctOkl4Zn5qMvaIF0f199QuyGfY1JEAgkD9AmCbjzwJhgpQfPzuWzFWaGfPMm/DN0MURoKBnhoSVHQqPdoLV+StvOxETu6w3owA7lC5rZXwRXu4PV97f8ysnLQyMHOxcJeR1c+DGPGmhNa3jaQEFoatFiK1AsdAvDJL7VBlZJMSkiBE8D+Xjf3FOmndmH8HC0t6pjsKsdsmU6wwf7VXHrKguNF5FdH1AKWAPU/QWrSuU70U1shaXkhT1YBPl9k8Cd3pAQjdzg7fLjAT4HOupRH6zfd9uUfnHL2uEBR10VscinPEfWIHBD6X1ubMy7GJ22lImUa594/vNrS7RsbuOYuvLMOmuxvlUCDo6eqH3yjnO3eSHqNTW6Ju8dU1cnh9LiY+ZnWf1MwK6ePjoAoqFiQE3mJwfLq4fzU7CM2YiDzxmzie7QtwCacKkTApdeS0Emw56NvCPMKioUFv8kzKRitEQt7vXc0ZXrn1s761VqVojS9mvAW4mDE1DvkXviTJzSjlQGyXCc/CLGf/tDBEGPU6TI+hMP7K7kxWLzv/h4QqMdfISTMgTPHDOKRSQJYcgSlRlHgQ+nS7BMAIv45CuLxL3otzpOgpfwzuV2mp9Fhqt1AxqVtfkq2h+nolfCLTDWBdNUHHeXWJ4hX0ItcaB/FVXcEbiBkwkKT1WTZIJgSKEAd8GlaVEphHwUjTxl5OnpHR/UoIcAZduQgo111snJ+PFtXToPZtuu5Pm4bq1c0r1EWY2kDfB8yyaLXOkZkjLPpJmDxtMfUe+KAEfPriLyDgAKM4idL7FKtHJGPqJ4ynmIAcS2yogTl+fHqsg9heWEY+rT+37PGa3j6zR7KV36vpFr7kDE4XKwHB5VfRtAxxEPilT6J1JWtxxbcCoA+l3vK70BnzPvC40wLzYnW2gaNsccuZXU+9bit32bUdx2s2oHNwMYqxKtq3hzcuE9Cy1+Db/m7TAUjotVYs8Y7q4NNnBxBEufvzbTrefziMCuafA4hDH3uVUGElFGWc7q8DVtuYjxzQZhcwEq6bkgRLCfCva4UfFOjiPgKg004aqydgOe9GJR3l31wz4gurdVEbEargsxe6NU9WY92AdZ9yXDLsBQu4Vg41vBqpYfaKgCixFWoXX7CuEURCi0koRZaBAXhrAZu7VViM8z7aiLELq5VMza0yesF+kLG+/nZYFgfIEAAD8wqv+Dd0v8W4QFMZtpKN8Jdl/Wrc6mZ+J1IIDgq90ogVPqQaZMc3uDw19y3CMVeD06hII14tftqFbAEVA2KNO/xIAMXi53GuFJ0eCo9Fp0t+C3mMqBxaFNewPvdHK7SPP4X/uNRlEzjtp9i1W6e/nGjhwf4z+LVtsuFZFHsuzJE99itxVy9FcXJIlq6UNJC79wehx+7nHr8xWTOGzu4nxPMaAsEzyRLUZgNHNfo+Ua39ePcmln+/CX8MGoWOHSQUSxjuOjXjP6+SrSl4Nn8pdI5wsi4En2QNwZp1cBeS7R7+Hwz/35LbV/BnYaxkryMUddrgUcAaDSXrZBibDqZpdbqapcPoXhzzInv4dxxXY6lFRbmSOnWa6te4rNrYbfjlit4lrQAjUjsIEwwK1IGYo5IOrbxVGDDBVp/n3Y7owHf3tRPOgYIvDUAC2kxCrmN0pw8edCbwqKXd9fmkGK3il63Ho+vxNfHXKQ5a5fCJxonSysAEFYvAe1qZMc6LEjDRc90fYcDkBtxnVW5uxWYlYGzLK1J6nGDV3RBO6rAbkw6biiSPRDKvmqWRezEQIDa9t7nwW1G80M+bPC72s+dok9WV9eOej7y/yROw/QoS5FcDb9ANVYycehW5Q4NtvpqlWjWc3X4Bzp4veQxLBCnuOVDGNgNuWI6wldWSun+Wr1klglLf03NLNmcyRYUlQT/GhOElQy9ypsQbSy5Ba5cPOKla7bdzqgJKQs/Jo9+ws3YtHePancvijK8PnpYfc24XHnd4lDlWOzxGbpbLVcmsA186ZPocDwBAmTsp07zlR98ajDwaz4p6icglt+vavFgG00n4Y7Wm4HdH2Ov65zFnDK5qZN46m1iYpxTSW8WcbVKuIHT4mA20Z15PKnPoubW3eP148OTh9UKJCiWwcA7RWHLcc/27MKG3KVLMz2hu/l1j07y8835ejMlCUhdozDWuIwlQoP+au46lhIVFmU2FHLePRMFHcARUqDsMcN/UKGuEp0JRacbDcohYl8kvVofF2hvsBHtCIGB8R78s5aDBoTSKt6+h039R1vNq2k1pn+G9+XtROvn5dl6XurXYqAXUd6np1PQMxcg7CqPO5a4HQAjjpaApF12fPdzbgpfh6C1nxaDsg4j9r1P6gwEmn8k+RmBvoHFfrqQdebMHUR8wsX30l6pyTemKqP9AcM9AOZ/WgiThImz6/u7mYHRdT8t9Po6orqeZMyCnw3SNymkapTaVMWT+YJ0Y9kwpffhUf6LzginCK/2TxAVzW6CnWyMJxgux9k08I7DkT4AI3FNKUcrWPQW4rTLfHNukM1Umc+hELU/LyAXFX1SBuL2QVGfJ3lFFE13GYm9Nxm+Sqy/upOLKklGvP5jU2qMPequcP14Ekv9DucT91mlHlvwezR/abB40Mnl3jm/WJJJV8woYd4N929gZsXfYkpnDK9AstzZNaySCWMK8NM9dXksqEv6N96CnmbPc4Y4K3jhWhlmHOHLsk/fwM8diOiLxCkrYEZrd7EpK9xPVgI/EkCdi+WccxMIK5i4xtid6nlkniRyqq5IzxsezNjaiLxvrnhdsj+lCmT1GBw5iV45oomSm4glXAzrvlTOSTvSROKSHBxahHGs0EGXhklQMsQizcksHdHKtofTR6OcrD6x+XOmMtHURJvAX4iVwRUEcDq7q/BcvtRe1d6xY/bh0zxMMdgz3yR5brtHUhB4EChePXXrBEuvPVT+y0CTTL06ZErmMhSlckfqkk3s2xzdWqAcyZoaKVO1rxMLaMGd9mIl4mBi+TKg2Pws4i1sE7NSy3UptP0Inp6BQp7LXzdTxlQk0SBnBuybXtY+2MgryrtJPW+VXPQ/NEbTXTX7smbCPUIMXMz26hUqRwy3BKInqyz3VrqbyJrs1uMiQhGy4xMgcY0NfZrNtDHza3S70ZAHJhw1QRLTrEGJ0JIVxYFRV1MN6qAbzG9lBbQwYfcfrQlsPJKUC2Rpz5Qrx0MyY6PnEIkZy/aeVycBiMqBypSb89vsgmDrkavFo0rZRQTxT30iKbMLOTPf8vrfozIm2E18+rzNzMpm65uSVJcJrw+7qoha2shglo2u9Mot7CZ+v7xNvJa4Oab/teTeHktHr0SmAV0e8DLTc0pIPbR+F7kC9HNYp4r2/UOu+CCbDHP6lhhZKz6ITf2VbqpPBwriyNNbuI58ppTsQ800pPa4dqBb137P26nH8N+yCexf2Md6DWzO3H2yt+1Lmcx34YmnI+tRgf2O3w8hOvxvGdIYAPGI+6fTEBmBNGi8V+eBZgUbkd48hXKrC6Pjn5+iAe+rAX882hNNLJDAvWwNfjKONoVdrU6FU2ncd8g2+cc7NtG+XuKSONQzHO7tswdrrl00V6fUZK72EKpj5d94RyTzksP1ixDGfQKgSLzT+e3gB3TeCesJV/3mFrvDf95MHUxuiEErBZRnDsO5qXMpAgwYG+wRALq9AWWQH1nx4qjVLGUc0F4Qk2tsJ5h8QJJfdGf4r6aBr9lSxq9riKZNuVBAw+/xu9eKPjIyqmYzR1fWObO6WDANqmvJ6yjABBcnvYhnVC0bc0A1z/C5ipl7cVLkZPtFQWa+HqxCuPAE45n1c1s5Ljak82okCa9WXJ51m+TVMUeVm4wt7ggH9/kwfkyp1Vr49H9RSRG6W/tJHutylllR9hf1GNe0rpulklyzR7YmAKDVttYCfNqMfM2W27dam1dmNHfAjsTgmjRo/duZBRM4qAiy+F58442+l3M5VN8hA3ozsGzlPAaHvPhuG12KJQ7Kbi0RuhFB7skRB9HrQmSCNnu7h7JTZTZtyk6vQC3+38FqiYiWgFVavQ3UlpgIN0faY73EKZ024qwS4e3gWuyzwhA5ujoiSCc1h3o/PzLKPBtErHkRS65x4oO6vtYLTiqt/XQg3NncerI8YjG0uAR6IbYXM6qR7MCVwbD9RytfEvclwxP4vUyl/rgjJ9S44vWbJKxu4ahATg5U0k4Pp9jwHWHdSkDAm1obnq17Tzqnw95WgHkTmwoZvsk2dbLXFieT50aVuYJEcTi77MU1F4XTLBaJ2z0m27FzWmlUrX8mfnmcEw740GjfLatLWmmBddLf8XzV6ZfVn7BUhXnGSl8O2/6cJ/JF5Mr+FRw/UiFg3eHenDDL8obmTeMtjq+PiQvhijMa7zJRfLKC+hHSNhehTQmY0xywsZhNz+Q9b1rTh2ZNk8xvYZBWHQeedkHd7SukV8CvYwC38lLZd7e74rjSuQOs5yYEb6nHgYn5e2PAWDExAqLQZzc4ddcLTV0jLl+0n6/SHTvvXSmlKGW1A+Ls6Z3KyEkT5JIE+aIL5+RhYdnvUnUr6DgX5qKCW+ny051OUNdlNYmYKF48l/njpAFHnzinwAahodeE9b4gmuy/8tH/5nnVHKNfS5U4ntUH5Q49YELz9Nt0FJnB7AqEeyzoGNhFMVxuqYCvv7mmhVdT0kCsw8Mom2jc7NAOH828J8fXZujVeysb0YID/AowxPXVxo9rdMAUkwHhp0/jlpCgkX+h9v9I1j/udidoJhdzR716F8+rrmFelkjnhDtxUatrXkqt8BwmjYC4CKt73U7m4wkCZcqigXcaQrxWMHPJa/rqKvhTbSO1+cCKS/h+9GRiSjVa0oSUF1TUzRzLRK0gs+wTy7DoWOBwBrRNqcx/7bIkpgbk4a2+ZcjmmfFy/KXmUvvNUTd5hAhp37r6xEREizDFgnXkwsFQBpLuHtIHU09E8JkYHq8WtZ+3VWv2H96/xcR8rmdg/dgZkdU08gtigs4iqBnaloMsjfpFOc6vZOt7YOHEY60WNR6uKKYveCPMHB5VXE6f2VvhsRh0bs+yKPG5hVk7ibM6vYSWq2tPfw1IhROo8Rl9LPFstul/2A/bx83kpiC4LUGCfKuOiMH7bUjAsNR9ydwKoqAlggOG0JrvaVrvGaA5lO4o0mCe35E17RZvZtmB543K27LOGVWAes3lTfR4JP3NMOChU09uYWBakr5bhHDn/VkfaKj0aCo3XUoxeuMJcMpaijm8Mrpg9j3K4+pjNF3UN3wuuC5w5lHYzdDpmhnYEkz7Vx/Sn+eOT6SiKAUR3abZBH68EsZ7C+j5TImN4bAC8UaSCwxfkTJ6YygE35FmRmw8d0sknfBs8fdlBO7P8UzKlorVu47dfOK+QUsJXu5vk8piAATVYrlKPHF2xMe5AN71ZsusePljve4TQ2ThyT2+GTzdztlogTHMNj9q+gpHHvgVOwPZ8qp1QGoVbeoXiMsOlqwc+uU+Bp1Q5HLXk8mxFCbe2k4KKlLizWJYR3aomIsNn9o0ujoxvxUH+D4zIUk5aDdrG3caX2LPWF9t5XDHEp7kq866uotmWQureLTjVNYtLqXbLYV+O80rA/7CEjSi19WzUcVI5n8zbXLt4meXpewOEPSgUWebHm0HdTydAr2t0+Rw4AkiA1lAdbGQ/8YhS/Lz8UrIDI7iXLXqnGLv8B3hlUMiusc/2K020wcbcWYPCmbR77ZynGvRk7pXCVHj8WYwbFn7AZ5R5+33tJP75W36une1duDsnG6JExLoWbis+36ciRXktlGavql/OL1CX7IkpEL/IV2x2xDrMPNV6Bq7f78M9gL7hEpn4ClvkuRetZUc8PX9OlCIB+XQz1FyjjgzqO4vvsyjIIxtM9M2wiTGB9Z7iEE+tsaBvX9i9hSyQH0Z3L2UyptomZ7Ob6M7Me8l5eGvHsd146u/gXKKbsdZtJ0JevTegrUuq41Z1gRsDSfC8mNehCq0f0+PgYYkx1leq4TXsC6GPTUjGmYoq0yXv/gCLE3wg1+c2QCeeGVcVkw6f9C6ARk+OX8zf0PgkgqW4vuxrtwCjxnDn42SPvyhFclnzzYBgRVa7p4wlku1k/IRMJqd+3M1bdbn6/Z9XMA4FEJGCa9PEGFifOuTPYmj6c/aTTKRzWz19g/ixaHhefphPQyLD1C8OrcRfJJNtWJxFcQAPvmz4OlH8HX18p0XCOjx1NfAQXHNikiXVGwFznd0l48NfyXdbzHIOhgdK044Ybjsb38rbJ2hV9G4TshR7sk1S7IBQCUxPHfluLsrPcDTliei5Lih73ZUzBnGInpr9+bdhQE+kdSxEk4W5Bj8/mTIzPoxo1upLL23BcyGUFyKDHPpqSh0W0EeUd7m9ExrWqY2AR5/FMMV33L7iS2i5lyKo5eP5UTNxSL13JdBtpE7rH1VoOSSGJNcngRlPAo3DUbA0Q4Zv8tV9nlePOEfbv+pZAekjmKyxhGTdFm31Ke4vUIRaRGzPNRNQvhpAnPExZkkZU70NUvGTRzRNuTKCfdLEAY7a4PfmVtysQyGG7hz7X9paiq/qK2MP1Sqj6vNnbZ4OXRCKaX0aydaNTkq3h4h6n20HFQpZqCm0+ZSGJ3+nfaSqT2ZjH/v9lUluWVivBW7SsbU3EUO7YcRkn6ycMDuanBeEOQ/XOGMfMdI90DOw7mds7z0g/rDDMvH38NzEwvYKuBI1aXQkZjik8coFfcyAXX7MzUqUD52dwze8wCKjTbIxKsWTCchRN7PoQcD6fZwVWKS6kb03QWJShkL32QIYMvxeoV67Oy4RAi/WfQ/mhHcWkYuXPKGTf72So1mIxX3GHz64sCarHllJnaROIFRnNLxp9e9OyoNg1htU7RZxPhLJnKd8w+Af7anWjrjCm5qMbymQ0f1TvLFube37dotz8S1O8VVwrKTfPKP1O/OlnUgLrsrzsX7eCfbkBlcKo9xYGNIY7sVhlQ7xxeLryhcfxg8UalwMYoUx3BaY3vHkkGYLFKgdppvOFY1Jy1rxW2zQNfoUEGEPe5Otv9q39gLvzqNu9O90Zpc4py/dcOD4CxJqBjQ3PJJfrZ/NINeMNvDRH5pglI0PqNg5Q7l/Ft22LUxWzpvwUb/+vIpgBpV5xDp+vcCrO7hsyONgJoV/lozKW6AOtoJO6TXdjsLmSrLsHi7mwl+md+frLmFfuFGATgkd8M/6x2fBOMzpnQmzzT3+BCPKQCcTaCBlexbP/dMQBKTQPQ+gR4bbZ1no24a4m3EIiEnwkKGV5z5v9S9clgLDsbma3TwOzhey7ca1sOca8jh/USN6JBWLVd03V0HaiCQTiFxL0ETbvE2t3NOe+9mczTsX1IzJIt9UKr/ZefLUQ+AZovlgD2p+vp5jH14AHZzpuOBQFrvM3ap5ENgigyuvR3xmP2NPzmq7jWejpjKswQCh+QE8FJ8dtfhW7rpV2uKkGWAJpQoLeVgFE9sA/2DUuqkiP5TFWpqWWI2TE7QADS8Cx8Umvgf46WsPT0a5fxlcLmwc/zrOeHym328jvmvKxtIL2+zJUhbFrG91clUSJJxIYmdCbO6GaQ1rlRYUz20Q/oAdfkPmSqOVxqc4fHpk3f9+6TOOW5+ZXclvkyvQ4hUxFb8Onklr5fr0Zev1iONFAK5BpQucu2HrSrnNCEpIqaX5i/dJJOAJLAeMkKhF2Zvrbovf87lK8AFgzPjTiSAQEy3lhrvHKB47ROx79R5L3yJAHKyjsEH9Cnlp6sfuMRJAzM/x1Z4JjR2AMFyj6EyPY1dKz+zX0Bbou7+zBEyhknAQnuArLX5cNQgLsQxu36ibqPx3mpcYR2NZaxxRPMcARLpaHNyND9R46zGVjk+ddMOph4m9hTCtUzi/hEwWpd2p8S7ttTdbi3WqDcwWiWkaiRlv2N/6scxYQkmtvqre50c/+Cq0bqZnVV+xSemQbF4deqvEp5iooo66L/Bbgry+Akm6Z6HWfMNpHJNvoOxPwN51uL16mgmu/uszMTTGUYPS6AsPF1ZVtSTWRlr4KgzgrlCmcwuy8z+NowleN1iXanjHNJVqnwJt7K6Sh36D+IUqm3SUsPAQvEEc/OAsvaB4sCuNrQEKhx+Kx9G0rtTTDF+ZFt8TkB+D0Cl6Ysabgdac6+hAeDfPxzLbKZY2QmMhXDNARoeKVLkB3lYpGEzfMUwudL46kAInxDdNiNWU4JCzmhTzvXyWAS+JThpWvybZtG1o8iLKOsrP4BJ+8pnfNi9Ot2Mj/VCj/UqB2xxNQY0Vl4HbHo6lxn1l/qNJs5vR+ZziUIcrkHsp0z3ME0Vz6J+R3NO3lwORU6gPpQzRNVG27hibmlqFTCIX4Xs6s5J1+RxL76k+2ujdRUWznpDifDFkpqUcNXE3jL7g4q2HP2fnTY7yT5xjPAQMAzSzgEhJSxacPHrCEkyhPzVAu4dNI73CluvCOYVqK+I/Tw00VYEIgltdfToutuQhZCJM0rHPtn38Vb8lnAcQLXbJLe/vc/prlVEFuaBY3tGGyAFronRzBsAuC3XFrUAImT/zp9fU8PBaCbGcd9it57Xh9wLFXS6d5383rKwAORjHLfoS/5M11xOFUES5ehmuHnMn/IDADq5h8ApPuYlRmQCOYTletF/loblfF6xo9kzigVpur3tJJn91fDfmqjPb7y12tBfFlNcxc7MLbywBJSpU3sdmHIrwHOw9Ikt8EDtfALXiJiCgADALjJDv6ZDjZ0XcgoSfkf1/qYB9Df5akuRDTg7fjUdlTkLdERqJrbQ36GoUENdeKGjwl1bQncJgwQTq8F0PhqOKWgMTczg2cNqIv1kWSj88Ugb6ME7FpP8UlNTlSZzr30HzXCsaB4knbr2do3VBJXIBvu/Sp6CfaPTavlOiXSEL3umyJayM1h5KtOqVrNCLnR3OTZbKTd91IRJXjWlMZ5V2vuFcoQ8dPAoNhN2aOeU+98qcntunW7cneKuPHiRAOu9M7lL485zC6wrrJp3YXPkyLQmpm+2BKQvlrmLAs1JbWozBti9EjjiCAchY1PeaDjMLm2C55nPtXPuLsDXPlVLNA7bOTFh0XY/61ohrf6GLwKTbYMf6a5448P9lhMKyJM887ARMH2DKRO25aBjfyNSkndZelIXo7OWnFJx9UmGaEu0DMnf1ydJrCD21i0HS98fQx4TAJujbsvcs23RyR0ux/b9JaqPnR+vI/En3XrbKzxh04DavnTI5cgUcXS/Nwpv2EgXJXn7R5cKIcr5TaAyp3Z2i8aanmF5qXnCi2icLKOVrqIeZUW7TWhz7RL0uFPc7Cb/5JDZWm9AOcUJOLe3JO3seAAuHN/wKqkOxu7DXzCi9zzcfTRxGG4d3S0IzHmI44vqCP8vFn29lKSoZq3zIv2nVJrgRt692auEb/V2STY7UUNgwTIdOD1v0Saa3nfYSXgs38xyp8Y9wG0JZaQlS1lpMPGVo+zcPRANN1VI913jgmAqXqWyW4sMcVy45JkRSnLpI43cQintE5KL2dxNwgSFU9BpV1Z91942PtLPtKJllr1KYm8pbq3Dh9x1QntYI5h5nskvPNQt3zVovtd6RgTpXyqAeNgArL6/fhLKl0I4D/LSErfP6/WiFHNWbvx1uSiftySzhwls6Z7L+Y4KHzQrZpe1mEKnEGi+inUZrZyhXmJReJu/nW/ok3pLGfT1LRYgJXHzRnWJRfEcYIHON6EYS5egvtR9GSNGq99MZeRGebPnsByM9eUc+GBLyYr7z1zznjlg8Cx6SMQxQzrQ9nCzEeXV8soypQTazGRlvM+AlTVSnTcIoE8zVkX1mGp9TToMVkKDKPZDNVjIUOBziMJc/zc1dB41xkse0PS76aV+T2PG8ZvuxSRYxX34cnVP/1RECMCRKcHFW8uiX0PcZprBImCMNpBA4f6GAsMi2VA1W4bsEufdHGDZuO72Vs5LSuzbJaJKbcygmB/up2a2wY92o4VHI3LBNbktPfwdnAs1IcimT9wEJzYs5nTHmUjzX9C/+G4eW0woY9le/U4+IVSct9RdS6nk4OFxJnh1JglwjNol6Xnx5i2je6JSpdAVUCMJMMmahFrYpyNaCvbPrWbSA1QQGsIhgEr95U5HcKme01y373Tq2fGLCu4+C4zcZPk6YhweYow4TdyV0NY2Qj5u528dv6WlmtSqEBrpmRsw7l/ITTmNLlwP035PQN6vnUB4jmCmep6DOxcT95csNnZ58Umcja1mjua7hZDbDTjp/FG6PL8n9eLeq8RGYqN0cjLLxDZrpO5Jo7XeZ4SSaHNcF9hY6vot76hjBsH/7NE7dJl+Z2EQ3DXFFoz3MtQAnjlJWDqbsZSKWcPfIjKSU5BhqNNpSDVYnDmIjyWOxylOcd6GQ7ZKllV23FT+9i5DsFE6AgBvkgYO8vZBHO3oEScvuIu7pf2X2cMeQz5eXxoLc/1eZthBQREkDPPYGMQAVPt4pSoKDOzgETlXExj01JXVtQRunuhBOtQ4dCiLD+c++fYUHToXEgybNgXklwKgZvI0I6dvD+UdhQYB5q+ZH+QNGqoHx1XRxT3lgqEwAwtspZ6PIsr61+Iow0MCQDLSWUzDJpdgAFS2wRi1125qQud2Ht/nosup4slrB585TzICCXRsB94mgNLVi09Ik/fRJatPlODGue/UQKK02yIsHXUAceus1TrfjwMsLYOuu4CGeOeQ4pMZ1Y7PMjtHXI9kcUw7ElXbNKqVthTjkL+n8awZFbHFionr1UyIHAVLgvSQuQjacKWdNcZkWPZKND7MotUEYPwGu/5TVIrKcpnT4XlqSZ/fkyetA+ips4mjRsXR22rg/LTdZ96nRMvjt6TpL3y3GOhH5oZ44RD0X/l7wqvhA/CiW7Ucw1BhNAOif4EYcHq3+n78Q5HMjMkm7XVNGsPpBMzB6cyE/kq7HnTSdtczNwn/OQitrohJMzr9lNE75Njt6nEETcH9EOVR9dw1/nfQVTtD6hbgcyRV/B+jQo7kMsA/mXG+c02Euxgs8n8DEEitKbz3/0nA98QP2Fs1CI3+j6q5imnpuhLGoqDdSdxKU9h8ohW5yVSa++oHuZZnx+s1wSI08Bi1cJE/gS6n5Xees0hE2i+MIjLKvglhKGgHm2eMfClq22xl2xmu4szrPkFe55fVFvV93dHlW+Ywqs9OhAtM+Luol1ec/M7Lt/vPEarBEbti99lNfdsFmLONmK6cZI0GWxOnnI3E1Co54PzEg53eENE2l11Asg81t9+9Ov2LeKJ4XJdeKzlhGyTqwoH1qWHpQehuCxZercEglSLFl/8O7MVrwCCaigrRT4NVZk0KSafDwVZ/kxttG2Lg3PsHHQFH70tD37SPoDNHjc6GxlcL3kiHCo/JqDQKl/qKhGz3xTk++DcLCzvB34w589+z0nTbxr+uorwe75RBKghbQBjAV1/9a4jh4IFWrJhHIFYNB8EYQTxEQDRtCGAQYgxRH4AmDBRouVgIofeHLmerHw92mUllq97fRChFcjd3/gVbBcYoTWENaLk58B7A+fyKbQvPeNzWELVF0gikFccP0SRTQsuMLa1gcNebz9vB5Z9ihckkAs9MKqbAVibNU7AQWvm4ZJaRBv2VAoUI5/UOAjS76S+O+8+9xSGEj81ImL6FwuzTAHJny9nt34kyJzZ2+5zcTYM8B30NPvssS6wWP6/OZdWcr9AH58Jbw26yzi+9j5dPaNzI0J9Wq5aaK/YHTMkjZnaBu3wzLgwU+2bHBkZLKk1GNcAVb5H17dFTZTrSNuLSqYSGU6V1WP+yW6j9Uc7+w69S0wN5oDb0jDcTw3tZ2xXYiNOKnWBalCdA546bFwWUy3eJN/4rAEbt16J2bigUAuO0wJalopb3r0tF1GpHlvnltNpjw/9QCBC+oHEsd7cKuQPDxkooR7Ipmh0lR3dW4qddLYKJ5TpwneePy2P7AM9ePfh5PV6oMfS4tGCu4MAMxRBkDHiILh9RgmpD1thZn9sfey5hvbj0fEeGOqhHzkrQYEMPhvsPUfotXsijyI0FWKwRSOA5BXOn5ahSn+nha/Byerxa6/llxhGM4/h3rNf9IDT+XSBF6PU1X5ca1lexyzDYBNewPFbAxHP+9Gp8pPImk+wh5exegbN5DcgtcFMu9syNtG4tV+3yZiTQBHSYZ6D+JQS8ELVT56OWZgdVP7UPqmGHNoTlKpvQJQVahuSqoz8Mc8bPQMykXB1rUZlCRX731Yi3JgFSj1+F64B1euy1wkL2j+QuAwBog5DxRMzMKeocz289Wp85ko6E7vTQUzTD3ttlKM20FMDeTlsJ5q4Y2um6LgP0ZCgzsyVDK4IIbi8gt5Q9nbXXDjb54TjEhJ+u/DnQ97ebIQ92nKhr4sGmDdhGD6/FvbVzY4atHdveaw6mqHGlpvRwxIuYJbOlHAa1tFtdsZornintM2tI8vBxEF+KTW4gdhHFh6BLd+COZaLjLouGZqraF3y4hNdUUnDLs3GOmZdAEwVivu+bYrw1hczCawoCcYgmqecHnXkrtjdxIIe2dPVxrX+J5iyQSCVlIaudedTI9opVAeTYFXQSsxJC8UIUacl4uU2OkWoMcYl7zBcrZw3Q14oLTGKFeEyJIDY3A3oE+gB/gi+qc3H4jz+0lOCWqk5j8eTOxWLB6yTT2lXPsb6GmVq3d4bPerrnFJcQ6x5KZMlUAQ4cJ+GQ30T1RrpgdBPwc8YKDvZVuUlH7561U3GWGMTa/AGBO+qgTQF+Gof60FXgJyLXg/ctPFFo2A9A28xvSf+VOEaG+JvQmFCsX3eLhytpdVNMWH85uotUPgWHQIZFk1/8xDcjN5jOLbP5a+A0/BnWAe4C9Kn76nEL5dUImETu+8rYjDF/Nzgo3Ddw1TvBE4jnF+dB64t+8sBEGFioLsokxdvzH3NnzYyHMaY1okeEq9Ou7gSDS74RaCX7BKqnQtCRYLBUZc/+J8loyAzNSXI/7RYZgnSQkoHQnMx11OCoaVAbxHeh4pPR7KIJ/gORquCUYhMsN46wsZgP4aAc205mZTTU+3kEHDFtF0zgs5IIr07iqZsBkxSdCxW7CcBGGB2J2qf3ezfgvosQhXfSJdI9Hw79oiAGplwBhlhbfYfqBK2v9RvyjQKpgFcq4suLWSyq6Zqdyr98uGTr6Ju3tTKOIR7usEQBtnak5xI7bgBy4pfVjC5KdQUReeG8xe1jniK1Hkz0WYUeoK4tgJ4E8fQ621RnITAcRmTxjovcj0ukpLpWDsp6UxUz0zE17jXiMm6PnnbGtjlLptrScsM6kpMyRm/TLFki1jLG/pqB0YlHmrpeM4Sa4gE4aAP/HpX+1KI28axKYHUC5nplElyfZUImfdDX1WVIan8ok1dpAf3wFJdbH8UT6SurJxNDA+q0Ukq1WT98FZRltlRjwIKHk6LYLH/9CL6myGviAf3l66snv/ZBWXE+SgwnBfOz4Kkd4OG0xwucnsZJ2b6gOoDI5kxxucYcsxRmbwpDu6oukh+XKzkURWrRinkl5VISWXDCAyLEn0Jol3jdfKKxTRomBzaXreQ6jGeXjXKJM6rLt50kOB9djeS0gzIExKvqBGdUXbOKTACemGQ5Sx6M/bx7Op9dSNW0b9ZvhK1y/0wMD3h9BJZavRgHaPq2Z5Xuh7o+cfkIO1Z7YRXOG1BodO7fsdJO5e97JMX+/mXc3bhVp/J3TdSYiPSIGM+k2xHqvwTgp+nJbXdl1QuOIjr8Yx4p614UMn9/ZZBWGfOnbHFCgZaL6qA4sn5wULXKmsS6MINlrqDrZNMN0LJQSGRngUnzeqNKKJZ6xh2TAS4d7jz/nRb38DwzZgk9COTcIv0AdTjZWmGyUOMJ78MewUqwMBHElUqCbHAVEIS4uh+LmctKYWSmOvSja/ywNcuvaDCfgpZZxXQx++MAqdOTzrOJawH78Efl/x28ZyPyIIs+Qmwlxe5f+PpvXvCfqFR+F+89GO2xiFgFvHZDQpDWJuPWpyNeAp2chzv1elD2UMgsIEd0u8ZeRW1wHwY9NLyZMtT1bcpwB7bXaYA9oq8ez970ASPrAWNQAupzwiy2zP+k/hZDxske5fR6Y1Xv8BNLjxGFHm3Klz6FvyPnrABN4Ofe5FXMQz/kRL2RzuO+/rMZH4Yp2M/4VhK5RbFW156p3avkbtiKoFFfXCmGGKqUqDJosiULITyA2DwSEkXjLtXRoRhi/RC+XR0pChqWGmFi1UGnw+3uCI2HqFM3wPoSzCRb53BaKhTMx/AdTmKsH9Ywd2u+MeoVCJpR8H4IAwOeVpNjNyl31f5raklXVTCwPv6lvOTFnUtp0xpFvpeqZGSECIVJhBCwzGAUPZbbTJ4eDt6fMXHn6NFfrQyQMqCS76BvKjG0Qpx3p5gw+2scfV90vjWXCYb+IU78guanTBmBIXmigefyexCNj8s0nZMhljNnwUNJ9oIKujf6KkdscH7Skq4oPDMVPaaqTMFJLjAWDtvELyWqMvXkyUR0EnUB6ZbD1b2W/IiJR76vPtSmUYjwBh0lsLdQrtrldB0voNyqjF6QzVjijpkPwXBuUL9yCNywh4TJ+IGvRBe0v0P9UrsgnJ9/4Vcl/4eNdgCTUXZxJypc7LD5ZfoBoaT0+V7P25fMTtS7aYdEdULTXsTPfBIdCAG/asHQjpUHoMDKsmu9jdKaqOE7TKlweJvVDE9+nwjjuqxbuDFQZH+cYVHKlzTLQAoRT+2+fWs1pdSXKQwLDGkVdxpdrv5lu6tGEhgsT4H3tkPeBCIdAaEx1qPo2ZAxCBef1E2zhXdrwmJXSkRCkLEwky0mOAOJiQL9zgr77DfmTQsucQ+Alzod6y+bz414YxrH+8+sjWcpFuJnh4wXe+Uuuw2I4lg1BOBnLeGDHmZ/RMKldSp3E8b2ry9XqOchLq+EOIS6Ie7A6IT4u7WaD8yu9+vWNKWLL8lwh2xH19FBIa3/YsIPKTcCWp3NOa+rA9YWb6lbZ7JZJG1CxN3FyOqoiWjZ6mrNnS7Gs+2RnZYM/CWWhw9o6JS7B2kEzbKgJQyJKxxTrgcc5vcpUampbxgGtF2sKgl5bNJhALnjI0rexMtiBBuY6uu1ZCW9G6gMBN7RiZbfpWBW2cZl/b6hNwDQZjJHpf1pj+5fpviNCev8WE5AQWIJqvcrkG6eucyV7e3hbC8CfBywhqmDDhXEcVFoyrnlhkkIcKNwmFfL98pEa6XVYYbRkl+eAcA6QL6XOuiRMj17CE1aRUJGxROtS1NrgBEhDNIO3TsQ3dc0TChTNaA54IaBSVbU+WTVIwMR6s6kyUCO3VP2fIEo8iwIzCmxadnBAR0bbZYTuU3w9CkqcYRRZ5BlJsM6j3RS1KXyDGUsC+0QxUMiEtyzRK/WImjzWe+7HsvrsLRBk/09qb+LNhUYcskx34dNQBskz3mSr2Ftkg1weKIUjd2vvdbvpJ+x/yqG3ZXk4dWMTbVP+w6T5dSPvrOfk9mlv5Y1r9eTwZ1/EvhJ/uQtt5ELAGq4POzguWZh6jf0noTQlYkPOcxB/faXj5acAyGV6mMXs9C5d4VjGe7VpZHlwFsB5wDKNB7u5FWs7i9s1hGcEu3snF01GAYWmvtgbS0TzQIANfjgtGic8NZwADTUjXbNRNudrh12jmqaaAt3xbOEK98b4H+aBhX2v+JZN1HC8nqKIDfunDdHEWQrJXannUJVd8SPqAdfy1Aifat13exVM9Q9bzVg5LeeA5UQRj4/65mf50uDcGpm1q1ywHu6rkjmYMIwd8DWVgi8/qKZzde78gDMkkUbUTB9ULzPB6lW/seSG7Znj7XcjQ/dFUhR7xI+a+2Zv4T/62W9rZzmkhol4456WDzTITQ5WKsNTK0+WWd+eK4DykQLY6ojf+zELu7LRbntG8SJ0s1PjRd+2iVcJVLl7NPz0wNk4tjX0Sr5zWKEKBuUej+ho63AkV4ZVp4tVBeBp2XfoECuTYCBD5eIiw0jmPji+GeiVRQ/ZKBUEEALO9uq7RylHubPiQg7n8gE5Dd+B1Nd5wAj897WkHVHEaB32KxS9pHMxGVOQ5SmG5dK8Rz2RMqnSscOgNdtxvu3bPjGxt0VYG8OGbNtVc7UwWH/GHdqzeR3rtYp1QL31ney9cmYurImBPu/n0H8Ci+180hMEIdUm9Op7p8C9SsYaYBUdOp/60v8uFGCWfSsLxihy4e+ika7HYs8E3dyqv4P3jyC7O60wpKO6PChyXIZoxlPFhP2nUZWDqq3GRzXSwLmionBLwkkW6FDNqydIzvD39Va9Kl4VsHNjJkAphqE/Pzza9J2QdUYcp9kcP8Fv2RwPytDGMbhq/yn7q/e0SLRyZj1+UnexhHvy3W2d7fm4FjxCM7HrPPRNpxwYct1m1RUq2mslvF0KdiHDwtGkCW5ymEcQQ1GuGmQm58gONLSYPhyWKwvpsqrUR85nBzRRUbgNy20gDZle4FELZTYzcnyWItaRuS8m2k1qFPzSmulgHsdfgDLoXjBcbiUDsSqjj18Ca46A6m+jFB8FMCWohaTDFLeU9JzTCDFGyW5+ZVy+dUs2iWz+eHCw1bKys/zeKfeUrivV7qiB75SpBw9B1mBIkQuRo2XPcbTHr4yHDeTjIvn69jlSeckyN0QDl8Zoo15x5Dfo3+EZVQJhlt+XV0cZXCORnj2P2N/y/16oSoZhIawCCAaBrEZBhKWgPwRdiLSfo9+9t2anLwi1mbTKV8Yh0wgCrCLsvO09vCdU8EKbZ/YnYYGNC5f0m8koZJ/qSwO+5fbjA+0z4EKOVTqk/7os6UPI2WEfD9lfZzSOg7LvwtHcQ8OIWOvZc+1W9A8MQKqZvVimbjfic4rftqV1gc9Cagbf2kltze2uv8p4mtwk9m0y3cAOhUST5mnvTzlIJ5g0haKTzhyuAiX1Kv6z/wjs3Nepd9U1731W0UJdOPS8+AphhTEasS9Iv9xzRtN16TMTXUgJc4AEsPDxlFGAZ5QfuCR/BMVLtwrE0ia/iDSZHovZUpIMkCAu9edAMhSyQeTDOoFrwCwt9V8EelT62Lp0/PbwolElhgyzlttqmfW2Wv5Rfz7WeaUZouWFwexgncXT9hT6woRt2ZZIkcRd1+EZfkx72hSwegbMDs8xsTutiPmLXIqBQG/hNmbGh6ElCD9WUUPvxmlfjzMEmY86dLQh91XM0zIShqe3qVfg9zMLToUaueoia5JM3YqLA3d5BrG8DQ6bBWam568xoxHL3qlqYuHZ3b+wwoXFtuheYYoY7c3Vf8donzlkenp0eLv7aBNepyDg17Wp8ta905mDYdbcH48gdb6X5fe3xnLyzEhbNHWRR/P2XB9WvVNqf27sUVRQAge1/8/a9Pa2RzVV+S42i4tOuJ9+0gznkI71UPVxu6tTZ6jaulqaOba0gzl7ox/YbDyCgGo40iCFLW8R7JhJg6mbwyrsRtBHnfddr+yVBOsp8gcaxB6StreHKzRWzQl+YO5GCpUAs4uunB5685QC4PkfkwWa9aWpTBl/RqCMlBW7Pdack03PlRdmlmklKeMbf3I8zbGjPqNgY7Iv5H9JtgoVEWMDSATRYizmndOKxMVr87w5JGKNzs2EeEg16z63QzBFMMBFTYkIkz7i+WyCuWdsxumOMw1xcefpuIx6Dl3MgBGpRQZVvUTf3O8s/p7SMRZgrEP6af1iVw9uY+DtG2OZxSSvJ8Iif+T9orUXLkD+7flwcJaX+kK+LDowe8zw+bnyodNLBNegVT8iLAurXQ0ABxucVRVKAncOQv12XC7hBaoZisrvOZXukp4CeBa4dTmFCqCbAshdpjHkRf8jbdCAR6E1gemWV2dUnuL3Sk9bpk06P17qux7dl5oMFyOxBVyNoMigcvdq6Vj9991sfH14R6Iu0LVLTij5eDs8frX1lkGTfC6c4acljdnVTypCLMJgA66NcNcX8DZ3PZA876Gv7Cc7xV5aRvtjYnanjml9486nm7s95L5N90ru44vY1bpG651sFW3HJ9Q5pp6HmgWud4p00ihdlCTSoGw479MaT5Udp1RWyYySuxiwavK9+ISREiRMI+8I8uTInJAYdvQHn1xRio2U73LMGalxfwGVEJTPMB0tZuKrCDcbL8AS8JO8rLbdi2RFhr2sybKL3/RH6AkGWCgFrdFH706OzWy8UD2Zh1jMQ2bRW0b5IuGjxME/6yaqPKci0PdGcclQS7z+QV1WL6z+Ravjk0e0ur213/lyQHGgBM8d5+Ds9fV8Sq7qkTH7GWeaFSV8g9//YXXpFCAmio3o9yRkUoracTsOzOx8LCwcSIXCB+fyBQ6jFNwf8W6D20sAtQm1TCQT5yseKwQkbOFJG2pqGIY0IM17lVUPQXcpB4xd0BHqKFtyCivzSR4SI8tjuwnn7E86vyIR7OykpAouAbh9G/lDvh+CLCWq9Rxj9AKWQ68esXaulGy+ymj0dIqzH0PJHHC+h8vmXOx8dt3bcTk/LNXVKuB+6VhvrmlgtcpNF3xt5N9OkvVNOpVHHi7DrMtnL5KKApk6pGJn6iweRO9yw7ucmpSjaWEog+pGgmgugEWbaUwugz9EpC9heVyhmwjsUg3wp3TudKkIq9XOlbruX6Gxjg9EsP0kudV//vj5ACF06Zdo2tpWAaHOkDSpx6DgF/TQFRdg95Ykd9ArOhZcnjCobcvi+58nuGARcXxZEchPOMDqFgwVKENdmdGXHmSwZEYySg8SsHKOPsbF8qVKJ8bbV9jWEJSF8WH7InLt9qmhDGXP4/zzHVSD4YNaHWvhykWLeeC564MPqHli8gRo5KZtUdIHjoyAVUR53efEKYEJ8YomGuc/c6eszK4S+fDwapyyWoYOjOwQQPKIvOUUVnbcfWnD5xmd8wbsYUXvR1aPUoD630MIQF3reqpLshDLeiOK3Sgr86n8rGEIdMpbtBde7oG33JRcZBetBu9ZvQHRjhCa43Nlykxv0o0SaErEsFnu5nlmKOUB4h9ZyzC/rjnhfiPk1gruIfApu08AivzkwJW3Hput9FoRWe356S8B8RQsCdeHPi2TTi9Qt4LnRVbmmJa0pzRkvP+0jOmvZibxJ3YP6H02yI/CXU3SKuuUQoDNbzqAGpKkMhZm8mUWNwHzfuuNNHr9mfsUzfFRl1+bC2Z2XNAaIqkAmumWWT6EKjYZ8rod6fXWOVf8iDzb48k/d7PVO6VhBsP9DQRqJSAf4nVLJ1NSTnaHQ9zZ7vj6FLl3IOAzjJq9sgm93i0m6d5BlDKgLQ0Qpk4lbGYrB7ygPQVM5qKY31/WS0zSIfOPOgNOPLYPBsfQeNwLsJsWCJrFERzFreAl1P+l/+TnJQKXOrRXwgaFqvsYcym4eENNeTEOEwTuXkfis/7BKBdqBzSAO72GT0Hh9MiuBWJ/rQ0aaodPYbsvv6ZewyNkFgBcc59HKhIEX1z5Fnm+hSWeUdEm7PRQUpzlNatXLZpxi7u5ymWaD83cycQa+diECxYfUWrhXjGvcK5wA7ZPtgn9vpGYi1zAO0YdV1usuE7hdta0YhOmIm+I983uvbLTvbx8Qf3EfvGri1Ux0K8nEteWJu1Q0KSQ0t6OykXBR3uzhoOmCEPrz4pVVpz+WxjemcqPS+lPe7sBjcgj/Ru49IJ1D7yVJJpb5cMocCN588LthjdcDPOZEm7+w7KbSITTcet54hEOhAoJMz1n9v6dSWt3m51mIW4dPmJJeGjCaTaW9G5B2KM37B5S+st2200x4zwNtWCmc2XZRCcAlFUe0/0PRCoia1RaHgRNK8aFLR8caU+TC0z8EabN0Em0tpNQTDJavdVyzy91QP+Hh5j/RHwCQizQ+OFDzA7tkWM8qsGix9hCqrK/zA8ODxp3QPTkxL3MWdKNcjKdeGCVRH9KPUenlc+yZk/Vnni61bbBJRuT7CWA6nw1Q05RJ6NghrmSvYZRBxrXzORXebyFCt1S51guY3Dw5NWXbDGH3/NIf0FvxmVeRBc4TKU0BOSIpQB2jblJmS+a+2R/Tg5lwnM59hNtjLkmyLUhyEtf4WySoSpSZt8Yja3BWZXj74QWUvcIpqVMEv3rxfETN9xdfMFBSNYJMi89qLrVRZJTfaH3/tJeDBQTlyQIZkv5D2up4igztv7/luFuAoDNRNHnKh6L6reW29U57gaYnplmbRcTLL/094gbIFgPkzgvFUjdDNDfcTf8t9MOFfSdRQuHyYsFzFwLwPy1MnDN40Toiy5uFeIi5lN4JaPSjE2bU5pM8z/80Eq/SxwDuVH7vB5Z87M8ZYMXLwHV1jfLWNYlM8QVTQ/9VcJE2zQiLaZ2+Rf/lbnwvjeRail6yZF0p/OOIOdLYx7rLZSI7J+NbXmpXeiMcpqKdmlfW7EEbj6g1OSgaOJQakIkDUfxbjnCKsnuIoGhrJxWXGCjonpvtEhvuEDMbMfT+Y1WBfKrNVMS62PdAoE4wMap6eCe6bCQDp6Uu/ZFW9JBOoO6vCrIlLfeYVBlchcEz07pTKUmLEdK/aYLEBj88h0TDCMfJfz7mEPectNI7OJd5+oAKJZbPwhkTXfR+pLDrZEqDbXXyTassvkIXVPpCywExCytHUCfMh8iGNqs2BVegF346rdrBX4E5ag7KmG7ZBz+MZwQBma5cD5Xnb+8JgiDowUdBjVVmO8Q2fnft0JZtShDAs4rPX02ICXykqHCLEfs2BZgxsajIR5pyPmkMy3d+bjnhhpNfbe0vMt382fuk0HxgZx6PLqSc2m9AuwPYW9V0cgLocxhFECX9+HIOq/lBqvf9c3goQDi72rJ/IMBlikOV5v4hEc3gyJPWJPrYnMQMEttgprH4ZAEiJwFEzM7rgqa3BcXaNBag2belit7JzuraYM6/Ay886P2a2aBaOovfSbMmPLmZfILTlAuutjN77JMDZwxiiinLrzuPKH7q28tBMEqx/fgTMfBLCCoDWqZ3WmZ+86diRZNF0pB88HfyUFiYlEItLcentdN3p3HUiFONRuPKYa4oFsCJ7YoukVQ6DRBbnln08+dNI6avMf3+t1afPCjZxVoY8dtiuCN9ShFvoR/r2VXIssSqPA0caWXjYjPorKDw6q5/tHJfqCrIT1gIpZ6zmvIrUHeuGoAnaC4tfnOjFFwiSId9awHJ8W1yqxuVUx4uxJ+AqCeFZCHeT0CzP/QPRoF5Biofk+6XD9T9JxLgDLWQG0g5Qe07tiOgNVNi3JyqavcnYmdi9cXBublK7P8gbb+WwSUTuLNLBC23LxnEQRZft3vrE6IszFb8LSMeeclGJGVAqYbvOEXaTpn46YKYuxVJS2LZ4ppX1RHaVZI6ymRpHgsFqcoBRrt2FvdvgUozxwrnrI9P6PVViq7F1OcYRNReF6VzaR4uktW+rJvqEPCe1r1z+KjxoSOCbtW+Ipzk5CyOI5g2gCvNxDYp4qacyktUe8F/jW6ASKLu64GyvQFFO73wXqcbJYC7KsvQ0wZkP89p+IPewQ6McToShhmh21+0t2cgzmgopND8bmQ4B5WPK5Yxk/DY8mUq47xRp21NyEXuUWUPquZ4iktxXJW00WV2EmdydQob+sB26NSzofp5Vbmm9GvpNmoe7/cayCWmUWM/kmF5HcV50RrwoxV5V6Xedaufftra+hR9E4kwNTyTfX0IGBZ45a9mgFInCSJZEd3SuQ6xyA2+zpGDJy3Ps6aVOjnVevDKQg7vmh2MF7z/t7+f8ycUHdxci/zpndXLWbLUiM3yLQlfyEACbgEpH1dT/Xr9laacDtMkIAoaQUduWvOTVCifVvwUjhtGVid2ycFcDxc8OESP01xf4OBOJXY5W5+jG9ZpbZI8PuycduQrZkNMz0qKH2+xxseH73tCvJDsyP9xWTDrYBegW+5CvyO8cG/4ATSNCkxBDQHgnbA73qhjCA28EtoU3Aiv6/Mi+YnHEovVn0/vHxI8eWPIt96HFG99E8W71c62ZiuZlYlkotH30/a12qGZZ+XXOe8LrYOjNJjR9TwpkWbUpu18+xjSIC9y8aDJFkP7QaCN0WYI50Gu4h072rAD06xNurtd/utm/GqP9kZNpKETjvFL1+tdbMAdsGhjKlXb5bljhhkBISKJqDpgWIy9b0PTXB/y6L0WU7lGcngPj/wpXBAqiV+vjGp0snffb6+dJyeUPhQUMZbx2VECVGJ1hjy/XrIR/8DLwbZD/Lfkj6uGB83myfsQ5DdNO1cXlI5EF3YyH0ICTUEGPJUNbXH7niW1GaQvr35oOXJbMREOH5Hy7eom5st54erd1xuJI+GfIw9jGwlsmSeiNTe8EKFwG7RvCkmNOMiRwj7JOLwWNElNviLUcKeQh4XBKa3WfIuZLattB7z7kvUpO4dofgW/aLMIdZMrPWNkCP4RAplshPHN0ZzigLAEwMx22cy8axpX4uwqSQdal3ZEz9dNblgxK7mnmoDbNobUpKwpWOYzn1e78Wl198EbHWpe0MhR0y9HfaahUEmx9tNcKtU9uh/2ewq7XINwJRgMctkWmjAYp6f91NOQlN5rL0TrJ0lmOnENLMFQ2Rdix6ZmmLOLkkrKiZ+bGdEAhUzs7/SG6E5U5yb8AdWriPX+BQrP7JaLkfTE4PwsHOR1AxVL1Dreh5xOd/x1sJErwegTOt0sKyvhPXt/HgIyyec9enclCzD2HKQO+iyoLk3EOUdWvh5HGPVlVkUnl6oPKRCziwuNANd01ZIRQZ8ASjxQDZ78WEA/fbG+e+fqCCHR3v7jpQ5f7Seg+B1ZdAdDrcKpDy8+Fuhfug6KcH0qoyOpAO2IxAm/xKD8dWY+Wh/rzKYXBBG5lJQ6Eh/77TVdnM6Z2WURJslEviQD1Z1PR81luSEN3vh4KTcO+UAVN4vbKGqIX0ThJsm9WwJ4f6kzYfy91n4VIIVjCnc8UBON0nbnplbYxIgHO03S5uToTMdncztp7wm+OTzau733q5D55lGM0Lj2qF/4/+H6MgaSB+UDF5jFyPVlBOQL8YKxav5BHZtOVCDBuno3s7Tm79hdr49ONbC0VI/HUnVZ1JAG1GCVM3mguflTAt7+za0JRsNibnTFJof68cBEqtg7kkOxJ7c43F7onYT0gi10pQHWjH6Cc+zsjfaEiTBUido1yiQIoHIh5uWCkuE22P4wrheR/MAVrDO2NVqZtMorX+WGU6avMZqwWZrVEJEFCp+EPbzmmzjtnlvkckNbJwDb3HXPNTJWrNDSbwswbL0jpsS1tRFgdlEUgq3tsa3vpX2Q/+VKQtgHwa/onQs9rS8X5DvKHrT0WEJB3s+5klhQ40/zE4RBQEcpkJ5ZSpmrYIsf9Z4ThZv/DKGrqB7JtBvx5kkIDnL+Ys7/HRi/nvdLIBEVfjnzw8PiK3p0Wt6wF8/7xdaj+ElKlvWaU/Pqk/rl3gDKl0+naqPUs/wM3HuhQYlOtEhQ5mleMgWpVFld8eQsavOgIdsLaKK1TSUq4muEzBLGeQllMLoEC8fuQhs7xa/FdYLpTA3qs8AN1edPuHDRsMQXHRCJLAefdSA4O5vq/LzDVTZAptro1u3rNoTdFeZ3+0CJyMNB2qtDAhSyL6Qje8tlAvwwodftdod00ITsGP2IFerwcRRYaX1LxRM/3TRA9JEsoOFV3VH+nsZZ/2MUmAOKh15GVT4aZoLCDHxgbM/44IqfFrlkmwm6AsF+vvXVyXj67QBnXy3U5ghI2eCaLlx+WGX55RgnpR/Eh7fDnw2ucwVNWGiKl2e5NZuntLyHHI/UPzOWFpj4e+DOMGe7vFUvjRKUAF73YuGOcBM0ctOYWN+Y/ds6fOHym04OdmTq+zH2PejeHyitqWjTA+d2lNc4vvnsecXbnMLGYvVXEDBffZXGArNR7oOW/57au0W2ITBrxUK3mPOXFUY28zHiqV3FyY8kD8sf2A4xDzR+tiZQaB7gGSEJnJRvyQ1NpUAXnvt2ODaUP8lSPBITy7k2hR+JaK7XrMpy5XKWzz7jfiA1LbspbKg2Vlwm9hYTFoXaWs8Z0bDpiqyW/p9mrXyf0wVd/CNCsOske3+BIUeOBubn929ZxjoTkv7pHXtfxdPAZD4FUgG35VcGiq0PA7QnDXBOcscA1SstSnjHUtRnKNxYqYi5A5pyC9HCeN1xPOPkqjlvmao8QQsAj/0wdRKdMzQuJX0tfPQDU52TJO3RCjzpB84jOUHQ6Vz+uprgSDECkCcou1ttUIBWxejaR5ivbAJmvkoeJufxQYWZU+zXeao8YKJBj6SyA4Sw6GOk33nEHz1C+eoa1LbEQnx0b+yEu0ZzdWyIOXDnvJRurxX8h5KEU30eOHksFl6p+0L82kylLDZOemQzP8kqp/ZHPuEu2jgls44pCaHpt/XuLSuz/cX26cti5vS+5qEWaxBLUq6RC1VoRGO5+Bi/E37Mfv/CdPeUjCjEqIYBpy/8wj279bz/ALNR3yID4QSXQRKqWNekKlap6bc8mtdjFbISdEzHEq06nTkog4luI+NtZ35x0c2wRm4GAnrwe0EvGy++/R5FGfhNNLtOIVLkojLs11F45gbYTvlHF5/iN0k6gOp29sq99nVn8779DDAPkgUyPSLCwW4paain8SuvnFpZ1SXc/At3prIWKGJHEU3VWZflds0NvHjjnpDkmYbf1I40pcjr+HXrwzDie/wVCMzVv19hE8sbF9p3X6AQQjcIBkHnEg/lsmdMZEq1LC0AWdpx/QIlJUQMSiOj6SgMBKSx4SnlMdpk7nohxH874hq/moZirx4ZTXxm7jwycPa2zE4pbap5eiOtq4Cncw5fKJ5QnPeAKZ6W2IP+q0TTF7VSXDtr65DlBSbOC7mypCW0x5TRIc1xMq8Dn1ddYAeDgp6cR8m1VcfBmSmzjWAj9VY9SzkXiKa2ZlDk5LNKHUMzvABZdZKShhKPemgxGI+/L5/z2Hucs4QDbahvMnraO5hnNvehpUN5PucMd/PBW+/ybH+PQFEzyAfE1MlUxyBaF0bI45HCDfnyQ5Z1iNU8DtlGOjYV1T9tuVa4he5lCMjKoEKx6j/+yU7Nq9iNqIqpU9Oy8+3cfJ1JIl/X3CDgW/2Th6Rr6AkHJp0CfR2GxGFXuVzgymFeFocOBBJYqgR3dVM6rA9B6SSkjmOcVCtfGWD3ELCPPM+kIPK2WOva42LdJZ/cI9iJyVxfXXEhg2elZrtMNbGiWq4lDIYj7TpuI5MnBF0FbkUcYJ9aLeRwKiGPmc1gchZ3J9paR928CwjNoeJvxb/M5DmgTWM2/jaIswQm6Iz7kskUJv5cIhCi8SZV9pCxZ0FcVUx6z/6vZFBg/anxT1AIQVhulf2wcvPcQv3YK1UyZlf5LeT1vBqXV+zA+/IJoaDgsnEc/jn10aL04WClGnfV2Wu+YGdbSUUcXY2ANKA80Hv1/lHPixShloV5GQKqTcDq2Xj82jM8iATi/t0/Zig9M3+7NbIeQIRzEYZaBu0rzm4SJYB+99bGqOVJu4rcRItz1XIrk1P7B+P0okMOJ8wgsBxJGThL7Mlpf6mm9i8b+XvC83pft/33CHsgv1+NhkGELxnMJeBYewMoj982gLAZx/RJ8G4Ss357iXhASQD+QxA9kL/2qJ6ZlUIXhQig/2Sk7jC/oR9cySrfBy7NUiKc4mi7MHER4DeJu3GKrZZAbhvIkMz52mhDcHgeYQtlwkx3YtAV5k/RvLkV+HjsSbrWJ0SAAiXUjOHIZfIYW3F93hKYjaIB3Mk88UdpuKgVQDcy5WOYvB9EhLWGvPm2/X+HuTSS0o8Dg/M1WiByTf/CjeMZP6qZIgSbqBEiE1rw82sQTZE4MsYMH2BgfCaVP0z0t4MCX2DMjflRSNJG7iJosAJZO6XKOjgJRNJH9R7+myKtKMke8MfNA2i8bIJwVX3E3JRe/UaG7IXW8mp+eF6kcAp0MlVi+vBRXMsWFFbGSBZHgfF5sd9QrRdKTRQ86KQQLd/d6GWVT6LnXoiCEAbaWUaHvZ/LNoodH/E7uPOotHED/jQ8mYJ0mWtvrBngX31vZDqVm+EKFqbXi9q4hU/OaxTs2lbXZnT/2j3JsNka9rq5YNmkH1YGfJFuxHxR8fqvXee6VD5FLnoH8grtepd2scuL8sJO+pds1oJW6/tJj1+jF9wL7CW1oTTWzRIXRNt//jtXdRkOJPSlONf3SwptFdDfbCzGqL8laSG1Dpv4RhOby+bVUA45AfNcccD/oiX3cO8IuPukKTI7/NMWmPq3s3S5ype3lME/G6LMVqvfI57ugGfP57doF3gPEXzDWsPgm0Z+7Frb7cRfjS1Mk9V/W7+GaRP5piybEWumlMoemEvyI+uSqUs536HKeYilNSe+/ZuyAk5Lv9CJD/Ztm94ucMNMz4NSMubTO8YNlJPse2cGng7wbscZvUoahDRZeePikC1xSjTMb+WdRvFlvh5eRVxpAkTdd0PV3WppNtV7zbNebY9KrModAJVt3w98EoXK1J6ZJWy64OnsdrJkv9brQ8J0gQJtfK68CuN4j3/CAmXoymuWR30rh4rGTFJoTSPYcgfMtvfD6W18IKrEGXIHdGl4zIjlsFouOcztLRBWPZBbravbORNeRJe2P+hjc+sgAM6heOyZcC26tiYAyitv12/d2a59R03dwAluCYTXFCFpHxDMb2+x8FMpKI5hWVpuXgjabI3DQ5/ZiAO2K0peJk9N2fKT0P+bW+sQJmbW5yke5XH+u5Zdpdj2vLxbFkWQYdg5mDv2A2B1KEJg3J9ydeSW4b7MmMHEM2BX4/4RULCdmzgc9gR5b7IvjgVxk10hgJTJD5dirWWMF8LPrUmTqAZeiAouzK1uhVlFIuU2FQKL7v1l4cAliXYaugfwva/g6WA2TyH7B9OXjKRjTKIVqf4zfEqfl3RsEgKLTzXHyCsZAANvlgjGd4HzxEjfjkCK5gha0+JGuwMTHOFg1USRFImM6xvCTA/OHaLZprhElMnLWsORpBRCm6eP6vsq85KRwenOYJcqNiRd2BaUmAPuDg1yhWwxVti7cxUVs0oLlZ+lnMPGfF2dp3T27BuLOzTM5O2OIi8tHJ254+Sk+r/fqqntmOgj+utAT5VIqCBVzSMb6sGfc5ly6ouSCuJi1Cau1tXlLw/1z12O8wVelgHSKRekG7ICvpS1iPjfb6eKMwx+xP8yH+Cjj76khodnfhcm6bj/8ajPBcwMDNWnP6v5h2FPD0rKZVOG58Cn39NpqmefArBWd7c6CZejkpw4nrx8rdZbxU830jCww3grOUQE9TY0gzcrNICFCqCCUpmV41CBosw4V8kJNhqVMqJDh0LcLfrMAV84Ai7ypyAzjVvvIMluAEiqPGPWKYzH2Xljc3S+MEwVNP/HqvOrr8odThwpAzcVp3WJaHvTv0JdM8Wh6JlVnQBO7HUnyEv3t9b6eFg0JCtmAp2O3CkWqEHSW0Q5wYWhABAz3FcHCO0TqXqKIR/mnhOrlknrMReBfPrRjWVgS8La1XgmzE+qYtfi7pOc7TX+THSJye25aHK4JZFmE6swINJzTCqeDC4PceBewOC+10cauIB00WSjtF2tY+3eNuavsImLSXtpSxJeoYYZUl9ObdRFDmbJjx64IPPCUxrImcLcmrXJCxoGIRRBDl/jC4ZP6ufcwis138MnIeGBGLaPFO1ZVevUgfFq3/atZmx/QiEmj/XoE1eIoNURW1n4SDu9drucNCNUTHcNFtomlpqWDxZX8fNP4JCx25e1IN2pI89b4d+8YX+4OKLOJb9U6xas5Gpq58uLEeSyk9rhOfR4+2JeWPWSEUAJ+zygiZZtOv3RAZi7LwQJNu76wCd9ojvpIlHRuTSdcqHv2psKkr/Gr1dw/cFqZo6dZTi2H83OQ9RX3Ap6TJIeh2JxFwkDb7c5ACfbC9f7HR3b1LPMFl1hQDrdUkyIkvd9NScYMDpPWfzXp+cLP8EAC355jaSTEo/fMsMQ4ddCuaoNpq+i0Pu2QA+MMvFwui1LEnJluF+7s4KMA4JyPa5eGbLmyLZV4sb549VpEqXqUH6pHYKZUq7sa+edwD1y3cZr8e/T90Nb6W+zRb3nd8jP8BKXVuGsrDSgcnUdOedgRkdwkHZ9jg4T4uxHhljhBYolW4iRXS8xep4Yu8/ymliqqzYOiyWXdZ523Y8iRyVa3R5lHm0MU8FO3WA8VEDDNMM83YK1KD2BqNOupZ5oqyBvbvXbLaVyGUYDJbmun6GHg6Z1quvuM/NWJE4A2W1BA+pJri/OahH1si4soYFcz02chOqHVQxXOONVR+Dg0bZW8DT1rmDPc3iprluSu+oYH+82UPYlw5ES3zhqPntL3bjjHAi5970sngMySrcwB2VoeZ+N9i6Qq5fE3a9zpEhz2mBm6u6LL1VrVwWkd1LxB+81qakqNjR+hazJTGCvlfBLfWC8NypdYqT+Am2walq81mWydfJa4zrfirxesV6o0MsySdPPU3EX6FVGmEzPDXygLvdaSiy6Lwe3gMYL1ReALRmcmehSdfTjd9ESsnrk3cu9CzmzjCs82S9sugKOdLHm7sW8OAN7/tqAMNGgRX+EBsyDeJll7IEwco7LrvfCeschP8rUIMWouzWbCHXmeptKxvdsW2KYTAAa37BeuiG+IjEX5IQyh+h8ahxr68fQEXtZw32ahxY7+I5NPZpcdPfUVioKWpWU37tT3EcyA2GC+rx4tXFA+fWOY0OeQ1o0lC01z91ze4Npk1WqP1i/HI+BR1dfM+j0ueZCvk6oKU3HRnV9y9ywOjQ4ZNAeC6VYV6uqXS5aApgK82rbST27wvvnz4WC33dvzCoBl4O8pd9p6UQu/zhm22IeoUPJQTTxo4u8KEsogBwxq4d0JFqmVl11dSPVU2YRor4pzZHHpi3vZvwUhRrcoIui/GWbLuceESftcqRhHG2IfV7h6aoWiZURuWZxjoj9QqF2P91PCK1+fGSbDqjw+if9fhZ9nMlG3NhWrmauaDtp8ZsR+90RKBT5G2zy2+gsdLU/Wa30t5etZdrCxoXg2/phlouecP8vtoUwx+PQ1MmjLx5Z8LaXrL6heH9uh0ASrhGp8/b5OPHaA+PK7rcTXgo0dXH7RQH0e5XvBs6EhrUDpPJYqgZxSqNULT5HL3lQOcQEFoIBe3MUX5A6va4SiMdsLDFX7VkSnsYw9UHseCPZSOdIFGMUJCRE8qJogfxLykhcEOTwzfrrfgpkBlBW8eHWb7ttx1qcLZGEvnKLqI/0v2BkSJKux7dSqrBlMvpQU3A94lNCsakkqSM4i78XmjnPFT41DZ2b7ufH29ZIn5/Ez5kSb3F2b0V2E/up9D8ULnAMsFcCyUWnzbV2zc04ovjzAHUjwjwOxL/5w3DYIP1Mcuwz0BxIE2teUgVZCran05ZCO/Kq4xdbnzEU9iYUwz3MIqh+biWVKkFu9ng5i7nGj01+rZpv3OYvAbHhsURy6fWDHSEIsE/dY7BTGowWhVBJd1azU+Kosn1drv5xfXBgT0njm2WMUPODRyXVlE2k4mD5ttfPeNEznU1DlIu8PbxEMOvOfGQKqS1w7pTsbZmhQVlk1H+q8k3IY9BStsNoPy04zKvBWAor7v4MBmOKa9b7BEupCpKDHj7Sx5Kcatu/qux6DX6d6bJHwKsXNhLtPEu2O3WFus6x0MrfAYZ32FC5AA2/hCYnMXidUUyMaz7LNtqhXgZgVzrr5Dkd9CaEYQJmxDRlL/wRpQDHUOOJsxzNfmZcubgNVltBy58WzDflFDWR+HEYXelZOiClZqDumwPvpGSoyU7tPuwOOGSq5JiURYn+/sCOwA73thQgqmCiY/eGiWVEKl2Wz23MQKeV/QIyYYg/W89Bm4sc6bzFWYAGMMMJVBFElrIJoqklMKzgrn0rmwtrrsmvsECg72pnXn6wEo6N3A9657WrMCLUjgXDdZWbcH8xQh2xGfbXCb6163aOPxCkxNNydr7dfx6iz766kV35asafC/obeVzM3/JIrC80bDq6FE5O592147OorntJweqSJfRs5G/tqkDoHXfHcyHgYE4txcNhWzhlEuJBu4fd4C6YpimlkvbeTs/yxCkGBMrF3X7LiKncUhKRGOjiRrxj/Gqx7i629AZShK1sA72CWIMenOiHQo90U2BD7twzBIkdavpZK6TZMVhGc5bX08k5JzstNSI/7Wuv5qUJoL9V0PlT8O1yWfrpjR0uQVbdvLq5dGQ+y2OFSixkxM02K7MAjj6GOvCuJcpEbsEpsWT+I5YgULAw/UNmpNdFdg/pLb9feDTvhyh3RIANcsUeLmoGd+091cAGZxdyZCz7xdeXoEdPvIfLfWRw+Wtcjb2Fptxi9A3C+bejIPVfeJsRi6aW1AAR7Wkul0CMJm79D0ai/fs0v/9J+kHXhX2WL8Es9RUl12na//I3RnfBMYJSeemiY+4mUxvEJn1fas/DI1nMsRffctyyPo8yr2fUFlGHwYobfGttmhaOU0VjklMNCuJ2p7yQA6BaXZk+0xRA/mf+nIwwpxv+rcd+PxMGPyPD9+qpMLyLDTC/DyjXtyQ891D5t+HHhI78UHs4xBcNqjHXVDk6Na71vvwXCRvExS20BSnzjzdVIRKmAkiRLmimuHaewXad/xv0cCbxqAQhrzHW2MgI4sMz7MzAXeyoHtXxorAN8K3dIIaQV0I2ejtSXvP7ZlU8DDmE1/XupcgDWko8mY6KuvQQWAZiHEQ7ZuQ45swwfgXnJpIu9H95cK17xTGh0q/EVvW6YNAsHGuGtxarcvGEpmspUGOYs8+U2DQ2NLWYOZTRs1OpSnHOCdaEcI+SPqTKwhAZVNYJLApaG8GZrZ9VklY3UJLFBCoSJmpB8rkqZXO2OSXoSll+oF9CFykfYOwt/XwLQMt4bZpN5ENtkkkSyb4JmO34Sv6XvuJjpqKzlE+CVH5CVtnFmBF5uNWJf83jAm1ulOVNUm25oFIvWD9u8i7J15iCmFvw//eUCRoAOedAqD5pmz6tsYkLzqXTOjvscXRDPu/blcLfbF7rsU3lQM/hc1rZTv2OZ6xojdQpga+J2Ko2ZCzOPW42tQ/LkFSev+NARhkq4/Nvxa7BYXQfGQo23Di8tId8CHPOivPLfzfO9l8EU9tWUDr8gcWB66op8KfPpl0PbpqliZUDVwJMlVmJHhKVrkdMcNwUpgtstJuyD+k92FaN6PUh5QLrv0WVWMHzwswUpk1aCstX99ELGXImalOxTcEvT/qensvmL9o0CnugN+cWlpvCH3SSCZMdQhOEZ2vEyZ3meKedxtaS+w26alxZGD4Jxwu85EVFUhYAvKdUfpPOFAJwX5ftjxYd7ZN2xK00eF7HD3IxnSZdgZgHjATWqEqO87mGMwA50e5lgaeMq1tLLLyCbVCBu5r8Ee2W8pUHTrIKuSUtvv+SJSM7AwtJkxClcVt6zG/WNEC48/XPJ06wYZVWcMzcnF7NPPZ7wiFeY4twHcSOce4dptzKUIy4brcbptospN7tvfOFwNrGQ8k46TryxrYf//bjKxazjFetpxvgqchPvQAH88+dFvfLXoEebXYdrHdHvRPkwYXE2qAHwAc3oXSJGz51IVhPlRXGkykGyz21tTCSwuKeiAaTUn0ttr+hoV6j15zFagHkjZXhlophsEV7OMNSWzkwcfU90S6i+XroTGJcVnU9w9s8HsNZ5UNOzr69eh7Uxq+I365IoJY2C1N36E+9L0eSEdCfeQSej3uLQ/nDA/psNtxrkcOgsCinl5NOGKtZFqY3Oa947viwrqsLIrjwZ3yaYM4SzHH+5/g1Li7GemwE1Oj2Eorh4fCrtpr5HTg5BVceLawHkeYpxZ7RCQJdl5KrZQWpQktVtT7qt6BpaFS0lBomF5k2ZfHSPomCYOnXnEiVN5acZNyxwY4lxeIvFni6jry6x0B6MRnPC7TbSIVIveIXMngcVkbadJOsMIiyW9khnWX1YMxouJ+SEGfJOEo9SfNuwpPEneldLSJkv+MSE34QyhTAI0THf3iqHADPxJuG179Tm1in3iQZAqb2XpJk4FcLOSynpmi/pF4ttY3GZGMZbVkF/SqAABtYcN9+pfwSpAUKpZBf0MsxZKzTHtgF4GJuAcgG2B7i0Fl+ZDjKbB4UOrYAQaEB6vlthnwCg21EV2KLKE0jpjEi82vR45lfwkZhosDqOeS0zIQuUmM74xBLmqHsSaW7RJ/jLXdzcl9KyC9fuTGiIoVtRjK1EbBcrSfEvl74AyKhHoTMpQJak9micYeMdvqfSrjofi+wU7Rfomuyh9ZcxV639qDafOooF3rllnNfvfqT9Qjv+X4e7w4JsDcplmzv5H6WVa8YnS3mir9n8xe/0pJ5GxoLCpZrsQA4QBqHGMRZAIEcRvflvtiilcSH22MDbV7rjkoyje6AbeE/RqiQlgIUMzCCvTCqSUfNvuj/hJvtBMjyqmHQuviC1BUDNjRnqoM0F6CDiYvHYJK+92g+TwGD2qIlXaaDbOlwlHVyKB02DyW1PxGdJK/TWDigoYdinIFjK8blTQwoYioaaeAk4rZ4G0Q86WSG9zzxgi7Gh3KTjYQacS+8fcrhom7g0Lyq/K6cw9J2ngzfklD+6wtVRus3ZjrqFhRC2prEPb9IrWxmGarmAoI5wBp2OoehEofuLNys+5qLpYOsbdby2iL2bqFtI/ddCeYS/eMRofCR0sLxXLWEa3bW+iuMNNkZMnRtsxH3ahnygMSPUpPKcK+gabE2mCOXNLzOnZ0Mla5lyQFu4RMBeRbHBSz90klSCxKj391FyZnunKyDRNuSz9JGxJ9hbcYCV8a98kAyr7EvTSgczXF/yoSVRl0A5Sj4puTmHOKR1YwYH4gtk7ZwfOtCnJxZhyHnMQOamO+GZ//I8IDlTzknYitZSasqaKTQSfbP07nQZ6T9BWFaULk5SA7U2B0zXqjqoPyW6SD5Bgk4TeiWOJqESIAf0taBH2mq5JVhT9F/T2Ug9uHTml5902D8xjdChID221LILJO3OEXhr3sYRunv79b8J/WYK9FlBwFP7b1vSNtFNQ6gv0KUaYh1z7TD62EdCSTrXJGwxEOpbbT5jaCB+28i2uzuJWPDqL4LAmxpPkU9B8vNxbWuwXmUPVPcr/NoyCu1rSuiBX6fDD5Hn1hOjaMiBEpZz6UR9ZcxewpLC/5xLVP5SOFAgP6mJDc9twqBD1MZeE40czNeW5J1PiJBY+v3KcpN3e5U0yRndmjb+1I5qjXcXFvO0z50/p8GIdG6nb+fZQyn9xf/gIEn9IREqw3l7P/GYg9SgjLzxZ2LP4+pZqlGk9PGj5qmlFMf4zVMqJ/Gywy6VfcGyWIFIjGz/IIxEqYvNt9gJiL2MOoszR5fvdJ0wByX3N8IRika1TW27gDmhkYodS/u/7u5xmt3um6fRnZ39KPP1V7j9AQpUjoTwG55nBrA3vg/zqkPqhwapOueeqqWPX+4vfvBZ5LFd/8Juxpji0iO6biwLvTJlmpcA4y1h0xcUinUkEuaVsv71RallnBMwIP5aAZ2EaEB+KNr7z6XQxoPkVeMV/0W9mYcKMhn4Ac5NkqCifZcGLnCeQh35CSWGBsR5FFdIDbKipsbTrgjRZEWnL1rzBHHdMLC5SVgw/uutysgcAUHQpkwlFYwD5GrPyh4jqtk2LnBlw/Lbv5D1TKhRNLPG97oqL6Wdcwl+xfi4hjb8d96KsNMHYlypOzS36jWUOYJlJ4MUBM2KXUgx3IjRp+rouoEOA0PNHP7THtLZXOSB0uygjOH32ZTA4446+IxCLjCr+hcDesAaQV3QA1nnmfpfEUEl1Jg++7ws7Nekx6CdeNJgm+j89+DrMyBtbEqmk4pVg2nE6dU3TyPSNPM9f0HgYqsyfNkea8EVuNO5KGYMxjYfbOfD669Um60UHDObfgPlgxZtEdEaHo4gI9lNjjplnmDBMwFWqpOq0lprgB69u8UBAwkelQkcK3Wa4vWl6IqOsBVtRPeG2sR2EnmaszVb+6rAhrmZLynNHVK04BSYbEXSs7z7SD4t65cNHNUiAFhg4GaWj8JkTzdGAQf43+6rPJJRtAkg9aW5IwXJvM0atBMZZy7Mh0ksrFwfp5tUSvR/Y2J2RtaGYzI3vIh4QU/f5h3k1hBrdT0DIdBaiRKF9q97SQLKTLCZi1igj6QcmSigbT14UKXod0x6JDzBf/moApMbzqDEz+3RjOkBe7PgTP6XczZIuPDqZTMK+fDQBeEESqVhpckrT2jOKumnUvpjz1MWB5FZ02KuvX9G4ecIPOlnwHUQTTztO6XqJsNOm2HniM5B5xRIMoKTOnwpnIQXVuh63PAsD6soYEjTRuv+EJ35wv5fLuLtpXMluTSFGF4SWJv0kWB1u/+tFuYnp4VgY6NGZaPTzoZKbd3ulLE4/390j6Wejkjl232XyFaVbMdQQjQK9imnmfIscmISsZeRPI954WR1svTT733Ea6dAnNV1VeCRv2upgois1apFLu4vqVsOBpGJCbfGB54fKeHHCXCUbpeUZaaVfLO9nkYvGzJrvmIL4ZhUlBTYcz3VmNBjDkYukLDx1SNKVNtkJQHBPW7h8TZyh1qoNH0F9fUAfFo455VV9LzhQC6pmAB7q7wN6ErClnOE9f2at+YNGjI4mtIsW1zlWTCXky3jQyLCJ7yMtxdEjYaUS0vl+WHRZLMEFTtjEQCFjKP2rBhGJGh0HAxFTxbU8emDFWKndFQcEhAFcceV69A0L8NMQwdjgGVZbAF3759CUbbefNoMJpHY2F6+v/BfsOju7TY8OjXUFohn56UkehbXhGjT718Gaest0tkK1Hlf29ZCTIbPEdq3gWHB1DrC6qQcZMnc41bdTC/rhGE01xmRktQZk4E/i5S9rhE/2AUVS/EJ6IUGpZMiQGOMnzkor2zJgTm4uwqr+5SqY2donHCdxMUX+FHrzVaIx6AZGjt4Ki603dn6FnSPCLMUPznfo78GOX5YqkemmFyemLqIKWlL9AipbdSN1g18SIQyLNCkgQTv86GA0U/gwTKOnR+lfWVXpX8LoD1KkMVw3h2wblyygCYlkVFdXiWjwq6z3qSU/l9snxvd4iYWrMacAp61mvEzHyJ6FyZRMOmFujjbtIkmV4Q5mQ/NO4d4jZfjO9yxMdJ03/laTXziP1nBeq3PqsdfteWQ6Xx3UQ/dw6/zw4mBdgLugWJiIPvzPlglSPMEaBIz7L5zALYFxR/f5NVlznRxdRHck+x8mhmcCRHHaLJj19B94lUU4WhzGQa5X2ShxE6NsP2hFUfn1mCKZziZN+TlQltM+YvY1FSMiKo+ZF2/BTL9KEsur0TZkqsY99erOeUmoHI/04sQ08JhVo/8aFw8PFqD2oagdnzw2PvcmDdEkjmRC49qJEGZywmEZPszwCv2pUA8BkEaovBKsL6+HtlMKqa1YBe5nYNvRiGwIGhVD2JpYDnWkVPE7cAqwsaBWBgkJGZMnpTwSO0zOQpulnL6OTlRYi23o4fvZFhk2PifViyIsHOp4pKj6sXKVgDqiB+LCB3MKd6IaqNK9lhuMjWQerc1V7RgsvBWZtCXz9/T76OKzv+80J1VCmPfJbRIxDP0Bkxl8OopmPdtVm0imvM4MLXSLvQAnf6pXpfi95tu/plglMPn5UzowLAbcSu3iVcwpdbaWNdfhzqahH/+ELG6ZaNi6PnTh89tQJgJHXQ9kLzTxpcty90mgaNHUxsnS43FMkN8pz7e8Ko5DQvTnapuUYBWffjP6rbon1H+o/q/sptryeehYdclZOWB8WskSeDsOLknvb1F/9YhG6CiOTwgKrCUxdPeM0cSPtHj4Hfa6f9kRAgr6yPz9a0wY+B2e9KPK6AtkH6ujgVR8mQT72K1+XMnv1F3WnoYiy1pvitSyK54QVziHcemRpxQUS+2mmTIKKgEMIZjTQy4Z3BRJ9HpkF8Yyo7ArCsXGAJEAhSRrZCGo7LSqvTHfdYMDfaDfEioYhrxpFewlspZTaXZvme2c18FyuCFAc2EA0DaggtfDXfAxy2nqmKFiB4DbdTfvux967lhqJWQLdX4w8p0cjts9fTvwRPY7pVYLhILsqJ91z3uCXuu+Iin0nP5HzNlXDGlKDnsK00vGr6XRd/Jmb6Gdp0CGgXGokzhxp1rj32ZTba7HZW2fJakt1HkfGLZ6mEoM/rSLb76QuVO2luGPPk3R27tCdiiwyftz0HkKzgdPe5fwoA/kw13cs9Y/nLBuorlZi1qv8j4ihOyUlabMtdOuQ3jRqcQq5kuU0Z1jpMQKA/T4a+RRCbzRAabhv0sfNVyg4Tj7is14vcQMzeT5xB94MRELg2GGXWW9XiVH+Goow73EMqQqJRNX9dNYrAil/EN96+Whbtmd3jxStyNj2fffQ0FDXJjzPXm68Keb6CB13UJnSAs+5wEMs0bzh7x/u8whOoUqNjKJypgRT3IzvBK+LcoVs5F4GBY/+0j6aAOkfc4iZP4g9OT81otUMUKw1Sb0QDbgLLgYJIs+OJwTjZB+wcX7oR7KOlxex4h4MwrDdQGRLKjvnYKTBNgyXJ0mkUXCRc2oluu5ZkIBUqE6tOoVDSl6rMP/SowiOgmUJ0mrDNoe4m8pucBIKKo4wARRnMYR9ttbNbIdu+HcZscma3wI6qGbCmkYf7ljsiEpIqRhIbm5Hkn/JqCe9LDQ++G8BxZZI3jQJ2c8yjlszoneiwxKnT2YDIT6gYHkHQ/CYePtbb0DHASZzP5zqmgXbVL2iTSdkzZqs3UT5WkJT6le6DlBsKiGAJ04LPZ73oFy7Xdo+rEvP8hSU/CeNU4pyddNHlNPvLBUDI5RM0ZDeUd2rGwYGg/bqn8R/Ds2+Ywk9WY94ejjGLW580gde/Aqb3iYjyoYGTceQya/3xy8OOryJw0NjYA6O/0o5d3vT2G3FhIy4M70GMye0/MDRndbEu0pxKczDgnSPY+Sz6AMys4c7tBJU/FngjvLG7Ilbj/B+VbL08ImnVNRs93SGjHPh9uk3mvfd4GaDLKIOVnsgFI+xd3VIKe1RYDoDPhrZ+a5fwK6/y04h0lwYLPX3JvK60jtfqNJt8nAnm68SHYcAel23fuRJsUEgtJ4Zn8jY67J5ZTPukK2Ur4IQE7q6Goi8npJBxvZbGoQtOArJ6hH3U8xrOJFWMeCuutcOVvTQ0k+mjHBOdbfgVul5+lZRCi594Zp/495JhqRZS84UOwcgxaWQa1gsTZ0oP8OmhJUE3f9L7pMidfc/2cYymhkKpAS0Th8M13/0JbvrPfisRzGlpnTg+q8K1gozBIC1hKR71SgkCNiqT/SdZD2QLprIqQTK8ZgB1bRNdZrFBC35hqNCNGidwoovn5qmyiQOFEc5r4HGiapVTEilMpYDe6L9wMSA3LV37OOj3BdCP5N8XGTrsFnoy7WB6mGD+MX5wL+fkkjADqQ4iF+a4M+fn/z11PXInSH5HgkfcOc5XEklSbwdYv8sX41weeqBF75Wb/62xNFhH0lP3Wd3c3oZGOBbWyP/lbZRGh8C+PgOJm1jFHarXCsGC3k+VgMCZ4rRJsTvKIaC3BC4T0oPs1wAnuTL48KbpPf/WunnPdrHU/Ty3PoFT2q4RFXgpRttksI/NfXV5rycrIlk/ioK4VH14Wd8JPL6/hvrYzkgfEoPjdMvhRnlc9WNJMlxELYJDRXebarkwqtNWEY/vduP7G5rpXTZkiDbiRTJhVIsu9JClB7jEkvieveWE5lKBzDMggqwO7695ovuTtPn0w1UpQ4JoGOn6L3f8QXpYs0mZOcVKFfUA/D/ZkhAKzTRsbHF+4MuMwBcLdvimHR+9GARFmchVonozyCw9y+nk2WVNg8CDZxYoF7QZqfO09GjoyfyhiFAxv6GVWmeuZxxsoTR3HJaaKEPEUFScsphQclNWLUfXJ+pBLsyz2KmAN82GtCL3iUqA6uk9bgDkJrObPDvKmouWPQ+1YMSvvXQz8i9aq3z4vbo+E2i4/+m950BvSTJTMNEXJJo5bGjgSI50eLO1HmC8kOlmd4B9CpZNDmPPY0yJblogGBE3hwtEzCsRGYPhuUQK41do9R416D+iEiA7h4S7tdx4v6evctm5AAsnIL6mjQr3mcjIjXB4GfJd29xXD9QWr51ik9QOM0G5uLYMFQNNsVI1L4apcjvBPidvXp6GVPHWo3qcRnw6Vl3iy+dR764wSHzLdDoXNE8VzsfhRVeLYkMUOokrxvzD7ZQLAE0yznb/YJ/xPK4AtV3DPNFLGr/HxrUdRTnv2eZvPszYjKolP6eFvPkAPT32BvD2XuUv0MR4vcW6w+maz73Vrbs9gSRYEPeCycKOB4agFZRHhHcE1QGnkMp54Uwe1tbrTGS9VUEvPnQTdN01aNm3Q/nwheglV2PYaLJ2DnffS/AK1Xq47Ts+8PJK8jo7tEdQpqHcdaJjcCgAbcFi5rb4ncgZTZ392UMPYMrf258YxTqxWPRtQDltNmSUYu/C+TMFEaOcaMOTeQZw8WQxCI7hRyRVT6TTrntnYUKgNKshw8kRcXcxl04XmhA6asR4+gX4YZZMcVHxRqJPHx9MQV1EJhELewFhFN/LAzgtaosejYvEjXJoWupsRkf1DZHo0gOl0dqjT+4hO27p9Q85P9lqIqMyeUy+LVMX77IDWOp+hrO95g/29FfX0TCw1qWMhtLkLnBg38ZqavB6Wdiu3bdD5Gb4DZT4wCAskzxJGsTxk5OnV5lYhRXTdl2inlrBgmOimlcxbF2zhW65Xa2VKjoi96qPOnEsi6lqW+BqsmHmYYvgPG21ph1kywSZP2vfJNIzhpNJiRQxsrT4FBAcidRd/hWdUD1+3c5SjCjue7fyEaQJYAXh8Yv7TNE/jykg8Ki7KG7YBEKHPCPMhdAnC8icQB2oagcvOVaFAqd0ysqbcUYUwOsQ4ArB7p4E6X7QR/xNjYinsufS3jjiII26Jq8gn/MF9ZVuNFk0duR95h6M0g3Fh7s/l0CA2xDA5cp+Loz1E6gii5tGm3/j6h14wm4f2mtIHHWlP3yzrasZBVzKInU3ptfc7hp5xeDH/YX07LZRDfhf9dFss3T8X96CI3NvbAWslJZdqBjMRcRc7K7c5y5Lpe92miMcePFEhjqFbv6dePRj/D6II9c5oieSXdnsLf+Tt3iMMpGbXYpfZUZvmbDSumToqOjWqQXULYXkB2OpK86/eo0vSLQgMP/FWgSLnaQ9yQtO4IP4XW/DhELl2CyplBi3CeY0AoP3hgzHfaIHPOxnqdkF8bHixbi4pve2t71xbghGhZcvPdk/MW5cOODZGfhbVwzoAVbKMC6wPuQ9UW4c9vCAJdT2Cz9VsgBsFzoMAuG9+SlVeAsz5RgRqcntsBzkyyuhP7BY2+V6C83oN7Lg0Ty+0JcW8FgYGmybq8EatynovGyKfrxEh37YUe5VZ1xpqgMkW6Q7Em4z+Yr3lKDKm+FQDr/ytRHhuhiz3zAhu6fJJ1Tf9OQ6RsKaTxkULDK8ExvUYea7eYOm0cFGtQOkJZvHFJEjI3mDvBHOQHNF+9TXHwO69km4xBOHq/KZteA4wQ2HmS7rbKRAzWbx5lQQctLe2EhZzfFFA4yYxld2FgUZeNF55L7SHLU3Xl/OvBJiI4K6F96vEPzFg25AkvAzwx6iM56/grMr0a8RCA1xzEadCdp6/O9BmjKYJt50tCwht6Qm/tdwtLiOTb5vxVBbOp0kq+A39RN8GicbvdEzFn/k5ch1cTB+SuPYoW9fvAnQ3b0veVKk3QUTOaXim3ZjhXSiD4rLVwqL0fr5PjOjUAqeIPu106k8tP7UjLVziGlNDDshl0IIthWT4CLsphVzIishec+PjAMkYJ5a9y/rjBe+WX9gSX2ZgpT9FqSWHeRiDliGyQcESEL7P2dVpstrrK961SSKIlXEajEyd74KwSEnceS05jHdeOSJcVuWZisfBOoO3lZbAhkkCMtv/eF1mdOZlAyO7KiObCc2mXpSYdroSvYCH1waLEVZKdZ2jmR461Uk1TErRpFelWlaTMq2uWjUsE8ZOEcAZBAyt3a0xV1YkhKV9Tu9GtRp3hS4ew9oHm8xSo4uWspzRN57pjsvLUEGXIcLj1oHpAGCYx3yNv1QGesXcZIUzACKGntb0sgR6quiMYUliWRULRPtYJ4QyW3ffd5wiydvMbyp39lGOnIT7i/SltUSFL4v3YpnttSsZSOFxsDX5PUZEyXzCVII8ODImxBTVBKmPFrN5FErpeLGB9lqJ0R/8++MGN1hg1NmTnkNkih70kUulXfCAMguDjRIZr+PrCcwYPJY5ckirZ/FEOptahkSfBrdx0R3tGtaM5c9uIN/mPoCa3S3MwaFf5NxM6I9Ha9b04f215mr5QgGhDQAfWresj2RRwddPgvq4bT6/S93LpXLYh+gNyY7RXO/ZzW6p7mkJFHYCkNYY+fMVazmdXlJadKN5c3U+DJYSjK+6yeUVI6Zt1tg4G+GKFQeFWiunuHPGXGVAYdWkrly7L6kuH/+5Ok6oOnUJA8pFo/hJvPhN59Agv1fMdwH1VWJQtdfyvqgGAk0uTyIFbNFFo/Jw+6HdqHSKWOkbt3cfkFiWX4WEDxbMOIZEdCtV3dNhp7X6Tc9o6GtQGgim2T4s0/yrYTLKGiSFx7+Urem3FGaxLkLAm5wa9SNVPiRfIp13WPA5shdDdarNAVM0JIXnOPbf/f6DN7B99+X3Ode06zAXlemrf1hYGyiGixPJUwASXvyBVOQFaJ1Cm9OjGv11Yrfx52e0zmwy+81NvehFJ7UJqvKyv6Y+dM8je2oOAkSRYyWk31ed444UIYV+5AT0nYP6NvM0gN1PoYOabg5zqFmKcal0VgAb94ZoYlXdco1gHDWqP/MgitT4k3B7BCpuXkME1h23RF3bwq1vREjEyxBMxBABLHjBo7bRwk/WodTQ8Vzo9N27GB3lEJMfsdQcc0R0WSWmGeipRya2XsCXUILLo31N0OzBL/b8sHrbvkaSt25EhEcv2doRVhQgNk15sOsK6Z1XYcY/ND8Cw9plILR0AnmUILxInvKYHBC9Nx1URV0z9N6Da3AKkb2qxRDtpRQf/rBeDh8sVCMpG9BBFKxa4WfO2CUEKyxK6wBDsrG2UrSP0lo7QmZ50Co1txenkpVqHx/R+qnxbEv4nGA61QS8iX4ZzqkmotL9/eI3k0zTfuKyBSYqiLgqumFU77GL+eNmwmIDXEPsclWgm/nGjHjvZjvd9wDhU7Gop7rtBghFBgrsGuTrMX+oktFNx+oSO5x6xEmUEAUur+r3kGFajWs18QLFtNtOTcLn0abbCv3Ibtfbe7BpywMueY975FHZJr29TvstPg/B8H4XqDZwlqOAraPBUxkAik0IxX6PSUEHFQae0OugEdy0vvCVgHvpk8b5elIQc0UpYRhAw1XHN0DNyFxzuxRbGnaqCH3pdZYif45FGmf9cw5fKBrEw8DXv1JXIw0A1me0VgGTkrbDQvsBalUJmlx3y5GM9oTagyYIWX7xyF2+gceA62cm6NfZHNs4dAZoywbeAvCds6PH3N+yw9uNBDZk8EoNCat/z3NMQFsSdetUoY3D0UG7qWukeYjHNpS333UReJy2Ue8BGFn76fi0lkB9oZ7/UFE0DX8yLOU83iWIoc+2zw3rCHr36Y38bpvMWUJpQ07LLBSqIEcc5LHTOqqp4lVc4JyoI58AQaB5/nV1snaDuX2wkBXALNsUs0vKNxMF1twwBPkwWtMkN56PzBmO/AZAglqug5pn1Mau7Wfhf3mbei7dLAbAwpaOvl458TUwIXRn3uCHdYxUAcuBYR77CutCcu8YFwkRTBsua/An5iY1wc0VlLtry7oM2nWdgbxO7hE+xu8zaOJbrXR4D/j1A9ZegPpqF4fTj09ozU/m4czzEOC5nqtRXMYR3CJFZAzTb7/IkN/hsPQ3/e0xB5LPrwDUCgoYySFefNIXr9EgJmMnBgl42Me7+22yVBnhQtKJ9B6hTEXzU6KmL20rKzRi8GFcdBquYYBGFcvRTb/Kvib6iU1HcA3Ypxoo0Cwj2Ug+fg4Lzq8fznNxzKqW9VCjHjyve/aDsGDN+c4/CqVOEVg0mqD8WkWVgDJJQuJZcdaTBRTxduXsj5Hl8hoWROyq2lOyJYPtCdLlx8pmMLpO0HGO/5yn3q8VICtjJk/nTyGHZp3bG95Y0UoKTanrfUOAhJNTufWyFr/8vri7D9hpDJJt719TGFFkYU6eWwMN3hFYkJlxhk80fb1T2uwh6nwzrA3tX+IKh6bVQVpqfdsZyISwR9I2KpjEl18biTyh4Afcqb45bFZ0fLOLpRhLtCFDyvvsJZIXdKz28AXC/Ga7t6SQkdPKRtn3ezTYJLyKjAVHSZIZJGN5T2BtmNPeKLfAC89Jopj/n9dnzwtJ3nbw1JXhz4hXorgezSatHuY/GRK++Y1yIYX58vB7rO5plrlXue9vEG3JSfwlzXR/+8shEsvOC0hS/z6VmTPkst43cnvbfjwxovMZazTr5aXFmC/ztb7QIdStUHz74BU7caRXSkFAQh8nWNelJ6++rcPLY4fWKpJ6fH2/f/hy992PTBEvLwbcst2ubvwhCY7MZyM+c4AJ7af+HdGmvPqNirAudzA7tyF0UrS2EirTM5y8pn72jXFuN4yp2FVHpWLCqfEC8JrWVESyoUePpyQ0YuzNMm4eFDrZfg5VH1a254GzTabzDmKUmXi4Q7IbaVXgSQ/pga5TzKwiZKps9ZEFddwRVx9ESv8v6mGjFWH+FicjWT8RoG9N1CT+U+uwNh4cf28oErz73kEsPJlZi87Pki4obiCxd8kD+JQvQw06DeVx3SH1g+e/ryPUuRIYLPvxd0FPufHplz0et60dAKuzOobzKYQth4LhDOdMrX4A88J2z8sfJPBecmLgEz6sdF6h50NcayyRIZZcJX8jypRtivnhO8mRymc2I3wdCEo14bw1YneFAcsKHA0A+laZ44eF0cYQupMF2p58M9eQfueslGb8SGp2S3gM+k3tkKtN0WD3FWi2ZnP9DP+fOdQNJiUXVZfUiyzrfpRD3b4YYJ0iLP5/8UO214LxAIdr0sAdY724hB0rBwQgwgQgSF/xiTO6nb/7QKdko9f1HUk+Px+oZUKH8zPHtRTdeqSSCzcwsOgT8BQ4wsoPnZR/8JCy/1myz/SgyzFZ002ZYx/efGnXGrgMD7Egwvc2pE9xtHshF+kXCCa9dpja7V1VwkDRZaHkYw8/xJuHEovtma6BPglxd9OAOksZ1tnbz9HdqgvAmNew0fLgVihd1FAdBUzJ1ytzhAh36yrWwctJ0qOW8jG7qCZyUyLb0Pc4NBV4SMUJ3cC2Lf+GaTP1kiIdoNqFoI2QK/duQV01gqT2vu5BADbvVKx5IIZv0lk2abMJlJypXiU+9T2vEv4GsbXdEf+vMIprx6Pc4m8F2poc4ehXD3r+o1cRxDR6RjwY1xZLOBw0ANSUPJi/uSirdJz5ea/pUqB2eilz0uXt2MM7QDSSnipPFC+bJP1+Zm0OK92H0U8A47szAPP0TvcuyB7JENloFh8a7GKkhswOpJCvYCnQEtBHKHbSNASTIDm2KzALzD0DrhL6b6MutSCtHXVaXFVI3DyIDhuv0j2PFkz0FLTRL7NWJMLnW5ICrz5G7sCRu3Lc/9FQEVackQztBfynbJdFnVhtbF7KOmOYq6jAXPxzKlPGcY/rtH/wPWTRgAIaPcmeCeTsQCyZyOIcnI8nkFQm6aWggCuhQ1Oer5w40PAS/Vy6VJhASlp4B+pyE3LlBuekgPxoRQmQL+RvZ0TjPRzu3wiE4kp4BH86zhXyChSMamnJ8AZIioNdd2UHAv0aMfGLJ91SespIF18lZ3uCbehOpL98smzmqovYignlLTir+amq7Bn0WFH79r85vd2H9TtPpO8B9560qv5IqPD/cxqszhLdBbvE4yuuQY7sj9JMgazj9WYxuI3zch6r2kOOoxrKeONieBcH3y9DC8AAIJM8008TOAstUONA4LMl/hORN4xZAbnsGYTKt7GmHuL5mPaAmDG7nMJ9U8kZeaBTvgApNVsunYguqXgllpg/1rfPkRdwhqIvAOOhFmCtL+yi/ANX71wNF9RM/+Zv3oc8ippMMBIb+bQElekVOjBMkn05LcaAjgSc+RSG58eOAy4+KYWMehTj6/vRF2uUOOQrp9mhcT+7CSGU6ZUPaNZoQbdDrdhYgfYeM+pX1UeFLCItBBMLqWAqklVi03eekS8eEJiL/s4p2Aklt9LNnEBFpOnrmR1rlqOEEdnuLQVBsp4tfFKLFX3XkEuEWCQenhIkJNJt677LhdtCn2oAS4EMAr6co4+/hhwMLTIP3Zi5Ob+fBDu+tJ81A9f891bhbV+x2d8Z25wzRSMMAVBXVM5yfnpDDlT27uFG5pxRLSm0P3VBfAXcyspJxr5TeuX7dyu9Wbf/W5MnWNZpAfF0RD+kqDTu2MrT9gaSC5ScAplX2trFImZ2DMETQwyczN1jUrVZdlMm2ndSRGxj4ZhDlWxrUWkAkR1qjP6xgSk0wik3DgAL7sXX3BckWAoxbXv3iPc3i8jQhuH0EDWEOd4315ZBzSaBvuiJ6Cc9EXcJo7Bjqp3n5w/ZfH8YrZToT19Hen59SbPS3GoMW6SOqafiFTIzIYKYxPavFXyqL7Fl7Gxzp1aEuWcajyMVf+MQPtDCQ5Emf2Qzj5Y3j8VoKsqUC4oky3JD0DnUy+ZUFGdbwuGAOnJ+4n6DjPLOYr9VCX4+ganRdZvT5yUJbSCXCp+xO/RPwv7Du2JOteMEdWeYVmxYO2A1CB9+dSp9JYexdorWPS2org5oSoDQ/ohlcicSFpUe9zcuhC66ia+oI6D+k8mqIDYp840Mt00fFRMcAmuifA2fIsB6tOa2ssNoAh9WliSgc51mSyBDJNz3Xi4lZ8rOq+2MqR/AjGX6BV+XGFz5dQqloYgdwfjfszy+5z+SstcTK6agw8xVbTtQcna6C6tmr1oVeRNWtbhKNJz0EMmUbFEmXH+FmO18s0wc5u/uCVSbCyGBwJl1o/EO9WHJE+aFn6tOEg0r4rIs0M9zxP+qekrhCiPpxQn2C0dsQuEaLgkTL8x0kQG+AO9Zrwmy3lMLmLnNor+UJLc2Qr1iU+j9MjW26DjPyuvpYUG6IL8F081cyyJtRj5WcxKANCS2tXkqsEN++DqS/ecmJWmy26n+Fbn1NfSPIxmynN3BPHp2uri1XvZtfN3hsPdiE8YmWROGrvImlEh24Ekfw5A3muXg/d/vET9/ZsMhL60I8w1aQfcEy71W+CQWdIqKGBx30Pp57LGN1hfwBrhHr9QQjaFea4qqxl4p3RWyxOU286AOc0w1OzVRIRd5NVdglV8T9Ruak0eypptxty9wqEaGlLatDYwd4tynuIaJXpYArwxSjRH/EizQd8C/ptL8A05xPnCtCdelWwyl9pq97fue57R5plQjtTgw3etUcYaOOBDvMs2Hn/eH5DGHAXuOcJv5bU3gPi8yJU4uKCJyzTvC4nglNVd0o4gnkEZvb+O+5/46uRBtZiR96ThKFcbcem5S5UzbWkPcE7PH+Ycd26fDueSvVeHkJkveatJAjg0mBA1RBjsJTczgGfmHOL8ZEoujqab8rzCWpisbOmFDE4cyCKktNM0NYTq1KCYPGrWgyah6ufRGbkfg2yCa7RSAf0ekhaJFj3m/XK3HrDe7vgPgCpUoov83ndt/ftYJruyhRobhc+dpBc/pbjDI2jbvQsSpmPq2kUs617tKsqiFYAOpdnWc+aB9q64h9JnsnqgRCUZDlII+Np7QkclkJO049lFHpB57bgT2+h99H1Av2o3Mb6sCMYdoi7YTPtmrbJNStQAjP2MaGp85v8rI5wKOyQWze+JmLiqyPjPTwJHIV6LEXib6o/Nljx6PIbZBGvx/5B7G5h9QT9Vq+/pd2QtlHa1N4AZRg0eQsL/faVXdLu5w8vyY9AcnG0FvKsO3agST13zKJn07+U3BJvYqTpO6/v77MefwbBWX09KGotGZrnHRxSMAd0fHpXMKr1zI/wCpC/mcTx8vLUG0J6CxX0TqQXvOZowVK5noEpAanEP/p108Upp0nTdcm/7ptL1XbgMefPKCZQuSi3/+DUt7asJks87I8wAtLT7y/ICTHDwJA/boeOUCpHOuXmJh4032YQk5qPYOgJEWY4JkcfEEuk3vzKcdNwZScilX8cUOCuix4vv8s7YHyQ4mtZuEWPviDLSTHE6v+mMoR5WgJ5AqK8lJuopmVPspCSpxpqj4oK35hhpGTRWB7HLWqcwxDmcbL+N0zwiWlrYGP2cT4G5c5IYtViGHwpOU0r6NwY0kU9XmKAquiJOYHI1H2458jsTQDaoRQldgK/1sRyeBUcdnSSKo59wLaJLz0oeJJ7xmgTasrhJ6XEt2wRFqgEEZRONlz+kFMrBmdRRrrsl/UXWVN66HMFVqYZ0JtMs8KfYe8GzgA0ZRAbBWc/WM1/v5yAfbk8DU89dSCCTjX+z3ePAyOr3Dgf/4n90gnoSKygHwG+OtqXhWjNYgL+qcTqa+/2aNoL2LEZk4AANwPYp4AOU5o/EvYniLzvzxxBCl2rsztxOx8CHifdAPp7V5zam+w8UzvZhFEiv0n+Qbhzjza5qQBkcin6yvR+3S78ibJP98b7uMsqBsLEE8Q1tuCIpFFuQfGof5f796WdduM7K/5I5oWUlBMqzYDU5ZvVE53SdksxipQt6cqyL8YqGVy+xVrhBHQ3WqAVtAeQ+8ePnEivYpLwNN4kOt2TOpO8eI9hdiyG8MZj2+hPXuJGkSkAN/0kcLx+U14RllcuWRduXBL8AJjv69WZEfVIwL4Kr0RCbewkvX9BwqNgw78G82H/Cf6s6YPoXZXS0Wna4DMH3d4JSfpSgZL0u3ZxvSmEsD6vn6lS8hxAfc07jjKtXbTXrE87x64xquiZxHGg6DYItv+SI/ERkUN5Mska7b2MYSlLzFWr2QcYXCPzLzeZ68/M0ApbglYz2Oy9ASoVAH55fL7/6z8bSJj2pOlBV9NoLMRZoUd/Td8A8Jh76LkmS1GToXxhHxUxia1zy8t5snOlEkPKbNuoIl+pZzmsBTU76ffJmD+p24dk/VzLLGpuKGrdaADYk6RLW/5M1dxNyRQVcRuMFMQmH2H9HoHu6SR6m/xrZt4gERby7vty69ytJWppVM/L0vWiDpByPt6on1W3v0kNc8Xl2iBj3CNUW6MoXtBjRUj1hb7AXj9J4VQ+l+ZMcEb3tadhTQiNJaiaurZpKIwO/3/Am4wEJLqdnVn8+vurxz5HUEylShr42QWtElL/JBSlCop+MB6TvyYDX2XqIpCjIxBp6/aBJ8ZwD3+eGiopczL9w+RC2gsuHT+/O0RY5zGRnniZZr4koQ0sar0n0xm55pSV/Dnm1IwAxQeqDhjburTrh/7aqjoKevp7yRbhhxUrlRUJ0PHbZznv2Lyw3WfIGoS9Dq6hXKrOKOb6DEqCtLfqjCitGL6Z9rdlXVTM3P7EqFGGFlntiHfxpTbPOgH4irvcJ7MFqpUD7cln/WyvnNBrKkZtYEpwyjdu3qmFptXsvRCYKJvXUjLGrBSIdyGebu1yk2WPbMRmadQz5qWReehzehDl864DqaytxG+Rpgt8jB0DlSTXGkha2iE4bXVm5huhxo3LUXgjIoYNpfwIyePUIYWUgYEfIlzHak1q/+FkM9FEsWAxi7VRvwRBQTWzRB+HckO1Vo33cG8ncVVDUPZ5YoawS4asn9xkZSidDDuzttYULLX13ht5SZUQ68rH2ZRKmWJvP+g+mv7F63RKal/A6sJFRaqebdLEoQuyIDapN6mrHzPYrKI2+B9POyhfiQuwVRfEY0vuGB8o/f+cBwmouyw89s7xfarGBmNdsLePlQf977GS1WffcGwWqnGi7V9BODfsqMdp6yNEb3eLzmaeEfW2xQqwVQDGZgVoHl9MQypf5r4M69YeUFWlM0JphVJ2lJ4aKVpOXQ/Hejfz0aNicIKMoOwled8/5f/hlvRbhO/fTCbPmAB2kW2z7/aK11rJKH39pVtD1HaZBzzJIkyUtpAII/V18rN1zALJH4BK15nII4SsZkwWAQ6hDJEWcb8kqzdxprLTHGLZKZFXrf5TIU7G0rpd7xMKyj6TJijEArNbhgbR1RxwqYKDpgTGH+gMi1UVZcR/hXHcvNEwN7Y9TLFNp4zutbMmKakR2+qpI2q1dfsCG+Mj8cKkGQvaRjCuHq5lK3E3T2HPeQ0JIvkLacEMv96AYPXEDA5TLypaYYch1rSxxQ8Gw1qOlNIkxA1YjV84RVh7AiuSTqxxLxvJkczCN33y9SqZZl6ZthbR3m/aTRJQ8olgCJWufV6E5skS69uFB+7AWVQpJfvHAS+dGKdq1zmYddofLr8AUNEc7MnAIejnG9F1VhSu063wR/I/BB0DmNUrEEwbSDe2/4t2Vfpv1YQF5B79fkHL2h0vn2RCs8ZU8CIvCfjsh7B8OdojtyqbkXLaJT10YKFjEAyKl0VBvhlWS8wQli0xz9OpyjFGvvqDg0G8I+IHCqp6KnxxxLcB3ANFnCm5VfHopxyClN0NHmVJGpiUzzROdwI/ysXpW0xK+XRNZeRviLdJlMx1CZEVVcKVRR4SLYTixPTqjE63/wu1zF3Jl6w8L2F4xWp/XLqirDki3PnHElD148Yl3JUgU3EQVA3LcMUqcxNBZ/4EW2b++dMQ9+eYWuzSJ+SkAtactPQVwIrSnyQ55ajgTmtwoMAI3/A6KQKE9yaa04ZsGn0lMCfcKqhl9q0MWPQufreiqJd+TzUP+qCojiMfpb64S0VmcyoeCZ10xiyJ5dg9Yg3fs9h3v8sKOc137fiIjan7j2wxXY1MQnJNayEtROvc9Buec3s0q2m3ydPr7eRFtPTYtviwf3+zpZSc/LcfPVQ2GB7BX+u+Jdxt8MU+RP0dqsZFFtUET44/0uDeeGl1BgulyNoYZHTTWVtPi99JIRaEHr6tNoBBQjGhTcbtsPK1DWyAR51mCUT5QgXewZPKuIublBfSW9dS4ijCRiaAjd8bxZFHL7fo0mP4I/BKzmN3oLzEQMP4zocE0hnvgnAl9dImQtxglN+nn3SReaQvDBZqdrXKEYSVOpFn561FOcqe4M0k8nM78wy7x9yg+XrIUlBmPLEq1WsI8+8fD957pEROuO9/G0yk4LcMGqMxer6fOxGEJfQxVUXsDXvng0SeRu4Jxc8xgoftW6hGfBSIwiH4zxs0uA8hobODRFc785160ZGAg3e3hrqF72BS3Gx4jeGcQxqh04eXnSkhvvOUiaFObwYraIV3FrvVe95dTgY6boMAeeGW1wn9q3yQBvWu/d4LtCkAuoA81Gj2t1NYi8Jd3Y8Pq8EyJNtOpeDO7aLV+BTWy/0hsQvzhJrgDA0UyBrDWQxxzAjWGa+MT8fD8MmbEk615RW9YpzQzagYDHMMTu43iHAMMqMFfeFXalDg6i7F4uw4jy2nGlhaDnewE0zXkaEmfg3B7TTkijbDQd7gnSDcLbTed0ex6W7jPBcSSFIzeadsGpWXv6hj5rcaXl2G3aa7MEQCa7p6KQ151b72wLoG02Euw77P8/9ISGp57DB/iijrpmchyNc1cT6jCDG8HHkA239tq7kT/sZx/ek5mpKVARv7yTWN3zqAkXeTW3uZ4vCjipn6geF+XEhi9UBsays/o3a88UP8Bs8MNevreET+c8wS9PmDCZ1ZBbXb3gyzpdEJ7N8suWDSL2CxdqFySSak8JyXfokzxoE4hLOwjG/Etq4rnZI3qXn8Oab6AvGy8tE+JJfFH5KO+2iRkCNtu32wvZxyGWOCci5ZK+93MrzClRkSAu30l8esqG86fLuva0bVnad1UahnJEzxic+Te/fYFt3LFRcyWqp+2/W6usyEikSEhKaWK9Vb0ubL346p/9uRiybfMM9xu6/OiwY3uzg3mFNUFF+Wv72wQAEFimHFVBUI6TTycBfoU4Vd1T+dxPhvjSNdlpNjS82tQJjz5c5QsV2CPWcx6a3xZ1d01YNrJ/hVHvIjHl49EBglTGIQWDhVNiWCUqt1eGMLCqKwqrJpT2pseRco6oy2iOzpj7fWXo2Mfkw2vzBAV5xLzeTS1fKnTTP4exi/6k6eG8UD+4hwBOllSuAyKjUwqFKjmHRJn5EWU23MLmEPsaFNdiwdp9lf4RPS7r/QLdQM48lKz36oBNKIEoyq3OSmEik33jk+0GbVs22GbzyUZq9c69BhvxS4Yqne3wK75VTVHr6x8j0gZfe9gMbsHe4DdohCUT7skIEXAysOUkAlW0GqkajGaFXBTPUuRdprE7uEveHeSqQ9mg2Z8hJ+5SdyDUGVZAGbwOjqDtHsVYqdzcVR4+XoDcB281I139n58zXUt2IedwRdA+0+G9oatnlYji3FujyN2ife/NqfwwAfoM61Xzm92DsLLqAqdIuAOvJQYfa8QBVEJstD+zoTbZUP0j8aP+kfBagVtu8dDHT2UFXAL1hK7e2+znFkc8zzZcA/ONBoUF0lFf8cAFLgyNi3WV4CRy06/Oi7f938hdll+NqzUUGGCeZb4dCQAfHc6tHG+AXpIn5wky7vygP1/jF5FGkHZ9oTSH7fkkOnQpkKO3oWwMw3LdeV6EX5P1Y1K7kmu7xjqVU+2zcyau97Q5uSw8igEfrO7zK949fy518gCoF2oU8QJ2VrPtEIwTPRAa1pVgbA/M51BaIS//K0O7ndyUp6wbpwuZ70sdT5/FQLImfOW6RUWIorSgxsvZPOcGiIouH/8dv8/zsKKZB7BXCi+052zztKXbEt5pmaAYtLm+GSvAJcYnq2aieDKjTZxNLNaGvTO9SvKXWZ/vhVMdvyHXZLQ0J6ZsFnZ0WxP9TABvJPNw0LeSi5nYr7ZgCV6gdBkNHhn7YR/yCB7ZFV//VTKLaOcQ8oYWlhXcax/6jXLxlEv155fcifIXiGna6RXWdmJ2OVQAD6aNiqJ2AwgahiCawOShnlztcNM2CK4lz2RnwZSBCzriOa0sdfKlDXJIAUdSQnN14hG24IetJeeeNCf20yxjhkRKPSaAdK9dn6k6mZimTPjKSTjWLT5gcA+gBAD7dntPSJwv+g/ywAaMabUFk6Tgq4ArGdnZpgrQFcVmr+t6dYxeKW0ZSn2wynHhf/uUZ0YPrkI49eYaDmyuEEUTjH/haxWdP/WS48Q9rsYlJOG1ZgZxhICypG7BOjtr8SZKhwDN1hu1vjGeSBgsXBRZ9z0jenSq4M8vWxMIvA8yVgb0oNTPds5SgZG9XvkrQAIvCPiKDHLnWytGWsTpTn65Gn1gxesOYJ3KvXmCyek7m396Qnb6DU/ZcRNXk3QbWNH2P/LnmraU47rrg/YclrTP1f3viNgoW240h1A8kI2+0c4baCYDSL9zRz71gbJTo5hQNh2cDzbZ03z5HyId958W5zcsNUi1GE1Xl0rphFlmmtPJxtHr6/0RLzXSssiR9Ll0qomGxaaieFjjm6NrbLlqCERQ0HDSqNeJlHWFpqZB8EXYbWS79hio0zj94fFDRsoY9gjJKrdpwVv/9jHj/JFrmNPkYO4A1J1wtW5mIbcQpk2RlnZO9Ev8UvCbfdT2nfRRF16IOyktq9n9LUy6L7ABjJujJ8kSdLLhQVEXyK8NKklWsmox4QclHd4RUxpmY2/AxeRKUjgrQNuVbiwB6rcb5eH6Ol220NkxAYabZV73lt4Y/QOC6bE9Pvo6S/VpATCVpiUN5IDK5VX1CrptcYVq4bL6GgwwxWaiuZkqMm+O0DsC1lEP2wmOLuKZCg7/y+jSrv2hC62zUn2J+vLaPoCtqHcQJjC0K9YFOk/y3RL9Fz0aWAUtfBBs/SMEYL9WsGbuyy0TBY5a4ax7PQ+DHnj+lwLGaoMkhY8IHbLroeYxzsd0ESHoO9+5MvfeYjq5GbMI1JX1EHG1/ai9iUgeVZO891BUwcL0c34OBSUOvsvdT17i3MlZohXElMjwDw9ND5zIUVahbPC0zqbH6KQjf0HYKkDu4Nbr1SHRsWE8aUQvq0tTNWtc9Dm6+TbXEfgv0c6TqJ4Kdy+7Fe2btN22d9KsxM4JEGfC07/VmjZc2w6gaeZPgm1P895LBM3z2hSZ5ijsQuFeuAU6wupL4Wv/KGMi35BhdE5WzJZOdVczr7biPJeoUI9SLrEwdECcOb3XpmOsOEmAQlgsKii+JPdSIbX/1t11KLHHJjemGtsS6BxLLf8UfUIjbBLpRrDu8SYMbn+pBHVLvipYDJQaPVhMT2QLZsjJAatOWBGbGjhLs49ep/co6EOr1o5xv5HXXeEwGD//k0vdPniWt4j10qcsISD987O+s06qoUWEXh5D5BhabkCGiYagAo399NoOf5PUrWqeFkGqoZp6zTdyXF+iRhbqd8NgoIHGuxwVWDu4ckE8fYeg8OnN346TklVv9NtuHG6t6GNNctlcWw4dTos8WU48B5Pu7Szp+8g+QuUR9D1e8UHNwFcn2UZSyNOMhcePTHuzTR0I/wvreONKPXj/qlP1RXasTFj1SnuNNozCS52ndDO2wsX3VIeCEGW+3UacmwrO9h0SGWXVncOnRkI9Qbv9MpHqPcuwPYFeXgIILAIUx5Pngy0/7G1YTSyPyTj/kRe+NZRplmsg+EOfUyKv9BkFI2PkwNq7iRq2pld8fvvweKWo/a/R31IVC5wVu5YYDzIWi1zZiAE+ytSDBRx5W6ejax82YOREC7im08hqRJTkCPzSZRaBcvz+ULLqDCBKJG2VCa9S7jDzQvu1wCrXqM4gxiijGYBBFiJdojwlfXm8Z5fdPLJ+DWzB12cELVApqdbu440DQHbUIWNjh3vuPx6zKcjR3gK+bM3zj+19kv4HUNn1K2bTGQge9LCHk+nJrgCC5DUSafgaajJrPaPgaLmDHthihUxSU8VSts5pbPU9xudEBu+MqAdklq9shWEyhfS5yetTAo7XIJv/L6KEj8Qs/uvXPXsRFTr0DwseS7KhK2o5BM1RTMYVBeIMfv3U/BNxSaNU8mmhLnamlWihWap3X/FRz5HCFQLPz1bCVl1nGOaBuln7IDztJ+3EWqdYlIfyLFtwuDEF7bMAcizcegyNXhBfo0VZnc20mJ2DAnJ3WrGWDe+6LUgy40HvsgZ1wU3Xlq4oqgegUxvRbw0GcIZX9ZSpe4ztElFxSiWWgfIveInwf/M2SIwVYnhLb+ypuP91L7BCO7GrGi5/bAbvWU0hxzK7tOCnKcfKx1dTl+bm5NcbFoC5P+WPaPbfnCmeKoQoyUUE+0EZK/827jUYELkMIASuGlpXVcil5+wTFcNNmQyxWsNaVOwqHkoX/Spu0Mv6TR0jMcUUa63lBO/Y6FZiNJiSsm30Cei2/Unur49nBsGbBugo8DDxjg0hWbeU0LU8R6ua9RrMAhngkp0M7Mom2yhOeYAbUKXEFb8mh8bixDdfHjKpRR7aIZRxQElaT9mel3dDZ8HBpV9nEO9LAfVJpU9Xnj0PCf+HufDpgFwbkC7N48R5vyug3ibYmDfwidI1YmHvpjrGBpEo0/foOegbk3uZ+kt/8OLHznSKNbywmwDQy4KnbnjF769QkYHoM7BbY1ppQ8hRXSBfkMwLoKgXbRIJb6Yef89CHYw9RTi1ejjgMtb2e7qcCSZ7cj8frwYl2AKuo3calLOAnGPasjbEFeAWDNS/gLtzkkiM794mWTnKeZiteNuutavJgq8k/84BrSP5isZF35/aslYW3fEmmNLOW58aLWbXfjWjJ3AY34a3NznuZpejVakdK8UyQcnrjDr6dJnJNuTy2WqUnWR2k5gzIxNifMA9s4HSAt9/8gVWdrkpg6Xh/k61NfY/4MU+MA19P2HMqVeEvInSTZ5Y7ue5LrrBY6/4SU4dQ/ZN68MH1cCml5SGPmm3Si59UfY0KDu/oAN3F6gyIG3XaguiGm2Ahf/dZ8r/3h9+22LK4ZqiQ/2ULVmjFFHv69eekWte4ianZvnLV0RLbMWdNZXcLqNf5fEPo97R4Fi4vP/FXsW5p4BDVPGvkNBvcfFpBNXmJWuco89sXRW910d5JBpXujoWKZs+y4OCUybik8Tl/1e/ekb6v+nainS4IE3xLL/DI090JdYPpmo0vr7XiMiiTWWQ9zfpxKbuyKNZtTIkjI7CO5qcBTP5qrKcgD20/8WdjMa6AdOMf2Aj486E4b7eT2/ocDImjNRKq/zJrqtqxvxJCCBeJDbo7RriStg5ja3xSM2H0t8BWh9WzrUh4hFHMpScL01O+u8YBlf0owzb0ARlSFn7uFxc8/jhc4b+BAPJkNTRjxQipERKJi7IeaM+oFOR2WQ/wsuOsdcYsWScGgETA6CqU4ffYS3QJBgZAhdNcOxSe5b4/IFFLZqJrq5eQPAs2xNGVNR4iXHFMBEutI0bZDAKoBdbSVcERal4uRHKXHxtTJN8L+mq7JYIKhQRA57Sr+GYp9Ff/ZGfgk/6xF4eMgMDEC3hmkvEuP+HIx+4g49pL0/xAYQEEK60y6OxEAPRH9UK1X4Vco7qKOk/nGftryWz40wTjc8NgrxjEEafP45IpY5sJ25FV7LZbQ8YAct8hyoXqiZuwU/J6gNv+Mt0SUjSqFGujmlkrquHlgMKvzly/pbMqBbJf9LMZOZ4gpsE/lOwuHeqv0z/C2VCfyu7wZQ8NACIlaqLvQWm+/9Z6Ni/xkTzvLvQHWJSgN7agWWtrPtXr+tGsitAoxCWO0UdGkFJtw0r5N4uSVrejn4iS9NIY5NtSz18SxNwr3HCrmr+UmiJstHAzzZiRNCBny6pic/l5pLT9XZ8KEdY02JumcVGNODvpXiI+XrZqoT8bKbJqn9QN4BjtLI/89yEhOxPffPKeU6+ovH6sPviuvVXMld/1wcpCeBm1QCPPazNvOeDvWS0WcgwsQmYfm6W7D7zqv7Q5mJ4/z51GeiB05yaUSRlnmUwjf7QoMDTxGjanp5831PvHiCTSU/5+laMZJAZJpSbhd9cc8E2ELtFRK/w165igHddstcNyS5CB9jUB2sRjNW5DVDUs2EIwPYYOPNUasM+LyE8sr+VnA1X4UZIwYvHbVLZJcJN+paoBm8Pv2hO6Qv+DVd4t977NEb2S/f0bz4y5TBh2g9+z9IMil7o2/PhYudISvkOdRBM+VAm+JTqY6UyMrerRIzelnQhX+O51yMq+VG6eehaBFPhe+rvrGIP5y7HBjW6Qun/2THdr0+BsU8RAIIY2E6lbghBrcT50ujUW4rsyf+PpbNxJS+YCnU23WPPnsV4AehmC72ibYQz8BXLafUZWAkpS+ViDugkrcAtwuzgKYS2iQHhuzBhlz+onjTqEB1GH2JLpcNcD+0YhKyNivrZ/DtJjE7R9bpg6UfIDO31NkDGqKpNM05EAlNDoI11/rSaetSKFDVoGtBbTJiz3FqMeFh41LZfBqzqJkk9o59DX4/NwJRVLXfhjJhH4RGpvBQU5+aTGwCZF7C3kD+XynjFUQKFiyMhLyyXCAca1UXEuDwQ9KKcnGeaga6lchMaCpsT+deKQg4uYRxmoQ2IHyrOU+QaFTvp2OVK+RhXowGdhh1oSbr24HupSZPji7TEL/wpEO+O9qMgs2Nm+lQu6nhz/DrnZv7bPm8pwTXCuArU76RKMla5VyDNlci5lWn/Ro3SklTI3TivuJsMN5/72W6xICr86FimI90oSpwflOqivr2w1uhNQBJ7U27v9bGRNnfa0kWnahRIivx2q9cdcSM9Qu/8PwueuKvVuZm+z1cxdcfzKfvtgxFMvn8cplamFwMVQvyXUjvAbYApk97ZCXIazsaL9xHXFrX2MQPB+RU61FyirMSUYUM+pQdHc4MNaTrK0AwQOwTmuj1cDVTPiuWW+DmM5MLyXuoE7ssD6YGl1OdGYR9lW6VYRlSZJrf+rvOtguX343Osg7wBUTn0TxBLiPcSj5/GquF9vj7WZcH3xV/EJvqU7sXmammN1Ig7q8vd8E3KiOQLwNK7JOV8BdP8zg9HiHJbv6OH5qc1nXjsb8jCIxueIHhh9S7on6IR6XEooH9TE3SndO4L4CTYem+6HWI2MQmvg94+Mw1f4IDlUCGCBpmqsg2GCkUmLl395hfjghNn7GMt4oAB2XoEKVEQP+z7E7sbMcb2dCGqF+lGqOfKreq0/Y8mYJvSXAeNb6DYTSHAdLZarYbHBayB5SAKb+nFztrZ+OIF6k7Lwsm+YYUDENGK/bCSakWvxkOGsJ7G7ytv8ARCIw1DvtjU6kCea7Mwt4+ttfuaUEFMDKotE1UaSlEebD7DnRCJu7IOHs67+kDKJ78GHRhubN3+flRlBL6vpzKCmgSmEKrkBUEwcle6RdzcCzDMCHeT9MxbsL2qLXpDV0Uv6SZnUK0LHon61huJoS9LBrT5CLRRtqlmMHn1NIllWzDmskmMHCTakoDIE9hb2clCwSkGBUv2QRzVjqmpdu7Dh60wG8mrTsyXyq0BWF3GrECgh1kA1797orXHweNAtOlkKKIzULoCyAqW9fdKZxFdHzuMoOcSbEbd3mUuFdLngX3aAnl4lnZWsJ2i/KyJ9ctMqnalWNM+onoTW0+g4EMO05ufNYBsMEKg4e6mbgIkYejhFKx6Qxkx5h2vLdpWkjcuq9HLTZ93lEGGtdR1zeiK/OG8qvHl7eR7x6PJRODL/Axl/gJ3jKRPeymxHA3bnZT3z6oWwqXjEex+I81OpbbaxegBLwmyOOUM20gfvXAND5ytGVUd2hUV1tnqDe4knDl+85UwOeTddsHp7fBzKTA9XAMY/3yZLSzZncgVmvfI3XtnkR2b+G9ZkINZBJL+rdTUB1hyj2YiVJ78/F/AcIPDhCxtw5WVvUKXR5i1QaiZEf0MuLMkJ/2Vx76pODYTMcLJvvlH4usFffaGoy1aleSzd8MC53AwFfYMfpUkNmVqV5gsw4qwfGI7zFnpIJDYFWJRj3X/aWzsz2qpyxI62wm7+GZdSYekMqCtNoQvdQjcWciS1mj2a0Z7yEIrim72f3R7Ja3nL01NRz3qQZkbt6NRpR50GSR7TylFkGWMTV6yZQqYypKS4mZrPMTFIpgyiqXDyfomhAJDm9cqH9ycji4GHasouiomYRnqh2sePnb8s6e5l66SbPm7xlxxpxPAbXxFUCPJ+itVzWtjQJ7mWFXuiPTygcUHZFEaFfgll8f2QyjMDK8OIaA/5oMOV0qlVqmmLYLcH9nb7JfXj04FRVCNW3Wyjp+3Rx5TiloBTSVlV19VF1+RcA/qPigHCI73gJr1AYVo6tnM43hW7XccPGXHulKIfW7X/pbF+ZOQenFeByw5Vn3xEmMCvtPlzMncQqAYnyYry4Eh2Xd+FMX1wn6VT34jRsAPTlhW2zhS38R5HWNTYT6EsTpG2oc1b+yybGu7Ury77r+75jlALPD2yuGTrJGELfqm9FMyK3n0obgw2M0wTosmLFt9HCDJQbQboIrH2c8LUo8VZfdAKhw6E5SsfCcEvXGxkDzV6iVjKdSYkF+v7xJLgy/L1eBDsa0MrDJADNRHyx41Nd7HAdMAbPY66rD+mMWcQQTRK9XKEklxGWF/H9HKQoFaEQZTUmQXznaEbAbanmnng7XLxqaLBjx26a9hmjHlLo6C4dinIxd/rBwRhg6oSzD2pRnwSx4g4Z99d2F6QkNey9i3Zg/oIdgKYimzURZLjL0z0+nN4sF8CXVpkinxpgMDb2Pg65PHGkAx79rJLOctW14c+uBDr4tc8lVF/7vbgQLZxwT71Mvy7Q/oeg8iddTcjrEIv3cYazt63JkKh1jJfmNriVw0vPzBA/sE0kqLp92nSml9MzQSCX8gCvE/TtrjrjrlJKkjquFgQa54Cn/2VzJBSnzONp3EyP//Gjsj/xKMczCGXVBZ8/3WHvM1Aaf7rhDjqGQlpgLx0MqSjvIVh4bydk20dVqiOFyoDmO480qvAAfXdKcQE9L+T3vgchSb9bTW7b0+/ubHeVaMZjbXtlHmP7j8Bj+oP0lpM9VfBmo6I13SHcj/SNU/aKm/wcwVBdm2Oo/6TBROMD/5P/u4lTNYjWj9apSC9kyQy+ULOyhE9f74on2kkFNQBdwmCCcbFVWE8KJGkfR7jBT+a/zTyW3vk/vIGMtzTiFTJi+lcyRRJa7h3gTEh6cWd/7567Qr3eoC5Pb04vuGFFqC8E3/MuNzo9uo8qhcc6sPPpigyiQvY2fWKDZiDuwL5bmknerYxlIZL81XGVykOIFIbzpglBDySRsvn7b+UO2ogOnDtlUB/OTU1lfpIXXP2sYE3igJtasw8+CyTQPe1WOEes1wBlEqSk4fp3RWBx+odUNo+srbv0/zB0rEAcjz7umSujbeJPfvmjnCvItlFZTm7QpyhiSmB63cbx8kFYO2K1oc/djQcm0Pn/N/lhmtnASW4428cVluUqZsd9YqzwUJau3QtskRbGy4yL6kYN8IY5Fbr7xzLj1PxXYccuA8M7SZAgr29bSRT1AOYoFIssCV26Ox5cPbonP6VHgwybipd15djHRnCkkoxNXZbJpIFHkIGtY5Sb7pBARxE3/CuaIxntJt1knxBN/wUeMAoRp9HmNakIJ3XqSxVou+XiucSkkwO/p85S2h8pMMMxcue7L8mag4xpOU0+jSvhbzptY0soqZ6M030tS7xnPe+NdPeGtf4kiaExdVf+PkuxLA936xGpgsC9JCcC4isdrGvN1uUUQ7uKNu9iwCOROEuyMZk09L6thCTwfPwlBFiiF9jZyHVZKoLAyiStyJQnseVuuiGJA33HmYUKsj5qIgWqR3vFO1BVfRGWSYq0ypqPZjTYwgx+gt/YQQfbVyBatDqfkiZZCYXtG6nmn1/FthSMiSO/rEtTyjyBsq3q3ZT/xz4SM5F5MZwIhmn0yyJWlqRIGrMeSDt/ZjeeWyrf/6fxRDpbVH0O+yGpUaCAKJRmLtwBzoQGB6/Tb9poPHmBsIocxLi8WC33oD8YGHmBagwS4iqHMuYk+xT4JCSemP4z3OP0ozdS96rPbof9lWgi8uwZlI6V9O5rDAkeoE/5RbhiUzHdRujBhZE+ExowlvCHgVQmchOwOPW1RPdJNcMJjrwxhXuzJHibq23pEVlKOGfyodJUGxY9wRwO3380BwuXwXB6zozV76mt8f1x7PDSH5TeWq0ItiLzBrRl4xMzGudqkOsvgMdPG92a75aoiDloMFwqqcGC3DfsBbXMx1T42ViVVg+qNwgL/3aICWGaYAftJ5lh4KnB91hpdzUvEe3FkCWXvwzcUSN41HUC4U+jlsqPNokd4K7W8NRytg0bKrVc6akqsu8bAJK6WcXiGbATYrue3AEeXkvG0fPymONAOyZGVZtsvgB0cuyZgbokM+rHgf+X9k+b/orQZLgb3jlOphOg0z7fiX9fowBm/oGrHfrguKTX34IjSDYRD8HXtldx6CnRzn5InwrMVbi+7RUYFHESjefXketKf5YhQ1bQN3c1gi9NtnVJFgI9u2D8mko/eL4xh2W1UKLNiiN8YD4Hgh3vgXnlOjhHHLafUB1L/Mehljd2T+0WRgUgHnZkEqGMNvsOc/8ZMYtqY0TfH/WTYZb0B7S+78U/MN7sJ3tln/EyGwTSRXf7aJeWmaGTUcqR18bYvChMkFTIaJNLHNx55iYZTf/Pbnwit2JZw+ZRIv4axrBpyKX1O0Qrj1FnXCPYdnRMrEzDlcF6fsJ/TD1cM08jInDnRIlGVf2AbM/ialVElsqs6BKZ/5x2SLUiy1z5Jf4wgEJnJWjfArC0bkbaVnjtVui80TJxhrW4Y3L+o5utS6/3OcEqhAEdVttt0qYN4aEdNKPrFLweCwKKg+vfT8ltSAWJgiTmbuDf9QBb/SROYTiPXWlui+8v8fZNY0uWGvALrF5WXotCXqtju6NLG0dSVrOmkilg8cVjfeiSmauEkroKJ3ppbt6Hbdhxb46Lpjoc3nNbr3bI6Lol3VS/jnZ2Ga5t88Wp4OBatiOSWyDSvh5NgyEg3QAwaQWRBtUL6e4+9h5e3srhGs5ktEFo0G+OTl81hbp/eI9GDQuSPUfsDHzbhDSfVbpjrtmTWDj5WnP30zvVRAgqY5y89EC99PCyIKjzwy5TW1HS64ZVFrqoda6DulGyJlr2zyF/FtDGWVdPtOQcqwC7DzlMj8sE1Im0jiZSsIRMddvDpN5OpZ5BXxDNEg0eFyNHZTHe9HxRJf+M0Q1H6NUOhDDnaAWHHxG8FOSqb89V2UMLnLsldIWKNmKmTozc2HD5s+7SpERG4lVe4335ti3WlRru4f3s/BUkja3QnBjNzy+bhRYL631U5gNYyJMp4UeWslpesgUAYIUpv48LOjj6kBv4a3Zo914Htl9WxsJrJrf2rt11CdICLWUm/IqheLgMOyg4wgsOYHbLfJz7VimrStDVH1b46luSuhl8xMd6kc4gJjRn8q0SHc9FYCjqcOzHGKS61YUSTIgqbqyvmcnYD3nNovnzhvOqFF6PgGLwU2c3bL9TNxrpbhjW9anxmd9DONOsVOI9THtw4xe94rcbsLbdnL8SoRmEWl0NnKVAMTNrnpEdFn+AKxxib6zkEpTg958AJgf+fXbsvK8tTTiahj5+H4NZrI8v+AVw+gp+9cEUkVsO/eu7S3YoE4bZMVDvtzlCOKRcM1OVz5TP9RImyNyfSV4Z9mT1VqK94O5i8hYEIm8krQo0o5TvOnEL6BE4iud9x0c+xCtJHGL25qas83u25qUz+C0pMb8jeOFb+3o1M7MuQBKDm803jFCdWEgDp2KaoCb5bU4cqL5NlwQwFSXpe+nIu0o4Sw+sEISIJAzhNy1PhkbIvzHM+HcFxZMRy0Sc6i6Y3doG9IRawKkTjuCuz3yWDkWwNDn2XUVOInoiBMA4SkJDGL0Z42mADR+Gmh9TimM//+MBHlcW7XtkF9OMEWPU2SVeVyHtnyx1Po4+767x4tUcoD0tVZiqNJ2tLWCEvnPDwysqpc9g5TA0ihBEEBqiks0Og8v5YwB+slNN0jZKjqzMUV8xi24siO49ozn4OneU+j/t6GgXratyjRV9IdUbTk3k28yCenmr7S5MVTS9sGmwztny3ZOcukMvcb6Dep0xkaMXWeDwaoBLM8lR8rHit2SmtO+3s++TIeS2GW2VyivAgP7gWWGFmi4nqr2cvAC10SSJlEoGKwudICw1eKtRDgx69XGLFPRrzIeUluIdxTk6V3YyoIzXEl1I+phNuIa3bVxFduOkGXHZ1SfKCXyiiWi1GFnzfuDvUJVcv/VsHDomX+3lgdJketu6h+me0guAWMM71Pg9s6J+ObOXtzf0+3Vp/a+V3/qK8UHB7QeobTPLSJXU2YQ9qn88AkUi96iJfCVKyTE1FklOOsnA3Gs316iLmuL41XdaqgyvBe27h6FPXnLCdhyQ5p5OvStN/Ur9o0BcRl3rEj4t6rIGQSwxIc67Jh9VeL5gMV33FyIDOLbdwtac/8n1Bwx3KaWwwDxwvYjiJIDwD6degADFyg2m5Nwea/i942wNz4A7MIHdf8gm0yJ3sUTkpDslvGy3UUNeI5laKKVtSihSXtU+CgaSDd986555NgayikhEawZJkT9JoNo4O6Ux/1Npf2ttAwvRNaoeUzyXIVd4MTadcKuQiGu7pgAKDCNBX6aWHcvyZW8iVdarD72zs8z47zxZXIzLqvNPt2e5Mu54PH0QAvoFzP+vUMQ9lKbxh5E0nhZ3K9gBKFRumsCo8anodCyked7SrcRKMPGvhQ4gm7kFq6oIH97qtcPrTDB5a0zc2a1gnU+2h5E/41dDrMOUnapuNSys8FicsRHdmIeao2QLxQ70Bcybl6li7JRJ7UKPZVL9YTZdF5UyPPs1sLZsW1xVodIfel/nmS5LOz2uDgyWkdXisPnyNdgJZkKJCYsYwya9U95n9NEWWI6rum2ePORuen27PPmM+nnx3pA3CFqaqj50+p2ZSysiE/u31JoLtsm228ZOXu2PqGUlWrLWtPcA/TCwGwwYtGuMBl96J2GgZTpfpXod8lROXeQCdGCFlyo6m0Gjv5LEJF9/YfJmi146HlZcGMh/cHOklMuTmwPFb6NM6u8tP7FvCMjUjbPVId5zIWhEf8LK27+zx+SzyX+NKLX3OcVlOyjOYraNLJ3nzrEitHvZ0lDsEyctcIWiVp5uFNW8IvWtP59V3njzUQ+g/TbOAereZIK9gz5874SadPN37IRhIJ1JZGskbaOxAzsf5fI7jgkS9DUEoEdLUXysw+bGMTdKUgHIxZd7eg1EZjp5c72ebZQnfkyL41iFVSLfMPP4yzJ6Rp5Ss/h2/41bJhFxTiwayfp5y0ATFbDRqwTKdlxkUdWyO8/PGy5+B1B/GhLPrE/Fru0unfdWbZfYcHsdLlaoLsZ2APYyBj9V3cjnY0eU050iYgN7N6hfkBdkq4q7rby6TooMIkDWiBa6CaDERx0EYjsWfwKoD3TmtX9Oth11onmYGp16EXWzsHpAkYD7jx8rdgNrj607T35IFuJla2QZ1bB1Mv/vShd/WLUMuscHVdvoWyODzgfa0UeNqiaYy/yaMIL5tSK8+0ygUK11yDCddr9TLrfaQhqWwj+6EUDPCi4U96Ay77EKkouMN1SI2Azdc3G4ytRqPOWijl2Kfokm5ojr1RyP6UVdoGtVybCmqUtD8QKsyg6K596zsUAO8lwCyuuBUVpSUAvbmZNnwDaIIhUO6r388YTTpzRUl733R+jTSXq2+a0oSWD1/CexdQ4TUyHZlfNZbiRWrj4JdqBTaYIFdfOySZ1gKZtUaL+ma2tlnTtZmsj8czNvWeSGNPHS0FxGiRh8DepxMgOXxJgb3/5L8QGGfIexyuCVgscO/Qa2M5LqY4vQj2ab5qmFTZNE9izSygPP+9jEG4nBl9F8AbhHksyN08UwfEuX56WZ/9khzhmR9J4FYoBM/dDpLJ5vC5lGpp/MFUciq6Z1YKSgqcdMVKHONmzLzfPrF2t6BiTmjWmv7Gal1H9XeznR0yd3ZRebx3dkaUb4dt4t3NWx1Py6XVPCvixNHQdPvNJZH5vdIZaavLBTeoHoWYMXrLN+myxuBBeNTXUvCE/OrwZS49+SB9q+t1f6NTYUTr0sbdLrn3E+Bow+OEQpwiwd4y4OzbFAjVPDyiL62iDmvsuAMMcggG38F1sRlKlAHwciCYENXISTtx//+/nS7h2+e2rvHVbp0yhbpbvQwTN+ayAuuZ+DCGeh1N3ivN3VBDxkK0zH2KETjdg1+cr/FJkpiMn+/3Fu9ie9hz26JjTxUvX5D1NFsOku77uHkEbEEcyB3AOzgEKW8hntd7gWZIRgawLMiUiqrwqNK8qLinfwK37CLBqTvosvPUTP1+4OAhOrQYL4X95NacjRN/+YL5KayBKNAzg1vysjIYU3HA6bQv4OeXESiUjuHX4Yscx6YQabqLJRc9xFxkc8b5wQgph09GkXrED2wG6sLjYFqLAV7KgP4lmCds/0ilyny5TO/Y/cBEGc19nfKP7PWgYSICqb64/rp6A/6diiHL9jzl5eCLYR7O80e956NusjLPvKCP/4nGObnrLmwQHoeaSnQ0IsAdVfu2tEARO7goA6IHs5rlnuKdTPhjDGGnU1Eqk/ojhFIPGM/Fi27gxwUInPmjSvZBBj4/zVUw2o/E9d1B+CWNoMER/1zsnll5m7maxQJEmKCIHBMObcghijJzSlI6iNXJpdcWCfnJuF5tlAAUthU4jCf4EkltQ5QK9qrDfkkwTmfAt6iPl2IDrCEfBsH3rFQnuoqkJpKLZC5Gk684RylkQviPaHaoZZg0uM1rkBzO5DE+6L1H4BRpErmGkv8cWSRWPmCL0GGqbNQzhU6Rfgyg/Nw1Du8WnmT2MAQhG0+64IKL5j76fBrddYqNuMz8R/F0a2DmhjLlYx0/Z7XXUs971P00Ii23t4buD2flzUvxNKAjBQkfB3qHj4anEkASPlx+kUrKN0VsZ2swvovdYAZTHEDqzuFgszgKTbguz0cHWakwtgvfd4SAw4EYprPNSSg9avbBRfHR8C29oLCZQI+McBbTxz7sab+Z+k6f+pdrh7DyeQ8WkjFBOGgMIfZfn1/aFAFLp+Y/P+p/oR3WMiiQZ9F/Pi3K9M9gXGKfyTOY6I2Y3jyacILis6xm415e9wQfx75nFWGvfrIR/qy5wC9RIbVoN9Pmg8i/YHTsGdbBDWPSgHZ8LwQPBxf5XnQToC+FdZkyX7bTXgLZDi/bNx0rP0pgVKV8KcwJYvACtJ/ZBCHgj0NSOSMVgG3xQsSsVum1CSY6BT0SCzltPwn2CVZDTQVHnnthFiOabMOfSc+j5DCz2/FRnvPA9yh+taQFm5YXygWA1qdEh8rWWkJ6vO0tHNfq+NuIJrktXzKtxws1q1CWXbnNrPnaFlTIx1Y+qnGQwtMdEEQogV2pYDsskkyfRYjLdtTnXry96LqBFSHIDmBC5NLdaB3wn+jwnp0MDHQDGqoqLJIBeBgKIjaDup6AEiGHYE3vnS5sZQ+95gEQywunKyUQ677qHVNKRILxKgY5bK5sBzzhE9Aqn6AmYKWoxb/wDa0Le0taYFPRlvPIWLdZihl3Vxt0Xyw4C70BltsXvXQUJdwXNGj9Gu+qAGsKY2uWnpDq2/yYY0tt0S/+dgM5ytZnL+A7r7+ggB+jLmblOy9x7gYIJvNIU6lmD+8vaht7lXcuodHaiZjS62I/YqyF2uDivd4uT7tdSqjY9SMSQLHsuNHFegKssVMnIQrS23l+O/RbFSs3vjzBUcCwfgjmff6g99wWdiXmrNAFAzIZhSKtaDB2s6Lxq2WVwGJ+8tzhZEQ4Etzw+o5umWhF+FupQ4RL0dIx6JUgrxMy07L/pb/uOgv0+Ap3DUk2fY7P5ICbx9us5SLY04XWWr63H8zurLFGudg17+eGvJYPEIBYNRq1OFoM0BZmsxq3AX1zTd1+Ni60nEowO1xAuU6BY1UE1mn4EfIS4nwA+KTA11XhgwxskR0Xc/e6vuQ7PE/A6B5Rm1ADiTJ88WxCnXV+pMWDNls40tznEbC9WyYvZuBNph69jHsuYGaHFXN8afwhS6g7WbSYqWHrYJ+PXjriiunsWCA25qlggSyhFMaPnhyPQAjLIq8PH9ZyJOJUyHGxASCIsC35DJgrtpgjeyHPFJkShXBhp1Km8jF08JR858T/Bwg3HKJIx7XXrjtgUk7YOlNdNtPG2LgaH4scX7kmKr/+bgdUVXQBxS52B1mD2j9magsZPKHto7caTiYVvD2O+t83GGOiPstwbJuE8kFuNQjqcmfvTlONrriaGvGxHWJ6RlnTDfe9EUsJrgcSrGdXzSrjwhSX3pBzjCgZoQ++TqzwBy7oqY7/g1cDdA2UcamxbS1eJ8WUtvMOa3PC49ivO/Y18m7jPl401EeyCovA5JKvOXp1pYMkKaraw7dBZaNewGyzT1kj1k+7mr9cF5dC0HIoSmcIRQ5pxW3RkZqOZn9UE69UqsY6tF5WygCOJSGNopX88+ZUcG5Dwdb8NPittHrrWm4cFArRiRl/ryXL9f++6kkhhiIbHRRe+XXTVplPiKcGdJLSxggwHJ7/pp0iq7QilW4yJHd72sPWbwA7ouyJV6t7aegZRi5ztsEwjucvadntL0qwg+v5T4TT8YOZjzwnKn0fuKfWEUBVXskv1A5xA4QnrzvtsWRe/kAdFJMl+6IXnW0aZZZyyegIR1x0uNX4Q6/dsOvNafVsgJC+WsQ46o1RmsjIIMc4Vwd5xRYusJYEHKtHT5dE32B3RJkI9UUAbmCmyMajgJPa/sxxPIG+JNvBOg049bUrXyY8JIhtFSU6FC361fHXKHBJlwaaUnD9SSt5BEXONv5eij7hH6B0pFSJicZScG+UMqeGJthxRhpHD3xF4oWMl/5qASJhWRZDmr/BE20e3gb5wQgJvKveOMe3nWdXhtv7YZHiUhq4xK31m5hCGf5LRTrzxZXRXVfjBKT+n4khcUS3j6EXJJhQORzewP5srqARwHR4PeoKmonycRNXDluXAC46x+o3yC4gaMkYaMgHioaR739o8CHVPPzabob5FvEg1KLKs/iG4Y62lO69O+6fcpHFUR0h77XDSVsH8hKhALe3NrY5SyncK1C7Q6adRdmuBkzrrur76yWDxFmlLtweQh6zBxH9NOrl/9n9sFVBo77IghUkxfY5jE8jB/5FuUs/sOctifvlzrVERToK7feeN8LoViYhWnm6cQvXgnVIlv96Kk5M6eQN4ZYzy2lRma/qBFImBA8ZnULNlm7drkwno2l8R0nMOlFvArOxu4uTv2Ph8P9/OjKgMwJwTpdvF5v3HuAMFrZHvki7tvsPz5+wZaxSXrh6AbbRo8CGtsB5lYUHs51LvKpF+q0mPJs7fcpCy6pdzmYt4RpLDA75c04n+eGP1s8rXxm9VFZj/9LiAKwOum2tfuT4q2x0px1xE0h/a/DHVcPhaQHgu0TA3Hk+l0VoiQCKBsImhMA+Z3VHfhJFOXRV4JYWSrig8rhl3SzKGkVWaYoaCujjum5JdKopkTFjhczwMqq03l4xbj4ON3Bp+8RW/FcPZqzgXTHLfAjKlBaRujmSDPiZ0l+sr1EobYxe0q8MR5WT3SgTA8jidMBI8ZEaKp8O5khDVd5Hs4HDg+iozVYIOpTzJe5O4B9eSx0fn7PEgpuxIaZjrmvDVKhoFjBPHJp6ys/YW19DRdh4UMT83wrP7k7ml6wHf2una+NZmd6urGqsoiD53bN0YeD15fdUbcwJsDSWhf+9rQUy7D2R5rJ6AYtaZ1jviy68P4NGxHIudcDNp/mUzs49In5vi3lP1v0nYUR+fgvSUv6YcBFmGFOR7OF+lJ1ey2Izq+sNC/MDET4SE1W0jxbBDOOvDH+3kGxdnRmRSgEqy0EGrpNt3cf34Gh/EP1zS8XoJegxSTohjJcK7Q8Rw9l5Lg5fqKnjqspvnU1C40hQ5c84O/VGq5gpo7xvI/jE2UnDzhFzHKgWOgL6/2BkA6x5FO/iUBD0/2Ye0jcGrjiEkTfmRoLVGy11MGvuS7e6F+N6Z8N7OaAcCCWogqWkIlFXfu+adRVqnc/8xzjVHRcDC4M1SP5zwyHfdwKgw/n96qAdZVKkvxnAagGGm9fKCrm1vBzdfj7YwbQO1hUmNHZCD6ucJzZIGk+HwnYpBe2IL5BWyackVXCCr9acj5SW/4V+SKXbdW9rkYzhh+oUzNKLJrAiWeNlRrzPw1LhYFKKaC7AJ3X1zplnypFRFTj7oDnk72FG01FPqoJ+93Kjn8B4jrma+/y04lP5mr55QJwvcT8bPDHOanu8a08w5TfsHH+EphOEy4K+dPhDCahl6ZSaE+kHbe+5C40ljjwF2s/L4YojajVVzV8wevcK+VmtJ4RQ2+c7IfOPaiFaNLadiLHVfVP4D15cXp2uGkssWF4elqtSvfzG5hJkWjl1oD+owkjucUc3/iyFYHCMu6hBFvp9JF5HxvTVGX3UIWDRkM0F27CWlrVqUeJnLVM8WvFHxw47ys9mPOeB248+1no6cSio2eLNQYjhvBQh9JeuhhqsKdjWOnsGqwXeMO9G1idwl9Y7EDL7SGBVXMaKjAlz0Uii71p2C5bqdjdnKqywZ+wjnzCoTe39fhJIf/brGDkv5NgDpp3APEVQZYFsmKPh49fOYla9xSFaQOQ7LMTr6WALta4fRHkRipCOadEDzUs3uwog8ivtLkaTiV06vPrvoqwboNROgh7EXg4O1mcxqOtbYsMJNdunPeKWaem5S4/y8wffNfTCjH8/pvKMjdbXCuEo2fmoiiaIr2s4X3IO2gl+byF4K2RG54fnskyuex+pT/z264dgkDuYfIpH8gpEJF0+oU6iOo9AoRZ8tYOouMqN3DkZ/GucSY2WgCDjARb8VaqvEZJ/YIC2RRftC66/PqC5q+Xxgj2c+Zs1ZS+aLJtsU5XxxxqcBHaNP6xtEcC3BHtnuHOd1SvQeDF2jvtdO7IxGmL15O4nZ8HyCiHfmDkjMPrM2/7YYsrhWevcw+IaOTURGKoSEkisyrlK5eTmfMYigy8IejJNb4vDOfU66c3CtNez7oX5WZ5d9398E/tfUXuhYC9SoprVSTWg1UAvOaMy8SizITJUABi25MaizDfqxSfgqnz0YCepoIFrEe5mUjBlb3DKDcEog1kPnhlYteVd8O+kZ3SFFtELCAmStcMRWDQ4GmEZo0/P0RRAgLnzGeU0DUZIxcLuuT3Fu6T+qYu2XRNSl1aikxPJYrAfT0dChNj8j4rMzjgxZDdj2Z6EglKyw4WZ+10TICs2pnLkdZKAWkfOH2chjD3U7vMOFDLN+4fdQAz9zilQvqISDUk/VpVH+eW51iy+DXH0Ks0NxXszBg00oAqmn3ssgu4T3tEPhBDT+OprJK6SvBTCiGQYF0t+Gf6rFdCQspWEYjoWAllJwk/fuBShXIi+Vh99L5XEpu+dvhEw6hOE4X/Xan8vey1ZWmhUvegrlu6rWGW3FVcFgM6028xYm1RJ06GJAnJ5T6gOQ8JfJ7p8yLlmf9kV/3nSQOBaYtkDiREqfrZtnJ3B63mBeP481Wm04aFa9SwrPnyze8EiULyNXelh5WwvqbImb8ufGmd9Xk+HEhI4I8qWOjsa7oXt7EkeE7/q5gUQacXK2EiOPRO5PL6jOzcdkKH4ZqCkJSnkQGBNuVUlbD7mo/3vReFPd0oXsSy/cqmMmrmZa1RYr9U2azAMJXQ97nx0QsS6ujvdECXu8Knyzl5o6+Np+d2eRAqMsuUl3ZbHygIwCY2yrkIx1FgDR+sz4b2/t/GWcf8nky4LIzJMskakf/7waiSE/Pirbza/aDZSrFWul0W7HAnWp5xglI1HoGU0D4jidVd3N2VvfdSoRoEX+VkDzZ2tpsxCJSsG3KzEQGoX8i545O7VurR0CA+y9zIC0Q1QjHQdJFNOOrN6yqjTGGlLpDZkafsgGnj1eAyd6MGy+Qan54yHD0MYvnYDvYFwhkkUnRazp39vqlQkFojb1Tt/5RGwyJew7RaAMV1F34XkClv0VnHmjE7bGYzzTUhmU/g+A+RkTRD8wJ6d/3XSirMSvxMgRp2nip5cL6bWMOS2eew/qBJgWhunMEr5geJmxnqk/SfVxiqMRNMPb3vqh4oHGgx8p4HGOtiwZGXz6B85ZC+zZrWv9GPd7xnOpuc0wo1gp1Kb5aF6NLnS44TH4R6ENnXd9W2q0yj7JaP0lQpeXale2vhm6beXhqKAFV8mldd3f1qB4ZM+6Ergpi40/MUyAFS78jaQ5zaCTghx4A5UZ8EvzaXCLhWBVmbh6KtcGcxiazk1vGSM0Tyrmizc18VRi3xJr7ICWd2fHkfwHm2tIhCj50Y65G5iKFuaivhqr86iYLIyfJH9/NCUN6FvmCSawPJFxRRKskeI+nn4ouJ+O9+Ko0em8NZaPYMtr0fRl0TxLFBCKmpyG2DHXfj7ZK4j5cQiCARfUyEzHeU2nLqQ0hMz4USQ1KthqbjK8LwPxY9XP99IjsmAMogOWgfF8rlKwOAAv/ZVBVEe0VDRnQwFvVikcQPCynOzNAC6HK4QTrkDBumQ6hS9fJzCz07KBcgj9vEE8xoDnqFTQsQg++00KN05g9xDLu9Z6oWqjKcNONJgND5HBDWiw5xwjiAt1s+gTDnEIhHqvawrW+Y/FANm/PBUtSxVxPA+5/znxWwgZOf6XzyELtx6BLuEkfrcaueEmS9zYEXqZwOn0DGXCXKo/XNXXIn/yPUU5BoN1SCscTP9jDkSdlfuV/V0ZJTkubeWF2VKhczLW7SjAJj8ShzZtQmNFbC2Ofk02aB4ciCVQfwUf43l+Lf93RHH8UfV2jwthQRT8caPHwubuyc67Cg1PIm8elUYz5XY4BnMePcj++foodzgQdIL9UpcWhFoC6YFpl2FUcb3HqwDCKsDpZqQH2UHWaGr10HxMJMo6SCVtzwuFtWS1vlkxw9uBX8HCKMwlHolqytnp0l9E4JgGDovexXntJTIDzcBup9HPU/J8qRChcZHYdeAetd/cmPUeHsdBgDD26Q12i4IdXSju0lLJQudYSytNVaODHWJek2r17Zn6/c4ml1kT12RVTbG/t/1c73lBAbSgqi9ZLqwmHrBerD15zUwlmA+Nt3anlrWHCeTXlg9qk3G1NDutrM7TFCRV4q2RQRxvdcWT0BYWsdsXN4QoncA/YfdshIcZkFV7ShSNiZRiSg/0FJiZwMCQz/GPPaRlwzRUy53NjqIuuGPuMQrTlG74ZLRiFCpdkaCcnjXZuwMZRFJ8cey4Y838FoiaS6iF+jDfGnatAi2TcfxCBw1NKz9MMAfYi6QoTXHKtXw0NlJuKLP1wti1uxP7g814GDL7sZsY3iKyAyE6cw1OmWA9J5j36B2btjqvNyPlPwWAyJQa1nrY4ia9BYJkZGlTsF9FZClMZH4hLIB6atGtwkpVvaj+bj+560bnmEwIfokMCpIeOmEN7VQLbb1cRbCoGZoHv4Fn0cBus0sQTSGJsx0k85sXu+M3kbMN3BAwMGhH5EcTeqcwjjU9Saja5gOIAW/Wb8G9/S7PvDlGaTd5mAJRVWqlBbEKOoQdxUNg79qIZeBQmfDn2gaJuChaQ0myolQJsQ3yol1vXqhkiLDCAibnFwvhWv+K4dkyhoiOz1sPlxQJw1hYnLdHRiHMYz9lFryzevYD/w/8+rfxTsTPqrlkbnUp8BUwHagdBbm4nzKBZKYpF9ddRjb+U4HW4B6rLtD6rVO6yyOHkab5QX8Ij58Au7XfZqzdfPecgELHk69Z3fwdqWPjCvWZkqKRe0L341rfCYTyCbn399M7MvEnSG8DR4yQOM1ynoWwk7MsA1J/7xgjk6dDp+fflnV9T32Piwv7NWM6nONgkIgc9DXzWNU3BDiU7baE+/3AAWbyL+YyeXlv6+WQQqkHa20Nko9qREz2L1Hd6O7RKYvAl0gJSouaoJzNsZRexC5teEhpdpUsifOarprFEOA1QKxZoB63Ho2akMk8nbrs+g2bzPbjIaI428hQP7DMBoVBdU0pdGG6u03SEqMU8VslPTkxqs2WIFaGmm9QclsusqlQfnuw8P8Lt+Ny9fHf0OjMrU+eS5iGmusvw9x7W8Futc+MlcfQPReRs+mIVfTOqCpsUmC4Qie4evyVAN1pIpWSW37UxbXJDCETZCVpGBb0UZz92JOPexRX704Xyb2/CkY8d1YqFP2RApZt1fBZsw/HCXOkHZZOINb5d3IJPxiOBfbVPvH5fgH7BMy7ZhlxCQwR8BxIYZplAuilH1xE//cQiyBCoEcS6is0JDjfgnxGFbhMTW/Cvs/7wFjPjjf3z4DFN/kXfMt8ZDu1niW9F4T6DcCVLIDPIUQsLHo94VUhjPbJr1Hy+6VURGhF2kYjBj/+tWvAJ1leSO2dv1wiO92RfirE2gv/DGuvL05ZGAhP//19b2HO8VZLlEkpUxnrcqctN9dq04geX0F6HGOFiGg4+5wuDH2YL8ldcgEALrfgq+K+KnFpMs1Y6A1vy3dPst+qDOYyA7KTpg3hTSU6hA/m/1g2kptB3F+9JOhGvv4kz8byF9sE9g1rLxuoF0S3b3axrngpcGCh2s6Tmces3alN+f7X70P9MMsmCE47rdHKCF/CzOAQnMsPQRC6xkkrIm6i5f1qjAga1Nkhb2Cp67HkXxOYgA7dizbQGioT2UUZCh1yPZJbmSiYD2x/BZnpcL0FRKTr7KNj67YE/ypHG45vmN4kiafW5M3bLz6mMtQaGY/ow3WNOg0kb+hACW0UtyIiVJHQZqVdqBRhduDou/u7Rw37I/5HkAPhQnCZWMvnEtmuBRUpkfJS47nivxXtjNZWbi+c0abNvc2zyvzmX6D2nBE/431eNDiFBbW7yUqWezy471B1lLNFw6/WBV9CiU2zsouuMWaLgyneECwW5n14JYkjZ7DRG/4NpFe9cCKA5BS92vk0GCSUy40NgFu2HYZUmVb0pxHuY82rRDu1ZAN3ib1slmqZOtH917aS4bRvqqZ421TO2Xsng+oaHkUJ5Y2wDsGR5AbT1BNP/Cp2GW3WqBJEmeCc3IKQPyqJKhzqgsj/OXAp/nhZ+OSuvJM/b3nM87mn76MWrrF1iyV/xXVtEoaMA6kaeEmXG4zkTy4JXxnFe67Iil65tcMYmyAMimuHjK8cHzHdlMBMQl8WZqmDREeSrJaZDVeDGbYIVxJZSJTbuFDshuqvbf+5eYn5DZZNuhTR9U+EGlm3lxufOfqYA10j+Q9xEbz9ktXIAqWA/+wCaH65QNnSckgRs8KxOiaY6hJuJAC+M1T8vfOETNCJvqURf414eC5k/55LwlalotDuWnq/D/FEOWI0LBk9F617awWAaWFb2q0CozH4tnI+wVKEkqP3KK61C6u1hEbpXc/6ci8BjnEb8b7Z4rOL3pOuRB8ysh7EvWa7rzdse7Lc+VjeK5ToGztPxmAisPi9ub2L95M32L295RDnnwyOJ8+5q2uPaoNUJIwljB3c76fIG7Eux/mtnlO6XbRPoystJS3CQdRmKgN9U7AOXikIfsT7i8N/ev/1KnFOQL4yKnIxDQlR0Ixt4ZvKNTTOm49+KI0Ve1hBX6sPHvg4Yyez6jJoPXKX/jHbThNXvDrNFV9kJ+T4ugOzUWyWBrfXS4dX43efdLzUqFtfrmtldHo0eOyYchirObdJk3s5We/gzjgmHZq/T2aHbOHlRy8zgE3MUQDNcvLdizTiFFgOs8QKuvHztfRhktZTBFyjNhHMie3QdUbykOj+ndzv+vQpiX7Ue3goA2VA6/kfhXllr/+sTVFQOc/VTw2p5epZ3Urs5FsZ4ZVZsjV5gBrPp1HCNtJK+kn85A8o/+AEAHA5ABwIJn6st6aCdgvqHfv/qk1+TKDSTkwfV5+n2r7kAlMUOzF61GEIXiV5IYXIueHGbzAPX+dUlt1YAnhA5xmbgVqRp3cAtYrR0dzHCVdnuq55t1Mf9br3lgQdgjRlWjzV1IRS5gxYQDThoSn1U5BGZOK8AcRBNLZMxLz0OEN2bVLParFPC2YJoLYikpjkAWBSeYZJ41I2Y1K9NRMm2J+ruKTKV7k+PkY9Z3gjCeEckiZ1FK59gU610aDYPkBiBbiCXDfqdhGfa7wuTBTK6Fx49CkxT0Pwbq37WngWl0OGNVoCLx3qs292kgjp8CJAcHHrSe5QGHFQjETEpaKPOJp3+Q1ddYJejxGAcGo4ZzNIM/i+KPxR/4Z613YtkLbeTEZjgxX16gQxOYLYVSdxy3gZF6kHrnDb7rgwrGFt/rdBz+exsDlOX1FFq8s2hEImD1BLN5SAI7KZPwuqTPDpIRDvf2CRS9SRxyp6qGF4J289MPJdpP2N7xQLDC1izc4DKDAfmR4/IdtnPaqiM8Qm3wFbUiobzqUhbWnWK0EwkkuK9Zz8tSxqMyFdDItiSnvNXyfKgdtTxy5jCUHTa78BO8eAyOOovLN0s0Or3HSYsu+Mph/BPUwyhTfap+C+tXE5gO5F+xpWB221ghtjVi5Dd/B83Ve0BTVLn6N/OhQFX9iUS2mkpMhukjA4QOYwbVTNsjIkcpu2tRgJmylFm+wQ/+ezoFzo99IABEMOCKwu6JmmKzh0VzMGkEUJQXoJLD713nacZb0otiwtgEokrWc5T7W7R3GqpyEidvldU1BHOudMPLbiI2I9K8wU1Loq1tqMuoItZd0C0RjKpbCaNhszBsoJ77MwPsL+OArBp0QZMllncrVOP+7XLu12370awDgMvxX4X7lfZUk/68V5mzBIyrBzQyn185isu/MHMMLXLemU1b5vLwpwv0/twHBrgJScMMQmRB/uMBgcvEYLppz+dmYe/3ygTXiPIF807K1G9wlw9P946endQVRV87qKO/p+iLpxkPCTpK/VVB8/m/0t/CvJMY+4DWbzHq8hfOI/D4RKWoglDQZdSYPVDOVKEFQapk54yZWx30ndO0Zu8Y5U72dOzQxUqVoNGnoUfEW4jH+vbSFV8xnPm/fwM8L7geCz4KtpQsyeDOMt3Uy4SxfH6Yjy70VJB5bYuSkVz3JwwpIQ9tmzG8ufimHcNivnvTFXKIuDhdtKWJWKXQhJE5sDa6iyB+sim11zL5ft8IvQW8TmAiIeLhGf2pigDIhHay8uqDrlWbdWd6QONUmfugQLC/ndho4gf2gKQHCMpIRUSaYK4masVc8eUct5bOaGdoXITDbl8cx92dgCsbf3VK+q7MYCc61F68669zksbhSKwyGMh7dEfaMgLUMJgmDlP+sxGHOzqPAQ4JAvrnmQWyuim5oR3P1OSIki9VNNT3PI4Bc5caZnR2t3iPKaBgFlORWBww9lHQVjlUGd81KkGLLu8dWWrYyerFc/+iAHlyB5MP4FdwdXPUx49lk072sEldZ5ClX6aHsQqcmbTyaFQ5ePGGXV+HnfQkyjcAZeqsypZ3TWPm1BG0i4Fwy/sbwO06jRs15+3TMf1h64rwVdR1JSmUAjc8YD9kjgA9RRMT8PG6+yvhGcdYmT5wKTqdkhRDN+gMKyKFDZ5zcAL2brvDrQ6q5tN+U9fqbByHPa2APBGjdiBYxiOJMSTQ/kRdtEv3qFVaD3mk1zOFDdQ6xKIiW6AY7PgkmSVU2Jfia353ZWJ22a5EttG9hPykm4jKYKh2lnNSv5tmIsOjfOU5AIZkpWelty2niHFEpUSYUe0zXjQ4Yy8an5agVA3FJxhMBsoDjTvSdzPmo5Dg+guTnk0q5LVFvGyF9Nzaxicw+cBDw4TXXDtogRrqRFVfWCcjlSHRcnljYz85oBDnczsfT9NoW2ZuQhQdQocOXGCqzEDp5psd/ksXs/ZfIhX1pPwJcwtcP6PcvZyQbwrt/AMau2UYNK84gMWmxb3PCpwZI1U8xoa/IQBZ963K3uhVsUjnH8ZPKzC4maoYDMC3vWhiz5sjgXHcgCYZFJecKSkJONg7rXy20aIPFl82jyuz49jL8gbO5k/+bI80j1tTwCdekW9+bb9yfG0AVNdfnaZm8QNqa61dVasXIzF/Q5JtG+voUrhIMl5GQooO3RQTqmtBfqnGEqhm2L/pwIi4PwHbQDcfiKKSd+BBdbBlC3r8UjNwYdDgVCQQpNUauSK4DWGZUPizlMml1DtQHqUShRQqYDU/9zVApzuktIJMSibpc0VmOH+B54Ak32UQpwf2hASlyw2WLEmMsInV0f0lQEXzgiQv22w8714coEMhK3dKo6qJoK9MYCUAunA7EJY6x7p/wxX95Fy54XOcWFJRiEHbDX6cSoKQdJxS3ytQcgvwdgGLs48tTT2ICcL5lsZ9imZ005I/IYh01CLz9zGyhhDFNwEgCXXxXETeh7lfxUFc1r1aR/rRFgMhWT+N5AfKvQa+kTo7gOo6sFbzY4RRJEYiNhc/HLTl8anTKJ+q4xkLnA7MtFL6bmpGTKcmWqGmKK/2cEmZY5bSS9wcCSjb17xFAC1oKVgrLzFNv7r9T0coYWwbFbQaC3FgsIW9BpSBfl5/Qn3looPl6pXod+b+DLgDvRRAv2H0rWFRTA+bw340DaX2iQSklJITkL380hTIrYSaUUXcB9JWvDeQ0ZnZj8ns+1XbPvfRKMYXCcsDarTbx7922UJwYRQq5WPHsHL2XFIs948MIrJT49lTGiX2xcqDOFHxruJVC4b6UG10nP4MB0JYNyCnE1dhxJZqUWMarUuUn7Tzs9kF2jIk2mNY9M0ff6/J5OwdIDYuBAPQTwzSAPretcOQHGVKbe+0dKL9zAc1hncFjDciwVW/GfBxDMv8vh7VAlcA+jAtcHYO7/AqC4tO6J/yXTQuI4InXZySmOKRfCWbClRnEcq7q7wJULWm4iikC+kn+70zCWAA9YbDvv0FaXFNW4MWJp/WSPuyfER8n3h6iLLv1kWWkXSIKJOgKZAnZuCFSJd8TSixFB7PCCxAHynpuTQ+OeDhrVqxWLQtlIy1oRvFPg//e+TOv4yQtj05sO4v5WCreQnsWGoBjgMJgBi/k/tWabq4IMIkLwqZgYsENni+0Nk5L3RZt5gtJsfpXpFpZNWWg3WwEYsM1DuCWnw4UN9nAEB4K8CF/mFNQZpBAwC+sWi77zuMxnP9Hy/4EyLw5N7zW5sTt5n8oPxULlVH/qxmbfZd5+7kP0o5HNP3+ZVHeay5mB6FPkjLDFdqJ5/w+7gq00aV1Dmcin5cGmyMLwqI/rKvBN0a9Ywubf3x2XOJN/JwXXlfO/NH5Y/8URkFL2xh9JYYH4v0qkbFo3o7wqIM2XLFdajIzit2GUtl5SM9PQuq1hR5sJl+DMlGAwUhX+TFLcerHMB53J3zlptkV4PlGAK1zGn3cvQvW9q4ew7wAeTWUXTP4EUF9GGW2JYY+7VI0As0pQJ/9hoPhNP2g+C3duGSdeEslvNSyEf0zxSYIcmhuorP9Dx73pNeOcuNbhbArUdYLS0UvnOMhXxt5UyEKwVYM0uT2dd2mxkeCqpCftp4VFR2dHAORJbzDsRJ+duI1JksY51rOc3JkLyaWjuxXrq1tmQj46C4SQd1yaoIXo9YORPRK9C78/9A7JpJbe1g1nw8W4ySCAQA8GKnfCCrxOxnexYCegY2R83Chil4pTUt4yrQ9lxRkkNVbQeFVL32wOu493eTCoHMJmLWsFTAvP8ZI2KcckecY/1HN+u7mljyLCfJjdVC8vLAlGAGfau3TWaGMbA8g/1Ea1v/mV7SKMYgHFU6qmkHj5a0TYhTgupDEoCX2Yck7abVy9Akhktep9u+MX6JZk0RsSkEox7cLvD9SgA3xK/3FUSOabXh+lXGaycD2IdXGihCcTl5mGXWyp+5MhJ+bPpRroVqCc3CI89Wr3liXfrPzXf4NRUg6x2qyDgYWUe9wPclZxo7FgAkmTgL9GHisMCJLW4wHTCaH8rPTskGPZy47NynWR6Rd4xcBK81eOiRKmO3kICSRTCsnAMHcxXML3mw7rTk63+KIPVlXRT3F1IcOQUzbsAAgPKWz3Q8RugmDDwsuMGlqqImEOliWKhXw+GUw68kpGobUg6233PwUTklVpXfOa381fWy2obOJaR16ANSFiBFCuycNi3qB1qKPDmWqSINFD2A9nw3CkLLSihsPtK9nJQAdgkryjrngMP03dhCWqb2CpDt5ao6kbAfYo39ukYkTpHmrPITJIgcVrlFMNZ6MP/jJwpTv0Cg+J6gJd4KRKuq15M886e3YY8wBwsgrw5OvoDpUHkb/QdNnP9g+qEgkTb/MKCFA0P9dEZLfcZ9eMDVO/npi97Nc2yfr3uEsMO3h7xW/ZzbWSx2wP+XXFcwG4SQZxFXuuK7qK5481DVEZiiPzsSE49d9179dDBjZhjw6eh9o1P96+V9Alk5HLyslU5AQ7KwEv3SegVQPrO0fst8B32aGAvAA+HvwMUmkLR16Rb2ftWHxvj4rA9VhKNKfMBWoHXr7X+N/G+Ydkk6amhZ3NEEahPMTojgkthn+n+Dw8mYGy44OlEDczp069yfzon4/gaznAAb8tLflto6Ovrl/c3GaTsg+HZRaG5y7m7mwLPhYI6hmrI1cMk5+th7RGjTx3vvNQ+Psiay6SHolmXgNgKhgOmp/BOBYhbee9lYjrDOul16eW9Wm/STRRaxD8Amqcl/CejfcypLjRgJGr18hyPpkTeZJXl6kngkgdKQh8cBVkzZ60og3iqm66A3sUs/DX00unJHxtmpZ3MXuYriHXXpqeFK+AQQBXWc+kMG8bdJLyqF/fWS6VRIjGqB4KQfpuC1WNdT5lylNXOJUbnBoFuSSiQbaZCLUOxQoa1b+Bl+x+qL34WScPMARLNsNDHA6NilyK1WuLiPYbQkkdx8Vf93S1HlnH8KIMFT4QUZKdEEx8Rk6xZF3QeX8zAeh0U93nbksKqC8NrH3+/aglyE4KbR3W8V6IA9QpHD/jhoMCI3VW05j0tcosoyWeBhrZ3CToolNQVMS++EK18B7Fdc3EybkM2PIKIxs+7wpk/zz94Jep+pBq8m5ukxLrYlVjkgpPrL6KNU65OtY+N8132jILg0eoE0GhDJzI8FqLdTpQO57nX0/NeOWCgWfyKjfjQNWL8xINXFhG9vGNoicalPOVGovNHB9jVTIzAU17l4TSjGyK1RxL857BrEq1E1JBYaYZQIbd8pwSaYupzFNbdQMqjVBf51Flp+icNzUSQP1aWRTpBT5gLz9aeauAObKIVgkrexI32bVw/gmt01BoiuWPtux4kKjvOpD59lfzKMrd8Op6GyybE8IWoTCynztOtaYd0Pw82lKDf9MVwOPTwCVr4OaOodGf/gGzft5EiP18RBeJTaHXQDFMyN9jFRrRXr3a2AxcDNfjvTI1La4C+xivHG2EwIK+4sxqXUwFBiyT3GwEGpJx/xc76pZB8dEG3BL9eX7asGNHuVcUI/lXEuGmnim4tU62WeNE0XO7g7XNZUFNagTMwSrgpVkW9c4b1cfyQON2dnqilcaMehA57qs+F1F2RQlXgyELNq69760AvvontPPLqnNNOd5GR04Roxz24yTMbBGhYbk61Mer/j8VijXV2pzJTEY2NhOHMYQDwKgwGo5sGuWP9xv26d8KyeZOkTC61OAagBjEa+hxdvYl74SkXznxGH5a87SW1egwQFoZZk74Bru0euhbyXU29NtB8/rxBFueYmS9+TbK2uOBFLcLi6sThx14T2OIHN7pA1GZHdNX/Mfzy89dj/dNAs5EpYuiCipLhrIRCE/ZB13+nX+vh8H5bUcdYYgdXqBRSGMwEVAAcGA1Uqdkay1o5XYLxcOg3VvpJLW28ohTw/TmLdMQZbMTP310TM6ftYMEIefGegpI1y8SBrgiF4Hl1HTKX3revQjM58N4xepk8keWNfsJeuy3K9dKxY/qNPaIZMVVcg0uvnt3Gf+lOyk3z0YUQ5RALuK5MUFJoUL0CkLsB4fOMTQ3W7aWN269bGHo5O9JKvCJFaRjY4KgApJFbM7pKcmQOBnzsRrvEhciiQmhxgN9TFlfbxDG/FQbKDtbsTYT5DjUxsBXktspOGpyqnu+6NHkCzYp9MDZErZUtwStdqUNPFmotXxkRjNHP/5zBjsI97sw9yHm+HvCt9YecEv592I7gZI8NEd8jDzV3PL00IM3DFGwgHqmrnfRCm6lGx9cdvT47erQdzvMxRn4PVe5U0I51cy3GV3BaMBDB4Iy9UGKAlW70fKljuJEqqLCgVG4FnxlCZjAY5vBcyU0IHA8dVwUdp4DbbaEmy9+JIw65iy0Nf01qPZ4EKCsyzr9OTkxNJh4D7TLW9VXFDsFEfkISkQyIBD6UprCvdq7nnYEPr3Ood6AmOM+sJgO2wMPXqVhm+DtlTVLTO+Jybv/3M2fkLkn9gouTux0/msTd5rrxuOd21p0WUWhKFfS0HfTW+NdXDJRSieuJdIcCxupzKhrREK1C0WJz4JSNuUVKTR2VasbY2mHtudeJOQmtOj2rOZtbAeNolntrqyKfvP45OSBGjoI85p6v8o1Y8JPHG0CiC5jtCmIw7TmlMRX+QoDJ7bmEBgxYLEd9jM0Do1YfsEk8eLNVKtiJKAZwhP16Y2JLuT0lhWVX+bDpCDBApYXeZq9heCEB2tPI9oeKDGP8Hh/Xr7NDIUNJuA2VoSr28x8CdbdILhUEGGtud+T69MIRu7VEGdwvyqXxnYGq+POAo08JAGZ/PcloRcztIwQbnFBpFtGH0qanonwLTtgOhF3/uPnwvYB2BsHnSxg81CPJmGW1KWUrOVi0OXje2v3lfWXilSqkI24fLDUY7BS9OKpydayz7S9pCZ3mfm6kjGp/evwZWAt2gMApT8/CC3/SaXn39OkgE3Nh3g43zB+I96h5jYX4p+EBiy5Y8E5vlOlqpsphnUbc4SzCecGH1rk01UiqXi7e3qUJ/+efw39UgjNtEz8xYvvOXMWHA122SlbipVcbEimsmlV3FVeCQ8v8WTNguTNIZps7ka5/GI9erjeFuqsmzijOJNMDP12OxzZl4VQKZMzJsGxxltnzv2gohxoolVmeoNLJJdYFokUmvUDmk/6mZq5NQyr8Pzdu76hUolcqjTsH5cjwF/NjSB0lXCGj+kI3kTCxCeSNNR7jDNog0hVDy+58KFZwEYjUsD0svsCUlqt6lPiYiV69UQTYYjthB9jASoWRYLDMvM9YmFqQs6tX3x9nG9ACp9CCYeQ4BS6g6x+cMuXJlXU+Uo+xQK8XX+60BwlBi5fqvC7pV/5jKDeNmKGMPGJ80JZs9cJcXb2y04U9g9WtHVOJSosItJ2QSUfmUpxHnbBKWh1TMtBebvLCH6oejpia1btLsXphrW8An8dxc3YKxt9zeTiY5wgWRIfZbs9mJN4LRyXDmujEeGtg3loI3fCPxupkwF/+Tj432+cXZBdcb4AWk/nfw4xARKygs/kMbwPlBsmHjWv8fcBe9/4HbKuHOYxYIEbAvOkyUpPzJna4dWpNkqNZbhvE1QkXD74OA5cCJVQTB75/Gp7YW1oaZEXJPMv2z4wDq/WiBwbvTU6pjEAfbLJxVEBpCgqNOY+qKqyvXoNSk7bCJLYBhfS9oT2pQh675JFeGiHvTXRB1vQfCA9gvI0z01Gaozd3YOUgxDIwBu1ORyE0WInEjQSKJYWbT6Xuftj95C7qsMdHCU2SgrQGebcnXyUG+qEqMRC/v3h0Fs1tyxoaFdleKCIGpQYKuqBb5xCCmaMkAB803Olvs+JzQvjvWRtd4qgzwFC2dk3h1C6G9R8TJMQLd9V7WLQVeqTbcy62I9LAWtRQZ9/UWxfPoISEQM8Vm1zf7WnfldWOijZn8KvWB6gkUJfHmFZbDQIWiK1iZnVnlygTYpQWSjEdzhmZ7g2kfziyswYdkJ5qo+wYAbCr2jzGH2vLM+Z0PiE5z6aNdgo9MP8iXmxqcEQdSOLiS9Fyx2uF3AitE4hPiGRmpn1H/CKkiwuc3UORY5vnd6mgFRNECaVvhqoc1fmC5+oWHj7M3txC/QvPxc8rjKKFhI82KhHMjl+cVCnfwuI33YGj3t5TzT+ww8rTjxy5j4e3LYq26mpFjwSgFp9tUcVxkGvk8tqfBUasGXiDBVJ45oREU/+YuLqm8asSqNjI9V+K4NqAzxWEIRYTGm9oBzp8RWH8KV0Q4GteZAZYwe929wrxyRZbZvgjnglxBW54C0v5C3o/+Nnz8sQkx0LkFh6n069Ku/rgFI+OF6Th3Kyb/ktA4xvRDXvwa2w6T5nJqcE8QM0b6xMdM12HVWwEsYicgMgJgxTIjQPnJzq1PQrnAkZseDtPWKDYb31jokoeqXDKeJko9CIB/1fsg2DsvrwfmryNgmkVgNPd6eSbGpuH2hRhNBu7kd74ttmUS2AqO1AD9lwFms8zEN75c2s0PSHb65JrVoTm1C0Fs4V4SI4Vlz72Vzj9rXkfKhRTCRsJTyi2chEY6rktFQLNgE0+Aay1L8NyZh9Vqbl2LKHlZT/WG4wEPWorG2e3uTGVg6X0lDk75u569Nx23HSDGnHLW0cYiFtTVpxPJpXLkivo4YkM6e+vEn+s9MXHeblciZo0sfh0xu/Z5Yj/WIquth2YyCH1VfkSyjREy3RIzSuyNHSyr6Tw+IqJYtSLFyTuVlcBEwxHKhJD+JK1TZlXS9Wjg5IizHm/O5JM3zVs5Edv02H/gvGoITxJoBdzPZIGVJQBv4VMOZlg2YBS+yRca1oyKcE5d55Q67UNaw8rP4LOJt4o+21YWVtLiBJWnWerlKj08Kc0kS0sCPNiZdtR/oiCG9VACtM+maMFvKg3YWHVO9JEC7Jo339EKolC/eRsEwVhPLgGBwBpNtdJM6UsW0BV0f1i77m8qCuQip12OPsxWq0wcm/50FuNLcEXyNOldq/KEH96c2wGhd74F7MaK3U8YJ0DKlUimaiFWM2DijcdrmerAM22pCrsYKPTb+6vYwjk34+zohqUKDyt7nomPuRWAPoNrshJX074QCJ4B7smJFqMnFWqsjfiXN6nAMmgLP817TysnScpJJ1Wdr4sAnm8KrHlRoK204yGobRvTCxiSSfKbWJOgtj+sdVeVxkJQNVWVf+CBkoOGR16w0V061PYWobcYtOWXPBRguPGwgpFbNwTodkw4GGMPT9PqrhOzfvSX0UufR/R2QZMCRRAaPdlscHhDew2oHoinZd24CCGhtE2BkQIX74CT9cMVeeyWwK98d48YkyGKGF8gNTjSOuJLrmGW1MK0a2bumUrrEXxjJb2i7cD9fUjCfriwW0t/vfcsVMXI3mqV41Sf4oi4L9G1EZ2iVrtwfxLJpvJWpM5SdfUaVftAMgfS9y3mVxfj15mAnKX9mxFpDYtbmCpCkYFl+iYF32VYnx040VUWUEdy2YmY8uZyBLcPdw8lWfxLICe1K+w8v1AnNt+Au8DAQhOozb0GJFOzCBpbsH+wkgnezjrJwYG+fCWFeixxZTDWR49C6ThPuL5ey0VVirBT5VlJNlzW2037IyQB/87gSHUMFCD5RbQ/1tloeLDXfmIiPAhAjo9fdukL7ucEJz3P3bMUYosL/rxfKCBWQ0BQcdgyvdP0BUV+aFUw20xrtZJKJ5cfiXdzuyBiHTn70b/97khbX3eKWC7BU+90P1XJHgmIHVdDD7PEs66NKvgnUtYuAb9D3TPDB+VzFMsyO0b2YICoJalaHGWpN2qp7zWVmCV2wkbtMOHq1Tmk5FBlNAQoiNS7Q2R63ehf7itzOeCC1kP9jUyyDV+Ge9dczGJWla9U+4P3g1kD0C75JgVsyHqgwwspuCb8RihVbhhZka2twM+JG6kCxx2Xh/BXcHgSbnT8xmY1rj8uRdchYseYPGULuFErxHSsnapvqpu/iGvSjewcsYEX3Jfvep8IksCnsvyg4s358NTl0lFL3i5u8KgclLhbWY1NlT/HK2NzPEaJMSGFzEOQ/Q9hybpBxr1Ahq58415X0QNldUYNUAma7h+mWpcp/TeSsFR6eEjuvf31lF8EFEEyLKya7rBuk409z2R8jGYZgl0Kp54hvpQLxf2lecGb1O60G6V5LFQAm7Ytz5kvlT1JUK/rfsXL3uxz8uBx0mBrEXvAbjs6BumN2Sd/JdLElNnO6O4tBr7Yt2O6J9G+X7FwdhRFddIh8n351hxpI1/5I3ghThtHl1i98mcN2B0ItQkZrPvM+7Gp+EzhYJoFAOry37xbGSJSNqdppr0OmoiWOyTGJNb3avcWGNrngOcft+anqFyOnM9od07yKG9T7s41P07iJZpgAkjIWrXQNpBeJea73D2zAkXm4CE+jc4ZkQ1h9i/E4/fVk8H/du3zYnwlpMTqUiNlodDQSn66BLt6V37wvq7G7JmNsXozrchLV1+VqKjPthoNQZL+SuiFuR7n1UP4keCF/PY/3VXg0ekSxySqy1M4tg61dUDujeWb1hj5MCyQF/Xp8vkFenbXJZD6wGnhqk/EcAeJXrlymnnMHEPqpzap+KZFT7d3wR5zt0CXFteZ1nInat1Nvih3brrLFJPt3KV43h5R5YuHPwHT9X5IuA+DGVEtLes+9XW1guQBLZbHbuXpyioaWD80Wzenm6UkQ1T1bh1pt6wpPk207TIBzipgKD/dlvogQluo4ptgVd/oK8LjZ8DnySEF/WgdUfH8n55yqXSZYKos4K5G47EWWt250sKMwDYA0igi6jsEsQrD7b2CKD9tRF7KJ8rXCIW7FObJfdhhIS0bVxYHrnsVypGDl3TKN3R3MMWazzZ+eYreNtEogW3YsY6Vzt4XprOZVjAPh2avkdfgNXAKYDVYmiBmBrkQn3cVXDEiiTc/3iGGkJ8fXlKhToUpBmE3MrVVIfdPbIcibQrYryNNK+DO6yHQyjul6//Ykde6YCIcIysa76IRw7a5Kq8P+A6UQm3OgBVGrn3d3bzUsubE9MEkGHYIPuwevIHMspnlK/7WyjlWyZoZdYInLcTv5ZG173xJQuO7a8YmWMT57kjQKy8A9n0moB4xgsHnyzckPY7XvbQ50aBAlOw4qkuyDbWj3AJDJ0K4MazA7lwizO6ty923FbxwZVwW/99aGIssTj9nT98z2LxCi5oElvo34X+ml7MYCU6UtVGsOh0Hpj0+sv1UEMw9sm6QL9MlTeevB0p4e94QumLCmtmN2/uFTUdqsrLiGXaOm/WS8hN2qSD4+/UrYJGf9BWH3yYVxMKUP6/zxMkWvPIXKvRVdONFgLYvA56SwPoZ5O3YwEkey8Yz3N9swr7WlFIOH80FPf/NUxej9pTxmlGsEmweIbaLg8IR2WLgvk+tNkrNKGEhPL1JM1nSdL5um/PdPaKmf4UpmDvXwg+s3Qi73q/EVsq5m6v7vEcwmFiEhutrRP2J6cOzcqMKxjvDew4ULSLWyDh8aBustbZATRcrZUGpbWDsJvnyJG/DB+YB+MmNseLA3alu9EKzuyiq1cbvqgnjTr4TuZoedwEbUjHKhMM3qxCvBMe2J9GJ79YTwu58uF/YjZX4ne5gMGgWudLGjGSG6MEV1gW3IqtZxjatdR3YqnobJOEyGTqDCkpejCcu73HTyUD4HRz5QbAXp4zAeE9lV9RZu1caRur3VQQUHJtJpXhm741Di1vHvqKw4WDSNNUnvI2QbDjnn+dOBK2vuKu4uKsQq6Y6HR/UH4d/Zhi9AijaKNPaVjMJpmJOAHfKmozVp5emuj4BzluuP46WP5FX8dHwZM9f51LFZwOtVhE4XqUTDzi6oNJjMQFzR+p9/CLOobSi3DWK2Zq01OC2MP6c7Q6Af5A8X5Xme88uPEPuHo5ubwEL7bWUu26HOllBuTPhDi8Kmdr2JOZrs3o6H1IiJM77kKheGP/d4ER/1tOpTRx3PfCtricKyKnhXrUN0LggSI8DRkGVCdhN2hy1LYXjlCXJgAEuA2zn0qAtJJJSjkT06l0SeZeTNsOO+Hjeo07uaLDFhdnaSxn1LCTWhtpy+yEf90XGuWZuSmqPhRp1LKAkSYVtUxhF3PafoJdyoTsbOfsEVOunLAPHPAhNMLi/31OQlx6zs3CRXTDiqtPJjDXkV5+XqI7vRYiFGX3nATGf6qdrS5yACkNylmWRfhuRDb2IyEPt3b886DENHHlHwWkDbKxuri0dYwVxCo10JwM6Wbhy5KC/ZC9gh1RH7aB1X+UXdIogGvL8UR1y+AKm0ufxBgYe0Dsc6dwKx+jcZGs0KqGJ8hZUItr3Ig7qxUmbZTEH9oM9ctCp1qrYpznp0jb+5WziABSRP87hl5YZFClaGL8ynMBlRU6fu2LeyYybVFO2P30+ekTdxZIE/KnKRFYk8cDmPaTHyUq3+LnH4sloO3avxRu/CqjkWHWmW76v7mG1147dtK5g3UYh3XqWg65hx7Lwzc9RB7OXdqX3L+bejnjeHCELcAc86RWoLQyIQvB6WCVD6yxloFbJZp9luhat5BGfnHbrWPdMqdCTSyuYoF2tMNTDb9r8dTNkX8UZTbmwPcrQoJ4Zl/itA5XEDSGAVoy7ZZhGe7RR7emVxX/bSWNxOSB/t6h0Yjy3NNuLu64x+189fpleQYhV55gR8FSzqgPgjFXZBK7B1dAE7eyCtWU9cRMuVJtQtw5pv6L8zZQaZFEdrqTUgpOhqyFjFCKzfxCyYD1xiA8QWugzUqtS+IzLYYyqABJIaKZ81JrKgwnnds2I1s6ILam4cpRHtupYchCd9MjEpjdWpOgnnYBBEJovRi4Q08JzCtlFt3ZWqq26gVGwd9dTxpvOeKjJOz9bSau2DdCKt7K5wDUGx9JbIs1csJ9hDIDZzaiw1CZ0BxuD3u9SlvzFq3g9UtzN/gKsiaOTIOAAVBvSRGC8qWruKTc5HQMWI7l3GxLTjjYsaIaYV14XKDNL90s/Pm4vRy+UQOUVAJF+lZ4dH0DSjSiiwzN++DUMeNRsHPHzGZGw4Lyq4jFeK/SfnQdW0jLl5xnsc5pAWwWOqP474CmK+Jw7BXKntTrevuCovjJ9yW8qW2/XwDSt2l3djYjtHKsZDEHNvLVg//mGK9nHWfG9qZYwEkezYF3dU2ToanF1EfOFJIUQcvr6cy9gJs53dK4nqHh42MvibHHSntJeNCfe+QXucN2YAb1f9Hl9inGkfdmOA8x98n0ELAMLLg/xqPzqw7gPmb96HUKFDxIYjLcuntCu5htZUGD/5trQVHKG1nTaF5ljtTScEVrfMqxMqSCK2M0YygVftdQ/0R98I/UcQtPgmqvBmGwS3wbMyTDpenoFl26YBYUaBgwbacIpJdhluSmx9YKacwOXGu2WJhq8bcU9W3Wdxm3SnXTxatSdcjzme+MYVdmVf8G0o5kkdoR8Jiqv+vI08X1pdSSHq/6YppIUfXQybl9ZOG15DY2Pdy+Yzvk/2b+bZGS/FOn4izZxdV5hISGrzCEcIpYgb7jxJ3sIgl6M5YGpMBVK22g/aE5deEav7f7s5jEVby999eUl6WMTSk0EOvDtbJ27KXU8gJDlR8QEVhhhXkkvOIenqRkabRNjNtFS9S6s22HIuXaOmWTNT0wwoVKUw9MG5tFVyjwzPJr00BcBQHj9/5AihsWFF27TJCrlYsEXqUBrwsQTIl6UdzSsqViNUsi1VUcXgE7li0LgBgqVM3YwBWETu7L2SAicWWPmOfrWvsFzsdkj89MFw3zjBAbmCS7/MTfpcNuKtgHm6gfSbpnt63IRX5claKehKAAIOJunoOcDfBmXIh+WxJjw8HG0+fMO8nRNftlcWLnbNVcu461/oOdVZuiKasqWJUNQnzNlFhsJ+LXR6pd34L8gLRvvaEK7/dn+303U3F6nTwzd4/hRCinTrrDVP3c0taY0qMewiRJhvoTi4AOXuF4Pv6kU/A77dK2KZ1Bh4b2NiDmJitX2H5aQzwvGcDqZxKfT3WCaRyJdKXt07usfC8Ufgg3G/56vpkAKuZZun59T/bOo5EspEoZ9Q+leXAWlEQwgGIEP7onQOWm6wXBW/GbrU5Pg4M9i2UCSpGcNL3dgeiXEXlDzZATPG5B8iLXysV8hklbksp8dipD9eGNhJ8VmcKxhS32MEQhSCDL0snsU/Bs3yqF2dnCHUVWhKlyviEy7xE2y9Co8C+VRpxsbSGHiiccBa/iN7q4prR3fuFH+U+T/Q/rbPmp3Yt4DiTmQhoFsBQzLm/osRbz4LhnG74f2XJ69X0hBqtjpk14F/GKEfunI1lvLdfMC4+cOl+D++YO7H7aUK1yhMF9Ac1PV3kZWcmvemoi1XdBCS/85Gvxz/lmtOo4DLbC//R055eo6kQUIzyaQvqgGbZkhxbOuZnQH3Ny6SZpbCRF5aiEpqQJtzuTrXDmQENEL+YCKprVyZwHuDEfsUml6wriaiLWftW2m+MLPOVsw4pVpJxEENVYIl1PZwHVkFeMvk9b3fQXxnosJtiDHhY9+zN3ASfXg9ZSQTv1VsUKcPuRbninbc/GjA9oTKYePm5EdGqhS/TujCorPEXsZIF9LxS1wS34oHut9ymhyGrzJbUBGcOAWorte70HdDD18CZaNzFcFfhUX+wi6M6+l6J6rjFnhxrHDLqdyFr2btl3GFMy2sFxwU669l9l7u1ZmOISfT5O+8EI3sDQ9bAER31t5f0JVzKRLwKXW9KDY6WoPhMJm8fjQddzIncrKnijuyMHxiu6Fc+xseeZqKSCHeNb/fAgZGdWchNYe6kzN7uu75xSGz01yRbZNNMjFZuKSHrK4fpyykY3ow4ev7aRQLE0B3wj1hsejX29E8b1a7UKkLem3xxsDBRxfoflDt05NrUdyyFZeC+l9F2gkkNWJkBxHH+9+2Ug6PWQeZ7lRrd/lw8Wsu46qZPppOIgjfTV/ob34yOPWBrNpGgURSncFUCABYKWpdUJjB9dSOcH+smQ3BIbTjuNwFeXSK+2Ya4Hzh+9iyJVzVFTquRr6fxe/A8LZTWPA5/i7EREoEPZT2IJpG4fLUUwpOWt7cNUw/xGnZdzTyf2qYzn7eoRe0PRfOOFy5jIHYIB44Ihc/9h3R6ypQL4C/3b4YoimbCS9ONbE01HSHH/MLJOVr+/up00IQrqCfwk5CdGzpnvSkefjg260exWJ2+wb/pjSx6SuTSN3Lw2cdHcZvubohsorzF6w9mNvrgo20BU1AbrNgCKbEKipyFMnyjkxSPV930YtAVIOlRByVMvgQw5YWLxmuDjm996TI4RK28Yc294wKr38lEocHhaTkGCmSHmhNQvPeqUKHnazZpatV5VKcOpZfxTbhW1K8boleUzMHWlEjIwWOOeNNmRZ9AXX2KUkXKpaXsc7SVGhO6qXHdFLtlBeRrjzaeEr5CK/DCrFQM1aHQuhjumrOTJt6MMEVkPqk4pYUdOFQrxdu7UOnIsQXE516whRFz1s4DqWIhkxg+4lAeIJ8ZMOVM1D8MIeKjCrzUM1taIDVYnpSdojmMD9+tUJeXMnnOgcxZyedsqQrPwMOsLvtzsNdUn0YVrPJaA9RbEqNK9hQQXIyOP4ezcmixJ8kMacgaHQaQlTQVqpgH/xms+m8fdxIIhiS+sCBHmR62XPbykeu0hTz6IvIcodK5+DuIE+txEs58UzmB6kU4l1OAADFQep/Ykcuf+6uBy5NrzXPxgf8I1RwlmjLOPmtkMXLrXBRpUMyaxOozSVn4KvaMSQMufIaQjQxSqDLabKHZGmrPEYkfVEA4w+AH0BoxX92D904zKZEyIxd5kJep8ej9YF6XbbqgDsQR5YoJGdKLoON4JafeN4AINHG+kQOGPJxVuWXlgL5JHEW+vR37tp3UUXHjlvR1syHS10n08flWfTbQiA0YTEOzHof2iKGJJm87ByixDjLBtygT5z83hcYjVVNvdqk+MZ1ykmE1d9RxzGmqwLplplTiXTwlO97cwb1RauApB4WrOLAZa6IJtdUhDHP+nml1dBKBYita5y0UirjX4AbzP+fJ/8TGqkAuGV/TPzgwvQdEQZuViOhGz2WnVxrmac+f2dJZVabWCIPtVeOSUuu7CLnVDkLSl7CCYaj1N5rKq0qmbwZJOIZctJLfS4N27RCmyTm6UxhIIZdGojkz9XAyZU9LYVyPr0UHtHcqm1X1NNKNw7Lp1yChgOIdiwgyjkwYktcxq8MDH0ifCq5iHEhHTW//vXLJPjLsdsepW6/3ooMxzPkWvfeKnUEnV4grk2jnONVprK4Nf4E44XndEMNqiJkrF9CJNtJIP6f2EFn6KT3YEFw0SJ48wXzypCiO6GA4QIiEAzxqRQUCuoNuf5/cjyg3cbYuhoDIi8N0hSlV1rEbKOC2nkVIu+kRTQ9hNTviSaJgt8KubNHbU1MSrrNsfiYRug7YyAa787RWTfVLDKKXODCbIw5PSSbyaFdC9QLgao/uUG1ESneHkFOlYS/L/nXRloeexqCTkwpyr/5OTIFhp9glYbvUkiU6Yqt3M4T1ojqdvXinsggNVHIxlVNhrkyAf1oyhCvE1L/D3PfDkmfNeZSKjOzRWUzJOls5lDqnYV0IB8+KyNJR6dla5S6iHhhsDhGZdNn86XOcJBe5wiZtyAtbl7h28ufzi7zEO8umWdXjeWEEpCVv8Ufd+MLePe+gu30R2v1v+hNob6RBeyx2tewkq/VbxgiK1aWMgIT8edJjfR6EaW9TP8KYwBkA6p0+Jh0D83xGhRBIk5eAaf5LYqLVng7MGfrZbzk48iPMM2NxzXAzbUx8DHMebPG3+JQKEJLukrn8VUvbWehSk+NxDCjhrccUcnSyST7YHlaDQD4gNa3hscSvPYpowGlSkh3NuU5fopKYi1N8SuglKsrYeiU9tYXIPM+jzGV+9lWuTWw3tRNFqpyLxjST4XLq3uR5egJ0Z2CaVYSCZ5NOl93W2Rwe5dsxLjW8AX0o0PnRtDP8WHIl5bE7w0v7StCj4k+8hVVf2W3grY0EuXxV+BoJMXr28QFHjctzwr+Hi+8FjNJCeuz/+lI66RMcpOoe5k3TEBdnq/9Ap5L5QGcHFsiOY5Oe/7LMjwyWGgg3Fklb0ESTctdlu06Azi1qdGAjRFW7V8PUp18fuyKDwPqIdUh2SbTlw27pPvsCPC73G/dOSiewvtA8/sBqr0dld5zCIJFOFpyS7l8FcB7v7/0Z8lCV/1iKszWZw9Df205krbeo6uJZu2EYJHYMp1J6+yJcHJ65SwsplImM+fxWO6MyF1NgKDh59VX9RiE7P9MX0LsqMQP+D9+rKPvOlDt1g9SqzoDO4dAAU/4ZpKlOLZuwEN5O7Jut/afEhmzhPkuCofeJQ369v7tic6bxIX6+qZ1pT0J5COTMtToaLUXC5PzyvLdkS5lvqFX6ooeEIO5lKL7zNY50mTn+KB9UxnyN1UwoUvmE6npb4qTgWgcgCFHqZumrzGng81dFBt23JpRKzgl0z2EUk8OGERt1MAPyR4n9PKGEBOUofwwKOeC6tigiF4x63m8vYXHq3aYEVgWxxTf1TLgoUFtjX5GdoDaE+u7YlDG5QS8kJtJQveofjPew6AD5LdwuX/w5XS+ui7MDaK/aYVPBG7CKqTfD4FC6B548zVWCNw/ZwmYt99h2fUYoEzqXi2G8K9trZ3DWDADT6bThLZoMmjwyfJtO3ykwQKkog0+ImkpsfNx+UaHKfr4TtGCnlEBvK5UPVIpiA43wTK7wluEZlqAAu5QgbzBJUJU71gujgVq1ZJ4SMXCNw3dPoKRufAqKE1kdcy9LHKW/983RaAGSxRlSXzZSSjkGy+ExOkhoZiB4HOHxUqy+psAT48cSPK1xRKqS194xU1eoBgHiE628tL969Zrv1458FH1BGUewjpGoBW86DVSQn8hSBpiHpRjjKCqbGkCOrsz+CMapSWFsNy0LW/UgKR684ZxgAgV2KOpXS7IzPInzyX1kfPBo0rzEpz5OyHkDEnllia8D17cO4uGT1bMyaZ9R03mpoUrNeajw0lrelSB4aYHr4Swflg0dbfTdCKyUwa6IVQrgvdK1PMgygb9dnh7nQ8HCxuI6lNibrpfucnuFcY1H3OCu4UOi9jufz/8+/LMWMxnV955fAKDUtDFyCB0SQ+Ti1bfgf3ogvD/QQESeVPgwr3YIdFsJQjWeD1zYbiMxuWfJ40Ug6WYW8nECWmqrC7LRS9dcJ1KgioZxra5ROU5t6Lx0oHkdhifYiYLuYZgOOXaq0+b8spbr+1SJhyeKzQmhjeFo/kN7s84s11DRRdTpzwtUtMUYRV+WmRoREG0edbzj/cSeO5tMhrGmAtqFfIRuD3PUJZ49jztMX5UUpYXW5WhXcwBD1o3ZCHfAakV9AOHYmPMiXAdhOigLv5qPe4KIdcVhcJ7GCCh7Dfo6uvW4EP7Po2aORglzYY6oQoYeb94nAaF5yHrhceiw71QU3B1ZLbrQpV68KHl+QEfGaR0hh+4GQCmpp01Q84w40aNtQOHAVl7bJrIqpwNCBrk3lmep2CHA1eP0Twps4ZJ29IcQFPsl0mZdxmot75J04RXNfLdw9UrcPfh5jHXR7ukKoBjFhSw26qJJPtwZ/aJXIf8wA1WxuUvnUZnxPgk1MRWCWGIjGsrLM1wCP8/D+cqQVryAe6NR8y6UtLy0TfuVoINOvz98PENPdY+JTPFt8ojWGiNLHBbXeflEs94BlRvmJesuo92toSAuR+fAcGEiLx76o5XRbfnX7EjjkK65ovUjw3McO5VVx7cmseZ0LA6AkJFNPiOSnVWxZS8IVrkuiA4q6sTqliPVWTGz2+0MEH/lSsK7klnc8+n4wfocoGjwy+fOUaxanXvlIv00VaA5robGsPoqajv7LrfiPPRjgQ/E438UisZ0dBA2CJ/PQcmk/wG2Aoxf6agQBLaEAlJH/sGTk2k0RnuPd2koNrVL/fW7IcZGtS/vVAdzK+tI4iBAgXlOAkKJU/JDGhk8EHOVm0oBgQJpsjwlMgugeMwqZ/Jv2lIiOH+DiW6RXV045bUFFbSSyo+lwGb6I6NEwz+PQQm+HjfRHKTxg2evJe+oSK3ZwkZ0hVynkeIc5L77hXiGR5LpLZq4Oo4ByucWNYKujbLyQZSWYBz49OTX8NMqhNa60dLPsztRvdnHclnuvTM8KbiIlxAik1mscbk5tYaJKCa5/R2ExcLrqa8s2VSYlldi1YDD/ajptnC9kAtqsa38B7FwYBBQF9rqGV2STG4qIiP6rykLDnsuTVWTHufaXTbBhMC/8odSQJawqrK3lD52EECfZWAmKUADWBinl+7DLri4Khk4R8vA4YBNwkR3p2xwCm0eER8PEzlz+z6iDnx6/QBZnv3NP6FMe+2Jihd6PxTxZKSZV09BIex1/WCc/73lPxMp2+7auSzvEFrVsKq/gVzBYzFnaoLcNj0gnrOKtwNClQ6BM5VrMqgbmDXrFQIAI5eXY82eMj4UEjEr7r6M7aIuD8rTAQmpUlgR4bFwzxc1ukrRvESnpkHvGwARz0OqJMSTHIN5tQv+Rt1X8WFgBnZ9egjYUqzNj5T2wtPtm8NG4MB8Bxq8FQHbXgbRReiqpTQMl++1mF3PexsARZNqgFTx/6JaP0NJsyWyi9riiXKbZqBIVeY7Sv+YqT9/TmWPFqPCak900rNJCfkoywiTj3pWpGqKxqgUtr+bhv+LBApkS7k/WvjUYB6H04fwlyBvevEpY90RUVkQib0HVtRhquRjIIxxF6Zsa5EklMTP461LESsf4B14gacMZKiOc/SZYYKi1d73FT+sIPHn2WFBfVW723Mn7v0L/Zlb5/y+FgVPNS8QBfMLht9GZtqFufropXiKO6gBP81rsol1oKAFAg2+2MCI8O9DjdIqnWfNahKhOaRtMSFQAtK6on8uDGhEl6+YAuRAG3SXNrrv8Ygg5+ANj2UhET1k/uG9+EUNqjCEixcN0ponrZVoULdkg44pUFfl2E6PIMqUlzerWY1NOWzCEC37xT1aKGk/A/9AK2TDMW67p9RkHkMeCH60ljkfA66ImZ0ygnLT5QKN0WpnLcO2G0BKuETZnab0+Hhf9Gl6CWQ4eo/ZxFR6Wgx4Ag78aykx4x4IVv9da5KyStXeJAvjEkPCOstaASpYAk7c/JDvskfML78OGze+Hh892JYniKGVwxYr9J01MjqeVWTEHkE8ii8xFfu5vNPD46Jb3DC2h9u3Ca1WD/MbgGjLhJcD4XJEc57mehKhmsIyYkejEeWlG8ViJDPeboxQnveTPN9V3zyPyaOJcm8iWOS45FpVafAIQNkoa8E+aobHBLLmL0QfOiCNln9DPnWi1nh7M4B2o1uOxwooIk2+Rdr2il1KiiWjU3NeF4Op7+Ynz7dHopdhNofXpUYCxu1HVIaRhG3TIvRUPhFrQAUhNbY+eZgpuevJRsPm36CoZt1BmdAhzf9Ajx1I+Y7y2JQF34xvpU1luAbazoY7k+SgUwiCX3v92SProPB2tDLTkseYzeEUAuPXpp2uaElKLFt0NTsTfuEnhQ3mtSshUYNzIYiJg3x/JJ/3y6tKHj2XjqLSFQ7O2SJKigvCPrvvAjKXRoEMjKtLMBfbUIPRisSxUDFJKrrDq+Tjc0j+RwAqpKjZZH3DZcQi+Q9Y2y6gPO9PeyFZrAF+uI/sFMzMFiK5emdWm62ACWjmyQNBr/jj9QzGLVAMrHC0YbmFT5M+4DyVW8jqtGZ1O+TBgdpFAByA3+2QgV5cTc6K7XbY7G/TqMCw8QQAkA57ubO7st0zLEanQvapyLoyOzaQtLbU8DgmFG/E5/Q957iqvCimojd+LmtMMUuKIZDOlSH0OBmpzwxrsggp66Om3sne+6tltMyi7qhkwCJ5yn1N2RkPifq+6gYmNasXRki5RR5La4XT615cBsPUrq/zFunOCvIr0ZbOJ8nRXZfkIObbe7jciwGTvWHnraWo43U4jxGFR9R2H1MAu2EVv1/6taHI930t7yj1I5FqoMR9dMGy3zlPsJG676515VMQ84GkFEeGkBUxqvITWBlWNV2ibSroaeckGsHF2Yc4jShL6e8WGnIZBT4kIco76XR2utR7BZ4KqcvLpV6hpJ8Dh/VtXkYFc6pID5GSi75/j5U1iZ0+5t46UbHXAzms8g+4YdhSMMureT+JfOnAdbm7o5/UCZGbrzMOOHKLI5f0brE7ZlmLDMhG1bUbyNi2PHEdSldDnPmptEFYbBr88APbdgeYrULvWOXhFpbYKtO7W1inLz5j/+2LyarsqoBzLIZsBrcGHfMmIEDXkzE4DfYTZsEzKCngtbmZXmWCQ/rMn0NbCndzV6aKYMbTC1js4XO2ZvvAdC6WvPS5ubACXxe42LtNdHbQI/lomTKc2/S99XSQC2fKqJnepRDNi+oQkr8VUmQh50W//GdiB6ZomRHsCDwFSaL72y47rMmXR3OStc//l7bFtPzHo8eaewLdbcJcxpMJkHs/e8uBkOBdfsCbJ3qRz6TSnET2WVgzpQxQc7Le7GzXZloTRT7dXRq93rkCBG0E8uqIiA7wuJSLdTfCyKu2YHD0MwCYGqkC/VufuiBx8LB+d8CMkv3QlM9/FOY0F0jvCUmChHpAtKjjJ5jyq7rhrKzDrs/ae32OBB+O/Db+isnMwZvK51dQavmfs12na3pOcjt/zUh/qhrNn8psTuMv0i0eSYjfWS3CBaio2BjeVNKOhBNG2BTkKQYZhhUJY4avBPSd8xltClPGvfXixwPSBxzgP8HchT/PWgc1iBauQFNLDN3Z/dJD9UYFxby7VMyMD9cSYXZXdqA7k2WYBaMxYrHHmImSg8lFB7cZLkZ2xUMCahygqIKCE4hgvnahc3byqmkgFrJiNcb6DAqtW/aqfe4GJvow9fle2wXt+mutJDUD83No/DYhLMT9CO5u7oTMh/vQEOYxBkKpDruXLYbY2/XJDu09Xi4fZyRrhafkIEsMcpWHlKa0mCP3B5p8AkCpjPfiQeCZb9N2ar/pxn6Gf2G3Iu7KlE2PgYnoW/oNP/st3JfV5ASBwJsM/HRw6GAV5HOHfNRJXQrWf510n1BGjE/sU/vZcA9dMuFFXvy7Os2HnXpS9bQ9wToHMK+Y5DSn5DVgOfeCLqbLwv1x3IbaTMwmaKAhRK41QJ0rVsV61g7J5CmPu0wJzvoUMekPgyGj9aH/hf61gyb6H6s2/7eFS1uVnw5dQ89TTFpV0W3qYk8W3MUX2rN4MYIT8xxHZmYBlLfXnBpvyobkreYozD1n7PKsJVIZ+rEvRfpyLTuqBQoTAOcUyWNln8omNpQ02BAtg6aMH4KOKaUWJ5MK6Dk7p9kX3BR6sU1iKCwHo57myK/u/Iacq8DvDJiRR8zWmA9ndcvOlbpMguEB7jEbcWLDOSk9cN/dK/HEN+d5eBnriM+eeWRq1xrQBGu09wdt6MNdOuVTPX70SnNG+o+uDZKgYhCs0vrAKW6csMYnT2JDuQAv3vkkLjpqAVPn/e554gIoLj26W+rYP3Tl2BEKRfC1o6xO1B5i2HKbSf5Ls2I4UQ6a6B2ZO3MjHrdRIrwHTi85ZRRrFve+EutC5QsF1Jmc/KITtWDBoosORGUYaNBWsBu0yaItyC4P//bjee6vASwDZf5cE9hr5ciM+Rc7c9z3fvlyb5UvdfpRmi8M7GlcbXYOzyGzJbcPgag4n970sbk9i0wqENaUG8i686eqN2f+tw/M9FLIpY6wLpNdDK2TIPHdsbmW10nK++wBNcaRJ0hO32qL0Rci6/Elq+Hjr1Q6vNGwQd/VwmdQeuMZVcjQkHpLJthNqVVCi9CBMxpjM8ak0pQL10J93IaoxViohvYg1sq4LB/IEmP68bApzw7H4HunphhNWDB1IPqFJ6XRS5Ezv00OpoJJ4gjr6o+uxcLJ1KHs1R5fvqOI/zHinWkCytycQ1d0YaQi/lqcnjUW6Gq9aVxGYsikXobATB0rSr7+BTCU1gFtBYX3mLV9XUbLpBL1QIfquB1r8q6my7ST1BUgvRTKeCMjYDMCKVxZRL1AbDfjjYmnEyV/gwA7y3EqR+lR1ozf993tOnf2yB2uyNJ2zMAuS3qX7as2T22bzyURzrFqt0hX1cuNQcxIvz0yrmDPWXToELSV8Dns3bXKA9dw2IVqrAAthEMkQ4mtK29kr99actCzOIL3lW61YCxRkpC250RPHvFzAIbOo2SwTI3mEdFFjMjjMq/1SHKf7RvFzFkBzTq3WzMteJUJb+74FV4aubFM0s0w2LXuOihIVYYsAoNGe6Bp7Ud24a86sucXTs1FXAfG3/rtjkHW/nW4yaKiF5WYbbo8E882HuRNuv2LJadbRQvIlkNNubs1Rc+l88Vsf6uIyZ6fPWaAQliB1pGljXRH9EUDjhBbZt7SdSg5Iw4/cFRU4dtPANIDvt1pdnuQNFOEhI8Yxc5FNdD35Pzuiz8XsMcXgbjVvpKDvcBJT9q4ivOtbi+D8QNwBdMKYdx/3RLzoNgl1tIzGxULdB/RZ6Z8M7VjvPHpylc8YxhxQKKywZZRBP4drA2L9tjygJODmAVqpGV90fSK2zVEPRZ1eibvn9Cm2dbrgECwEKaitsoWTn6nKkxP/VDY7ONI8Fad+qLN+L94ozWnM3mka7oShpgIi2cCgdjWvkmWFw3QtIYlTRqQlv5hsEvHsULKgoyGkOk3+cVisM3Tl0D2ddjA0V3vxnZlWsbJhXvBZTYkOYrzFj9cIeVdibRs/Dy8idvpe5RrdMw+Iabb+O7AHxUybDu0U//6ls/lDmZEUrl0kpB3tqK4iQXzLfb045YulPCVOMswgE5WnyFS6aHPcepHSuD8uKnojz7DaUAIYfh5DOiW6O5Oeei2lWgv7/sZX9Xi+/L1Xwh7cMxkA8QF59EQ8/5Enth27xMQ8Dts6n49eHUCNJCIpuYVxWik0x0tBVYWXDSsiFpM4/3XTzCCNeT8fm2uyuyBhusjz2PVnjm18IbRuEwGWPb51vAYC5ukCLxBK16vrqsWK9ztqtk/q5ww/fFPFT8PXayQ/NdJAoZjIW8CSj06pkzaejJ5WpziN+0NYJTzoACmArKHb/JpSZvSNNQ9lORp7DJf9hK0kqZDdDl2h1vrTjp9k7QEh6VyRRnzV1EMw6WqcnJKZq2GaKbCEU74XnI3NPBj376WVTVAbnsiyHtzdodzobu4K75u/yi9PodouArQrsOZPPiSMfFeWGWXYpKbZPvvJtFa8RkKH7OjYNPn12pE0Ic2mRKSYKvPOTaAukPBC94i9EnmHkBexQgtHWO5WqMjn6tfu5ATvtr8PfeB7HT6dgVq3b2OL+EksOdyb2dOM1le3s4P0kI9+JalrkpOudtcu2BQyLkMDFF81bb/ZHZFpPo9KrYOd7401WaB5pq6Y1Npa7yd93W3Pw/UgVuxrEKGTspEBNzTONPg+N5TA936NPq0cYTEWwLc1cYzV39RPV5toUnRkPChhePrSuNR8KKeyRcI5RZY2Zhvfw8AE9yQJHe/+88GMWbS17/wv1lP7a15O+AfVzZs8hY0Ddy01dZin5NoypMEvV85utd3Chjjn5HEYU8EUZ2zMD4PvJ17SqWN2F0l3ovJFfdVFDhsc47wTIj9wIGSL29Y03GsVwxhjeKvoSHs7sjSQ5GFyFC20q+qiJkg2LOT80eJOzg1Oxr5/wYllApV4DGyR3hxY6KTfZOrPeP8/YfBwdRm/zXfdhvp94RHAhjYvO748f6ZH9P7qYoA2fu9harbxfnIto4QjW4wLmuPYyd5urbYH47tdMPMFWtFabX1TRQLrWSYkR4frqJWQ3AxUsBsfwfN2iLqXjcRaCzPKTK2/7hQWZG2EQ7zSVu3ODUhzaSqw4GqLTKGsgS3PGPdv2S544yY+vXyGrShgblE2NSP+zwvSLV8JOx+bw3vAAMvWcp7mnWdlozPKBIvmYZenZH8aBwtHlyM3oRfRM5Lo58IluD2bJK78+jD3JH7EfiGufiSf3XYMNM9ra21Av8c7uxOGvYKjlbQnmdkDtzeWM97LwRJxZwb7k7/cW7LNVyoWjOnKKq/dNNv8BRkd79s0WOwEkpqSFnc+4Vo1PZTsNMsVwMjAyL8pSWiziszL9XCUF2beCyNlsxakahStR8Rb5f5hNUQ9Emkum0VlDXLW9NacrMer3nfQIbgCcXn5ZAuoad4jxSJnvnd5YxAwyBsjsNkSugYyi3AmoSjEGpGfC/U27olR31jFKhJYlrjDOIVDudCxzVKcovKP32Z9cHAqIoVU85AaVSpHlopb4K8/cwaRvMM1LYhJwaq/+Sv2EN+gEYxU6DU0Yuquwfd8UEZ0/brWkvca1DXKMQliVJXUJuExvjyBFKn9cSSOI56y0bbD2OnEVZG1kJr3nRqiGS7Ml58uBFQALPD7l3q58CVmAr2fNLeaGpLh9CbXy/SOo7nkRDN4AAATty94W+ehHYzrwiAKhUePKrn88qSvxBGCgBtTUol3IjwrEA0hmpDktRae1qDh0EkkrjiKuldC8H16v/d8FfhVOLdjVtgeaGDThwlIqyF3TFThsPiwSqkOkaFOQuqQFau4JO9SWNJS8gRafH2A/cEaMNibezYHXCjakXvoUeawhZDwWYKr1KIr0irwOjaIo+x8o/vfr8a/XBY+r4+yERqmDEIS/sruzaxaLe1YkG34GhIR3WO5b/IxNnsr7ETVIc50tVWOhS0/MFZTbOGqrHV3og3UnMnrOr5kkP6F6wEJHw7AowQrpDAEX89b24wd6SBcg95bJ1qeW3iXAxRkT8FzQppEj2oCzygmImBGtsEZemsDpSh6ra2vKw79Gk57ZQ/XWT+pkx0f100+Up0MEJaO9xYC2hYzASbh/jOspldJG4jLk+2p58nbYPu4Dj7hph3JHrH5whmhnBag4hFL69NvCX3d+Zwbvm2ZrxDkNw+iDQDariHYpzPok/fxGx/BAhYbyBKk7Rjq8LtzVZ4JXnyhyLW5ovAqW4kcw/2IRhuA4oIso/zbrfxnhqZH5fA04JIl4Npd0AiEdi3LnUGYkv0o1X/9Ai0bbO7bQnwI/BpQiOdgoknimywtdYDUHlqmVtVXuHzmdFSZ6m2Fjhs/HXqRSI0L28pRSbvt9cMfnmciRzxKCrfByLPF8EG3bZ4nPuwk9/FfgSV9FgTnusMPvrxm11SoHpZGQVY9jLikc5NsWq2qTzVZ2OAnhbt8Ns63sjelui9QYk2pgpw1y7LYaX2rdt0NjZQBgv9ra6PV+yh9Uo4RFHtktM6oOv3kU0KPTwpoONpPvcYGoHS4n9F2pvPqCLA94vkVrOUN/vDLAuIVhMY/krbPUsa5WtTdgzsv+Y4mADRDkmMbZRpzH0m84Zq/BgTT13Y2mbelB8xZjrtubCPBFpb9xJG7MHu0yoEmcmcV9bHkK9J4IuYnvmbyY0h7RAU22bQFpX0xr5Ww1oRs6aZ2jan3NXdNPs5+Z6zqb/2ZlbYqpo7kf3/N7xj73gW8xiWQSH1miGuccsPtPM2v2Sazp62Kk9D/lmkBcJs5EolgOijsRBgnVeORNJTV2cYiWhWPpU75CLANedrSKZM24VA8/dzgz075ExmuSqAG7D4qQJr3MhgGRIeHS4/nalmcxw9qi9wNfMCFFQMgmudLVUGlx569/3qM6tH9MjLmOfn4Ypnihiaub1EcBnTncq8q/PHd067cT1w3EhxpwPBaMJ17SqycJINvvWi5/RMXPeyyGo+l0mn4gzY2ULS2FwqRkbDuF1dblW4qftCgkLAhvz3p77GABn2JYSENKEd/GlmwpBoYLO01TuctZB3GpV2KKenPBa3g2j/QAKaMAw4IIBt3KYB6hhbPaMK6hVM5c6EilrqqY0bUmZnQkhTEt0XRL2uapp7WUn72fglvm/b2R02KDNmCH/Tej/WDupz9xMCCf8kyWuZNNrie01B2E6CJuhAbKHGiKDCpywZ3vKjfsz8nW5h70imerIIdO+g7nymep/jkXsQms4P8r72RRb5ooQkFmMklo28c1fP7xi5wHBTghC0fnkBgBqiA8sTCBiAD91vGqWKJHXX3Cp9SImAOJcdy5n8yK0OX4LAOF+TeU3QN2JAPE0oB43UkuKL3mSBU/BIuhi5pOPmDjFOsPPKT9oWJ/uJvESqCQ/+cs/5fQwPaXL5Tg34o1x2LErcZhLH3d04zgvUXQgzuYN/Ow1xj6dXM4iKHFgteiUaXPUce2o12e2tkK2CCSxQR2i/ExWx/hrWWvNMCMUsBOUk0lRsM1tfDVsUofFJhYdJojOzj5lB8HMIER4OI7dsQXgGTDo0efOx/8j1WVonujFT0jF6AU/eAHDX6zVTwlLDXrLeICd0Ex0FKlYdJxEly2viN0xfGpSjeBRQ/3SPZMA/CwcKpi8Blu7zZcyTyRIN6XlieUK2eT2F1DXtiXvhzsZ6KIQlHHq4vnPWFCNWZTouxEeqYxVztkq/Dry2nVxB0IEdOEO310SdD8Ci7fc6hjzRhj8RytEFZuMi8zNqpODPYLotoNbPJomkB/DdhYoD7XbPb1N2nuDcCR/TDcPgxrLfe0Gl0yDOH0uafhgZtIGWqqoiJ9WU3r52Yv5vB9CQjmZRkrCIJZSNicw5TK88PEwFUE9Y3PxjCqaKwgGG2M+icrLW9B001tumm6kAIs7i44007eQXAKmRuW94HthhRe1N5UG8OBQ/6G0XaBNw1l4/BLMtFUdQkQWcihS2JQVGzwnEr1oXyvatpO4D0FwVVnaOgOaYyVT+xom1ZbH2kL9fyMIOvo0+gsDwS8qF1Y2ZaSlgTFOlFx3i7Ytewv6D0Ayt4RKgLJQj5HtnYRky7Hyrtpic5VlwHOyf/0sEotafqh+YZJ6NXvaXB9Mj5vXy2sajAyse3OsbDxW/BZ+yI3p4g2fYhZvBXZxZmz8JI+V1ktFLKw09mvbj6Y0YPFrl7SlzHQoai28qiuTQTwLbpwU0UANZSStZ6zfx6/LxFjUwofXhnSW6cUXh3hfZP9NQeu8c+4/f55LfJX3sVSdaDirOSGx6oQCvGCB9A2F1tMKZeBIcaUfBylSUW2xeMyDEcwbNl0JYi64IOoXmmh+PrWaFG/fGQbE35raa77xIhbew0bQBmjYwDsylxc9sN4cr3mAhVVHrv/ul2d0muMXUF4BNK9LGOr6sL8mdTluxyHfynu6U2RtyWZCdtjPsUT4Wq1s7RQMN8Ti2OvBVc9fm2t3HyPz+3hlh38RfFyjqFRXvLq4O+5AdGHYyHhJmKRcWLH9Uyw4rwRCRDpa5lvQ1RrALQtzW2+aua0NB9r1a6OveRwlGoO6BMW9nOpY1lWL+6tcs540G4RMcUdkWqJ3fhZMfWDdZzWN3CnvhDh4QvAW/W9mC0bO9a4BFiQunqPKdaXN1sXLPAvf9FA33pbLxj8lBJpaZQRJs91/r5halRNc8wFM4ukVEKURXwwCvo3PW9HYW5FY+GUJ3dNlftzu4li3cV7YCbju+atzD+q9fv7WmBq748lQatvsSr5Pj9w9hdX+jwd9wvGYVEhS/bozt+Nk0wGTkaoK4WY1xt4tnICbHcdCqpSqt0PkSGmXDsiBV4wcWqrH9nN/WUHzIyP2rig6mzB3Q8gpo498ExMVJQq9BXF65V1hNDoo9VxXw8ROOK7ribHJlfFS3NrjVF+e6Y6ekoKZjp6GNv7tUMyV96czpZK97DT2ZewUgX5JF7jV08aLGxwN7hHPfHcoo/XHhteuVFqWNLBcTR8ZlexjlyE1NCQ/Ho10XKzPrZp1NjcM8QaiTq2QKHfZR4R6RTAk2Lkk6F4543Z5pLFa0zSnzKqNI/eKPbwmydq7eaqidet+5qzQauUFeqmPzeg2lDnZqJxm6ZBtx7g7Chon6AbQ/7Sk5yeadCt6yWK7oqDvJTU8sM6EMNo9GcFvMRCB1vcHkb63KvinTZIlS/w1/WEV7kxNRZey6/nVOMZCmyiWgwoLdIDnlfVAv9qjUDvs35iyVaQv6OblwXoDynPZNLjJJ3cNkX01oena+oBqNed/4NNejxbJ1Q7NOGP8+V29VGKD7hhJsLb3isvhCVnJJvcNGg/UOy9cQCS2NJGNcfggXjzvsEaUlFspPNlS4BXN0N7SwAdjOzrCLnzSaw8lWQbnsMWLM3U/hezj0/FPDrIJihvpw4UETCgAWPLPAko1xAHjVHFy5ixKNUFco3dxxE0nKfxQ9FMuLQHJ8x7jO8Q8x0YsM4Xq3aq8VxxRPeyYr5zDaIGVTGMsZUbbkQJLPM3NTJbXRrKw9zCARXFS2rn92+ET5WNBCElDk5Wp8+8VBcbCrJyZDLCm/GoQAaIBTJ7SE1gpsUm5AADMULjsVH7jiAWzn9FyVTPkKowht4iWd1RgtenUsvhU4tHgl7jYjOjJhbufCn7FM/tLlu5sqdISghZn8dT8/dWdfl9daD1RJAnYVUwgmOjPq/NA0ixVKTfySoBaD+2g2WYP49NBUkVi53RP5h0e2WdfvCjV1MkKf2AAKkfdC2wmDLUNPBZIWr9vw7MMgKMy87yKEqCP7Tfgs82hkCOUEDi/8feE3P+gQdki1uS2H/eZIFOp9lD6u1yfbvsgiur1CX41VZc234lvVuychUYvo2NgBotWZWSo15LnjvJM1IsJl6DMD9tVVyDymGkNWsqEP5SA8scHTyXhLYGYRpJOAP4i9+/mw9/ctjwiwhHCSbjl2b3w2nEnc+ePCVspYNOfqkG0ipOapeOuAk6l3m/8i6gINzpWbnGojRbCMjCbK3WOK+EJNH6tVJvg1VPoKXF4OXqJqx3gJQyMCNIZp7U7hOqagLxSifwqsdoes7Wp7k3E15MYySAtfhWk93hLi/TnnUNXqTQSfIE3pzvxjSs5f4itJOjzivTlOSs+WmR4n5JVw/x+dsPWKw6fjocJYhqNUiA+LlULDB42H7IiAtSP0arSycbaAfj5WUEbgJKkgm9jgM1nxpA3zYjrAUITlREPpbivwqRbOnWVlUsoohAu+oecjGHvzD6PXVOr/RWdO8Y3Pqb064wLTf7fg0tK6NwxhjVFzwW6Y6KYfV8nhiFm8U02L09/bAE/mXblTM+c/ExpGSLwzeOrqoZM9wTxI4ModJ2YbspWGL0SMeVFkPE4+x9Ghv3CqDOGWgqfGKJ26YXqMp4auUxmyAy+cy9x0ZNwAZVdH/43WsKX6OJ0Gd62Qmy59xjIPC39lb8gPdmHLUPW6Lnh5v7uPrmYiVwlHPaj2TEf523apQBed1XD4p+CvrW/d4Q+/HJTGvkd03RhBQL7VQ7x2ikVFKevbHgmFvQaP2ncE6aICmC+3WsI9VVbUM2cGlfJ9Mf9jz1G6wl7UrtFAi50AGJErnXqGKgvvOV9naHaYOSFC80OueWahfmCeIl6Xtezss/myT90XKQFYJahXUXn9/k55KJIMPvSLcSyyKIV55v21DZHyPh5KKuPCZNadiz76Ddaqp/Ly3b5OvJPXeyG4meWEYmpVH0VqFyVESjVWuWiCFFg56s/v6NarznIi2uPDqJzxZqIec73WI3nd1C0H5KwuDU5f7IWGmvdhlAKP2lfqanDHGlewpHBBMefTKAzUUwvmwqM9akgNcmj3CosjPgIaS+MzMiWSQwNrO0Y4Sy+9cUv841Sq9PoFlYhJ4zZ0cthuxux7uTqKFFhHPEmS8Vl6/3S8VYxZsrRtfMTpLhaQgzx8o3VsmFm1PPFcEukk0xCCIMYda834BYsYDdi8NFIhAwRITwgqOnKRAG5AOlwN4vyIT6NGUmYXHfJlBG1s3D3UETvq30e/hC6/S/aub7irk1RdXd3o10sNLDXbYL3CBbZC8a/f4fXZfrlwDE45jV4Y91diLOsKc/2A8f9AyHJ56UCOgXytSi1Ywf8SUoDPbg2kpb6HE4GVOYWGGA9G8ZPg8gcyVkybBmDjqw4w0Y0iynfuLNpU+H5iWxCJoo9kxgO5ET4BpvExFBV19JAV5a1Il5Tr8++bMyEecV2gf859f0z/NSNwYDChszcF2Z2zMwO9GRVxhhDwkMNWK0f+zh7725t30PfcGcXSndhBSKLA+rVX7MLUZJoWTyWmmS7RmZJEN+wMJ5qh+1yaOLY7dtZWc0AayCLFV+c8w2mHMAqzm0ikdJPfyJ0RRzaa3Gf474fPUMCHuKsIxMIquNsME3PBPY+m45nvZ9m9JfCsOs2oSgVxwnW5gyAdAlpQlSsMfI8WuYi1vXU+iMT85puRjeENxun1OL5XnbYutHOT03E+HoyfC20xaMs3wpDe/VYsIAnXhKbu4yNqIpyK/iqoV3+E7M85S2cJWANdN8uS8k4BA6MnjqX67oWQ1A6vlqvCoLx23AFxpFEYBilSwUStu90cyChzin3WJtJ/LzfuCUeixlPzNgjOdVdmQDnfDu6LsAXEQgpjOx14jVjt0HcioSvEiUGQ4uqcnwMGiXZfI7cDd2shPIbI3WcbJedV8cOp9fCaaF4iTicZMAgjY/wGT2l2qY1yQ32TmkmA3sMAfGfNhFSuH7UBEkI2IfPh3X2MuYO26JLDwZG2WOAZOV13WZZLhjVQ+QvMeZTwv5h82daAwVZ8YVCfy5U4uXTYpGOQDa5iyuiCGuSzX7QTEtF3h8YqD1LmISRtU+WsYo/ny3RrQdpP/tlfJh+3JkkfkT/Asb+yqsqR2ko/c4YZCH+ila0okTrQQU7qEs/3a0BNfp/h3R5krLhixwEt3tqGBsyCQcZZX/HKvYn4Fu4Qbx04UqigFR82sn8pSXJ987u3DUWX66CkvFTvQEBPsmtt4afh+5onUJQTcnliZwhty4tavEq973c8H1MxTg2xMmXEVpD//g80c5QwOS+8EtHSMFbUnTBDOyyIBEvO/hitFYLsgGP7d6GT7qqLkVyXO6+DFq6OodeSr09MKw3DPIeQFuNTPu8Y+eTsoQ3Qpgw1SPqFIYbt7hOfQXOPoJ3i8Wj7Y8DWcoTJS6SLnt5qiCjO2NYgzad+ZO7nPwV4yCuvfRL1BqkUGspLtB+qT8JzE5X+t7pVH7H8V3/nqRMDLGLJPbcyWoUHvwcPmZ2c1KgMsUvO4MvjbPwc8pSoJW/NfUOJg77ZVmwgJRCZAC8tIHY5Zv2IbxbQcyl16/3eLRczDQlQZPANz8FmgkqZVR9EYO2+zhzbrecZUE1cYoUf8BlPp7qEAD69xxSaUVwhjEIdIXB20nIjUi30VDVm4jnW3MC3v44ISPL96GvSSOol72vd9F5fUC1jfxmFl4KTOu00Ec1ySx+AREl4ldJByPzfvWnIzRAKSbu8A7l5uwRJjYJ4l8GIWBxSm04i3V52b6MpGgjNZpSJDSSijOQ/9Ofq5NXpyQqoGRYtS5YzC9imwYyoj8Ke3Was9JRObry9D/ldbvBgWgs5hTY9j+oLNJD3raYi56IVGdhACQDV/i9QOfXG1iBeiIb4OKLl7g9KvvdQmGClBn0YTctw4Iot0ZzEEziXViGA1CQNzjZ3fRGF8IFJ7NLcTTExvx4JEQhYFw2D+kjY5n35PPsmtNhn+2M/fPawdJEz/VtKzvt1cM17nID7N1zZSUTr6GMxXQ73xilXIEzbk6vqdv8WRU/rGb2Yt7BcKKhXIj48ZdPjO2vTdFfpgqDc/gCZVsQ6hPyc+qbClPmjIBSsbkeZOZGfm6onKme0BjGHqYD4VaaFoXNU8NSuCvp/gghOwqrZiK8RQnB2XYaYIy9u18w2QoomXAFpfLvrgabTCn+x9BqINWaTwOZJSdkiYxodjiATFhiigNnyL72WP9cBZW0IDMXt+MM59ET/Kr6ctXNZoEQ7HF/Oo0whekqj0lm6y395AJdDVKECJsRGywkQC3KMkORVWDs2LgGGo/iDQpzKApynWJNLj0/fBzPY8RFOWpn5pg1FhjnhEL2ngjF7ziBviwjc7V/wD46KKtGAMVpSH+x5awSOu505aHKTFpx25PVUF3lqG12tAlGRvF9/y7B83f1fzpYS73I6rp57b//H1ljZSIfV6g2LPvrVGqMkzOCpyRLFMLNrsNp0AZbBAVLh0S+VlqhZAVzq9c7RjZDEEx3guSc0vp+T0RjmsRNd522lihtPHK+bzgV6iGmL1941IREIOFXUeoZIOSfkp+lPnRpzvw2yCwILrK7o+U5WzNibCL38WQnUURZfd0LvsxRU09/xWcLYKRvivzT4tRBZRzOu2gBxw6s2ouKF6M1JALR91qu5+Jdmigw0AH9rbVdijOwwjXQD6Wj0nPM+H3ox3rhpTmtGmEP4dWZkJg/PkM7OD223PpXUn4iyueLlcnSlqOXwcUbVa94RK/W0uDP63IUYmYAXXlc76fqF6XPPkiYVhm0WGFBVwxz9H0v3pqYTUEY55P2jC68FvOI4nV/py/mFY5n6JtFyc+wR+iDkyUengR/xwRNab1XFPQoP7skfsok2RD7TEBm1I833IWtZtujRW7vpFlC46MKzanBl2MHkGgE8nzwLCKa4GBxLFFUWsjgkLAj0iL0M4SWSsAeWi3o8iDrTkrypxONv7haov+zvdXYQX5FAryG81R+kZIInraVhLNnoWOrAtcFrHm9FRd3nxacVBuhXLH4+g8PDuk449MQgOfv9QwsK60w0+0r9HQV1XtgmQ788mBkkZIP8pGCMTYGdalLS3TwU02Bn4/Vrs9s11ExKE2cCvqI6oFJqnEQo6grGaC1BKupyTO7LjnpbKs/H/jHdgmHkzEyDVhVOjE7fC3187srI2Z3JSbhbO7ponQrlI2RctFkc5sypgufpkoTuy8ZsSKZNn/qOWzE9HwHIofko9OnsjBNJGZCbVxvAnKSOk9fJwqCaYpLOSgzAWbDIjSNNpmwgtrxlT86SEjxQZ2nwWXwsOkck1KduC4jJ/TRDtRhvuT/4DpZx5guon6sHne35nFkmrWtcNsYtvrzcmDqPcIxyZfXNGAkagpsJ+qm0Si+0DXxQ60+jmZlQUsfK5UaNfNHC4xZyThdmrgVgqttXVrUhjc2dBvO5d8lYPN3kxAE2J8VAvbWE8bQNWicTEUCTP+n6giselC0AHP0HafpOvTFAM2WIQyWjg0UDVrpCA86nD8AKUw3hFWkddEGf5U6ZyH74z3HxolR+JyJkDmDipSPhaDd+rglkbLdUO8Qr3QmMMsTTGe2LWVJm1kr5AJqqLI4f6WtYWDOoIqSHPkvAPlWQ3d5DGzWfWmyq1/ebeD5GEU8Ex3Bd0+zKWK7W0bAUj2mZUzklph/Z1vIlP9mk1Xq5CjG8Gn/W7NvSVLZNxTotM1egOqsPPPsc8u2k5EEmviAqzLMCEPU2huIbJvrQRztRO61zxowFpar79uo55El73H1xJlX1mlvpyleIFcvmhv6PwpIwEaszCY2s6x/L9wOvxfltBkqkBNxbQJ2D4tgfklkwkTUhbIRU6x1HNXgg3S4hQkqAcptpzETBHOzOIAk/1RbJNlYoUoUaM5LHqi3ReBKJueJTgoOOhhEAbfvalEzi7EuhtGfvnkhtsrtr10igEH7uxQYQIEHXFNhU5T396f7++yl7w55Yr/AZ47jPB6V9wWV7U7q7QPutQ8CPV5Ol5U7LPPGIqZ4OHyLLIptFfExOKAoZrHWzlzK+UgLW3/AFPbvdQorCTQIZt9Q4BXs7sJMX3jSRZAAjKge5iZ77spWYgHW7MeukVwvVYLzBbrRA5LsW22vxxQ09ck4VupJkKKzkte64TMRCmmqEVfmklqOFZ1UzGev/K4H3B4r02xGmza2TWph7h0PyoWa1jgz9X3SGWhv70uLlUCO1WPy5NQ+xQurBw5j3GclzaauYal5WH8I9MUsuNTUImVdCXrqF5s2fDxPKsxwnLYu9kxew9wLUzUv6J07w9MgbFviGRfXp/QgZUSk/szYXc6ZicCFahceI30PsKXa6Wg0+b+/fIn6vOI6aZYnDxRr0q+Sl+lhB6zPPPUMZQeKkDOI+yhgRfEiuDZc65cr/QXGLaWx2ZYn2ykg7tNHINWr0MSunyCOh50Z5JBx8UNY/qdmNEXLrD+3tP+oMzibf2FPXTx6Lmyr8Hb9p38y/wCeH46wDEyFzt54Kj4avcgnyyIaXVhImg6AbHe6oGJ8xxyxSv0c1hl7i+D3PXlhWV+C6gIARS7a/jCTyjIa4dyxiJ5xdOe02mdZPO2DoTKz38QvI21VGdpImxGn8MGJ4gU3y8IfFViAGrvks7RyAPX3jtF30xBFqAu3ZfLbrAhfC31YjKST3cOrJzr9EyCM6eyJUokuCXgIiI55NDLugrkfykNp0a2r/LWvLuG0CzqS6TSgeWKeP9SED2ypII1DF6yUXZi6mT2qeKH19YlKEFNpzJehokO2AkbizLrNFFHJClmv9SLGUUvgvSXc5GQjVjqwgYJSHuYqd4FiSG/+rv3C1Uzo//mqW9WCyPU6lAetGAFzlCB6A4Wf2lxGIMg7ae/VfybkCHrmz6liakyG0aI2CRusDIMpx5K5sqFHoCEan/7XnYrPxFLuHIH4gX8Wfy6+MBJtyH77SPFvfsj99C51GL81KpGy5cS9uSEkiNdrkfmmaOvVCDjixpz+z3izcxl3cmty2iJbI56oZSWTtLEgJItwKx8TrPRSvapJObm/6To2Pc9CmQ0mUcpq0XYyvhkTThc84McIv/dNJkLh6irXdU7Y9ltV4vIJZ4JQG1uU8sUicutbrkyviQxrX4+3ryI3s/VRQs+kVwiA+bVE9Q+o9+U/oG9jb5vZT0ZygaZCfFGQUXxqFWAXmKkJXFZ4+3FZ6VWwWrbKkphnHigtC5frMUv+hikrbqhIWyuoj4hS36AcWF2LA3ErOJD3fGPyK8zxYWI5U9bkI9OqSfZZKPQl7xchDtmlXZZAaZ6OzQZf3+PEbvl0I0sxXZfxXApgohIAjZi26tHGxOLpRlD4jyeiS4xFU7e4Wc0mRhF4NpV5WWrdI2kkiawBq/9JQjXkOrRf3pu6cOfrZghczAwKRAYIL7OwQQj38TgBZ9k4Vokj+wcU06+aBUwhKLwGl9mbaTLS2IfAXXWij6GP2zOrsF072L7NqrCYLVw0siDhIVyrm3Wpp1+tBNhpLYfbuONVVsujWD/kFv+Jrz7SHgu355VP+qzwes0TbyiXYDUBpojmuEHGKWx8sT5PO4HhgYSQb0pEjBGS4eawf4Q+KTdgnslRIGImRiueotpOUuOKkfnybC7pHnVoaixLuu2CnuJmpBzNCemyp/1dDtIooLGKW/dBLQmWAw9Hi/3a/nK/f/ASFqi4On5y5Ef60cMgtEjByAEX9JXskHa12f9c5Y8kHsD3C8/RPtAbqq6K2BlvVQ5rduWRrQl3UDGiSmGVcDkt1sx+3pvisYCC/3pMi6zFAUPgGzIgEZhm6daex0ojFg76aknlKVIIsFQ1H5g29NAM9gv9tc6dOZLhnfpCzefrRhG9oG3uwYO2SZLHfU0rj4U48UE0Z6jTJant8J5wWZ7Tk/+PT6UrEV++1axZ905sr99tAQRmODUUZc9rKBL3LvOF90xbyueoVPtB+R0uQMh3/OH8BUN34JYyrKon+nvMfUIZ0P3DLpQI8tnMk+SwQOh9lIplZisBiJ40mj3O91GcW0FfTgGuQOw73mf5oDwPqTyab7zKkjo4Bxqs676gT3e24QADPfwsbPHKWqZ2Gmpd9kPTPy8rfQI3Vvo3o9gvN4WHla7aY8Xm9Su/PqeGUtgXlk2O0Y5arsc3CeE6fyInXYbz+K7mINPINes7mM0CYlcxCehH6dCp67E5RAtmUxG0ieKAV/Q80z4crGHuVTlU7J3gdJywfw5sJNqI7uPZ9C8+Y7EbshImUAZBsevv+0c8yobrOEVz0q9hk/kccafKOqLjn7SEv22nWpuXjoCg7iM/NYNYDdoE51lcZGTj7geLJxIMsMUXgggHaJDIlQBtu9TvJDWbD0W8KrhLEPgusJEJlrZztUJ85ZQ2Bzi0q6vqABfXmHJiyyev5VlnFwQnpCH2knbvHCljnbBd3gbUONGjdGwWLeK1OcwbV9+fVeVzrR6oOEV0ZAfct2tjRxQOWYwliP22GcjUn/t9U9CcdpXDuVXg/qFzkoucu/L3kwBcQe+LOUAMMFSIhc3uj2UJlXXCLGwL41wloS8p0qLH3RgV7G+XHB1vW41jQcWd4frJZP+P1FDdEyRKfba+8raA3A/bC0mayQpZwAutRG95xwONz9Ckxp4aShtrs53nLHGZtgN0+S9jZOp5tqjk2nWYiaPkMhGUVgOeY/mnmRt6Ulu4lfSMQIXULNXD/tPqlon2KElvo5GUHjFu2jHXScKP/qolsfaL2ZmLWqXZV/RpaGFs5VVUTrGcwspVvs4xBPt/z89iCcc/KN07SmZowqTDkytL+Gu7XeC/c6asU3R2FbDLZw7WH/kAEam8fs5LsoekdFvHuhg4BMoq2gC2IfTS2HWxMW4j3Dv2Ax0bqMdi4qZONPtA1b5rjV/+Gepc+TDeMB1XGYyKZkWh87gxCMi5ZChM2M7DBdsd/IEWv5x3Bxb0s8BNjpA8jlXVyYrN4m49686Hb2/mwys1f2as0Po5Q9U8ooVjbTo0JAlsdFZGcchSNH+DDMmlZkw+0ldIeBmjQuySDdgXzHjJOboxkCgwEYrpI8NGMw54htAnzA10zxEPcIhABMz/pFWMvt3/SHufVa3dgLnjBudVY5VSz+M17y5Swg/79qsnZeU9nuBicIYZqoCeC5KrdWc4/BlJJO8G1FN4ok9GnUTsNnPqYvFTVc196UAzwNUmLIbbt/Ontl9wKxqhdX6w/UeCm6HPwM+b848H2y+APynKzDO0b9EdhPlPJzsILcNcZSjcKC299HkQcFnFlQWZiWuQsBMlj227nqsK1JnaxLsIkzlGyvaXe6hyCybHo2CeRrDu2WGX1lT+mRPCn46pRXOCy+9LLz10EEd4dbqtEdYb5u9XbXyfkkDRkubDy0vFFtLf/U/ZFN36d53ioQYh6Y03ofxqQ648ohLjbILK7C4muHwCwJ9jrWiqdBm1Xvp2drihEe4OLiy0CLi3EZosl0Krjd2LaR7gO6S35/oFgVr61r3vKB0ca8EGzh6avKp8GySaQWI5gc2zCGFXBCLLDudzgFIpg0uyVd0oL5shfuLnoOFgvT+uP9T1YGZFjGg6kqXKON2sXHD39mJaq/A5eVHTo/TqXoF8N/9pIVVU0X4Iy0TOAKgYFR2gRtLtVzqLzVoKnZS/bn3qJ1SGzMtKt7YVYRtpJfmZx6Dj4nlAWfwU/jWiJLjK75r6CctBg3I3HSnSZ3aeHx0IpmEP4l2P0xzx/b6SZFaMAJmhheWFq9Q42+M+gKnuKbH+FrEinQ9/7gY5nM5hKBW7sZoC19w9GiYhxRsxDbJFLKebJAzQlQxwo+mmM1v5eEP0Zjh4WVsJ8T950S1UN4+t2/U+6yLSRAdRbP3AXw9ya4UCzKIQa8ZOVSa9JDQuJyt4R1WchRnz5Drxal8q/hgsCoF1I/7tPwmFK1CQayCSqHFAcKMwfwadQh+s+2JZPoErFz9HDq0fOvK0nYenJsn2n7AJusYpuEmqzI77Ovqqt3aq2OmIvMHfLWPfH3LRZM/CJsIhyUQN4LWFbxQmWG2kwCrVDk+v+UBShGRsXoL+9GxgS9sIpdauAqS+whzLbTOUn+wrIrjhX3vKLCFkv/ou9YrreArulfrSPxcZBb1PKlbGK89jBeK4G2pOI5U1WGd5iVH1S82GqamVbDqzn8MoBkvRlVqFbJYf+xh+6wcIQK7eK0RWWUo3AQIrfJSic7B4T3Do5863oY6PEs28P89p7a0Qe1AYXw4+0pBWZS6JiQMYfdslpp05PDat68yPeqdy/NIdcB0V+isTNyM7Xg9jZaITC+JEuCLySukS/u56QtnVumLEMe1B3ESyE+3AF1jOvCCffV1gVhLXxNxkeiQ8SZtKj9r9yslWrwe7R132hJg+M5KrZrMV7fhGbtOQJSG6qNFu2XiatE45Wy+YXP70DpEukaxS64Td0WA3EJcUNZLsTNNZ/D9BOTlrqVHNKx52BvApQ3+qQYVgD8Zy867dxvtt0RuzdhwzwkKS3JiPF9kfubg7Hp39VE1fEG8P8yRBNEimaMGIrVurzACuHBpk6IfUmh/amZF2pXDtOUfFU4ofXgz8PEydlJtrpVBe0f+HnwAYxR42OBvsbPsq/XxkgNcJKlS9S3qGGPA1M91J4fNAoS6YgPK5cPduVR8R56OwWqdqwgS6ptsF3LZvHnqzVysT+FKs6HResFwh+LseKWOnMi0Qdy6D6p2e2j9TCbHnT7coZxzFCYw4FGfu2pksSMZxDBrXyicxuexjeeQGyG1Oe247JgLA2jPZekpk7/ggturE++xXcp3OkJpjtJYOv8SksJe6UPAhVvgmAauVg5/A4/PUKD7IC7XGlPumXgq+bnMDSmB8HfYyGKzjmzc370at/FrkqjE0PBFZ10MG39irysuevVQ4aDMVCAC2W0TsHSK3TTuFiZLkB4T89codq2VWClx5Wy4XlLVfWrwNl/31cydr9AkPuu4NoIdXkrwCBCkHrhvxrwfJo+o7NuzDo2EvUSBNMOsWR4YB2rnBFXplWRcnxyiarc16x1CWLmUN3+cAQtL9jeebdhmXjsZ2HqrQuKsOLdWpvTKXWY8xCTZgGHHerDSur40zGj1XdulpcvX2uC2h2ZWVprDDieY0s7M6R/poAKPsaJOAR+J99aG/NVWRqidJCAhu9CrCX2Pe3CZCdE9F5urNZukoLAJqB4ESq5ncUs1bZ7rGW56jVvbt06ZG+lrah+9yC/C/vfHk+n+Sv+Bv7ghuR3KQ8zP43B6l9flvLOrixYWoY+ipn1EOI3XhUxwkhr7M6acW/9a3zWvj/JNgrP/8UpJdj6f8xoRcr8fqlHbJ0fKmwYN4WYKX2FJz4Vvsvvc6FUUt7bgQsaBlOjaeqNqE20POx/SjXQjHIBCNw3PgK6DS5mpbod7PTka11Wx9acDoYN7UnujdLpnYitNfuD+7Qu94y+1Rk1SimCi9i4dGlmePGjGScuDK1k1FiPZiLf80Lcr1vmCIJZMWQF6zeLt7HhEjdCOndS3aCTSC5U5n0kN70v/2PKJTGskh45ealJqv6pmnJ3PxjLsFmHaZgk6fB+2wIxaR6NOuBBCwVJeKcM6enuDnZjp1vNWy+PfEOZWKOkfR2ghtG4siyDRBdoj0zxCq05tVLGys1BbmxfP7pUVSXHNR6F9S31q4ueKPoxu0AGcAp95FE/6ndUlY2R8vY46i1R2KApBVPtEYVqZpinapgI/Le27UjhSiF6qQ2nxFYRsN77+qV2xXJEHwj/mlVgQagdtUvHKOZYAuZbckqyLe7hHjlWvsuw8l8zYYTXK7MyVTJz6yH7eWXwVy2dGOaylYuKwqll28YwwrGYJF5UkDT39hNOG7o2GIlkDbYV1Db43RDIyVp0g5W2rRCvZFVoqtsE0c1IUQAsb/x+xi6+ZxyN+C+WwtUe4Jkt1w0usgFxRBdMwNq/ozJiNGiXOoVhg7CuyDW2j2BE0iT9pAnaxt97oGbI2Qu79stYvh0F3miiC9cRx35hAJe+cOq2k+fSEBOYu0lc1Ocs2GnQDv3+gtps8xlAtVmj9kodwqUnmVN0bVORivwuKVnOV+lVlfsx0dfz9mCvQs6mXMcVRgFH0KjETiE3mRoDCiiykNmDgaeiarCGXxpaIlGGrFY3eoM6fEvRCiNxSccoQswDsayvXWDhOMLZNicvccFpiNynmpF3IfDsPbxGly/atJe7IALo23yCS4u/J6M0odfoEQ5ZHUL8dSgZS7NvCiblUJ0+ddn3ThatgUDsxJ9q6IHb5DVk0kvGcBJQpD4YOFI0gTxIw4vMdS7P9uiz+OSPGubl44nR+HzP3acFdRckGt9F8YfOyc0AHxaTkknt555DpDRK0cGvP1M0ysGwXs//WUzfRKrpQHsdvrjum86L93AJmKzjhYxA3nSQHmQDFVYV+yq+t2dzz9LuH6z0EOB9/XMG8xDINdvxrLck97CtUpDaAK3T8Fizb87XarYlMaUyHzzvzBUmZav9a4xAt+kkSV5ojbQAmJBCKkdSehlAYpQbSqccru2L/nx3CJO510oqtTwmNLF5zUEQoE1ln7MdwToO4YAhmwd94mlc7swGYB8Cle53b5HNe4HBt2pElvQnjaqHq6gvicxZen4IF0r4r5fW3gJY4VSPyOdyQIoGdBecpMUVqpwe1naqiH6S7zYTdNg69RqowQfNcX8O2zt4ARHUxFFyiFJkvDKmT6vbW5H9wtFMmKtlkI0byF9HHROl9cN5PsL8NtbNrVQ8yoK8PKA0CAUcvLCA0/tvN8V5yICtWhV7oo+LVbTnl7O8PLGzfNFYiGl2bhW9QfhFEpN3JzadXXo1Fp0JTFp0CSFHsskvgPZoOvsaXOWXLn9dOviu7PQffMmNNjnYrpdUNupAb6BUXXIRBCPuSVDKCl9jR06g9OYJUIoBX84MknuV1O+iffKS0wERF3VbiwMrLPZXbtlx/9Cj8LVHvT7LgZMbcVcO2AWQA9M9GficFl1UrlVpM1R/lVHyo5KE/iSZ80nf902gk09eD4phjZuVp9Lwun16bFvNcpt5YySF0v4Tig+n5OSyroU/65u9Nv9R3OA4JJhdoP+p9sDT18Ijtlrz8YuziPDqyMMULnWj1bI0neg53V3PvywffpXMDckv5hDK+xAL3+xMXK3x48ntJ7Di+vYTI9+fV6i1byEYYFEdUkRmM5CjaqaRshf9exBNSotUCxx9hn+Vw2kWyTqpmY916JuNP6GvQFyT5TaWC0hg9iG3KXRd7q8254DcJEHNEnZ9x2cEPliZfwuQKcTXWxkq5sI+6mBn5cQCTqALyHfXKvDCsOm30pdlr+SnvlQPpD0fWYS7uqeamh66xxQrQf6Z1LPYH93k05lh23ckB7OxhrJLrUQY4M3IU/UICO2DdN5LX/ZR2EbPIlzNAjiZb9TKKd5Mo+QAChbLjI4wKGfKdwEBZxI3sSlac06K4kDnqbgWTSGkWoyFU9zl2nTf3OZEoqgv48oa3l3cQeTeb9ZBdMgLB0CCdbfvjZlhrziE6esB1jhnMTIDX5Yy9BWRoB+2z66pTSFw/nTAXCQ91QNC6I4Gkb8gwsUfz/hskAYmgMVLXUYHaMpwADPfUhWa3/Ti5rnz07L/u0SjX3guBJ1fwrZTJR3f9RwMC654zMDLEOVpnniM3X2fOUey+qUjFufiO8Grr/MzuX85yGBGaL8JIFohCrCFP5nuFv1ISxvrQQ/AOm9oDySIemEO81jowgKgyOy86ruv9UddBVcNB14Uk/S15klOKSNKLUj+NURBHvsZMwfO0cU/Jsr1kfWMAZkLfDe/CaKHZIhVdOo0waoVmuOrOCLyI/dGdu0VaAK84/vv61ckXeV6I/HZ97Hpapmb+k4szkHVMGJbDJXOnE+N+GLH6mRHVm6txHrhnLF/IqeFyLa9haVthSbj2mHPcfdyMU8JohSxZW/vBX5CpOQarGG3mSoKZHho+WlTCVVBiF3lePNBfpHnDZDBUDi068GK+ndOFs0LRkfleYtYsmp0u3huhKDhoYlEQ2AOyLcfhNqP39844OVMWIcozQOE4eNFyOfpFRYMJGbzgsa5DeI+ovF4KKW0qGS5KZm+N0+PVwuUBsgoeG8406PkLn5anHgs0XRTk2wKQZ2ENY+VBH3cql3sTr5oCx/clzQdxcAZmqrP4beasCMCjZhgyA8+xVqt5zW0QmlnhIk/aQe37kc+1TF0xQ83SS/K8+UqeTbIrFs+K2F38AECEWRQo+1GEkMzYLjdWlTn+YXowk8ikH4O0S+Me0u/3aLOkZFdTXXb9FZlHqYdn1xE7VL7qkoN2svIKIN6W9/fAXuoDoEjYJSMTFQjIAeVmy9Ho6Ogq1TBcD2lz+ljvAeoq2KPSJCs59YWDsbb5+CqGVackUrLiSX3s1gpfFrENkqNcJGWjXKeBa+YBUTlUuB6uJ53IFWI57SA5duYzszqTASj9In61zbFdmv/6xOcq9T3/kqBDZI08F5xCjjX7i7II5RSk77FvGp3wLDSu7eDVbkWEjsvvju/gJ2BXPvXca8/s6J93acx5Zjsb9gSJorod9+J5equ16fvWzHBSLSchKn6BlBG3cyK+IEMsxe2QvbC4CHfwDyvjUNSWGVzIwYraIKIJYTw36AMkxpgG5qwYg0sUKJppUXTal/nXKS8rwzQLFlg6KIuLX1BzR2a456vzFRRdNuW5jLFIFLGQ1/bbdiPPxSPeouEfG80nDwZ549d3syY+gZd/FElCXPJnxk1sggBDxka8/e6J8RjfHOsp0uIWUfCT9/CAjzMmxj1LBl7cIyfp8EU7hdPk9IlgFyBlu3iJh8ESzSjkyOnUiU9AswwwXk6b/WTkWi90uJTO6b+IWEpjRFqNtaYEWW6C4BzGYK//1vWOxWN090Fayn0R1PpTj5WKV5TXTAO7xBAVwBX183JxPfqbXNxJRJjUHW0gL64vj9ixOGQOvV72Xc6sjSS7tLQWuKQaa76kCv6xBkDFCL/Gbsuple4a/ERHiQRAo4zlkfjOdeSkefi4tz1qgSbi9HyU8b9jlSz62ZFH9X2RBtVxwlXa75jtxUZaoh3KTJfkQfzE7/94IMVS8ovED0iT/xNohRdR/a/WlojnE9aloizihfvpto7k/R499SSUFA5A7+XKpx4qRvJiGEPrAKglY/RDedcuXACBCN9sHJ9+QzqQ2wECSbmYpCDE4qbZJYMIirPW6ODewl8rbd2HSRfLNxEpHiByToc09lbKL6DPBegf7NbVpeqVzM4nWSgFobZPzRVWFXqUU+4ReFhAlbZpbyz0N3OAY8n+CgfueNXV0uXWisFnwkqrIci4GmKgib4KsjcquPbD0nhRnlwGRE198gjPJ/+s3VEEhCNyzhi7pGbI8l5Ych2kflaWIFX15A3VSDFSi5D8aMsmcXNiljssWiceNIY8vMVzcoBq+h5ZGlW4oT1D/VPZkEdDnoJMxqysuZXBsUxeUr5N6e9gMunRTQTVUytyTS7EN+VlLMRfmbt6EJJTvTElTQ7enmK8acJGYmaDpFFPbaVw7RLqFQpX0tXiNTXtS9hULuNaRhXXiusqVTRdEfD1ovoN+usekQIjuto7rSM6YBdzKRLlZLUdFJPxj2w0BHOzFmvWFZppL2HUfcsmoeRGWukAdjnTIRJHAZIfPESN8eEMba1M9Z+LoKEMk1DfsqEEzGtBFIbbch/7xJpVlDBDixyxpeEbR+zNjZP/6BMcMum7Qeya4x1jEYNNQwY4HXZkDD76IUlgHXJAqCWNepjize1PUwygKaQ3Iv48weFMHUe7jZmm4l5iCoKZsZt6sGD/rTZwk5MKlSiBl53Vyl32y4QOIu7LMprQeZWOHv5udf/mwZuAZ0lxA1fTYny3017fCC4LgVSKfOgxX73oCRHAG3wtxOTZuq98j/AruQoUlKZm09dz6M67hIvUqvmJC1vfSkQZoZlp2buQHZDCCMAX0PVTUGkNMRlZFjG3sK/bcrsUkY3Y2HYilbZlZ/bXJO2BVB4hHjlCvP+ogwkSAjNLtsN1/pIVLcyT3I375SGdJUOleu+jPrcQfF5lC2C8F7+ifaGi8KksNnKGFLbGFlVrbXRJkBbhnDEZ+8dLUo7LpgY7GZ+HePoJnJSF4TwY52Ij80tQXAWAyfvUSWWGTrwM6BrInoKw9xptKuE1XTqPkPaQQ7h2vJAep6i+Yrjfpbt/7xI+zFrIlnowKaZVIh7B6Gvws29SqL/SzUrvYdgPZAxmKEcgn8FZ8EnjrW0OyG+iXMiv2CAbhPf1iiptiYAhqRw2ruwn3wJ8f6iKaSxljY197dD1EXxh5u0GqotWW51wj/kUw53SdNgC4j4menW/drvW2W9ZkM+TTSQ7QHA9xJfKhhz/FOMHmTku7ewhNZFpwBJBk29uFWy1KxWw0mtm182vrKhmhW7TQSbnUKN3Frw9Q6TlrC5B47gsKUWqlrEkuTiNFMz3wgo/qHsoYWCzkZggjdeVI4K5sISnZ7Th34ah8vvzuSD5Vw4vxmzYFOIWBN3WmiRvhP0ZfLu5MdoRWG4Bk3eRtDnkmNRGrER5VjJ7GXp1n40Aae69i6KxlxqfP3ejYIBdf0iYTw2wBAbPFTI54VZyZx/I1BM5UBiJNBFPkNJnYAhXkMXqXDxihZkgvBvipD2cPjhIa+ovVoaT17nbdMNkEGVYQ34/p2HChUnPP/OHC5yz0CP5DKgFkvyzP5hOI9JEVJUX9N+/2xVdVJ3W2wdmFNlfqYLUiGqfE6ok5DVNaSVbmNhDcLXb+TkWqqj9DH8fM1Aj097oSIVwJKYJV2UzxG8js24LGJsCe7AeFZUSKGlm+2dzUGbtaFD0JTgst0A7bTcfa71TBYL6WSSeEkJYaaglkmZRWtiyxYCz0MQ4ewzVhcMOU/FYdAalrW9TjbxZy0msy5AWL9f0FOq6QG6BMtpwqJUtl896kotUlT95lOmwsMM/Wja8ZVeQJ+sh/hVR7MXAaxU2YGj/r6b7w1XL93cTrkIavOFfO6nbRsePLqE58f31VRk+VoCDjnt9xxtYi4JDqzjgdzn2Qti+pdEAmZ4BGU6AaXphQpNZTR9X2JQvXUlc1g//iQi05nAAB9asdjHHNxxygPn0IgVa45XyO9rEk8OJY0ozGBe8uIQe56q9dn/QWYjfBvUT1wF3uzEHxWhbE+8GEcF3rW1uj6xdtEK5NOYtAFNucnjDL8FrdfmEzl97wLikUiBhrvwzoYAgCRMy7aQtMqazYFoXdJCJ1vq5RGYzvGaZ21+xS2fGX0Xw1oMP2BK3N4b1D8fCm4OlR/gNrIbv+cNnOVQE6SuQ41oMLYqXkDsfttwwyVmDd0ROA+/o76KRSXf40rN+EbFGa40Vy9fNNjLCoB/1R6fx8o4p6/o6+yjpzjA10k4gBEGgkwqHiha/HlvpCWmK7M4BFDDKMEkFFpIbCR2Sfp9U7w/Kp75KNhBnRbxV0FJ9KOGbrMXQ21UcSOGr0hQtV0ld3hMaPMeMV+8J50LaZdKWZrx1ngbAw6SOFPzK0AsgSqbWXFjvs5Hvpr/DldCiZzmHE9eJ+R+8JR7rKqz2SPeZw48hjFK4k5ok9YA1zQ68nYnXNs0Zd7bACHW0O437VNrRumIV1qfsN7g39cDDcOMkuRoEazyH/11/O3lUYkLmprD901W7SSA4vXH7brZWWwV1uUsQ78y8xj1KtbsheHwG53rMldRVwzKDC6qGA9ZUoYAnozEji2UXpZqTULbVGnJWZaMDXi2QmyOD/WUSUIWiZiOLoDbTQjoFiKS7vHsb4P0IKebYtTin9SVcEYURWRTvQ7LcFV1nzfxMoHwMwerbHb9oLN8aytP5dUomT8UHzEkFENUaCo7Yo3wYncYntCsr2RW+JecQgrLvpjdMa37FFn+k9ep3nnMfTRawBi8kHknTRPxshWl/mfBL60wfhzU76hB7WxGX6iAsIZLzhi68aWwpX6ae1jt1FNC/7o6mCn+m9ZaLcykLZ2iuRKB+aDsLraevVwiMMTAVE/bvXts5hSzDjtxWSNidilN9Z2Ac9e/NYZ/Fxmf+SOc2VMgjtt0kS3IdDJrI55sDlfYhjRHFdrFRGToTOYqMtHJWWNZCxFT3BMX+g/Z/6xifVF0VVdEOxS6qruPKcxdFa0oajenpfPNvAR7Uq6kHMrNfoLx41huNnoWBWf928sak0cUFRatvo+QIVk8QK9DMqgpC3+vw5vmmIATD4n+fnO5PJMVqPMXFBim2fsHiJVcisDehxXCTGnjvqriJP0y8ANrO+55DBZuUmBphC2+H7RgPL+xRYr6cW7GZyQMyN671tc8xccup6ZKq/APv+/cKYSd9VHSdbZiIRWeKrqWgZ32pO3sGL7Ca/esR+SQvexnMD/iNBsrofUhckUwEoaSmElT9Scxn1fPTtMya0tEFNAqT+/gALoa018L92j9aMs+5VQ6zB79lZvmnM3jqonW5atTBOlWf9M0wOW0iyDIlsjVjECMJeoo1eOVYgjyw0FdKA6CPcB7dlsLESSt5LS/q4lFKj1BqdjkU9hpG7zEXKj+KgLFnew6ZY/CgtCDQhcJYAvzjrO1YPt5T4uZ8l1R3z86ihSOcXyCko1YXVdBV622PkJN4MzB/b5qBbJye4TTPtNm6KYu+xuuegsey2nWs4IfBD6QVOMQwZCw3ajPGmCnB0yQ14thJ+0wTdUB5h6v4iDk5JJISI60Fe5YJP41r+f2QYLYVeQY4rbRVXbtbBLuIQTL9+ltbxLwka4nXDvrtk9bDBI4HnhkSdMIghV/GNlzAdHXjRlqe47SUkFV3qwxUvdULHpwfT19si/p7fttp+yz5L6Jj3j1TK/tmwhdQIj/3oTvXnDJGbMKY9BlGqEZNJFc18i8Fxt0oDOD5FpQ8MFqKmd85bSvwHYz5JmO+s/kfmjKlge4MZgvgIGL3JOE5uv1S2Am5+cck44+EfI7zQo1hOtkDyQ+CR5dsbogLVSe9zUpsRrfINa0rjn9FT3C3tfyzK5WdtDt7P5NM/pqru2druqnJwKK5A9YQmpNyLuJkJ78OZBR53FPnBpvrQyxmAE46LuZyWdaDDg0Y21KSMYR0hXwlsSPdL68ul3f67B4vyfHdfNVMGuGEJh5kR0sC2hPtKg84ilq4n9ZrS4CZ5Joosl9duJvP5LJkCjgL9ItF3+wS7BPhOq0JpeATsnJ6igHizH/XySPwY+C7/VIlni9txxhu6IY1xjPH5qx5nsSBxFSt2+OALic9PGXGKuEvYvCz/3YSg5l1JQHLumET6b21z7sP+ifqSoKSUUXwr1XgmWs7wlIx95cyn0K4CMzpzYHRrv/0tpabHKN2ez++GzXfOmQGQpLQfqWFDYydKs7kyX4cErdzIH0LSeXDrsdilA9uM45P1X7TuObT0KQvH/J+FiUpb4/YeqmjEx6DcagjfqQ351E4rk18hF3vT70/eiqLAuwv0CtA1VR+X3V7nwHs/or9tCK/E+F0ky/9uGie+UPw+IVEJb+WUm3Q8ViKqsLKfNXymK8+M5k87FA7wePwz5bvDLZXUNENiG3MZKKOlMqINXuhUqt5BkWLj1SopcA+Nb4q0k1SGfgVXmS4Xj4ILgKiQlyZ2ru1ffSiwuEdhg9GMekSo2g7gyx1Y1FSbmOEsFNozOIft/ovZnjTePODZFeBe9ULvk1VESfX1mOUzHn3uISkARZjhJUqUkLh+3CdZ33MtGOEXfAbQ6lzWEgHqrRDh/TQdiCfAiHXscKtmXS33ehp24GXWvBjeb4ymw4DPnVo+v7Sm2ng20RsNX2rh2UMDT2C3Q9Tnsp86f2HKm/GtpdlZTyFwmtEmTCZhY7ohb7FIec54KJtoSiJ6Ile8938gZzLjgNL2OIDpaHnEeUsLkx8pAtO6zRNOpNP8sUeXsmOVTjE0masAYIv/SpF4wrWXu2dgd7cm1GQHl9aanUxnXSlwUMAe0s6eumPSoym2/rMaHg6M52m3Jdpz7ZWaicTFCA39/GZ6eT3l5j/gdXa9fLzBxuX9MEnRxBwT/CxjtUKE6CVYOfv+mCyaLurnddZq1Z2xuf+dUI4W91kcjLHflTO3RG7faKQoPfncISj7TSxgUUGB6wwCMQK4gLzILG6OHdKs0PwS5o3bvtBIRAHPZl8oKQ5m/ct3V4PsMff2nFzwkauJw18cm/xU5QdUJF806JOxmVUgH4Mpy4kx/LimBc1GLXunhi6xBErOaKKoXzOv5XABu26xLfm+xoSiOdpF3ysxoTPpfEZ7+muI0coYTql6s+ka2FALX/U8wRq1I3MxYLLFoZdwCfAZ7XlLzvNwkcbPEpaL6QFYh7YxxNHKgpLmNO0q1zk3qhAKAFAdrcWhg11sTDSnXdOr798R5bU/GgsRZFFQMPz0/ZFPx3uD993YzxKJviOOt1k50KT6wcEhl1HMJzy2bmzj0Rsz7cAEl+L2OxN7g7kqaAmqvzvtStsOR/r/jszbA2ut5xC2Rdl4GefCk3xl/B/SKq3IKOrAqVBFxYbIVi7g+7AJWVXg8hVhzzQ+pJ5YD8i5MUpnisiu5Shp5Mu7RR811Kz5oD0kwJeJAqgug+d3LnhOx1NUTlg3fLf5nTO3VNgRHs3VMUQ1yPfzlCHyk3RW0EhMrvNrZyg5LMLJYT3TE5LTmKmy/yP9sOOrDPJty0SNvg7Hka0OMncXuK3EH9FkPZ4/5rrkhhOqoNmJ1TQ2t/r45Oj2X1uISIbaL7JJ3th2/sUVGa1pWQvBqVsUeJ4RdsPRKI4C64bNOyGZ4nDYK0vZ386bCoZQCQHL3mpm5lenSOYHhE9JvYw14Kkb4qLoTr+gJwaWE7Bp1DdgKmxRBALCA4y1cAGc5i4ma06V7nkSDlKybdOj+iNBeNY1tyKM5CuwkbZZf7kvoP5BR0QsIoWK5X0EiCenKf+Mun4yuMW03p/whj3AM3m0DXRmd7WM0A1mMMhUEaLf1FL3mNx8iE+IZlFR1QM0x//rnIsUQKE7kxamxcSKVgA0FxAg057OqqJdBJlC0bxBG6uY3rBnUOPCh8QDgt501FXnykCHPFhAdwxE3eb8KVp0Ivf13sFEoQc0FMrv4NF+egC5udg2CBlZJleuL0idIuYyW8dLIM+Sj33VigUhcuGKaYFVjWAdBwnB77R6bSWcOXxB+TLjR/ZG9bdq5VHfrt+vn0lX9QBXfLFovdky2QSs3/RrFPRPsl8JYCVi5mOi6ZojtgXLTu2vFNkwomtLskGwc6YlqmeNXIDiPQArGVqxETMHab6L885bHNb4Oa4VjDtMNvCT2D6UIuQT5inglJbpQSNwe5oQo42B8+aEEIE4pEVD1/lnayxghm2leRBWILDuBA1cSgwTzdKpASCUA8VgwQ+skACKc0i/eqlqV4K3K9uPP906XGSp4Lr/6hHD5sagahriP/QB89BHyyVg8EP92qJKQQ2EkfL1giciYUgh/nfOzecBc5WYePqsG33e3n870nCNMXsEERCuppRdCqtLBz22aWGzrZwMdIjHuRNbm3LOnsClk+3WnhfkFVndzfvS0OYAdFw0x43RAXYiOSRmUyh8CYTQ97GCktfjq5G5ctU1i5M+6W2z7edMxr1yB3Knco50gRREIAXHwoOj0vEzWXxI93RpdTQACsPdtwxavKz2An9qa5gYsNe3xktHBdQ264dHWjpFGlavW2Wnnkh4yTGk23CcAKwc/QsoIsRZs51Skuupi8inNl75ngY5MXwSd6jLUVNz+WkhSl5fdI0JRTAHdcW8i7eA9j5IKpMWjTcT0oTAX0YXpFFHh5oA6qOwPi/MwqicdsRdPyEUSAbVuAz4c/fSBo2KZWS/bxjBSrg6BS7m+MyMCW1gAFWQZBM2EXwX+Fan8DsyWfx0VtXnkeLLZnfm51wyoYez5mbravKg19OBBrlG4C1+xZVB+ZKbjc0CrxxIkC2j/bT+m8TQ/Cu/T2zPVWdcue2k4z2EF41FJufoxAm91sVWY6YtPv+J3kzS2foej86N3XE09iNAttA8RToIJT7WUxU0+iLnYDUqOKQ9ca5TanSgPOTykK7BjKedy9Tmg4dtxgOLEKu7jyQpqUliRPGBFqYAKV6s+f22HGgKueHdxkfY0+afckXemnwl/T/AlpVgDIYvpIwLexdPKqk2aR7Zy2OArEUllXZv1Qe37t0raLCPyfVj+qP5TyptnVZhv7HhfIv5u7yNHCs+RnNzKXpSuEnYNtoFRlkBS/lDmMjGxe0ayf+Vc6iOVIKWNJvXQZxkCD28nHcSQwq5ODeqJoEp687qn3mS9wVhQIgJB4VcDvxARlGrldyB/TorUkDLkWLNgNAl7nMDtwZu+nxH1JnRqHFcya9kyMuMdb3/kNZ8Kep66CKsopPRgAfTXK8po/jZBYh1/20Bs+mNbyog8LrVDRBqALmqH6P9jz/9j4hOyOlb+I7srzFX7rEZuiyWTAAynXUnAwdNuHMX/p7F2mUgOr6xaRJ7FV78j19vV2r+jtEYrenszl5z3G2Qv12LxJC3JBFFGawdRUgjdRzGYmBQ0yxHRv1AYy9TB8wz4Ag5GskrH/WfFStVkSGpPoeG5zKflGbTJiHxGuO97d/3DgmYOnOQFfBnGEODMO2knTJszBUJYjkQgjLpbNRn3MK5DaEFg4JYcT0QJcu5dYC8j5L4FVP9yXbYpfVA+EM1Rga/CccALBHjcZ6gti1gQ+Y6diP4ks3ILo+N/zwTjE/LoK3hnLns7NvM4irJ/BRE5tLrUt9s4Kq33q5+zqV0NZHTCIwD3m22IZtqqEcCHyUzQT6Bg3thdbioGDdVX1ovF24J52GDZ6dqFA4a4z/nfwzKxf8trgx2G/J0s8lxPdLIfSti/rUt0XXNeBxSpq8roqcrBRsTC6qcd/7jTekH3k4gRCJxKcxwEcvLVsnCBzZRi/uc0hg+7QksFEEk0oR8wz3ekFcv4eoDWI/fgoBdf9/PoAdEsWlraZ3JwzJKVizib48V0/l6TCZH5TUs7VUjzeNlOtT9tckrHbAC+92Pfwg8smBl1crSXh7QmuITtbBZZrqNaqzkajePk7n/mOEIRd6AxjWZvyTLAp7mAR3ddRqMtW8S09I84/Qq1rLGng273ouhEcbP2e+h6zJ46iyCKMnWpCXcvJRfA9fc55BfMmX6HtXq/eY2deFRVpbuukYgpxFZC1YyjvqiIPNVVW7VpOEdxtTfvpoMg291qz/xc84l64snZYJ6LdjgEr7r5D1X6fbDpt/Nn5/hOboxRT0n9xJvhiBTJhMtZFyoxSFnp/stGcIOrySFRe4mV3fCOUwg0D1UzZ7WLPhAJp/K9XQnTqYF8/lHVRPnOfn/DF4zgmyBkmdHyfcwnDnLf3dX/54LgYjedRLSsMVQU80sxNYeglLFtgSGRjxn/UGeoSb9EtV9vEdtZAkNP1idTGXxIkEU6jtVHDXhc4KfHiubaIutp8UajI0id6QutOSV7tx4vuN8YU6SMvHn+Q5tdY0l3gG8H0TTgfxtBubRfhA8E3PhlVZ4t4yVT9/n1lqXu8ZenU0zPDAEHPSViw6Lq+hiegtR3FuXXsjF++hID53M4HBXZ8TF5BeLwG6vdOphG7N9P7fKeo41E3vNSNS9e3LFGwKcOYaamUFkTsbOldpwBYnhHGWGT4Y0UOoD4bHi3J7e3xWyZRcldKBoyK1c3HUKj0q2eQHEvXwmMkBRB9mkNTfWUmLxn/xhkSSZ/ty6qQf5+HtKoRdkVHDE6wHnHWMfMURXVJw23TG2RdFGYmr6KC5I/cxamxbuZ//rBQ+J2V4u+lQkXQ3ZMkAgcv7jEBrXHZOVXYHJH4eWZv05rMbEQDA8Mdpwk9421psVFhrveEV8clR7BoIoYCm/BqSrpMq/FucwIlMgK7ma0jg5m4x9VT7xzo1l9f+ogAY6bYN0A7uLxGAYNWZvCbrdixwvkahpvaDfHUZ5oynrKfWcPojLoNFcSrkFwQfREKCNoBFyutHW6oOwzGAkLAfZSzUpOx8mjxD/4y70FDXnMU0iFN7IyZOsrFdHTp5lh4z5Qkanugm+YJHdY22E6/dq+AphFf3TdgVrpccFPH7kxmUMBVGB26ojSqCHu3JWBMPVL1jve21ZTIzawUPL0XA7t+vhCpkFGPa7v1YEIkzDAKm3czLzE+4uMvlPwGI0sPwsHs9wec/210NHUj9fe9RnfA/yLAfijEZfEdbCnc2DqnBp4aLt0xCA9y3TSVOz/2rE0SftWvV0aOWEdxxBk4+9ZtTKnmX7gfag7ZlC3+9W5sFo1/0tPpwkAXJc+3CD7XICosFh3fggins6ITtMNPn230zDspu2M5XxYgrQ837hSPrU2Bk4FeUyY69PvuTolpGRPRcPuVciTooyujmo8ICz9h4xU2t5cVFxrrfkN4EReloS3rq/LYwPjErwhvvDHPtm4isgR53D2LJg9guN+6+iWDJuHlN/wI3cRVgtoMfwwUPjHMthe6qg3INdNjbL949jdjRosmNMdpP6xy8yEjRvD1Ix7l1IBlllIM5bKd3iCO86axdTsrPK08x22eHm9yX/dDIraJeGcnMECT2TeuG07yTN6zRFBUeBRb+VIsx62+QfGdwgkKwdwpYZ647UYCoopF4UGywU1JAqfz59l9UvOotnWzG9Ru6RtiN1Hbjn8la6f9nLDJAR/4Mf3LbnvRO/ac69RBFhZU8rNg58qt1GlvwKrMInd7X0l4PWH4Py6/58+lH0w1hXlWRtFU8mdLSUsPdRPRnzcfFUa0ougkPFA0Tt684SbECg5sYqzfFyWAMTAzEbxkEofV0exD2sPgYFwP79WrjtraYq+BAgegBSwkoxnr2Waku73cGXxFKppG2nn7HWEwQkiiwevzWDboMVbdcwheWTA+AYxZXiQFKnn/ntk0n9TwUsrr16Z1nyyqnJ+w4VPT5zqTKKhHyWvvT9EgV3gn1d9Dqh/iH/udmtT7GfNe1bEBqo5YbzL+889JWw29QzQ9IV/wfAIhKsfgQhxO1L3PPcwym6gaPeD7fJNWHjnPrC4tfnzc5i/kj13plBeZkN30IbhVz2xMnGi6ddV8B6zyDJ2MaXdUr604Om+9Cvft+z8xLqfoASC0mcLdeRh1/jhDGHU/tkN8OdSKDnBOSkP/Me86MNloticL+lKQfPNFDm/K91mbZoxuB5GDYKhYCQiBKb8Csmax0UTQwepH3NMQOKz+3jfD3//0R5rgiYQbV2Ykv08sH6w/BOBaL84woJkNMQla2aqwmE/ME+051WiMk7z1YKAUYQoYbcDODnFzZ5QW0SqPthQLqTLkIlX/63bW/s/TE3HMGIYYpPRyI7HMWRYogoQn1S1Q2JtZE9d0POdQ/+p9EyXN/s/gv8hvMaYpfiVEnSLseNlbiikhXf9WXU9zS8TZsKGP/P4lZqlbFN7ln2tn6uB06kb7JBJ7ZZ/DRYm2pO0oCOeNGy9rwUZtvG39GoKFSBmtzdXwdTW5zpigYgNAFgomY5pffhfwdXz578py3hY0Dyq2Y0frbt6yfsYTlkzApsccVKUfSnCh1gVE5apVzIak5qQFOQNxEAQgGyblxhJjrCfvYsFwLqXGVFhk5jAHerKU38NwUpPMENpj4GBEsRtrb2FEV6RWBMgm1eVZphEpDQgJOjN/Kl84yAIuofblXvyCEsi03n4rkIVRtMxWW66x/OCbcUpSsAnX6Vgv91a394ZHgK6JLcx1rgXf/CPEKS7moE4IzIqc7I3jYUyjD2ItJdf29WLlU0LTCmol4I0MM2fDGhvJEwZewOc+ejohjVBhcMEh/z7ll3l9W91HwA4nEHizaQEhNopzJgy1sUqu4hTr5TogoQcHvqkOxb6yNlLgejjQ9yf9WN/20Ri/ijlLWdpOS9rz+26WpNuUdlNFLBXlraA+wWdkUWAKdvZy+5lqh0I0nJx8MbfRnCnROblRGzKTOLcnpj5aRZVoslzxS2YZAHcc/PM1qxunQuZldevvxSnA9bb2MQj96JI0lKPlY5ceeNPpNJhhBA+FtVmaIC2rWK94ZyWrJgq52W5TckZzJJSm1vdwpvm2o+QvOysid+lgC/NcFlT66EHjjHwyK5q0u+2Vb8r2WkQ8GCgls8vPl/DWjdBmk3EmBvY927VxYmZ7mzf+E1Sl0cjkIMlFD5BpA072GWFWOAnwuLjJsBO9QgSauMqu2USHoR0AkG32LtRNabSLYEh3lxfS3uIQAAoulo96b4YH3ekVtkJFO1UfrK7xx4DlBSdEPCsZ97CC2WPJ7G7rcSIsoQVrVNULj9R3zDAE8aoe32kx3J1r//svi2W76jTSvoadHzl7eoEEFkTLGYs40VbUk4qlcXrFkwOvfO3+tKUYO5UdWJxybWkpM3zg+T6TrFI4+HPTjjh5HmwGYjTQNh5CerafZQmQbQzPkBXV5P50iSzNcN05sqRv/dME/IOJud4x4LZIgjkpu0ANSwsKdXbL58rjVoT+tuds+5iRHx+J4aGgGggivCk7/4aK3sWn4C9eWFtA/CVojQ46+CEoMki5ADM5GuS+clTQAOTa5YBIW5qI4iHQzC+G972bn9MfQkZScXL2ZszCxS/WP2sTWx1bmeYyU4taRdMNB1bn9RvsPelCuGV2YGd1M3ojHP+oZCIgekOdjvYWo8SHMhrlK523jtbVVKnS2omnKFta1cmn8fVxb4lqFuLorLbQgJVi1Ln7zv7du4LBQ8ErOi1AYIEfrnvPXaC4ye+IkK0HxxyCSQ+4glkhX9ICjpaT++2lMvp8kHbaXU8RJ5KZolz2s13ohF5G5C+9yRmrY2kliMirs6LiJM+pB+cDCpyaNKpoQaOCBWY0BlQDzrOrHLWkGgFjNYIxjk7coyg2//v8A+PmZGte4FkHIJzQmPgBog3ll9zljXhbLdUKzePCb0jwgZuC+vqTZbJVKVKc2JTmN9QI9s4ow5CEyXF5cK42Ozwp91zOVE/FcrYVMnpz2BgXS6CLNsZaUfzcp3B/GEm5T51k0++Icn04i5y/So0fHaYxkFqxqxHWzIh7Y7vs7ZY0jevFIdYaSSR6npUtIOkJ9eJLpSdLhxI8FjlA742ThRlvs04QGMQ4e1TIlMumaiiGE6WrDkRfZTvm1J1tXZmA6lVysddb70soEHW1+EL7UrzURr1nxagWMF2iiTbDKn1MC/hlqbWudd9UM9b+Mybq5c8Ww0sc7fGNy2TlZiV504kBBzSuKZhegqIoljfENihGYUREGfrUrUHlrVkF4UNXRwOwlGwOjINgZXb73jYIFl0NTH09XZBLr2jLJhNTFMvZLhmLWbpnzW+YFwgVQr2DY8yRd9pyechnZTcuB8ekbetV/Y4jEgRrWrBITvCt3GRYZSprP7d5CwDG7BIHc0Z/2a+7cPdxmfZyx3RKL+nGmK7GClG/DsBG/XmxHLQRhCTu2YKhwfKBLyACyPQZ3M0T1pgsng4LtoQWwyrugTn7aXkV2gs+9DTPpPSKauIaQa6Eq6JiNxn9fprfm4n5GD9K5qEp6s5JB1XBzC9EjZo4tWKf31GGNo+SX+JbKVWMW0m8F1+T1hpmWkLObmp1z1iP3kTl5xw2h92DQSdzsNd8nysOGfmQgkjLmP3K62zU7bq6SDGctdm1Z+UlyVTOKIMEahJg1EA/1Ki6jm3rRA8GtO67zmxLZ8nq+OXI1atMkX3sct5ct+18kqvTFBFWqBnqJLsza2jqnATyWSMz9cz85gp/YgUPmN2P7QiHMuJhtHNu0IVzReOeNR9jz0Yf7LV4ptrMadrGHwFA4ikGrl+/49wp4+xB8DGV4jxGxeOquZyqGY4zNErcNODNzbEFLXsHYM9gcTQmCEAilfEBjEB+FFovtwXhQa0BAYasjfNU03aXVd0h5+vE3hi4p3Sr8eCYj2PLBEdV2y5XVG85E5V5qO+rQtY2ZwTWlj7GBFcCHdxGexOIeRzbmeaCRVAprT/klvIyLmbEshAbyr0W/TsvCZookIEAN3TY3i8YncryTxEXHp8r2SSX9Tk6vh6F//iBBx99KxoBJgxpnNuwl3ZDb3xJhcjvgUUUmYWU4ymZ7Vcci4xxwxRyWB87blM4jXBYlCWyEzmeW6tofPHdI1wi0nt/7KhZUV7ILCn2FZAkyyYpu7LfcbCO4Er4in1nAolx+pl4Ilr6khGMsxcDx+8FWRDqd9GeV0x/4EZ0tZYxtDqw/LFcTfz/d/u8INvpCpjapDAYhCfL0pE0b+aid1HeWtsde/6o4Rpob52CMsaIEPOAv5uUm/9KMfpqAIgk0ZQDZEvS+m6/YAtn2KWA2zYiXqyLxei20OdpNCItetVdZbWq7VHvVNK9qkdh7gOvvuVLlj8VIWrEP1ckj3Lybm/v2ZoFpMX6T9RpuRNpwqcq2gAVPFj7zhNcf20Kq0stjcfVufevQXwZiqQkPVN4Punns7luWNT7aJyyzaGVScLRp2a4eOkUHCuxSPmg2CGioaxsf9CJoTbzwcfOpa32DqjjHSASQqUx84bTa3cypvBOjwzdjySPJJM5yxiX+IZlcX1mWzER4oYzxXuHARIqNTrU46D9ogbbxsr9E60gBY9+og5S14qeBQq5dzOFopVXH4qyuv6qJOvx2mrETWeV2rnLPndVdK6ICKcEofCGGuwLKKhXFPECiVG/daZCtAAbqipsYhanI5M8b7av1EIBdcZz59XSwkGRQba05DbMbML9/DeKaSAt2/mebYpC7AT1UqxPJE/MHz2wCB3PyGAkdBwADPY9wvEG0nNuyy1i8s+VBjpH54YWcurUDAuehfbQ+AElm039nvGYmUol+/UI5aU5MuVtLkvaJUi4eqllyZfAEP3DOtSDO8KN6zVUQXP4jLSoYyFlbItJMuW1O+T3FuO9Hhp/xlwDioDqfrNsgJ7RlnBl3rriSG0m0gQztRIiQQ30BGYMNMMIt345f42vnnfcut7saV9+v9sxNtuXKXhdPeT6v9uxydMcmQafAJWE66qzO2nR+lb9CYLCE0F/0tpkOvJ27c6e/Ku4JOUxPyWUPBPLNLB5/lVNXx0uwADGhZMe+vZYvDDbOODaEMf41OAnCCb23sguoTtIZDbFEXJ3H08IXCHptX6v95zc6NL+P8ZCqI9H5YmQwD33QmVlshB+gxrW3vL6lurZHQWPyI0HUIjo/6E+MMe9HuY6QbUMvs2RWWeTMrc56IzgghoOaHFHAKvmT/emS6uqTQR+N7SripztK/qysIwHSJ92AQNte7ZLfcw+5/aWy/IePY07GUB0pCKrm1SLIp9eXBZ4eYoNbaW/t0DdNNEd6eU7h9ohLnRZVBT34o/CaFBFHBa7MAU04t037/aRVvAkyChE+X00Q5Or/zWXMFIpi42zgSmB0s1UzredmJPfuPy/jatywmPD/EZvpDwWCzGpenttltL6hSg478EbhVJvQK2qyVBRyT64hv6bPB0a+zueJBbSFmqDEhHfxptCQJHzouoXuqLq7NpeSdtjwrhOhAtHcbKOrtvfadBx81dC9DGhJLniNxbTWT5Rsm0RbtbNDU/OanLsCXebL4yMBzSHl2FnXl+uSJv416l85PQYwQNBkLGz2vJaRCu+cZ0iyu1urFkuADR0mmZuo+A07loxU365J613Vh8KN8agWZOb/7Bh9NhAQVTF5ykIYiFQwWbnPQXwMuFGAt5C0VHuTFlPji0e1q7to+fMJMRYnPsjkkPOVTHtBE47lSNMmafjP6gsKALR2ra7pCRROYYHlVP9T0VTbno6Ip1XJELjmv2bSMk9jHUmU/SiqpE6tSq7TDaJZ4drKrIquYOJO2Z2nZnyUmW1tIQeOLXDOQRG9Q/9f2wV3AdGUpZ4AU565lfYrVfj52DNsm2XMJzWwMO0GLWITdOCSlQiXk6kG7DarDk1p3xAt19D17YcnAA4OrfPQLXE7GeO5g8239p+WKWrJrht4sO8Qod1eQqczW2oGaYCUHflX4YqxvLPKK5MXFwWeo/0OqiZ3KUEgeE0/KdCOT4AelZtiHvBWIt3b0fn9J4XLGeUyIB0t7YZmzFJSay0IGLD2uqLj/GEjhRNDhqerTiatYW4dMJsVBAYgHI2aODEqDbHldAcqHH4QJDy+rmo5pTf2EKCAhe1LOFnL/yZK24RT4oBjRFnoGieN0HAxaKYMz9Owe1R+L4bc6V8jLrn6Lv6icwJAr2WcODblqaiOguABbIFRk9PahkYU2QGBkbEelGapHR6BE0uu0bTSViKxy08NJZvDf5iDgDLTFcE9qU3GhiD8Ee5QVNMouvtrLsjez2Io42UB2uVT/cal2bUL/oXaw9I8wuuChu0CqFnCknJlpDnPsCkm1yr3BnXyUzZNVKGZa8zunrx+FvevM1Ri20Di33GzGMUSTUSVXEiEszrQQNhEs+WhkndlbE2vzR0dOqcvEtROI0IRj16nCvnItlatxfA5UbYvSJC89clxRDEBUdwwsc1yrhaKAkIXbp2oHAXY8gm1uTCxh6X452BdGS1D5VTYsm9raLkt9hHSimg+twUD1pGEHofc7kWswROEOrsPADmaz704BCerPMbKti7/YMWNedYAk6o3C3mT9PNTRSXKV5djCDuUj6NfOHdEal9VdLTH9NTR7Qan1MpYtJJDB4Uo3w5xw/q+lToB6yn/KufeduFD2zCpuzw44MXp+Dr/SEVehQ7hyCyZNfkH1PY4gMidum9Uqt43+hHWXch0oOTMJA4FaiNiE9Lv072azSZzIJN0+SyGso9ZR1OmudcI53S0MZ/YBWaWGt5p3qnLTi1XrYCvcyAyqp0aynXj5V7IFXyunkasDX23PzWSNT/ouMl+064On9HnKKzBPZsf2QSLUn1xC7iGBSkSgSVJT0ApO+1BflQ0yi6zCA3KY19P8OVgMeO3v0XkhYbcScEuFwoCWZFSiuQj3ispsBbQyJr3mEKsrsmdLzdTijzyEhE/gBCm1xjUgY1FMGXxC/1mGCj+7Ow0eOkDUgPfFECh2WRdFz82VjFr65nx4X/Yha0dywS4WF4k2QzfHplzX4acYn/HrS3m9XhvLUyljfx63DgI/JjkI72eCqcbMAhq7mPWrskZehpbMVw6cZ3kX5FhLjT5YVaHEpVC1kaYtv7TVNNiTGXllwqu1H3Dd//L8LCMcvDOdREQYsY1LXJk6qkrNRD9A1hR4HqeoTxjJBERWAJfsgZ6hFvrCW6FyDONDdSRPGfRjdifu2Yx1486pFH4UGjH7vI6RBQW8ui8aREzhDZTTUW85KatstdhFWOt2obI6uu72Ata30TSwKLx+9Fp9V34q2cL6vkAZ2Fo+6Hcr+x12HiafppmBFQNr9clAJ/KH94K3AWzxQ65EF3tNX8NumImk8sL8qq63FVSN5pMZ5H5d+G7pRohQVkC3kcxM6JLNoIbDa4J1sNpCR5EY9pJcsYmjxN9mDnoAMFj+MEo/p20Xo06/eEtvR6XBGVxEkRhtLQ4OS7iMc0QHkc93f+FC+4lfQMirGQT2ZdtTNcRD7MGi3/mYMPzFK8GsKsWHzkO1Foe3YQ6zPX8wtZSzGpdoa2WJijDr6qDM3yN14snVWReEjJvKj5c5opepW53ysMbRTDrSBF+4aBRwJ6RiZlMSG8VWs2C+/1zq8emaWtkrmPQl1erIusb09m/a5s2lNXYVMETgn/fksPdPrOSXzSG58LcJvelPasVA8JnswaWguuv/p8aua28lPPEY47CvdDuWOP12hiNdsnXO2C8qv0w/9WOJUuJPNGNoRzwdVYUEvFrdIH8/o1syqnYNnXL2qD7alx5Lrxj+qq3M5D8LnSr6tBJ73UtKtLbcCulqBCyImsZaq2z1wkwkq8XwW7hNSmR2POcrJXgc8V1kxof6eIPauFvgpvn+Y3O8F1YugWtCHozDTmlWMoCeyJVzg/682bJylKCJqAl5o8NRbjG41e3aiKxR3XJGfkffdY6zRZNfYOPpjPa5X+TDvPnvef6gRUKO/RO37JUWuy5rnuSJGNC4Hbj5d3NXI4s+jtQs0XWcAW3td9fl2JFTsP6o800uS2OD4zftSDVuIpVIkq9RbEvzSqnMF3rpqzZKvZoCSKS3pD0B7KQcgz3HCQ1HADEv/QS5ZBOUYX75/G5g2iiRVT1x/sP+qaiPvWWZnRRh03NR2rEms8xQ41/1bjZHyx/aRpGDkG32Pv5L2L6nuhiVfVp0LivWw8qPZPKo4snompJMI+XpTG4F1dTWVZQ7It4nRXykBYckHj7ZWkjBg0T3+aYavEYHBkhw8w1JGLEogP4UMAVbzASGEQrN/HHhNG3u9YvBV45D8BQkjKRKQ9vboPfdRzqVL3rhhSitF2slxPifoiBy5bFzv8b5lrCoPA20rYOuj7eDseg55HNn25jwoa30b3f7h3xJRX1Qz4Df2axL5kM/Qo6clYwdaVTqQFUnpqUq7Q2+RDvlV2FTnhfgEEzvV13LJnoFJ7pMDt6dNRkHE4dOGvAforgi3NOg9mCIKqCnks4Dc6VZDSIj2HRsEWBlEQgfXFQcM5374g56pU0DXG37+0IivXxIXIN13buClxjqHQ7yMGEQsQLArFdDEg3y2SNNQ29IEwLlQZmkVglwrhXZKtmGp09/Fg2+9TtTJiX8nVey76Zm4/qtxjziAVoIS5TOf49agOZAso+nYvgF0g/nUWOEw2PTschPrLWKepAU9AlemTQlBaIowY2A+sRE63smG6lynXZJyFmUTolhRL1/CC3r0ie4aXbjupZdKKYK28RmpusLNxgOrhIKstYDh/u5rsFFamNTJP093+1GZ6yyZshyNba1w3rkl6gJXAIiY3RaYhciFGPiXlHzl0rfqnKrVv8kLXZ2NO0k4tOlRq7nDl/offGSjf8QtANgLk6hwNXyIrgpeXshTzLSqkYlgYIictpZpF8gRkvBja6O0yNrF2JEmzg0E8IHgfMcgefsBhdFV5f/exUTRjlG6uuRe3FBxI8DjCitekFm25ftCFSQdVcrwblsehWA40dSGlK1yc/W6M8RK0ZDZMYJyjX/JYpEydspyyVUMI16O1S2mRtFnuD7mRrD1xqvmX8ESTwZYKlamzWB+ULUqTkxPI01TfjlVlE+36mU6+MSyfYQfy1CX1NPDIyuRVuovryjuaL4f0+v0xX0BM+7dPRhRDmEVizxEOKE2Mj+NxxZKzjwsQ/La1z5XmaOPzu4O5UhfgUHq7yLtkkzerpBOJNnfshiXgjbyhftGxyJys64oacAUryn9bh5YLnTrFoOGB5PRn92F4texAQ0x+95CaT5A8VB/woRX/aBN2DbwCqGGvRkWEiM0NsJsitpUnUnyafIRfeLJcQLB9PbYTdE6efIAAjgfyQfiKHJC2J2nx8NgRPMj1be9tVLEEdCqZG4XklX6hZrD30Yve26TSHAIqnKG08Df5AOgbtbDJp6WJCLqDt0LtKxLlfc9Kiv9PvQp/LwDwy6rOMk+XP2c01cwgD/j1wFu/M4TFJnu+oz1qtCboyuayVAhQ6Hn12FivRQ0Vjbao/J6HbXu5Ay7hwzhIomN4nXN4vUPsnSODO72AZcmfjDybIgWR2BsXp1F2WxrnN/evtDUPRT+RX/DEkGH/X8m8r5bUdKwzuhVeGod2RQ5rbXnYkuv2yU9auqjlWBuMerkYWp/ReHtKcmDsQ/99RHTtMUtPhepy2nxLB8diimIMMHzeGjyS5ReonI1OYvaR36o7EKDBPVCMxzxbQlQXuuONXgKpmgnfZJZJtw1XwkN+TuWzJWQ2efWt15dUcBaxwUrGgcvfF2uG+2h56uUz+T+IKEY0FMM9/JFb3fv+VOzsRZCoJNDbDKADF5LRo9os7KTLnlwov3Pzz1RA1/1LkUFl9xw20pcoeB1YEpiQOd2pyqnkHqW0npoiqf/D2CSij0dExdH294aUN31e/LsotIlQ4822S/pZcxUQOvcoCwnzynB11YQ5E7kJNOLOUEGcLtG5ol/e83B70w26JzxoqB4aKBHlJbgU3PMnBnEBIPC2CXpAf++sFjcjL2a/2hj3jT5KQX2NohNj+j6Petci8qXe6pMaoa+VuimUTWB7RNhT1KHwpjsNs3V28ZkEuZnhP+kTM130HgER1aUls6/2pKup2BfT9cFpznTEFWtDDKspFyb/lEVc11kFMaoifpf0ytlupvwxsmuZiHUiery8E9XRDMfeGkZy9Ygq9rmpVX9grPifXNTHklaRkGsl+nioaUgtFaqwPuKiVKORUEoz7uqIxHaZ7XzRidyXSYNQF4aMT0vQJiEuffZBRJfAVELCL9FPIz/yc099IBg6hH2XtKFV0JjfUWxKnWoaL5eeL0EjuLZv9WBiD+zIij3V4bRjDxh/WREOoW/0NC192zwTPZ7F2Is4UlYzsKc1C8cG1rPINQB6UXuH7ABHWotZRsa2gh7xKG8fueCfZVHYUeGQV54gTGwx4aCBgZsMv0UJi8tdjA//sXrCs2vJ/LQ6zOHKwQj2dxz+DuqJbWmjzQn4UmjS6mLdtNjnXVwkGb1qyMf3VqhomXu6em35P/qjOZ8LY4Qa3sI4IVwnrgfqabtSHv1ZryAzijPLfhwP5fAPCGBnJRDq3rKnu3ShQNcT4/2I/3wxp3ScgrSN4/OtlJ0q/g0ABkOJWMV/1gb8Wh7qtvOtIPQrkc4RSJdsS0TD+1VfcsAnMCNm2Fpb2zuULuzqyGNWuZmRwMyO5x+WpZR7osv5PyT0PF4lC3TtW8FJ6dsCZa+UAbP35qCIhBboXfhF560hfefycgAf0ajH1QvuWY7KahKjIsAs7a/ol47r8ST4oLlAzLHa/RT55yQqaOEwXsZocodZYmDkYK+FNBEZ9MNWajyTiQDp6IA4FZc26rADV8IrMppn4ZAbjpxacnHBDbHDh3cgqry5vTS+nOVlZyrSNUdQHSqGKIp0yy2k/o71WKqSC8ilobGgvKdTwitV/fsQwR6KUNoTSn6E1AHVjxycgBcnXxuXb4v0dh+CANUKZwmrASkbBOAZGEWWjL1yuqstpkLhuZHVOv5Uk6aG5ywZy1g00rYhOkLDfZpsxHZfIdMnGuEV1dHYjfZxgiw5UOxZSrC+3m2vXE3Od1jND2RIKtaloDjGFK39YbLpaTagO/wjrMbE3SsCTTUR7qQxcaItzOOOSqpdUhebcTO+rWiWKFYGPVvQ/6Ld++HRsQC21MZH8fIGpyrwCHZw61fm48svAwLUAAeTIuel5th1ZYPbsEHd9KKhsgJ66+uJW8G9kbjPbMh8BKC3hks8mSO3nS5I0zQbN9sTwH44dvPRpFIHCNiyKt5+ATh/Sr4D+Uds8p18krYZ0Jto/wDpJbj87ebuGvhM8Jb5B4RMFbNT5KtcnuajtQue9NCtJBegEDdPQJQBFppTGxChraCc62TFGHhimqVBsJALwHq1Z9MzmpBv/vOcQfLCKzD/AaWnXxt2XG+DDBrYrnaaQTj+DTYXCIYV4LqiiQNAJuXtP7Dwz+zlSHoUCGy0GVRYzbqgsAlHrnaroYxkexJPKXK/E6QaIP3tudkmVFlaM2CAz0eLipCqxKpewn0yJUkcdek5v08KbgtzY8q/ayguUOjZfTxQiCq5Tmye20nvvSc+D9t8jxWL4g3yle6hoQz4x4vqcK+3GL3rhI3wQ+qN98fFWV9uOXd70eqo005ojxkLEvjhwazOoxdIOQYiFk5DbGsETCM6IM4nyade1d9cVeVyJvD8hnvgJKKrSVJDbxUIjB1qelxWFGVwHkdyTEN8BDM5aHg7s4Y6gZ6HkMZDdepramr3CR5roHkVcXDanQeKzj/kO70baz2UBd4klPY2xrOOBCm3AtzSBs9glw0J3qK0q6lFxAU8nSf4pwX7ULZSIx+8pAJdqPR1UVxohJsLotMrwKWb//uE7wtGVKC1wZhbAvEuUj876kZ4Qa0UCTDrRqP4vSbmT7JcYXXO4zCUfsdfJpZ+8EteFV1AdcUdqsi5wl+vGoijMJRcFABgWa05XZaVZIjqtOx8lfeDMO3v6CyCzEZIWpSG6nIwXgi+K+5b87fqOj5QO6tNXnJnmIXeo11ziAHXhWZrIozpmT9NVF6FTCl8ARyoT3nSjbIW4Yw1m/mLQaJqPmAvQp9pUBCi4REHIQY4MdzYhZZMqTBQag0N83YlhLqW8Q7vieDB943ylsX/EVtiacRcxizIweXTECn+pvRRP5CCWff/aBwyFfByidwfBhHAl2RtGguC6uoJnMPG5LGEW4puhKY+nTZrEpMETaGw5BicFW19Mkm2JOVh7PB88zvEOcdNrc6scbq6hGtirRxRyOtP3t6Chzsu/swB6HBXGFa/8TpZgiXb1xL7IIH4p+lbub5BMX8IkRp/eAaJD1MFTO5YpmmkDcGzOjuotJQbTQKlQRc9CKGhcx9g1MS2S5o/VvqK2JghJkI9A7vl0m+tLTl0mP/RQfalGk01Db65w/p60NCL2SywYCQ8OU6WZh9OAr8nPgBf/52DFe1wqiWfOaJnfVowZYIbg9Dd+t8euK96zILWrK8yfqINeR9cT7miRnAaq/tc1/G9JWfEv96wO602tz8ZVjayQl8YUV9xdd7bfkJQCPpwMhYR6TnW2TySnhTH9lYUULU9hDrV3UXFCpSDN98Ty4yiJ1bobtpu1aLFjqR9NSPxMmWOyvxuHn57l7SHKEwEnY9sj0IC/O8IY3ywM677L6k9IJZ2DWXkq2XPkosqQ4sKAg9IduIe58LNN6kQCztn7jMnzxMEkfwggRuWOuoygzr0Zexu5LwD2I2OBY0g/kMWZvv9LAo9y5yfzgKybzfr5TttaTwqnFTzw+GoiWIv+GeZCzLcdbXe86NVtv5tbQrff5NGoNvJGoKCswC7F7YI73iZkZTW3kIt5I3CL+GTnFZK9+XxO/oqE9j8RcHDISNQXOug6vYkiWWsgvyzBrX890zgYL863xO3JDcq/oNe6mfL9ak3SjpRZWx9rH0lCo4JME8HL1fz7wj3nC8ddHugOv1Fcg2rNPlGpzbIae2ObsogxlULFW02J5bq/4PItIcG087/wD8b/qgCNM/2CO6aqolIBVqKn4VCk9SXebZ+2c/bNp2tC/6eWlLRCXTJ16FEdOa3kh1NBmGR5jm7aFA6Yo/Ch/Y9GXk12JWf3anbOpsjc+yUNMXfN1JzUiKtIIJfd3aJAyXWBjxkWVIywHkWsL5ot8NWc2DK+08qM6gRQ8hiCjuuEyOEbGDULloS6Fz6eJ4TqK3rPauBGdXug6c2W5siqaavSXPiqJRzwFWtGv5J4x/3uJ/mPL07MrK9SdiSjzduc1168jxcKZfWG+ky2UYlZ9pzUOAZLyCl1myYkR6UvD/uaGVl505EnVmjhePcKVsJEzEdJDCQiXb+A0vC3VUEW3zR0QFTRH+FF6G+ugXVMy3qNNME/MeyBNjoBN093/LzlUv2GGW5OHcautRwikclhfSxCMviIzPp/s7nK78/ayWIsMJRYhLW1G8MPd89RcUDA1MrC7AAAflWfXOq4xvX7FCmcZg0Ed0ZJOC4KOipgbA5qWqqeb53hgqDTHPMtNAavmL+L8osMZ1tG4mBAcH908fr6/7+zHNftwJ9fqDUwIKB45ynuEiYhEYQK2hHOoGpcRwaGoRSLpOYqbV5428dqjTxgTvik/gQfgIsVkc2+jHamshqG6Dvko05+zfmayVAWBt6Dqf+lmPMvAolV9DZmr7i0p91zF2qaTYArKc/2EK4ApFxNQ+Poi16zSmb9tISi1P/+tZl1GBIZgk4aR2cFNJB+E/Ktuig4JZLsTUsu882gW9QoBZooQBygLSSp6HaokliAK7GdIC0Eq5586GJAKJ+bpfSx/UeFaVtX/KxG/O/8e8LU+VAuLIYfgmCLDdVlCG+fqUtuJom4dnDZ6rp6SwhuECAjvh4JViHpAkftyShsDPVMI2gvt3NEA4Gmb7JFBqjplnCA46zVRxRh7oe+MnaSZD629bh/KbJOGwf363V8B8ZGgGJHdyU1U1t+ZhYQ4/S0Uctb5tmAJkZ/K4wmaUkMWjVsRQJMC58vRVdLTCC2NAusTEvqHSnJO0KczRBRyzSJJLSE6L4r039JM5F0rlV8IPLOGwNCgFsiY8St0xaHr4KU1lNmddB3ypDRed3N//fBYESRVD2SEaKDLeLC7xESG2Sj0niYnmpH9zA4q0pQs+ia248b2G1JHFtjjU8dm07J6gBm1p8Se/70mHTq6L+CKZiWX4DeB9R0LKxnYz0yBpp9hF/QlJQdRoriaR7K+7XEq5Is86QuiWax3zJypSROOin2pyf0phGL4IJho6gE4c99zAa6Np27hidaUlMHO5wp1KFajpmPgmnN+PcL7TMLOXM7oY3wTBADNy9v9Yh5oKW/BYUOkOgcOrEenPY4pPIoil5wylIMcfycQ5Pg8vKGw1UWa12zad8ED097a41hS4/HyUGTzVB7fbHK3olxDTs4M/Djeq4C7YlksFRAlJ6rDfekvvvkCh3F0FtZyjVopjo8/1NcS2+cuySOcl2dOh1v92w98RsWqTa7tlCHagv4EdbFcGGy9flNcBpm/38S0DoeqiGh/XBL3la4mHjpBSF/Lrp0Xy6LqTXtlGHWfAaINykU+g8hRAxHiRN4ZenCZBwLA6OKYUjUOyfH+suEn8WUZhbwyfF0faEgQN74CJMta4vgjIoYoZ3hHmBwANElA9R3axpj+ukBOP3J0pFglantLBUZ+PKsZtQ9t6G5w+jxZSekkWHW/MXMDKI42ULuAiU6QAmhpHrApkAQcaR4TGJBASP+mRmIQLHpdVi4eGvdQgilp2ukC5sKzgO9bzbLxhno5w7Hh8Nk601xleRr/ana5Vctu78zC6wR8KNgMOmekicELJpO5Rr5Ghf0j60NQ8V6fzVayDTgCnnuTLGZ9Umhm7cu396hocm+IiGh4TUv1gJwlWH/4asXGVI0TBDakXp1gO3tD3wQ9KnXuHsSammJRhuLzcFd3M0T5ofKta7xIBKIWCvRH1tZlPbN2Ik52n3eY/mryNMbZ8YHpQE6DS0GAiJBcyVJQEReGgltsnF+FuCmbrry/miz1sFRvbTUMfkREXSGzOMtfO/1Dm6Q29n1VzQNNLID5hxjLisXLWVzDkDe2DP9ZI+SycywldPSbZcXissi1QMsQGlA+Ysdioqb96AB4IkRvXiEWOz29Iz6wOesdfjW5KZYpkCtwztXHW3vRqJofoP9oO1xBEqi1wD5ALKfxHaus6N5GkMwFUoB7Dn5YVJjl4+bd6tgiDOpKmfbdk+dD9R6ir/5N4dsynTqorZ6am7DusekE4C7toSa4fA643XGzsk+7hx7Ru4+6ZY7urOP+I0n7P9YPkahpqfpFjvj3IcL1dPR0B+hXyTjOa9f/gIXjVh2rf4Py1GQCQZzCcBBhTOOfuy3uY5vcdFwy4RyK9kRMc/QD/8Vvxabh7I5aMTXqSSg86EMVdo0NvzA95uMUyD0Yg5oT3I0NDCGIvfQiwlSdfR9XiCIP6IiWtYihveJHW1pLhNgKB6nFZ4jG73kfBbwHRGxEZrcPYT+vtWPe1XT3YKBOIrcQhR3JzHLEpZKkE6nbsuqlX62rNeG0B7FLFJysiGI0RRIJYxqjiSC6NV6BivWiZUf1PTxHFe5QhAZ5u9tOpJZghtlnKESB3kRTgz9Bd0sruzLs1b2g5V+3GZENJQceGLt+5YSifzDcd4aOGpvAAD0FvganNZN4ivcx6jWl/23PyDn6J+/IhUsez/gUQeUWIi5tMyj/mqB2CrclPPEFIsMoYSKEzYQh7PxDto5PNTykJdgLP8i2kb4w1R85jvdwl+sOzzx7GL6FdIt8ZtFdRb60aIagx+qdSvbT+i3TS+L1TCFfIcfT6puKVHk2T2et9PfniGMQDpQkzute8wzHY0sjA5vcYMpQuG9wKcVSq1mE9s+sTO+xKGpAxChqGAHGMUFfR6jEA0lU3GkryVCm8HY2qA3Ts0aMFC04vhH6Gy/UDbhyuLeVrtu0Cd2gj9bpn2wM5/kCRVPvAuuemVprPOXqMRcO98rz58sG4ex1lYSiYjZ2ksmTm+4bAXylOUjr418M0y0uN/0Zp2zawmO6SHvaxwr9CIRSEzgz2VqT/ervNXzX/3nsG8B/R/kssj2WH5tV0CS8L3M2iqpyzCWT6KMzYIDvvYPCJYfXBG3+OOAuvNjCirQTefD2zaFhUXPopJjKm70o/CLG4aEjlsbjXdmBqkZ81Y5fUFh8v9tHIKYIthm6eb6qyKMfDBvYf/m0lNoLa9Lvx8G7ALaB15dmp6USMCGRgy8fThKUuiCcMOv7F9lMqIz/llZcDt3P0VEkD2bjL7Kwh+/rNKnb46umDFcRK781QunNaXm5/RQ/n0EZffUe8VLqcZkAOoSBBUuM/1its6sYWoB9inNRQYyV0Rz4vKTfrxzzbK/Td4tFzAcJEpvMb3fGl+WIxJU08tqMeSulCypeEiQaHAKVua/AA8h50P6uzajjlAo/JZcv1IOFOyaBu54dnxFBqGVr4XQoj1hr9C3X7No8cRb3oZIHuSBm5SqDEMuDHPQ7vMwcISM2Iml7aBer4HOMeeVu9US4OpR8qNkN9XSZgw4gg6UMbrIVfW0/Dsgqyvrw8k4eQMdwQiX9wK+O1oIoviDfuzsBMb7vp0WbiZtp9Yyj/4rRM0XCUtfP/E2JXrQXzzL1xOYJbdFDKp43VCJt+hvW1VBx/HzXoAmUuBvLFQ59CgBoL6iAEcoZeTx3E9vDaVI5rwcZdXJDxN5wAhe7KABrq4jr1wg9yKC1AelqxVlF7elxevPA3cbuQxKrNwYxHEUaS8ZBN6RCgPhRM4EGaFCxSqKV3LwvWywGqec96ZJ8MAVr166xLVsGyGMGaznQBHqZdglnCpcjulHajjrQ48mwjQVdvlR6xpwq67ptZhh+rpFBRI/d/3/gnOGY9rQ7CZ9ThDTQPvz+/9CNY3GdkxIMPM+NFdxNcFlHHh7cQn9U7lgbCRdTAkZc3MlX6tCThZxGw1/8q7pOM8denzQ9SixwrhCm4Tfo2QD5Ze/LS+esdxAd7XPCPz4Ewu6/t+s9ylhsPi3mXZWrhIdKN/JvNPLxPICRLEGq+6XjprOyXJlxZYMrcv+g4fkotMeHEwHoJnX3pJ2en1kQ7bBtaRPx7BDIBs+GQZTw5EoyEChNHI4kEdYRG0SBmbwbxjhNkbp6Nut0oig3sNbj2qTEkdP1Ua7cZ0VCsvL2DACbPfxzaKmaLQqt9HzdlJQIMqZTinZYJXyXU0Vg8cdnAlo7agmbJetXDGkPPOT+J6F2ob662UlX/qroj2lwppPiaPxtG/f3IyimU/4T+2WSXy2bpd7GfWqY7rICcHQQdXM0i7fMpeKgkcZHFmFXjkKkTtZcGZos74d2oipRRtarDbu0q7nn1EF8+GfbJv+Z4Il7htOAdnxqURP9MQVWZQGV/zQLFMXTJR9S5S6rL8YJx68ortPsKpKqxo2pKhkAMnNnYoUMBFSqZYhxWJ/KSjZD3u/XVHEErUjU2fGf298Sm4uY+GzTwODk6uEalyLKLb1FKxEmZ7+v2mW3HLfrLsW0Y69kDiwwJO+zywvcJyItnecRxTwdOkjFS0yF2W3iQkdVfRVL/zzd/fOeWQAn+J3fm+Ce1ik6RCNF0lgNPBYKDlHwtFBNCqb2aGzJ6qNZaHxa0hSW62Bc+8Jh4nbR/XjciZBC7IH0iPT8BT7kP2ue+Y5wZJKOMzbqLMfK2BzQo0p73P95N4dBjzvl/k86dh1JZXwzyspuh5IsTm+mqMb1XfWAID9sJl+am5i+1obUVaCs8PlhfuiYGRmxNHUYuqZbSguFr34W5yY92vYC0A/5me3eDyPPGaFitCngxcv6P4OumJhOXttuvDlAp5Vhyx+qOJFvJwu5xgbG+1kk9PvzpVqiXoWyCXmIWLBL1v6ADTjmcda659IQhdz+FKqOUjjg8wOozND77WyUuDyXSsjnw49UUmcSjMUcCSa91l/r92Gqj8pCexdl3k8vSt5lXzE+PzPwOLWfYcCtT+IGlqQGKvp5DMuJj9cwFWbbD2+QElm4XcdtS9NqoRCrQztrmGWIyhHJYc/godrr4490ttIlnsaDbjhPJZGqOmIJnw4hrkS3IAnvrQ+v0VyrfNzo+dQoaQW45NZkV2B9tENT4pLOStNRqcgJyTglIfRAgzXCNaYhw0VeMopeMXy87UYXGnaRdobP7LQvNi/1mESefRiFBRWP+wnsI0UGma+nmZRkexn384RFUC+I9A971bCOKdAGjNXZ1JI5kpa06IWepN/RfH3Cu81+8Hke0PN0YE0BFyhqNsN/mCzSDYQqUdYgc0is0+NSjhUzvBq1qKDmAhKGbQPnvUODn12MoMvcKktozHIhEMgekj3kX9ni79qyQKthuSvais2iIyPQ5Vbqh+x6usVvTCNNP3hPo9fumNi+t3wjH6Pl7BSqMRFZ5wDBQ+w7AQl9CeYS9j3Y269akN5kCY6a3KHsetFxfIXF8GIfe6xy/Im67KsSbx/M4dGwRAZLDvC+yaV9BzlaMD/Y44H1+dvf0o14hwDmzbN4gyqmPzwXGAxUVdjf4unM7876sh0Y/GhVOKLIMyJYWlHgk1BUUZo8/nVGKB7PkjKC/Pvn4ZCJmUBZqkeXy69Q4vkvFE6wsyZjcuObyuSinpOm3QYX6NNIgGFHPNBu3vsxuwnJKEJ46wDxAQNzp2YoDGMuPvaPo5pezQjoNtacHjT8/auUttsQ9lMfQTliecfohqAKvDwsyiFaBmbEJ8UA7vyUWnf7/itZjI/uQkfoMudjdYnR8ZP2W42QLiutsHSQAexam8JssaXVi9PkwJjYLCClXGHL/JsEceLF8ZVd520JG2IX7KXUfYkyKCLw/ml8DJ0WY4UzsIlRWi74BVRvx7ql5ixpNpowyjXcxmnvF98lVk3vbY5NUHsXc6kfHKnzEPtIXnBKIDeYRFmjiSuUdzan1oqJLoqqUhyb+tim1UsSTFj0TKoSHu8loPWOTvlElMm1u6KqOKWNJ0nnumToUlXLXZ5Hd4hqx4B28YwiQx9oHLM5x1kQj3HTuJYA9ojTFUHJ6qKKIeZKFOmFLvuAvpK/K+RmnQ7AVez0wghN5D6CZIg/JJdX4wXxr3Yc9CRD8zSeg8sdPY0Dkdp+6LUUeDLgS6vVrNC56iemu3nD1GHP4pf94YKyx+W0XG7FxbXQharoaPpdAccl/KAks7sD4EZplV4wia2vXXRFUzxG22Rpx4OLjdQNlRVD/bh35QNywRFi5qngpot5um4jVep/k1G8ZDUf9TlzdOMbRHTTEoMnmoHamGwXqKuuKZos3az2OuGlL+27W0rxFM3jNfe42vjl6CaB2I4+yAu2tDoFUK5FsZD0NWAk23emDuiU56YH6eBm7/0Z2JDU5mSBv5hQaxiqty+vDGg87hvGN5T0kQBtoFnNznaadw9u4UwsgdRg6AnPlR9Hw5KXwnJdvZPdZaJazW2YYZf5Z903HsNNcgYrzLynJpMe+ZUnGxtfCFtUCIjtWkTTUmOhjb81Y2kHGl0h1DbTCVVAHk2CTYikC8YezodXtD+VZlLusD24Yf6M2s+9Vuq1Hnl2Ge2lOE5xEOYdjUQbArTjerb6pm9UcPuHlL3Id2Urqy2ixSsXbFoJEHybLy2Rh+5BGn3UFxbEmal8GjJ08UOXL82VwsULEUsla6t+94u8HkeAVTPUOdFn/5SGlBoFar25P4x00x3+TL/Z/ybNw+5T6S7EJTB6B82TsTE1uOT8ydVwEV2ojIFlBjFAjaoclSt4dVIc/XDS+sLjzmMTOZZj16pm6lEDr0DkdusguZJhSwg2NhToN+J3tilpxx3iBFd0gHKoGKqXAEqHLyzV991UtP1HY0sq9VFkk6JPhy+xGdlWWDGPngFEpZPO4Xzy5ewSVnr3gPrqr1PifMoPtYqn/xtGF4tTkUaef5pM6rMZfUWixuXscBrTb1mrQAuptRPDJQI+OLQtNPkcGHBF79zQTo0BDQes6FBaIZykSIxaf9ANXbufvI1W6zPLHpvWpo2xP/EMnmvkDUElmAYyV4HAx79fNVE5ARXkCb4G1GjVd0PRgJDci3CjzMJDuAxdgB1mkdKFV1ZjBR/1s3QbNE4YOsRR4bUb9OTiVlhLP9YjqQKJM3kl1Lho/dRUOGYWwOpiIOFqFmlC3hmH+InFbojCU7qmq02XE0noSMkKauqjdRJmNJYuitfk0T+6dpNwvU4MUS8SPKjU2nID/jE/Fc4kMlW70vvJe++2cLiuDvGfKZE+DB9Xr3hntf5ONqIhPz6UzaWpmqcO5mnsjSt8Xdgi4AKxdRLmldwEPc/eaRsiA/3ML272GwPXhMIqvQ/lr3ZUe4gCFOruOsCTAn1PVL1TbarDpbK5bsmVmlX+jM4FhPN6kxBYxUbCR8i7i3KnsPtE7r6rrwe8H9m2ml/Vb8uDB1qsIVSrXf1rgchmKsxthXsEHPMm8+CHEIKMmbREUi1lI6v45G4717VBO/wM3ruC3ImOXRm4WnPa7tR1jAUYoCMF5vNXrhgi0WKqB8uVwXKHTkVjCk/C1OzHE+xFbz4MzlnI8fJIHpbB5QdWQ4Z0ZdQYNnR8YvmEvxmu8Q3klTNbYaj511DVu00EgNTODwLGqQi//Zb+/Z2xinogYwUql1P5ABK3WNgBHJ3F2OCZbAbp0QSO/BQjHUnm0puslEeIbsHo2LOkqE2fRvBlMlyNCOJwO1zXklEkxFRLi+ngLreI4goP8s/Xa+BD5QS9tJKPx5xoDmjVqZ5KeEOi5y+1AmPEDP44qIZrgWgiGa93hhgUmWY3W+D/53lO9Om+bIIK0ERMVyt+slt2PpuYmL0SXUyA0ovb+Vf0cCXtXYgSg0k7W9BmWn3mlmVMgSrys60xecX3SqXEOjykTpPF329cL/y6lI8PgtKBVAXidL7bCEFCB2rhqgA7fkDZt12jm8yAS1WoQ0KawfwXEQgyWDZETNth4svAZ9bV1TlSuJ80AsMo6NOc/WerwN0jZ1pXI0JYbzZopP5HpAxJMEN2qBFo4uxCJpfXtGUl/jVD7kxIaxBVyaMEuKMJfa9r2dYroLyHzhS6/sEYwUBcAVRY0nVg4XGwSTb09zKxO5fl7pK9d7eBXSeTZU9eNaUpN83YhCdwFqwpEBQgxBNDs4RAiniQzCJ+B5O8aGSZueb8bITiZVJGPbVvypKN8LvhOlfuP0m8YTm0I+xeH6xrfYGmiqrvzmZcOMCwV7oXpdE9pMnocdYMHaZGtz1Jr2wq2Nloro6VtwinzhzZ1yWwGku3FqBCF7MN4nKQoL8PFlDFAmdkWdXF2AnkJoqH87CopWbYyH1lhrH2nZsr4jzmTb5g/B+TlFy9QxFkzygTwRZlGgbCzz4QJK/xq9D9E81jf3sFw0SZGO9oStJy/lL2apTy/89iKY9fHJFayYpZLTTPhXKrlLu9wBPwNDDT7lf7Jt//kJIZKXDtAtjeInvV9h44DewTLlQP1sd3Yh/W+ZvwwfjyCG974/V0v0yCpSkF6ASuzS6FvD7Ec3I2U/PWIcbM25wOw8grDrhoS2pA8scu1OlYNLrK4i+q8vEqp2iINgz9Dt3KcXTPGbNtk3taI1Nvqa9lIv/i6EvB1GjR1KC39Ve2gdp8HVaShvaQXgLhM5rpXAoMk2BDOsSY/Nz9/xN95nu6M4GTlyA4/v0/tkaVdTRzQ21nlr1nA35dqPRQETO1JhRbXNV0+ouhRy8wn4NB7N7aMgEIpsSKiiVHQAt+u8xkXnIkvKd8lL6diamXeW0rIdyewl0jBgOtWCwwxNWeqbWnO84JuEEWyfB3nGV2XScl7LTKvXpc4zjBILCN4W9xv72X7WJRHap6Yy5BnTgd/xZxfn7UQ2m0EF2W8yAYTD3q4EKtnDTBbhmre3LCIsY37xpwJmTCM/fSF5meAuYhDUoGD6NYK5hPezk2VXLM4yLbC56Aicd0qVQCzetuf0HSPdzMd4/lF723LDP2D/OjWnhFizqla8AfWQqLlOLri1OZm9oqhSpK8gppPTlnvN4s2SR5JhLtU0Y4ExtIyKG2eNrrOctX4k/ATbs1uv0jQhPZmuKuSK4mNc4UUGGcAkwIB+juKOu7SbziZE1pZdEYjyhetqx+mp4npsbMWfsOYKuHjZoy1xwpLKJcLPWzq9oQJsyFc6xq6RMtm4HA5MXk8ya1qP5DLZ/ajIcPatA9cfndH96TRCP7kRC0wpxDiMzqZMHdsjC8FOztM42Drei0/vIr7d4VyG+4JqHpJKiq+bMQkzivmjJdO4U8f4r290KBMxnDoxF13R/l5iN7ynGnoz21pSbwZCiwgPbmhRHHixDDyv7+t5Jksl0sSPllkPleZ6r0weENMtCRFz1coXE1hP6GAuR5ltjmkgkQGlzu83DAIbXIytc9jhQxRmpF7dA7CUZtaxsHMKnVLAOxMxWWF3k9x58culVdaambiE2Atp4FqvYUWNsAxUUum6SYinbh/ePdVjOcquF91b9vTz+c0U7J9zGEl3jhthIcM1qE95EO2BmTm3iEo8X6HIVWSkmbpJm1J4LgP4JxyLhJFSO5XXXYi8CrS47nzGUwlyG+2tHEEOwfcqqvmnAyE9wosmXjbffpMVo2TPh0Pgq+nKxJLGBT4RBCQR9mnu+BYtUeYs4Q4vELPjdflvQBPwIvtb0TPh3b8YRBGdyHLiv+P5xfUgEShwHfuqjtceugAXKvYb8q33We+V05VD8KQJcbZGcN8cmSs24UA3elaBcDEnqN8z5EyQvf1OG5lQTAalEGGm4tmBiiT71ZzjVn66Dg9Q7ZUlPAcL4L2Ad1BWd1fHHxSyLQKtQLCuQwQKu54Ys9ooLse3OZYjYsobM+/3HEyWSKdj6D3eDClFjcyY8j7lrGu3Z02LAdhxCNkjV1KfphAXUfFou2flAE/qlJhYPCSfx8OPNi6uJbNs3kY+lpSL91k/nmcbxJOSm+e8d1ElF/+qvjT91ZcibK1gSWEnvMzImMpSxWBwDVwO4Hk5YENv6b8huQDIKDku+8IjFO0FsC8IRXOn2CYESwe4pCzcN+ifGVaIKZJyq6hismBN8KD5xb5NHmwKP0ILlSStaG4E3G3uYUnXRbP0gCoCR8NZtvi5+iYMyOBROwSiBDlof7jeTgar1Ma9mHA1G3ZAt6Jhh1gpoBaODUO9anbOtRqcFhPDdy1V0o6Hv4CAKyup4tEDMYa7NmASJHsaAHVjQL3a0m/5Vchui/7zy1qOGlf/d5Vh0RugGDln1lQc4O8iKK3ohz/IlnyRfDkGjSJ03BuCOb5o0S6Ee3WB4kvm+h/H06ICwPi2sVzP01fQ+fmxqNhcxWloyvHhq/Iuo0YpAsZGAqmDd+HELMSHrcnej39dgxfxbo44AYE02fKHwiIFFKC3ooUQBMvtWXFBXHS2HU+XzZJlSw5sKqnBHwCAIykYB7OXj3yVScoQYrEEGRoALF4X55o1Ej8gjyuYLiqY+NPbMu10/IduCpYFViGDmfl2bV264YEzadKmD4hemPW9f1U8+TuCp54sHI/mx1AtFmxVhRmJJO/jlXHg9DBuIjgLD6nu/JslWcthjewcJ//zyZnywsuyNmzBzCMAU69edNePC15gpCC8bPAGF9I8gKeJteTkoEYp6S4hgIeoi8C3j4b69loQ3vin+ijayhXS8e6p25JOqUDroP/9ssIpLJV0pWh5klIBPm2ncgOAHRzC0Uo/QDkyLEf7/zxl56WDiM+aCQPMRyXA7OmjXR031UJG8XoLmeN7MWdmqcb3tuOG/BgSnFRu8KXqohCp3klb57rmgaZxB8NwnLayqLJpSi36I9YES4YYEzN8yuxMOELgPStnfhbhN+zw4++OLmCj5ImmT2HNvEQ5HiqCdaB4kr/JdWcWxPG1dcCudFf4dwsSdurNSy9Tqu3GXrjxZiznMTMp/Dj8mPruCXVYZDK3mRJv6WxU5FSaj3T+eg63UiyKtjsinailAbpQBGaRO03+VXMSlSEqyTmRna4cU4iHj2k3fc6Vb+5xRQhz6IhbI6vtvY9eHv/wRv50gYCC+ewGTZwP8Z3LKlE6mYi4Yl+LZ+vKsk3eVL39zKXZz7X4a7UfGaIrUKor2DX6HjrHXXTW2SJQyhfXbIFkidYmykoeMSzy1sSz6W40/yrwGs0M94Ac+ICfxWMCfxD3r4ZWKbybb/82SAlZi+SFWpOXgpRLPjpQf3zRTKHVA14yPQsWuC2E1g8rIOabXrOD3QgLVEAumYnK/qNSPpm9GamnYN+WI7mOUPZBAv9lKwjy70JwHnwcQvx40orIy/6ZepatXd9m1tNBBvnp6RzpZ5IrDUjTIY00sldWfI8A62hB99TFWeb1lmHhzU+gWSWbQW445g0fgiykU8u0c6w3cvQRfED/1OnfEVpcwNmYmRBBu3qyh5h5rqi90G8QPGQHxWfaoSU4rMR+jmtP1Sa+x8SXNXWPxXBfHLTWkzuRwfRmfmkRulCRjQJYrg1yZqs1q80YsHuOGdixOp0B9vfdd9HXJsMJXD7qGCH34chfF/yjR/TLaL4DcXZlcBQ4GP2sTplWKqipq1a5H+G8BXLgx6+swfonoo8D/MLfnC0XoLi9uZDehJRiu2gyF041QqdQARHUFe6RtYeYVnO1MEEp6zyMo9Aa/5uO+s9ho2NE0lBxAbDuw3Lxejv2mlkLfRi3qsL+xWc5GzFsZgAA/xWAp2QX6+71sNvXHwJCrr+8WfO3J7G74T3b3KqACTDrCe0xzXvC3yEtuh0O2Ye1mPXT0vhOay+cE8X8LrHygqkqshWYlzeZMYvWPtVfWMzLQDvGi9wJH9dQR7c9AOWT+cHAICxBJbSTAmgvnkLPP6re1C/FAfif+SD9phqNrr2eCD+mqvBcUvM8swMSIogpJK6or7gzR1DZy2OTziVQL0/vvle8Yvm4ntkbqE2q30U52VIf02D+Lmd+sb5OC0DPCDD+qaks7WWWUcgG2QsInICcfi2EL4woebdDwVeHPtMQemrqAsEPzK+lG6n2Lz0oy/vAzWr5zOQ6Ui4LoJ09JfL1FSSWC/RFJEj5umW/e9w7QR1WsqQVb4vXyMhCshvgBEn7iY3zeFIRFyMc6JSD0gEYEfFV0oKSDVoX8AmGXpKokouFjzAwcl2k9UqgxvIaQeh9ucPK8YGVV+K6Q8P9/5dJWZ8eDAGlgVHjMQA0abD94E+bXTyppFB+p8QoL5FUXWpDu+l0b9ZOfwlSJGKkQVbbvDg4Z4GIkzS75qjMyZLIY4Zd2DwgwrHSXy1nk+RxBjAfoQ0uLciKMk78nSoFsZxQHIIb4/cWTtn6dz0QP/GLqAHknl1MG0VhQcfX1RkNH5CEbzT4kkBy3IYQRyIWg7DgdiypoWI1w+pm6cVb7CyyweoRxbNTvdpaY8lfrdzzM33wzWmPnXkMFD2jPKTG0FcaMjmHhTrNy7R+7FAYJZWrXWrdQ2pcVfPWf+hZ2rw0hLUhez5d154VFp0PwtOwhgGeExhCMK/rW2DJlun5wmgzAhZkfaaIXnMH0xXZ7W3BuRo3ySREcS9dRynC2ollIZzBXHYEXjY0oRUBVghyKMUU3Th1Du2dllBl0Jr+q9hBrtmsburevWw1gynjmGPotSdQ4SO1LdY5lnlbEJgf7m9obPcQeRrrElX5pUohW0CVaHx1mzdHUv4Ezrql2yXsp+ypb7fInMwt2uR3jRF3LIwAMWCxTJd9HbUhxmfgxHrCTY+YafRexcxe6IyiJgepBttoZFJnVxUdLXg4BmJfDhEcQh1P4T/HMst+hHhjmrUvlvB89IxJIx2fgPIcuwANa1fE+l+DuG3D8+pBRLJn4f4bhyr01RMvVq7EMTKBHxtLsIaoe+ELdAer6CrJd7RwNZbzdBHT/HLn0LGkCpOqdQpy9trqVPrqFM+KLVNc643j6V0zN4c5f31P07L8sM3zlBEAkhivhKv8Xfand/N3KahGIq0SGJJefVGeTDuzx3Ozs7N5q1cKUhIBcPB0B6mFtasLkAj1J5NxfIxrcpF8SwzZrU4lfFwyWhY/KdLYh99GlLfRDW9TZxzK3henMC+boiPxvn9ovsBKwDyNDoDk3N2pCTBSurzxltzc4j/OryEXlO0erjwaPVAFpWl/H9qhw2kg50AD/HUAjauRddfw7a3T/kpXn/QzVvRHY98shq0gBzBrrovhGHk/z5kQsCQViVYNAwKv5nElS5dPV2nM7UL+U3P1KeSaV9XjcQ5n+iqi0MRGOeFk7inoMM3Spl/ZCeLYUu9OYn1Ur/h10hMBrvI8a05N1gbuYi5VSxVvyEXx5qrVAVn/6XDk+oR1GJEc+8kFLNvs1CPEAQRtzSjncON5eU+iG5FQEXAC0KDCDf8cOIzyngbZOCpgD66UiruEIFlq15m4F/kkFaIke/1/EblyOYYaN6k1YXVehWQZoU9N2NGnYpxS92vP3K3oJeaBwEZ7gi0zsEPRNMOT94jmAk9oZGK5dfRKlGwuiC8PIMd1LKw0/KGosF3h3cr6cjJyy3sUjOczlW3j3EILsKL5EwWSUA+JMqYzBcOJ3mtlIVhYRqxNGYfRLPVk5g0gS77S9SMj8Tl+Ct52k1dh9XNpgzpzN7sEkd90YCW7HRYoMGg4RAlLlaHWXWAK4Wk0Asv5qeWUcIMwh+w61qOEXquF05ESBEibU1AyLJ6BBY8naW/Y5lEgb9L9LKGWLDkmGTlo2CH0nDtygbQDS/DkLOSW1l/UmxJKY3POTGTcHd3hrhhk2YW5O88KISeFVA3moHtYuTeRk/YHtx3CZSxUuB7hVsd3hwCFBZ1PaNSNyrhvFehWqZLV+B2SzYyg/aExymCa1C7GVlRqzApuOMdMBKgJKwT6osXCE5Yq3vAM1TJBipkhvD0H8bmxQQOFmRmc9zgkhJGrSnpqjpHuf5kcdg26c3Y3JXkFidB8dcHH0XRgWbuNgbletQEFSFA+byqIn6MmfN7gfSB7H5D79SNt2pZtm/IlRnokluoN9oLVoBfNpVKCs4wa7UjjxuuN+5pR7GunL0SMM1ABn3LGBAnlAURb46lJatkuWf7OpKdAMwf3gxEt+dJDTG1/Bf9S0s773mfDcexrq/Zm0+MhKIGg591HAN+L+47mLgQaooVkr8nOGY3SVdaOd+xrtfXFXwhhNom+vY55QCNZKN+WRsKd64k4ohMrACM2N960ZaBEjFpG5La50o5YvWmhpvevMXIXvRf1THC21dlqSKDW+du8YSuyNptGQmaWAsc41IL+JRGOlFjzVL3MgyvEb3vTMl1mO9iugw9evALOC4X7z+6Cv2UvDgMYtDt7szsuaSUThQrEv3B8+jA4XzKjRktHSh3FqqAO/u0nTwSWeJ6BGN38OLzdRwflmtisYGZ1u7SXc8NjXhzGAk34wiuEGpuZeEaXfiYcBfTL5TrJf2DYdQnNXbWrE8ixX/rv5pWJo1g/d4bp/4SCGakoz/qdGrHmlzsWIPV4hiFIYRARSi03sjyUX01+CHQSOy2r20UrbEqVFbX+PEMwCd8hGxh0Bs9VoahV4I5RcU9dPU8zplqJa/BHK23qCDYp1lFVC5UIanzuBNIp7S0NulmZReHvl9R27Ek/kF9fQ164NPW1uQkHi5qkMS13nQF880VyxsZ5nyYrLKhPzUVxVgY1P+cQbHhaAWDXzo5BZa2VOJW1b7rSvvdIp7beTG2/3niEmsL/SbmXxdpSNjub844T878Pm05wjvWECr9HKAev7r73v7+yehH7uqrqKkh33EwEf5k/0gJ5aUhHDiFQA3NGAif89jsmp2fu1PxxnByvhGf2UL1Cpl32SMZry2AJWhu9SIuM6g0LYsmjwA45EijW3QKQ7MyqvJjjJUuBwQEEOx5trHnGRglkRcBnSudlKzj/dnaV3JDUhL6pau26/FA/e4ucp8xZNt4CVNGQLlI6SSaM/2GFogOXBK3ZYLl16mnyuGp3grMQUydGmYFece2+8IF8DrlHROqK23NcoYt2TBoC0uGehFzNBFDe9UDdBSFhpaAPzn8tT4K1e9R71wrfJgnDY6Tcr6xUmtJYSGbBMH4ACB1hhkeR6azgTnaqog9PA+uO4kjDaK5inNBcUNtoBJQ/X7Kl3CpfoVEMDw/PgaYX0PD3K3jGKKjH1bCwsR/6xkozI2BiO1FUFzFCxgOyitzhoe8WFnkz9n+Ogo20Zi2UXa2vDIZZibosbxUeOkuwvUDUjeza3xLBeqTW696gExKKY+ODrbh7+JgrwJWj7/A3x5xq7hLTY7+XpleNGRWIqFwkv2d5M+cogevrRcqpHjTK7sJjAevMjYHhr5Xm/g6a3FS6s/ZvsbUq2aty6PqovCxHG0cd0lGRc4TuWboYP5oEII2bqYyBy8t1qlRwgoouVVt1ZRVrE71GJ4+NXrOor45irUY2t9wy/yhLv2JPmkEDVK+nPuUmptAwinF5hOu1yKepJyOkP248N6LVkAS31bzoA951MWcq70uP5bDa7Q8qBnT3i8D+GXKNulsELrXeLBD4/oei6mEq7cghhXmZlPD1D7JXe/xxpMDm0JFyUVT/W//X+tfVjoPTwKRAnX9PQImlwqREMvaa5wpqkLfSoZslses147HXwdd0rA8KlV/ImT1REJQy6I+k5cGMzL1E9d7KzTwIyoIKAI0QGGAMUj4f2rIH6or5bfRRVszrnio+kJK6E1L11+ciu4fbtrPbaO5wJ7t4za32dIIkImulivr6LDgx0Y5qlc6CaVrpGnGURM4FTgfyPsiT/zVCMvrW2Wo9ode6gdl5HJhYrOKy+llHRXuQzXVFwvnrOZb9qp6U2vyEszkg/3xdWLHPsfqGIJxVnTYEZXdhDYIaX2+vBhoS+tE5qWNxxGmDZ0rJfb1iFzUPVt8xzaMwdqJ6ERgPqgxI4A9qVk/gAXxefBzLLyo4Ysn7Qz+nkgifPSor59poQTGOgncbbR3v9Xd1PX59cZRwDHr/j2HPNIRsbEfrtxnutssVdsW+Popfm5nxkX4IIlCP6I9hi8qbeQIB5WlohwG5cbXagZtQIvLaTxE9xvutR/0yvSfGeYxjvx/PUQEoTucbtCcpB7ctnyuzwMmAyEQTIVJpJr4o5rvo0QakyG6niCbnRhPe88dHBkt6qspkDMudvmRPACcXr8CDkDf+kZ3orW7mouSC3S5FzcMZcfcU8FQ9t56vTaXpzpipppw4lVzB/1ozUJsuteEyzDEq+46f+PFvxfhaEZvJXwtiNMHzq5lr2GWqHgwIUS9asRNAcZSad8LFtJ24VEbkFZsSFrnXPHMWzJjDs1vL7SRZDhqZ0HNKCWECqcECjxGtvOG8ndiMyAx5wcyqCc/dhikq7TZuVux9TKnQZkNRwa8UKEBYV7NQqt6xuCSalPSUr6rZbGjE9KUO2JSoYahXekYLb+L4dWKknQ+NXjtHVtQO39X1LgRIV9PlnQhovf1uRSUpUmBToo0sgu8dFPpQwjtEvgJFwwqfGhTnmHLVn03H/WWzcwX1OZOKtMJfMl1pixZyikrehGAr/FBByO5gepIEjNSbPZTndO+q//jYgppZ7kMF8b3gHvIXH7b0iPDKWzJAv+Ny+gpkl/6Rcs2a65G7NZK/vsVZU9ycI3HiXV4XsJGdi78/FNkxfiwOSFyzcE9giXQnn148RWyJzGNZZ0a9yhfH6hW1xPsP/MRNNfZZW3bfzf2IF5kc0O27akkV8/aG1A0GIyv4URqYDEG3w+jMKDFUvffaff7sG2bbXh/qivjOOgCSp8DiY2WJ8pLf15FPY7acrO9MrRIhkGHs9fB3dCvtDmaJcDKMeQXoI5nJmJHEU2NYek32QKwUMzdDy60pbiHGm155Qc5Eq+ydGZop460Nc9aqB1/Ox48DFRdssUD0kGh/ByjqYnckUGcnXgGVmYH+OfSBaqN0oSQrQDPS2RjvW11dPEoTU0IqmAXejJ7zQ+nVA1H7HfAvDhZPVzZ+0tDW4fbtQ2zpeD95e8kSUs3RFdZeaSLrUs7b7osWVZS2zft2EaM/VwmZVPSLfHLagZ+fY7JuBIQ5fIW27AYt2AdDx3zWEgTkFkJ12IPboMsGA1Xx/bslQaxcC3Qm8S1unNThznGTgxIdcj7OsLrArlewpAz9QIq9tNuSYcM6AfisSH2Pcw0idXhG2CtVkpQbbsSap5xV4f7XcGi5g19rP6JTOSXrLWr1s5lrh53HGiMoUywNZD2g7NhDCvxL3lO/K8alY/eYmnf8WmKnzFU53Z8qwYs9ljyO3rFrGWbEmU4eXxXCkE4s7CGQf7ReOfoWHvZC4QHgWoBvIsPWuEguWSDZML2i9uCilqbvj1FgKydbgGhCithCmfLt1AeSqBziLxt3IVadvGeq3TQf4KobnoVeeycHqYVRovQhshglEk6JfOqtdKEh41oxzd3/NXl9X3UjEGtvDgD28KEqz2U/Zwz2OkxFANVqYPjRG4hFX9q7CY7586PYIxtA1UPu7G/05boAPTjk3fmZfQi/bslFVfCVGlEScQbPZN8drHvx6Kks31pMU30D9XShcKxpnCH/nHlSVjxKKYfxUkynFPhlYZCk+mNX8bC7q5wcumgEvXe6N4+nTnv9IJRjwva1+CWhlyE9r3/h0K90Vp8NjY828OzR9P+KRw7GKIqmMgHBPvku0jDsXt0u4caEKZG7G8nuA5ZT212OG0VLZfceMf5khzwiOqouObJwK51cLpm7xSghk/ZuV3LmM3J+Hsajija78yGSEtrZHe3ahLxqmuJaO3GOv36q6QlSZWfuBf5q+QCbeSLrZ+QEjovXCErZ8YST3t5AkHlecBBSAfhXNCXydjqPZnnfAsOR8g0n809eUnHa8kkji8MG1esXa+NTYP2M2VGzdQ5VMcLIe+FN39HoreXD0o+HTMfX3BOGn/vcFbVTAU7rG2tS2vDK0FG457u8eLuGY4I5dfV+e+ycdPlYWLjI3A0lVXbdxXheuTdxgs9ICcPPfUZrs+PYAB26WM0eh8ghos95wuMNXStnbSh8D1LUv5VM/NMPD5JX7m3wA/cpAL40NeQgdpkhrSkUqEHDUAE0y5Vg56M9AgoTO4jVCzFn6JGsN44vlSYn1EfEevqELZsAzH3OIKVk9bayR9P/FeH4oTLgP/thREQ5x2l/qYYA+O92FTznIAn2bKSkmDTDRhkvJFCj99ycQdWpB4y0BRuXTekeY0YdRR7XRDx8c/TL9ASu+Zk/sQfr/BqyhImShnGNeXav2Pu4IE0IG/Bf4WU2gzKfNCbGhcEcHl1hKmhBRGEWLwgUEzQw7IWFSvwLYFuLzAYB9lSmydQO0bzwbCVo2fBoqf2YzQr37DPcluOCu4GM1K0B3WRcByR2Hq3Rx/KMRca8j20qXerMgnTyINork8/y6SEM3ijyPhukKatcMBeaAmOtkixAEEd92PMELdiR4dn8OkgP4JliTP+CthS7sUDch8qfQo7PXEAz85hCqdllO1I/Ao/+824U2kAhrQK6sxRbkonArnMAau4sLEiKKdUijQ5SWKxWJwKe8ZCJEBscqXl6555A4Jq517DXc2hyXrGadettwEywq6Ggu3paK3gLFnQVdy4l9nj4skpNkkyktWIsjE2BoUPpp7CmefX9Q/WElgGdiWYHn0/GH5g/HHucBOO6/DozWwCfwCwR78VEbOyOQvW4zmHTc9Y8AzSOUUughlu5o/2CtVOZ5J7WJW6EWh2CsyJhcJIVnXNB4pNxe+Axm57UNPUZKsXJuK5NbAz5x3x6PwhkXXQgmiIniA7vqdipV0EPDPTpHOfgENzFloloFOOk4nmJV88Jof0OagryvXs2gZiB7/86wdTfrpBvvHF+fsNfYzj3rH5eiHj+fVoe+KY/gWp813NSEJJqaGn/5GjceOWyre95r2dU5U9OfZyZZDv+oOFM46wdg53rX4juDwcUYA7rcYz01d7VA3gwjIipoNsmU5It7W6bYKhDMfE2bSalIhxFAgcby9xuC2HXjmOfP7/KEj6WZXyRX5Xb0XfmrQ1JPeG7UXOMlsPM1ZxZw7rNQ+9/e4CSLkhuzIGbOS/h0vAAB22aVKGtX6BHLKdbSQqpot90gVM1ddD+dpX96zxUQ5ce6YaQZaOqsaZlPlcQgvqvCKpYZgrYKP6lcc4RnCkniqvoC3xjQKdrp606r8815JK/3ivIZ0zzgXAUAZ/wcIc0hRiykeXpGO3FYXkf57G91SwasiGAxzyNUyCjzzPUcHDjInOxHoBcu3Kst6IzBv4ROq6TEt5eQY+dEbaZ1altnQC+JhIO9wPDGSItZ59YYFXjf0arDOocKiQKq6LECMFfST2xCNLfXhcg3V6L5RxVnDNlEspkCfeJw11shKZyUpXMXLSEvGol2Y+R+DCdHaHbTNHvRBiKHpqDrmgT2radYXY6FsrC8s9nGqi2lyTTPzkTnduqt8VEDXHVbn7kMekRScknMz2FTXOR+SxcHxQSZaTCeveciSke23PY8osQktU98YQnQmDkF8DaBXeIdxHO3idNRif/BTN+5f6YtBHpe0wOexmeWqx4RBv1w/dr1ajGU2v0F02CSmzmLU+u4+EsmGXJRtmv9sJaYM9iDBJhUwTR0xDPpANXc7QlFukVudKTIs8a/7bmupZLbpfeWH2Oa3liXbkxNNWLidg2qLkIZRDx/XhijX+7Y4ByPlHWpywzg2B4gvRHQ9A4YlO8un/QbhGw8f/ZD/vGBQtf6Xqd5SOuKnNkyl8UqBgCpQ1XHYCea46oDO1ypZ/0ejuqVbuFr5Nub2k149PbAS47a7BSdE1sq7npQFLBlCXg3HeM9ZrxdDgtGcTAyKmomL9v/AiKofHH5h2fYes1PHZsk6te/HQHthGgPLUwiU94BOZ381lielfZDJvwKcUTMHycPZuF56aTn92gYnBIC7w9pBXE5++hN4h2gTSBc9mPAWV5jx4sOCCqqApG8rAk2fOILTkKWBzW9YN2631XHvyCN9GDJS2LwktBc+zgYdBJaZfMaVaAAV1WIbAgTIkM0o/NexoOef6Q1WxbwbBwl2TuoSar141dqR2ve4+Ck28bzyygqPGiQOX5BcXys3ebwpsnigoS6MrasT52xRhqYCmQDFiw974z6GgCTeMrrA7QEEYzDrdi4L/Oasj3QXzpcne/ruL/rf3rQRp+R+JpaYDFHrLkypV+QOic8zPvUpQ5djsPfuAdy77jEvhp/hBYEWA39iCjtg8Mr4u7Fs6IHdELoI8IIzXENZNXiNmfyH9V1andaO30hYQx/8PqNyGWLwvydqPcUbKKxPiCUWf8EqhiughDCVj0xazM6E5PtKSTpbT/oJAbGLfMPlzoh6DUNNZNP69ImSWQstLjC6+sJmj56GhE1soz0ZAUF24RN/GGaWPenzV+NxZ0GfRYWRycbQCySyCtxnPeZrlDdilEO9USPcE/mXug02CaRAYGmp/8OkoTc/4n+HCJbeblyuPdr3QOEktLD2+0uYA3y85pdaYkd6tLmy608m5a1GtJUha2KDiFm4I1Lwycd0XUGQtAbchH/JloCAMcR7OrFqy1OHpYObq5+RaeO1zk/3rVHh0jCqLT/PMPbrrEzmx9uliL1gIN8oHcceP7aK/QfEPRPCOcS7bGTV95ltBwClbGXbGYriKYY2zXsEeJ2DC21gTUpEhhoa1zIQ+V8Y1ZLZ5bz3VUWngBmpubNBgwKvd1SuTYiepIHqVYFOrCrg9FjDaOwMujYfvnpFJcyTgmd3ag5Jb3pf2yKwxmnBLtf4ZwTjcpTrZifljubTNujqGrM/8byQeB/VaOZ5vIfu20tT58wme0ghfnQ5luwqQ6IwSu2dLa2jISG12azwcvdlRHY5x4yOXytd6LoLGJ6ES8Ih6k4i7Pi7u5azN1knBQWxr/i2LeORtpyVo6cf8VDAUvMVX4fNmO90T9aeZawG+tEwQRB7E/wxYlFgTnO9nL474thPVvx8AFMqXaq5sr9lCYPCL54qwQyQvBWLHn21wNGwfNjzAh/tZgoS9h8sliPg8MTBtjMAqr+7Lbo27mGaLaMyHi+Z4q01iQZtlxcz0PNzK1blx8EB02JqZnRZgrs2k6MPWWuikaIC5ynKps9mZkQ3NtMZJgYqpZuhUkTj6lC6+IaT4YREGUEbj+NAYuxfkpNstzjtQVcz5EPmER4xT6LIN0REtvbDPlsfYNcJ50OdPlW5a5z1n+hlw/RpZ7sp5lYhK0y7dtbBnAjra+p5JllJZJahMesklyOGmB+BlLnOIRNTAWA1R9hmDPMdNEQHlEnkPGU7OdmgfXhb0JAQsKQz6twxIlAMQPMdDTiVIHPX93PHt9V4DozHyeDKEGuNu3oA5+8RVi1UkZ2WX3ZEgn7BuvDKk9wjrIJmxYdewO2GiPbMCx2qGt205ExdrLRftCHSPKlupzwRTACDwbz6gaLgJv7Y1j2spd6RH5vb8X7zDEnXpOg+mPFzFS5zrJls3VYEfvFhUgUo7J00CezVngh/XtCFqRMvyXSDSKie85L4CxcTD3vozVJZx7K5DjoOBH/uLL3g44yM6TcVVEjbR+oDdzwY9hJ9rA3tS7Y/PR9tGlCVuEg0DnCNOlfwZgox/jamWK0y/fhsRQhusiSCuu/CeKyTqsdsnScCQElzMG2/1ThWLMtDgg728VX/X9CGMqN4IHbkshchwNoNaw7E9ROFwDtU1jYXeyzYbxi6CC5uO1QIMJe3ELRTvkulU3TdyO89VXVPOptsBg/9cXzUm3YZ9LtNnXc83Ec8VDI+iqtwpCdB0NnXQQM/uNIPmTKY1N45L6OrQk5WalUTWwvvvn3nGyCjR/FZKHDlTWFPNnp2mMPqABO73af5x/9+mp8Q7H/hHCBpiyAJoITYPL4lM2LQ20WpFgb2btuDRE37FT7AJu/6DvmtndTB9iT6CnsYU6qQe+NykNqWwMzk69+yVMuJGK3rZqXwoxBpT6rcEYEeCH1t+tyE7+tq1T7XKFdoM91ItbdHnjyGhajC9Q5RIgJ/7/mq5z1m+VuGh1nI82WPO0CXFyPP42KZfhjK5JhvhU4Gv6O7xunKdyoeEmCSOvOTf/PI0cdhUHDbNHGowc1/iyTeQ5lp42uTckyzie/vTHczI4sUiCi1Q8wzOEEbabHkjksCvb5QNaFL2b1W4lcHUykdINuHT5XEZluxJIpbdhpRH6vB5QvL2CVZw7wqb5tkO4YGELFQvuF55ccGBQ5glgWeutYweqimNnHxoeAkfWaZQIEHFmFWjUxcGbk6RISyWYHaDTtfK3PWbJqqi0E9rFmBuIJC452TUbJaiZuzxfX/e9US2JfUmZ6jh22BcD/Xse62L9rOodKa+b/K2oCBkpTsbR5cEF6S+CPCMwRmxgXRdhbOf833Ti1NnTCXXnTaYddN0hFOdjaYodqcDbu12HwCz3U8IzVqCVuYr4Hi15THJ5QBIQB9OXgX/jWZBTN/kYFIQT1nXKa/UPeQdMQT5Rfv8awdKKV3cTM9+T2ItZ/oTlleM6lVh2VPDpwQBfniR1tHTQlQK2ewf1ZCTq5qD1zSz1ya+Q7OieZmcsrkoTOLeFdBclJ/1ofj0XBWzmH1Ac7YFFUs04kVoAC/TPT8YjOarNYvZuQweQdpMV0EVKcbtVvadAe+4YVXmOQ2dRSFiV+8tQO15e+IeR1zRM0h+Pnrb+LQ65WfQ3zj3f9JLVC+kmJV8yVXzRDc/E6x6Fe/XbOR1ZotzQh9pN6LdysOgMpUzW/Ufdg2JKUMFDAbQ9hasQyteiWpAMSlSGspl4v2XvyDfihVYMWHbQb0VdSDaqwpOvMI0zYWm4XWKMmD9gOzqWeKmQLZWTynvqnYFcpmEy/Bsuw3NdZRGv4lbvaf1mJEC1wj0TRW4xpC3tEpqGawRCWGYDjI/7GInE5GxClvIJ6DLy0+3LtDBQiCcelOrRejKqklQW48WbKZKlfBZ5LPrgUkGs5LJ/jKnh5tzDPLsPLjebZpYpfQVkT+kXlxvNWVChpUziml+xw9Kx0D1XXCenPAafCBO6D/nMIZ4PxUiXlOdQPETpEsNJiTOqvelODZ9ICEy047UCQTZcP1MKaJOv0iTrgZHIeqlDTfhODuqTzAxRumkc3mP0MR13zR2pBYU8lkrwFDhw5EefGJcr5qQ4IRRFJ0tw3ziMtkwbjWwhYKBmsvrfupV8JDi2BR/JAXkpUsXqJm4DO9CanT/fx/QElR/X2MK6Rzbdx0uwuo4yzqX0cCPh/z4Kw8y+VcgTyyJ1SQPxvxCpSnBMgtm4i9Gg+BEQezHvfRp34wC0YxVkKUhJI2kojrwJfjKCCFKIsyrnwjv6GO7I4wxiLoFbV14Ps25WkjBEt7qr0jN75aULPqg+VayEsvKtzXTYuFpkgpJxvc/xpncdVSQxXTeueoxGz9zzatH1UwVu3hv1F0xWsXnSRF98wUmFKNArxNeqGXXqStAvrVAvhq8bSYJhTxzblOGcU62GQtI0MsrmvgM3ZCv35nfk613npnxhUqT59Ma7jw758UJDNEJGeH6AQTFB7qTzs/180k365bBLtozGtZzjYbyWbIPn/C8cmv558jNph8vaTA9JEvbvhvaC/Lu2W4qbZqvOwGd0zqplu6ZDoghn2laNwhbYMc1p5xWf+q/Bu6AC+dSMtOxdwLK1isqpihqosXIiWHsWYQhgj+WPbHY5jDIae5aD8Dvlfx+bGWZz3ogOunkeaHwfCEAwj7lDRVN8JXvc1B/y9iVa11Ws4DbwK8kokYObcHBtY/LKLl26clb2V6XjHnUqMV3VxlrekHFpG+YGgI6ie3OtkVF53drth9DSf0aJwPVX+/d6KZWnJklFNkZCcccuzMFLq21y3PgKD4QMA5zSJBBikSlwRZFWS095meDPG8eG/1Qplrx7qKcpzW3hGlGIIKgNlnbOUBRMVaT4L5E72G9LcGS6/ZEq2MfuR4EglELAtZTzARZu4SlQQlm6BJDZAYNm1O1wv9ebkMEnxlLUtwFxCrpW+Bjx4/k4rZV+R4J3nK0dhsU+d+nZXRdE3AS7grnwdKpDhiLGqhH0WnnI21TIhyX7GidbtGhxRcJvD5bG2IqCjr4teM6vjcgXsdFdzRfEk+Pmuk28pk3k11JNiBb5fngmXvHIjc4aWpNBjBL5cP6dJCHQIa8/3vPe+q1q1I21E0hLimIbt1lFRoTyvu5aBA8UrYauN9vvwsfjKlDnvPVtUEAEjvTxack2MQfZDCP4FjpMJv3xVxLAQZ8wvJ3D3WU7AdJKXhCN3u8sOp1zfoTBqngnKYI275iHvbuw3c9XRyXXi4JN9t6xOd1QwufZxgBIkCA9Bkif2QNtbL0fPJ1D2ddVdQnJybQPY1CcMN+RXVDRqwKy2dlU9NGHyewFnn5YzPJqR4gRO7/bGLv9t/W+qTTWs3neS+j7d6O7j6+m6b74IZxM3RdeY2bXSkKWbUBN9WamrPxHAtNr4ZEveCk0APHDguhVXAJbloyrL6VazEmHMLN4zgSmu+YSJSqgvTlMg1XLazgINeuyQ/3vRRcEyPMab2LA5wPBp78RZXRvutPpDSMajK+0dl4oFElRNmd+n7OvcLKaIJkBkhiSNwxTtNdFSH8iN/P8p7H9pbikCzxrd9zQcCRJKCVtLEIr8j4g9O7DQiSV8b5HCYTpEi3/OffqcMiMcCkA1Shko69XQWc6U+gAonrGTRcfxRZ2R06QlSL1KMAT3s2AmgWSgivFDgykXouPpV9dgKyNu6q4rEB5loZnIXTDeW28Ro1+8PF5TTb5uU443jDPVobk+HEqMEvR3cCCPPOOOhZ1LX+tbSUyCZPN47CFQTDCTpo5GcEghWFnUagMOinm5TXsDA6zePD6Q8EWKig6aWMZlEq0K0segCO5NoxG9F+KfHLGJxAx/fp5e3QJzauxglwrt1Y5zskAJhtEWb24BQwD2pE8ASLjKpgCGYTQkors2bxNMLYsaBxg8MSyl8PQNMIFM9DnxhQ4tXUd5+oHlfgzZ5MN2M1qlkRoRuw8IFi0Tb82JWpI4yZlBFp5kdoMJeH+3UaoWfrmf/eCAph6SUfRKKm3jZS10+QBH/uDB71vnGfcbSuZNvBUVI3+sgCH9db6Lg4hb7NrM3PCY1f1LHkgxAIB8MlbHEPeLh1Av+GBPhdAtbKxxP3FSzutaiE9sz2KgVmc22LMLIsh9J1zSZkNspl3cyrSkync6Sy38SUXvamWoL5Mz4kFxFNj0cZRDDXYIEzCDp+3GXvUhlgqnzxWZYnSgptEWDWu4vqSJrLqRvkoFQifQ9sZaYbsZrq+95Ifr+KovPTI5hy7akVsiNhZjGD+/OVoJ19Zq1EdHaqQeY3AmShm7nVvY4l6NCf2IaRNXky+L2sw4mayyWbFlH6WQzktSpAcVAaXLymqQ9oc/1gkMSsPSdmQjLQNRFYtHungE15+aKiWKjerfjYjIf9Nvski9Aj5czX1LRtbmq6LndUwpR2r550vHPXz+dgJDt1i7boCD+qHCNVLSd3rhVTpRe740qltMftYM9cNgpkLfzTY1EalyYshA5IizcpVIuuW7QJdJQYdyh0hraxDMT7BIXKjEbOr41b8RP4NrA5zDw03qTOh+41zVwtvrwNonWIRwwDxi9raw4DzQN1LiL/WMIPmRkqFWLNX0aGvpx0J7bCOY8TJ/tp7Vczh/Kvwjx+wEhVvn1XuqwxNQeaCRaB5DU3lIDzT8kd2BDYmjvdpT2aLkEpVwQ7FDebdgt699RkaR+n6OECO2oZMF6jFwuQp9ioGYBVEPx+3rUpU9JPr0rMMV0M9kJ/O0LbFpJe9g58TyHFcpKZiFv7Et/JUf8Kk6tAuBPcwkCVNXv6K6p1k5x/D/TC3d0xcwLOrDanjWXX5lEkCxhzqGbpTPXkrccRAq6HLkwr90FTYHiAtrT2+TqPBepydxl98dYFeQBJYZ+bovE1I2d5CHqAn9lbtmX2704qoW+S3fbv1ZTBKl4n/7s9Iw39mydl/iwg0I2n9URjlSzJmv5urGot30hBah77Ei7+vJZSq2rags9zR+Q7IiJVXrNZjzqRibvsY8ilEbEbmNTfE3N56hW85M5E4UmwTq1jLAnb3RIdWT9Sjf0Q+P4e65e97w5ncHpPsgVSXYbV6hL122qrZRZG89QJjHe6NNlaF2fis+9+HPL6PV/Uf3XPpqS0BJwfy0JqxWbKYtXRLJE/fPLqUG/dkq4QUaZ2kIFhgnYcwo/1xZuZUVxYsMLt2gAmVxd2nbAdVEzTn078PINEFRYyjeGHCX2WLSpvLRCcFaApexziuJTuZNvzvMbnNuS5FFv1QstvsP0OQM2DA0qCSHbQJFlBgGWhq5a8w/LG9cGfs21ammHRZcq1mLAbA7mmCL/iRsiqIA+7g0fBe7GpptnnM4eWyETRVu7w/ihpvdd6ZwzXKnzLRj2MW3Kvrny4ckEB3myp7GTGV6SFUogt5u+6U5GufJIhp3D/Iv/tmFhy6encJ73ml6L7E8kf7Vzp3MU0aYXZ9maqEbrXoZCslzcTqH6KacdUqfk4qHK98Sh40aejrjkTsldHrGOKd3+o3aKDQv0rdZZetK+FmXUHYe0COCfBsEuHjZ9vzn10cs8w3fQVtKGHeUHW17KrT2tQKNoIew19JB2UpCz3VmJv0SqQZYWm8q8UEqQf3d0wVdZ2nYZuIj3mKlYoCY23z/nlP5LWCzDdnJekdOAnLijeS2stAy7bjnT53iRgeNtGMP1IgzKk3866IYAagveBpVjxISW0x/v8fzfIAsaEsjodYWiYKSYpzP2f7fpHZnP4rF2QVwj3SlM8bTgKDbDt3oXFtTzZPwWKCaWabwXZFqgJ6LSiuqT7J36cprnEzyK7eC+i8U8ujxl1IXg67pUwNOGrLuRxXFNe+B6JqZAOlA3zc54mruOliJNCz5MuVJR30WosPJPjTva9/f05cdDw2Q7/4WWdGgi8TXlZnZo1AFR7tykWukrZ/WdKIInZPKb5pI5TqH1VaKchaekEXP2LIaI9rJ6/kXXCJ3lQ16Ekry48Eij5hCN0jGp/3Zhu7l0f2v5fll50HaXcxcwex1hkPLIpMkt5uFDbH6y/6zt6wOROywWCQ8PFUrsGlJAovVP0Y8jYZ+FDFZTcd38qAkFXE15ARlXMfnGcXCzkkq3TDrmWdEkkS7gr8H4BqGyiApZICUvcRAM/qkEAnJyAo5/rM5DMSLiFzfC6KRV/C7bGC3wy4off7sToZZWc3fa5qiHYMK4QW2V2KHIwjFOfFzbSL96P3KH9KdZBYVn5c4hQCB2neDgXgp/fSh7l7QS95u/n3lMzrfL+W698E86VFDsfXdGU43vxsoJVq0M/fN7l/yYFBJ8IT/AD4J/zPSHFf58J4lDFcgQ2MQRD2SmVusvI6K502/j4G+R1Ge9pmMzLG/wTfAUWyzGskRHR90Cjgw/xt/YlLN1cqdNqKwldOCvVWkr5PuIzvggx+hxbh2FYmgsjNawhv5OFpMQ0uVTZAzHUj31MosvPC6iUbQOK5PkhCvJ+TUvbNqx6wO1tPaijBfGfNBMYDCxwLUMoZpN38ieiWPZX8aSMZKNLNuzFXa7i1dIWIOzqMaBOoiJC8xzFK7jFIqQVX5q6HxSak3SxQSUnxPIcrA13JdhSGRC7hNkp9zYDXe+Hdd4d5c9UdyoY43Y+zuRSbrsLzuN8/SMMKWKgUNPlxk2yASuFuHz+fSGkbOg0/C+nC++W35q34n885dy1L0vdE8b1C0SoMlXTBWP5LnxWX4MTPlYJAVQ/0k/uUsFpSS3E1QZgi0TYrj2ehN1L5uVzSpjjIGshlEJSpWBp3dKYTYZqbj4kO+z1ykQPxvcJjksGMRkhJOsua23VsxSlafbHslq/wkq9+zSrbmONGNQGiJFvfjrGgpu77ODr38gdATImu9MhXsbqjoGbXjE32IY4GfiwOsYbeeGWeXHqG6uI4yyonk46eBEA3PSQh40QMp/Kwk5xiRkWQnkwiMe7yFkiDDXLSSi212KK2GPFgtSkKFsnR4x6f2uBGZjYbFRwCcbGPo8fdrfE1kpupCcYB8eRn5WCsLOTdV59fHg3HN7ERmxBU8HWdukdvoIzPvI5zJQaGrQY2mn9/vdYfbNrVkOedxFC74fQUjoBH+KNWEPHlhsLv2n6ywuqIesGTwuWnQDEo0OSjX/Yf/ZYVUyZ6bPh+KzfpngtAYJvCofGvz1tI9O/SWq+5TZLEpmerEDsww3fCc1FaLRvsHHmujqhiuiTyXiteBfMvTS0JXtDniShg6K+014L+s7liCH+HXh6JdG/5B0eBTOAYxZhijJzZnAv6LWlioKHmLtUUxUL0XeOqIdOwV5eBk2+3sPvg4Sc81Tsehr9LIOAJ6JG1C9FM1TwLbEqa8sOGlu0G/yATpAEjtrdnDsjfFxXKdVgxzeRx1RlgDZb0s/jc3agMTnGvdwlAIQd5JWDrDLpxll6uHOxmM+GsEWIPW4CETtdynMxPl/EKUbWB6QkJqW1aRSOgWxDFe5emZyQYmI0KKcU1nO0Pio4Un+N/vNT2HkEjmF1VsGSDE85nFDnFpVTTxSIb9efLS6ORVcEBE6NSww9p9yuXp9qF8Pt2yey79RW/87DZ5HywZ4Y+EGWnW79Ev0njUnYpc9D0fhpiyPGtYTw2OsJ4DbC9uFKAlJavXFg/Jf8bUwSAEd7wbkzKRwJhbWSyRGJIEhb5VVQlQtBbbnSvcDu/QTIJhYEHcH3mnV/PBdvpSY4I0B1EivnxsUYzqqbIYTewGBgiGDVS09yZRVYX/hdG9KswWVRZ0GhZMXLnrEDYiIX2P6ktEuo02y+cgs0fdUA2fXFS8FZG56fFZ46stEhBPsx3J1HbQhRFZKm4gzmSJ02BK3+VjH4jijKcq80GSdO7PiIce0sKkb1TtRNt6Y5rOwlKeG2YeEeEx24ugwQzQemwHwHE/B15TDGCjel3Qt5Ng5/SgkJIlpOj9tbF/xxFvRQz7wmHG+71be9UZw8AXDieeQa+iO3ccoEdvHDoZbauLm0kQULxjWGMjxlTlvnBHlMk8zqN+Avs7uObnZ4DeyjPAl/gRCijlEvkBORY4XhoGTAhkVNJ1NVoHHOx7ClTa9uRGaWFmAPWnS2B6S5qizxGSVy3VXFqlyJXiheC7mB/PbeFVyVqe0giMAD2aCzIum5bZWsywvke7SqLk55WHdl4o1VZAM1cHArTtPOmdOIbCTZ5xy61krlNWkmpm4PuFyn7ejwPY+7XsQu78N8vqZFlaiTVoFAfzG4uAZINy8N8dQbmOzV5PKPpXRrLWyObQPuDHiQAKq0SMSwYj5ctHgNJxoKsBzzBlJK6SCoBM+5maD40HWZ/mTgfjNug9wFqRyKqkR0FhqnL4z8uEBRZ34Y/AVd2bNR0DABDrNCzoodNOr4Bvx6zqtimgE0MeMNGcxYuaVanRjRuUMeJAU4ldKWlzaIvoyXzEe2s539PwxCeFULOYR9ysU3IUeqnNOmHaKdD/VsfPetSvJJx2/PZfP6l/GeFPiDZ3ZbxcI2O761QVa6Lc0aCKhoi0NPtn/JBH3vKuTPNioVkmMPhnEB1nSCIA0E1+VNlHMaxdjOm2osLq0Oz9XMOcxV7ZXyCX8iDUakpspzRydtb8SbeC9HMfplLxji/j0qXCa9c2Ez3sZmYqUTrX6sNrTD5Mvtz7cdjvxqMqhrNSS4oUBK/oOsdXRo9SUP1PKxaFGbUDVx9sQ57+kbhaTGyDpvd8ml2BWZl10oNOYo3QIC+s+2Ksm6ZE72LRSVPPLnAvVuPTnMhdFwiDawBmOIe9zotvto+6kM+iUXb2opADvV6i3i9Z7gonjTB1O2LnPidEbz13FcH5MoUgcZ16qBmSk3lCdVFoiwrrsxl7NCAsloj+ETBFMe6t4rzzTgu3iaZ1yOfzM9H3a9erjKvnn/kenBrylhdmB8PdGL5sLydVFILsBe7EWgvmVfyqFXR7rVYRRJM6lj5ZQPe/WivytInbGewRNyFflH+qdNOJ3izNznaDl88+LGkX1/f6gYuLWqHARc6/iszRO4KlvgXIcSB4dwaA6S2O4ov9a+mO3722yYqSWkJoHqhTvp1KuR+II3J+w6RXs9stFHCQAB5aTpXASk8DTVhelnvBwCHKbr/5fbUngSHrvh/YNIuQW/I/ckvxujyBTt2eIVx8yDlJgggSfgu0kkrsuljuP/yPh67WIhiS/yX1xAlpMaz+41m3I6sq7qZa76tkTbejUaeljnA15is3pQQi9g/Q4tloMIxPC8gCA4n8yQXETErBQYG/ZtPRkxEFK9sSLgY4nYxHiJYoFzUPVWex0Cj0HF9V25ZLdIu2oK0dG1yKQUbUwYLvcsSaMni4xNshJYL4FBsiYAZwFkn6ItJo8qRLGaPXkBDlTAT8FnRF02gBGKYb+w1pFYHq2q/r3ofJFSHgcYWScre5EsV1OMGA3SLLE6tl1KcxhyzdMO0TDbpYYl9pItlFzAbZkPTk/nC2x20lDqhDHhNVyfIYZKw5lQysJTTgccXaXgBBg8oDrLnkwuyyWymVl5Idi+uruA1jktwbZDcTD2svVvJ4ILylQB1c/hivTdILtM5Vb2LS55Lkxd2X0gKVjfVU2cJ3LF5QRPx1oEy+UIuKM8TgKpJ/CfETMMINC2FsxBLsE5+yMCjmT0obxUGOdcyY4ZBqsePSHIVoHhALfjNiPJIk8BVxbeiIv0gZxYXP1Evw7Z6jdB4ldFyrCnRlTKQhK7r2rxJE9PaZNG3gmBvuIPkCqGcOKCMnCo6cwJ74XlGqvMJPocpBn8VyNLDTo9B1KIwLmbDDkkXd66kWNnyQCTJgqooeqryqR0F83VYx33uXi3jvn8AKThq31zY/9xDyeQGvAq1cv64nFGTNfRG5/ps4m79EylxqFf50R86d20wSHuvCEotCw29rvKYdN67rNY1+8EsqamW7UffEsyUOeFKuJuvlDB/sie6t8LWf5p9Z1fAbLQmMmoK8LjfrRuUsjppvpgr/RRpySTb2RY3SgqYB5Pd9hvJfCk5epCBoxCs56MG5UnfcWuEzRm+SX2Sz6GSyIeFx7HPhLHCNcyZCm2yM/JhAPx06PHelDatduU5ekfKzDfJgkGA1kohbiewFdYqju9+h+hInLpJy0B5/vnW0oTJgibufKNzMX0Fzf03SP+QP0JWjpDQutG/dsqk2P59ZuavDRQLL4j820btROrevu5bRI6gCIHU0WZD9kYusDsc+of9hzuymTjLVlJgF8QD2VaGmLmdk9j157KFKm4kocxQm7PBwgYqaG7K4KY4EtreV6KzJHxRVvAckMCSMlPXpI+dyN40cop+1OjWnb4lMlgXrcP9y6hxYsfDlZEvZko8xNNmwgZ+Hj6mUxTuWvfZbR2pch+sCx83GjA1YqyLpCT+L9OZirbH0iwlQZwdeRee+MWKmkkn+zS5AiCKRoRFdfHHpQw78UrlHnv6vg1xk0RSIjYhINz8Y7+NwSEEgaBgVv9XsC2OQ0UKh9CYTYUTBryRpkXyCSO02iBj3f2z+tQef91jwkH5VXGheEjavfuRR65DGMQhDWT9fe71OybYk1iflI4OOG8GStBzoenjThZHWkb3gSFOtIZRdoIm5E3zLjGSx4PiSKU775yzmu7vYWV5I+vjAEslFm3j2RpQRNw52zL/DCBAEEcIT8dO+wWnfa2tRpqRmKHL5gePIWAkGmccpfYZkWIAx/zYg1imT3mueQLJgYWDs5JNZl65xFTPrGwrXl36xamJ71j521kLxxwJE8TnhUE/fkEOobm42LVMIt4NMkOkrxGw5k7DvHtsxGxrVug7K13vJ8lUgBoXvb7fpwX89VWU+IO8nE4uztLkuLXh06d0YH0glTiZkgvMcXZ9hMbWCNHzVm9e7E2rHj+dx2c46XWFfzuF2m9hFbn7PMQ+u3bCcwfqz6oA3PDESrRtDVtGQw0T3i3h8R1hqoG9VUkTsCfKoSoLtkE7rb+7ZLB2hCnvBZj8vsF9u9K447o6iqHIdQ9tmjOxNvRovEA3W6Ub7hf5a6YbmbnJA1wf9cb9vaZkidInc/oqQYgchmiqS5hxzCxDKbZTE60EsNoY1FT+tKvqKpi9S4dKH+iKrQhZxfOxGU/Ke6g6chiOAlqYHGvLzpOHu9l8vMS0MkhEeTWBf8YvrtZno5GrI6Ecm6taN4jlHZen6kpgj84Mz826BAz7G35ovFPcZnbibUkF9NeXMsJj9NR3DcvSe10jrd+lcgoFaYNKHJnSmzV2sr5tlSv+7ezlYkGeLpUmnjxU/v0d01qjQJbMIJmdMJiHkfYUNLbEK++tkE6OG+VnnFi064NWyHDk6bmUbxS4JJEgCtctnhk1giU3kxFJTYT3yUpd083UGfa7ZrByCyIK14/oGp2CwyRXsLoISkguZeemxkSksI//AAWo5phDZTSHdjJWdRggA8r/YetfKYjV2SZIlMlBxIGWZP1MQhzCcwJPCAn0xidNlLh1uh5AQwW9DKh57Xmp/gNqXsDPGOuhH3fmIGHfXXBk5IFKeSOzGKoXoV+VFcCyLNW6azmwECFr5qYSmOhzDTsVsJ9WhZPC533lPjh0bF92t9FoWQTL9QWcqzqSXVfk/YY91bmeu1+4xIhDiukULRo1z5KGMEgnPXPwb28uwUIclQhzMnM37Up67adYBlN2qWh9NMNrtyVjhRKX3NVQaShkJbyss4p6FGaGsjZ2rvZ4gMMKr81t3X50UtJcnMDUhEPCEZVM2F/1HoIzWoGAO/1/tm7F8d4CxHVs8FJWRa/NK2+d1hIQSZ2wFi2BczKnlEkSsND2QkC/rbsjxssf3JLcYO2IyGB59nXcLxPvzfApDvp69FyUdMPNzdSqgREqa7HsWeUW6qMswg/h0a27fL3N6CILqSRwYpnUSx7jKCo28QcJlryYCsrQudGU6Wl+1B34AUVvBGMmY6bocs3j1C1K1xWsA5HqSUCw0mifGq0ESTwktMlXu/Rn2Nf8hydZ2Km3g+u76Eh5RpOc/QiMUxIya+f7X+29GM5wcXgiTvWRdX3+0uCaodmhEwJzMzpxBjrTJn9np+YMtwKhPHX/k7pkqagF37LJLLdIIT3USnw7P1omvn1M+SRgkVHQHgvmSHeCRI+69KURK58Ox+xa8AF5wgjJuYdIzRNdVY1VQ5sI6u6xQ3HZnCvMVZ8StBmq7NwrAJO6OWTU2tLq8nOn+wOSHJYmVNQoaDT8d2EGQbj/8WXAOFnfUMXOXDhE3lJEG19ZF3AMwxzQc++RVkCbxkiny0zPjITBaD7gQauHuS0m7G6xiXb3prTSzlKXmpNYEtvRGZaqZrB0RwD7T1emUd/t2JGnkYSwfgniAiMXr1bzg2EblQc2EHANdSOM972ooLmOvDQubAOThMWK1tg51eYXH/st47HsV8Rk3VOw934nbzA/xqWavEqdULEIgIH86+zSNMSSEpHWdtHg5PGMCHNsHMS2VfFcGQZ603xFvVmjADdNbAkyqLuS3CvkQtyeEtxp0bwE3fmjG6xXKqzup9OhhTKLUuBeX+2T2pYljU2c+lY2WlqkaZsfCP0BZNyog0snj97iWkl7F1VkGExvToqJ7E0FLYCwJ3MfQ15lgpZqXFiw5zRkHpvQOcdQRmPqE+u2s1+dqY3MfQ9rE2EY+l5AkaW4qGbo1tHY3dGSPfkvfhRadA7slwfp56o+IGnhoA5Akos5c9/CRF2TPUD0njlAQn31KvyKtIjhx1FVVauePC1kmdCDRTiw87qhFH/yoH3n8PvYs3OrxZUbqOAkjAKAs5CA53Nd+d3OPKcppe54C/0e1tmE7cYocXOTr69IUE4IYnIVAMvs3tR27RVoCGu+DiT3VkyF2tKmpgITWECyMz/cSolubWHvjcDNQ6oBSNwKGb66kgapztdOm0A1OaSmTKsaJcD18mPi4dpS9R8Yey+dpMMLFUOj2XPuGr0SAIxpIf2z2lCUNB2pvT4HrgqZJHAjptwinDYaFUtwiuqdoF5x4Td6B3tg3b0wT9v8OAqvRNm7lWiPhhZdFxbYjKk3TYStlPL6Kqze+tf90TdPdNHj18pzeshIuhnmMKTEzZYz3q9kODS9JfTREjI42NWNKYF3kLeUP+2+mbGpYmq50RfdwFyfTak5U2V7N/F0E0tyIfDj8kkAXVPDroeOOpswnOWwkBEgdFYn4UjWnHotYtluDcCDEmBdKXzOqcmfspvr22l0NOnaKVuy81RX8OraYn0fptks8nGxMJJ+TjNmksxgN1lCitkgPSgLmCneoMw5Yl5xI3x/PTNI6g4wXbA6fDFUILO2yYpNgDwo8iwID9Xv38Grl9dDfCywk5h9yD3y8a+hDTGtFdA11u8dz+1ca/uOxuwnFrD+Pm/LDph5bQsEq0GsSdX1COEEpPP/XPAPlZDTVDBqRgXuwxueWuneNXriZSECzXPa41ATNnwvl8LgGZg4Jc0VE71GB2fauQDwBWdVFWN+aKsDfU1sBpsyNIDo5BKuTroj1u9U5HI4tpAJWaXYpTmFFNIbz1IXlwM0AHAuXdhvtZwJNZ0ZR0yHZP7GxRWx/gnyKluNMGzPGQ4EcPWRV+VDnq8Pp3KvK4l0surT+SVjJiOIFSsZV/lu08FJB/P7iH+1CxPcLBZa/syDbLOrzNV58pvP6K1+zuXn6EjEU0XTJoFxNgfOnF1LVu0pBGDWeIG7/qi9SQwLBcjelo3a9fl9hYbe3+Ou5kfOqGaIlqXZUiA/B2i4tEveiK2Da/7rtvdIn/EwdCaPCxcHmrW4Sqdi/8VXNN/KAXoZCLetU/0mNNoFjzxaAAAnjxWYXxpVPEuA0+8DS+zTH1fugUZ+OdO4QhhpSSgUQN8QXScAbrkOQTNKfJB7fPzU2lNoXigQmmuFghDg4YusLNYEfmzHuloIi7CDxHlMojzQfijW8NyQE/F4Sf8LCzSirNcYDr134LsQHv9KwBnKUcXgmInsiLq0I4jF+HRNjWf6ORi+J9pvhGQ4faqQMfsLQ+LbxjI3xH18zbyKzVTao7QVqkZfU0DjJbpRXrk7ADQEB4o1bbOtY9zj5oJ7HDQsPpDYh/3TyGZbQS1Y68KzMEEUzZrItdC3VZdNli5jx6lsulgAF4h2hwyQ3/wbaYHuATKNV0kEiVXYwDu2Yt0gbAaNfrQOtQg9XHXVV30OE3onnR2LPm0cFi35peeiJyKhP4fis89Ld8nrX6h7NunKqQyWVCcDTnJ0udTc76gDKevnrmr9DWi7c+xIgTm+tJgQlExbkNbBsl5G9zeZaa/mOWizr53ZKzrItUKsjntocEOsku8gFCrhxFakGZOoWRrdyzrO/3FNOtMTCAU+wqNF1NiFpWE00P5pGUm7vqwVBElSj4JYLZYyrHNgoNsG7d22cz8EOMZbbdk5iheivub6f5s01Skz7v5gdYTOKwU8wkAXD1clFfelfSuCIyeG2oJOuVlgieQbGNcqHAhBRf58kqVNrk1ZbvBD6bjZZlSTMo0ptZyGPz6d6XImRL1Y7jixlk74E+Ii9r9IoeEtPhTpj0soXodD52aG40x9NcbFp7lt05NQyJh6Gqco1WypSGQU0oCfS54QzOm8hvkt53KMqV5YiNIFvyQ2LXE9TuUiedI35LMOiJCqPqTAQtbGjb23eAJwHpp46UTXSbbWtTXjhyKgS0w50RYyBtGRiawDKMPEiWzyIgfpBJNwJtva4+GaCDUiak1GpzMcWcgCMd2WQ6cF/pVw64q78Kph1/+fvxLBPyYRker2I5NEoD/OSeJAGbiHu8ryC2hMv5BO9Vmxy4bQOHZVwrU3xcjk7LS9xpZl4/jDC8UyA5Hpj8bKJZAsNhoS+ne84YSTeXNz66WdjhHR2PETP9QRNFUjWpkry3l8jq6OOo/Z6CzImurBkwGSZhSLNjMgsBGEirQMkzTMtRkePYaZhISLbqkYv2tpTwfyK0s6XYCyLNIy+ejeRsQdrF44yKq7tp9nJS+44wRCqIoKr4D2Kq7otsOFBrsQPV6WBmyDRPFUweDKuN8GkcPZsOByx0Ehx/+/1erJMwdDQ0DrWKzfX3KsIc6W3cZOTlm97xrR53H3nGaIIuZX/FbiJnEr4wtxmw6HV4i/C8Hlo0nQY6HAB36jPgD6BubMBV6TlQ9zIvYPjKGKT65jie9hHSjTaYuyojXUjoEylehksaeYgHDs8IZ8GwuJqYz9EM+Qj8IxMwHd7e5Y/7w7rRfZL5G3iivv3RPJ6+/XcKKylNBTB2ifJjfy8z8QnejVMGPjmET4829V87ethfUIgTEg1ZTKffrfbinaqwLS41x9Dx4Ud6khizlHkA1D5OaoVs3rrCsGILy8OpgLD9VzPe6lnNmj/7T5G7CLpUnMFJRiojOWjf+4OksGRRWtPWslG6H3VILJ/W1XJ4Iqsqsj31c6wLyxkxBOmgFQISNt3v/YzBx+1JrBewdQvwyIGg40HwYbprR/Zt3tq8BoSVCXugBPkalSgsjm6bLnevRQqu+cZX5Tcdh/CciODqRydJx26pnM5kJBEAh1TLOabGHBpyiaRIYHkKnQO5ej9SFbiUjATpsoe+8dkkQXa41vLgO+yfQzBG1QZoWAC9P9JR5XUxQii1AF1ZpOwONPzvW3vC6hVB6kb4EOou5Be8XXK8CL9wl4HpTeLxHZXjlHvAYlQaDBrMuuH3sHPrCUD4qEULo1+xSDKdFcElD7kcN48YdGxA0XwjwAjtW67ljIIJE5AxNxWxDb+VZ3xbg9QNq97K2tRaQTJw5c7OTIuxjUdLH5VZ0uSMR5RstZOCubvN4gOZhv9SkTmaLZpiGL38BA4mK7qvaldiuLdqKPu1N30kPxnGTHX0qVNSav7U5/q/S2GjdvvmNiABnRsEYQCSh6/NqPWbprFKB7sYZ7XqSyEoI9xbCTXSPIK3Es8haGjAZzlfZROswnYAckE0LjaSZYf8b36qi7alcQaSe4lwzTcf4bOzhsysnOctt4oeTlqzigEJnmxQ3EDY7IYCpmHAEOn/KrSvQWP1KdHOa/zJE2jRuWSNmgCk/vdpymqtmrH0zGPZp701hFVrkN9nBJ6xrh4gsDb3QZnSJrcHhRikpJvwMB7iMIcuYaV9cHLLKCOqCgVGpKP+EtBOVUGktgw8ROLk39AptloyEh7UNbETUXfY5CqSzl/ZwnKAZx+6Jis9/Ana3sxEEHSq4F3rhIPJxA8EoMHmdmV44osS8guFCHpHDXAramrPVGDmiSl7dsMmUlcXmzeyZvs1aQGT3HnT470/Ker0M5xX3agtU0zKNo+5e0vbBROwuMbxtewmhtVEfcUyVfMrhJRDZ6W/ZppnCUtcFKNRkzQr0+Pn8X7HabrgSp9etO3RzSmAUQq1BJk94RyndTvHfFuCjrF9P4bPwFhTe0Qkv1vU7vzHG4ffMegELJ4k5IzTKJ2WVMTGhzEjFxFVwC2kh/PHdNG1mWANPq8dTQWcr3Ro2FU+g8+WWQrul1EeAE9uj16oVMxnKe3yurwatXz3kpbjPnM8LOEH4TdlzBI7tbiUYa9zQCQXepog+ZRRXFlLhTyctUS/FX7aNyWrd475NdkwhJBNbeY+YbPK0mHNo9Cr6sP5wVcGd4J50XNTRzln8FC6sWUYlNkElcfNiy0hL7AX+/rddpzzsYxLrUB6FY0auZRoDKHq9mWg0laJxGSAgdU3u2FqHYGhR5SuQZVhcry4+EEThZQiq+z5pv2nLPw76fmQzYp+gk4VhVCjPQxIpuQfFOPFLg2b7k2MbxZ/6jA8UH5TF2cTxH6S/yR7Cdn+TH2DTCic+ub7wJMFmBTtGKSG+cYUPjYw9WgukDUN0iIm+T80jKTq/JLy/FzdzvpFKwht5ctMM7/Z6h9qGFgvxmsbazpcnuVar1i0FtTYrEwBJ20KAL74RuanWSO8yt4bAe01zTSQEnRs1kB9q2W6N6xb9D9QLUz7m9cg8LI/xR7JTMZ7rAC6oNGcKpwhS+BY+j7NiChRe05apxEWc7DUQF2pmRrHYT0/5bvEYLCNyCqseiv1fpjnDcQIhCWQQxQevsyjDEdI2J4ZAVJ5swQMUk1iH6aMS20IunjY0ieOhTSXE0/MTdB2JbL30ckxkpxxgOJmOuCTqA12kXVpvMZKKe8OUTdDE0Y1KUCMCLSQGY2lEqMerbIlOEIn1h6e308OVgseRhSBdydlt1iW8z2SqZf6lp04P16TBHvE+rAKjuyaC3U6xlov+KxXjZJXyVlnrQb2/nzpcBSnSmmCyxrHKP4PvmwIsyjbnH91Znm/P6HaAcvApeNDK7KmDMD2ABE3H5e3YvELQNiUZfXZsDqloghs+7swkkG4HOCgECHwJ/m5iT17MvzVOpvnoM3z7Wu5Y/T2ksSKZS49kZJYEYhpRKg9SopdrVxiS0iTraPdUDhL453/cngNE1jM5FdMu08zH2azzYp2mM6PNjhOcVcfkDwUzubzXNeeOfoMpoeeoVsYN6BoY2W5CdB7NvyqkwshfYGpxAcw4fTj1iDGaugC2SwXRyx9Wp8+oGk60tO3eE/2ADoS5P7wMyoPbhk2E8HNepLzcvOhVFFDXGCuC8TFmR1r4pI6nIyLMspVc01YPton49TkIFvHqvPSBsAkRaThGiin/dnyys5yazk8UWRWjtf/BfJHQb4Xp/2akv0KOuHKAu7SSYrEJDvdW7CiNkeB72OWJcoeZ7S3SRhKdbsXPIjkJRLVe/GAgYCr7RbduKORY1h67poJsqnKq2NszTs6gvU1OUohPWxT/+6fBpMfwEeHXtIWLykk7msG/sVf29B2iQq67WUUrkDr9S0MLjsH3u7JTfBlgoqySoqCjwGuXso4To5wk80ESlR4OsNUrH9k6i8ehaQ1cqqxY3xzxPUdUzrHejqyUmgBP9YNFa9ZzxNFa906MONQs+sDcPiTDSgTYMUAnFmRPY74cECE9v0CC8wN4cilMp0BQp5MdrUamqsByaYx0KM0oORyI9EHGIxCuuaXp0Q1bGLg0+b2jORDv+g+pvnyBpz20pSzGpiGHAReMBfkNDe0D+K0TlnFZdYw1rxqM+bwS3FkS1/6L0wBIU5ZG/QUgOOKGbreTKhpW/BBq5XqlXAG1wnYN/fmzvuPqclHck70YnwDKGQijxuVubFZwy9y8VTVD7nelSXPEJ9KZqz4CzI40gpJs2bBsp+CR6U2Y9TTl7eR4ufvDZf+D5CG8khE2uASCyJajTM0gNlz2hf8knx6tO8avTGj+Gd+BUTlxoN3vszCGGN0/iPCc0KUQXmOHmGuwRu5ybO4llhtet1ePzvBx51bNLqrRUVQMrRSsQA+hAf9DPZfbRwzEbkSrJEz1FtYeLBhhxq08kYqxqYlIZ+I2RlON5s55qgfRzMCLoW0s4HY6WUXNHjchEXWfVFfbpyE0gGUaLzpfpXQque69v+oRNxanL2+G33/MhE1Vl8wm+dOajoxA2wDkadQypW05k7XzxWB2m396NOGqN4LIuhGgA0PhUBnXNosWDmuU1C6aupJ7XWGpgsQyTabblxDsmYkhrzVfPhrP7BPf4kPjy+HsPq+cVhT4VPicGd+cRKuRPumUSdazSB3omw6NWp1mUNBaL2ImfVWD2lD17RylcE1kpWeu1wDqSENMCa6LkeK1R3/aLiOPRG7R1ttAFXxAvigrVY04YKLiaN9ANj+qMWOqoGdKDBa5AHMPG1g83YbEXBfRh0BjVEHViPzHdW76tjnC8YTUvbSiTN+sNfCwOT6vqgXGj7N2+iFoVt8G3miQag8OiECNSXsHNck4yBnrWqxbKNJ6iA5rhBZreCfc/zwpxNTkxIEl/5Gs/zL8JSKZTcoofrKpkUqG9pcTLS0tc4TwQduFx1Z9Fad4HMe1GXtIaQt0CCGZz0dQkQcnZ0fRmccj4p3ivHpc26vaM4MeNNd5mJNTS87QIvUyak8WxotDoaQwPhYc2lPDR+0tjh8aK++ukJqnm8J4K/1XwiuCjToeJgXHYuKT9lrLsJ+OXEXrIaXTn1LEwyaE5vpnmyn4zfDCzM0jTzT49Kq0lQ0OErF1vP0ZZSLBND49MTXzWSI+Ykl4yq51fjSVf+f/dd3ihItc3c80EtCFq6XpnlnR4Gt2OP4b87PdvmTktOYS+o4M6X/xjZugUVGLgia7RDATlyLt4yUmdU5C3XOQnbhvqisN9TRMr23YOpfde2+Rkc5q1z3Q5YsxPhM/DLZo2TMOv3woeh9vQtgRAMRQbasesGJHESlCqL+sUlOh0Xjd0vXM9gda99QWa3+6EL2F3c8k9mXH5MjLweaZVuTxZXbAwtg77A7CPeYjvZkn0VM6L+haLiur7K8tuxfPieZqp5551AOzl29+M3s/rQ09OqlX4kRz7fI8Gqox5GG5BRcld6zDlnOUkdd37MQlBrWiUB2l3k2zPbqINa0TNlOuI15pNM12vEam4t+oRFS9XNxBn16XOoN2lJUpLd9TIJetTx35Kb0D8v7pQgkfS+Qe2zpMcg7hOv+EIqR+N5cGJVlgTe9cpYLfZpE9QQ+jPWKZ6dv1ohaMJjJgIINnpJfKtpEi+f6zaQ45RbWOmy45+F3REpxJ0/Vbj2kUjY8Kgc+i+GEjXFgpHlWDjaLws61ZaMGpCHs8C0OLyS/B8eg06xRVLFtIi2l48ST+B1SJnUHr6e1aNBFBiPKrk/vMopVx9ZbljxPG0EiLiDW055kb8qISewKOJmsSoEtKpxupNZ8AHSpGo6cgQykrY37avu3Kc9tab/cXovVCDeK6TE66pRoJeupT1pzpidatcOCMUwkY1gld8wm+BU1F5+f6bXPuXRJMTVOrW75x9lRcZiomtuevnUPCUme6yLplJoqjrU1lsdjtEKfoxSJAzTPGctluuNeasbHS+QHvE1CpvRdInH+njbQeFIqUQ4CAE/3IczVsAqQDrHsJbqhOpCsahNtopY15lbRaSZgmBIpkk4QoahUB0mWVnBZfQYtcJNc2fIxf3pJzcbgGRtP73DURhKj8eGYKSQQYyfNTVkjwQZwrj4imKJK1XrJSML/Gc32cL4PtPuzc3Js+bpYtr7/BqwXREj/hFibia2dHfHyzvB/76tRgl4C16x6kf5NS/nzmJNGUS2uyoVmUdSvijBrig2CrvUvaPcJ//qRgoUgH3C6gu4KtxiARHxnNTUWqlaabopmBKSWnwh9JPvEYjxgE6Zf7dkkCiX1tcHouKswG+sN8T6R++koeD01vt/KnwL0yZISXlkz6/u3G/9usJtt/cuxjMwWhjHPKj4l5mIYwr86UoE5017gFQndh1M9tf8tXpM44cuTeiIng1qoEx6EJ/D8TnzH09vt+x77uOk7cz90XhmZb2yRSvfkG4bEM4mt25DPykGmwEltRME2WGGGw3lA5sRXDBC2yhzibSj3ekeVYyiVehR6ape7lXuwktmBrGpAs54QJtA3eNU2cdYOdMom2ixDPZCYJJ1ZYU07ZDc+e7aTtEjUHBZFa6fciGhOXPmjHyghhhpDf5Om9ByC+N7dfaoitBNp6IbQG/jw4haApJWpFOggOgUVaChxCBFjs1h8Py3mwfUFnf/mD9SBturgwdek7Mbl5wei9BAgC6NGFBR7q8z1ls34qavXluCNl6J27SgUV9Yqn2IkIMDJIga2Y8bl+oSJ4x9L4R508nM7+lTHqja/Scoao881UfEv4SkTSouPdZunOJxnFao+yDkYSkUH4QE3PIfXKUnFnUZG+VToKvRicF2Vwv1ZVdboV+9GGyX7gjurKbAvqEJ8wYIoFGnrncQne5r4iiaKpYfviwCQaAM9Vb7tg+PKsrv9OLM4/r04L2vpzB2AZr61EsJmMnk9uz+gaUgiz48bpUzNvqk1Sut2xdx16tUh8jpyXIvVMgGaOcSdV0v1j82tgJjUe9VfpFFM/T5+ZHKKpfPeRF7Qk7N7yS7mynowJRo/uy//5rASf/JYL/7ONyljyFqoBSSAmnOCb0Xx/lX2xGOqcFZYj0XrjBYwA/mvPmgUfL88cdiWFYdJLDVttsEkgUG0w2QACm4FkfVH7XJ5elZwCmyg5hWa8pjDxfTKeiqtvVuertIQxdP/kceaIj+P690QB/sNKIt8RNR1fpXbI4bdkbOeMk9XAJHP0NVKYk6X/sBhidN+eqEpx2oM1dLhIBtISrgbtR5jheJ65BfGfTC8hgPi8lrko6vZc8JcxL1tsxtjKPeAqOomWuURcswRvZfmXQqDJZ7nAyyaaTmSInJrn/4TaMl0odcOW+8N5F56LaZrs7p2U3jKeUFAF1fqxHHWvGSIysbB2N1o4YZDYwFvL1Ulkk21CNP2b0sdR5qsGEGeBzBF1uXmnFmxzypFdcoQ8rOCddnYGIHBCYDBDLvhiVOaWMr9oxfzQ8CqHSGNR1jWczihowHgDu6oL/1dFR+q6BrTm5HW3z7KqzHbPV2OchFyb3li9gjq7k8AkNBvTPPfyFBBpQfOWpoN3r5HcDkosdYqov8L4yZGmEUDp5V+yvLJE+w/N3+k9kzhoUTtWzyBpGOg1Jt1Hh74B5DwmEIBcveaoIJalQ2m/GJv9E9b33Vr86GTFa15G5XImz83itkHuzivlnf2XqdS+DxLKZhBY08OtNumklsf0H2MMkcMZjxWEYAv2IIjbRB4FjCW3kn54COCKUuPTYXxHwZnEdaTQSgfA+hp11i6qwBCS76Mfzb9SuAKkk1kiB/bB/rkNbAX6AfNpSY8IEzcJ76GeutCWbZklzRlHWLY5D7FeQqJLUwoMyOseRNJfrNcGxjmKeMa/LZaGq7jerfcWPqiebLwssIRXv+Jvl/dv3i9InQaXG+HunbTb8jVh02notHX6cXI3Z44Rh+DXklWpsG1NbJGh3gq3AsUcRbKoounOF38nl1Vmlj8YkR2fYj4MuYgWL9qRPwnYEOzZO75n3VCjjvdDihKH/taKZ0/Z2hf7QKOh1dTl50lXxIFMX773xZ3mC+GuYsRuvlQnN0s6icTpm1rVam3RlW/Hwu5FMJO917dyXR22ZCXOwb2ooTtXmhYucxLO3QqS4Hhb3haBAX/RSQI0ib4/2mdUuJ3l2uXMh9Lyb1WPoZuBAaI/Sa7QTifoxHUssY1hhBYfq+dgdLJ8SIcGeNN+E3aHURZimAlDyvwEqyJWyAuNQ0uZuAKA0D+oUB4/8l4MoExOd9WKmSijicj5SvlB7zbzIUOImyjgFGP0APwOVNGFuP+Atv7XUOD31kMPVIAXt8O4kL5sOicIyJV5wiXGUZ8pewiRW/yPY8z1CLPqDmAcuoE3hlR+tRvId2VAPFHNqDs9GTl0WnwE7jWNac/XgAetXFarlw1MoJTSukRqSKZkt4uNQA9toepFbXMILzeTBg4ZXUCFNf1lo/usiQNLankOa6Lh7tTP9bG/xKT8567HajAIDkKzM3bwafFDH1ieV8AhLGneMOnwlXVJHkYACd9//g/zOKXqr/zl+eJAmNtZzTuZPMtk+80aeVMgSw+zcUvdp8jOYPxL9cXBWAupaZQzD9kIaSTD1WpReQseMGCkfBbMTPlAn2qeZjh6ibZg84HJ72Gt55Cjw1mV3XjruY3nKg12TL/FFpDSBUmaTVO/ux/HOa9smb67MxvwWOHj86PfYZaGreulSbbDRmqyWwF8hDoWDPxMK4IOc8030FWTBcrgw7QdtTmWi/59BD5kKIWmL0ZstrXHzvfJL+KxxKqX2LpTTQIcgvJRHDpAymzbkrmD64V/kXXmjf2mR6rHbTIsMdeLDjXarxmFV5LiI//Ctv2p2jKLJgzjPEK1kfNlKkf1shooX9aZ66UavKH9Uc4uhpRVGXNHYUI7EoJ+CQaLjw222FUvjibXuMhFKqdaq/EoQC9C5SkcFJNYm3/MWI+8HWkN/l1gr7kM8o5eKAH2SnA91HMsS+/IgjOle6iTqbKI1mdjX7WdevZ4JVRv3fYp+ODX4Po7sPuk4Klx7SY+PqDle60VNMAVPsKHrAnIpPe+k9rKhMazO39KlgMrhtR6vNWdruQ0E7OsyK6Yu151CU9mN3tD66uvYUEHWJgVHZmU4AAUSB8T5qQkFOixMArDTkHqR7zJ3Ovdgzh0Lop1D0p9yRlbDcZz0Ao49sZ9Pfhcq57VWZGbU5gk0uXWy75Rc8RNr/H3zvo4urWY1eYfwuZTD2WG5yT1Ql25cRKeS8r71tAXrCMFcmrnHRz8n+6ZioSE1bLjnu8vpUILxNKnJ0cwcB3T+nTxqLOj4YpaWYyauoLFuacNTTXel33Hw0bl2/UMlBcCMWzeblQUrz7HvxdBeCMtJvP/byO0ULrW332FsccbvwuufM7wcCnGaZT9u2nYrmTZ9Btk5J4a4GU44NTknXz67+OtTSBEikPg3dYJMgvoL6sSkCm2Dyn2j7797D9RtQSTGK7PwAyomw54AkQxj5kwV8z84CDbVn9RkVqxZF13Ao1FEC6u9X/3vXg7yx1eXSjKo2Nkc5Og8rk4b3UTeQrsHa0D8ytLsgb0BCM+tukkyX8H/vEBgts7x8DWdgqjuXrPvkFh/Mh8QoSQzh06ChTVwBK+BLeHT7ZnPPPOmRHsyCxquZMojwH2jbQmUlHnyIx7YxdnalMsEoGxXqoYhBD4MySbtIzEEn6gcF+YpfNgV43CaXnv2Pg/vMx+emUsSGNHh/H8TryUxhmoV93rv4JJ7DUKPc+UHY3HX6Il8Q4ddrVa26J+QK8Q/f5uQsGOvBZVdkcO9LcaAKdvNes/TTyiKcUROeV/OTP/prCkZQtLYa3eUYdHnlRrQ0r0Omnx9yIVxxH0L+w23Btkhyj+EUYkCCbJ9RFJVnZ75RcN6KA3evDJnM0/XDnUvcKxueE+Cs61nKys1A/GYp4/2sATB1gXz4mVfqYTV8v6PhIxNXkyZmeASDg4OaWXi3/pYQd7NkrBH7tpe9xkwfvzIwDLDBLt9RDV3AkIkoX1e/tj5HssCu0iyia+w5AOx5uPMPcVJb1dpxaJyCQuIqV6UVa/fhWgf1j2jVhzZJl1P/3XabSkk9icXH84ga+GZKPgr+9hFnyUipOGlVsTOlsi5NdNO6at/B9e1HiTh2IHYcCDKw3r8GI7at2ghEl+vphjIgW8pmFTiytG/at6bN0ywyn+t20tu39D2ff8mSdi+C0xu+QWT/GEV9aRKiNKLCpyTuuKIcl3CNdW3tfDAaYk+lDNRar1fW7cgSfXubKhOE8J1WQcv63BB1dEC8c9LfAHLteAz/BPSmW7gop7gJfOd0ZGtfpqSEvRIcQs/f9jkbqkD5jH6pJwsgBQoJCXC9XvWfF2XmgHGte1jE9p9TOXB1uLeFFflfRuw66nrYE3SytW6veEx5NQwspn0Fs6ZMmwhDGPheNYoO5F5PjMQaJdUQBpRD4dy6nVnHMsnsc+kyYYvHOZxYF2ELIyQlVJf/dMT8ze0w4Yh+HDUQ9/UtoBwpAT35m7ZmhrnPLFj9/UlbCzm2FIryzj3RMLSGNrP/Lx/KyI2Xg7yenbnfHAa5tVIdOphpFeRWHF8bV0DnqYT9p/Xsd3j3rXReLVEwanWyJc3hTFAffGJ08i7RoGpZoZFeYUuI0djDMYdF9P+X6wzu2aLa4WLoGgaJusZ7MhxK4Zxq2TuKmBtL/d4317JPs19pxBhb7T+oB/BJ/j1NbI2mIvk/Trr/cXWRgE2TIaawP1rJaqfbwEHdXbyPypbK82FJvmX6thtbWl6h6eCiDbc/BvlTxP5S/gr3/BrvowAYtyLRWh8UfKkuvFzod5CRQxDvL4B8qADZToCKVv7CDYuf7sADT6P7ZVAIRuPdjOcsNtCGN8A6xIgs6m7QPk5u9eagSo4oOGMuJm4zO8ucsBDVcFVWqFiKe1xFMTt8QF0X+3NByLufW9n5/eNk2/TJ5lMDtHFOnCbpTm3ZlplHTJdMzXNbx4N0FoVPlp6420AhYPbGcu9etHXyQPA+HO27DUM9MMgReg18KsiU9wK2Ruq1TG1ZEpZENrEDqJOfzxHbhwZ/peDsQVvQ6ELUliPBQ/JZKdQkkD3m+7Tv955ri8jQYyAQZSNhIrKztQJQvpSgA7068rW7irmtbLbJ0VDO6EUtQFQVyvCzEicbzR3TkmwYV4MHYBiXOwKZ4T+fKxXR+v3N0M3YTW2JUGXxlM6XgliqZ9OYTvU3Crj8Zm8sWBUSNS2dCKEJSON8CxVwGaVVKJRAnBMpcE5MCM49cB7RF66YJWsO1UTB/vuYDz0wDjFQVgfz8SByj0cWzTWoOyv4EY1zUQg500NEtkXXjwHLhQDwhzUIDRp0CaNU0EuL7reYVNjdmWlfFwqz7UEl/WVhc3ThyZajbKx9mukiiIYXjGtx87D/KG7MfdFmquWtImIKqCGNgOx/QojDtdq4iK6gycdDD4iTB7N8MaTN+KUESB+tt/f1lj3q720YWNO6phWH4JUjYeJOCMNCg93wVPSPze/QusCJafawlUGy6BeEyV4aLho50C+9bzuPqEyktFDt2MvTVb4W5XjaAotkHmcTY9EjTnXpTFaWUFdOefea2n3YkfcydM3rGYxhkQwiN/iuTUKd5j6rKoYfldOuZ1MBYNTdOXn2BfNBAjbItk+T0X6jtPGoVD4SHZUe8Q5bNTIlk8WJvpN5f6iBfxA/WCIZCjzAet/OwcYtiuV3YyyYk8MDR3Q1VxUn7PO6jgUY1hOhtW3KA2quxe16s7h2BSwWuCv7NwGRxHtY7ZqUVbYS/Dvlc2r9KJuO/j4lnHdRqz+ZxYuTkQf34b2Qpl2fjjnQ7BSTvsjmqjVs0ZnrTVxrsYUafjSvCA2397dEKuiIYhu6fngA1Xgqhg0LzyjEedbsMQ7yPe3tLz0CwNo+FVzxRan702MuLtz9QPzbU0KGlfpoIpXEE6qEPgB3TRa7rsIq1zW52E4tyChoK9URl+oV/7xtHt940q74W2tGkO9OPSV4fcZYt+Oc0cgvF+4g72xnfJ/HK8Ub4npHVNdYg4/tlXwX/2ShoodvuIjCTEEAiC6RLhYflCmk5LPSEeoEB4v23FMI3dAzMyP4g4K1YW4LRpM1vieuZfUbfFkyQZRHj87QISNWx+g0r8VpM0yOWyf5Gv/eMLV/zaSohfS0OKn3LjnguWtffxQm2WDeYu9PiWchWHxIGopbfY5HFrYYG9vY11wYHnrCrRUiGp+YJpNqGgRIIq6Rxb1u6NwNy4CCI8TyV5tyATo0m9iL3rzIRI3pF3h8n0GodhX9ivnGz9T5CyvKzrqk491/R83FzPNOPoPWLs6+gP9LMLo8VkptVguOMIFZc/MlVUI5VveIK55ZK1Y0+W/iJevml6B7StAdNVcldr1YseF+pmFDmS1vh18gr7i72C1S2NIElz1aKqnzW4OWLF4IErnNThowMI5j3iDAAsTZdVbTlPiuj9DefJsr3VnPkKjvsIpr2DjKaWOVW3sUFkXQvZM56U8Pvg/uIkYDQrNqr3OHUEVFvvZN4wb7cY7cIyEbpypZ/k20HA1vP78qDY1B/1Hi7s489lKxDyU+gVo7nzUuR+M+HuyUg9fuYLOKPfIRJjlVD1SVpMD4bbF+paVWnoa/I769MHgVs5RpnRmhJArS4cSPZ8aQ9bYBMZC/lfWttDe3Ry4M/kzMagTHikLbZgmR08dkNdL7Mk/1ok9RHN25AtqSXvPu3tR9RrMmHBEDmnR/jVQWBg8a5ekkMaGVaCKDbfKaP+k01WS36zedk3hqEj6FCHSYNOaFHjkxclUhxOjmj7UPZT/eqOBhsVFU8IdQ4EvBNGWSqL9wShp6m2mLWOP9jTusLhod4NGl6rnhdRQPB5Atifj0wV3Mg83xzYR4A4dau39xiUTjJ3sn6svRdMsmsT2dcFOeiX1ZvyHs1NMWA0QbDKap1QpoVZ+fC5CTprLopYnenIFZQiCxKETWlqLAZZkvXSJNKew3s7bLd4dm59szWyTLhYrl4c6PDJijpK8iNVQGfpDjYvsypFeqY7jfArueXGRDjclhgLFkda8VoAQhTIngbapKYHvFbsw5X5ev4EFTomWkiffjP/3YuKc4PhCOXzOLXgp6ArCFWpeGAFJR086n8G+xBFDjytY5EfWxd3nXOUpEYoy6MCJawVHQC9k4fz4BLhmLp/tviJGIA2i3bkvKnmT0ENigZWBTQ9chUY5SpX2DsZMeEm6jTdwr4vHt/drTz3OlyRZBEJZjPsAJhD5Xbuti7TOK0OXQWi9HuAxPgiuYrsezssj8sanp/w73NAWn3drkpAzf3g/jBHjMpoHyzf7m6DSRKnXBR0QDkXdR1He2J+aHG2xXHOiImZPCvADBv2CAxyS0LhyfrFIHLJ/HVF3Jsb5FHy5Vj4b6r64iaHJUrU2TjND6vUgSldw0mH97opr3uiz2ObiSTEOAB1nknXk4NNcmB3wyCZok09HpiMGsjL3X7Z0b8oNviMka+TSV9r6n8pi+XYrq0B9MgZ760v43VsBx5PQvmjdJPdM6f630MeZjlN4E3mM5JeQNkr4Xl4ZMLJfuUPtmHMYiBCx+rXRrBUTzgB1sEcg6dt2fZDZHCFQBIYsTk15qH/9SGSlDdQUVVcsOLVoivAV/oxPEtXIqJ1W5ThiOjyAV86enKCArdXx993zHlv6898WdNwV+smMGIppxsQr0g7PD2nd8elfy4a3FzocU26zF8kZ6/2CQuQ2zIVaNzyeb2Gf0Ff+b4nPaI1GVy//HEe93QFjlKZlPIaNIN1xaE3M5o0b2QK48eh1z/bIymu5/UHPax2ZrBsvmA+NayOYlXa04tIyIl/iGJ4nrcvgZACwkTwFziIcuPMo27Nlc1T3OxqoX6kvRpeZva6HDj5xvGEMt8qittozujeLnFV6k9IHuAJlvrLhvLO3J7YhgcQDJ9G9hB86ezoKu6t+9r2dM5rhiX7TlamMGHQtwN6UeyzXDS/5kHtgMI6U2PLfdLKyA3hFovN3dzwU4C4RWTPDZkTVrJBV0yjlFLgAAQ9u2abLhv53HXugoYc/6JX9ObATLf0fHrL/ZP6ftVr0OAp/nmELqpkXOGXWnjuAR+yYAOnbeWKY5tStbW2UyDtGIHpRBw2nUoivuIj8PkMKz0W8IyEtKJVZh/eriAvnSri4xUnfzbzunw7rehXh7+xlAejRi2V/lURMDdD7tanIDJcl8N5d0WvoFN/Qa4q25JtnsGSqUbg00yXihz7fVMrxL14BEpTtcfKFxjAF4mw/gQYQUrORuN9pyTSc7OGaTwZhsUe5s0qLW6AhUIJOTgl7CXuDpB4DezELUD4GDjDS2PxYATBhyLDl35d4MTgT1P2+PAIFoFHm7Ru25cD0/F26CAR6li+TP7lO863zbWYEMA5Va4yrAF/sUrNSu68agT/g3i9sClIYYKZiYHbnjN2155rXUYI5MruIFZ8f2XXkHZrLdbOz98Tb/dN1eDLIJCeNClFYaSoJZ6mUt6jxTIPgH5WxNsq+h6HgEeTQQ2znNB7N3i+zySgboAV0Hc7YwgXlYhZkWiBWwy1WP85w37Tov1f0jCtw8nLTV9GOWItWUOYOv/WenB51kYVWBu9kLd39UWuQCHWcfU5cenREy66F5VrPGlSsaMTv7EiZuIeea3KDrRpGWCJ7lULrpvkgVBb/A5YnvSrrDHe0rwb5aa+U51/GNNL904D1283ffazy3E8PjI+4jlyWs9gX4ScbYuyHytAh94qlQ24S8DuEmbBCfZSrLPTvfMRE5ezDneR/M2zojz+nqh+fcpTdX4VI3lVWi24YEBlSa+SLRHiRC39eW51jmqltpS7TfN7Yz4Mr6rSVPET95V2CkhGADfom5FD7n/fd9mZaP/R9IwsRf6GW9q3PGwsBSQ8oSQ0c8NvJUPFkv1FZ38cBtxG+ojhSVU4duwmPKuS7ZMIJdwh3mHCyAES+NGaT4ulGTo9cNTbef07K3FQKuMoPB/E92w0pPkRtQ9amYG+MuyV4VgUJvbiorQhVOR+dUMoJKNcKqALMOxRlbS9ZJOphbi36Ulqj+JomM7iglBKjdb5Hk9iLsQQAtkqzUiQa9IudsTQVwnSulwR3fHcHSLa8zG6U3b92PUUl7OWMeL/wVkewbKX5k/APKT7xXuTuWSWiae/dzDdiw/H+p+anuR76olMi6AgQyTjPUQ8fJfbCrLpLSonfcC8ZNAJYcQfJ8b/hw3WjbxZg0A9qStqdH/3UtKkT6dv75B0mRIycD9AEBrKG2P3REMjZY4dvkoaK6PTq9LVI1DCnK34IL7ehSTmv4x92iIvEmqFnZRuIvb6seD8SvixsQt4VH+xj/ax7aVBLIWd7gkBZ71wEIVv4MXG6c71+e2lrkAgWbH2uRoLERfd/8FUYf+O+mN9M5gcmip2mogS6nVnBThdcRKGSa78z2Yf7ZGlSd3qWEdCF9D5yUKd47Mxn2lq0fS5RAR5ISaE9RixtmsjCcCTvEiifhhrhnTkKZWbwk05r8R4vR3LsM1JKRxGVXvDdg/KAeRjVT4EPrvsaGfGYRD53HyA9jW43/X0DfJEE2IYtw7fUNFBYQ44iu8+0jYXB3n75hfEs+0a0hIkjpXUW3YULgVILb4NuyUVSBECD8wM43tmvF0LrMy7i2Fphabd2N0DLtaLlHM7Rmjx/rxOe0pmDl8K4LWkOumZzLnlwQDL6LExFwV/10vXdBWpW2ez/7I9ekK35DHYnxkhVWCJtMm0FTUXzAMvGFa8jbJ80rHHAeF8ZvllINXug+dPc1plr51X4PleFDXfWPV5EXnzppGFQbJZxSInQswzUipkmma6XikUC7FghzZ1tvZfFb+ItI7Bc3OgafeSgMnF2uCYSm4yh6bD9DRULwMyrhRlL4X6/7b/fvGI8R4PurPgDyMulHo+fzTZq7gYcXCmHPMJSfPfQLtulgHSNAY5C6hEuhJYJjwfoCUfusnRZeyRL44PsNksY7kl3oPCPCAA8/LLUt3wXfl5QvTOtGNUElJ1N4K/O/anCkW7pW4tu0Dvuuc/1YUR+JXJgV5VDbM0Lr90GuloTwrqv+vhQAhQd1Xgc1zxz9CMjsDLUx1EFZWph74JSt4wjhdSOo66os7e/6cctMHubQOvqoahC7FXigHkR6ec0iVCA4msQPWNKbJ1LZivX0qvm+/NAjcL3L24dxUA3sBjnSTFWaBpR677IT5LLuKpC+/YfPJfe0mwh5csnzn6oBDDbC+Ostt8vvn/WIfMA+CMIbllJ8Z0c0c5RrlfaCoETwpYpDvAWLXg0Dr/9Qqf6A5sJ9StIRns2T18WrFUrfgfG0IZmXth/jXZo8mCrBDJXnSqj3fUjJ2rzXjSkMGp0Dk4+fEb3VHDgo3HZ9Gkb8R+r0YT5J5RtvWZzbiRBEvNKuERuHOtf+OBxsaUyhzAp3RP99D8hKOC8WcRZR8WLNOkyOqaJg5wcx9U4Hd8VGX3TUaRy1Bvd/BjCbUlmVk3d+qs0w0Af5j2ZJpSGBiIf/mzsCNngDd9UtS25i2ruAr8ZMSeVFOCpJt+qHllqbkkvFweHGBtatqNIKgo+8Lb9dfUR6U6YGhCYr06vFuT8wJjHXymreRFsc2nOX0+4j511IwVD8yvHXj4ApxGy5j33SfPfB3xGnOZ4bqmmk8TLoemWoMLoOAg5Y5Fvy3HgywNEoCkdvCEtjf/HSWmvDWzQR4puSesnr6SUTniJyML1olURYe8bPYAT4JDT4VfR/mK8GgWEpJf6ZQolusrK8fsdsS1HDqWYQKMIXrY2sNMGO8LIHKGvi49SXSvFDRh39qNo923DKbs/l8qDBNH75vZzrqzRX2YPxQJZqIv73YXfwXyhkYNYRJtzAtW/eDMLzSQg0xkcOnknc+pvDVvdOmzP6EwkfTV03AmNHx73XmV6EywmyaJGBpTdgZVruFEPS+cSXof/7WDDeus2Y0eInnzEnGQuWeQaXFZggch/dheNIY7vmwWfJ5QXj6zl4PTlWN1H5qCBmMZDR8fLY8FwRmLfTIfPh9ifJ/fXA51Pr70BEFyaeF+NL5qvqggPUYtYYAwQycJ9mVRHGQrh/+VdDQUApfYLXA6aIjPBCBShWDkOdEGAMIZ7MTYRoCkUnAHst+nofH9FaIPXwCPZFm+5zsJsDkyY3vsK9B4eimT20mdS3a7ocUnTFDZwXbOcEk7F5vu6Wy6XvMRwyb33qahbaU/NtDeJCPUFOlONztLbuHWi1871iP1/56ldPuEb8GvRcOCZB7AWReUcfALuc95dJFe7C5rjf3U6hSyrdLg/lIRAiszqt1NLnc9ZM9TpW0wOE/aBaTzQgQcmOUDoopxLedDLVpUbU+NH2Gof/KYTkRKo91OTpgl/atCn3R71g1EJv9BZI0VEwugJrbeprs+u4dECO4rp0VL5E+hA9UEX4eFF3N2ABqABseM2RQoIMj4fQIJWqbT6gbt2ASZWkpRZvn5rTCarrX0M8PiHBc9+lTGJdBh9gbaHVt5ChV02eC/rq1shbWQOoxYv9H47w4onTmP7l6sbBucNHDj8gHUGeYFR4xGLaZFa/0853ORYwzfPdOySEhT/j+k5igpY0PNQZiQOQq6/Q8C3XYvrHWOp/4Zi6wMrqRFplA0leK2HaYNfIg+jD5xqo42Ij5qLqtIhNdTE0VUUjCJMo+6VbFTcKeOUAkGXPuBiJJHWzv+YBhAam8jtmwPFuyx2J1+J6caMczynkj+O38BBotT2W4s6gOCCH9PkVCQzIvydRMt08wl0Wo+hkoYyrrHru9V3Y/S7W73HhwMTK2eLglwN90eluJDnkGS6SWBYweje/seryTxsmXSBgh87q32rwn1wwuNrtzDpWtn/X71rYiPuW0CHX6uZRxPLL+7hYYl/GCfRAKpwBQ3lmGT/xfWNak19FBtAkGla5Z/Ug+WKT/czmwIRRzED1hGJdYD2j7TOZqwmtY3MqgRjHRRvP8bXokI2eiiJa8b+zzEWQu3WbxVCN+96Q1EnaH/kh8A64NHTbt1xxVNtbC3pL1sEicG0mx5fzvstcbq51WoHpmazPzUquCbzFHv5u+UxPIgd/WbwTBQbyZW/Mg6bVCfoNbaJkvemlj79jK+G2Bo8pwNr3ewrwX+ISoevY7Dc3k0XdXjLNWznymSOVrGXti6euUnkFoZYhXwjlL1/2BSPjzSMGd3mMz09IsFYRY6onGLuXtoQdSwnOIjEGAMEgMmoDIGDNlZT/iCNVVmNgVKDyO2Xu13OJQmrbMB7g8YDwRcLLaH8vc0JTXSLBHSJVVPaEGYtvJxLNEgYuP7iPS6TV8pvTqeZF0cMVoPaF9ZNeHnM940L+ShdfUaKvQfPDZ0eXU6o7q+KxXCUHeVEgN0g4NUqwy9cQyRVVUwCbpCCYKIUsAPGThp3dAT82vlvpGgpjhAXG7eB6wuQV+F5o/thqvpY6y3rGMZ6NCrATQHhYJ4PVuMrm2oXVOLYOQa7dmBBRwqqkx5aoAebNwevZIf+Rh2Aiy4UU/AZfyEFjGzx+Rv+r0WQoQSphBgoI2ezv/iraeJCQULGkTkJ8xvPsGxUwff+S/SFsxhUt2QdPMbpLaQ1mmvNWaKvExc0G/kg2CgmZJoqWOBSg4alCaFw8LHDCzcwUxTRXwOOq94CRijfHD3gnVU2IWbImBFVEq1+U6nXmi1ND6MFOCqv2OtmiAuIOPMttGLc+YUfojbmZSGAZ3iSL12KlmdNL7CIM0ZigoprrgMii5HaPoxCuHT6Q/kOagmQp8X0hIzEroVZoSdbJxJVJ/ujWn8tpgKRHj3CFNRQCyxNcN9XspKRCb0W7UjBq2bsvHfkERejox9xCTrDD9Ul5EOta78qtMiH0+HGQMTUVaWG0dXwB53qfnaNXblqxkZvbKnJv9fppWXwXYV/sARiyoJS+B6ulTH20dDaYL5TwcgTRbYkUDNEo6OVtOKKfyqLwKG+ZQ+kMBzprOVj3wkalpGolJ3bYejDshIGG+42KVyc7vNY9aEiI7YUe3gDOCXo408eaE+Aeu/EzD5AkoTo1h0TR1C4C2GPV+2/Ajk+F/EhiIfwBBArvXqFQO72WTl7WFMl89jdqVxCGzOe5n3K+dZLr+fx0Ni7K1403Zlhnt6QqjNiMqeuo0EnK/0wMpdiyrWmDFtQEzOlCMlND1dNhwrdSSl+zfiH5wlB5cHEZOwfcbZa4p4mGbu/9yV7L55UPwGumBzOVMj6BTU3acG6JRXdGxuCF5rtMqZvjIJ5SH2PsPwLTeAXyDuMkhq43yM9QhsydT3oFbaTZfrcl1UhFoBYWIOOHWmV5c2m86TUsY5FA26fcIK7WGRlLUKQyOfDLjvifdmFiMAZg55CJO1IeOv4kxDsgeHjJgozJeoQP5hm6Gyz/RAVgjgHMWx/YCTbnDqagXrULV9ltRT36Z2SMDZZVEyxj4PVgNNBVR1m8NLZ4+9yIN1+LKwGyktSy0toqXO8Ixmp0QGkAu9RarjmYoXKZQ2rOvZmTbi1/KAl+LDFhCpwBsDN8Dq07bb/tFXWZNeH97MStvOBvHDGaBoRWCdWSYohp2p9EaEIWKT3KT7XuRyrH5Y5aJcW3HCwea86f5InQRlO9nhNepCCL/Ae6lHOmAa4hkYe6gawQSBIPa7WVbsBxrJe/wciT5fH61uKlV4G+jDbu14T+tVPJzPTQB2+VYDJK9s/nnPyvIqsA2OUSXPEQB7sO487dVtzmXmOW6kJRfrPkIaw5UUM5n/KFRdLsvh+ePKPSHT3h0Ga6Kv3WQP6QK/iQ5GxH4U4Fef5PS/msr54JVX0Klq4Q9KxSYj5Pk3y1BgQtKhl9J/icez3oUUTNSUbJdfdarNgeksTsEcza75bMd0ZQ1ryCKU6v7ipE1dElA5monccMconkCe7QC592OrR/3nk+y73kU3us61n9kr0zUOLTXfIKG7eOBi2H9STCpPrhYX1PC2gIdwPdcw2BtFVxWWtYhoketWlM0fHkkOO2MpeRPgVhy+tytLpjWITQW7r4MxAO8hbKCbk+JfiT9OZINYNXGSuFigdoi4OLPrHaMp6zzTwA9ctUmqtNyz3k62Yg+4fJH9/dsaML/A1njhEFa8N+khbZIIiWBql84qwpYlZn/yC4Ebu/jfwaz3thxSEsnVpcuYYB863f2WN11Qa5S1NFcuUS1om4sXcJMJb+mAg7nyJZRg00LEomVDTUAKuO/X1BAQq5NfAqSjYZ67jnno2u/Lol7295LAtihMUiaR/fyn7so7gcmO8BgRa9T3NxLd6X3jqVRcD9NiVP8tpus/HTHtY6e1M0lkpum+f80OXhL2S5+vzelEQPBv0tWx8wyahK2fP8EPGNWeAMVS74r8Z0k8Z+Mo6zeU4XQDHiVxUurox20dDBnzTZn+gVePR2Qz8Y9/5WRUELf+5vVuBLWm/odhdjPgl9EE1ous5/WX70uw9DVjgEB8lvaY/HudP2TZX7h0M2WNpqB/EVJO2ophwe/8klVIiRkUxZozh6CrY5AmJBXgITt06xTrhyEgFhXcn2G6BufSSxJJYZXGe1HSPKeUQAuq1RwGXxr/qWeUrNkPZGTgoeYB9S80fmfEyFWBYd8BIvzHOz9yDoapUITRKV9p3BcggNQlVfxoN2xGJgjyLPwI9+yKfzr0G3dhQC5OCQTfKXxyrKuuB2mYCGMEcpPtlrrb3SI4wtRW25x/SwnGrxdfsXBLX2oYvGDvv6I27MLSkpZIONOmxpoKK3fOQ6Lx+X0WHLzw2t6W5qsW1Y0WYpELm7C8VBTEXloAPSy/D9jUeSaz73Ao9ibi7X5MS8Ac6xU5vC5bgMuZZF1QB9W60Xw0WMiJk3vFVSoyVr6CdjaAafBYwkLF/FgUqMvAJmkord0Zz0PlDJt+7r6PGC1wJ7CKeNgKitHwBJtBmFo3P4mpEmS74sjuMt9FLSYTAbJfIyL9izNAueWvO92AnSk7QWypMwkArXjSOltGcE5847nB+3qpf0t+cXZxqZOjgmhlXRQV9soWibRXBaXsy5aN7kJ94pOTGUfX5uFckNmxzsmDxYa+FRMmo3+9jCyXxmFuIjNslAMwYinmqz7dO0wksrVl1UfWfRCSWIypi4UH3CxJsOSUis7w+LTgepjgWZQ76lUoVrXFLk51AuXbF5ATAg3ACJ6dktg6PgGuOscU2FdeykPYNpsH0+YkLATUdjIeTF0kd+D44eY7/2QJbXr1fTvgEr5ZYxdnOGNIrZIa9OEbERorgNm7SKm/QXJs45oy8EVFPg44Kg5GSMCR5HiGrKJ09DxPfQmr+RRUsXrUCvMOn5Z8SSGJGj9awNxkjxhZGvxh0oXC6HzHzXH03vUEboC8y5H2YV02F3KnzUJ7w4mTYuDI4QuIjkzc3fUAK4mW6v9nLun8YcB6HK/0wkxcaJs82Kgleevnt+BPmSPUZcFObUkppqExYhSlDFwf7cMxMXDPNfMaSdjL0lUCV+UaLCJH6q4ozvsyB5AN9fNi7TXwSmFJW5X6y/onhJxM3qoKZR/ZXMX34GggPm6oxGGpBjIg3DOXp1T3mY/t6P7dJ9JzwWGzlGQMyubP2Ua6g7XLTlgz7uCO3P7HmXQ9sp3xbY0TIjrwMPlGGJd6iAW2JFLtL8kOzB6tK2AoTBEDNi95G4FnKXYMbwp1W/FzS8OqqnemAUojca31bbggoTcWbeVQl0am1P1mhBbi4AIbHq2jofdaRcXkEt1yy6dgLukQJ/MZzhYzMitAp9ytm6YGuoHJV6Q4n3hpiITerYjwnIZ3porTE92FwnKi2upbDBQJ9WXz+t6cq/pr4NuNMn5XvBFqE86RsqX5WkcCSTQJVakreWtNPTWR9hmt7bYdVtTrQIHHFjfNnlhP1Ncb0yWi2Rl8rfGK0PSWL+PqmmrPFp0QT9c1h+uEmh4I3XQZGHwW7oQKyhCpThmGXAm083RQ53NSpsgy1N98bpydLUVZkUwXEdKEzGkdd+VpNEZs/cBPvrdOKJbwVWVgcEz5z5MmQQiobeC79DaiLyU9bZlUJaCE9q+veBkYwa5t+H3EIDStma/hhOhatre9QURJocGVuYx+DV3gkuwN1YWzYbqj1FFAd4zEV2gqijGF8Kz1lP5ehdwaipILEdhLNsblEmvRDJj5IiN0cQwni9hY/pRsmXA+uS/GDxoBKuTT27inj/+A+qiyTYvbLAzKzx+iGThyLq8Z9MtPVyBql5dkBysiM2hfP0eyoiO5GSb75z/S28d3iOAtR+YGg0hMAKkMN8EbHhQ4TFENcQREEMVbug7j7ogM73c/QfZB5Q1CPbRMLCeOT1/LHckgnxt21PS0Rmc1N1uJnnT4hq+48EiISpnuMhcussE1bw5KaZ9oe3Uz/feteYAONvtzIwTG3MNqO56YNg9sj/ymKJBGrSdu1x7ZP4nSS2kksgWotlzkqpReBie/Qg6OxKDsCDp4C+eev7iaRZldwonb+AgUnRwJehLOJVB1T7chAWBEXzs7ry06TLc4+XNZ/vFRzoN9MGGGRLR9nDk+7ov34kByMf//kDwPqD9kS7VcKCBFpeau6j+soQp5pELi7ZNMQ3cnLOUHiTPPUAcq5egazpdBTZL1sZd4k5fKHCaOKx/XbYxopqJAn/YDPyTEyM9JSO7wUXb87sjwrS0L0KRNTM1ZTM5dnIextk+77r89iECquiIZPZEeYRQ2ccGGSjn+0bVDcyFND2rim5Z+KKGiC7ZNhU1BiX6i0BXCf5usbMgTwJj4Q0EPy8aTvsWD/aolj34y8sIjc/HMI0Vk3g5tuo0m3i0XpRvPVxWWPXmWI1lkZbZom3E4a9lydYl6eKTmTHG5dVfiQi9VjPWuh4REFNHYOVsRNPD3gG0l84UJ2C/P2JTKQA9u+tM4LosYQQQPYFannKbPqsJCuZnT/+iOWQTWLsBaTiJB0f8voxXxrYgda/eyv9ITPY3R1MKjV82T9WOI2/w6h1VafDU6Lcl1GWVvWJg8KGUVqfizKY8eP3kTEsNGzlYnRX22qac8y9Hx30AvrfMR6UmmB4+LYYfvHvObtFg/4Kbd8xF5f3HR9FP3ZheojbFKt1dY87mE6U+z9xgXa3PC16G17M3SkBOW5p1kFxb8Gkk9gtz5PS39/T1FjcCFyC3aFg36sp5E3c6MIeFg4kDbuqybX0/Qb9ljWzepdkuR+SwME/Zps4F2G5G3Z7uXm4KQYL6J2t/VJGv3XlWd+UWpMl72mRP7j/uPiHy0ruQI2sQZjYlqaHOidnnVJF5VPMoUX4GUWc3AiKTtEUN1Tur2OdFrFPPBa+omohrh8l1zPPt8YAfGYS2300bgSa0eXcbU6yASvP0m4dNOsXaVDaiu5vFj8fFHCy2fiUJw6nryae7ZNJQHOW7upNxNI6ir1/Ufs1IOMaDPROzCGqvLf2o44Nxnp+bQOLL4jC9MJUFGo/TFsVjgswwfwBdeQQ6vD9NIIs7snnemn2fwdC+sCh7Q5+gswn68tSV4/Mqs9diKL2R5p18mACxMQzZ0ErYEARptPiHsAKy9jBpPxjySbOocw0UzCZifuVigJhJQ0bciPvZnrMwGzfiJWpoapw8b5vlb7Odu+gGRbEXIEls7QQzOeKUQUP8XAskWheZM6lDo1B3w4IqCDsLgnA0Bt6sE03vjfKoaQL2P+dEJ42an7OqI0T3cOjbjdqcNhBY0okkMvAd4obFnKWpXPyCYv7S8BLuEFe/qCLzgQuQ4ZtWA388/GB6NwlA+zzIR1+wQTLzbL0+Y85zveKxlGD40exuVQqGeolc0EwFEN2zj/KYxMFgXg0ZibWm88qwm/1VtpYuASVfZ8GEZ1S9mBw+GaC2mcuzxfzKO7BkLUdcYp/GuAorbIgb4wUKek1VmGJPME97OAwuyreu2KTfbF6pj4HBjMY5vtaHfEaWGAyjY28iJnEblufh9+/jLuWuGvJAcdis55ay34Rf7rdodbsDVnQjz1vHk+5Y387GGJjONse3/ZVqZYnVRTsQdvkUqu1BpBLIsLVKVYT8+Em9aCs8cqAC40ZgkoanxgVHaCj67pPvmNokOYczJnJbiAjg3pDfgdPWXAPDVSiqF2oT/VgJ59X2A9++NSzrucI1L/CoQqtpCZtWB9tOigL6C48WXW1qbpRmzBrm1xJKNW+QxskHzQjrfqc/3EDzSjmPuzJrBBZ0ZDffBwB2AW6O2Vc9xkbKBiHfwYHpSyE8I8kNRDocHWvdN9oRzn/zYGH7kAYC7t0Fa0q/XF430/H2beGrRStNQAiKpJYVJfh7H0Y493B/G8oVvjJ+mBDfewRKknBbZbXb5FivJlDkwFbOmadAt1RIl2N7Qev17Kx2klJI6TW5eBcvH6N86/6Z4ED3nYEU0SnxUFJZh+djqwrXnyRHq8Q9KGi85URjRBRMMjpb3rf+S1nz8lCG8b9N31VvM8SlJB/FohFQWBL+XWu03DxtEYGv1ZcGJ2p2PDcKZ2OuqFzRbMq0wTecS1bVLGbHWK1Hl3iHhJJpIPNVbIYIcqJYoakC+OVJSrsKSTBm1WcnMPOepXvm3OaknGtd5VO1kZTsRsE6sqkNOIhtuZOV9emardY75EkslyWXJVfMML6LuDmyJ41KGq1B8k+ujSufJGcE4Cl4OkLJdTuC7DuNQVVPp8rlYlhz/kscDxwOxFaxtFzj/tEzlD7P/5zT4nz92KWwrCrwK9lFtHuXR/EgCsgEFaKnAwxCFCfVBwu0Zz09Nj3bf2LNEfNk/J04KsZvzRLaCEKBZMc3HqXqJZyn5uvoy2kVX0VqspghFdn7VeoOHQXAGwfepQYP9qwGpdeE+cyoZga09gVUUARDEWQ0hzG++7EIMgyjCI7tlJQ1QNzwnX3SlGEoDVpI1lHwPahYiOmtTpzx+K3IK7CxkQ+ZR+JNLV2musbMuadCN+C21KR4Y4r0E7ZS2UponxPDy5dWfsESbyBFj+j1HSFL1pWelFjq6YfnYt/qcKFnq36EsrbOol7JUarxqFPAdeb/qzxycavw/ya5UfEyJR42knMTsECMAFaVuZPyxDhLYTs/c1nDsUTHKM+C6V/9YV1cc5FTJNZbLhszvywjiCBzzx4XZFvbJiDk228Q6FCI/TIsm3SZ1y0cUldkGyVAznt2ryuNI2sANBTRVJSH57bxtpqiDvtnb8RYb5ajYi99MML8bpH0cFZNsedq4GuSdn0Yh/Sa9ZKEY6sr58n1IyDTNMiln9smLZmwIzW3mW4Y1//deJVtNqcyG++QD58zuLWSlpyXQyceB2rPHKX5NIpd8KE7wy4s0ePtqvjevqNnEfc0XGKv2NQbL7jgR1821DiC7t81UcUzLuIHKExenU3eht3Pj8sN5jCotTjIwwCBUEwwdZgctn5M43O3sTjYysw1sqxNmZLtTNcEvNKCDPbxyWhN2+tYZVo80FdFdeCIcuOqXBD7duu0h0ib3XROdY7mujETJgpWzyB8QmN0VQMR+Rj6o6l23+aOJ/g1kjVvmdmW0nyuo+4WX5N2BWI+dcsDBcjQ1GABSGTfM79RJcHk8ioyGloqr4sKTV1sV5e4lBY8WuXgdxTeBGOo16XqMN9PiDj77aod0Vt5DJJ5YMHLnM6RWfgl49AoHTY5iH0eAIMn01SkKvyCWrCPPYyDBtFyMTdNhvnjdlJrvPDGlJOYcjdGvfLxJPFwzhEIJ6k9vXYqCd6k2i09Y2Fu47rK4ifJ8YogQpDZhEJgSPkfj6EJjGAIeJiAPMjLtcwAHA40a0dJewFRxYTyLAl0FyLQ5s1Rx7ry/KJ7IiXTYpxHi8gzxjbDofyQ2xUCJnkc5GHpktM4aIQYADsPGGNnnt1TH2sbVt4ogvnJLb1JX4U5ep6mlhKlRBeDuG/WBmvLtWti3blGMsd/LZn5GM2f/4yEMO+RVHO3x9DZ7BpHmBZJ7O35pe2rsiHXSZgABWdLVIMN1dkikUUNWXdLhzlrRMlO2XQKQ5kaxcCB3CuQM4DZ0qc7GjYJYburYBcn0NFjselgm2zosCPoSAGQhTKNtOjHxeLiMOfZxDLur09Vz4DzBUdFCUpMpfT4UI35VUUXAxOjHu0LmoVv1six3obhVWAf+EBGPfbbEsrL7EcfBz24Tny0f9R3V31TvdXRvqACXybhPWkic54haEmHgREXqpwewjan3mcZlOzTC1rMAuPCL+ubcmWJmVbZVs+3Xu5K/hA1973kR1yDIKlmLJ44XdfP7I1eXohWphFKoRVugaafEVb5DDSkRoNZ/E92zEM40o8QMr9969vL2UeUlw1KpACnt6yQDmAvdcOiGtObyKwpx7wQx1hdEtBqsc4BGi1dk7bnxRpg6jOZWOuouQ07A2BIKAxqVaEB6q+c9HfAoRqDIW/fWlldP4ZOtdDhwLikkabTr6Gmv0P5HDlNZrLqBvyINJSSa0gtnPxYQgAiqxvBx/+f8BuVy0WHLdllAOimhgpgSO4uTCtmWKJtLM9pJ/F10U6b3RSQINNUK5+SGx7SEvSwlhWzRkqOCGvWI56Nb8J2TXTPp1sAfaPElEnfCxj96qyDLFh9aQIbTiknWgzAn+ydaLwxFwWzqwP/Fn0JHLTlHyGOf+ZikJEvyJqr+EZlujnSWMqz+WjBRsakcHHhIxhL3yjof3Qvst+rXqNd36lB8710RMM3LoNkHUi728O6NyyE11dKMcPhacPARWfS3vubb6wKyU+S4abkeq6/o1AHq/G9/WjC9wGIEMOUglkxS13w4SrAYZ04FT7MF1uVpStbaZJQzRDo8zBDuaOaVIavD+657GofYnOWFdaFFMWoJgBOHuX15q9Hf3pTNKQeSko7Bmo3Slu6JQc3h+bV9qb7x937n8Zt10DNXuQDwDrYgU4KMD66XDIuyG761FVN+qb1fPxWv0zcpqQCxD3WZIRkNLxAyDEZ3H1OnZ19Nik9BI0VWpFMFLPbhI2pFuOPbbJGh79b4Rq1dr3qhkOn1CJcEJLmyXLJNvFQb/z/RrWvvJJ9rRZOuh15fAMY6hpj3K8w5LcwLaql/+rmK9ov61aY93N9Lbjt4MZk+FzE+tEgZRIkiiC82BGLaWt1FPzpkjcyvlmKu9YtIbba8awH8YU/VQyPMu9CM4/tt9NByhKP+fNcNpNtgeYHJQ+BxVBcfUg6WtrXEC21GodGFXDnNqiCQgXPxiXJWvn5/oWmZKtQfJnXskgcKy0ZQlSe9Pjq3+p2aJhWYNVNArudh2hDYw9JLUUI/IJpZqCZ8+Vg2BgGxjTARBhd8vNsyh0RktOZhFrNfFnPU3Cj4GQIC35qDXxp53GWivbE2vnM8mRH+WMHaZ3ZNBmwo8hz6PncKuJt4uFHm6vQGQfFJdeDhlGtjTb51ILaKvZgdZ0KtqGARnZO13k+LM3fBeXRI1H/YTsOjp6Uj4lOZkYlgdy2boKNr4V732bFFk0wILSkq0NS51T+n657MzV0SgHIV1WOYtVhFIRrnwea/2kFlFjR32mPNiERQWHNqRNFI2J3V8yHw6PQS8Jh7Qdsajox7NPLmynnGpoFJg8SUAHSHNScx+vi2rM39xqf5VaMn2JnvG7qiip592N8b3SU645jXT2lHiBA1dzhgmZqds+TLjxyxmygZfvCU3lyO1VjQMa2Ng3Qv6MXPtVR/0vWRKScpOZmRYHiio3vqa8L1qY6xclmWy0iT60ugSCdlJwYUtoMkFHcjnCEMThl2WHvOCluph3QIGQaLZG9tbjcBP6v162/KWBrZAe/gvRJG7yKDbSHtE28sln+KkpHCMl+qJr7yR+cSzeVolj3hSLwAK2LUEsZ79SfYubqGdlHuRMT6N7H9y6NH/3u/E0SJ9hW/AF5A6tSCf/fnlfu6QBCcQHRb/FvE4j6QHBtqTyeLD1XY3firqk7YN6iBmTmVINoHbSAyl5O27iVReuiX53PVme/yvH5iEIueMWoUKfNACxiPF+683TCH9CMbhNpK83Kok/wR5SB68B8L/RVwGzGHoj2Y7Drdm1e28/4yL9u84LCrnTj9lRN4m91iAIqwBc4ivD04r5niGEznw9x0L9bANrq+VfbEHNE8mrIxLVgNstFpLq+AROfBsVEBoxCZ9lhSnjHPyEii9vbBxKq849wo7ncCqTDuYjBvxyrZnF0Xv/CQc4kfMFX8/n5XqLFX2GQ/07kXPdoTMlQRKGTpArJo2K+AFbyWMKyZPbHXRNrk3iNctLc7WsXvOVgCrm//BscU/FK/E5GjAbFunVP8Q+heBThsKZnTYsyNrpMESR69pEPI+g1EqwGFJi+ZTjEo3ADXfF2SNe2MMviY8+U4ML6OSOWiu19Rl2kI4PYPLHFRqWiJDiKAeoxUEDfYEnAfQ4KRpZHvqcy++T7pMmHTZTF20ctB7SXZJ06WPmi1MGtUuBqqxZWpNNM3mmd7CKXlejLghJ/VU8T96/dpbMXI4qlIVv1heBmeqx33Zo9nBe6DzBmItVfiWxfwzvL9K22QDFAVCgGXCDsj03kPfzaYKOqPuMstehXwNrL1INX8TFoGWqX5Yc37Jn67WkmGzXb2wPWNPoDRzfZhkr9CGe5K+NGePX2M+IWerL6jFsnzisU1ZTz7X82OzZtJZ8rLY3W8GAJS7GCMS9rVgZOA50L3C/Qy2b7LvePFX3+/hmZWqTd8JgWComR10bFf4TczMlWnlxOjLJiaYBTB/bf3k9LCBxUP109W1bWqR/COXXFp6GBXjYRK5hLtrBWN9T7Mfs4lBjt/RYGQ1QlYEpwgZaArVjLe5saavuSeJOz10UNWWb43qIH/Kw4dlNdLa1otqPO5L3bKp7mz1VvSeZ6btg/rehjSRU7MEVEKW5mlgGwct27YxYeK65rS9PEIN0Z4EvNVSbvinSenNiDt5mT7fpzw8/TUOCM5egdfO3LF07eTkYtyTweuBvrv6jcMN4O4rosC6dmesSBY9uJeUoA9byX9lFr7F4XOqMFGO7i9/2fvJTzQEQJ1lDHPkIODmvii4ztAl1reWIR/Ewg9eGoFd7ytzJxXIM5yqsev9+mklyj8c9jzuKSLYxltA3HkF3U8761uZJIR4IFmyu9H6vsCtijFt4CjZ2F+s1rY9EnePsX6lp4CqZB5Vhob2pdALmXC30poR2CIPtVhhdBtA+GMZpV3oobtI8vR5tlJ6pjIC4n5XDtbCe/JLYpdHADR3jeWnVVKU9wv7mwv/QQY3v+FGomWm2e1i19QLQsVeZkPqfcwlBSceUgMipFpZYz30Rh9JQ8sGoktCSLLlHNvfyUA5vrdmXNrQScFxC59Qk1rbrSY2fgbDcQi8kRzFQr0kWheDei21rgIKx98qV77ldtQyAkPekA4yCmAOcHAhjzPEF5fDMmv+2AxzK7K3tSk3vpPr4su1vogZdEnkwJp7cmMDrro7c5aE6hyZ6ZsZ8cfR+tACM0gfvnJRsMusKJJ2OAqnLEX+dTmjULQ17lGvwCU0alQeWMoJCJmwx7YNNywXbEV4to0vd0seGOMyb+6VlZKIHtQoVChS8ij8dvTWD0PzKtXFAHrSpWM7gtY+vr33UDvvTuGy0NoFPvvn6+5yVSj9UIGSSN9Y7dgh2ikAEUnERldFfHsfS8DQaBgcW/Y04pCsvg3QCNPD8Qu6SvOiLhlmbu/EcXjxk5I6/PixIU9RAwPXcetoODnD9JcaIR/SUH6/iu0Og9bd7Sc2YOrD6mSHK6AgQkgwrU5161eB/61Ets5Pzy3JGqWczQuNHQoA8xRhU2z6GmaVfGZMqdJKXBgYev3KSDtHG60RpAEPcC5OUUxlM3y3HRbch/5u72dGwkR9UKBdAZGIii1M5J1esntxhCof/CkLoOKHsPNuHIs5kbh+UsNTwzJXHgyzsxaM2BFHuv6w2a9zU3sYNztyIRIOIpSKEncnXUs2wWT4YrrqRNaCeAFQ0hm+kg+pf5LjIFd417axdE8p46WO5UR3swiVel+AZlz2QECfYSFxX/mkQmtXIZBBagns47Z2cRJgbeJxAyYMXcGX7fvFjF8N/dgNMKNL0XN3oimgEdQhQogdyMPbe6MdeKspopuUG9exsBobHaRdbLStJV77F9iNOVjHSRo49fWKAUtRTMh66V6m6Tzhl8EkseaILeu4dP0xkv2mrmjJWlpS2KHz42mCqWJ4f/fuPBenBUb12DTkBjfN7jERG+vArYYj1nUa772rjntKYhuheR/G4ckgAFk8tuaNHLyHkkR7rSE1i0jBIRqWzhbuSbLcEzCj0kW0gn1hsvjypEoMWVA6Gly6qzCN14kBLZW3mnf21DEDUqz9cDS/S6tfnTtxiUNYHtG6okQD9fkDGI0j4/RM0egOUvcs+0w4iTCHu9a8JQiymkFYh7Hvtnk/8p+ef0m0VXdK0gJldOIkWDyd6ZPvOj5Q1aHgBLrtByKQkqvlcD+cQj7IK2PZrOs4yw/ITjbQ6S/m8ULsNS1LJy+ggoIXr0KAODr7LDAL8b4BPJgaMug1LyjWRkXybjVLN3TDKYqO3qv+9Vg5HU81BQfAumixR57WdcD94J6VOnrkA2XGghCVuQny4HL3+wX2+bFby4nQWhct8fI6c7C+cCeMSX6UjDxzwwppBzlKbSFbLI6l5mF3BERkqv/ZNjbdwZcR2KrD3NiJ7GFKsFDclQG127Uek35taVes0HPtw3dvpxbo8y3/NKsAj6ntM8FAhgqdCXXF2Pzcygheo4UV+p7o1cmAZ0hbnj7K/uEqo45FVle7aFjLl1qLrbE/gEYTfhYWbOAl9hzMYnfhF1OoLnFm4F6455adG6EXOpnhkfQmmvo0+9vbhlxOll2rraZRYfJlizmZmw7eOarMK4J+pi0yLbqAnHnOxe4UnygROXgx3fiAH9uQb7guSH/IaFSFAay+aD2Fw7J3d/M5FosTHPFhxDfTC6BAMDaVKAay8WLn7+RWKUhGeztRLeSB+QqBzFwTLEjdjSMd6GR4WIqGClEbLboq+SUnvzPCN3WiYGTHomFyG9AvGFIc495/7XdmMCNHg3JW7xoHX8mvmRfq4qzkRtUkNZHVl7xqy3Jsr2JGzqpUdhMGftHo5pDDtQ7BcNBWlRkPfp2F6ek6CJBFFVZHeS5rNyW1FFCqGzNem6kbul3fx4wXj0By6bqYUTUOAGAUdodI/wV+EpSxkoHRMFXX1FDgcyloz8+vz+Ry8M3jG3o3EEE0OHzrMqPTzwPfmBXuLLCIfRZkEURPTrxzxTmK1hNja/A9SPWg2zqZCX03d9Nelhxt3r4UxhVE1KIQPgeoLDrb1ef8Eu0bnDoVmQ8ZUf/IkbzR2oJMxIHYOSE9VtXwGKT+pKdhrYRtChaT/PnxDd8z/zXWl3bz8UhFF8/BTA/XILbg1tsUyHnHpnBGcI5l8B0hQYfuoND8Vr2XFnAuj+K3nsqHzl4MilZ1LryDg+569hxiNWbvNqjqaLEFTK/HhLgWx5cfpll1g/lFkb7Etem6i3ylS1muH4zyxR9/eLe0ndzcEWaO3hjltTIudVDlvyqguszRxDqKjj6XQu0jUTNXQ017+sEygpmRSPFGuNjtOvP74cOGQnqa/lXDApF5eoqLQyL5p3sQK3r/gpNWxz0ugntNqa6fbma5xDlq37I7vOHijKg4xnvu/Vwm/tW5Wlfykuvwh/eAVhAbX8No8vqBNwIYG6wUSxXURjjp/DugVLyJKaWkFGJbwSXkcMY0Ihc/L0iaU0D4Vgqtzl84OOQYy+iWwmDKHOS1rzO3l/NoMnIaKPeiaerH24Z9pBpndQIeUZ1LJBoghBu/taHPX4rThKmtX/1up6xJPH0X9MyncJSq0AAZTQsUfqj325fGyyUb/oNcVfgIavCfa5+3zK0r5jxs5dqq3MKKvHHbym17z1xIE3V0UG6C9aaolZll+5i/DnR1fJlAyoY9hYfJ0JfYYpRm1XnxA4CIir3M3zu5OxCHlRefZVlmm0aaPZ/cQNJoJZaxHyLUuwGFuwscSRgyBd36uVknfZoDIrHusDpALiyxY/1ZdmjT5xeI6eTD33NhWJ85/xFe+TpQw/vDWSlJJLotWiFd1D8Np1blE2QjnqKPssHcBTmrIjBS3Ia3BSOLKoj6ag/9VF0xAhefE2lBUIBYYsQkWpg2/StqazXsUdPdzL+jZGeI1eJOxfcrqfALIg+Z9PR5N2gONYulhtI1YWOE3PwIxsRP52dlrKf6N0PQtwYZpRPk4sYRO2WnIVknUOv9KEvvbVtlO1PizOytWK9lklE5dIslkxKiy/oZRSYXgwPzZKjJYl6geeGspvD3ZvOl5pul3CfTUEheZvYOmU6TK4ZctZTemx40yV4E89BKN5xeGz8G9ixZpJ5qd72UrBQGMJJIPghtbOSF3dwPhwzNtaBVdhfXFZECzm3loVtCE5Udewv780n6ziUvfA6yLC9LmYBJ7++IJAwgRqu1/ZKhNGuvg7YjoUpx7HPeO42eIkDklrp1yj6qsZE82PFJXtAOyDlbUHueiqGppOLNnaY+Kano19UFTXl9VK1ckVFxlDAkPMY90+Q6lEezcaTRyG/VzobGZnrdSBMoyIObBmhiVIXEWx/n4Rtm3a25mAUAlgdDe6ECgxOXT7FD7TaGpM9neoATQaFk+ciFPTKgHpJgg/GhCq3kIQ+BhQylw7J9mBuPb4iHoSKfCdjuRXMp05jAmA0qW2TNMMdZk4yRy7LVgyY1aZiuKhUXQ57FTFEKs5Kjcb5W4cBFfXODSqh3UQvdcXoJwyqHcfSe4kogFcNEOED0NXu2Zhs7Fr5fXc0cIx+niHNnePU35fiWDV6c3xewJC/EH3eHwy6bP6Rq9qz38DGsNtULa+6ylnJHuOaa9wsgcaaYbDoZG/1Bk36VzAu5SsdzJuiDSuKQzWb5r3lG4lHm5tMXW9BE0THJo1WTuDHklMMgDzPgeaV/b+Ij93KILRQpPc7H/39y6ANQ6xswVs2aJqBFtKPhfSUoDyGOBcRJpuS4AiXGsjPkgkj5kmjDdPCL1QTiX2D7jCwCpg7nnoAvAMt0ABpMs7RUgQgRHweqZjDgBhEt2/W68T+de0DYc+MXiG5H4Z4Kbst0VZunxIQgD/LX5ibUZS7WkCEi+zF49xISyBJjG9GZNP8fQ0arKdTcUhUDzlmCE4PTlSTZU58TlkdDLpY/fiI3t/i9kCvH6e5cIFgVhyC/MlkD97OR0kniG/pZ/Ic47tnZHj3eiwYg7sYGRvMR7ptso8ShfzJi8VMB8eegxHeT3Ogan8RUb8+MPLgilGCxZX7FYpneLZ9MFyB87uiYi3G0Rgj2QbHZ5M9KK0rj3dL5bUhAyH8clZNhLzrF0hCGRx6gqNbm1FqOQ7XwgVGH64IsqSaUU/78lGSklBTH5BcLh8kiYlUQimPpyvPJRY95OGeJlLO/y2iaYjhnGN0ACaMDo1ltVZqwv+CC7qkPXXD2MM7u8UcFdhX0sVJWvGqHdfJiNwbS+GqSUw7H9jFNXeU8WyzVjmHmWKlnX/XgcypElMwNUuuExMJFEGVoHAMT+DRSFwv5TijM81/OqaJcbZi0LHneXcbuUnGqBwE/r1gHfM8/sokP5LknRJjvrSLRuliQEnS3D7AZOYJ810PzDpJZDllB6wb7tQJFY0CQy2rTbX+8HLkvArBljaxob6/lFQl63/1ehd+ufdL6uxtQlVKcmM9lfcHiObBm4Vg8wYvhe6UauegXJT8wodpH5WwRUg90zI47NhKlhCXUTKEji93J5wzJ7U7UVfzq/YOel262Dcg5Jgc0OZWlglH5mxG2qgFbyrJxsZJbNb5F/qrMuS8DH7JkPbCelsQV45xKJo3Qfzys3G/A92WNKmZjDomtRQdblSVgov41iTiUhP+Km07RG8zOokv97iz/2BJYHzHBNzBSMwcPIPizKO8N3AinEgZ8cfquNaUfHBbgfjA/Ych4sZ6daCu6UXeMNVHle3dzFBnzRe1fytIbq2Pmb2dOhDM58MhP5G+BCSMPc+dao98iibcofyWP6RiaT727mCEKGkA2wvozRV0da8guaqyG7URN0hhbDsPq2JDlBwkA9z7pXnlQtCM6eceJA4eefkr0CAVoofuGOU7NFrygaCF37VWQOvJKOFwh/NaRSj4uFhZ7scsj5Ec7Qvfq+4lo7PK7f7C34qlkMrycksD6C1APWyMcp/Kuv3YsKa28m5wgVAmEocJlwCWsA0KXTQo1AoJ4Y5LUN4o2SdYvxZXhdBi8u71cXrwiPhUFIjeBerynLSTRSmZXVncGyhDGkftD1CyQckNxiUz41mGuMQcFNrb1o16uxq1WC8X+XeTvpul4eIWngP9/NBM7ER3GC0EWusEMi6bSp2xYQFH0ZOJe5u8ye1rfKqGgiV4WL5pzppOdfIB5EEABrhh1Ty9TS1Ytq9e7O045N6ZbzLRY/pbh50d3o7gz71DBZGnF1gt68zWepMLEQgwoGnO/6/eLFjCmPJIBM3qXnRCBSu8Y8/I0TX0tZo6vL6jyXrDnUrs6kXBAGLPrmnMetCeGS2em1TP/3Tl4RI8GUdgUL5ru2FpiQrxunM0rofevLcnjcZ3se35uBgAtFC74pl2XCBhCg/enIei6d7BVP/W2WCV/H+goO+PqKi/eI996cybA63A2o8y+7TdBJDzFU4kS2fIuNHRp0x+AXEIwyvyuDLBjsPRLUJeUfYaXVcv6EcHD9FacHu2mREFJK2n0Grx/2OLsif1tjpOFv7h5BCcusEl3Y4KYwcGA760Ca2xOWcgLUqGMYPgmw6DtLHCe1dF8iEzXkzed1xXWcJES1p/gKRmoD9u+XPa9f1eG3YzU1SN7rrqdfddYtymX6kRZ+WFctDlZvgPQNaueKC8xO4S5qwycck4aVR+T24fmU0ns9KwzzRGn7nmMIhw6BMTlc7/LFNXgHYl4LaQpIQpWEkspTl2oHkfFO/5p2/qL/+/kbqVBMZxVvfp7dbg25bPfhhXzzWVkq+3PQE/mw9eSdEEP4gR+j4EvT/UmiZY3WTsuLZ57JEQdBNf2ySD06uCOYuq2eAPjk/czRvf3+vOer+XgrpordPZyEv8wBTYHRHr8a0k02k/pLX50sVeT32AKTimL2iz2LE7Nz+qF8VCUB2JHlOc9FclVsbmbETtAd6tlYzs9zWYIy5eQtxrmzEKMg0W4RClthLmzMOdhukz3APKaL/J3nMLl2571itYJRKdV91CAJf7YFgPZht5ftcHtYp0WMGySFa8AQcxqPTNqrcVnhfjSAfX3RHl+fufgBfK/4ybqoU3OX0qyxmZn90Th7SHPxnqEbpPCueQ7ycJnQh9ApyqhJ6D70kiCY78stJSj1gzr3QtFdCBQzDn05NXKtpDp5HpmMYlyRKOC1EvLCGMQNmZxnpgjCODcYVn2lLpcYxSydVN3Nz1Xmif9oOtJ8Zz/ifdTQ1MB+ltJ5KIKZ1cjU0EApGWOPVYcqjAw4+G36zEqrohEu+6mcY6lzTfD43gyU2ydWjUlHVOPqA2Rfhc6Vob4glmuPhQZytcjLbdJR4GfZpm/KFuxcEZQ4NlNoAM3V3s4O17Xy0zx8prb+ijArWqYlRnejG/0cGlWQR90wYT/tGi+GSP4rSlFvLL4cINVnWgAS86W/nBKm1ZkQvtiHI5IeGnljfKu6m/OOvzb5qDKIO08r5w9kAJr1LzXUQTh9N7g1Q+ZMrjcc8tUqpgYOpbUkPRIFf84II4RSeaQ6GmEI1p/YbCZKITmjoYZEuyIQLdiL4bQpI5hGH1+j1BmoyJeJFDt/ZIOQbKa4NNuFE2oDA2NTAgAkH1lERF+qvh9r9njatQ4RNrPbQV53kQk2U7FpGFlDVl2GJ9FlOToJSZpzREi2/OQhAbD1xjQyl4ZRYBTUI3slKjT7qyVwLn58466CgbllqsI7ZT3xQpZirrs0hO/byMR+FKygQvcKhhOXEJsTT3bdSGalESiSXcmIkvnMFKsYnP9GTAl4Em+YR6tmY2hlHdhj1fFWnOzaWvtBhozeVVEA9Kt0v4AsEm2OuYMOfoBHWrW5ULfOHUjUI31HvhCAig0+m5TVf59/HBAQQYcY/8DAy5aI/yk6qP0TrfhITXKZYo/mY0xkIavDkkapjbN0cmpxLEzGWtqqPl2sNk8a/fCdbDp/sIJhnAK/uwVDQQIAU4MkhFLXX0QzDyTFx0bNyfT3CBYkqMYWs1faSlKafx7t12w59MIg3Zzjzd4LTOiXC/BeHshxhXizQcREOZ00cAEAE37MRyDaX+tSe3KU7XDGRC2KbVBelNAQjts9M4gcFhTwuvaD56QUkOWY0w4K1LCxdFjTuHE7KkSBHKZ+ZB4uXrvmGaxO+OduTNoS/Bt7c3aL5dTE9HMGX0E26rgSukpmVbgxIZkg6vpxBWNp5d/LJZQ13fZKUwubeyGNPCkdtaOaQsuWdYVL6AOM1wFMz5NZwyhXTNWr+14GD290aliE0PQm8MmYBZSH1bbBLRexOFvKVD65qDsY5OXhXuOMLg/h/V/dtiNZuKEBzTcQjjEPXaU9fd/V/0ERVWX0Qi50ZhgdHkh58VADIl24ehMgP5n2u/Kdix0rnWGN7Sw78xQEy31RfXtz6QoRYdbH5MQaFe4J/S6utV7ZnOrrG3t0VuYI3GYwCZw6tt9IjtpU0AkYwjlPlsVC709eEyxsm1Datj343xMFtjokMAGacpYY9pNadRqMLeQsnFzXEty290+dmqEeX10ATt40tFiutjQDU4WPApHGPU3jsysyk87WQZQYCblu0cUioiowgsXatMi1AnrBAx3MSG5Xse9c6OOCUj+Bifg5x8DrWFa/HBTw1/yRi5dgt384LFJ3JBCePrSuZNj2Osm6AfHxN1Z4tp5RLskfIw83SD9Pn2hl5QuyBOBjYCjkiR2MOe87pPAPM99EM+ws/cz7nzir237Yq0hhGJw0qmfyWtZFtfVOtuB8nFZDKja6fgo9IZgkpM7jD3/RtNRgc+qZxznrPqyfb144Ej3Zk0zHZ1EbyRQJ+Bvh+42rM+fbQaqVj60s+Qn0PFRKnKk1q+ZRxMGNT+RbSYyS3HLBNfkX0PUpvX2nPrVD66UaUh88CzNkg7JAvBHOwgfj41VYnO/iE0HrcUWL5gBWNwE6leQlTtXFyQi2tz9dxBoKgC8SZi+BzrP68T3x/f28EYpxp3o6v38GGyNKaLnW03p5wAPusf/S5i5SsUqPUGot7Uq34xud9a92qjVm/27wifEZ9W6/qnMfKG42ffcUMK76uBxA7MMz9qtmZVYLsQDrXjuHS/mFVDYUeTi4litIN8FQffcz5RUjMWZRwBozXowfRX168Mrt55CDA9dPn6+2SNhnyZrIBY3XsKIdYTLfIy5qUMHBe+JxDDe/giRmBLjLkfS9vEm5014vvnB6YKPaABVoGL5rwADe9QkdgqCd4Z3nsZkihVyhtJQy/uYYbPzRg6KHRgEWcAdLFecK2+lGTBpsoQ4vW3B3dDkk1N5phSC5rn1dLC9R4UA6zNTwiNdg9zhlZLoFa7JrJZwxyU2FIsAI34AII9px8gniEpYglmg8AXyyuSHZARA+S79cQ3GGPiixHKei+zCq99YcKsg4sb2DWA4gcFrYDH7EpZKxVFe/iTZdxOSARb09yFSkH4naJ1eaeWfpdYzXe1UunwlQ/KfSiaSrdEwijhrbw79XWjlpd6B5qMU7BTZ1sDmwpDBswY48gnvNonLUB5xrwMY2lxafHPfvl39ZiqzybwITSOeN7qMuDf8ZPszov/mW0sj8Sdg0/kjpVBHhMa3sjrGoActhfMRLRYmXV3ucRqHwtTcnciuScQ6F37K58DjX8+GneF/8Vgz0nSKX4q0bw0CIsA8OZn6AcFkkTgjMaGUFwkYpwchxUzaDRbOnnOcnaACa71FDTARQbecyNYbi6+L1636Ocys2c5+PWw5A/RX8sIvV7uUN6pZMLBnN24c7DdP8L09dSu8qxZP/Agw3+UENqxMixZqkdlB0mad+MNOOy55+5en8tyBAP6p+4mAbGW1hkZuEUqHuDYfJbucFeaNHIQlM0Ae0V89OtL1SJIFhIuxOCIMFwoNJT3sJlPkDFtIc733LYBwSZeFi4IQtBY1HgXz5ItSjBeAXLCBZSFMyfZ7K9o/hrgZKlfNpuSM45cRmZB7F6ofNwXu24KzQWqxW2ct1TTGXZJaLh3Zq9rh19ohjmO7iGzEf3rm8rxxaWYGkOVmS207STLts0tO2702kDpQ/VSsSpeZdlEBD101kkCQtOt74uKFrsecxGLHuks6JsY5ysEr6zirZLT0XXpNgnWof2SM+C7HgXDribm2IZVxIIQGX+iaohkNURnLibBH+mh6SXDGxs5GjTxw/mO7Hh7If6/f3pIDhKcxWJqFDyzJiktgUuhn7JtaeF3SV6cLP3aky3se9Atv1Lhu2la9nUsuyPUkqwW2nNdEjXaHmSYk79F5PJ4uhutyZG6FGTq7tXoN5MLXXeyQD8MnuxBRJ2joBEPYteOI/8qpCb8FcE2GjCQkxFQ94gtuYE4FWxhKCbaRKE/MvWpun5BtUR793OgYMozNQZLHqrPnTFmwPB2z13/BTQl6bM7OJLcqyzHHz5M/pa8GCer1A1XqyGshZVCGws3xcfjw4dDukFaZ15PhUO5Mr4OYuq1F9UurtWI3Neu5nElKPST0RHd/q8cqVd4v8FqzKYJFk7tMWNhN2WrTDloYm50PIt7nfqLo2fWhWPfaZkbpdZ0GpQVbm+fxt9xNzSF04uUaHMg2Dq4Wu087ssHAfhO1Pt2jKYl3YLSZWdiX2k7PMY4uOe46QrcROhRGClMoH39SlMrUG77sq4AoX55sC8JZ3w4Azvj0aFLdSl/MvBXP2Q91llaUaKovqvoy1+lpKFNb0PMkkRZu00HqT5Ld5BwJ21nFfyv16+gcXveDgivi1QSnddhoMILPOblji+nYC83U22SOJ/In8RyZyp11HIzYUQW8Y9dWj79N+yzXSjtqRaWuM+QKC4XY68LCO+EYA90t4EEGAFPapdwdjV6EgQyOZfhHm8DMBUydNSRz2DzORdxbWLvA1pJk7k4aChciHp8kWtFAn0H4wreiVK7DMcga9+dgYrzQwMvjDaZBH4VX7HvzCDKqCLA5KIl+de9SChq3Z5CuWUe6prJkK+GAOVk3ieLom+tSPs9AGbyo9h5x2cRh3QpDuCCZEVPjIkMwvsvoYxsfu0xXhENo/UctYDAI3A5QxvrW03dcb7ZB5z76rwgV5Z+jmUOYyWyd1ynnUqnDQxuwO4WJz8b7+u3wZXukVFAb7zNkNtK5vLbp3axq9qM7K/NSF5jpjy1y8DkH2duB08KIjzt3u2GaH6pB3BfnwjCHrBuxOEssAHP/7jjdDTUUTiRK/10itED5MUbxNi7Dcb3TTU7fSKJGAJ+XwcwjLnCnpO44c8Ro95FFXPmYv0AIpx3ODB7qVT4ZWk4ax0k5cr7ZGDlKoJfiCyPnCCS0ONErvDoTMNNCPfmfdu9zaPEG35+141iumda82WiBbW/G7kRBmMPpYkh8bUwDoTK2ty/KsmMru0cSXHnsBtXkM7Fpjk4YGqxe8eS2/a4Y/NAG+fNBKlMatCtxpoyrTgKCBCK65SGI0niMw7bkCHwiVP+9s7l1yyWplbXPfc5d4nfQsWb7TGbURkeuHnzGRKwwBWLuX63L0Kh21CylJLe3Gm+mqKcqkDkvbZIhDZsDfvo5CnmsuWqiF9dt1CS77+Euwlv9ERC8SyuFS5oiJ0wyCIOCPR76Aam9YvEuD4BMLv1ePDrQeswSOhtwacvMT+jCio1wdSTsVdDhil9bRW3ZzvE8EFKFpzmFFKi+w/KXhO+2vOnz/v/bn8BXBoJ3k8LIap3b/IIdEERSqxcbpI1QuYKxTTLMPOFvE8Q31hY4w8iNCdajymJuH22Pg2cFyHBMAPRfSK2CU/NdAB8UaOKrkSOiiR7KtCu7z59Cp9I394wyHyWbK3dqBObp6sbhX2jmzwxT2sWmE4L81rMKnHez+YWNotwZTnONcCbs/QuM28ZxU/JsxwitTP/cV6RIJchb4N47hXR943VU178FjwIPSnMbwEQAV282SOFbH5Aiu7wzVrm3YJ9vwvzArfJ3HMf8zViZRnosmAthfLmU7jPF3RPcpj5Xz3a6sBHymHd5cS3X6inyHzO22lVKUa2XkYwk9tJ7gNi1Ko0h8kaF6Qi3yr4LXs13rzZ8JxTfQxq00aY0rtSK0QfkOWCYMSW0qaCaRZK6Fkq1CYE/x25cHHwERA6DWW8NgBFZJR5zq6Nkj7meMsFqit3uIbYICVn4LZbg6CXgU7tnbwSUzvkS5pRSAl3eZ37UDuAfsRnPVvaar6SqLM+jI3HyfeXIQoUKx/8hYGszdhTTRAWwNwFFTyRcB/HfaPNc5JuwxTTQeaeTLw9yQPjbq2oHwG9rCO22QafLZpgPn1FWoUnO5EWt2iD7zLbD+HiA9B0U2n/RyBtp8rM+oiZK/JDp6ktB7UFjwGWWKaiHZiGBbTsPUtaloZMtrVU4PnfgbM9mllq8Xw1tyJZ2Tcf7Q9IscPJZSRbrp29MbuKd0yKuuGVeniJZGkMTcX2hOfoR4rbNPPuLi0FrlDVdmQreVvbqRa9GERxMNeaYCITKAV0EeyCEJNMhUtsaeHCpgD3xPdyqQ58YEAQVUcN7SBYWfDoz900Q4dEW9TO6OisPKYhZ7+eCo6/P7KD4jbCDq+XAX+ZwKt+ISr3k16UEQo42sjc/x5kxoyz6FPEnNFgtCA2zNS/BgqxiL9YmZfRd7EX+r64WFmzNfWmNlw/V/UxfziezC/E/KJko6OA8CBKa5eZwUMuOHEltSJvWguJg2twKR9o91mBCpOz6ww7yVpkNfaPAFLpBUoKSAIFUGp4HreTmqtPP6RIsVNfeKik2IxnYyjVcmMjt3j1RDAXLpswEJRg9Q2vTDF7UC5ryGP9O6Mlp+q8jpTw5ElWU5NhKLBs0zXIwF2+rwzimZ8xOw8KnE5pkpwqRWKaAc1pZ/oXjL0MXYKwxGQYCZy4ryXnDqalspRVx1YamjhQyo8Ywv4TEkN/WZ2xPFdvIZu4VeGKd+tfD5wJ63cdv3MO9E47I5pu7ifwb6+2a3MvNqlf2gqfu3oOuxtxVite5x4GEmY57l+2qYJbySYsEaEeYB5yu972Buk4GWYNYO9nTpklpkRKmvhJdSziVg9R/UyvXai6bzvlLl/kv0eRNwviZAHM62DoAPAgsXm8t2pRPr9uQoqjKCsuXIt0+3UoubRYsxeVX5prrRbuitMT3FWxIaYsEBbqd8Ku7bVuGf4tz7IqSf2DyKNiRFSKG8uLj30Z9YFBE/K3HkE5GkR67xbWzaVUDL8tdgtyh359OTuNCGfImBOh2wotoIYDkLn3yQOflQrxPlj2kldsjqv3/wmYEW9yAnhUYr9aDcZJGB6PTo9qdXGO803eOTDcGjOcIM/I79D8bg4m7l9MD7fAx+xrNvhKdLdEAo5/tanR9jGbhgq0Sb8oAxz74AB6ulmQPRPbz1pg//EGkNxPwWPChSgh4kGIy0jcU86HD9sTqVadRRefsKLlDK2yvf3Is95P+dMthgkUmrFbCXiSSkwnvY/9qBWZfcsbXHNitxe0DQV4rd2C4ooYfjDcDLLuHF0u0wSyzw99JN6FMmXCQGHgEhWtUBidBG/rEl5vn1Hu9X8Efnw3Youbedf7fawna1Ogih3gAErW03MYf3ZiuaKR+tn/n+OBSXtPbk+un6/1CyYvnXTiOeGNQTqJWlc/rJE1aHDtilouUTt+mf6r490RRzJB4kl+vZWGrdAu2RwnbveatWoG2LJuBLUjaJgPm3QSwbH3vOTK7iOx4qGSLjeEZZHVmEpxmZ0oXDHpM5hWS3YRxnvlVlHNX2RsAew1jPR6rU1+/0vfp+2WDwzYF6EofOGmPHaznxX2nTP9QxB6n92Il+wyi+GDvWhFrdJcsFl9JMNG8X0dtKMh1RyQzhRk12CXPH9Yp6W/dJYlHIyw85SAEUIapr+vcZafZ6McRD64gkC0lyBtF65nc7TJOnhTl+P4VjKJF/TodxCWnMGMpSgLRU56ovI1Wz6dbxIa7c7WFLoO+kXoPLkUjk5yTTt33BL+2RXEsUEhlFPAe6/RoOJ0x7gfeodnC0jdxbd1SA1wze05BOGBAqdx6ID9LHlo2caAaJ5XZrP54NKJNu6uPVO8s0bLztnJm+nTreWWOMamuy1W+am0jY0Xt6JcudaSG39r7YcuO7YLeN0RwN0YYoILzDLnzGI3jPtZuYVe+b/C+Z9QOaCM1wP39DQLxwX1OZTJ8fsp7aU13jDe/AugCNGyn9PMlWKeWtOQelgGM7WtUzs9Hkv9JIRetpokHgbN/8PV1TKWNuNyTRPnPveUrS98+OCCbtCL3nJ1iRr3KGyNJz2ztDzgYxkl2neiopJPsEvjWjXKR2mgEoh98kqN9dBHq84ccpVYTZw9tLfkcmhsJMhUFZvUE1rPoFjdPELIcG11PI0u2pgq3ZQHOBJTNJhm/EvpHKVD1h2cyT0CJ8A6zQz7zjT7xw4tuhekU7GqmUrDWXXWZWbc9hPP1WP2KhSuD+Fb2hqu3jWwd7T1FUraQFdSQJd58HXiESgmrPEVOQ2IeVjeNhDnFSNjcMoiC+VO0XG4enzt/xbSiuuDPpB5giwxua3GSnsSrRjITpKx51Rz6o1zkZnEfXaugiz7rOVoianMUqCwvdYSvGK1M/6OK73YwE9IaoUbuQ4pFJTa3HPTk9S3/TrQjfybQft64362vx3MaKoQNXdWugWPrb1Eo1ly/gkp5bZTATFSsOwubLwgSX4hCvr6Ctmz/792AW5tk0LQzsq6lxRYtPyEPx7s3a9pfMUumJZsdpbJeOKK01FVL0dFiKzAtPoiIhjdItWlH3BRqC+uRVCNDdMHfwJfU7JYKQlmYEiY3uOJfrkYKeuxOVIPw1wh7qljJK4zEoCTZBV5Ba+6kIZb71WN2sMR4DV/oal4cFtBmgiRxKFndQLKyvmP6P36V07iuj+B9ewk2p7vWrmJk5sV5HS1P6TgmYfcMt44LwN0Rm07ihMIfFtVwKETel4sS17L74HB+ZdLAm8FUUrBQs/OBe/2XeJS0ThDGOjsIdWE3XKMa6EqeUCLB2f80F1cmbMIBnsADscOLSRh/RcjydmTPOdUq+yTnOzbhwRuRUoH0Yp27htgjaQrkE4n8PWyZHE+3nHM/ncrv+ACSEDzwFe73AJU1EmsEmynAoWELxaBr1wX6tZxlf269le3Kv3JgQAlKoJua4Fe123u3dt42zoCwOTNCkwSurOGBHc98gI95J6zG3s2Vo7m3SuBCRkvXZw9WG/HbTr11HWkMiBn+eSq32ryBUgbmlDXS74qAeidVDHJIB1ik6OAbX47l36BRjRjnhjVoeN8F0TBYyfbxtakmqO2ICJZmf3clAwNESUhXO3y8bHKa7IU2tGnXs4/KDmrf5FfCO5tIql2FNfD/droiX8es4PvwX8LlwCb5pLuu6yq3TpXDfDPIt1yQm3cpAiO1wC0E9dbHf9Svner2DxWm9gG3R2xrRfg8ERvyPhtom8dPQUUfyKfTpGgJGlhaNbcQQT2qv3THcCup9ofMwxTSUWzB8krsFxsBEiXf8ucqTP/QJvEES7cKzImUwTK3UAOBXa1QoypjOb0zKHIh+9r2J1779HpzCRj3FzjBb/ebkRPxmcWY5ZEXc94ukwtlqFnw/9f3bSUCY2OS4k5NcdSYYvfT9EUlFP+6cccG2xNr6rbkfR7JkgTCGci7v5U+ABitirdeohBS3EdSh2a5fj5NTJSkAWITCGsIyRTlf6rrfIjOHvLcXaX0XU/t/6jS2W+6BOkUcuAexacFLQpMPuWiduv8CKFxVbXk93i0qU1QD98UhFnGGgJpTVtHLEL9bfM7Q+xnTxueUflNWeDgegGtbxFvAoeaVgeZRXp4LQCyNegtPbRSUINlufsWL71a0oi9POIxDVq12r+ZqtvkvgAhFaUraYcdyd4VvM8R4DEgGtDaSnPnYJZh+F3vErYwD37T8JumbsfwGlsUmseKEPTo1EYLfGLhCqPH39I1e5fXmICENK1CY0Xh9Acx4DabNS7GVVuHnJNn+B1NAPGt+DmFjNM9sup8IjUVFf/RbfrX+ECl+rnAEvS/gs5sUAhc3W/h7e8u+Bk2xMjKgKZ5A/c+U0eNH+3avIuqyiukQAfwSA1u/t1cDRKcZSku8T7ErDDibGeiAH2TkUCDJUuBWFgjtqOV+NzH7C/RbSXEZNjBPPBLwEaUOA+HpyWT1IUF+vLFsDJM1nFsa1CBNLR0xA+Z5jZI+7iELsTaB0Zu0PoKiT6aN+QA/eDF4JEwKDu3viqhVLDCi8XqCHkUb3gKNLQ/wd5z0hda0sH8Y0/ekPbK8oVXgGO/CCKlWMIiTYtstNnYrgkRYb1UmnyqVhgrzyocy/1s3x8NVaJTBmFLq+n/wWp4M80sdwlMUItY0APhPKd1p7A07baBB06M4fvXEnyXgsuHxCR9pGFrue98IuTLZ8qnFUw/kowhDevK9jEYTtp9Z5QPpl+3XPlXGkshuvgdCw9uzqdu6A2xrUZvyNMCQgsNFmvFMRo1970L1VSAaKLPDTXy94uqxIM/6Jwxf2oGKLS5kEDH8asw6zbE7BYk+9LKvsHswxS+b620PaqbwsZnX/kzLeYjqpVC+I4IzSt2ZHHWg1iPj+5u97NT1b06MXwYMYUm8mozFRvwKbNp4WLZlUMUTBprY8fHPcvoriPGzYCnzXNpTfv22qRf/QGPlFZgRnpU0jdGtARMwm1xydouKROeXYfp1S4G4xbgjboBbYipxKHkwJrQmDN3roCt7aNj+p5vs/9SqM8McxMi2Un+0b7qDyEd9BdT1pUnavcPW6u/Ao/ZclpRXQbSfy1lSACYNkL3Wz29c5rSGn1+VZtKxL/CnXISjzG2/XApKYQlpe7lwNR9TAWdlwzEbiU+6I//EEJDiKgd+IFpQZsqC5j+g9qW8h/ajFW11wL0c/xCI0xtwHs6klWMsZePd6isQPUiaj9VqRcAh+4Wd2P3/f6TbRMzLHGWXUtit1304nakHK3V+2lA0HklVijf2+J9iRJa0p7x3UmxhNSdCemNGBqf5g0KSWIkNBxy6aZR4O7nwX8DDx7mLsIxIDHGArT81EXa3ReHekze5exY5xpvC27rzieZ5fkMIa6zV2wUyGIsX3HkDPyNt6KsxRh8samzMPR3UPDjKcGUW5rQowd5BfKxWCqD63mMMGWbsvdiYLUsucnkfla612uTQ7DmzOEwVV2HqgMudoufkMyx/pslEkQ+cginnSwKQgiozIQ5jpWz8xb/1TERnPCTLKbOMtL4MyZ/rFucCNs8629cgcM9Hy1ANHBet7aXuDVInZeveQXChiFj3YuNEsAPVr1aybrRe4DNsDo9qjKKDsMZDEWFyGBbxvof1UIuoN9Gmz/KmsWRyZPWgsIRBUW5Ea1li/F2J9pve0UV8lShZrpg/EpxKa2R1rGueBE9TTs84aSAl9aIiXhU8O0nhJKP5EIAdKXy7/RTKhRD8DdyMmzjMFhSnL5E4FkcTg9Dz67o+YUyJ1+Jxx+wv41unSosYD+Ud9FrM9KJbiZdu9sX5nDoKhactFBLjMIwHYx7mTnKBp1xvPydpoIuvwbe0H9dLTEoJSPnu4v2VIF+T8U9b0nusSUgdxca3U8d+QwQqhwXeqPqVIiiTCXcmOBoBSMY3GEiaI3WKTnccVlMk26Z78mi+P0bwpCjGrj09yEVoK5Tbzkir8NXSc+pgcHxUI3Mf1DaCzLrhaEy/9cVjkiq0hhuoNLX9gBdS+vT3SZdhBdbzHZaLcGMt+E3QEp4nd+2OX3iWtta7va3zbNFQBn+9HUfkhnH4OcQmtglWBTNb+elWEH/aDvbIppc01M5G6t1HvLtemxGxmtIvRGg2hH5/lcU4lZwF4EIlunyARKv8MJVIEmpAs5y+FOcQtI1omFaE3tMFJ6p33Cmc6wFQZBbM2J8l1HGGliwnTFytPPUf3BYlFT2vOvGsdmxlfe2Sw1CsCo7GDDvAFkrkVATywXTvcb2XlPgFN5Ktj7uCtLFt26wgk0H7OGzjDQHytZ3EN+sfq5Jh7YyVs17JnsFS78RcG7GvzRRmya2XHABkS42NzlKbu1MVIZP77tQRO8Yu/Ypncj9E5yUdfon1zzJO0QkVwba0/vp2gfIR30ZSEr9LacVX35b6Skz8R0uWCyI90E1SYOb2LpKzedCF8uWudPPZ0L94UbLBTXboVn96qdr/cXHzGHhxuMxZCdrHD3eowIwXH51dGn8ZHDGTdRVWvnqdpAGlLaFbRwlkBZG+Gy1K0rWF/ItSXGz4doeA79BGuCb2OgKTouK6nu8XvJSolJFyILR9knMhA09KUtK8HBsEji1Jg4tvPmb4Jsq1P9flMavNsXH5SIdcCihYgfqQ5QDxkrbHkgq4wjHx1HK+K8Jd1VSNRaOyGMkpJq6AuLkUCOJddie5v8o5jCM+Q8Qs4NgjnjhmvA6u7vaYOZSfOSZ0zWKW/4U732CGFliQYJr/OcICF0g0qGqShBTqVCiAkaHpXKlZg7QHASSJ5mvs20JnggcM+QJCYmhtnHfCIn/ZSxoPotCDlM8W2GotzhdcRglWNp2nf11jQLOVk5JpkR7+LVV1EYVIq51xgbbTn3wKfD2sEdiaE7gzR60WMHYNCGSX1zm4MN4Fv4ZSGdgX4OkFA2y42v/Gx+hVQbKTtRe3ndGkFszin6WEyyKf33goyWdPyBE0Pi2WsBWQXKhpgAFx40+T1kcGxFk/AIN/6ADiHtuhmRtqlzAg5sEUV1FJG8f9uaXhmnuVsy4dxoORJEAtAS04tgIDdNu6qY3NPPa3sRmVOzRDA24hJLZkY8DroTeVXm4ncX5l3d+ULZxJtNUHCp4GxHTodxkWUhNgG4x7937R0bW8y+1JVYhvkTNzJgHeayda8k3NcJPuAuEvPfuhtmwogM19KxBUsL7LZUyTN4AATttJfRd9+QGtxcTStv874Bats34dqFLsTqyO46HDgYFMappSIAdH+86Mby9mmN7ImetHC6QvVO6OtRViptH8K6et8CavpNCM1dEx8u5dTK00/Ic+hUXqhkbOEebDAAhKyM4GWw2dNsGf1Ylcp6v9gpjuQDkHPdR4LEjGd8DvwzNBs13Y3gaCktpvLmo3K2/G01sERepZBqbMzDm8SY2ElFYOA/ZQ3jhXQDUdU0j1LRY3zXTgkQ+3gbnabSciWEJur+VtnotKVbrk6aueZJOevNDgHlMkcfblP0VmN6X7Atos2yDF1vUoG6hKMFGM0ku87b+5ueOrkWX5qN14xP7CTEySIwUePMJr6RMw1Uk1v4Whrj2ols5CpCsE6QGolyToIx+/Z0GAi4pVBEUo2TQakSJHgmognVFtiGHyAhnqUN7Ap/vVl2Gp7cfl2mw8X3w2vP+noxguvzqmb7Bphjc2kKT7y0IbfDatkPIJkzaeX+MMYRFMlKqfNG2FoAODQcnPgeNMvYjQfg23b9T/WqFTujYH7D/p7ceekRWAr8azXfLU61c2qAk5xHjMbydCypSCgHDQICxCeQe0AqjpjHUe84cNckL0Y1xEZJA0HYOm4MAryjq4wM7jvSxkigDgz/2VzJV33wPSy7szuiBzAOBY04MekblWIrAWY82H9eQONyM9JNHiKpn0iGXsTmiz1PurmAhzN32C2JOA1efPDRAyxVVRggDSrZJYLPx4Mhp0AU4f3gzyHzHNw9pDu4dDdrCuXQPit2hu+9VQvuJWzomW0RzqzRU3WlB55/AzzGnPlyGw2bnCVj1EIbRF5fE1z79LjiPoDz17YiIOfwzQk6M9hcIQQoPtPWSW4HC7fjdjNlCKDUWpTYTZTWMJpCfYS9H17jlrL3shQH1WM83q78gAFmyf3zU6lI4Od0XQzVhbUfNvwI8IVR0ZW6AF7lHOimXZbDc9msj8Zl0QWHnBqiGDNj90PTpT0Mzdw6r0ci/xFKvHgVWf0iDZhRYXOJDQ4WOue+fuTTFL007mHadflmde+azi/dsO2oPBos8Y1ok+6nBfM8/x6nmnfAu4TIreM1/hwsvCQqDfWrri2ta1fb055WmxEXYJoOeGnr7XQJiZK0GblJG4O0tNRWk0klYsmQx2DpTOR1qnljxmX1THDWNXDzha3doKX/N/yLjr2y7ECMkYcYfDArhRhUkNJhb3Asi1eEMSIpiFdXgv2Te6YsFCxcH4fZHnCM6LaNbcmDIm9CVlUQXJBdUQbuKkgXW27iGIAW48yCwWR+bI1giwiwnl4w4BvTBxubc/utYeG78s9SYvBAlwmd3ndVtRIBODZ82e22HLycPNgRxZKPrxO7t3qAiY1nf4Z1b+i2DaffCrrS3joR9W1mP8Cgihe2nDORyhPtR6Jz+HdtVv/e5RmDrT8u9IIjaoXP2gNbTt/6p5dgpPgbAgWidl4eT/kbdrZ4pNFwtjyuuHMPc0uXU0nX02FRBsVlWxfP9V66/JYXYdInZ6MkccKm6mg9/pIvVo5OVUzNZq1B3Gt6vNOJXGMcCPfsgRdszY+Wh4O/VIRGq/509ZSNTdhJoUo3ggU2QxKZXDE6Za7/ojpt/xQRjeMhb+meS7ury5EWPjrhHCfW9YJyHzDQIGOKexUmGQE/XAXd5MLYwEG+UfCniXhesuyq+MEpBKh2tk9TIUtBn95QfYih+s01UMfIW5BHwil0yMzjv9dQdqiVcZWkzkEecQGMIvcyA3v8MR+fbVLjFKbHk5NanmbwY+x5vOCQw+vTG2WxF7SgoQxvGEoybIcASfrUswhdNn2B3xaL1WjwZvP3r8sG1lI+eMNDe/j0yldxhIF0+JWu37/7Q+WlCxH8F+OCRfRul9t4lD1Fijyp7KZ6Uso6rzfCHEg446nZ3spYJfq6x98XsGO/K6z89fV2Rqx04XdJY+tAaC4sD+Cxyu7SkBhCBB5lhOl/SGyM3PhgkHXvO7YszwwQ2RsPMnLbJgNKYsJgAYPfio9TGpBRXCQ5a8ODPc9y/TyfKVGmfe2erAh9OL72Fn0nFqVU2rcQI3ih1x+/cuNlgD1zUli7m/+LPfqWMrZ/nu8Dl5FW6S0l5HoDUlccdE6EKPI4BovqTu+UdhXqvXU4lGz+eqUtOG1+Evf3hKkfIZpOUhcTHFOgNF8+9Bh5wrjwqSaL72RLK/obRhqvO8bksskITGEAWBysOBdTbtB/6J/wQwPfRa+54EvQCJECfOIva+3+s284g4ENVfLXTRvKh4KjgsYgqamGh3aQ+ia/TAT8l57OX+4HNYuFQY8ARjYiEIJez/M6WytOpsO+9+rbnzOPMkQhICZeqKGtSliFW7p41aQ+7dV3XWuVTz4x1dlvbQC7o+F7ZVUMsMoDY4jG/aIarBXSK6nK5vP7TtCCMaziq9dKOHjXcwc5WH0ZHJ4tqhyXLS6bzVey2LE0hqtxdnJaWiItSYSCr6YdCQ+qvbgLBCedLppQXxH0PnjXeKSBTKplwACRZbPOHzr9caMYmR5jxOUqG6Wm1DLEtXGDPlbwZmRbJ8b3ePtikySrFzx6rcMUOPoXKA0kiwyFo7q/9kpsfmPkrsXDaADxe9gq2p4hhmQQp/0hyt9vTkS3XAzafs8Jm6O4AgwAh9sVvu+TOAsfiSl0sMQPTZh1gd0SscPNLZkaUv3HJTIzjmCBYR8eNNg+j6/GDDLsFoN8EoPqONpDLjW+ALdP1TnqQEGLYzag2SmqtV4yU6lC19U7SRepuTPg6sstG39fhAN6ZBidWiWW//CbxM7LdXQ9Ai5eoarvUTiRBxLbkqeXnGcwRHE7TWwOuBcVuTEFgJgzCA+LLCR6GT1cSR/1Exy3xg6G91BUz7csM/RPJn1hkKFaD1vxVI5Kab9Erq7TVWt2UE8XnFDmIsT1qDG1w4i2w9cx4YPZbTCQuNs45XdfeHQCmCjBHdQAdQg4r6Z2ljCiAAqSoM6G0GR45ifbQfkbab8uSTsn4nXlhp8GHnaIhyM/w2FVdz1n/Qq7CZP1eiNmYKp7Ryq2eg+5vBvCg1I8tS5v6zvXo6jPDgTtJYEFjheMxgJ2rJDAgnrPy4JH2EmBBj6Ho7dNyYVAoJqtOIGDw0X/ZSevT9aBW9KquMO1H659L9pp3ImidmZg9gajaBvs3mh9HECinV7EbxFTvOu74TPU2DV3MnYqCziKZe5ARwG+74vP5rseShCvuTDhJL4Avsqj9d3zwKdEFkFO24tfk7wEmXFiA/6KRQQJ0yQiGikeSbVfbo+9Yw6ySYRouhJDYHGJ2+y6GU58RqTHTuAJGChvM1mTrNt7vN0CVRl38Ua60xowBYFQEzmsBzB1QaRbTrsizqP2B83Rih/wMx4zEPfCf6yhVNivluL5kt+L8QBhY7+n3zySA/ksybvtq+aMm6O3nTl8MwFNKiym0C9C2hnJ7nlgFzdcjr57Fx9N8aDPLQK7IlFzPLtyKoWRX/RsmLQvurIvcuN/f2//EmyGXnZiFiwXgMyJhLVuZ35dmCTSL6ZtJ2dPfdXdk51Pu3boHtfHXFSx2HSEBMJfj2ojtR2Z9V40pTMKZvhXesjGiDAzOgg1SC8xxeRjtW7LchPe/BV/nINMFlDJcnVnG7YCzi0u1owsdDX27zt3+Izwx9UaE8cPQrs+NkU3h1zZekU/n3D+d77Iu1r0PEBc9+8J8sutPvQbrcvdiZ3roiP3cOSEOGcTPMKD4u+b8aMTo0poKFJheqjCfrCdCLmjc7b+wCDNswTjVOKU2JfiI+bJWQux5ZI86zEJsk0LuIZibUvWLEOpIWqqiIP3iekL73O6aBEHotI+FTdJAEKXD0aClI78i4rysBpwsBeeGTzoFohPpHvLS6ni2b0HlJtOFIU44YSpeCcW48JL+Rcmnsh7e+hkU/dVVG07C5pvmR6zkIdfby2NWG9lIyMFkVFKZG8Goy+xyk+/vpXgU5NmVR8J9ioAloUWmUgWyc27xvjtB9AlofzqqWa5Kj1Rpsmds/z2upje+AdiXwvu4IhagRKhTFMfTXNOdHxzZKAu7EhLVibdkjBLdAui1z0COrXjZHi9qTzuDSRxgnQYK18n2uwRBOkCfz7NnCQsx2mE60VtQ/GGB5floc9NRworp+Qw0R0ux+XhXf3siUCOW0cYXAmxwiKEu9QDpjlX1AIlS6FYlhkJ3LqHaEn24XyfiW49UxmaRmJTK5nm5WkFIImJENnikXWaVDC3SFf2Gi6uLSMEooQPhRGwNunP0/nW08xcPqJBluGRbTvlK1KLKXVd14H/yHwXA9UAkESwSWwQb8rX0Gw6WKF8RDonYqcFPCkd8N7vjyXnC5HbdS1qYAtNG3IlC2DkV2ftfFNVPm4jCS9i3X4Ar43MrVZfuc6xiYGJz/LFrCmkd4D6fJD7nxOIRZ73lmhNec5AA/juHvKeYD4TgPY+9lgvmlCLpuzlcyACvVuzZY7lrINhYUc14dDE0BavVE7nfMFB8erkBmGJhr2SLea51NdrKRitwwDwqofT3qkLMWfzUF3kiObGqM9gkgV231vHwx1IjWPSZW/cjrzA+c7djA+TT0pM/m758us4JnWxhs1Z+917EW5B7bEsYMSW+LncLlgAsj18U2AxDZZrNDBerD0LeOLwIAIM1GL/CbE1An4ZYblKakMOHF8Kn/Djq1XQlHUYs3N5PIiEY4kxW4x6HIi1qU7LFaZpEteNU0fY9X0MGVZ02lsRqJ4+8JqG4rW9qXUUoDvaY0O+4ilXy5wYsqvYJQ0IKtcHJwVlwYO8+ov9gl4PnLzY50Nt2YsDZDDGUiwpAvFYbLQgo6MNOvjUicdCFpBOgcN4LjWwiaNNuKoXtd79tkWyW0G2Wmvumg4FdOzn0Nqr/0C1A5hnoMUkTt833E/BjE9v60Uekoak403RQPzvFKfNAHx83e0tBggmNz4K00yzz0vmBWVavxC6wHtOjdX7MvOAPKknCbXadL/Z/uknyfV1xM2DOXwY1/t2Zc3NEGh2m/o6dPI7Zc5+BNcr+aTgDrgrj90mDt+FcWznPjbgau6X479A2Yh7jlX2DUyW54BIJcJQ79UMR4WjZvrZmVJ07k56gmtfm+3hzgx2HAJsaI9EnyXQig3IhUnu8kjl4VCcQgL35a9fsx+7AA8J4AlKfkYC9nhXeDu1+7bkZAfuxdjMPHuni1fsa82k9T77CrLJSUqfamsT4ayJuPbmeWJ5dbkXHz/JtAYg0vBwQLFZYYsck1TmJaAISLoWIwIlCr3dxIEaTKHjcTbQpPgkd4gXWzN5mv8e4onrQXG9hX8StaS/73zsBiDARzPlTccxwVJIN1H5L5g5KfwZlqasAGbLiSfryfs4fv51Z04q21jjbq7Dc0IN1zepsKJ9GGiRRoZ5ZjKezdlCS6GLyDItcFM84gj9nOSqyyYeGySwhDGgqUWOsVWPW//JJenq91ZCJGhGXMcJlB340tCJUJbNzkmHL2mkP+Yr2vVAxMdi/sEAUQDa5m2ePcsqwqRXMHt9DDLDEYWIckkuRsNNnlDT2TToibcuZ9EGnHbBHt0uWGL8RhszU+cTc7K7SDhRZfF+hcYPxCBHGQ4BpfcbzCO0SKSLXE4iuWN74Z4tdqMFSWeDZ4o9XGQfRzbEjXGiR2Rexxm9tSyGG4164F1Sf42f+OYtmbTA0Or+YF0OibnU/frWIq5+kcm9iFW3khoe4gsLm0XcBqotSdWDMVI/j0NMFdPr05rwnWvqEChD5pKMxviX7iPriVznH7vYSlhG0OW2cVvd3bz1Rc5ZB8Sb8fc5ECKi3JjEOYWY4is+JjUTh/XT9+9IPEUFayFC8IlF/X1hUAHUFSJFaTn4H3CcbbS2sOYDFTdENezwKJ74J38edfkjMOn3roUPyTwPD5wf3ib6kFCj26gTbqo+tQtiLnLMEktt7hd97Gw+rorWMdDqWtDtb30lz7WhToYiAaqXF5Y1mz0KH11mCwT/c1ObxGwdhA/TyfAxqUFOOy4zKtyauY2KpWojG2QY0Pf+w2o2FjI37alOY05FduaONvZbNYcA18hQnTTAVUKLPTt2dTOkL3x4TfvqxMLfSjfbJn9bHma29kkWDK9hPAkod4UBYqnToICqZh9lWQ1rIL9SuzXZix3kiyDBoQC1hbpNWpN6pJz2BULqknry9A/FiamV9kuqWTaNkfpojqTzSMJi95tCpse+WPKvKKXXlAIMyyqJpXU0/4soLuQOZJqAaIbKI4JAVJsLhWSPkttrr3Fjf4FG1ghKFln8ppwOqMXxSCYmwSTB1AMNY7nFO2o4agaTkzU/0cbbUIoOhbwi+5J4IKGzo+k6Cel0wVyXYpejOx/gD2cxyJ4d63p18aPRDiT5LUBLQVJzwV8cnI0tbZBEwu+IF3KlQCQr1XfSqutW7kr6juhnXRUlR1va8Xo2Ij0xf+UyqWlz0vzWZbMCRuYYNpDQFl+u61wLDeQsZn6ImN/JZRPy5OGy67sDg52JQC9k0GGILiY12N4x1SDlT22+IgSKqXAUkOaaCgoMK93CKLglwDk/kMOxawaW9rfmyQ/DTlX0RK/OW80bim5aLfmRmyaRPqIcwph63UeSYLdn+DRUonQpltpota7GIFLoCUQcdSrtdgCtFi6j/UqTMCtaOjMw7tRxNWk00rwmAlauE2uD591KdPE0UMXcwdSF6zQFXNDvudirkhASeKaV5T8SY3KNIrkV1tz36Qw8qPlkd5ME481qs4tdlk6oxyB8/bMKP54DauXz2dCD09XYGZ+qW71XGzudj4jid9reio2LISZ8kNNFKKckekXzgcfaBJ3dvpeEZbwFO/ro21k1C9HQA0BfbWdPr3pP9jDAdWC9Y3cFUeTmdeN/R1gk2FC0wz+6/4ndVG02AzqJiaMbioMYcC+NRqD3+rVgyUQCMyF/8MD6JalRHwWuFP4WtazOBNoPhmcxwmPSWEns2twHaSUxqPdtAoKbMxGxH4wE7BvLGUVMA9goV+XZyG5dDEwvXy6d3EgOihLVcR9/cJa9ZCHZja7C8hP0leqOu2uoJ85zSpT68m3keWpi7xSqcKsGtqxd/jwijN6lsf3Xj2nfzx4SO+jDKRSTvBfNZd1+mkzLX2GJY+0m/kcPZWmije6hlV/m38VD2n0IxLtMWx2sGk+Xc0sbwBByddzpbQ2zTuoz1vqtdy+rkwurkW2mBSRS2Sz/IFlSK3XKRtEujkL/hMqE49sIrkXCf+yFSayiQBd3BXV/C2v5OmXxn0+NuWQGt2Tar8SSLEZ9Fop1LwvHs7gnoo/jCHFTsohQRqYJoOk6R0F53Nk0Xi+ZPhJ0sfoxuDppkfegc6wBmlDpZ3jarUnsPiYAPAi2Y4P70DTmVJ0zJRHdJC9dIjBteUQUGvBd1C0pZSPdaDWA2nN7D7DnKyJQkFmagZH5v8ic87ZtbJeXdxQqILUnlmKfCtfO9Gr6NAtsxp/O3PTvYSzSgslzkjONX8+1gy/MfHLqgIc+1ufdJv63nYAkPEkL+vbje+m4Ru9iRC4nhCofZ7u/wlwGg708wDNV4YQaYHqp0FAyrPNgam5m9fJVuKMYDhPUwnFnasZUbm/jA/gehvZkjVt4hHCj5YhPQZOvurSndvYOh9/DncJ02JlinUIEzl9upeVmNhrC1x/L4s9fHSv3Iwhle/rnphXq95ZvREhAhlPizvRMEJtHNDYRUKM7+jhkdi9i7S2rqV8Bwh7DRKGNx0cEgI7PCzG/tDUzCXxducwYEkcOED0tmoS3eU9Cbu8Lw5gbgtsXcrQckJwXVu8dJZfORCKdlRYfXgOKeRMvFKuNxBImkUCmre69+HJQGL58i9uzTWAKIQCAwP5t3Gct0ZleMzt58TLWr+fIAENBPdoA5H2YTjbXn7jBxdp7FixJ/dKiZ+HnsrHS7qCRIDbDxrM9u8chgaSe9/66gH+SsVpuoQzASIKHGTUDhp0ehRzRvKlkejjp5kW8L4zHWURmpFoQlyo1ZB06h+1L/A92nQomo6QTDkMca8sLiOV8+DPlvM//QVI4o6gALoGKE9Ql13gIkV7UCK22gJ/uZhGhRmlPXfWLA65pfIV+cyyHpeqUPZInhQan1ciCf9gfCHJgVrjXqqV+kqPBrnLFqzA6CHRLM6T+9fmP4xaoJ1E4OcciHm1Mew/mSAzaMHrxEGUfi2Qwjm4m/6TRprWLE/YISCKrqgvCh6kqTgdzvFdR39ewBvqOufGgz7s+ZGlkwcCiMTv9kl3vx06XOtSc1k0qAUYWyNBf0rjLcUHGq4GJVSgxB7/K2b3Xdy2QCGdqf/Fi6B23b3qIb+9tYzuCN8qe+yb9zWMUNqnQJN9RZNAzQhqka9kodzZhqI015ON5HKp/PE8LWjpz41HWJq+7aEN7WTSoN0MNQVy+6qALx+Fkguo4hjAse2lkpd19te//CjSO2hCZFqB+qfGjd0U5i6oYJcKMw6uP+d/uC7UYybVp3FY+361ZLjhtjXh+eO0Hav/f1pAQaW7cfqepU6MPnKHQw1ChOV/HP3E8Qh6XKEcy8udFZhPoV9hCbX1GBtnvZu9WsOrTzSoHc7SDlXTISReus3s8UzWMMrbc1wqUlhOABa7DPD9FKbPA1J06tNExG0E2/jaol4suoSEG80GSgjzOAAshFX3jTjp2eabaapeIVjDYLmqkViKqKBFxAxH047RSiq5xWu+scZHdvvvz6wAQifkoFq6oOGf4TFi3riI2Pqp2h6w6wFx7EZG9qFmcLwK9MHpVj+Asonx2YEmwbZNBBh5cF4SMWbRgTP02SNiCzwLkdxfxNXANXW/v6y8Di2x9RfUak8KfiOzYSiESoOMPuGg3SqS5YAddB7cRVHDdC0dXfj6+etpfaiWvMMcla7wT+G5z+gLS0yxrDayDSawp5TAlrwq1+vzm4BQdw8jcH7gAbiOsQsOod55AjHZN8OOw1dB11pyjQIxPu35/3HRo7vMY5gjwDTebbIsi+LaHlSr479I8hz0MyquKYBHj4RXzFsLmM099xaP4wdQlbo6qU5MNQ21pl1q4GBkCTElZfzYoO4kcuoBBC+L5kzqZRIuXlqi5wJO7PqG6TdUVwbK7j73Nu+igt0ZQc3ZCi3Abuc+RB+ux471R0ysLCRDgJf+ju8G2zeEnlhgc/SMPc//mFGfE759lfRaVbFlB6fy6mfGFfYffqBsU0nAN8wzVhcmk+4o1DLxV+f7SVbdyYy6hBoiwcUFp1Jz+1E20vrg4taqIZjGeNnO8O7HS/Jo7A5YofLDZHdPeEgqLUXjpGwQKccHtbO6H2UielVyH1WbfuZVRt5vdWoR/DwIk2z2A/QInMda+BujTE8AATqco4VqKRGsqfbAGe/OnIGVtQRzsopVSTVMccxLf16ujYtNMua0ljPBBmGaN8rJbC3G4x3VouvkTPfEy85cAyBE+jjEQ1LoTbtpPikzE9OsteuyO3/WVoFZXo2uSkQ5tkEGB2PcFhz5Q9LgbUrBroj6PWR/WGjy43c1R4WSbuV2HXNzhwZTkYD77cyQYFOTVShiaRN78o14WiQqF2RsH+7oDlwf1rJIiKMW0AWNWyP6G7p0bnU6pXMbeaKnickf2qQbJgJiVcX4FVqU2+Fkpxw9GJ7WHttdWmgDBZ25x5D6nNGNjRFhg7nzDzFSbxIVREKcVCUdXQ4j0FxC/XCjFXSgrMiJ+D1ghD3zpqEP6lFO/vSm7cVTKbtkfkBQhEbv4KQTl8iOgRTWSB97LqNkT4jJue/bnBazgkRwDuy3KPue0tiaKMQqDrw0Y9IN0iW+7iVaR8xbe76B2abTKdG6ctH27L/IOyql4apUxYBhtm9DR/zvItxXPDlj4DgjvXLYXMLTKlPws+MknnyTUGU5WxC8IGrIdD9zrM+kt5lgP7RmIbLTJcaK0zwq5kNWn+QI25WH+70KF+vVK4CE5f8l9BtBREOhPzf2LnXOASLrWMwM4QkBRVewiOJO6JCOgAZu0VOH6qBxdjVQ5qHO3DN9nnLhtwneTCOaj3UhehKt8iHz45281QNIEtnuvLF7Zvvb/ryA4y7WeTMHodkeHCdLEcls5nfykri65aNsfGMO0YBm7rw51SlQ6kq3dnbHTI7dSpws4gdFNbbrjp/UYwHfesY8CabEvrT1X7mToLSIHUWQEHfbzL07mgD7rxjx3G5m6GxKXIwFSS+RZ/QNsEoMADprw+FxmpthIPIVShMOeI8XRNvjI1hYr+91qTuu3sJnPtkpFLvphwKCwIpl5AYhSbemcOJ9CZD+i/Ixf8VjuuFFYjoTLo7/d+Mc5JzAXytOfBTJsZy4rvuICkce/vcPC2Msbt6Dl5Nseeqs4bgIzwO4Fjst82JscVE1RFbwkCg+CY9QWjdyLLX5qBiWdstxNcW/o4H+YUuljJrSHDsS/KuymwlV5nZwnIQL8yWaiA7WuEacBIXesSxSSTl56JbI+D3Pj77Afta7C6R9t8dzXMMg1vF6aKOPuEjFjTCldHTbXLC76WDqz222n6CqNJe5qKNEtJyIo3OLNCCdsHnriBMORNsOsvsEH7Y4/LkqaHhhFAew2DLWkXtUR6X73x5WC4UcVZekf436BAoZyu/qMy/IojaYvjqMhk2XQBwG31rXJu5iRYBkA+r1rbulOi1MQ3wYCI75yThyQCma2mFAzK8/O/fzw9932d28AdgpfbNVVrdGMiOoIAmnG5wFoE5CmaMly/elgj0LdCAFPFsVbc0/VmWt0EcVi3WMblKWD1lFO5n8JkA2QUIdQ5ZMH9awOpuc5NrVo7znxgS/ktWaIVJVW92LHzOqcBkem0A/Tqa5Kxnhn8aewc0MZQs3m8s2LDFarEQY9dkjkm38brJgXZoJFo/0YG+Ds+s4UGmvpaz3Ktji2N+yo5aVpZzdwZ2K8pryyMeLaa+uCP/yKOp3blnos+QyJ3Qi2uIoBmO1Nh5+J6v35eQoc1PaZyo5QYqb7BoDsHZTrs67+p5NChgIdtnMP/rDWgJlH5vzBvtzMhIkGy9P4JZtox8pRJgGPlbh/KacLepIVizkzMdIPI3wi9uCM1cTTWaC0TZYbdwTolwdYsW7rWSwGXpSjrd3384LPy811VbFMNKU/naV6fsO2t3IoMbNhFx5nLBO2U36idnRMzgByJG+IMsdJy4Wksj2JCAPSmM7VXQKNBnZy7JgKT8XMYh3zk2pJXhSwgjD/iRIKVwKiOpc2FQhOyqc4eMnL1SzTT8q5dtcNeLoZen3KZl94W3Rfq5m07BV6Bxi8Mac9QXMXTV9ZL10N+pgal+K7ASHVJquL/A3SbYS773ApmIyKv4VBrQkidvtsKTKnU6IU+EulU5/7JvPtwVfk7OgNgj7pPvIydmIgiwgI33LV1Up3FdAmp958StumZNP7RB4ithoinlfuxeSIPQGPQU3phyyJLw5xM8rxI3LHJeRzTBGhW8pQcmq0FEJ1mJyYkeu0Mjj0D7L/kTeyITFOV2N0vDXZt7tPzyq5CnSGInEe8r4R9M+A8ugMFayMSd/Xoidek5Iz0CcINgBNpzPxBE17uAHL0l/2P2PDwwbGXPaVJFESjlwoS3KfFVBzhuM8qEer9d49C5bwuz2z2fGQQiGLXF8VjB0A+s9y2XLFevESlTvmjGmjh0FicyF8eIzLqYMILDq3sMzEpgtPqfh/BYVVrqFGI7YCl9sLBVpU+TUHnpnQYTrWUsjwzKkDfzwxm35hFJgbEgfn3MT2Xpd5XUyBE6ts7IaEsZM/Xk7dRM5Ht1FnzDOlSto5vM8XfNGpUNyBeWcjmxkQ9MtGcceXCS9MH/AbvR1zMH58dzlhvKRCFXXjpoXcV5Vwfem8CsJQnpHGyjRGzN2rmCPeuZQwgeAvDhW4VaRsG4TtYPWl/SiHevlE6R9POWVASUBziKMBW2QmoG8/YwuNvzJYIqskxGiWTz/YFbAKsebfY65fw4oZ50Nz3Wjz61/iflQTD/Rb/wde17/oyYEO3RMEV2zczYtCwtcbArMRst3UqcXo+THpdFLyvgALzQiMWURT1a0DwXb/4PJ0sqOpQrOxAwXeVI4n/JZyeCri1bkMCcbsdiRo2UL7qlwQuNjgudpDkQOfXwnbw6rcuNLsaYB5JzLJNGsu0YimjOOo0LdD9v3FJXCz2qXhtu9+pCkRB7rmVSeJjMowK5PLk5GWbqOexmSRrwDrUOxv9fDO82D0OEkT9Dlz8TrBw6wD7Ojsoq3pJz39psJ9+FAJ50699MRLCMmotqLHqmLcbNm5kFEmU4XIsSOmyH3y7V40kqSVZx+3w9wYux+yaEC1UhC6u+zIRggBMavAP1QPKy8OETrVbFh9eCtfFI7lBBJDyNvvdWBEa4eWRlFgx1EOX44pxBBM5A4/Iy0Q2N4zM3m7FwkRJTYGmjMWnj2MaEXxZi/2PGI+xMmSjebaOitGcxs9oX/L9l6tGO9Q1ecMlAAXOF+IX26HqNoUPMRozFnm/JD8lbZ4BEBmQDoUw/QAvIUB10FPpRH2G9RV5Cce72aQc3jZfitGWEHK4+c41Kot6XATDvKU4tzixzSru6KkkGIlbJDvqzaaeve1lKYdQKoMrg+vBpLZjubyF1neqRVZB9j+X/ZbZ0Khf7vaQ99n/cv7LWLK7ZNcPJb3nbpS4d3Ut3ukMPF2Db11xne88qHrekcb94WT1a557OLfrXJ1AX9WUYrGNyXaJM+D0SntkIoczH9HNMRQ2HwWCb7uCouVxekWK6vqdRSjwW8wAX1PvbDpzLu8c9kD45zDEdpzUzeGWaoGWOYfia1WrU1Ilf7Hta2vceY7F9dVeji1X/Vx32e+kmpnKWd0b3u/DyGKwhEkj9441M6UzpBQ2QlnGWBpmfXJzKPoQrk2OEe3H5Zqj3IuQ6omUJ1dDtrjYFatmvPP4U3Dj1Dyj4oqwSkGkKaEYJ86cpaC+aJW9YzwoieqmqKE1Gvags768e2a8lOzwCZ2PJwR3nM4zV5rt5H9Y4lAOCymm6Ky6fyEEpxct22d55vRzi5/ksWc9uC7PMLwJGteAulGIGtOlwzucAX9NcRNNh63Ngr2lkEASzMvoqUVlJCujQXFXhBK1QMIutPo9KQMWYiyDH6r/aupjm7Fm4BZy23MjHgrdEzVCplRdCm+aDQ/E5c8/kao02y7ecv9Jbf1UHN3n5XVcc7Drqz6GRtWSY+SxIcHLfJ71Sdwk4aDkoakl094a6ybHcr3fF9eQRZ4/wBKdsoCvaVRo+tLXT/Tw6B5EjduZHxLMeTk4SlvgG4dq2mFiUJn5NrqWqETjjSdAVCf0DTs0n8N9LQfK/gi7lNi5yiyDcmYaMSBcW42uyYehqHCj4HqhjW6mQeTzyoeWBVumu87mCw2X1kB7Xt76LEW2hUzNoqZBZgjfBy0JmMBgKPu6IaN0IiNgdFkA3xCDhiY1QMLVUbMg5+//POqd+N+cDb4JahCJAgx8v5HBcHk60nH9dB2TyoL1qsN3ai/6Sr7Vw64JIU66To5WkytNXDlm3cwb41mw1ODSddMinnv7pmg87S8oC2CwKAix+QNe4ZJyVc8rYvv0/RsHip3oamzo8cw3Nfd2goYblj34NqIDeSAxS3SIUXcs7ZdEl5nTgiJgr65yNq485M4PpqEHuqEKey1fjHvKF2JprLIsFTKTav2OSudx0Z+ztrazX+uRI8Stq+BP58LvdjMHjUHzrp2R9g3kcqxtdFVh/EIFzytaeGoNGZSfEDVIcwk+B5nWCdJI0c69U/976gdqeOLDc0oUFwst1ZCA1kfWBD6Kp3Bjb+v+uZstgz3yTaa53n3IhBHqaMCabpj1W/It/k773aq1CWssg/cfTyUKq0b+FL+OKZibkNZwO1Ybh3OsvfyS99OG9m6aiFv4aD5qGlFzULJYSoEs+GwnsMga6B6iGq5gWkXsI8XuvYGksni5mFno+hOPKj2630sryZAoYAuDdS4upWwMM8TmEiHMBvxpQ1OMrqXTZhc8vOdc5vCuoXKGiiJOssm6T095/r5ZhIdh0S7hrhOtCR2RAbTtWdxOZdY8k8U2rb1HilI0Kn9CkeSUWmA5FQUTvLgLKbYQXvTGrgRFMEfWvcs9yjmu1hPK+bYluJh3QDJ48UMNzUZDpk3NS8NHiWXMZtG5/UXxosDB8objyme6KZj7hWVQ+ypRelGMxCyqdEhEqvcJqt0SL7doxXGu0r74S63zQZ4HGMY3dLGIMccLzpJjx7madrv28jclVDqcb3pDhb0PeIFFMMFXV4xY843mGZ85VOM2gXfJdFtcPvAgcWSNM09Du9YVfhwfESAUSmg8QaYRnFIMAD5c/i+gtHqgxCAYuEl8ufQe6fvd4msTOxu1lMNOlVrp+FVYw7wSv0uqYd+5Qf6b3Wy5GEcXzv9Ay4fnlHPU6a7D4BlgEcR54DSLZayJGvF280b3GAQp/uKOmkbbfG8LJnqSRDgVAT1jW2Nlk93AjUviDi6yhQT4epGnDWCyz2yHKTBURbvsIJ3EwbWcSzD2iyZryIZz/ANg5IkCkk1eZITF1t0dkFxz3EIfrrk8xr5mkfvYAwES13sROWiFSNkKaT8F25enJOC3hx5T5NVsYok6dcgwRUjHGk8/lKXMLRlPf+VwP/zbFAOkbqawTiLq7Okm+sjL9vhWTEf7mXr2GQM9bTckK8y2adJzJ/+2q9Xk6Y+pWlBPL5bc2s2HIqREJRNxrr/EYLryGd2tnRWPEl7eR4rBWum1meKmBXyfanCM1gg6cvhMUewmj1DEgbbaQ7iJcLnuLP5S2ehrq9N0WtYZ36RPWwaFPorKsMGJVy7wMSfsty2b8jeSLhIUlo6Cc+JCQi4fqvABwYGfnRElNdPG9+v/HutIbfd0Vda6WFfIkUERgG/69nIHMcikPyd6owZEUysJynx/PnhPAdpAesQCl3oFcdyK4EH3eDyy91+02NzwKRI9jSUH16J6biUJDIaN0W7kv4KOzFb+xxo2MzaGIEib719SBx5G1+/j9YFnHE0oMZ489cMk3KN+nBvutecHCwPPAguEVpsa6sNXsrKIpvPQamFhCul772dEH9sOWssaOh51sx2xjHuMTyxaMWFzY52Ah29c/9boLtl3O5re4eVjUQuKnaVA6F+D+OiCddBPCBLNkwfUeQ43pvKm/KjZxqmKCurOB1/Sj4wAK+Ph958HcD5mAXMUROLfwEbI1wtFlSieP7IeF8MzmAeAGMsAJdzlwr4/yT7Obi/AADbQxtx8eK8lNOqvnGYgZ4xRGDsXNP+pRxPAXrOWj6nJXwes0tN0xLVekQY9FmyAos2rMVdZKCjFANq4loSkjy/DCOJ9asG9bqgB5uVljhfV5kCHV2GjrzuU6GXP7YrJCsI2B4hHK0j6CIaKxeyFsNeIH9zBn4vEK/ReAhJ/vszbGKIYInIn8Mei1294LuiiIXdXvnqMRQuyVWUrDnCe1DmSgu3HtmZpP+COGX8y9d0K/06KEgebJaNdl5EDEsd5lvhNs3SovnUm+mowOD1wA0XuNOzrTc4Lg88YTiTuWXi24BE0Lc2GecahGGCE8L3blmXPzZkN4rvCa6xLzGdGV1paQ4IryT6+WIjD3lj0hvO7vgQuV4r+aiTXOMRGNlAJP5NFbu1QLicMn+xcLxc7oaLOiznkopuUKsrGoGSWZZpF60zHyWs8A0cDg/qkFEKMlM6bv8LxiiD3rwu+jy1ZVY7wGIsWz6+tg6kjcDkfMMoROy5GjiNUjT4Tmf+oHwPDM/J2EfeUwcpyS3CSFHRB0AI3zCz6XMzaNp4ZRQZIEoGhOLKoZf1LaINeJ1J2Gs4e+0LZobv2PR735wsqDj0A5Vpv3X1eGVbje9eQH7sJWIdzLZdFQ8XVnrhI+tZ03KUuechPjxrVqiM7GStkI60QlCzjkeDLZCatrAY+MoXg/DW0VCzI4VOkoT2iioWGUdvbn6nXRHlVTMq4j/L/cRrIoSYxC3KbhZEVTGuErU0+ihNDSgGYU8f2G/i/B/e7FO1MjH4lrHvE7dTyvtafNixcwsbwv1yrS8o47DNPAMyDKRW78eZjHp9taWOaY3iqVfSPwod2ppqLbebDa6ZQbvkWwQdPNetF2HwM4+0qYIYNUFSCZNDvLOxASwxnE52yFcj9Q8M6B9xnDhOBAKBQrtuYl7uMu0ng9FO6XVCptzMl873mHzWhX9UhKBOviES7zXCfzGXngW/2otktdYizTPArgdEmOQfhV3+jcNusgoY7HWWAi+Re8jd+C0nTwUFVjBfAgj5ANtVTopaoB5fQRyPQBrtmWG4BtkXnc0eLO1UKQg4gQNyGKRxw5Z1aV6zJK70iSkKYapkCKjHC9wzL5/ZKQG/9LgSFpUKWf9yltd9ntqegYJTS45QFuLf72LeuBEe7C/1rTjOSko9yPxGPaQZb1nuZLRomecGMYsgByh+SO17GKBmPaLsYa64e0N0uttcQuqHKQLMag6SsiKq2p7kjS8kk+UMMcPROt1GjJDGjmrSyBW7NmikzjNAf20JfQDpf4EYve1k6K4JxbmoWUWsklcKslLtji0A4eAtPYtqo0aX+8H0NmVqtgKbOIHrfWjMmYlIjRONrWo4KjCRhrVfiCb39KX8hlDcVAFpape+P39y/uL1YUcAVgI+H7b+TICZbtZigfvOrneEkIBmUCUZuxJ9tPJEEWkCizSUJfQr6DlbRP9IElZttldEHbRMja27/AHvnylU2fbCMWYl8hA6Z4ONAuQ7ARrM3n+GERskf32gYlAOMgWM/KlkkoyNtR+lbJQxbyIJ+RThAERNCU4wOpV1GwNi97QuLjPryd/NWX/gWdw4xA+Q+b4nnpXABhaN8LeQ+YMrhQwIlRImlQYs8tN0GqfevIEy0TLUqs81yyyYCjSgZdZ5jWHhgiqYXXBhNzyf5hmt9SK0y9l69IixvXEiB8j5DUCt5DAeLYvhLIRGCEnTBHl7ksB4O1PTL/Ats7S4xltq0CKjtglu+da+M8ZALfwgEw6+ucbEMiyNBAim8STPCUcwmd2IIdjqpOjKP6VK8YL8eSR2hZ2eY2aq6z5RGnWwqFnuAqqAUP+X7mP2TrQXL5Kxxn/Lb/5qrGKmZEji5iqAdpQkl4NbhraJyrCSb2JkAZIyNrFHEpE0J1CV4OQ7EtfAP7GdpFg7bPbGIwfOT4waff83JsUZU/On3Pp0m8YWr+Vhu3tLMR5SnSV+mCMUndjX3IFHRlolVhFzElSpu0bTi63IiU4OXPBXlIN+oTHXHaegLJB5NFYjDH+dWgSCsvGunRRpVzqmWT+tfKHHlGwYONIZfnq/4GEWo5TgNPxVFk1TS00SM3jIlpQ4hglFp80KvA2bREojuidw/zsPJe74MV9ylHLVXx7DvS0E0QmgW7aMuyXPkYmAfUsfFYR92Jy7tsSC6OixGCZ2QZzVq5gSvxzt+DgaN4T180Ri26Rxf/6VWy5e0NYls6G61tDZO+jeXUzAfvSvP+61pz/sccGYUNEB6ZBQXG9XEG0yVHoEmtFYNBr+bA/nG1X+7C1uTjxBI1AiKDpm7YuBTQT/P2PkMfKA78Ygy/b15LNZfID6kY6g/fmlt6djwWa3fxA6J4LjKlrMXk7u7fsoPDaR9K3K4nwWFcKjKmkOMTnaBbIv6VKRCVcLOrJp8jUSJeiHzI4Tl1O+4QEcTEYZwKLam/5QLP+1pkCYpOzthYeqODnli5wayXrmtPJSIsBrtsoR3bAMXi48FmumQP5rjBJ6swI1gXzqNtC/f3CHHL9LF1B3JHdBj/5KNDk5hmJo07Qgebjn9Oj19yK90s7Eidxr38iGENiRZaoYl0npfow6jN7EeiCckDk3gr7VkkkuPTn4L+K+nHauQc3ihazmR9OYby2HqDL9rjdG1nSL4+qhn3nbt+rFHRA3lSjWH3N5phes64ViwLRQWgrACiliBZqiuBsNBkWGb7yI9hwKgk+5CpAYzuslGRYYYWW0Cec+eMCqOEViRoCZ0tk/VYuGfBgl8TVg/IkA3YGBUeLX7K0zsqT1bT5yGM7niuhzchzs9Da6HWP190g9+OHdZPqXa6UsngXqvvNPzn/K26dei2nD12TMCkK9UfZfE3blOFfSTq/BB2e1k+PfuGbbuucPuCiZKYbUEAbbqJylg2HUPFlKvK6l2Du8NYUK49zw38juK0+4pk6pJCgXQt0ehRrXwrfVrFrdpfVUJCu5fGZhEY1zsSvXzTUYqvrAcLWHf4jO3wYqucw7AC9hqKwBNiJSKLO3Pcxfn/OkX4A62pquoA5HTqCGG4HjberJiZvWp9QDoclhmFEwrElNQnmpsKCQbBOsKVG6hqwJrKF7rqquTUt3mqxluCnNsvkMEGkp+BVPpw5GgI1Up1hVhYaaAUOEC0ngeIuKb3xHeaQJQZiGNhh1Ke/LiGxrsWfyzjXfmatobTZ+LMp/DOFru1ELRHQvlB+E7UsMKhi7y7LtJfwIhCaxGoEFySYz0LIdeG6oOI/MbhLCTWNdqt0ABqobxmGIpudCc3kFYVjlmi3NQQ+E7izCUov1Hepc73a5bjKAskz9VTQHhy7c8VPbJx0Yd02dyjVv8yeOeqiNMkZl8KNH2mGQqPQrVwd9xXRdGwrqyHnxose2YOzIKNzxvgon5du5RNe7fz/869dJuq4w/rch1Gjy9ESYb26M7I7bAL9AyhhYqjhmb2KZP6GMkBwDttcMHb6TpHa4sPexB8vc+zd8AEvpIcZkmHaIP1R4cDl/E9LmItS7Lpij4G1cXCIr9ZzkK+SucaXLSqn7CwUztBKMbKLV6ZuEEqYiNMsyDKxQm/dwkPAO22nMPVTL9eMIeaplOmanMe4kf4WmWK2sver8RVyuogGguf9jd64EdtF/VuWrrFnlzKvlh0zkFOrlcCSwSFrLZ4Jidj+dn8bpOk7Cbt1qpunfiaymy6EWKxnF8R9Lqfi9kEIkHUVysUzT8Oq8wC1Hv1g3ahaBN0vXnTa/6bRPleNlJT/xj5SuK6t5CRvkeR6ELKTfSuvfLga3Lovrkr8RmOtKnWKKO7nUA1Vw6lPX3o3APzsedVWgb8Xq5WmcTWiMkEEnorrzTxV5Wv9Ayd+VrI9YeZKJhMNqsP3xoVOYRzUzIdeQcLB+9DHe7VPMnDIaJSN1XEukWZyPnptcd0t/oqYZFoORVeg99ajztgG77o/vbm4pnwDikw6yPYY+54WFtbsSjiO56vOSXsunW8e/d2y4HchKFO8rlbpXngZM0Cl3umg7JXYffvlWmbxW+8nuQXyhXC6Z20sWn/Evk2GFm4/IDn99uXGkVQ85UrpfgSfZzJCQzN0umN/Xthk8qG2NgVQZt8TmDas7aeXT9zfxORksS5L+zNEYbvXbuGUFjL2iydkLq89xUTw8rBtLsHGuQcexxIEqxAkpcqT8WSVCGmqaBnx/zWfmJXzyHI5mfmIUV0h3DIiitFtpW4q7YtY3JnvZE5he9l5Y6Udssgkpjb5ub5geA7x/zA9IeYq8bN32f9eKyZHTZ6uPojR1DDyM6t1fMFZLNTfaMy85Ercy1PTv5SVrQkDPBOceK+V2x/WKNsmACQ+w/VQ3r4kahXTUpIeCCx8mE0aIEV4xm9rRAQgIRWzybg9HWrYjDN4x2Qeaqhp4kXJIROePj+AIvyQ4krQuOUVYXMMJvHfNVdoTA4W+BLgbQd4flcMeVebRnufcP2PMRjgb1ipbOrdz27yPUR+z3acohPPTmqmAV1I+YLc2Q+BuV4HKbvDo40T2Xw+dIHBQ5CNKCnPI23jZaUXsVt5sXYMfCr8NUNUBB0mHEpi1/6bc53M8HVu9B0CQaxj44pOPIlEMGf6lmW/3Z/5UJddQUvJpzFU6kgn0rGDJT6sR6CpL6fg4e3h6XtsuNy5LKU9vPSpq4sCCYwb/51OhtQb7HHOdNgVKBFBEr/RkxI/Az+mlPg3UQJpi+On7muvYfbTnP4RFjPuB7P3AxfdQYH0ZiB4orzq9esuJsx0Sy+hmGP8Obd1RgOhRBZbAlzgpXo6EP6qE6eu6SENwFLnQCzIOeXKAN6E1qJMxYOJBK2qJYYesSFFbQTOlSMTIsVEyhxvZUOU1HRiIJ98F9MeDKiuaIYFY+HHw5aMi8XtgegWMTqVXCreWsMYTm4z7mZ8SQddyOTJ9BB9zF7nhV9CB630+lZkKI6c11cxRhMjqbA+N8WJPCGjGPYpMo90gE2tzcGIcSgBksUVZoJRM9iWn7HbzW0nMtCKK++9nZQmpwH1DmHV6q1wTeySUztZihcVmRAFvZZaybIjKfAad51u57CfdgRNhtSosoJ/MJHNN5YdnbSiYa9BYWj0B1UvP4zIp/AsIB6ptRquS38E0lLxILW0luyCzGHQjDqerzTAIqLfCDBAFN0irOCWjXjPrEC4O2ESekfy2RiA9fxH5j624icpbHBbcr1/qV4DmyQ5RksAASHYYdOiOYExxJa2nx/pz5lDWow1sszWiG+cNJJZTpbYTtKfODdP3zbNL+N98G3EcVUoydFYvXLARHvhlZoDFAHSwL1ZdwdJZUOxvkyyMoCPQtXW/5bJG/87ZnuehgN01QuGHEwb4F7JtxTxqEGfmkzz9NRMh0g+xQlwfXEA1nJAK7kB7lD4FfOgzVR6rhDTY9fgUXJJGW5RhZMFFicTkRqv6xRZTVReouefBQkQhj9A0sbGMLL+6HMiCjjc8OIHn/Vhhn8V38UJUC0P7T3LSOWHis4fvdvXsVxJgQ4RUzcNDemkl9A3+DUBjoGHDMbyyO7brauXIHIXxpMT3B3sT7wzWZraDjX0LAtfjcDqY9Gf1YECRGqrYgA/Aw2L9owgFq+nU319Fs/RB+HVWAbeEgIgsGsxODaedJoahYNYQuEw9QEeRTXhW7kaizGoWy2lK7ROKLk5Ex49fx1BdVklgFYId3P957zWE92YeHxDsLJQCuBvkdyNFC5GNoVzL011DkGRGavLXQt08YPA3I3yx1eZFU+UQCwwnI9NpBKgsHAwlMTC9/+0z7azbtE/zWWmf90KAzIyYWv09xGguDKmmRTaHxMrTboetmU6L4kbKg9kXZu+sm8Jefs827DpuRKOkBAaXAv68Q1DKdA+BTAUOKC6axCHRqUxhfk69Ak6ib8Q9uyq8GZMokzLj6BcNTFxmplYD3s1I5qtKY+tFCaRXU32OaSts14Wi4ClrB8L7PSp+IG4B5lI21AzcL8IsBAABVT0hblPOOEFRzuc8GycCW6qnW+lM0BPOywMX4hNncoUdSnfhvXw/f3iTPTEAsfJeMtfu4xNGy2cV/N4pxKfwA1ttHtJvtQN8vlhv1vZ8UXRy/Y6dI0MJht0f4X4vfQqMQnx/SzavsU0s1K9CpD8iwo6IRY43haOiZFnCSgHl3ARvGRLB+zJwURpJTdf72isBermFEJheVFZbD82UT+MN7OrmG39IdDyEgdMPiDh402sga4Hz1g4hZZU3298+MlMkhscb5+zkVzG3+MzYP8RJsMME3DVGYDjyuI1K0tSCh7ZQ7AqEEmm6Vxor21YXtp+XG9pwiqXJhzsh6bbLMSVLQucUzSEnzd8XAZ/jmW+O1Wa2dOf8etrk/s0LiYsYlMza7PnIwuVsglfQtdWdmh2nYiZFuTENNf10FKuqV9uKBOVrOuQp/xP2Al8YP3KF3rcs4pbb08Cj97BTEo2v7GC9JSjYjV3l131ciwkyadzoSPv4wcYsJucCKWeBj0jULZFBygaG/tPCHxZCDTD/mkrZ9dRV2nUhlnbG/by5G7A+GEHyzakKm3Z7U5Xk0fCM2NRgZfRLtTkCmG6deGtof5TJIvlDhMmQBP1BNLsnsKVNly0X1tKKeD5PEkSDlpz+M2IrRuwyw87lcxM5jWNRHBIBUBcPR9X4Z2ki9hjfJqaG+sqQhJ8Az5C1mscuxnEU2q3U5HeL4OhxIDFAxE3IiH85EvuD84ePaZmvfF6hVX4kdKr+8gVBZ1gEWB/+JJF0OLHQXfPx4/ULZV8JfaLfZ5bfk1n8Ug9IawQ4QSCteFEqv+JaTDsbkivAqO0XMPGlnmcAJsSFQkscSM/jNiaZmZWgjCr3QquwzpDtBrmaDR6AUR++4x+CQMgGfq6kpPd++noLFupsLbDzegHCNx57cQNpcc/DSIz7HEBgtIrMhMvK+l3j8a1YDneYC253LzU67/QrvlSyB0jDGUV8SDcGKuf9KqcvHeW99gos5m3qlvD3/Ft0jwd+Z6TFHz+S72esdmATOxPMBwm6SRtrwTWiF6BsoN5yPEJ33u5c03JJ5V7n8Tl3D0etFOL9toL8pVmwWOUQjwrQv0FLvIFjmIrrqGpIQjhWOLHikNxb1G+f4QNGbzWBtL4DXD2pOKTh4LBjmML4I+79Y92EwpAEER2mS/biY6aYrbiJBZB+xDbzmKXDA+QCO+So+TcXnKOSLepIB6VMOguSE8x3S0TaMTAKZ7X51nvhXU5lwULcIvmpdEfd0ymc+o5Kit1pRpNxO8SchA7cV+ldaRUcpXCob+ICiGPzhAU2+IucGghyTGBLrrqJElQ+OUopU+g4+4a9KyZ7UTW5fAbGox2f3EkMA718X6kPSBFLxyqe6eW25QEJaXLtFpi2pY0pjVgJrfghzmKdwTNxTzU9MhHRAg41SPRfao2G2Tnof38LeQP8fNQ/JciLYg1puj7q3T/pNjhGFtkJfQDWDZjCBs7GweNvwugSK+z5w8rxuwicNKIqOs4iL7c0AdTNwfU362KuzeLF5eIgAy8QRazN5aOcJekXdNx0oFxLZG02S2Zejny4O1U+7Bb4CHrHALx4mvz+pWeDCK3VcjIi54RF0YHl6I/CvT3fFha3c3JosY1aTkY/yA4l1DIQajhktOuBYjO53mudGfP92TqXhO0c969KIEdod4H7ZSG7arXj1NXO/Njw+lHAvEJYdnp+sFrGR5biCpKf9yZS3dbWs1joEUAy2OkEdiYZ0MoHT4fX9NaJn2Nfm3OWQFfydOORh35eIAi3/ghT7SR6R2bnMNmi6Fgzoujiz1gLpIXqK6jp4MmJgAQbnapiCyl30olxt+qxh3NThf3dO7E56l2sSBOEAYNTiysimCVSN4/GzTpFqEZBwGuANIyOF1tcubIloc6nMxzSO8aVb/oJrrFih6KleU1KPalYCTE5gkKCPQ2asHwZm8xrydP4S4Qv6mWwI2h8n4FvbfrdsEtBoI4pcz+waf6IRywgNgaHovmxzMZcnhMgUz3yPNeJ9YF65YD3R0m77wgqhgZsl+U/h3lKf3b6exO7SJzBHSB1XCFgxTh1dldXGsaNx+L6h/T28Egg6bz1wPXj74EhuIAr+7qcOSCAehjDE3EiuDhISsNgJM4itPEzXIxBa4iDiIw5l+uhIneBb4/g2HdJ+V9XBJrSz5U+NjiBDTC1bqSI5aZ4mLsm+GR7njcvWyvsYgSDypp+lGv0kbYd+yNF+cUnC2agRTMNW5Hpc+PQVRy+rhq1BhTcI3mVvTUP2djq9SAi4+AeRTKCR0wS+8Rw7MfYXwYR4EM4j9ENm7Toov0rzktrdXx+bkcpLtTidI/LSFcNwsp9kTxS3X8SmDVqD7qduI81HNUGr6IkYz1qzw8UgYCKYUPQlk5CvI6ZA2JJHvpKfI/2VZHihAHYFgrr+0yQco22OJlmBtsf/EzvElZNCDCTsFulW3s7POkl9fMnOOVrK78T240k44f0vJvXaesTfiWMHDlUlmGiMyey61gYZSMXk8TU7Pa8faHNboYKn7wtbAjXT23q7PIf2Gp6ikobjpEhPS7t3UzxXP3cF6pvhYIqWw8wCRl8TzGfJqOWBk5iWUAye6IMhHgxtKQSHnQ8qo1DUpjRPqUI0tM/Mv/9ENOhZDAGaswkIyQwrRJPS/0skafAJS+CKbglV1DbjlBXq+/wsxx8V3+8go+WmilhOvOniZw4BNytVmw8Agea0kqya3mqSj9L98KUv6rQOtxg+Ozv0g5bnnMTNLerchY4wVfm37A5ml6YcXFCgINIWMNTkZn0moP6tQuumsjyv7xywPCysTa7xmXVSk3n91A5SksmtNatbKIYhttp2p0ufGu6TtYpplGF7og9ZvrIvLsHElqCMNsCVD7zNasphLgRv4od22e4JzXa1WFh1I4G64qrqxXFi/tlhKIZvB0DRzE1NDr0PP/seqTEWeJpSSCro9kujBxCrYiDN8xYFm/paZ/Upf8hK7jHjXvoejuQZsixs6jK9Avp9wnqbjGCokPFZtAvL9k0aR4KNxxao0244BHWpha8ELxMuvjUdvro+vkoK/6lQmsZ9xmDjSkff+zPGwySLg0D2ORzxqprkLoEsBE2zoh/hNYHLhxIlLrBtOjcDqeNSBT9L2nvcWAmFOb5j0gNVwVzUlvUDcsq9OwfK3J0PVqrqmp0ilsBTQdfWPOhgG7At/OKoG8XbcQOlQlKl0uDLzF2iY34mdOPKZGNECFs9yT+HKJZFxhXC2bwBDWLrzEoR81VzkmIP27J60CeKNsEqSa5rEJURyt3eE1BVnZ9CJf9xTP8hQvEqT1Vmh0Tgw+Ij/SfxE+XvXt3tY8swFTv3pYEjYU1pMdL3L3jAJD9YeAMailBTPf7a2foI+JRJ5/18IZYE5jgia7lVEu0gaoHeIu7SheAV48yda4V+BxulK/uoWbxOYB/bhYx7EaZAGRgs2fzYyWdDhWe7ccx0C4MU9A9+/SgPbyL8M8Equuu0hAVmUS4hMI8JQYOEj3KeTy+ueRIMspu848yd/KizBtO+uuTEQzdUvkYWjbyaD+zcOG6JLg3DZ6xxGcpBf4inQtoqHJRFVqRTnILyZBNYQyLWk2KqfaavrN7ra9EnSmm1T8sAfhqhjg0qGAcVXyAGRw/NaMqnmNxE5k0UI3RAmJH+B1kuXcW2+B7s8oRjTY0pcwqkzU5IKWRXEaWu7UBfC3qhv1hWS2sdYXRZV+bZSffkqu6DtzX3vQS+FjpS/GTqNyNgpQrZ/2rBaVSKfZm3W8i5DKUTjHH1awXljFgfNEYK0+dWeDAfF8EU7QZ+JggRL9xn/N8foQrMfAxaiNFxeuC4G7kZ7auo6Y2+uXTytyiTvyLGd+n5tCJ2HiAihOY1Gw9q0izWw4074c7TAcmpjqEoVmDcxlTVGMLAKDOXPaCZ4Hcceuhi6drkicvT5bgx/lAE1gLMKDBmWhh6yc3AEbQEvqd/LVciFzbvLhFaiVuUtDury3/BnoxNu9vT70M98YmBZ4R/i0V81GZsOeaaQQVHJaNjrehsFO1k3QxpGYFTlo85mBr/kuz/BNaydPjAeYOVQAV8mipvkmN5E/ZTtsDAO9lNk/RYduubbQLXdUkTypFjZ5p2S1cGMlUDSYQzAqYApiaNPUs0aZNeJ1a6jOxMzlEMw1OdiCTOs8BJziHMCrMkjyI2o9696ia/hEby7n4yhCQ7YE6w7XPqgmtxyy4joEoaRoazLxZ31zGH9DpUzPAeC/JzAbDalNxYy9klsO5XK79a1Aj65TSvw4hSWMvmjh5RAaJxkN0qZ5iK6/w2SsNlBhkRFO0M6zoEL52+edBVTAmSeaV/oxwFVGkO7lw/RWXLVwb1lPY+OX+Gr+gupp/Dy0XwIr+oco3v1B40RzV6FAnQM5im08t5S+bgXgn4hYhDtJgRL5QaMT8vznv/rpFqjP7cKURFCWQL543kUrhr4lwJQr3aef6qt6NdN3Ang5nESxwARNTLdiuiifJiMDvXvpIVJHh1VTCEYaKmCgydstG3+wF2bMPWPrr0yVwvpPlQOeJKwMX0KAO7VXwQrVSdKMTfhhjsDhijtwHOEPb9YVi1uyWVXY0nk88ZbgyIgRfFKGK4rOhbDl9ZDyQ+r+T1GMF0Kwl2xvJTaD8j1elsJYKKpONwIwE/dPwKI/PqZVW5Cx8p5Zkw0Yf18j1jjuO56NaFbgqWS8Yxb13r8Ch00cwV7MqYfve7MzJkd0PE9TS+cSI2/yf4iQnEFDhbGq84hXCT/CL4CFFbx+JQOt8QeXHkO6nzPcUDZX0fzzQ6aXYBHBRUysXTKMwf/K/C2Z9n4Mx36hZi3VtptxDcmk+NM+V/60lkmcvXvhoaglLRfc8pxVWV5CkexM6LoQF1i5CEz5MULa+XQ+yeOx40hl23dSguiv37iwRHOzWaMMzQkSnN4WG3/FbgG3Y6udTkllkhXvcP9Nbx1vO7w/+qdLsTba2eEJ3BrRgRbTGO1VAkVNb0Kkmm/e9q4NpuH39fzzKM2sHwZkKknOvRIAA2hekjZcCElDDY8U4vpU0VXlIUYChOyUcKN25waPXB3ZMuLcs3PG8yyEBOkq0cLqnP/58LuTs1s/xfJLDmcMsICFnowVUItLAxV0kKYsybtBvD8euc4WDGJx5JZpQ5D33atEHfpMBdLl58TDgLO8ozVYw83f8jKiW5OzfYVuwJ3Nm31l0ZoeOSNTzJDS7hopgmOA+v/mOkP8+aU26oXNhdMAlrE6DN+UszSKC15vripRqGvjq0Vd5L0UAZYfWvv5LGFV12mtrBwpdnITgG9to+OHWY35o/P6EV0jYdiK+YWuGXORvDpiv/yBcVHOGU3qIieCetvkg6Ti8S69cbQ6Z8w4EV/5gVMLxjinv0wij1ihVy5GUqXlE1TcJas/DquK544UDRsSpFV0fx/OGL3Z1w/Bxy44yDdF5nR4bTzuJIYBMSg/NJT/EXxzEd6XQZ/XS2Qyq/wyKtzMGLTz4TaC16LA2oUC8c8lLRzTvbFLrXYxKuGjAVl5R0ynnwqAlhx4LxgF6lu/jyi6xe3avZDniFvIJN3JgRptGohVlmQ56l1/YbOY93zhVHW0CR8Eui6qWisZHrVYItfUoAqOF41G7g713mwK0G4/4SnIMF09aocGTHEPYAkrQllpN8jELWMxgIuv3OKTPyHmvntTjUVu2I0xmoUSV3vGYby4XiGgbVevyTqh7LIR4v66TG//qKtKtNajO2itp2cCGfHEH8fxubGLrVn/2SVaTMMsNFjvWUfz+zBDzM66jwC7IQSPTgNXloSut4hZKhlRg+wSIkgtTMhg4OyInxzsO8Qr7CFhOZTig2Z3oTLhpbdN3lxzaqXa25Qn1Ax6VdBJqHwKwWEHsKGMBhZiaRD9P2yTnhr6rAoGQ9MHuQordWUYZh/aYkeD7wxmYXO9AJmRKnffLnBgrl4S0jr4a6Wan/EzfTiGjKCiA4LD2IUkwPw/D+in6cDw2M44qN/WsQHE8NTQgoXqpbFeOonKxRO0C1izmt7b8GIpeiXBIZZmfNaCnd7T0+7AEC/wl7LxQEE6rYP44K1HSEObbxT+r+n/GAZm89cDVRrdG3GnKP+2Y0hFCJKXJ88nfNkX75spIpvwmXQrATLdMHEU0ark09e1KQNlhE5bFzWEawY2fY4Ugr9Fn8F6XYTFUfpneCL11VeWSZP6C9KiRgAfhe+01CsiMq+7EII/SdDXynJNqsHrYUhwu1flboTDaTxVjCC3PFlrFnD688ehpHEMQb23EbIiOgPJxuiaL3CeZOAtP5JH1z9HRKeLUAxHTa9BNGu9foeAFfdSPEP5h4XwxlYM//XEDURl2OIr2bGX+mAgfQwgoNm9nFP/Ej5WaKxp65aiOVrdFvBXZki6SwXHkCdOlwKz6JJKm8xWeg/RtcEruf75RqkajhxnAIoR7oKcvmYpmWd8gIqooZVzOm6tolhH/KJE7HwccGJkdrX9TmHEF3TeOSvIYdPvTGXEYkKtYlfZa0G8AX7ufmxFa0vBd7VkDj9nvxv6C2j8mRwjohGnzzZ/STF0p20RxgclLAgOLU+0/XDCyuD9upa7ogZevhaUCgjBxEiXI+ZG1yOB+Tzg5SwDWvDAq+dxMy6yCXU7ldYY70hDbhJqPCHSeMwmBu2YZDE/K+CGTTf/FjWdiH/sL7evxp89Yfu0X+iTOH/3WTk2UoPO/vqnn4PQCLW0+JJ7l2m2sUNbWqO1S2rs4jXpuAffZk5fK7QG3nSfqCT0/xt3TKK78ncPzqJ+qS1C3rj0g+4E3o+oYIQ1+JVSlL+ZDQTZJfEycSuNJAECCHYCE8o8VJFJhFcE89s85EgyungTVTBw26rsiQh0bKyHbbF3+uhDmyO6sMv0b4a/1l4irJXOrzYt3EvlLAI84q36+lmLKD4Ytg/EToq5i1VXKvMZjGCoBIYfbpngVnoHW9IvVtQlTySpOQayPRDavFnMTJOv3yE8J0/Q1hBViosUS6ruSFprRAUi92Jp/8SSSYr3NGPWja6EjDYYofSov/r2NZ0cr693iKlZuMPpU4zYsV+0Hgx8Krz/YMkWoO9QKbC4/EI5yUw4xnQy4ZcTJOfxsvpsK9swfCg2Wos/OiSX48+Q/SaH5uG68zY8Ii0ofNaNvjO1gE7VvwvqQJepIxGdbr+cHAEPAAJWE2bNeSAcnMyE1h3wbXLJFUMYSYPZTakHt6vMVXejxFsqBcJsfgfWJxr5K54a4+gXDghngcqXvA8i4PcIa9sQtAjsMhf8edscUqApOWXAWoggDj6uS64CbS5sUaUEMZgjRiuvlTW5Li3Q9w65rnMX0gTyR9S1A03+aK0t2gGqHp+va94pWy9w28zAdvLIpBJnRmZ+YDnBhHHV/0LrAs4aMPIwzkzBlaimVzxjGD8jNA+IM8Lg6asEXVl4vOXQXW4/47C1mCbekZk3if1h9r+EFIcGMOFKl8foZtrV0Ug1LyfwUmRvwXO1FYPHmA/IlUG4OEo69FGm8PGBlS+Cdsd48/XpTli065LwlcnT5SBJpsb8wt/0ilDGCxP4KbDtT4dwQp8t6wAMSDjJf0VsFDTsc70imoXVbLJclxfYSiO/l7hNxaf0svLj0diZZ0WUpOlV4EUxPRzKgYqxcHh9zvUY+zRBoiw3XSRUpPOqHBNE1WZ4ry74eb/JXHzFCcO5M9UIOgD+VYFhO9VtHTVTuU8srPDL5B0u8A+pX7OwK6W0jApr0Tnqen48yLcdOPnzxp4zCM3NyDYHmrT4rgg9bNJVQzwkLbuhoXREiEImzwB2N1mSi/+rn5JD8yhmrONrjDTnPdc6zXXMEcbOUmnYXqN22cAnRzrHDjz4RHbZbWOP8nYmetMHt+uLHTRnD0VLk/LxalWX+EQqUun5otbC2bbCTbra7r/4MSa2RM+EGe5oP5DaBiyTX63Yn76Y+sZBmvTxLxd/geNHsGWoryT+DrhZ3dDYeojNUI3UF75fxZGurSX1GeBaIU409ykYQfTf1TYtczVxTo+imlJi/czTkLMpHkYWBodm5aCP/we6KaxGwQbf8elpfqheso/AqicGAAT4j5fFYUB1QkO5QouApRcziHGJztu1QExR7uXs0qdeAT7jIoQGUWRxYZhNT+HwAK1DQkZQ/bDEROkIIZ9XABLVSJi+MPVLLZe78l3Wshu4yYOrijMaAAhAfldKm2ZYtziOsZXEVqGKU2e6zHILEOJICnlqwjoc3xGUMfI5zPg1KelAQMfPh061IMCpnPA+F5ogoUOW9xCAfqOxUePaSD/eqXeJ2h1f0a6mWliF2qhfd9MpUFjUN9rWMNaP0BF7z/fgOgTzP2BHUKJWavgOtI4D0Xruvhy3f2zjVuIX2git9jfSisZ7Wa53Iu/6d2L7AaZ7bN9adz5emCvCPhovkQnH7+ysWnWPM/OaQVazvbH1/r217bsEqe53KM2tBr43jKgJDJ7Y9j65jVCJMeEZjZWlEoZcW2Lx8fq2Mayk1J2Wc92gUq2PYI0pp9EYkwYDqIx7B8NSmjR3fGYw8dmu4AaCS3of4G3jh4NqJVsjbgs/09htTJILTLUYu+xZzHXirmvFVemfilGpa8YHZQMw0YFdGDKtEuj606NgwzPmy60+aAJZr7wCC4btS5yTen3zEReHYpMwhyeYCHatneZ/FU2JoQEbeidTmgmnFvhs5OiA6ReB6cf+4LQuz5uaEuEg+lBLbU1bvz2YYZafCj18knHtAEDqgAVgpopJZ+ki27n2e+1uH1OubBHTqvZZmbzf+XDvWZkDbNN0J+/to1W1IreRFqLRB+vm/mqF7xtGWNFXSrCJHH4ZwoyPvMfK/TlcJDnGOrRq/yACir62DI2WgQ8Vqpqjq260hqspTPWJz+OUjZgWnFcr6DSXAXq+OIczeQBA8scVMM7+YGEqOKCMcb9+8cYrscnFWdtIYYupECKrWtzDO47VmOxQd/QNJJeeFwEIVYxfKji6jaTPyCcpPqDuyAXOcuBumcKepcu68gBorlm7/cJFCK71fFPiZuSGyVsVSL0AQXsNC0dxmpqQFIIZvy76jbVQLqP4XjwShA/lsGAI9hSQMU50T75h0+AX9IbyO5R85iLuy3OCGeNo0kjdAolVXjZ027TsBzxv07nnbiW6xtvt4m0PM6Pt4E+3FuahGYzM2oE5B9WfDZoYAM3E6w14XHPjsKXBY1HTu6hH8P/X3Eu+UJgqSWj/jVQeUzAyklPkK7SC1j6U/S806RF5OGHlebz79I9CmS2BrBiLi/z4jGakiUjnFUOcXneIni0Hj15kUOqgoM7LrzENR983EHZCv0E05VHsAkVQw9exNp2A1QZ9fM2vNNpNR0IsxFSsEJOA1vanin2K3P3RJdULz2NMUVLeasjhEuN3QXJuGRUpJovX0XzoswGq6qjOQWp4GCH3kTSzlH6IqbaRxJsFflr5IKg8xLHwskhzIl7DC6wTuSEZN/kTLGPWCnKufw8VyF9QI8wqBD5M63UPj7ROfrf8gdnDfAx9qzRYwToVG7z5BFg/kqOip/ROt8YSsHKIui1sLTJoOPsA7Wrg6k56ORJV1tXRTQop60Q8xKD3oOO2hA664i0wAt8BqN7rVq9Hs6ePXw/txKkPZy/ysrj1vZh91B9zWAL4MSQzB1x7tuPbD9y9mGQAGc4H2gpFsmK29zN+dMoAYRNCu3kWlF4R/91ZXfs7XxV9Exqhe3GA/q1lfVnG+xjWTJYmkc0TFG1e/iQ/1fiHRLZchr62hDz5mh1fTk43HN9eDMsnpopI26HK1pcy5gQ5Prh7Pi7xhNq2JC8JSOs3KjrjCSMPvjndtrw00vDkgV/pcHs91iS33FfVvX3QT6BdDy2LnNfx7f6EsQEKjBe/RU6s2r0FuiUZ3LBT2vlEVcxFq5yP4ZOKfRWH0xj67tY2Ym4VqVgHnSbmDCM1QPRIsGCznRjTLGOJ0zMqgZ/xNmtErImYg9WUul3HIshmbN37pCL3yMx+TT6yXjAOZdSdJcEj1hBDNx7Udu67AHU48PKxM/i4mnaft1ydKIHGDaJy5HOiX2b6p8Qc3ohxccKpt0Yl0c3nWlKkKNjv/Ml845N+kCSufwNK9c4fjB2M7rOgH1Ai1xa5m3mrYqjNgOEXWsDVWOizava091eEKjfqpHP2NGJK6kjrQr4Dd1ri2mWP0ctOnrpYO0NAgYpwNZl8YnYUGhp7sayc8sbLybKoEKXTn9a/AYgqVr0/uPqnlYNvfChDFQhltZxgBqlnMOj66EF6BBIbnZ+W0JM/hiwzoDAxuBPnXvu46Nax/tTmv+6QGDUHZrhdKOTsnI7gFIoemEMhbg0kxgRtc5uUIDkb6VM0n+XujzRNQn8WE9eJO+pk3VoxyQvSGoQdqO9WQdLNwObWxf7rZ6fbY1zJ4xBAuOU5LLtJcVXGW6M5KlQwpKPNDqmgwYN1a3LNoOaeo+vKDcGYexHsst4YYURBrGCq9vqFAnjaRmBXwFrAa7pVM7zOAhyP3ZNH0FQSeLjFzTjcnbqq1LNWNZUnCOdcG255Xm5KdUd8+WXCi1VT7dc2+pYpReTwy7i2dnWmlz6TeBl13JJ1F7hyo5tbFu5LE7xmhoevEiR8TeeLbU6UyO3omtyeDrl63NthaSWPc0rDKMqs8pkRq3T1ijoiegrpuCqOqqslyAb8+cHrh1Nq0g8R36DMy01iRt0gEJ+1MMcKVoayJvhLHeyJ30uzdwjGsbgv9Zed7eAaz8v6CKITGN1KEz5OmlbC2GFB9eZXDWsq4meqsyKCW+xQvImGgDDwqMKw8gRITgWlfTm/ezGrKlduJdm9kvoZmd6sFzyw5a1zKEdL9iy80W81UsJrHZ2Y0wvq9ayNK2SKpBsHNUo53AbURLuwy4J5FIjIa2yt9yItrMnLrVPgivJ+2gSjjGgvvCDlYqn6wVUdwY2542fIZ6IhqYSq7ovNV2t/EMZQPYxHepTg5lJoSTjrhCHEkZgh7rBhKXZFK7yYqi7kOJWLH6CYUP0kLw4JmC42XoCTfp5E1o3MlnQxOAp5CFk5rUXa+NXj/DEc61BhzPGbfCywuHgpCNwwZQEu8FeuljN7gMtefAWZWtlxb6GX7PFie9DiFfWGVlerGI4Mig/oANc89bHB5Pa10GfgnF/kvwxSXxk1bZ0ufrZ29cy1qpi4E1PMqrL/jdPlA6bJKthlCnrN8/4CPTTfY+n39HQQyuX7vEnf9/O9+EpKioGNUnjmHDn29mmFgPhNZq1Fservxk+5Q0WY8EXsZeFEmXr6nHXFSpqFeeBdEW13MIRnCouMuLMQgWdZPipTYIgUpkuZetYWBpBYTPid2s2nyiC5rplfeLJp3D6HmahWa0vRht6OmawEk8sPD8otnJibu/Q+/cJdZzxmEMx2oBrlv13p1YLQ/TnzT00SyohN15V/D03CIPG/1b88YqNUt9yKNYe5PMa9AIg1u3508Y7jEUWYSkyYXkmBrcDKfxi94N1R5oN5x2VHuE3kvNyVCGDWXvM0or++JVuzT1ai90wyx1G23fyjUdskNajhQ7DfZLclBarRqXheGo2WvCdVwKrEsflFvDQjvXVRDhrtpAAjg/rmuD4t6Iw+HJrNUCxQ6/x03j1dzQVmtD5GRimUlO3n7vAL/FVcjT/7JXf+mdb59BrAVR3lS/8B1noyxA8y8lWFE3rlLQdpDqnLKRy1cK1pmNSnXURF+QNUhsaa2tsVYYByP0xsZt8HVx7vPh73v2/NMfAMZ6d9xuyxXc54kM/3KpKrAyoLOgzxJhwg53bI6R2vMiadpMPgly7Shpq2RleQ3hiRMm6x8atpun2pyI9lkXzWSvfwhd+eMWBLU4OSq7UAok8AaUjyZwK4BD1undOnzoC3F6F+hFhupuIvHWDA/sm1t4XLa/4JlrZ1rLNabAwFGc9hbNT5J+uEvzKKLIg62AXyPZNOvHSCdPK3K5Dxh8X/fj3dbc+YevWTD/WQZL1U9fgT2HSVpkTBm6gNd0mi+UGYTQDz9dpid0IYJaLWh0AB4Qbs5ti4EueqAzIR8Ytx5naYu+sp+Oh96APXrWTbbWCSaZEv1iOfG0xGmoANLZXU/92ytcovJo/KRqajFHDMulcD9Hfi2PPFDRnat6wLabJA3SnSf19wqN40qdpsy1LUwAXbDb5ge3fnn79laUz0SNRIXeOKk8mM9JiwrjEcHDRa4tXdubnWMLIVJaaaZuea3juXHW0T6lbxDmTYndMXM344Ad6ydJYveVJc4M696SyN2A4JDZY3BqZU1OmfIM4KIWlWi+QPDYonD0XnZhOdR/z3mF4WVShzoTpucJ7zNFDOghYQuQ/HA+nUM3bhM+zdYrPyYnM6DACPZq8S2knGhG2ZZCbAtsFuTuh8R7lgRVYqVdmkb2T0Inh9jgdyvRED/TmXCF5ndIrKCLZlBILxdQnIHWCwc1P9oaxsFfOeEj8/HdCGgMjyUNorEaL789w7eR2R0ziIQjA2nQKl+czGdJBUjGj4vIYyh1kEC8mzwqfK6PgUOyqeQ+boNIjoVKIJ86B+A1qt6KeQjqi1ZVJ1LWI0x4H/j62FlIfR9kKTtzN+jYZ2CJbcc7uK00PyaTvuM2mqq+CdzOBLgIwYFWDgu3OysaMmTvtJ6fafBkt3TjO1b50n1DjP5uZ73yKq81M+AmFSYAyzmbAJsCmDc8naYaqAerDqMPpciJwx1gvsqamiV1oCLscSKzH1EWe74xlNtlgGdz6v2yOWsmFGf41bK2Ean3ArSKRoyDUT39lc7YUyeiGgdL84vO2BtEPh5PpIer2+iC5u3oRh3AesRdr4YDmFKuss88q7hEss7O8aMPq8X5jSz1PxYUM8aX/qTRYmPPqoCamrflwXRm7EhQ9+eGWj0vV+iu0ijkygwi1i5LuHjP6vO4iS52rP0h/iwkLHkukclbK5UZ9tVsTu8rvxhHXQaQYSUY88m520CWHIk39lsMbHL/NDKGgpxqosm0uGuliNZqyjN6+GC3cypvyuDJIsBMrlYiKUfTomL85sV4fU/mXAFTTaE2jjBNSBdggG914DF0J+x1E9SnaM2VJtUXyY2J/Ga5aQsDyBBl0GgWixZz5bAUN+JUvzETkqBn2Kc409FZZ/OTquVTlsOT/uLO5H67q00ru0eeuHyv9J4Uxt2CMkcmL5fHqgINeyEClSmSOMT/MC8U7svg7QBRBOblkcBOalD1QgofB9oc4lQ/v+Zf5xnwFqcmpevJQW+J0ncgA6HeEkXG2QqxAT4g361eIU3Yo87xdpcmS3wIOdmvyS/qLnE54cZAvXEo2faho8mhl1Ovu5WwHI4/fp8utybkaEqFPMlKQkcoSccOILXfVcmlHZIJacMjkWvmQJd877CEqaJqJPcfpuLG0KuxUWPphd/r41K7zq5iV4wNqtBls2449BC//31PHG6fIKGrZJrMcfYNbqTEw0nGk9yiTYz1A+6WCWAeHmmw+r3Q2CWsTVSrb+ZZM/9/wwWbQZW6x/82ykygVPyQ8HSYoATmzucN3++UFkt/DCu7SEGcrJ2HETSzUSC3CUPT57pl+AsxLA3ZU/0uk7Hto1Wj9mu555aaHO4l1QDVsCBKYxpsI4jH0JGZNCNs5ILHxf+Cmf9Bybzf+/haCQiT8JchflDt790G3EQyIJlYEHM7YCs0vhsZIPUPtKrk4xywd8yJC22GgKnS+h0BvlRMH+9W3zemovy+EmFCFO3ekel5rXmKD1eduMWclSvIse5LSdyKbc/PVxFoFzCzzaEBt67jcsUx6S4OlKOxHF2FzWh74m/LIoLI9tAJltvxNBaeK1tK4oTVvGTMV18F3jYwccLUVs6qKlG2Lrz8aHmggwYCJvQdjOnpUgCHJZ6EV7qzp9Jl3gMTGEtBTghw/Ol9EPKcjqiP3tO/vufaqQfI293KCUv+0X5Y4zQfs2mMyYIAJXbSukQTjE15eUz5KCSMippL7O7ihwo6u64HW6hO9bhuF48S/+s97/4ra97dTRDA5kBZyDZpw2uaYLzg40I+OWFm5rMoSfGbV5Te6hRIkjVONFyyuIX8WJWCMVTt5+XELeit21q4Bw50X2O6KSCbdN3uO/kf5FFyhoTAygyI0cBTXPU/AMBLYPhHNNFxlRyKQ4E8Q4+ZLtQQHuqKOgmE5yr5/jXWj/nJ6SNDL38Gn2RQfifCtT9Tzt9QhmuPLLJoipVA1rUYh1hzJP/+o1ipO2qNxpmlqE3kMB/P4PZRjc0NFkV9shX8rRuxOdcYPVNLUjqBU6fkXo6fg2O/Oo0/HWkr2CPG/4j7KAvgGJZfQQmN/YLL+kBi6o1PS+bphnLLxEaHV+E2i6I8t4ZH1RrZg5d4mRXRIfRfu44AKsX4Aknj8aXW8DbMHIP2ZTPN81XC2ejdQSQTcrh66Nwt9+KnrFTKCFcwVP9ku6UpArCQYEUki8kVEAR6/sBi6Pr//EBMt34944qTHx0soOmXdHR6kQETrCVc8KbfEusx+gICn7sQRJtq2qYluvnnE3JhlgjHnfKiNRP8rNFkQIflbX+FZGyk4bQmMwI3PKqRGVZLAYN48LR3pBSXEscfrSK4PP+lhC7/4a21fQ4LW4AAPIkGZZdN+V7CWKVd8ymTBpKTP4SRZ+g1ZrCwoz+C805UkUzK+hlj2SiNIpGLG8teRotcTz6nl2Y8WqU4Cia6/gfmJu/FlXD6AmgeOiSHr2trP4pEMHcMU5EUEXUgTAyMxJ9V/nVwFGt9oeK2X+bI7fADnS5pUBKfSErcrn34DlvaQ/aiFlmhnZ8sw/Xlvzu7XN+KrRYQWV+8Avivnw4EjaMYel05Xu4uEjS/OxwWgn7LO20tarAA33up1IiD9XPyk/Ey3bxN+vSODBWFWdAg5gzZzTzURAC2JVd+ZTdYsqCrpckQZbNe39UwgIfhpyJIfOHCwoDZcJj0vCfBjUHROU4izvLkkr6P8viayOkP3+kNb95FaHMkm+UgPerMYPiWzUek8gONH70NNGMNr8zgCKt8TrzpPHgMK0W9ZB3VWHztB5PSrD4snEiNrEoc42fB33KFSjScW1b7dgYIkyyX5KTSZbunLHCtup411C7zZwHFZbGOCVeWBOvv6Lx7c/EQFUItUDBCSSKaE324mei/Jh8g2kfCmgqMfuys+jnh05MaueDYKrcrKqv/mGvyGFdn46WhuBUMuNeBi8ijIJARxzN5VnCPAWtEXXcVDmyNxhetXheeLSZ3pNoqq+JDaV5p8YqK2lDnLsVbTxX3XP3uRgzqm6ByjCzqCBi8013xbBl8T/LpkQNU/I0jVEDb3WLbr+BnIpWuvGbNurL58X3WUEe9EjBQ/i95sVtX1OoV5Rx997HIUiQ7Q0+sUiU+SceoJp7RLP8flpGiGePguQR+bfqLp9TPtAvp1T6ZjACi2TV1UutzFsVLLTRhhTwIy1mw1onYmvcmrDvfTyAoR0ibcNmwNAfl82QYCx4+0e68W+luE7agJYLBBTBvNrs3KRg4Eab4OssTMrNO+4d2T0QVPa5ctjZX7BcoM2BKIdw4v/GAonh7eUHtSknzEbEyi5jQbRnecUA3h3dCURW4zWq6TIhSyvhs3LoGHpeRVVFNFaAOYFl4ABzc971Ne1dkEyaQykpdgNnY2u59buQ9F9GQnPjO9Xp+E3VmeZkrtmufv4/vfqBwDig/mmU3Jt/8Rpg0nLdSH+bLMmEzZDMW+drtrmYrTwLy9/zPwW4Hqwz0HxdlJ/Ch/YpKtm7VrxFdUcEDEnaBq8hmWjw5I+cksGHwE0Bjn+FJkOugUVgIknVtCjLnhT5Jk5biI/kspW1jRxTAYyKX/iInGF3DJnigIDQRPj7jSzYRj4HRO9JAN2HfMmdLTaio9xAFUZ66FBJ2zNbGxJFUwkJocJQN2JlwLhzB76/my6hdi0XEBKOdMRpVEZuWTqWATl8Azyv9dD8Sj8pPMTSY+IcAag8Ljic9rcuv6HKeu+QVwrPA4B9IcXzWVip0RPKVjcgCkmCklJYEZZ+N3wRccawKUtunBTb1GgP5RgYBgaBHng3GnRExE4Rsp/QLb1jwMKCidzSvfCTG7aNbswntlAjXmkZmhf1jsZVr96A1ofdiI3KIWAzkFDwKJmEIV+CHTiXtZmClXEJXdvF6CqGBlGggDPn5NfV8ICtyTbM5U0TnV4bMFy1yHrFyD0hSj6esrL3zp2vDlE9ISlgT5iO5KMsGCoIn863ceA0jfMd41ByG0r8npCZG+/yTaqBCRB291sPHD76P1b1C2FCb6bHEDqKLb9GgbiV6BCmG4CE2UTR6OdrF3uStcEBMoO+XkZPM5r7GDfsGaZC6yZOAOHL0P3tNwpZFSZcoP6nRqhnXlk24w3cy45rChnRY1RSlq41lwBkQvjrE5L+1ea3TJNjwiW/i+6LRjMQZsO0peeTIEM2ev/KmsPdtYJW1uDrZIExSeDLRdf8tCUUYLrsxK1xDJfH0PwXsSF7WI6l5++5+SSZ0N+QNN0Rf5vxy4h/0nLqGXP0iTjMb0YbG25yn2Q22hMXh+kvelnYsh+eHDDz1+iv/OU06BV3WCgMizMz2lGmVkOldD9BlyUOLZWywAYb7omy5IH0+a4/zpm8Y36samUB7Ts2fsUPyb7uNXYl2eTb1+Lft1DIFBhcIfcqKFzDwq2wgYyC4u1dMPkmCJ/A6BNQ0FW2dpP8i/wGNclhZsI4X5VslGxrHyhsW1ApR7P4S0tnNToiSFUwjwL1VLrnEqM4ZCqUCHs0dMW0d+Tftnwl4+tGP5VTMniaTYf8nbWLFKq7TmnQoNYUWaNd4odyb8p9mltAYxP29o7VdZ1kvX/SkgphtNg7cTuWkZeZAhn8zcuMhMYUiUoFtgvoaBADXCz83iuO/MajAPbZaLIL2TuBFQVidG4DgLjkhk1L7mYGhJHOw1ntipzLnIzpEB5va2iG5c0v4RW5K9M+KduZ2gIwetZLj6kj5V7qsJP68asV5D++s++Y+U9R/rn81hkgi9YM8Tx6X7uP+scUm5QeNtbji94TrvsP0ZJYEKceHdKVZBBayOSRTqkDZjDsKDpBOp32dxl2Vvr6zbdOx73KXxUB/AlfGM1wkukftiYwVOArvxKZo8CCkOnse6YIyzD+acODJ4gQizXRNUZQgs55dDRBZLP4nXMT4FgFSe8al1RX8YSwEfU3BPJLoGcrF0SsXZnG1UkBrDTMlSeNdgtcEmz6yRAJandOVMyOaO8xSwI9V3mMZ1RVZnQpxQcXoGFiv+1FKjp8cPm65i4Joblj8QG36L1Nch8njTYwEHHEEbo19LnpHDuZEQ9YckKSNF+8uVMQP1gyBWY8micIBI8NKam1S8p3iik841zG3hLpZQbruKDLqEEVKdivPYsqAE3Bt5mZr2gbIBBPhNspKFooCkCrW2/kzqSjPBLnb0qnf7RfP795r3jSbyaNT2UnDO8PhguoTvpxj/VNDJnarTsKIYzEHeKiNMo6ff5Q/A/oR/f3iuVSV4/NEYEUBW1uAW72eoyHH5fK/5bmwsYfKSaq3qbMbdT9ruYnWcxnRPkHYUMqFIVGZN65hZIl5Ha2bs/vDsGcMnVuCW9pUwJsqGHcSiNqhxDHajq5++GppvgjpnkTUMYjRXpKkzll6qRkpVr4FbltK64z6xbWaV5dei0MFk+kEL8ZBDWMystxJXXspEn4rbumYi2VVD+4yDIHaHxEjj/52GsjXqsFKcxy0Ku+QIcf0Nl23s0huPduqZ/8bt47AoBlw0zUpFiqWX0FBFrIi5eynAi5mtnz4bFqPd/hWEWTBjL+ouSbsj4Dscvsi6mEVYqbsAopehW1VQQyq/+RtNeJF2cEzBlkCPTYavjhYzBOfRVw1yn/7134tgIi2LOvYrmxWGG64C4UzfuutLujh4TQlDVntUruFplzMT/iJKp9xB1tAVDjdOP0bpQQGRQC4r1ciDQKuD4exVEUHBl3cFrBJ5EYqssBGeN+D401L1QXUINMePD1jmtfeU5d8TFsNXI+BYiSg1lifQU1ihBPtuZ+Cpo2OnLtUR3gnPVKA0U9fyfxzvbADoRDph2/F1LXJKtCN2gWd3mRr5FFIj6YA3/heyxWdS2KQMVq5MQGx0LqBbghZWZE9uYEaL2u125mo5MGTJ3Ne0C1AbreKlbKSThyPnza9Jxv6fV8xTBmITOBGz9Y9EjbfpfVWdDwj02Bc6snzmuw29v4rFY2NVxji6r30x7Y5OKGlpyv1pp0L3cb4HyGZwmuvhzg1nYMk7pnKYDQJROraqy+et2FOJR7r7p4M4y0nrXne0muHZ+X1DZGc18ne3+niXYWx5EWeRxZykPyHZrY2VEad1Si34cwDOOsebJnEeh1PXJcF7ZIUY8oPs9boGTaEWo36JRHXG8lTIehiqi5R1Jfzh4rc8M7Cmeh6KnckudSKoVDYr+RhyNOykBYXSuWbw7rtdWEP5gFqfOW6b/z9OXn6Kn1vHNppDebYqO90JFznz2onotoECDIKAwehDBPJC/p29RtG0NfSt2P8GzZLAHqFqaZF+5cFcqPQ0pD+8tMIYAWtexoStLmw/GNLEzLUerkdgreKRLJYS9VCt0tkGZ02puV1b80Pf4xIHmzMRK2/UYR85+k5xcV6p3S24GO7u3WNy5OpD5GFscDXiXWpCm0pJAWJqHPmRsOMHRaVj7EIyeWsriNRDyTB/8K5oMtMibDD9os4ltU+kFHLzgIstOA5k+4I6CeUjIkNlLmrf9mx4KipQC8+ZVXPlJMNBJUh5BeLuMy7m+/552BdUmRSRt2pCThJchVUQio6kcQR7CFH1F6u3D+lUu5qT4+rmpZ0Y3FWSNvStXyx4mdJ7fahs3fCJhqJO9eMNFZUE/x2Y/J8EcYgqwQv3KRIY91MquM+79ffzJK6WCNT97zB7WjErpXXMMqSNf+nZ/rclCE45A08fYKJGpVysYSHCnhpmN/nCleq3XhDbC+iDgVBOb/Z5imLef5n2e+Zsx7EuwRbFMYiersz0kDn3QAxTDENofm3qfnLkLOwDhLS1gJL7ZYFq9efSaEUx3BsiffT7mPb9z65WJPu+dZdIxQSuoEK9tZd/+mXVlRsvMnX4KK7niIkv9GX3ZUfEeJ9nBNo775KnY7vT6eWD6qP10cPTDYyK6NZ/byeeUDPjKJTLuR8f56bpD6qQLICJhIL0KxuuFZZ04oUhh0iKaeg6MkrYUqLKPxDKuauu+ZdFpEbfQEqGXsX1ZPS2r65VSLW/0X9Slmy75XdeW7+2tuJwttcFEaJazF96i9XE9jwOPGZtA2A4fu/819oFXxjQ1SimNdiUYTwzCKbb/e83MWcSgK+mBfFcQlUG4qYHcWtaabMStZhgojoHnA212vDnt+eUgdemYdOwNXe35jckhdcU42G8w6iHq7xvjOTpPetg7vJD8CZRyqGn2BoRDO+qXQYlh/vxtjjKRNpJ2gcaeULlB+ApaL+vZx1fxVYDAY9t1ru1t0+TQFKPX8PJ7OmydbYX/xytKRteMdTeOPQczU//L40/8j1zHcgkNT5U7pulgOGRPMjf0SaEnICNN0M0YHplpSAnAfMLg/FiWhDuWLpoPY29o0ja8WQOfCmnA5QkyYecz/rdrUEqf/OfD0bgJHmVToW5hNiCQnwESm96UDgjFDtipu2TSzIozSNLZ6a2ZO8iU9Xn/8D8qPTuzycQJLVVFIrNJflEbAU7IaKSxi32bj3gcd9Rxj7yWE3k+ZLHjFfzBDnh7dEbctoHGv7nmdllsAErHF1rGVpjNzOq/0rwt5jAKZa9Y3Gfg6EtD9YR2fLx52/MLthoArVNmR6wcSiqLodrguEvLs3KVIZ/WzPoJzerVFCam7AZsVVHOJ3aGjyLMX/zYqgwtbZ3QpELhMWAThlBorgs8LnqNs3B0GlWIWVh9BYA8LxBcjHTBnvgrNzkkYjOTP1GeaJsnQuuFbx411yF9uI3bieIB11RJdSTBTr9J+R9fzqmgo710ku6sVY1niGyW3oQmQPr2e82Kks41vXc/T7c8dSq12vsPijPg7pisfrVDPS/7NrIlVolq5OpL3LSlmzNeeGD3lBXvkW2fi14ilabPdogGy7llHQ5CYrFqeS0Fwi8ypTk7PTX5v3J5/duDK6yjx/pjptM1P2YDYMspQ29sjl3WkV9yUxZhoK7Ti+YvPRfHKKfausb1m7Q3aqQfqPLmxZiXPxH1lEtMiw6F56kRm9b00Qro4GX+rhOlAH2tg+akfTAqkPJI5QE4e9pNIxXJp9+eruhGtCZE7WsMAK4PrBlXK+5wHvXy5fQyThQEjLfM94+EdHa+M30iI5p5lMylHQV4lGmzZEkidrZ3Umqm2dQC+439R4b1TBUdEuki1wSBJidGRDsbsailD7Y9QAapvEq0M9DSpEH3dC2IvU/a6R3kdhcGwa6hZVeMZ7Hk7XRKgg8eMHWypSOUPolnNmTMbEb/lWpG9HKxogtxZ5uL9aQN7WR4ch8xhcndTjVPUYBOlinujPmkdGgYyZ8nZMJp1tkQD8+MUtjWocxuO+EqXdRAMiGyVUENGwx2IhuHfqPq4B0RMmjP1FoiNmSUH16iYVwhGV79pdvsPL+Az5z2C30PFx8CyXK/Nn6N4vYpTdjayFaRRwownxRU7PoesZHdFHjckciVS0DeQnzn2Kcw0X5xpj6PScp7EkunZEUf/2+pcXweDbP4AAk/8LjN9LE5KMo2ib0T8jWHtsZexVKNrnlJmW8uXNFmNWLXrlIvOKUkznKr0hlPLI0LQkuYTsVJcbvseJtLp2jMSaHdQaIz/TG2gJ3SrLxIXiCOzlX6iGVcEea9GGTqGfrvnCXrDd5AfT0JrLe/lf1StXKEykq9lD9OjB3TaAkNyfH5x7hyvLpIDuqT/B0j+9RzeZSl4jhH6lWs2U2WNoAnzgvVG1GzrhvNOehAZ/xZyTFuo0xbli158LEQyBGo8soV2PV2AiCCdI6e1f0w9AhWu27afZ6cjau0UhZsXapCHKkPlRdKtFnpcwhG+F+ZkDSEWD9ir1Fgv9WcBBNdKQ6FaGhaokMq9qtdtp+NeRyGpEcFmqaTtgSlPjJe3km+4NPs58P5SOmTDW6jwPwD6b3USKCNp/10+4Kzdjk+zvhb1W38xChTMp3q5iJU8xQL2oR0aeWtTAB7GFMAjiEVzcFJ/6y4WrppeonTlhUK6UsZcEE5p+nFocQm21MZ6yyrDAVDwkBg0CLZAJcH2DeDTTaTJUfP2irpHdtyevFCfYxwH0P4remF+kv7QKzKd76fdLIYjxukNO8/3+vj4wmWtu46CLFy0Vyx3UCUeNTrLoTbzzxIJ4iZsIeNquMMgDit0QdnKjhP3L9jFITGW20iB24YRA043nSReUM0K2DYyIqT9lJsb6FHKeOI4skELOSC+Szj339tiZ05+cpzqr0G7E2YGcIiliHA+UfNUzsTR+mLDR08+xReqZ4jjoCU7ZR9LgbfAUJXedgyUmMG2LMwGLhmpQhtTSLuT3guvlqOpm4fgG/675PUEsHSRFRNHUJJg24yD+g8a5/0ZlUbm59gcdXS2maGWC19KNmskO3cPsu8XlzQzv8Tip83eNHTpcu31oylfH9A9Cp9bLkS4kukOvbWPh39Z0k3OpcuNZG7S8220/5Sgy2qvPilvU5F6opilag6UtUPFofCOeathMHNuIf/IqfRJA5/zFBJMVBQMuJspZKXkkgEn1r8JIcvKhc9vypt+9i4PUjFMUiMm3jy+J1nDX0jUSCjRm7yfdXHJ+v1S7x9xjsuV89MR0MmYQwjhJnIjwbYMXvFooZV1ulr0f8VtK7zMkd+1B7/8cBB9l1/uPC6tIBKcB9RR1T0IM3l9qdUY65K3th7uVRizP1wTdk2EYFBI10Ve8vcTL7zEbNgYnmGFk1GWGyEyMPX4f1QLZcbuV/9pnqZe3vPTaguOXFJulBw1xUXfq3xr7ZJ7ireUr+DwN9xVRhCEcelMMGsWlPj36MX+DGDmMu/FqHvOZWDMnFuq8ZBkrMQseh37f5kZUt6ipa6JualNTECMlK2HDAeVQWLeXACmjQLXlADQVyIsKdXMPjoAfk2ngm4U32XwftiwtztvGKBD7Xc63ewFcTu4dNvrATB77/LzkURecpL1Sn0KAN1AsBa4qp8tRtvclktDMY3k2hCusZeQQuyam/UbhepZUcC50OECk/vVE3wMk0Snp55lJaYdCT8upHyxnV8Hjguc5gWTJfiSBhS1QZz59BSCVKWdGXrP2sRw5h09QzdWttNeqCZqugWN4KKKzbZHsOr9WEwj5LwcUbsJHtDTtLLcpNMaoNJc41WlOhUJgceKNNg7AsLfanp38xSfc6u+Y2o8qzYT0DE6Kx4XPzbLcSpqAVMGPF5eEQO8LF8CYQW9BK9poO84d1I6Kn6dzutOUCgXftIwnd1KqM6tCxu4+A+cFUWaKitU9vwPxvKJfZXnkkd0bSLKoRRSu7OT2YYzeSiaBvweiWrNtYyQojASUalYdsPqQnEgWoRj4PLFm2cMTbepz58ksLyFV3hR+DTvO4JaMTY8oKj3PLwk0gI3oV9dWEzmO1qXKVDWvx8dxXmTIr9dk72JezuMSyfgYC4ieoHlUA58UEaxtvHqcB+93B8CuhAlHBnFBQ4jKbF9bGucF3mBDG7JW956+tGtXkS64JJvqZ8oTjCXtomHd/IMdQ3l429iUr3G5fUrEKDf5NDsqLW84SyYrRw2SJaGEB021mpX25NrOgHNmwSzNGGGzIVNt/SRKAvMh+FW9nDyvSmvqvbLntph0gpWjq3MEehY7hQYxDF3+Kfj60f99cVhn/ExSHrWIYUlUeWKlb04qjf5AFDjBuTfnP6+foesPcV9KxocPjI1O6Rhx/Hqpf+hgRytWqWiadbNKmhTaSQZW0V3CzUw8EaYQ6GSXDMb1oE6NkENzgj1yf0e4F603VsxNBalRu95RE9Fv6zwW5xnp26t/XzSNCT+6KbNf9iERTUVI2cH5rabyZwXrzqPGrNIHOmYU8BYm452Zvv0j0I7ETqlMvKGeo/ZJvOyUAwQyYQR3eMFPZR6eh3IDJJD8bZedoFMQoUTZIVMmax5DyDaUGOsEc8Vimx5ClqlJfs0DCeEJFpA6UICC2m7GnXpc47iyvQ3Vgvpyu/kHSU/7Irna+idK4kJfjRkc7jRC3gksI5kbrg3pwlwXVk/706qY+X8JiB6IbJSEP94HmOadUJUUn2N8Rr1LfiMb/4Vd/UjSmUriSuTpbsbXKapAjM66ErjUwAvxa69oVKeP2hz5/uHdrdO5lRknrt9SFPQrz+SSlCrLT5a9+MN0uu6T7K3gfhn+LkR5LB1vsZkODJWTow6dZ/pPDq9fZzbTNW7LTa4YdrtJQJliXjUXXP+ppHQdKI39s858mN+cuQsmS0yufz5xX2sJmkuHlTl6sRjr056ZX7N+gC9DqgX/4A5nvk5BarVIcWwypJAbyCL6php4vIhNAyBBeYMhIENXhYl8bcNE79BfkUcI6AZ2ntacfH6u85aoO9kycL2ytqrmkTpGyxyoXZhNfjnW6PKWzxafYXXjRQQer00TVenuwMvs6wWBiI6U0qhnX63O3t0JGEDFKO9mbzTnQSM/UZGeHV9XR0+taU92ZjdYAK6mSEH6g2p4rti8aDZX/dVZ2j+wnx7isJOhoB4jRelXMhLHuYGfOC1Mi191j7eOO65Ab/WvgrgzPcInwtcum58mmph1i8ZcEmLPqb7x/0Vr2lTiu0+PeGpPpvD2Mgth8SacnxeQbfUc4jaZ5fUHFmm6Et+T/ApvTu7rghx+h/1zahNLCyMaOTYd1iHBmngOMFof4lBAwtcY03LeYZ3t/PJEBs+Firg/pC7TQEUVBYm95O2ylnMNQ/CKIXBdMxTlKrGkFxkGjOETBhNX839tpsjntxD1HnkpivRy7Dk6jO7z00InOSkC7fXNJbmf+R7nPsopORHO3URj+u4P0M1J6P4xG/RypILx8nMWS+bWnBFCToyApYdEAc+YGa5yVUc2rQ68OZpPSkd1xqY2JB25I1lVaEjuRDAuEuCn7PxG7nm5HraKCJWFVQjeDGk95oVEjkMDh1JhlBfPL/K20cU61htw+BOAKZP0zs5s9Z/JKpMyxx1cRCrtYr4LUAPnZKuV10vOUEsB8vza769im2WGJpc5jtUkpkyzjyKe8RHvBG9gGlc3cLC6Y8MDYoxTi80u632nwBcYorY5sYyzWcwB41P01zOoipr1EQfxU0oggzfFBbpnmX1j6HQ+wypc1bzYxHZMQ8A3q4cV87j1xKBakwXg8aIieH41LFUIQJ2fbaEAC9nDYax2ZE7DLnFCW/Mx4fV06puE5FIySIlxlA9BPiFDCNMmU4WIXok7XZgHLzUobzrmG2EhZFhwoJcMjxsUICwe3EpsdYUoix6arqeUUyrd9lQOE4vMv3vmdeiCwb3jbX+SAufg+FboXiP8I+zjtylIve/uyKC9wqY8qqNC3howaF1Ex5kUpptwORSGkfBPF99TY9JwUctCRA4vUuh8ozeSTygRKvIGXsnVNHCLdLEzH0oRijy5RklTE9WjfQL+YoToUgsBKBb8BCtH+Ev10f2Rn8COsMF5WQj6APqmjR2sz2Tros06jIJLaE4TcWy3zVP+Mhty9QaN5g7Md0CJ+VlE2LV3EZMPKL2ZDod1yG8FQLrm1q+O7nzx1BkIDV4/POqBkCY45F3Q5F+CW0JPYR2BFtW1OTVOmkJd3hJ0RQzJ4TfQW9f/tM8Jwqw9i3Kh3xUSqhqo8aoVk37D91CiTQeuJpC+1k4W8mwBiPzNEXpPhBvBophY7ZG7+TaOmjydyKb2tnAt+u4p0ciwOTlGlHDaQc3AtRX9fEYZ1ALdQKA6/NYa553+CD5EQZqEl2u0lsKl7YE7ia3RGecLyGnqfdwrSTkvUomhZGjlDKjJTUZyQ0fqQGFzSxyxfDkptup7tYRiC8PseEVwjr1QH9hQ2NQUMZKJGZ7KIUilm1Gg971690h3PPxbhaIXxer8aymti0NFdgGVpV7ageWmC6f9V5QifPeZ1vwiw/ZH6Gc1IQdDK0/MEJX/+BvFuCzA+nxdQGdtKwEnJjppKaR+h6vD0PWsm9icmCYY+EliQVaJV1EvpPBDR8EnKFmzZODFs9Eg7yfy2kKMufEhV0+gSmpPvZKmMvCV7tWVpknAcJ3iZigck1bKL7se0heLK3j1qI57BCCighuSn47D9fDkBj4/axQS6EkcLqJz7jLL/dOzZnwhI234Mp5dnsqXITh3maG9WHxEJG1gIaZSggYQRHpJhV5hSBfZvJIbdbKJa/DRV0bzlPWxp/hxfZBiLSiTvgMOHQ93Mi4S71t9d15SVdABde7lLsbcf5Jb1uaARZVZP0XDuZk+d4nqc38wnedYbHzEx6UhY+AJZp81lX10xVPVx6JQLL3FZSkxL3Osbbfdbwv0nBGcE5kblhaxeRErsgD5HjBMiw8V3uGdqWwBKA3pHVABcah1I2R7pZrkcWsm/C2mgJQ5O1IYUqeCDxxpRjgC6U20ZvejcGeUW2XjasUS9lvW/gHxqtinZjbcJJHcz2wQoTEIb2xEcAYc7P+8kRfo5wAiC1eB0R+CEA/bOI3WEZtlSKTBb+8U1UCwCkSVnlD1Ukg2TRMgfL4Nq4MagZXiM2guTFOaU1d8rO4pK9V7lv3TK03WVr0Dip/cHkzbXwvH7HoDlMdksbgn//oHWYa/U+CDdXy6VllDK6v92knwkqDN+EdH21RfsGP1kxhRslQ0JCS2I/QokOT9IPEfWMdT+5igBuiOZeoECIupuHSY5uZuq19Fu25ojaUR77gLlwXHmLBcut6YipAl0tX0jrrqr58P7Qb8BcA2CaU+2tRPZ4We9h+S9hiKuPveWDkhqKDXgY7OO0j72e1K8IIGfR2qTQ19SBm96NTqBVPnv4Kh8BzwNDCtt3bHjKwRK7ZEjT+dLG9X/Rnkw5B0nI1AqT+q3jkTkRRP56KGTvlMPGF6UBB+lP+LrUDp2SMijh7jabKTi/6gqpcqzIGCkLz02UyGW3KvLunq8s7Hpdmloq9ZiRXVCDZNHpwygfHzwN0sP019EaTWCTqECRpgwfIxZ6wOmCfS+gXP1yRMqZmD688/xlWKlHpx7oDeFEYH/JvVAz7/zVZvvf8sAggA56x6xOusr2XMR/4RK6xJzWh4m54sDuJdKPSBrCMKDRMaFaSJkpXGMPszRY5cDNq2GcRO3pF8HwGIRDpXw7bPtKDxUCqjxjQxCEkchfswfYDM+lo3aRxafr2xXEf2pZm4wgCrsmWx1/JaaL2cPUHXmmLLYEUaIWkIdaQaNsNbnjby6yRF3nw7AJPETUurwSDTjUTzYplLLLtb3E9uW13/13piEKO7TSS7ZmJfKxE2YW+z36rZrSHJgWQgHEe/Dz6sXnRFYE8AN5uOW3HZSqPhGufm3bgktQ8my1+xvFtv5kSKi4mBC2XaKdO3AmaeD9HCaJTSouyIT2Py7fUslMdlsDFGLDIOmK4fEBOA/o2bcglrmEA3DIWaOARfoEeff7+RwT66mFta9tlWMQQqsvc1qWVimANFusZpHGfhpHCRlsuYp5r/wsNBFGSs2qB/eInAAxqIorokPBRkho2QEvzxvu01EfHP63fPIf30VH1ZYSPteXsPaWttqjEiZxy5RKbNtjUPc3diAPvCvfQUi/j1k1OhU52tX6lnwPsaDKvqK24LPqCTn7TydGXP56gnVKlN7x0wRawFghE3FD1tNy7PnPjXg/gCOV/cD5Qml4hG9QKJaR0KUW+waLWXh4UPJJ5gVNvMQXDHTXJwBMxJiHD6lM5hHtZqINTNZlRQE7NwBiFJ2uQYIbyicRNIW/SJq+NCIYyOc/GZ2r1LQru43zsPoCrcrqoGtGH4+tG4RuHVVvpCIGFKXjLv7LHlPECjJR0hE4uVKfjqssHBLlNhpUZpeX3mvTH6CEHaZNxFuJ8uFUzlmXop907/dBGGa8WHv82nnv0xg1HD/nw63xcgUm4+wHBMrojh9/pNHv9RCFq+FXCYN7PT2nBcSifBxwfddFeXpMC0XnhJ7ei6Yz5srK/23XElMz6JCxhm7oF641A9ILMdxN20u57GF1rIl/AAItaZATKkXyrIShBJYUR5/KxGYsNvVwVaTdGL/yk5cNq+W0YC7n6U6HrmA0lA67fNZkVZ1bf4fi50zm3UKWnhdH8uSnP3w+ono15pV8BZcDUiVPcQDH0bDuC0q1KaQxGJ/Gl7yl4wuqcTBGJYGloaTcIff0G0BZ6ZLk0DuWeQYMnrbSzEwDxYTuWOrMELaf7R23lYhIprQoFA+IerGlFzT1AXyM5J0Etwa82hSCuuICivNsgPF5MVYzUupUcI9t40fWzPOOQm2WobI8IJsDXXhMOLpkakUJcE9aAKS3geSYVlGiXq8sXppFRcwKl7fQ43FUwz8TvOzJWeKsZSW7DEZepaSWX2kozJ21OTlycCGBDe6vnL0RZdEAQ+i6eLRxO9AVBMe2/RwpHOrKOAlDm05NekqVw5/1asDQkDC6R49rbYGJ1WGKoqdJIJTKRds+zoOS005qH9ddlQR/4xSuNsjMpPixn+eIH/owJeZEV7RGtck/2wbWlDyLmR4MOADMdlvGsdQxS4YwykM98dy9/gmH8wJLxuweWLVX9EuJXp2lrFGlMLDc0piXPJrjpgQUNHYFIgnWULVMFEqfQyU465qTjOJVhirG+oZkTnB3rXGYzyRUgRGW0DK8ZGM37hVyoNLgNEzk8mDp6mjQEMI/i3mTl3frKQMVlOsDyWGA7zN6C6HqyhJ4qhC6mPP+KNE+bDK29o+1MK+1H4MOiRmuRt82/lROPBeBcoeafEaSHVcja9NEL3zDOzwqK+3DVuzdfTSnCgFEwT6P4IRv5stgaqiycz9cYOuRGntMGHU1NICAB8oDN0MaAW15ONayuHxq3gRScfk0GIueaC61ev8iW4COzicTY5I2e86FQLMtHgebKpib+rwm0cBjkQ7z9Zki+MBsGpm4Qmvybh+9i2j0e2gYaDiXWzNmYUbnFzRnugwiexHmiKHt4LxivUv0vaOHFbmILdlT2f3AKEBqe2moopi/2YdwiIlcATDhMR4yCnGDK3TeLkkG0/By/8NiVbeY1sA3ZQ9DE23m90H6YuccUsi1wuZZ6Drww0Jq7GeQEfT2OgfP5/p7qweXps0XV3JdD1BrcOHxDzRk7lneDkCnkGP4t7DhdUFbhjzJCSF16k7duzi7Oii5T8m1Vux98hE1dhiORcHOxfgbbtM/yHujBamzA7bJCL0RtImysdD61vS6ClC1zUuz8OxBxkQcuK4SaBEDdTMbTxvpS4nqD/KJIg8LQpB1sOOdKPjkvm8LpHQCVeM5JV8vHnUdgdUIw4F+AYZw1Sq3Sl04CaMnqxojdajUSHEWVmqxrfhILQxjFMeeKuQQSnRwhZ2cCYTVN/Bb5X/0Sjs0xGPfMgI4Usrop4gBXaFRO0J4k0YyUtmUU7XKBSImrWcUaCW4UeuJh8VGFAyEkO3QlZqq4JeZd8zK5MsiyxPy3/Rjrx3ifAnRdcfvNdkNqZpBoBtlw8eFPjTc+P+3/Nom+uETcLj+5l9whjK/oq+wgypLi0geZqiq8hY4whJVRlXKVCODVN+jv9OBhmd3pYLlve5KtiO9jti/NaVGpsseTzfb8Wc6bbEmSrMFcCMF8IrGMmcuFQuduhOocpEf8nf3Z3CheKU5BmdUG4i3v9ohLcWi2ozkPL9xammHQ5H80zkv4ssG/1E/H9z0WuQYnV0DJl8BuXaoopmct3uwVImY3zX9SefofbiUSHDI57qQHJitLTy+DRXK9JuEtjjf0HcIuTwjvSgtkYQutBJ9axWDMIO9JuARSRuOa2VuSmMsFY8nkpyzTa6c76B4vPqtI6IDr4s9szZOZsl2X1aZjIrVWMQQTgKDVBg8SRyayDEecPXUIqVvt5sABwhMCBqdE12dpFoFJdErvquXwpX4EK3bPaQrO92oH74BQec8QGnFZhOAPlJXmBORl0gisv0niMS+mhALiR6wlUUuJ+Mg+2KdYCrUSYVCzvpsQJx0uKGbDBJhF6dbPK7uyYwa61MFD33Sfx2E1RdAvbPcpbLNgfMwPnyJc3PvwSQ7n64tAwrkxZKdE3DKF3e3yfCBJGIdNh/+FEytYgOT50hoQSJLup/wCafsaSKCQ5ZleRrqBIrBSgwJwb+xSW5jIdFkGl2JtyEPlAtdAJvssrcAhO+eCtGIEmqeqZ2ZFCLs1sSowZaOW/8f6wwwad8R0iz+0rrjim1zmAooCHTH4YZ29xZ/G/Lz6c1ZFOZ3OvnM0cpIVyNcguY8aZ6zhgom/yetyTJ1Jwg1TsNra/ObbHy9L3vj9dhsjlInyvEQyf134rUYHa8CuzI8jOeUJAYek+TFUpea5DuK275LjkLghC5+ub+1RDMgP9eq89IIQBI4VlZYfZ8iWbwn44O/f7IRiHTGUgKuiDDBUK3y/kf1rkgFRE9vxrK+QPm1ph/XD3/0R2eNNXarrKa9skApRG1Mbv8SLjwh3FgKAUgS9/tqIRQJtyaM9f/aijBFGt3pIxBiHfZpmR+BeJmMR25u1kG3POe8CKY1R52mW6hiONlVhpxRDK+c7GVZjNZ6lSI+z/kv9bHh8N3zIevUtuVIU59zeGm5vtG8k467eOAMWTITwDLkU+JcYesn6Rmua+Br21KiFwqbtfr1WtF5MWiQDUiHF1FuKhK359i7Ymy+hnDWPNXGQhg4z1a3nhQfMcnQUbFL0PMDRPulXwjYgn6hkIUEr6yNlSD43jPxwA31NjlOMHJkuxpptwqElkeHVnS+4ZUnM3ZsnA5lSmHjRo2iHzYlax3Ktve6o67qz6dhlDu6YSSDMz0NrHAIcMUTpa5HHrmyXPh5EcJ9s+OrsFVK3EzX9iIVUzADX6+Zm1I3nGRz3+snPsj3rqPkhtE5K3WVRidIdic9tjtjInxYHcnh3TPg4sxmb7UdzFmFhupYietJ5fFApkqWP9ClL6TpcEK84KnkqELK1L9sgivFyGE+W4Zs3ak5eNIV8dj8Mo4p3I6T1fKh7nbSXY/AbhYKJxXRcLNEFYV3/lbx6ghiTv/dmwkkfCrTZQVmOR0w7LTl3Wrd4HdBKN0uPHBEOIs/VZp1W4WvdPbzXMt7qoM+5qqBPlaDE3z8lv3nmuUHNU73OLaJ8AtiufCUE5XflOtRoFRlbUwzQFKmT62lIe6HFsS++TJkZHBk4fQmpE6JyyMplA7i3Yh6XFaNdDeKnaeeku/hdxUlcvS2JmjFo8LRS293/cdeXZhSWs3248rijhkZILthBiNLO/h5fO2XEN0ijuiVCp9XTEqBB5EFJ8kfuK07ylY6mhyEUXqU3bvn63vEHh8OhteAyanUXa4c6/pPjovhjpCs8JMenKBV/83uwjKmeFidJSOBH7rTD2zlzlXlQtPs1Gwm+LE+UBC+YlOAXQx7d4Fe8HWb8MyFFTDZL4bY6xWX7mBysu8+L+piod8dO1BVz7t9IRLm3VAWKRHVVHtX9JjbA4B6vJb54iMV1aVMMdIY+5LsuA7kcOmDWEIXo4/+ctob2IzZtKCyMuLS4VZqNdkqcP/19ecqfXOJwnGTACn4/ChsIWzXlbId0pCetF9NEkYsEHpqpMKIcVh2Mc8hq1KUPWjzhpY6uXTYD95z7sDoRdJmsFFBcjm6lI9yf8LEf780EYvSzlkOJAyXlf1c3sjeyAaZfL5GRowHj1NqhsFxEIZfapUo95be+K1ZCMqkuzkCO8bMTH07kasVu9TS3hcp/DFy64wppa5kByWKq4ANO7W++zeqSS4NSrXOrs7mkVgnVyhlRgZKpE1vPaUgFXCsOtnpjdGqezgsh28FekH5PUO6/qMK/29X5mJPtr7fRry6likqFDpR9Fxxej14iP4SjfxRVuBMKoBV5g82jKUKal7/65qA791uG4v3focLe+cXXiHhbW8/DEg+xQQ8w+26Py1N/jI+PwUPhb3+lkDEwSVugTOz5cPM0XNAqEeFxZSc7EmmHO1INHTr2OmuQOb8lLd30rwm0xZC+OqiypdrFvb0/i4rTFxAnpsP3Unnen77f2vpfjpztcZ+g/ekdZcPQFdiIefmxxPkYdjRozgjCdrzjgRLbbjTpnKLICWFvBd6lTuIAdN82kkF+j1kkqgdL1uCnPPvLhPjoe9Z8m6MeaqNfR09w44D8ZuXLzSledTgkQm6MXSnsUuCGRnDj7Zw7AqGV0rwS+yMfaG4aB+ay2Nfxt0c2zQuXz+6HC6s8VZHzk6HGVlM5t+A1/YBf8DEJj6lsjPUv7sljStf8DGKDYT7w5W2oTZ5rVa/pXYeB9QA2m0jmBzyRPDVHGUG1246FiOnifIErLndxSItgyD0lsEJIZ7isM2DqSTa3D9iGAfoRA6npEVTxKrosd/u/Pv0OFHeoDXwYBxTae0Ms5BkeIDTDOPS2rlN/F35FyRyRJUpQ9WSlC1xyFNsvO8NCPK+x2CcUCu0dhJhMm1WgyVmeHmJ8vUaTLuAdM+4ulzdvYcUHkmqyn52D2xK397ql8DEugz/2hy1V1tLgUyABcj3pdsOS496s494iSuqMqjGYts+jPdlIQA44k4H/SeVAfM9TJWqS7ak54CDPzI5BjbHNepNjCGq/5fJ8H+f3a8OylXWAQCj7lG9MBAsry7w9zUM1TS9KPR5nNqINdEPrZM74LEVv6g5iZjO7fQRLdZtR5pKBoFhZsaANBqWKJZxMfOr1KaPHoBej0Mj1t9zanWQqElfOG7INyqsPglY0Say0D5nLTsqGfFSsI053RJoZ0KH4Ky8haLjL00/fPrkSdGah6+hKT9JNngepFdM70IqO9j+7snB41x6NNudY7+UvrQ3lAI5Z04nSZzS0WzJxoOUYMRIFxxXnpB5S877fR1DVZhoR7AWpDQNIScUkQyZPA0Ti8sL/wXS8OAkNVB7V9D48zAgDM5EKdSk30tmCwQxN7l7VNgZQI4QD7GkPkygyoqdwtKi5ZIVL2ISbqf+GbWyLsDsU4rebK/c/yPr4jEZoYDPl0K+sTPLdjasOIt8JO1vSK39vlzhqerISthanGYxFvnaNDuDA2zrvSzixyPi4vOQ2LbU/WzX/k0PzVYTR0FXflwar0++oUvbB9JiVx1taKh+z+OX0VHX7X1grctOQbNoFEuea7m/3tQBriSByR2Nb2whXj4lXcd2r3m4yeiss8I+aFxsRYeMefQX7S+KNEmiCzMWwlZkU6ttG7xRFZuZAAMl0NXmuHxGxjOMNTpCakSv1ZMGtdHLfys5gNFQDPQUoqA8ZM/Ba3rTiNuokC84cxYGOmeI+rgT9BvjqNkhqeIFgf4VEsNREZ8XdDe1Xw0FpWZ0WFpgf/OTFPx2cjOh5sWNgo6z5h0j7gqixksuuzzhrGcEgsXwSseHmFtjEPKlBEXCOxJnTxuhWAmkWz8WmdVMwxwKf1+7rKd6Ol1cBCECNjagt2yI9ALZOkuV6slSkpPs2dhLpEBFYpN/o/hoNp8S/iFM/hJBy9d6qNOgCxg6F1xk4V1sopHZwNnAMfJ5Mais/R4W288EEIDtn3f4y6/gDOEmPRGtAdTPULk/ZoTHInHvwC8olFXgQGE1c8nD+e2x8sQhcoxSbc8tK3yh4Pw/kQjM6020vo453DI7sW6aTcy6jfACchN360Nc/oSS5hmov8MG5PtDwx0KoWM929lArjypCDRVyNAYgceGvQJuOQBop2B+ImDO2JbXkpoA8/xrMf6K0ZZERm/2clZZnEgQZiEgvvBivGXDgPD3sUIivIkF/T8FOgxrj6jP94YuXJt3+fj/1gHfDZCbPMYHuGukrHJ6WX/p3mtVLnAhvi4aEKsAeNJqEA+LfrOfw7IPRsIHs5QKxexdeikiIZHMybu49dj7WeTXBog2xMbr9MB9CqhYF1Ztekcouv4Pc8LsABQesHk6xg8o2WuW2bAWhG8eedTV+tSmN5DSmDkOdt6yCMQMY5RR/6rqUuW3mvZHJ5Thx5Ch1+VwenAYFw6Ve8WLNXHp6io3hEkoG19keCOS77ptZLl+EKdPTW6ydq6hy5dohm/CG3pbXVZYkuG6ZRDjFerki4WWIA66FV7aPP5T8OeKxNdaxEGHtlAmWBGCDSuXKAScJMqux8FLPxwOwm6Miy4Y5zmaVgFdZKVitq1Dmb0JoZjySsfR7realNDS61M+2bdBfZCz6E6xUNuIzPnftZ+wdifbYNMQODz7m5LMShnWdm67GiWvT8LnO76mvrpRmf6R6dIJQ8Izg9kFGE1YIlSwpmgwDlsYyG++7drdPKHqMKWoJ/yiV+ZSQSE3MzXHyr8NT3TYDAuNISuZTBz36CJYsn0fSCsgRoQnSLET4sqhm5hf9NfEK/9lvV5DjN+X5X1VF6Hz9aZbqm0qwn2zumkm551YJNgqcNGLVzmeK/E7eEBWovx0cbnHdrzHYcbKtTSrRdljSI67NKqlFmeU8yFuJACmzyKnc1p24UD0EcKGoz3K0iG1yH4M8s83LyTC/a1k1JaY/7206sfuPJ7Qo7aturydrcazQK1xSzPGmKbUsybnEBDrfS4D0eu/nwliz9IPpOgMEu/p4j31qMhagxnddIyYduX7ETSpAyBdXgZioHsRZbMX1ixg20uYWjVlyP83SZY/HIMM3bwwYy8ybbYUXe+KL7eNeBzCkS3J4w35SuarwnvoOlmUMEiuAEB3a/C0YPjs7Ee/LsV+9gJiLbIotAr1cHy3PPt/TZ0jo7ncQ6ZvXh4Pr1cNFDDCuu3gNNlo1P9BREz1ytlJk7olLEuunblqg1BI6BnRajF51mDO66FjTgEiHXbgZlgeHgiCyaNLlNaN2zOA8eYrWC0s6djotrAhf4JZB0Scx97CikQq9PCGY18w9jmfXnarAqHWfjSnGPNhd/SWcJOCCyZFyHkXMPu2p4Pr+5Ou4x9dZ8202h8fXmeevRLRPoMH972QNVdoGNqLNwRZF6d7tQongEJWYj/B1xD0xoaWjhLRluKLMO/3Cd4+o9Skebx07uT0bmnV0rxBnPI4X/gNVYHJ6sPReJtm8Na8mKzG+cCsZuAIcP4pUKYIEwHOEkj3tyksyUI713s0xc4wDxyyQ/AHtQUOM8VBBDs/M8d6jm1XGEnSL2BUjO/PuyGUf0nlwwT6VDbDDounB9rq71ZT6uY3k1Hnsi6wKNUhJBjFTjnRALbmug/5gI5zcYmcju7WxMRGEkoLYST/DFgyAeQuQG1LoO7bUlvVB4+2aRs3L6GW3q1GDCjQXWkum05ztPu7hVZ8xONCvgLno26d76d5gnwJC5WVo1t5CoQ6upR+GJPfeiae7cL+/aiIEqfvhR92UufJhQR+cmbVtXYrJgi5quhIgZ1w9h7aS7PK3jzoGW4m+jw4Me1NmNIo/myRYyiX8pQR+HDWIkXsDUPNMCzchtwZPXw2FEaz4cfJMqL8kYVZ9sFLxLSotmlUV/dFOxJFAZzc8Xnxwb3+egktm+2lcUPaz/xH/NTTmglK6kdpV4y0eoaR8cXmdoW2LfD3pOyZxBfHhVw8Xbv1rxoEBrzCQ9Qs/SW46dazS22YqLPeZpxopF+ZHXIo+bRopijZZvkxb24F6uW6ZaCbr6JLM53gNRwiU8B1Wyv1uGp7pVduM0tvjirc7hLKG4Nek+ch//OGe3/UWYoJhvYLksGgUwb5luqwVyMLiTdnyjIuyISA2QyRVffZJQsCrn0pXuEbEUoZyhjJQkrysxhflsZpBbvIEd7Iz85fFQmfehjaBw332CRG3JfnFMknPsHK4AE7v8RTlus0DUafpHCVGIz8hbmu5oeW/NCpj71WsSB72HCDw/JXyzorJ5H08FP2ULI31n3b5Web/ZXoj32s9KSXeqPU3wrag7m562u1DE/AO2lSlgWfJ/7xATVxssDsb7ph4TNBzoV7h2K4fVHmr1iiWpXGTLbLy2eV3yKGc/OWwwVsI6MJlwODX8VUN0uZRVEYj2e8wPmdCCZP+1JtWZ66rNSTbqqRB3NihVyTWcEQaWKl0CaFbq6pKmcRsUVh3GfHVsxZq+8L9Uh1DZxctry1FwsRs/2i5VjW6eSvgUEMBNopERZwEM/HgeqTGStDaNGb05oWcUJoXYZTdQlsCkLC5yyi258dmbkoqpf42+Qx4eSIFIt3uIbBLt0PiObmoxcT2GIP/JShZjMzMe3Hr0gojnImRJLd3SjPMvUEISaI/SzD8C5l+czVIrIL62bZcdcAFti3CiCkzqQ9P2rb2seE7E9BCgaxO0VkUqlHvWUG1ekSz43yE6qfNHMAESicmM9xBDJ8X17N/XABswBnatMdfUqZIzOygMA5BYqk7RSQ7SNqS/2l/W6yGwvnkn0a/Sz9V/0ymG4aGVuzI3gois/glZtBKtmvP3UAHlFQXeMTBPpfIRoygzVVOCGhLNbPyjzRj6Yma2jGi6YkGL6SEcFCj7xvCFhHy6Fx1y6JLwUNQrLrv3RDOp5sQxFLNvNJH0MkZK8Eh9ycDG0RWHCeh589DhqYCTuPnqc6RO49dh0rtbCprwQUpbJYxTyqF4nnpcDd+yUxRShUMwMGKHS538X6KanYmuxHkSSXh+oo29aMzWrPhzDfHFxZsslpyUn/GRWSBHeyCs25Kqz3PI/1+DckwlN2YUruVK8c/h2UMs0dZQlavbxNd9fCq6AD4TceT/qoq3qHmQoZLe1LJOw/q2CxkAvZ1vAlycRIIkgLMDQUvjHnHUXuHHDrMnBgXR/rBb/s+MRpyLAfVagx5bj/8WeZfdeqVad+75uZkU9dB26rKif+dEbOt20ofj31Us6lSOcpNqFuuvS3wHh7ZFGdNRJ8JN0WeHCPIMSE2W/ujVYCrLf4wYfW69lZGogUYsgkCdK8x9gMLm0AFoe5sk2U9IGS1T0JE9dvGkNdeVyqA8tuNR13N/y1qcgk5IPoFFk74ClJ33pUAFitiAxRkZRHCpM95OeB1JqVp6VFxFb9Ny760aQs0zWBftZ6++cijeAICeM0882tPDMe9SvVXPCHV91bADThMxMgaYyuwIxY0pjetPKfGND6zKzdp2Sm7OeUA9UpnSzJNbVWN89/09JI+UpvDr0gwvcDB82ZYU5YNFLufnmMcezsYb9eLVobdfulGx3gkPdnOeLct+4MJvVp+23+nEO8q3x+nZxGQnLC/lwo2xbn9v0pWhR7Xaj6bjJgHbRaZUXZiEWUbiEevW5Rifga9hJnMXiucU4f10ejX/bLwrJxXgkmJM5N5VyXOv6pipLMu6nMrIgZfDulJlT9heCYg2qkRv2DteExrAuj4YQbyHfZCLHS1vUatgBL+bl608ONtv3rWHvlVdXcGEKRgK7aWftwhIIPLz+DNmPHS+J7IrtLyVyl5WfHFf0HYLFBETEmFS+N4Tub4XdCl3JzWG1XT3gn4eWnx91hpKRbajjBjHpKJfEtfNmH5cgGGtThI7HGZ1lvTS6Uha1qxRP/dzj1wSmtfJbTZQ7CN+XsWHdofFF0/cMFWS6CGge3CMQS6Jfp5g4QXqL5XcZ59NxuRKKeNjCYTKgt8bRUTcVloQP6sQ+d1xDnqquEjTJ/Frw07WnNW6nPjtFVSdVaE+iojVvTBl/8Pgv10jkqiDJrTsq1agX/VeztfnDUp3ZjK0pBAVWOE8pt4KoiUfpZw7LLH0d+nHZdburkUmH3g/VYow4W0FyBQkT0KOKMlMXSxO+5S4nu0fOHtnTk6C0msKliJjHbb+CKbKCPy7j1w73QSd9Y/sn2uXuV8/77224aHRbQveT3SDFntNeTWV3C3Ncga1rXqX52VJ5Oj1MBU411K8T6O0vMPU1uB5y8mDnwUp/HVqrb8aMJ+GUsmdcxw6y9vtd6jTlzDYgvVLjfql1tkZk5WGHLwGSQM/oUoEq6N3dJAayEf2LduDC78QUNQOe8pqXwwSMmIgGHZi1DaKhbMVsXL5qsVZbgHagbsu4gXX98vkzKF99Q8Gz4mICU9mdjwKJWoHEYFTBMpZWPGD/hyKK9YzY7lX4Zv5meDGi7ZW8S50g+SM57bIQ2gxSFOY5E5zpu40aq5d63N/8u27S8k2DNLwyJqnW/I+0l8h+lhd5jsm0XQuS9C/nuRBfRlhSUwusofqZhpR4CByAsTVa5H9oVBgtRluFcxs9qEOa+UE+j/YM5kcwwJXAYL1y0d2mEosMWNh9hx+/7FZriCL3ABFUlE1A5FwO9K5dQw+jkzwa+iSOP6lIoUOD58IG3BlTzsP6Lh8QJxteCaMTQoNys8Lut4sQpgzZpdgBKZ+eHU8qHKtgm7iT0SK9Yqp4R3jS37HZbfb8YAnUaoyv9XkDpQqho7FnMU6euxOdXgupWv/zFebX+Z7yTUIr66Vn9hRQh+NRUvaFb/w77tAbcXEq5Cqx5VGfV1m7GQKZ9eiu6PV/sKk1uhI3IlCeac6a63V5t4IQukJhif0FZor8578ei4ZxLwdHel57NTA1rmUCnrb/IoIsY95NgnjRrTO7Rx0epJVSyvK9iKKvRRZAutBhw3OI8/J3sgd1vsySa7C/tZdS9EW1z5ciuktQS6Bg8XJG+/saZiALkLG3heZfuY+X6jkUseFwedc1dpofGNb5W8k/otqhqP8xJ2gzhX+xKMjaboWrrD+vr/R5VQZowD9LbobfZHU/H/TIiRfPhiTQ5IoBxyewV0L89ZNivl3zS0swFKo3rU+Zr5Zfrq5vdlC6CjcYgZ9ocwI4vPxZdd720AkPesEzAJgEwAbAiFt4KGnS1NqHaCZoMK6It9aNOdeCdrHRpz9LKRfFOZA8Ax407EluqxQBxCCuLLUF2v6LlWRFk4Qob4X4pm0obkxv/rNao9o0G0J24Dw5rdi/39X85VG/NWoOXbUcFex4/Yal8hgtcwvAgpGSDTwrWbV6niZPO3K/ARUYUc8NZvmKlcX0k2+NvLwbf01RZIntqFr2oPfXwMyMZEbzMDCIJYJdO/SxXGbxDlsJ8+SV2nBvgJOb8hDBSTVR6iIg3mKKuCBvOR4IkERksKVImLKkeKNqc/VAcYtmpunhrE7PQ8qCUu1Oai3ZyBq99aPx/q7JxfKpIPitPfy79VDF79XkYv8zqg0ow+T+rA5zPj1yU6jLSUv5VKeM8xKg/Ie0CdPB1a9M5KGGmU+ACRUIshrTVjamMD7vsgpatUKKDuPEVW5hAnGuDl6cFsUoLcGPnIp0pMV+g7LO2MEldC6z79DH4j8teCosfY+lf96zlBmmY2ZKSc/vSiA84wsBmRSA9rmN2url7kYIVv9Xuo8yj8kWVY0MiyRuzzqCH+1hRxhx9hQkHESdNQLbIWiuJtt24qlBU7UlEXmGb8B3BFJDoJ2/6pAgsZydBmcV6Oo3nvaMbLX07dOm/VWGMxFsfYitjPErHdh8ArIDgHfcs4eTRlyPfGTocV/rhhLWzlbx0oPVBW5bP0d5jPBu0VHm/UTME1EIM5dybbzQ1Ulv45Cfu3yjGmQ6nVxQH05Bkx8tNQIhyxYy9C8wI8GOKIwQlaRrD23/xIqPO7r5K5rbf2LII5GKtATaxGGHS+JXro3Vj1rx4eHipzpAVnR887e2bZSz+MWOZk7mgYTEYb1Z1R1a1XFeqotMCTr1iElde20yiajFes7eKxWC+L2llJVhK+Hrehh84r/nKJBW4gSz690Xrs0jc47iNGZvgjIV4GA0YSWogNdA+XZNIfMpHZIKOMlhzfjI1V00L+s2D+HK9CP0duLd7JCTEdOt9c2CHbeGJ9BdM0PXYzh8L6BzbrJw7Iho1YU8sa89j2wYMhIVq4ofvpWg9XybAg3b8xeyYPQ+/TImd3bm8t5rGDZrgZ7RaqMLc9vGM6iVuCR1xAo0vqWev2YIZXluqvt1bi4pahSz8cio55mIBfLp3bdNVI8CEKuN9zlXVq9pqVGSpVVgf3PDzrziWpGXpHEYf3AlYr9tiZ39Xf3rrTMddi4zPCPpgamh9Lu5SCb4ayaQ2p2AFfEVTf+lFM/mtAmjFsJ0FcJJknqYAB5i3jaPguUgNpm9p7I778/3XVu7+PEJUO4i6bIxE58JojKAEB8ql28t0DaeUJtiT5kLh2JKpFDfmyNMnlvlV30Apnv/wA/SZkSMD8361i26Q+tN7w6jiNwIV3nyK3S7qNa3Cu4U1s5i0YclW+p4eoeuuFiV+ZfbnJOIB2axzSCAoUIItD+GkvH2yM8XnU3PkGZ8GOcfL7b9jGCbMEB5qMDPrsdQEW2WdTGH6bR0u4pNB+pjcx/OUiNbiBJMysmONd6H6g3a+iI2KhEewNmUDs5cvlppIWhZ7TnR2q0LfoX1yvQJLab4qL6SUZJqpfkf/M5AK18p5icthPC1T7UTPKavnZlqKtGgKXTq/Btx2Gx5mgSn2p0tBDcmHvO2+s4N5V6uZujKmm/b6DDRJ2TQUv1qeCr3L9MMoqNwQaI61GJn5IhII8ZcRjn602p85+GCLwu1Cy8UDAIyJKylvij49BQutOW+44uTf3qhYVMXiPI2ZNghh9nSMNo6VBDE2xSM4mGRBiP98rL/Zk3XzG4YmbKzq3/oj40DkzOZQtjCQGTnMpiww04SW0JPPuPoKzqXG8u8xKVU8v0NfUFFQTvZuJsou0I6YCzkeSiNxeHHM7M4wnXGM0ZaE9bOPNXP7A8ZOTvLiLDjXr33X/95gOofm44Y5zyfacBbCDDrt74/Kz8KfvHyChhVN51zuzruJtmKWJxWyXlu96j2gAlgsd04InNGYCU6DQUnCXlxrmjcrnQWMJVVPqHo9MdQ8Se2XheajQEN9Rta2VwYj95VRiRURwqD4Z8Mu13IPH/hFJ+HGGFxzxhL6pSEJe/8fE4nVVVdPdfsDS2G4F9vCLLED9SHezAyM+aUQfPd/N6oovTdiDwppl1oA/V3ogr2GDwBHkQQ9O1Z+LC7yC8J9snMFQDTacxs4iDwujgQAiW/yu4ECsqrZlUzWdWQlWvQUfeAhPB09dXA7mtOVlw80l/XGia0gpSV5OnpAYCw75vh68uHek/dm1K/brK4+8rQPuGIZikGIqzX0TdXnPuHVh90M/ueY0Qd9tSssFQy1kR6WYjnOT3p5QrS3cYMjEVxEDiTAibvbGDABwkGKcCN+uxSmtHfQDzBpEJjKEHB4A/rkLcl1pHen6fjaELPyl1wpx0PbzVCBeUKus6czAe6AZI4peNBg+lYmU3Q0/92HKWCzgp/PqOduAU/qnToawIWiLEqE+zIEOPz7hbeTzr9uLEMhRmT+2f2gjn8uHmdEGpCm6smavA6wWUMAJ1ns89JoQb3eYCYXjMixKE/9hIZ8iI0WENQNHMsTWn4wr6aibyM5UZAO2x2Pn4EaFkjTU5aXexIYR/xqCvSMGo04lhKTlXoUx68AGkEW8IXrZyaOBm42T+1U1OFH4EI0E7MVuhAmI3bGTv0tAd3oj1HEquLkwVLa6T0JvdqK7wtG4Qw5HSdcgDUyujfhBbZHHTGAGYz8TxWy4G2yChbJuz/DwevwiOISN4jf3803O3StTHsJYyHXjyWoeu8O8lN+lq8WqTcchO+LEa0WGcq0LK0cZLzWmH0/PayTF0SRgH5PCCTTtic7FuV6K46yedsPS8dzBsBBYrOwlq6dBC1BEH3VaAU2InhRE2nqrzlFnbH5KLq+raWvM9d+wV9t2e6zlVm0uh0vegznnBTMlFigDTqjc2flaYQmfWivSMf+1BZE2iwaWFsZ7WJ84Re9I+iTOoxHB5aKt6Kq1rBFsitmwqcGga4MGhTnCQ2f8tgbQln0ByqjDHtUgvawo2vKto6b44vLL3fHHlr1PVNHB90zNWNw1rOLFM39Nd+/Lpo2ZvEjnjgmxmao8DRJijfYF8nzFI+c/gBtcCxfdNM8C+LY+5Eg9/FyixJNXn0iRqrha/98TNsNOu0uh2FqBI8fJC86QOj/CCwpVJ6yd9utLu/qX2HZ0+ITfZuZ40dZNBbXOGRGDFR7jAn5Eca4yX/FNfs5vmuoBayM5YzQVGLn5CXEQnlJ8Yy5B+8vphXL5pKwHvCEpWfYr/oaPHaOWDiz21GpOayeXvJU5h1m1RdOsq/h2wQni2OwpB0/jsYYYOkTEd7mF+hMsJh3QxtEp/eQ6MJgLwjlPG/FZ2nfbxbhaIuNXK0iFrpnyM45tpVa77C1TrBlZqK7cWb354hkq0hFmKWpzbJpTzq1WhdozXSYVFHKukqim58z3e59BbxC5zkcj4iUqt2Ig2SymSQmfjG/sz4k9oHrhxspJvXM4VtUpBXJkfsoID6oLRlNyorDPAZzjSlvio/TWnTOJ1T+TitUeTUAAlDgVeV2jDzqKUVZW/kXfWBJ0YVFcW1O7R6+98obeX5ohfPY81UcahFg+xiowSyxB1sghBwaT9lZJ8gDGSiDECAIbHDNwfIJh6vx6lLE7dolrGbNb7dD0QwphhkgQ3bBXq/YcWBixHbrUZNzDo0dyRSahK5ZfIZ+7Z/rqSIhzXaeYY8X6uqslGadGOVsdkIZ5ljWMnGp0u9KguR3MZ+B2oavHL1tDj03fBQFTIF+TdHsr83oNvSISATbjD5xNZr+XCf/KkmClXDAQwneiD/74s4r1NfyBwji4rsXB1kNWHgR47g/9g6TLRatDeEnIpbBWZb9wN36SR6wuVgKt8s3hKw6M/av/ThMt/iFQ1rdsi/xW5dUd34JCuU7leneEVwpbNGj7GCWHeiOtjNU90MLsJjR3MjFCw9aSzhKd/jQGfYmaskBxRRnkDAFDT0t3dzINc5xYPEJ5IJILDemmAyEJCI3k8RGCIMQ6G00ODQeDrswakNwOJ8hXKbouDG2VHfLauP5qAf2u3WcZNOHpUsoecKn9y3UkpA88MSF0JdvQblLZhkGST1hY1CV/5uXXfTy3T4F+BDCcQmV45liwBCbge1dW3pi0xcny3C0BzYLuVZc1aC+5CNEY7M6jQnBE5ufuvkOlS/rOO2brc2FFXOsci5+UEu5Su64nbxlPeZh6nR3ENX6Z7GeN21rq0vnVTxIHANS2VbgmsDBjxAC+AhTDVceiNfldrCG4TYU4BtWyUEREzW/zY2fnuJbFSwicbV6c/7G70ywrZnVcqarJAAMy3xn+XcVYOspmQdUdkq4emkUBazxoBmFECwikTDPZMANumLXwKDjsQdNnAaYZlHlvVeAK4NwoOLDC+/a9PtyWTWiadzLGEosNyr5akj/h0WbGkCK2sGuRRbxa03/+PdZ5mR8PBkk/XHK++IhT/LyxwDpEb+UXbbXKEg3jNryg1g6rvrjN2ZrkPSBpQJZ8SPwjbUtF54ImamRq7LyiVy5YH59cl72TmniJSLAwXTeOeJkn47FAR0iofpNZGlUISZsrZt17oEpjkKV3LtqZhIAjhOWWlG57czd7di3iJ4pA35e5XkuXA0ple/jHzSCXuIScIOvM+MBB4cuBlY0qnyYDbMkVsfmirpZoZ3RpcRKh2YGBWQxA0nxa1azLNV6DnF6g1cTZjnK9HaI9pxzNJ63kyTMUm55mQuR8vNHUaeQFch1LD63B3nBjaoUQBdkDnfUzX8BPwuCzSyLz/uDa3EQXqe2E75D7AW48rT04zY+i6ZxUyybYBMmMIhykn+2jKTAe2MCNY17EnTxruepOa2BXGn8gSKSBxRtTpRixI0sT3QwBFCB2b0wjk22s6vqpEFtv0utaIouc06Gvxel0cYFQ5it6cEsyamzLfHxqxhJd/ZGpj6de+H/fhqyraWcPinqD+eE6xX3/y/7cAXDGLj/U/SRZlr64gELCVRr8eisx3laxWbNjZqGajzFWQpvtTBIQWFqEMyvBt95M08CztTLbYQdkGcRMpacdmax7KCtxUh49CUX9huSdxxUiDGoK449UvKKqUtxq6eY2v74c0Kv5SQ4aXPuNRrOHCfyeDgeUdZyan7kGmDx2aLsjLoU2yXq3owXeFj1Tp2zCQ6OdylDPIyHHVRark8wCLCt8AenK6RJpAAyHuONADvbOwiC45Gn/eupKMJSV5VG35VAfaLdj2H1EgDXHkbBBcwnqtqB/742UYgR5tQoLMwxelw8VoZ1Nww+e7Q4gGa3+UVgZSXaQztixYZxr1cYL/50ebQr2Lhkgc+T6iaCEOrx68dxiI99x73p+0hF8ebd4bE988A+MfuEtAI0m+RyhOsmhI1Noqg+egOLsXCmK2ZxhwtEewiZnFuDqkC9Iy+STSTWO5uAV04pqHNAvlLfE6JRQpDAy7dKXRjVKrlQ/re+HHLM0qhq5e98PvTiqo2x0IE073z6+o1xPf++WiQj34tYp6V/VJjTQCkkEe7lYu7HBZXgFZTOjGZNJrA4ywKAv+90sQug53ihSz6Bh89tbnbQLSo91pVr2XcDDNVnAO3p5F6LTRSCmqV/FhVatDnDOffLsTfN14yUH0t2B/Wyxg7wvH3r9S+npARAjalem5eOBAC8UniXatnKlQJcMBaWES4ihWfr+m59p5t81ZZyAUMHAK3oB+mYsZyhgj0IxQ1yrdNMgoqQXqe59dbfF623RepBouPUYnJg8ZyFtp++12soNQuA/bzhJE8Bg5x1eWZCUKIHkqjs7mBTh7P0FmBUvsYUAVYfDd8zcaldldLxb+SFIqHBluiMgIcJrWSc83pM6MvwpCF9Q935Y0Xttb/jU7bIhX3g6o40EJBl0Ngb6bOc6foTFIu9YC6ssV6+3MyBeSq3URMpN14qx+nfbsY8D4SgGJpLGmRGxx3dBjYJplJSjiVeCIqJLD6LBn4jfqdnV5peTqMcOtWwmNtxrCfbdYy1T+oKZmYnGF0IKvfUAr8e2l6voXCK1GidBWwqJOvUHwRI5O5OZgWnRiizohF6c7WMLl1Wa/FW1bCm2nO31ONPbebDm/h6lnyDPfm+vXcUezJs/qyMoyWgyG/MZRj6hPiwMBCDzA3DS1iFRrU5d5UwAVaQT40ft2scwnPPqTF9H1lvUPc/aGYLRTU9f1SUyl6E7hBpIRxDpvJMOzRnBHa+qCuuGsZVDuDGV9QC2iY+xYUhSLx4nBIdE+umcg7KVgXmm2LH0v9EA89b9e78BWnDzKVGIOdTQN1dm2je998KVrIoVmdE/vMYnFRcUHAjwECfmwSI+1FF70rUL+Q4HFggtpt8TM61eK1kh24FlKZcUebzBGARQH/S76PVc1pjIvhh5Fpg01lFDgOYCn6lJj6HbTfwr2WVrFRkO06Ib07BabzNFygjkgjWSM7WxcbVIELvbi2jWiQSKYYpLWqid6gqMtq/XVAG2C1vCln0KsJ+WD0bNAlMF33VOO1J2dSUtjiEjZk6R8KPKmdljfG1uExzz2IfTjs4jvusj8X8tvgcpTn2HbLn72/fOIgk7WGuPMavxp1y3TmNu/c2q64r4fWd9Iml27XB9g8TTaqdxFHLUQaP0R4jt3UEexrSKXVEc0gdRF9VPRd4TR5yRCS1zqD7pbW2kVU4RAYiK1n40GBR8fUDIhPRuWhy9oXUbmz+TWRnsEpP2Ro1o7ZBNISgsTfeJkEA8CGvbWexzjMz67++odzzlaOb5goKY31cm762e6sbvyp5Dma2Ydmux77szBqqZxciUjeiZqxOq6tCCDR1TodSG9T9QsdqLCukiSpvg8JtDV0cznD/cZPzkKNX5HTDIqjex2PqEuTKs9JX00p9gAmQTY0oSGIdbhk8UWHK3uTbzgTfPeM9UT3lv3NOxL4adh1/J9DAM+oGWuEzw25RBwr58hS3Its1emBMck01KqfJJ8QA/A1S52K+G/zVE2K3kvCHfsgtrSTjcX+p8gmlTJkQbuKn+yN7cfraK1vsZv/jVS2+zCzLNhUkS5h1jhffRad384Idpf44fimqr6JdZRm78ZFE0dJuLlpCyHL7yHFzkjp9+RtDmOTMF31BFkt7QUZ4oCtX/6hY3GddL+nbLRA8uxsOgk0aGeUU0VdNHfkXe8m5utyLviCRe6D7LDiG84qMIXnZER5qMwakX7u4r74RJPTMVgd/0o+7t3D3n4+HEtOMQ37+KpHceAhQtFhfmGb4Z5A5icplXzSxONbFfJZVknPTiaql9VXORDgItt7mbcc1ExPF5YJTcv47QW4VmWpvXfMSshatpCGZ1KPQFbrh+NmjbBhkQJZR4r+XDxzwal9ScEnLLz9IFxgnpUp8nz407rcsu/IAWFF0fZ4j+arrA2CAX8M5LF8JYi6902OFBSMfPMW9ELLc3hnnP8CFaXxGM+RcEziIHQGyd+zXxeUFe194B8zdMhcfCCqvuk5Ee4BL4yoNfobwaJ5fIgLbyU/NJJK+sPYU7TvYQ4AfYDxwnZFNWipgreA1S89jRlutyHyjZn3jc/osmtirRq8XKb8bGKIWL+MjzNgxECMVlwKIcuTG8PAjgncd0TgjawItW8MFih/ZuPCLnwEX/zOMNOvUH9xL+yqxiS9L8iNeLwPhyRYHMiSpc/epxP4cZ/vU/GTXb26Gj18d2eoQY9vFgiO5QgsrUNG7FRcNO4A7GoRQSV41NCnzv+R+hyDj9iC0V2M+u6mLKYX1Gp6buILpmaMnydjUzTAbd3G0I2ht14MH4hFn76bU7woQlDtrz05V4Fkpj6PqdwSZSo26mPhPXOQfCQIpMkFGXwph1EfcS4n8ItoM9Iccu8Q/iEF/R+AzSgrbSABZg/fqr0b+ElE8TvzzDDMB7TX2vuCLCstMGSDtl3LPPJKaJWTchmcrHgXmnXPw1KKFZ1CwLnziLSfsw2HTz4V9IE+ZNRk1fMhHJ9iW5XOBf6cOOZAEYrA7XvRixQLBOk/L6XjhXFJwNqJNWy79GoCG5xAVDEqIE9GTe8E8iFLh5JuKDfpGouBzKFpJfEsBz6kpuFjpuK6StnbKOixbm4qnT4WbtG18Bv9ycMqnFXuFSGVfGqwQES3oJatyYlFfrg/yRTURKD8qIIHNPqCpGM2065RxHBbrVAlz5tmxKvlK2PaXdn4B8s7jRZHo4pi4KMesQuPU8k2XkMghLho3F394ZuW4wLaK78zxj/yu6H9wPovbdfQvRMfRqSIJwUC4j/p/wWjRhcWtTsnQdz5aTl+vD0XJ2b64rGYsm60Zt0BUPKFyr71f5tsuOrd61mXgYaBXPdS/8LHFe3o4WyYKUh9XEDtIgfBADWhBKQN8P2QL+3b9nLdM/zdaxtsMynajviBvg7z0T7SMLZEFIbgEamxrlj35VW3u/23sgKGjIPL4xQ7nZg+SkQIvAmaAtwuOWEv7IUSjc+Kxnks0CPaNmSGCjj7YbO3kj3w4fxvi3hW+7iNnGHhHq8xCzHURq3bysfHF9ej4Hn8I3W0us1YQdAGySfcGcJyC5n3ppl8OqHHHtxyLJmIJ6fxUw0IlLaRpDYzk0Xvmo5aAeoFn2dbWnBFbXuPZ6nVeZrr0sP5ktpP9tut3AJXe6MVPE27npnig6jP4KFEV3PGPnoJqYJfN61hg4F77XmPVrm7BbC6W4ft4nix10JOJuOcAQG/QIcFASTPKDMVwXF+TOiztxXGFp1vkpC1PPCJZKkLs3AMQk/0PogbdB9JtlnkSxdu/EexBqvQGLt4YUrfb8X95luvRuX+W2MZiC6dLAd7DY4Se+iLfXL/9b9J2zH/qZUcELjLrILakbpjtX6+pJbNgZ/8lq4dw9wvJy2JCc5elPPzrWJ2PaiW/zoh8sn0sfKn7yNpxZ+OUD5xzThwvdwl4flBYpTdBXVn3zYfdQ9X8IuWadyLR2I5+80lVgNF/1vBUNHeAVZ5bt7JvMchq3KAza3SlFkg7Q0qDgmu5rNoLYooCsaiPXNcjwSO1N8IKgvZbl8vDRpJKtkEdILEjmDjOTCdl2u6rc3OgHhfzzqkHrZbMBiOHHzJe83sujjPDBSMuAux06yqSRVhvWo/F6Leu6DgDR3BE+VyP+mfsQtZfkSHp8FcggQoFkzbNXaxaNg2ZzZmzE0uKecyHi/U1dsnfFXc1SLKOVWWiiVM8VsgRRAU9a/+I5DO+ToqLLsKoCeA0hFg0Hle5aOpAkFfB0/a6lPJ9pOOh3rj4mL9tqVLRHYBfT/P764PQ8aQXomsPmNLMuqKF6W18OMw4mn5qRT5/ToOpLPA1+mJ7tW5CXZxsrRt/Dgj9SvW8FeISZia+lqjp3exbedWwkqFtZLcqCryyjHAShm9hosSR+DAxOwhIB1kS05HqUqPcB7rcOx+OfBjtUBpi1ryt3CJb1/I9PTCyR4wOKWDHC2r+XYibdYh3RK8H90oGXUgZq3Cu6jbJ4/c/Kv1BobP7cV+QcHoM04dKRP3ke5nqoMIbW75IgUSsMEw5s3BeGOmGly9zdrQQ8JOSwhW/0uh2xakXy5i8yXMKaLznlzMGLe/o9BZssg3N2fByPVVzpIageePHRFRqFHeUOplYw80/vshwjyAMD6MgnpJ7PPaqD2CRxCHY+5qMBLoqR9gkrP6CvhHDnISnFQDBmaLSi9a1RxiT8pioBEAD6EVxJvetmh4jgKZ2UW+2mT5WJsm5zszAYypBspp8TSUWbkQbsX+DRdXBbjrRoGtIe+6r2dbCdzq4aIY0iJ6zrCKxnxen3h09Fo7idGDZKCluYetlWUzbpLFn7qiwJO7fjQ/no7OaPo7VdGnV4Jqwvcq4glKX6jBWKilyO2mXJUOCR2r0WKDbcgNF9zjZKPGcXzXk7O2yCQwyqQpZEVYdR3kM9GbLuVuds1s+Bm0/WRPWxwRWrMIi7VzE+Nqd/09ck64rMOoqORde8h7rVvTHZhgEdr8TtGJamc0Ff73s7gLPGoR4R290bUTVTjRXgWXK56BOfMlMWTgMYansvQtAlOx/IIWJ06KYnu7leulKQ3xrVQ6Q+nmJGieKH/a+qWf+HF9CF3tnIQkl5UyusuXFQRgVkMhnT/1eG5UcLe6InTKeB6YXgIOb/lr5sHpHx6dSmcS7U0S+nzTpHh/e6wcC7NXwjQdKszF04tT8N3mE/SDaYJmMFil9s8rTTo0mDAjnbZWlobNesROQOPZlKnvwpbHMj8LOnjL6ClwPzv9qLA+xVPfNB+1H9oe0OCjFaNjgQj2DjTUAojWM+JAR7hpgwtGxdgOeYDKYhWoaeSlsRJR/VWQ2YcRENRglP/0M0IpmraHDPbhKXvje743cpR2Cf8lUCNBAvW1UQxquG8wuTSJtufofah4bRLUsLyDUdxh/loMykFU3MQ3gNmmIp3XvEbQtMRBCYtRHf+biqYBGPj8vTdFelhDw0rynhlAtpVxSxhwSbq9LLPbnihqVMgOnYwwAl1x1yCECVjrcRuOT9qoWa3oB9YSGRVw2kxgrNcZAGsg211KrSXmXYR312zRQbPK/eE1UT6xN5AUBQLmtn1LaG0IHhpIvBu3wc/r5uRBJvxtUggUJc4SuAQcCDqe5q6oXYOtZJZkHbqQpRjJg0pz0DVjK+720BKjvX6HU6r5tNeDq1CsKdl0Uri7UlwmmxX0dYFZGk0QJ5U12voBjSjSYsUbQsUISccBTbxFqSVqxGxioqn7raJGJOQPVyid+JrPfmZLZrjpDEWAs62YEHcoi2ucJHHY9SxwtfjD7b23v4rizM8nekw1ceLyluBEXjLRNTHzk6oBw/FcuCUc5H0Q+eNso/l3qGLBx/O6l/9bdEAshEcnodJituIay3R0oDE1NrlDa6X8QIWYC9mmzLBIgDpNLSoQUJE2HFW9AzIyfHujwVFB/34EbsnPpl/k8KEQwqsf0piZDeuQQkDc1L/sDOYq4eXkc0cxGhWdE8vDekklMFOsZNpCircm9KgjyAbaZF5Q3kI3xb0aTRvXqpcK67fe/UFiTTtU3HXVFpzKbffLtA7KezC34eqJ6la19pz7pPUEPZT3ZDV7Hsz064uvLJVc53NXhZtMS7eDUHThF/W4DGD2YlasYrwc5Z7QTsdwLAeqm1RypXot1WXgFKcQNwrNtlLL0Mptt3jtWDE6LxW7qslpOkuc8yWDhDuAghoRdY+qQqVbX2YFI+0feFjUEWsRbRZUaed0FbpOEwTKG5/hqAxYtG+nSqI1/Cj6jx8pykeEQ2xTcmnopWAo0Y5iL8gvDialhK8pPZmhDroj3F3ND1UOwYiI8Clj5FWg12y6DM4ESqb9dtlU+6U1VjfYtZJGeW69srkpVBg8YQvf+L/nCQgHIQhqUnax/e84WKjWyJKcCbSJmyUOr5oNCpqQFIxXOxN2Th6P/rydbXUQNu1GdXppgvSGj03pOCyJ1caddH4C1EFvQirS+Zkatl+YLYAR4BTfGllHMRJn0sYX7x0yr9eYzDMUMiCXd1b/Zs6ujgJVAHrXOfY/QOpLTCPn0CDK24O7+kHt6wVNWJLhvQHB1eQ21IBqjHhOM/v4aMk+U4u3fwrBLvIHdLfbrWQeAiEpiKJKEoUl4jXKj8OscOcAFkxWxm0YU/Oe8w+wkcHTMP8tHushS1teKlR6XPeeNjNlVlKRLywkIAgeHLC0pkE4iA9CuTfRQipuMM4Yf7wWyHwQ37XVFHZChHZbsLORWEK0tVQ2eefs5eygwNtuY6Q1nMHvzK4LGltbD/KRv697LsCPHAwJ9+6uyGQrRteFUK3ICcvWU0nyzaHUJ5TeTq0Acd3BcnbNbpbpQ8B6OKQrnWtorqFsu2vaWPpfZZygS9joHcsoTPtr64WnNBs3FtY5S/n+ZggaC69Y3dgFQ3q3tHTfeDj+r2i5MXzbcAEZ3tB4ta+bPtHNv6ITEzVaQcdR+yYRWS8je6zCwJw/qFN3DkK9kaxxDWRr57VK0UYjzr9OeY4sFAL/uubxHVFWXZqBiUDGJmPKXCrhIQEaVhTQSMlOofLoWNFNvr5pfDL5C53BV/VPcvim0AUigYRovCaeKKLEqIODZHD7UaeN6SgGtBH9wrLnugFbDPUCCTQJb9K5dgmt7MzIUw1AknP6TI8FyOWkgrvqx1Xc896vQgVnIZSl5x4UrJsNOYyNKjB4ZCpHc6GPuI0Yl/SFDoxUnqvwWzXRLZfH1rGA7vhXuIXCa5/HXcAFKnTTAXEgTxGVIqz5HVcw7T2jVhWg0MQyeD4XcIk9h1Zzin/0l9wj9hsV5NvesTd6wZgDmcfgbo3jANKUerlbCgSo9qAiKG+7Zs0naUskJQGG86W1HhZPGvErIvdMCEDYx8wjLBy084AKeqyMc+l8D0HeZeAoh/Il/HCLztgtl5FbFSUGEseKll8edSF1l/zQsstYja3CPEmOcmVgDtK0f+YlubpACUvjbBZRrSmXiC8DLRhBZGviQszc8p6ipHouB6l4y1MmOhXgqqtmQJkOVN9clnIpq+Dt1qS7r2JHeBKJaX3W1Nyj5bWrgrCKJQvRWP8e02F1DtRm2dMnkS3T0j5qZKeKEXSu0ySfJi3xCHK9S3tnO/eb2KxmHt9knqywK6bp5zJC3LnZPjci1S3g2+pOZE+4AnNdUi5PWh/rm9G792gpWOQ9mLWwSTKll6ZTDWuAbJtgc3sdVahY5pwTu87xgjBmxN/a3ptaQnxJlsZsNpz0r6k8F0fM3eqOoG1hvMqHgK3IeaQXwPTFGZWojzzLXa28O79LltHHN8jJVO7xWoZ5ebuX4p+mtQ216P0pSkyCvPC7qEKZJ11jUoPWrq4xbnm6S30CGKULlZFRrO+V7xxl9Ofci8R/kcVIwrXUd1+jPKaBV67WUUrk2DBi7WedwsWhJybKSFnbIYUEBARoFId09wrzL+GvkL2dTP8cs25rtqvpL9f6ROABFTAD4pXqAAnonSb4BvMbyNHYMlKW5Me9M1Fn83JRk+0CQkIKaBbHczHJ8IvciYX8QlwxEMbhGabNqXj0S6Z6reVKK/OGVd5tMC+oTMa90JhN442XZ/zV5HduWSQjsND8nN/DpZ3lLyeATbtYBjL0OA/B1p/oJ195E9S+usNmVtxNki8KYtxxm+ROfKrblmAjG72RqIg1XiRVEIodBZ22qOILX4LIPA1PIyKRn099xRb2x3peMYrGWRAyxcHrCDry5skw0g9DL1nRrfmwqZED5xRJYTJKIYPsGiHNZ8iO0sooYSxQQUDJcau+VgsbM2ywGXCdrnBKNwJOysGHSYib+0LVypgNc8cVVI3X96lDTJk26SKNbsaldcsj6PCq/T5Ujoq7HwJJHYgAGr8AGPFu8v/6yiAUOjhx9zj5yLdyfcWnjj5EgntO4s1JShKlQ7JBCJlImbIAUSVAxAVF1EjpXaHgX+PYc6hiCxTVnrg/Uy9U6jSAobjB0AuSth/n6VC4nAPPVGrujRZpFRC6s95pwPi22fq/tk5lerfnpUV/KcYPqfbM6z3o3cjVYCGTMkprsLV3NcOMRhSsmSvC/ByzSRVOFpZyynku/xdzozbap5xy9gkMuRIoSwzcgY7UwrsA8RRvy95I17vRX4gdHQG9C8LbF5A0qdMlO3N5bc1aufaWfsfB+Jjzp1ZO4mO0BiGgXgml9ldw1hf2CzG12/extXimvXfGOtFCn6j9Mw4WIoAJxp6JgEN+txR8RQvLui1RbebltZ6Rgc/98ZNxbJfU2ZQJoNI9R98DRFObRftFBS1GnhqkKJbGj8sGPRuDa3kJN2TTsfYRdf3ljDzO5KmPlhweiMcQiYUwms97+VJK2ebjwa7t/7vdFzPJPu3TAZ2lNreXqz2t6jMecWQxRwtXoAyRlKDlYMNONcwdzxVnGs+Pu0noHY5AqoWJOU/f4MWBgvubeFBqHHF/ZbDnZLvtvDwkpvUcuc30YjkkdQOkffaLzPOfeZD3TJSGTvfq4ELoX3kixJKqCHYLp6Pq5CkRIzvF9PFOQSkgYkLd/KiIIvhVkH0nv/4G0t3WqgOWNPunX/cDZpJ5BTR4o9w6rnXglW7Guv5Nka5NWNVViC41my+kHfSYDz/FluM3AW49QM6PQJaTNZbX252S69yT0MMUMCAqR0TeahIkN6lwJnJTYEk1tCpiCo6wDJpfICMneo4ZVBb3veYn6BWP9ULhJ5zQ8Gh/I26I6o0fT5rf4DFllh9A3ix1vzXamgfmdiBvq1NaSlyqupgCY25hK8VM6PS7e+cKrPR9AYYznH2WlAVwABnieVIt4NZEPmpeSG1Y6fcV/8TZYtj7zpa7hHJIlTleaGotLJQaSXKs6HPxqEEuB9iZHEfnoIz/UlMrlXEiAYBIXYeH1kqUpZ9zCkrP5yi8dR89TNEdtXFo/2TK/a8Bjt6grQyRhtXXKotTZMRRXrEcKkG7dgMNqQwX4K4lysxt1iMpwRJn2deBmccMhHOY1lXLHslbO4NwmniqOQY6hcgZEiN1g17Yq2nc9gKZaPBskoFPdInaZJw29c5jCQl0uGPrppLIRHIR3XlHd2iBwA4rb9EZ97DV8ji6QQacs7TVMCxBQryTWXcKzCU0amFjAze6wER4GzREpDlWo6Lxd75VqcqdJk3iJBeRySEIU72uXw1oXxauZv8vXZVYhTWvQp+kO/oa+9ZVV6BIStGvYzXrn2xAv7R08f2TAD24zl9bMWpLIVPLCjWviLP7HqpuWtkkNSVy6sKWng5XJ31tkPgR8LJ6AEiy81jmtGWMbjCRhELGbQ1JwYb5BUo7+7kn/KqEUFICCh2H1IoxBOckP8Zpg2en08i9o6SIB0C+gxMdd83hWGTFQPm6hl+vtYRji0AnnDj7K7XyqiFAtWiEMCBbte6cO75RQw/pzTcraXfvrH55WGrxQixP+0T3bThiMmrbqG/vHkIBbp7bt46/hJ7FqkCpQ8lU/WErB/NRX51OIamO7/gdczMXYt/nmqC4RlnOfdNQOz6nJGXFa9do4lV+BTOJati8ssjAA9HLuv+Z1cLB2tBSMxe5GeawGWDRBFGZUsc/T+qw//e0Z07L5dNFvNpug4A/ke83OE8MbMqgb0QZVyyGeqB9Kw7RTEOtht6rktpckP73oFl9T6bVMKzU6t4/TguhIgnhQwBBQNWELYDub5SgU6MxGAIb3uvuasIdM3W11DjpUQFQVyMeQGdS0tvgEgDLWAliZCdDb0eycewMGycCSs8pTufCic83EbZcTtDZ9UphWwXPPXFp68OWLdgNjNQatcPJks6rN7RGyY9ChPm1oaYqieyzvUy67/YvqRVJnTnbyd5BS7Q9gLdg9YYse69vVvNQvOrPEZIHqFMVygetGTe/X6Orn8ZFOpeHyH8/zbJSPjTay0zxzloQ+LNQfqVLwKwjcVWnIezq3Id4PUdN1sd50O0VL+VcGnRpwBycpK7PoBb6XhS1YD3tnwzXA4V4pz+KM0QfhGqB4OHn/2Az8pjDEFufTTyLkgqqlmPCiVk4X1Sf/3eziMrV+2WPzX+nf+2e0ZPQCbz0ToK3mIJCkjtf+eHyYCp4oJLDbjQn5x89lEDupW6T1jD6n11x7gHob9J3V4cXVyVp/RXErq3bKoWT1EhbTQreNhvsCRRmcW5wKT3iPEYqstPq7nZ1GdpsIBO579BNBWh/2CR0VSHvfEU8jId6KO89VL51xXOdhZT8DmzBtn5ASVIUGiIT/6Xe9/U0zPZusKrKeG67QxciHdL7RmFY5WcU8L+6Bg/2TngvX1q4gojjY3pFV1o6tC9GyeXlhRdqVV5uyo4y6KJwef1yLyA5vceFfviLi+a5/nmcABhynEDZ9tNg8734s+gk8T/0JAB91MoEvwdIFqz+zpd3pmqZIU6FkIUuzRNevPjxFtPMXNDdjLizfDDk+LjVSppOtATcC/iGqHv4Uk1iLxAkcdIEjH9Zj+Y720HaK9H5w5bxoZWn3/nMErEpV2uQsVnXowUbp+Wu6euPqrISYnOnH+LMxOHRhhx83wzTDIxbroEupRsOtbR1mph6aOMZnqGDYBxidpB1X6SAhnqjlsrvuxMnN1kLia4tJkn/VZVo2yDsHWZsRnSN7iQAiGYyfmLwO86syvdIW+Ore2Yg6OlF/nQMiBCv+kLXSGyAmYe6GbPHU8Wqj9bZaThXEr7c7ndhEDjZW+VytWQxNFJLRimp+mT+Jwfq15tyXHu4eIvaJa07+K51HvB1CpuOFKa/p195WFv9UnIcs+GNg64sFVu9rvvyF/kuauAr/sksHsNrXHOg8OxyKnB9UmgTrr3DjKjORw5dszrjdbWlHAMDqIyHWJnJqwyKhq09v9SGj6Gz3/fv2wJ4qCvGIIZy7nUdSJD+RcjoBBYOtYMZvjHh1lHTUayL59u+0U8l2BG9p5LE/kCP2wNIJc9ye7jOhd9Ro6EVxWkP7pPeJq39fFq5qeqjBtOHnCXbB3QDSsZ7oH8Ngun4www1zn8+qZQqUI8YGrplOvb83xdHS5r2XJo7TW6uAvTR4YQQ/+9WILHcsnqTNGGT2R42Og+Z33tXgkTxUr9RPcSndPj5Mk1DmZG5ODMDjBlH9OX07VGGBkDQFlWoclS6AlxQiIg7Rmk+fk3LMCQNeDZ971FdpZ436VEYZmJApXtBJGxbStl7jEk4jl3o5Zf8pTe21HN+X8cB380j/Rw3RnN1cRoqHIqYfxqGOwG9rnNVkhX3DZGSDqCMBDqx85kxWiSMFw25jQ3R6Iub57tn6Z2Wrwqd9fwi1k255AgfkD8JYupPvPWabnhdU5819ECC961nzhEZw4HuQ9SpgOywYjjcKOk6O6H6X9dqkbuP9TqDYm6W3NcyZASohFPjA5GYVmBJYd4VrKEHoCNWv7XnJ6vX6aL8QF6DOFLW3PolmIl4QsTj9qBcqY5jHRYe3RECG0XwFlCP38bk/M8gIL1k0ZSjGG2KxlksTdWqFVX258aceCJmg2XrLQMeIlaWCDh8MnE6BJ3XL26Hi0rcCZrQSzV2fv3+fadLiUnLXCHXOKm6GhUZop1wLHTvVDeWev9Pp5W/lzgYMe9HqLO5OhPEKp3/DKt7skMteLAlytQ/VmSuo8oxrQgVSxAQILYN+GJbVKLUt8nzDVb95DNJtCsmsUvOZ4nLqKIkXAs9xq+24vsqU49ZxF1m46CJTe0S7LjI/6s+Tb6t46Sphrf2tHnkz1cJ+DHhCEt6q9zOZhYejZoZSa+N/hStceydSAQUmf5ASDMsTPMeNzygWKCVr1NLdD0o1w/RNlv1JKD7kJCUBg3p9fEXCZ/PId3IzdAPvL/gtCzwbsU9Rh2Bqv3WDtPyW925Km5LueHzoNiZl8s0urJ8vqEMIRLHiM4JzNPLvgjl6rTgTOqT+jHwvMEWXwwmK1q3Ly+wbKJLHLi9P3pKVJoLa7utaW6p8JnqUTdLKejY8+wxXE4XwSy7t8QtfHthS8cMYTRtAKgie7hjNNNYqYQaaoNw70MFQ2iwzjHPlRyAYkIbQQiL3nV3aANUHbeq5dJge3LebsRv7vBgIiMp64A2NURHiQ/tPwAoQkGhJQX5PJa4X5X3KQb17FQaR9nidKEgONaWPBlmsVW91EbOYSAkF7aJBiGMkQFkvt8NAJpRneTxy9c+p7nS/sxYXJmawPrzo3otqberKwHZ15LEx3P6PZe29tPOBx8fBZ09EC1VwkF/6xGRQjLYNwMQuKwEV7B1aslyGBQMbUwqMC9TZPWASyxxIcr84msPbSwd6qlOEBQ+CerxQWwsoYyEXignhBAzNVRYfqwGkcoOsBsvya5b352K47IRGVhTCkuimwNBhfld3RkZjCtVbaP44lKPV4Os+loNCyvLY0nDF5gaWCtduZSmbJXiuNAKJd5+Vt4Ey7/bh0ti6L3oh9usExpmwDCA3k79P0WdA3uZskuDpgBqd+gW6R8Vpr0ABQadFXWuCfbCQHVHpua/jzWzlwJ1f7hEdiFciyRJGTDe1HsVy82tTAQzeaKlc0zeUH04wAAUfqXhTU5uBb+Dn18TF53dabp3QiTc5P2rH6zRz7+wRG2ll/2BTtK2MhIXpm9sZ5/6a4bWhV2o4EhVRmiCeDFGz48wZmtfIkVVKERs3N4wujP7ptNqhI3Izg7fSLpzSQ1d4qTi4D+0yrJHoAjPU1bjJEKNNFYYTQ65fRbP2syBawe/1e9APFLO60Plf8Rr3i7vRfNEgumHq3lfHRR8At3LfEHUC52VRrkzw3I/4s6rNPKkfrbhOvMy67wdVXlalvN8DKYctqzIEGL/MCCY8qQRvJnYDmDpst6xmhtJv2JqkD0uh4cQ6RKNCok5gu24VvPqV+FBwfxepogTjt+kQ0WNL2EOB2bCAlLGinqURIoGgrzfvqXfLX7mQVr7CTeg4EBGQ5g2uFj0fAyfYqbpwEXWtgEPkQVOPpx3SgvSisPiztI3ciG27SICNI9+MFKPBd4KmIepirSOyj8Q+03zlJ+Png3tC7IsBz9GIKMxYK+AUatqkc/9lcLx37ZgvJeJtY0kgz0y4gyhdqnl4yq92CfW2RIxhyLGYuGIf81YicvMmQdFrDGO9mv1Py5fGcRlBGIK7XopF7wCHOE2juOah4WBbhxus7hiNq80hX/lue66+On//M5J6FhG742+c5rXUrIGRXhrNHxylWCEahpZY5ygmQoM4SHSRuiaehHK4hqhdbFhOutKBG41KpATWmbyPE2EXCoWWL8Vqqc1h90C9TcP5Tn+vnWKLRqQ5YZ8WuiSWGjnbawWIbJ4Jius+qGSlm9AVlEa1L7Byuo81K0TebmIU//yioxIubamLPY0LWM4Wo9IVBKx1v4La88wxgQIWvCKnnLsX7nRF2NZLaI7AQQCidYT0GqlPE6et47KKLeHh+AOeFrGfPvnciTqxqMmzAm6+b2jLsa0PcNOfhBurnvwkKKP3U6YPyTRx2k+8BesFrkRbLKpyooTtbgSqy6406f5OrwPxjyXHjOgOKAblabn7+ZnnpxZew7yl1ugqs5XHnj4A1kCLcPzjanOBZbUS+XnaD4SnEukVT3e/ao4M+a55Iw/u0IR/T6OxvJj43jlivC3k1dOLkVAkS2GKAKoDADYiJntVHnsw1d/kvGRTozRsTwanfEv8/ayZA/JMSnnyawY+y+AqEUgloPl074yo0Cp9i0h5jJPeWSf71kh3Gsy0CpyB7G0qMcF8viuA1rPzhdBN1Z/ADjtkpTBqtXnh+ph8QM/bHcWL5pUGqBrgl0C6SgTQfzN89ifCEGL5/TWO6kYA14hdxdsRnO9dZM0NQHttRjjyNHEimUq01e3N1EUxji0P/oseDwPGIZ1QXak7W2AOHSVkA7yC9sKfU7Tcax83U0ymYNlmQzWZ8od/mVXWbuh1yj3QvkNdBW7Rg5ACPr8bIS5SBM94grgwK3XTTtJv1PGMzrX+cwH+/kB1KccWNqWaCtHZJZk7CcloU07/mji83xPAVblxZQlx5VNghUKVO3l2HSsdWYPJ2K/TNMg1vrSIuN/5Qf0SKRjnhf+OGBSG6i72Y3y5eCnvPGs7t1iDja9wRbXDyVWr/9q46kdFah1+EtIOqYu8fi05EF+NxMDR9SmCHjHw+KTBfMaNCDnm+WA7v3xyXhZCYd79R5L+OP0TzB94nzxyrI1pVKG6UqFkMK/1gDK1QD/ZxbB+kUp+vz+fi8fmTCOe3IHgpuEZq57a3OBo9cLgGTu40bP7TEHaOlInj2cpjWTkaoTTB9a7vAqo9kr4Qv50UltxsuMNVROGvSQLadPT4wwgTo3PMKaLsuRLSDa9NbJAv0MOOsw2q4AcQaqFgrM2oOGpBprRp8bOHKWURcGot0leC4Q0R3nohRg2oRRYJLF17Co6EqW+2w9yzvdaTPngd0Vr+DcHiWoMqVuyyfEqmoUhdRe+optt4mC3gxnMyHyKNHAUwvsgJwDm8cVDAMG4FElTIKejru0uVNdeOSfGDFGBuAngKpCQXFNbesOgXGFN4kiAKymmWk4CPYk36QGa3dAnFsr/RH0JCxoUqbdVUfTsyNd3O/q0Qb9yu4NuRZVn0slmTOG/fkTUxcn2gQWpVruDtCUArJN4nUMlpqom5RXuu7fqMjlqzWN1vZ1683tFVhphLtDJ7IP+q2MZxOYoEhq88CWcteE+q15OOzH6q+syOFmQ7VU+wZg/4nXmCK4oxDP47BTi0IgwNp3i0d5p2VR1llIiz4NfhULQ+ioCqd9aRSzedJ66Qz7T495ON3wtp4+CtmlTsKwuzvaE3Lai6dpiNkwt7YEk3OpNaS088o7bBZ9X+q5ToHpQIOvIIp0QULlorIsK0vBuAUyVK6gJOSjjJGDs9rht78fgWbrw7i8ORyK8ge3RkKzjy92ZHD3qB8cdV7txu6W+LgJWbw2E3TYCsJBdN/i3AC42fnS0o9LFe4vVvEubbaTeHE7oVGiOMXFtsH76gPX4xK75jC9ohfuAWlVFqAoXyWWwYUfocgtn0xn4ohF0E7kmSStpSgK3V7ULi6tVN2OTB6JqBubCq9fACnU5znFI8dWzylBwQ+NkdEv50loTalERPPN1qDoWzUbsHn3NMoBJkmjF1GrVvz6oTIabmJbSeXPo/m2KBx6zOZu7U0CkYiXVQ4Sre9UoAbsrKyZmt/SeAGNzfoD+wUuRyWcxK5PZIPqXm0uo3aeEOzhebv7qLAvdAj7jQrvPorogq1gnelmQ1Nmc4sXwOEq4mBWTWSWEHB5OoTSsPrRR9rV+yQNo13spZ2hAKF+ezlU2FEYxjj/tba7cnkJP5Ojo2SLEy6/99NP0PqNH0pZ/zKstbzQ5FH/ZcYWvV/DsqvbcJcRrAZVDl5RBK5cwbWVhN9k7Y3XPvxMEh7NsWNc+fj6CWf5l43Tg3AlY4mDZF/Wn3hgUDsX1SNbiiajMNP+0TrrCjbvT5KAqP5KZQZmzjosHAnlSYgSK8hRfC8g5uxKqGMKnYCWqXyGWUDD+pUIjQ5KEIOuNXgcN7otz1SCN8hwKmKmePIO8Y91QWM7bOU8uHKlKdYmVjbcWNhodqSHHbaya3W4XjAUE0Dx8u69A7hVMp/Y1J1CUQJn2LwEtx2F57ZSkQ/7ZGVKwYdd1NkFBGYd6Cl0LorMtwytIvLTenxAPRCgZ4MxKrFI98HgHtNpHfC8DqMMjpCGootlxD9wNPwq/RO30TcWhU1cBBTdb34EraRuIq7sO+tspX0vaAI6hn9eYsIBfMZFv166QdhO3q2G4AmHwLs+zgS1f+WbqpkS68r8uTj6RJIyAeNl3nzWHezaYGqz2IcUxlldxo/JIgD0Jx2IJpoaaPTZBLwCOv0iePmSfo3ki0pfnuUO9t30+dG3zIsJNLzwU9/PM3yM82+4S1YWkXQZAZ/Z/WXB9W0iRoJiCJuDoDMq9slvJKVHWlz0CQbZjhuzeF3XlNk3ivyM3bO/VuuVREezWOhpiAl48TUAbyAKQP4fa4XL7tHMQ12aGk1w082gMhFzcUwmVbPNaphA6hIfzpzMogEbM0KC6eH4ta9K9aceoeXPkO8EPhlFRx1qNyydVusf4+A2oj/mFxsEpN1UNfrsLfYo+aid9akJArXH/H5OeTuKYavMqqZtr2eq0xEBgWi2+xxcM7tD5aEQnDAn9BxgTFoEuvWvEUjmr/csnOsvgPHW7fKExxJVhEa76/tf4kw8m1zR5JHrESwwIDOk+q7igYlfTtEtRgzAJEVRmoxDOlWn+tFyNpTKkmDrT2K+IdJkmRPidh1JIIrSOwOFsWjiLvkHgmXdI3Vz6JDt1f+JjMSHuO4QWm6sDRl1c6NfjW1PCBq/PkDi9YhfDrEsjQFdl8VujhzZAbI0LC4MkuXIsZ12YxK6DMJTYSCbnVzR8zq9DiQ96CA64agMcNFsaOTnU1nQXUCGh63s9X6+utoCb1ygF7G6wKpLm/lVs0JOKwF7aoYRzGATZdsxhruBq3IRFVQn3msW4kanDsiD4P0Hiy4RDomc3+US2r/sVXjUouzLctDj1NbZPYpXdPl9xyMvf8aeOzl6l4MWUbXqxY5HcnGnGHY/iDtltM0ZfH/dsZwMb3gl3OtIDfWukMr5fwdObJzo/BH54GKxI4kOiSl2r5lzwNdW/eXTyh/XmID8xNtauOKFAg2PGByD4zKACE541UCmdmAz1K35lj65RpuAfXCnAIjJmTu7MbJZa1j5RfkBDTH1kfSYTYIENVQapTFm1dGgDfqQ+3y3PGTU0b0oR6IDwTU/lsGrxgyP3opJj9fJ7JILe8i4Uaay58pwxZwa/Hw/pdG3xtk8AcDVONMN1AsxVslnqLvTaV4DrVG+CzdbYfnoGF4xIcI8ErLh8QpbcezwRIosOSY1t78DiwcduJ042YMi1d1XiARDTEwvbQNmEwMpj7EoS34DobcfTwwO8/TfHsZnRa9HrGCfJuB0ieOgLqzaSTGLd6qCFS5PxYpDkZcEbAB5SIdthLlYQzoUDuXd9bIYAeESIu2XMHbgH8ZNzXQLVm95Kcd1WS96c51EEeJ0ZdZHm2MbDUNg4uLsAKnb+eRQ71FXu5Uf9c0ihvJvIJFc4bogSqxNNYg4wjRF2IgVukYXgMaH827UxbHqtk4RYGrNl1wm29AlgrVzvPICgyFZl8SY4c9FWO+Xvg4CyHu/Ln169KXbmHzG4eGF3ZJQdntkyNWzcsryKLJxmbDsZ+JuATUrZHfa0UMkkdcW98GYyGo+3qqQTb4XbU5uYt02li/pTQ5W4MqPmn5QQRjOHixp6+CNFeP+IOg7M2jp1DVbweesndL54yYjbSFurKaRaIeBAMybiKSGUV5412No1/RzeV3/UX4j3Ny/T6oG0wscH8Wl+RyGLd1HWnWPaX7BhstpQnxYAPeqXr9wn0PomgXzwp/26lE1QBbphr4/gjON7cIUnimVZe4S2ndPtfzfFmvVsXRmk25ojPr7CaZbRP9wgIQ62zF8auKzN4NlTXbm7ZYBv6/Op/qzZEFgkaO/kLEza6UytVFoJely679Sfba5XF7LJRKDoMeKD9Ih04XBnslSwblnPPRdanYpTrN2jPV++KCLrbungsZPgyUVUt8a25HBguGSF/Lm/z6A8xb9swwue5vCRLXdsBTfvEuFXNjsZaiI0OFGCtSkeKmf4FiZYTg2zTpfZAnM4LRFhdtvSOdEJgLxp/0Me6GL2hM6uwHhvQWu2SmGdEuDasZOrP/Gnm3QhoQUzw/+y8MyP9IHbhlrZIXG5+H2/fMwPi4KrjaKZGOo/UkN7l1Gapo3Q2lDrYDbrS8AwB9W9YkO23/nWVk01yHy9IApqTmQSRBnjMbMXzy3WK7egAr2f2SvOZhSRzODObB+5pXc42oqL1NzE1k49NWXIDBeNlTsrKhXlpa/1hq4X2nxNjTwxEUnwBNSEapdBLV+hjz7Nfy9GH/Yr9rRObx5vy/HwImYzdYC+tVJ2+y08qhDaxePm0DwSrm3LbTTJUAXOAMk5lUTCNIOUvqDwwF5xkizbinEwh5FJhESeAV4O+nZpSIl7pRwbBtLiwjLNCjuaM93ypihKiqWuW6CEB/BJDa5zFUQEN3AGza0eHnLwbND7ysnZzKeUrozpBJ/Fjvg7oC0yoZYvQVJFRfC//kXdcKhgCRvB1OekQQLwM4ZTJdrpDQKnb0oLgYPnSMDLtNzl3q2osu4HcMgJ0RsKdagMz/QArJytTu/kP53fRjsVj2CkdIgaJ0e/AvyKqEf7xIsqo7Pe7HbBQeWaJMgGRycUuu3Dh510v4j4FjBasE6x2xxR+WgliTDAu/K31vhdVIJubIXiPOU1kQD4GXa/uNyQhukjRqh9OcrcL1knE02qpDtBnv7sZtKk5hHj4LccXWwuXiT/WEIlGOCA/mj3K7QKeJBlF2LyWFRIxQho1gCKTuioGOtIqhoYiDKCQ9z2qVvizIKmh0+dqA8QZ6mTI6ihK6ns4EGbEKDS86BWkKgynRAjuaoKrRp7cObTeOhkAEj5DCmk8bd1YbUKk9WFFK6h6CwH8Lbyrngof7g1+rKetknq1Q5AG/YTkFKcyMi9Y3IPdo9iGLa+dnlHGVbzAMcrOqvrjtkhVRBGKexHYY1UcwDBHDNmT8oHFNBYQ3wFbP3hvi9vk366ONgpYekqT7ynWXfrGFBwNGRWSqXcPZzhC+DrdRWzYLd4QTMbv0xFllueY3ggAv5DOCg/mN5aUIe2YM5tslPZ/5oXeTC5hysFDooLS6Wuo76BjwRf8HAcmnZ1XqYBhQ64jzSEDcN9O8DktmyI16WbJT4r+y49ioerMvcRQk3XqEaCWfzNfitahoLn4qWT5ltaPGtii7CwQcrVztD2T4TzaAuIngY8P6IFVcdThhjkYaX5Ari01nXhYG63h7fk/MPIYSmXZBF0aoTfOHgrFg47lpBlivWX6ZRgq3/Rorrbyw4tnz9Bx+2HuwqfJ6XsJqEShY4CjfVgoBnrqepm3ghurLvlIkJJtVapVWlCP78OQzf6URowvQtNavjl9J2t2vWIN7+dvzwMcnyMwh6K+dw+G6eV4ncTuEbNtA1skhPhp0pBJf4GTMN/MmYTqJqpjLQ5rEzYIITE1qXUJO+j2MjCnmd1vp8zdunQlx7YtLalSAxzcWZoeIHnAQ/PcmekwFf4tC9nHv/d1WNiM+XmrJt2aGKV/W4ol42vj/Qjk3jQu/jR1TrT0Lunpd9dRmyPiqBXDatsrsF+WOTbzzLi3m1ic+hZORzOIy+JhlGZz54hteYDRNgof8jML5ciSIJl13HTysNmA0vYDQ1+xR4thgxadh6+JjJQpGap3FJ+3DckPc3KboCSm5jtLxG6pKTIHtGMZfU+0ImEXuY/93x9W5FTdWYWn1lzY174KlAHlvOpRoDt3EkBi1Vl08Txop8XnLkufmX2ZdwhiKxpnipKXOI8SFHeBD5YqepmlN/q4nk0x1U9z6BMwUPZyTPb5w8rHkQAr6YqjbcxBaBhUkpnZJz+OvhzbmlYwdpxZWClUMJgMOhpfaajDoh4IKUHEN3MLNrmXaOZ8EAwzlET7Z6+NQ9JowKc4PdNH4cPQICMgXKi2JBCnKw4tswfWxqpN4wJ4Spm7NfVWVOTLcTS+3jxzKVP2vrikujgAZDKCu7+pCrASuxSItkjkhXi8a5cyAc8HcZNv4GiWjnr0oPfp1bvyJ05e7UPa8JWhfaHUkA72pgvM20s2kyjiQrfZepSV8gxpJ5EdHLwSgirr+6srSUWfGJxrj9rj3YZINuAI7d3dZaXWrCgJbmy1MQvtKeKrQ2SF50e4KjybsyYBI8YsZcmrpHmLcFDu8305wQ2llxOfbMigYSKTjI4Dp6a6cGixjcQQNTFaEESBHoJ5wFHmv94QZA4Ow8KoIM08rNsP366XSG0irfw8IiZ8GRdNHp9QcLCr4Gmt0lVNo0ySF0My+7TTdT14EH3G+2TK8C+6R4jU1j8W8+x9ar1kJYyEdK44vo2aA7pjCPaPakjjVrNwkvBMYas7NQLa3uZuj+utDSvQWTO+Jcb+3F8DE8XFbloHfJ3pHN+0PP0YVehCg4KhFOPX1CKooSzQAiaRFQWF7AmC/fTiz3iIeFcR7TNHKbAwuNwMdxl1Gss0udKzqYR1lfI+K8qJD0jPThUyWze0eIsIm7WpBcKO7GClHeJ/o4R6sEgZpDR/zcC0QuGt67XLIRCfj150QSEhHztWn+aO9cQG6125wMAhwLvObEvnn/L5qSnKwXUzha29IOj5Oqb0EMIQ5S7AndVaBU3tTO6eNsxSFWGHMZpW52OXMsVvHK1YkMJk0QWO4v6/6lo6Xty6Ne4SsrxSe45kPBjvkSlzXfhfiB4YWND/NsWsTy04fE93pySyDdK7C8xhKwvQ1qPfde2xzzcHEcOUgs/EBJae7E9YVRf3bEqsSTrKPvFd0OTlNpsLoTk2hs2GWon8ArmdPysqF5pQOJcOLpqv5BIsoazlkSBqAvKQl4GvISRR8D88E8upkpWpYFU7xUxR1BcSFbjYzh0D6V+3jqaRnQ9y48yhTxwax++yF8nUNtEjsUafvZvDuWJN8bbVg/hMFxpE1kGBV15ZJmU4SnOCP1rOQjFw9xm8l5SvAiwV5CFBZPTdqXKKDpvqTh7uTx6kLE/FqB3zH6d+B0+p3XwaZvO4tk/RD+OQdwzT/R2lXK6F/+l87ctm2WDij20IEkDRZ0rZPNU4+Z5XMoPMocfV4SwrOW0X4FIJR3wyTmUFUD7cu3vHofFOH58FCebJXH1/EBJ+1/+U1uj3JS0J0as5P5d2+Z+g7RCskkLixXL3BkoibVauDoxc0a0UqEpFFjPZ0EQQByjG8roEVCGkSK5m1Lm3+7i3gyYLWuKSmDOh3hcCbarDG4ohshQOHwHt75yRXAhnNbKYg5TtjVb+dgd92HwJ5uQfF/ni54RQXZOIod8CDWrfpvuFCjBhfgdSUh/FZnS6ewl+ld45z9rgV6EikjxPFAZ6B3dHNCCZs57MfrSfgJL0VWPxnV10cpwRBdnnOUmhofkbhLDo/r5hK0LGzWdsrBmQwA094wYj6U1PK+m1cqdSkaeihUwkI6aPyK6bRZaS7V+vMySRYU/kD2ekqp/J2QQNewKTLOOnopa+1S6TbhOz5Kh7PhDOCNYeLgg6A/4gupT5dzxugX1d1Kx8BVvBaaEDbLnIJ58JRG9T3XGK3+/gLpXt5Oax5wf80b0cdLauxfkhlp7W8yvevSiHIA7vYw+zQBNI1c4/nAUt99F2JyPb0hMQv8+bQo/MxcYfyBJcpHPbuUUOAVpYl8zGrF+zFjlOubZJtENUgcPCdRCIsBm/Ix6sz/LLrVc1Fo6sZRPrkMYQLSKjvrXRr58H6iZ2w25P84GTIAHyLWR1i/2LH5sw7f9m/K7TapWRaU7P4SX07c3s7cXJGiIVqsCHuWFDQdqquMKyvllLk6k/rBN7GJtuIoUo3kFpCCovIw4n89SEwawF4G14D5PG64sQSICW3soZhiL1logmGbOxuDEBN4O64Ejozj2vVTw8wIVByj5RmC/6DFA80eh4iixleg0OyFvC9Am2QYmKMuDWQytSvGWXfdoboQaiJRdkmAIu856V7JdWDVypMhYqaA3G3CY1AUBV8vsVs+7sOvcYK8Z58UqiMKggX83yIKmeTbqiUj4ug7aBnSWBPfpp8HW1pygpHdNzGj6Z8fO1/BvJlyOIvRkOZQ4lPDy+f+aCVxxR3MdfJD8x9CRZum01vDnTfDCqHxEo5o9VI4cAJqu5V/VKK8Siu5lgCGyPhOKkvuTEz8hSFJyp9I1ORmwfKUwwBQZuZ0OBJ2nFJeGEcDvlVkpJissKpMaEKHTeBH698CtdMC190hcHIRMHA8vjZbJkQ/dJfVrwQH9bRBHIOiXCn4qeRu54bK2EWL7zjtnVEw+9PJH2kVvTQXh363G5lHgUBCVqRncrnvA6U9Ar8jmt1GNK2v8/mNgRctvtj8EL8aEp5dnVCDaXf3vpU5AlisLy0H4bLgSfisfAUigELm8JQhOyaDs5QOyvkKLQJGfEpVnNuF+Lp5xkO/hvFbbJdzgxSTDtBYtWy8S4+S4WeO0c8LmPCMOSph179ohtTg7yBYlPJfI4/qsjkpBJQZN/YD70ReWwsq7wRwpiUGhncT1OJrfm3w5V6C+JoPSjElOc3OC6Lc24L9t9j3C3ikUKMbuGYWl3EFS/XS6Dqvn9Qk1Ak1nXg6EEuS1xMmI8K0p2rdaYipYuvsD0kILkbBrw537RE5Rs3qb+KAGQOJl4FntaFNH6QoncNuFkK6E4M7H2gPVZYX6li3NG9zbomUSeQk7bpCkSe6l6DoIKVfwVgL2WwszGh3FVgm7689oXBnkHQtrxAHQGh8gSbjQ9jGPmMXzA9kj1HAqccVqfcfG0mkbSMQnoFCmEt91QZsR3a8NAgwoenimtLNXNspPkdnqbmZ+kpfN3Az+6kDaTgdKNpMO3Ezq8thqEpUFr0sQLnRTkap9UPUqc1MrX//gEndnAjajZSJrjaJo+0N/xH8y34lt5dAZ0l42VDF3nCE1R6fV/C4iWR9pW5gSFrJKrwC7frBt7ifnKjc1SbzQBq1BPuSp8rVk4E1Bt/U6QXt4bulBmxn9tJe1U6LS47Jky+y4gph+WE9yfxvEYgC2Y61rSJzybNQlfhaujb5SnenQT6sotwmulllQruQOLvsJlehN/x+K2q4PLYTwa64rzPZZn9HBtHxBZL1nYX26OaIin9qsqItagVG9AU9Bej5iXVIZgSI1hl6tFFa43z+GDbkiXtQXKDnBTlxoin0/Fj5cyTLdAmgOCtk2vhiRThOVq59CBipZtCeU4eFEuUW0M0AZ5quYAwVLpVhvZz8ugnVcElp+rKak8akXr9uAC0DGA1OEHDzcUqfKLOVnrBzk5UpFs50gRHGM2v+KzpZucf1pFRvCtAvsPBvw4jABYd4KP/m8aghaM/l0rXFK6e0iYqvzKkdo6kLa2z2CcxMNhFEh8dA8ZCvgFxLH07pmheboVVzwZcRf/vl2MwQZcAXsEWKuunYLXuiVJE3kpXvBBWcWd9D9KOefblcqtbocCgTfOMtfy9P/wqmwBHaApYVwnZAx5Yp3HjUqiDE2Z88nqyTGMYTf8iFIgDTJxZ66bn8lGHoP4OccBTTOtJGWLKKWib9BA2k/B1SLRrJABCRd+VxgjqDPO0Ny6SpTyd+tgpZkhN0hk8N5KO2ndd3AN6aBu0vQAWHQFSFWjv+jSx2AoDBGhGln0kysmA9M3YoBP8+46Otuj6qidFfDepyyCf62/A1baDEiH6FcSfofVmtaN77gKAOkDgOXy0W2w17zhqNcMSUu9d+4Se6qSce0qXCgldZ/BgGHODlMSlKmZx2KGohZezzyZKw7pQRxMzqhoeC758rTkhSAoErTroVg9GBjzo8VMEkowkHLyjCl2NmL0ace2+dkcS0Hmr1feljm37fZlWlJ/5SOPUJHoo6vQEFVytz0O0HUuRzLEVqHkkyv3RyLj+fGQ31xvCSP7TdirkeCCkclvizosud5Nw346fM9H6tRbtfXMjw7r4pV7QRxnwVPH9J2+VCtWb66k2af1Fr3RQR4ZoJ0sAcKsO4Cf33yNOsEcGQ4lttxq++tHlXTRNm6gh4egqEkC/kP/tMCoBO6QZoVJGZPPtK1SGbKGFiyY4aX7PsuImgBHa0tkEU1QT33RDka3SCEcR+LS/qoXaQbc/1VmkEE2fbhhCNKdFxqmDqdKlHQ+bPeRS22/pYwcBKFs84k61HksV6B0Y/iUwHe6XQ0awxWI5lurt/8cJW4JrWZYz0pPmLjUJid9Ubhu1NpEqNqT/Qg8luKexSkF12ORx5YPjIBqMohTYuHILhgsee+jGbzTLmxwel8wOeA5yH/TWWnzj+hUjHLuM+BdqkMN34OXoVSaaFimWo29efCT0yYBUKOOZ15j9HSXKBRq6/2FzmK4sTcBqnL4Cl7hqw+GBMEnlqtLNz7nd8vy+49OD5AdUshmnwrU4HiHnjgPYgUneF9bg3qbWQAcWIetGkp5TqgvNbtJz2ka0zGh/6rQrBKv9CIwLnz9It4lqsdGo2RP63Cq2NFUjAgoOedL+psUmwTWL5JQHTWEhYqOreXwMtMz8Nvj1SDAmMv9vWI3t990UCngL+sKc2ZzmXh0wxsc5af1ZeYj7pcvu0v/3gouw7KVm2OI2e4xOGagl230LR0DxMIFN9AeW2yZKzPfVS+CmkW1GoLoL08sIRGdNUqFA3GZlMMfagsKBAi2D4D5w+aKE9dnofqnwE0JfY2aroLPSe7L6M5RPN8AI+mwBH7+QA0gDOzqx77rUDp8pxrBvCl5hoXWoMl4CJIIELNyvsrWMNTq699//O6m/aROXtplgM0j79idC4okbRYQw/U1kmhjswCnt644XwzVAo1KBt+TbBB0iMGObLZSw3hmadIMrwMyj1/YJTbU2WA8NZeuwinW8PsdaIcs2lCpr0cfM+lWjyeCvYJsXKwiZXfbW8Sxz/AsuKFDpUDmb+AYtd0TJlTJAzejnvckS4yi+/zJJTSbHrt5yu1z8+rrcsev3TYcZOCsKtXDrp3OmBDccNyGuSIceuvW+7adAXo8JlPKXVDiyRkqF87Gej7eL/4aG3dFD8We43UsYKOx89kQ5oAHfCaIKRAlKnnexhphOusEORjor2PZT3YWrNKc6vsTEGdRAT8iFVZNrNCv6lVieTvGv7IXyuIMW1J4YuaTxK4cOY90BsTQLhe5DADplNqYG+p8XnuwxosBpx1f2ouVh1WmQvyjsNKtu+QKSWNLdko8hyqL7HNMbIslHY8SaeCpf+FbCD65sJdoI/1wxoGNt5C68XUQxaTeLHWAJSA8sFRWpzD63a5+oDy+Ou/a8Ep9+NHvtTXzBohuRL6U+dzClfJ3ksujueEBGvNDjzRo9n/9pz9Aj6wb3HD25jl1znOERdXNon+3QNF0A1CnEx0h1tczCsdWyImxobe+bBeAtjAzO0mBSK0C7AUDrRNjOA6bC0K00yPvD52vaBUFbNIqaF7yo5q/3Vp//7iYSSVG7wsXYjpM54ZF60Zw8lG+JdSjVgU+qhwjHcKkhr0I0MN+FRnbg0JOnsZAyTyd76ynffMSaT0MQIoEfaQSg5u63QMXGfX08DJqPyHgZAcaanCVA521e9H+SnaSZwW2MSutGj1gqTcq/Z/Rija/AEut+nAphD6PBkhUur8wEV/NcoW9AYUds2TZxkPRMw6w5MlIZbNu0fZXSXHrcJlGM74myTget69towIpntglAr5zblIN+BlwqaIxiJXqdZf0pvexoZob5gMs+loUiUk2RxI9Tetad2NoBT0tV6hUV8JjOvm17EczFQqApwTSs2wDJfk++1GNsNM7C87ie929HFIH9FcxIoaBdEdXfDCE1vnFAfyw0gx9d5+rEJLCn7Bl6CpMxEHIZlD6FFr5qAW+EswGKLs/dx0HT6QXXzxjIj+pXOs7v2fBizaXnm4EgRQhGEdyXWc1m3EBlTLdhpBhZEPtu/v4bUdn+Gqtp2YoTUx6owReXxS9EXbjEq1BF2TkWxbhiC60QAlOKEtkGl+9HWfXJBBn6XkgFsA2QppnZVkpZeBjGzKbFNXUkzbDzGoTyyFqMPZOIoPK5tTuMpXC5Wkwy/6a1wBjxNsJkkB9zYuL/6XV9NzM+zILwAF8D6JRDooIoHKGaWHe53ZNFz+8dAZ3MliTxJwVwdsmA+Y7BAaQqlOs5mbHBLtbkvGyuzRFaY8nuhBAGls52IwfbypPIxZ1j0BcztO2LjTYizmOzjbLfSiBRPAk/85QgWRYKMdxcnyaSsT6gvfGNlAhDxBUh3RG2CCwVSubs0svwGlSQtEvnHqojGP69f2dR8NPM7z87kzgNXOO+GlLlr51C5fhUS/feOb96bwoi3uzsOrHYa1ij0d5K9R90tfmHFuZOPnJXmLM84Grn6KJZ6bQjqQU97gTkHH/W4NHJiNOIzhzGGODLEUL4S382dO0uQ1lR88Ykfajr3l7v5LKusSl6dRUIIEorak74PDmZsxmPxp4fUFGqalw9Kq9qw+rIylmJlMjzsEdazg6ffZdRoTPWT8AquqfdpVnnEpOaZ8UL7+9His86/K+B52IR5N7onpQ50SwVyj7P4ESrsTPm2nk7/veur6GAsXZUh7A4ZVXtm5tGrlTA1768fQVONCoanyN9jpYqD9j8/XIfE3bTvLho9ZRkHBjv1EFpIycIHble/OuoF9uJQGzWceL/BiEIRRTq/KFXRm/ShcwtIh5s+cEdj1XxYpsz55ly8ubYuk+7aw5+htxW9OEcKYpdHYBYsFZL9H/Ynda1GY8YwZmRjG0ukXIvlrXvLVkj/ykZTpCmUA2UFY/E4aAT4kvAvGuVA/nheYe3K5NLkcd2x9vV3mqUp18alN11M0nnbsrrSy+cktFN1RQRUVeHqxhR6M/r+XHhrkyjS/4ZGsMLWlYQKL08Njirh97OPg6yCMz4D59X5YqDHjhCvACUo8+0oit19anWYsywwedyCjyCagOtXrnss8IfMu6nDAPoq7wnOhu/375/uBMNSVjT5nzi/1SQm8WPtvIETCDSfrPhCxf2L9KG7EipaVS9aJDdFGuvf5FN4ZmtCT82xhleyT2uR94IzUpjfBdKZSmBjMb/JWkBX7nl1Erqf4htRl39rzTa+68XWRI3x9ig5NmeQPN9SjJrd1k0S2f7YTQBVvs3csHbPTtWtTo/6cPNx6O5M50VvnRDaHaHw2Z+eKlRFx1omAyHf1dOevyrdvKv8z/m5useyJ6tuTlDIyV9DF9SwQnSC2Fj8gCEG6rsSDUiJ3Gl5x4XmPmf7jgvYBih7YM47DrWsUiqrCY6dMmoCWjRJEICjWS42z0co9Jq167aMqnE+r3lzy23O7oc9zzSnF5MPAMyWexE6r9D4rYGr5a6Au2OYytphmo57S8DjN1sMEHismf8iS/x9tOWNimUrdsaCK5UsMKflMvTVSdjqusoDcN/fn1uvVc0OiYiy4cJd65PeTRUh1wt4AHOlBFf+u+gq+7za/67mT2oE++DD5JwblSO+TWqmRFc+WI+Q04CZ2HD1h/KfRySGAYCWetYTvADNcqQocOtpD2gGL09QwaMPve6LghkdzYlM2mRPZhwmDHOxyLrZHO+8nM6ssqbSg54M7zfmt0S9pkyEkO+B+byKpufxGM/rphCj2N92f+ETC+R2k1ydC0jwSZRTAB99NWl3puOro9s2Ksn7WLFjPLUhqZYFco0Z1A6W0ko0S3YgWpRZLzkqH4PmR0uC5qq1pnx5OsOdM3pq+OsKwoavEKrNc6rCJ0sBwNIE6sYffqnnpPJVdwVg2bn4zUt8RVb9MEdEH6xZsHqTnzUDz59tpxClzIv+6h/4wqIk0N8bI820PmQmzT62txiNy/1mhT8/GrmcchpQTZSnndGRVxILcYD3HZV2KLIU8l8HoH6uec29Qo+drabNmIKuD6dPtUTlB1eHf2CtfKZgCJk1J2Yzl9+b6II3cAC7N5zCdO0fbEx0eR1SSUJNSCVpiPPhPcu5no7r2o0P8shgdHmWXXuurxvkv/GbJv/ADDo47V2tDb9EidKepZEWc34s9ApRWkQdsn9Fu47SeSqGjreI+XoZt7ZoSH3vYwRKMNmIVFj9GRfpd7GGGX1y3C+RO6qe++eOG8LBkDFXDSCAFX+LIZsqeKmHjoKjNr36+QDD9creS8GIksxDprOc0TOwsME7BJNzi/Ub/MrfyxN13oBBY7UD6rVCAuNGMputxhRJpFjurEe7m+FQkIay212a7rkXgaCHfMKLY1MXAweQjTkR5Z5degt3skT4EnisCwm2bIjGi1Gb2mIK8sJ+TQkdXHO2PaarFvJ1t4Zbo1V7LdvaZBCxFJx49vkcxJl9w6CDDItICLp4uKuGN2M9g2BuVMLkMZE0O4nO7XJYVTHfzxcI1KvXcEPKRZnzHmXTuinaQEPjeRDolLTDsKP3rt4oXXRXpvV2tDX8UWIWBQ+J66gyLIO+tJjnUrrTl1sIB3ucNsLy3nrdIGn/SRVOA53C2Rz9cpas4HZCudJYNrVdbsmolSKdQzH0jFG5jMPHYsCezfHqzBy6mLcG7Gs/9XSTEfQ06W1D6NUIre6mGY2KbDZhaINeea7/JEpJiGRCQSenhEQywEn0lTkM3WPMGjZf/a3bl3cSGtFZ20Ebx3zRE238Vt9MoKgRkQe3rjmAfIPbOqXgThV9wLA3zLaz3S8HRhAFdBhWsf92nZOsT+mPhIIPw7J6s3//MJlah6RgjNH4uMAch7Ubuc7j06KrZPMQTpp8XNZACeRZEAkj9Eg2+ttV551TNR+wkcZbOjgYdnele7mJjBRQyZhWawsmCjzhZzo11xQVcjg5cog9zT+blcYffmyWyftKPZm1VfrdZDIb19d9gfFSpM5S81CdsL6jISXSHlu2bSmru7mW8C3PgYgOuf7DKQdL5Ng8gcbX4DDcmpzQ7Cm9e68O6fQeJ2EPBkz1uBI7OfqL8ajXvif7aXwD4c+HrVvx/fENY3m2hcDCDK/MNDj4wBDf0XNF90WMaRug/sLQe83X1Thea5zDr1qblzmre3lS8HKy2VJICYYEmna1wSGeenEFvZLxDZKfKP/3P6lou2FGrFkUMZ74aWo6nQsDb6w9DJGBMnOSIo1nD+e2PQOSqgvQ9OwzeREYh3nx1FcniR2gzZI8uuXWuwwaLhnOKSPZA5tRglDlIKCinDvqqVVRE7IwSgIkSiITNNrVh+vYOwP/6Fd+i1plawjgWzOTFc8obFUUHwzvj4b65sw9kJWWnR1bH78cVS/T4PLAxC0ctcR9SWqu+dqxp1r1ZRD/OxuFoZf2j++TQXRMrQNpMM932t2wg21zFXtNzV+yS1LdNmF0gz2sG0dunFe7JIa/9hfafV+STc9H+5EaC+kZxmp+pimPYHQb+KQiYFM9UMO5Zjn3L5ZbkbTyUO59bDBP69JV6x6+R6DYJuODYjqvgrzzALHAty3OqfBwBqn4ZAnXuk6sTkygLk+vX5tfyl5MV7hoEJabQ294BzmfCcsO7o4I8B0DIflshWexYyutHFeGs0hQ5ypH9S+myAiTA3fLmDDKcQ7gasFQLqI5PRw7d0UCh/Cl74zONUNmDThBstHPcHDmggAbSQhuwPyP+RORd29+m9Js+Ztt8jeEHencs4iN98t/9IctSzn4N3ToNPjrnvEkB0g8u2zRn4M357ERP6Kq4dIFj2onn7uSpCJp20gbZ5K5LpedBcoy/zJf5UzpU+qs7oIXHDiSfRAxVeff5D+KrU6HtfpJ9O5aR4ndZkC+UaNZjoTSCn7BpRi+ztgG2aN//jeBUkVkvGlGA9qxzK11x/qyjD4yO7ouL8gW3b+4nKkYF6iZ/0QNI4LCNyNbJAUASIfPPATaiJmZSO67gGx72xJaEavXdlE4UySuOfnSv45VppzYiQIlBLWOIDm7pdLBZufJI8eOGm/eUiRpMdyZE+oBCF662D8th0S4TQxZ6pn1kYv5dRZQ3vIBPhuCXzjeSq+SsFp1swGTQkfK3sOgKrG34Jc5TzVP4EBaHQ6JEiIr9mLJT7rZ2TyFlnPtaYg6DzWZLmC5L7p9Da3xM6745PJjO6W0wSft0O2n0IU8JuAGld9uy3EV+E5IO0k9zd2Yl9tPdej+W/gkGvIM/KhblJTvHGr2mcczDsfMJJfOdiP0kFEmCsvevLTuAFL65d93EnNGEgfKcqrDxZblN6Tn+NXCxeW9kckLQN7o4VuNG2nJZq/GgSU7fgNkvidfMvRJ5qcOkyu1w1gC/W6dcgsyrkBlhSiefPMXpCes2CqgKiJCiQ6ZSH/jndv9hMN8dII0kGHdswPBlvZ1snUZbwiNdzKF4jgEYnsRWuLMxumWhBgojujm7gmD9pSFdmuUPgbQMetzXQkaIK+Wt7Aws4jqJsV1RQRAjqcAXHR4TqfZwqF6GhDPSg8sl47CvEGCerNYcBdcME+GtFNpZWxwMpNM1tyAu0W/1O5WCNapvJQaYv+sVweuXfIgAeeqNsLZYV0RrNXHDgQQgxavDC5sr5qUlV5+lu4NWpet8b05ozgmYqq6WhGRUfpRoGUzmsvvNJnBI/N9UoqHl46kaDcVqputIVK96c1tmi7V/AYZwOPqnAlYT+y51cDzXs/evGvPFdyH2OfBeiyyv7LcdnWk38MYMpuxUcxSrWXr0z1yG3xBNN8wzQHKNtbpt+54R+HDmGmBBHn7jY4inncvI91L1g1lx02yQtrw6waVvN12PjIRS9BoiI8AHZ7fzw5vWa1vsW8SPDarQzR+efEQqS+m5AlB2zWr3zyEu9gSh2ARkc5AeFH2/Ug2/G8xe6yAkBiHpp14VKnkXQtWvmBKyJE0rkQ5Z1lIE2+6oR1uZIQyp0SXex+88SxiWQjvj/4QGNnfAk1hie4L4dkCkDqcYbU03GCvl73DtVq8D+WO301TciIuG8Ukq/5b1PjgHw2GBRZZgcL2/dyjYDWToy6DoC9sfsbmja3L2WVqjal2tuCv+6ls+8L9rvlnD9/B/uHwRHg+RwhZP3Y4j70BFXocQ+VZvL0UsUnJQ4IVOxL7HifRQbt8ZDAQkRcX8im0pAkbEdXlf8adz+/46RgRVL1g716sZnv6SS41XieUZlrBgr8dIVdZ8w2wmh+rORQhQaTJOT84ATrKuIxhsxI94o4VPArAlcyW4l3Cct9aDznp5XiDOOO9y3mUPHk3thwMYBDtwU1StHs4KWtn4J5cPMs4+qE2wKQJUr2ggszJ/SB22AsVQ+y2MaWqREGlMn1WuqBKjxkWXi8mBLe03DzOF9p3FUZUKdvoSechY2bwjAh1P58/zqIzfQqygSLOd6+06VHP2V5V/6LVW2rbzqoy+SPro/YHe5paE9bK1sSQU1c4GgU3Q6gM6PFeqrWcdNtcIxB6CrwCcfgOqhCyt70XugqOGT8PDibL0orwXoaHp+6zX5NOGV1Xm+93qCpZhYyXgb1tQGfaoArNHHWf8ro7k1DW5+xojL/WxB+LyW9Ak75rYTJTzSg0m5yEvsV7BxcdUPvSd4CihPgGIg1hGfehjfaWJSqkqe2JohI5+FSz4LQIoZVEY+ki+7OSuUJPRRQfyZBLoVZAU9f3rdxXmHhS2kkRtApHH6xqDrDVzsopYDEIq2QAlH2jystw+Zc7dkckSTAoSKEGHLyyh05936C0MtrnJdCPbpoGkHM1SYTO6KgbTjrSIZH94wyXZa51H9qAhdVX0KECHgHt6lsNMKJkHy2oxy4OEaWOTh/jM6QVRYgt9SKhtBY5cB5NIBXcQfV/Z0AOFD2jHcocLGDAUjlitx+G/0tyb4K6qYzJw3JbUwug/2OB3UVqyswyFL/UKtjmyY2J3C/CNJBni06+wBnKlUQ78V8dlZiSvb9QXWhFOAlejmCF7klAzWt1Gtjco8Zq24Rz8BvyXYgg6SyvonAA6ln35z0UQ/uvtaXaMRxHX+yOJ+XTpEuHSByXT5FQEfPxMghx8+w5lQWRs0+AFgq028fMQ9f2r3r1DM+Zm8ibX7F64I4v+bIwe0IjhBAzcp8FtdgMl+r/muW26Ghu06WQjr3aIf/fu5aTKu4oCzTNAjeIEJ6RSuHiZLoHUCAAsOAbKKl/Zf1f/P09OH93md3zFSoiLxT63nhJD//mRpsm557QFVycOAvw8gMsgtlr4Fp0p5H5LdeB166z+pwc4dlxm8z24+457vcC/fE1NK2QF31SX/Etgnq+7ENOitMbP8qagE1hDb7u4HKM2RshT273mihiP3z6FgOAcgVHtijmt2CJ7CD7BtyeOWtr8g3xXIhHIB8RdTZlLJHJ5liwIwE6p3OCDWa1iZC5Wt8Of4meB7PFGCAxqjcSOOWWYdBb0uBuFyTrgHlRi22WMpP143usJoePEWGFQBUqIkEPDkT+tdPLErnX7eyeXSJOI5wlFJ+5WDu0Ir40WyCw19KlhWUNR6cTSrsR5GEKgASGPffUaDmJ0Bv7r9hL/ZWbepyJMyqpPfKYxiaQeIwmddmew46YKnku2W9Br1xvOxICeq6u4yJlZ5cTXtO8tQu6O0B00MvhJhf2aiCbHl5udwmLQ0Q6ZJN/qmO7l36zmzgfPpBhwTM0/iadfGZb1lp2SQLdDl60RDAN+BTVe9U35rSs1kyO0FXj01h0rHl3LvEB1ty4fa6T6Go1a8CtnACMqRuIiKdFGGbVQ2ih5LHsBeQz2HH9VAsOQHXiM7ZIXiHmzc03AmWMmx71kuOvGc1qbugHPFNms4UYKkhLetp/tz5kXydeFZ65/hNobb5a3qZE5HWos9vKzrXOEOHFtYlRZcI9LS2ov58nqk+YEqL2zzIwsp+FrotJbJzFaltjXEcWi78/uRJdvTTx5r3J+5rDc/XJqlw65i3qEwzSa8Cqr5Q9vuVFs7sq1/s82pTMFzyR+yvhSXqu/0hRJ5lEH9el0EzLyBrWLRko1y3apPA+rpzsGsis7P1PPr4xM+MtCsTs5tyKH0JunikwXmWCVk5w51SwzBM7bKBzmGaWhBjUOD/ZbJnjggqv2PaIqxcHOHgHebDKFsKYn9AM/0wH+ygZzS0HQNKg9TDymS7c3ClLjDEsClIErA/OfYFDUftiSgEYWFxn0u7jyXpk5nes+B/UnraZsPB+ssMi9Z3up57xmj/N4uM09YQcE+FK4fZzmUOm4eO6FtVRJrpzxrMXb4fBcnDnbqEgk/ScIi3YOWgCR6OwAT0hHAWaD9kOWOueca4SZUyAnr3LxK2hsDGYaViMigr4qC+5NqbDYkI0dyWJlyx3tu5HoL/zbMFM3ArarmHQ4fcLlxeXe5iAAx2oFr91ht2fQCL8SEQ9YtoEWDZAfmfqHnRMr6vacNnEzt06w5VLhy7+RiVI0dpfonycOUBuCHtl5WScPykG5olk2o/lpUM+bh+OjMDfcO8U+r8aa8oBb5d6+8SIktahryr8zw8tJp2HDOSDpuqIDZzaD50kIZMFtHXia12gGw/CqEQP8+aclYizPPsoM7/AIraUNlwrx27MvDy9hahPMCYn11OEEen9iHCmoXbNZ1+7Juts+XyYTodwQ5wKYi2m/645nU7ZsK/mBP2EchuQzeL+LDDPyTAWF0cZCq7RC45MuceHNLpWj+Xjx7hk0J6Oj0DK/AZ2nUxan4NNz00UIihwQYfv1npanIhPpjifWbBjqGuPbooAsfyy4+pSL3HhNm8jl5pgJgudBkIWkzAmWjeemOAb3d+WwGfg9GVLQI3ZiY7xE3XQRZPJVSh/uu9AACvzNzUYBGq6863jXQ5BE+GscM7MOAHR60f0p3kkThAmYINQJpGiUAZNKfhIsh5W34cnAe8xWuSAtvr462mMXmZyEgkO3jgFgTvACyDRl8Na2I8ssKs0of8XcSiWPT0w/rDj9fV95XIuPaYAOaGgc0h2nz1LEfnifo2ZxE5hhEs80ozqGL4xMvxkDBx6FJkqAhpmZDwSO2hImZ6pD3jplQTTPvjg8juRs/ASzxalspX7aClriXfGNA48tPKSj+Vg/yM3KQA+N2ByZyqB+CooAgSgcpa+NJps0c4ueKm76uh/2vvXToU8/07fN6Mf8BqdIGp1/0mjnDkrMnxUm/jkm165GR2HNxGxLP/oS1Xs2c9XBx7J+Q6YmrW7Eg/dNK0TXZpE8x8vSL/ycK9EPheJvuR+SqlO6d4WkWrA5q6u7aLOMh7NKlnmm03fLTjX/MoO4jbzI/i3hWAv+um5kXXLcFqYMsbjn6wf6xg0Y3EU1H8cgbh18CWouQCXGWV22q+mHlKWk5BI6svzIJTjV+aBRRT/he520KZCeL3oiZllPkVgxTFFxBEUbwmmUNoYjCTrhziCHVqfnE9047j2FaixV1Q1VhZi0AbdygaHdjWvcesKPzhh4lLRNj8duqHyEeAAbEpChybZv5zGrD4u9QmM20TruIIgmiQDwqEKARmHvDiV4aV3oChZqmz2X2VcHWGyoKaXJ62+B7jfwAh2RAVh0pdrp10NM1qrLQcyaEGCixewEVQbE4XENA50gWWEXYhO3el36hJBAvCEqQ431grTByD5Bec2J1nZKTZs5VhxSN2lZKSixfg/OpPnve6BETVVI4kK2fjmcz37jmRtGof6mroMqBXxhDUr5xn04sVToLRLuKm+wmZx2qK2KeKWmG9wYv2RnU4ikAmz4tGFu2dvqMFMOGGle+GccpN4vqHj340nZD0gHRc+QfBlfm1Tm4wGv2cwOzaiiEOV0p+fRgWA+yfh6UccdPLMKR7J3n4U7NsT/xL9IQYtG0BN+yam4uqaASLqgDKPGbd5ojfVgQNRjcKEi0+gjGZiEWxQrOzUrI9vUhy9gGYZUrNdgqABIaqJiea39I+Ty7Ibc8J3Cz4JjGpLfCHiYb70mDYfypAL1U5lye1QhXxdjheq6eUvbKdWvc6xEZYKmUAKO5FUkiOwx12zZJOO6j9CK7SeP/SQqbvxLCd+vpb0ldgnopV116QJNLm8E4u+E29tDpxenpY7er7+xC+vKvG8a93Hpm/1AASRRgy7MLDVpa6ENNClt6WEW2OPBPGTCb5H+Kt//6NmGfDOgfjh/pSLrbn5H8l3NvgYvrOOI8LopqfHZaKGgLp9khl93U1/dy3d+Ycf4RjameVEx14QvZjTZWGDQyLloyk0GLMJuknDtGK5i2FFS+kMjMwQbmSI02TBI7UfeVUm4Ndh81MrK2YVMQrXzI+4oIf3/7jilceFGv7IZMxW34YlchVcfaBrdzlJI1ctfwHI4qQXE4KWGFyJDRDsRM0VCHwwXr3Yk59NiE5r5W8uls4jj8yqv6qW2Jr52/G8Jvvzy1AzmT7u5JtTnFRP6YxItvfG4N+G1a0CGlPHYsH0nRR1OH4mw70CeWT8ap0+eZrBIkNoXHJbtIuP5HNuiOP2KWVKJRRtdhZXDhy+gXXCohEfVrL1MgFCEQirC9TB2fUVWMXtwhqr8KhgKWbx/UOdNM/mu2dULTGDMdFeQjr/V6/VC6xzNQCLkm6taMfra+D70qUUMCOpTXmFCKCZBK4qiwdQ4L3PwgfzwbaEzPQl7tIqxO33kVuV0gvHkeVl0C3L39WwHAKwg+bhI1CziY6Abgm1QgvgObpyjdYlmSlvx4NnN1qDKwejwezhwPr+xbimCJFw5VmQ6tfEnxivW8UTM4MygD9IHP0/CyGMruCHV6s4z2ifNkK7Wxa/ZNX52Zi5GV3flC5bUy4KICCC6fzVBDmc+D8Ea20Djw/pAi/eV+o20k61CiEcGO7M4gG40S36mZ5ifwU2c2VceGxUmdEHYZgQvOOqH4RBTgMxfzrUViTllJXajLvL2v+fEmjPDg592aEZZoWjc+rBT5D41N9YvkjBX7NKPs4pqWrGn8upEVq+nI5rix59+zHcaWmHFXkC5MemGLcDncyNwq8JB+CWC4tlG7CkVIZc+y4M07qU10L5y2qFbYKEYsmO8jaEkaEoy8YadP7Jhbuz3WKkwtBIP3eXF+VT9TUX2xTxcin6jeaxa7N97BtiNEIHzQiMY3iKwS1mKAmH47iIJn5fiEr2P/EyrUR62US90p7AAJ3q7t9ECL9OITpi4s9C509A3AkNiOOoAqEyNgFVlMrL8alexjmQD740TKaYds0Sl4v1xrACrfuAckGiCjnmNlByyumW7of5/LmUZFUQlydUdl+xT2iUiZ00IUMNn9zrdf3XOTyOkawOi2t37vwbWosTyeCrKD+g4WAB7q0OzUUPwbHMITKOC07TwJmbW9ZTCpEBvuQPYRpmLa0FD4c3BDTWws8Z1Ia8iuXeqdAJ9rP3q5L5EB17TtYW9QrZjgegYFEXvEqezK2UJ2QFqHDK9Cuz6rE8WMSixyF/gI6LD5KdFkugP65Zg4MlM98+xdgxzm/+JPq4BU8vkkmuJmbEl8UqWXcMsaKCQwNVc3zfG4BDK/aeZ03VWDp/bgECxqkSXQOKFYrRx7M4Hxb4f4YrbfN1CXNssMmZe1mUNAMebzgHZ2O9wbZMKBEFXCSQaLEsLN8B7b1s0FqqjrjUK3VpKZgqw2Jxe5Xc0dGBF8ZnqmY8zUC5hPo9VZjvTGQwBH1tTXT+I/EC2KdS2YQ0NltaEtFtOWv/3G6Eg/nFLdLZEBENKG7dyhHK7GC0oqS4/l0uxNvXmNzwyPHadjnWMsThSXIwj2MMazv095A8UnxZK+Kh4btdh1sKqC932hhjzxhZr+oWXQfO4OvVLsbQxerAzx8h26+1Pt1A20h1xScmlbLCLUaRzy9cEE1jz/B1ePEWC7ZdYBSn+g5VA8hpQHrnE6YNKqPxJDR5i1tJenUQIJq8y6dt1q2JsQxaaioioYOwaXqeap+3mqcSU5ukn5XYyKsSYLWX7bErbMlYt2PeV1dDzMEvMTZcAzLDLX/pXLtRRg+vCNeTLuZsfudO/aUsMn2fYAc63U8Z61prXYqF1pMJulEv4mkorEpcmoaMchCY3uNxseiRwPdbv2deVGUkXXrngivK8w/rANvWiNAZ/0WWIzYe2ChLh2+AC9fmw2q3G0nNiVep5neXb1U8HZI2pmmLlEq4CGFbzBWeLhmMxdWEw12IpZkey2+9YSLwHAuwkWqlH7aF3KxuMThHxqhmgiBBzLOwbLJcWnm58/Zh0W14ktcsFfx+9tTrMCfgOLxJ1sPJr8l/MtjoYW8G23TpE0iEdO93u4hbg4BXsLVTtDnWcho9K/tsylzcF0Cieptao2GzXuSTcNcIC4pLTlG0LYxsu0LFwkYDpvx8QyCi2DptbtDZN4Mh29DTILo++mFpWVtG54h9ZXVwnyc6Ub7x4hEpxBEgqSxJHIRqxebcBqvKZExJLOVih/IutgqvrRB0K/GwSt8QZt73Kq9JsnM3S8pI1T6czztON2yjqi0tXYOFs4D9bCL1gjsl1VyNuBjC5OMF+9tv+1MO7RFQZyMXJ/t80YI57p951oH0PqqWEm5z3QlMHfJMovh0kIZE/0PaAinQyjxRoqZGkOeor/TYmRxPCJt/0zs6RgjuyAB+c7wSCSTYsyx9gBJRRtdkxE1t1B9rzgBqdqVb3lUVpt/bJAFSJQPKSv1xqWvRJcR93bQThDUbHHQFOSwS8oi2U/JeW/9SxGy569DhtNktHuvm0M9l1x+BHqCpJi+ZVi9HmtfmsviFMKQDuxat5WT0dodJodITDzkl8LTsQ0zcol4QG9zLcUIp6f0fdWnTKJg2c337zsPqzOpx1FF6LtaKmnlFmQ9F6xfbJXQy0UViWrvKFR6kk3KMsZxiLbk44CiAdK5ig6wVLGykAVLrdTf0+zHZC9sNz2oA7FcM70IEbTRIZ9nk0JqkuAE3uRBQQOaqEdqDpjYRuSVb2aYgVzAuM64xKcRpwPRcQyScAGnCaP8MxFox6UAfeuHv18hLw+mNZXTQnVLp667A1fXLJG3KxiQSdOflz0EVPePkfXazKsSXQGDcT916BJE/a6bIV87UN1vrtTxUJRu9V3bjpDCyqPfZN5b2s/UwQZLSXVqnHcZ3MYEzjoqf+E1G7ZyWqy1LbEyJUsp7snUhALHmqYLisdQXZQVRXLWwxTMltaku/UcwyMVJgaevskVhXDKn4OXHnq8enwsWhR7b8f7BdGP9c5dibmVllYbKpr4sckRw5sSSSdeBhTSvUDLbRvVDQudknyZRJW81e9z9+0toa/bWJylBe6kkxoFQmMX6LGvAOZ2tvu9fIpk0KkD47NCrb3yNMCgr49m8Syh18vJKPY4aW3i0d36IiT77T1f4bQ4vgAkoqQv7wXo38bSYfsF/aiKNwVRxABYMdiemKAOuFhiI/IkQZygVAqAQ/GeJO+XxNKXhZc9DdKFgbK4ENAzoSxsZiyNkiPcxDjJrYSMNylitCjCFXeREKZ1Gk1qOsKrRvMH66nHj984CTwwjbapY15z78CNmla2ct0HGvIM7iiHa0/xNw9InBjw0BHNDmb/0WyZ5j58+NqyEQjJ4TQWIuvA0Ao6MgIAbj+D5qClDjvKG5cT8wo5SV55I4atOdKiGGWHgDKqf9AQuopzDr5smp+ML3IVc8YzfhwkxPjMz3IRtO9WjmKVlyeKH0hUZSZx8UjcH9EnltZZp75pnuFwsbsV5e2a/ltra0fOy5dDI7eOpDHY+1dj/BdzndfWFJpbgecDUtJ5TLQxcwLubGrYLw3XQGM7D6JSHQcrvcrW0xqRDDvQUtUdEZAbsNOMvQKCTxHoUHeCOLBeu24qcOtj69hbrk3Sk/GKr93Vj+FG2wmk2fDD3Lpnr9huKj2vuA2Cj06EyitpoawrgSeRk6AtPOMY/98ouU2BWSAESuepZOQ7sxE/xhMAfX391+svN9AJ8ypphwNHJX1ruXWMBklWDLvQRSxif8xxFfzmOoKlZUW9PckMgh2ZcypT1M96579d9uErwcn+bbafRoJIhAl+SVx+ciIU7BP0dyztH2nSkCcf+4I6oiBbmIR61jWIHM1lrc1cjnKs1bqNI2SPgzfGfkxUjSkH8yU83TbSib8JPldNnPXbInxfDtp9DZ1wlAkSLfiURcOSGj4F5Y/Kjm+RAAGiY/QVxYEu/l3fOgvwJDVBJCyr4bv2V6Xilbnv6bdr/02tB1P2gtRuuuH32eg5GvUXzWsJPM+y+eGin98/MIh7MRa3F9wFoIJFC9FzP+jXUc8SeBdxVuHsuWvSgeQJH+PrA6Yx0x2D9OsUhIotDez8g9v/Ay2Q4MmU1YGzPFcPdeIg3U9ezVwvqFI0qOh0HTZA+gTmjC75fOdLsEv+jlBJ0B1eSkP0h4URlKte953MbQgYhs6FESv/YeGaPex3wyR+NHyzgwC4PDNIsWFO/GddLNlEOeo72MBuJj+ZQwLS+AWcPID7hp376SMu97yB0rXJgOA80a+dFxRDdEnp9DjhCv7fmq3t8MlATGXuRCWAsiCjiJ4rkdm+TaC7Qg72ctINyJ9iWZtRdxveqGzlcQtzkhL2+ZUgNWpTvoF0xY3tIFq5+WRTLEyfGxA14gDCQ5U08q1vxq6cRxoSS33frDOcI7pLWe9vyBJSXOBvtrFfdMw+9Qdd6Csj4HHMKE6iLADwpGn93wYG93l/P4lXz8LJ1hYfAzXjyaRdwAYjntOm5ds+DX1mPas2bd6PfNtDEmQLTJ3u03VZ3SFMUmw0vhYiFAF62kVfLhZO8LPWgd+IJhJ6In5v5AXhGhqT3XPTRBVY5gzXQ3BJR7xeyKvR/G9dTAraOkNWAGSAdjZmRlSY0p4fuYTHuTaXZdteQBB8xjPl/BZMygUOh06Zsho/SYFS4L3+ZOWKrAJyA/en+Ehw4luHdqd4nNhrQEBTZ8sz1EJ7lhY+CPY+JHZeyjRCj6jE2L7kpEA1O2ZRW+/TeTL8LCCWnAtkyr+IrNmxTGD/xshm0hIlCU8HkAjcT0nuDUmNY9pKkTUncNCvh63LNEW6qrQHWUVvke7w6v5pMNC34JndPSYcSv3HiYe+WpG/MOFWbUyNLRpntwIkwRkHciCB0nnA+y8aa/SuoLKTX67LoYkoH4kNn+il3a+ZNKn8vyymE8k0AEAp44V/7h5GBYt9lQ5NH95FhIrROpgMOErK0yaUeA0quiU6SzqYnpSiShEXiJ4eW4c4IqG+GlBDftJpzMp8YyNX4Y/CpBJDbxcjpZ5U0MMmvyNI31zLC/tXbnpVeDtvJQHD9UBVb1XT5tPRhBZO4qho7ibCpx/TwbUvDWEIND0ZOzHMK5uz7edoWqtxHvzJQUN7bAhCfwSL/GYpkINLkP3VNoQ5QwdT8a3GX86ywXw5iCLmtMKnGNOwxEwR5z/juiEcV4aaa1iUtkSKKxwF6wqkZ3tPYwIFMV2fo5WCItIFKxNtwvYeTV5K3PDjaM5It2hdeds/G1o68+roRlDgB33hvrFF+Smpu2U3A5X2q/2u0f6jQkVf3iwBc/4aDk6FqmTgx85DNPEQJso2Wh6BNJaKvAFKYm5Z53vpH9GhxwIBsjtJiBgS9EWDd54di/ZeYpVe5EwUabeaoBoq0j32vp/jeSl6tdkjktfeiMDhibsc+jG4SoFglxktOy0DEHBMLj3sJ3ciXiiBNWFwMRCOxpM6xwTeUa7g5npgza8daXaAsrj8X1RNgGYr3lVaisfcfWG2iFG67GLhIvk1LtRqbkHigApG/j8dbSfOgyuBeoUD7+pS1ReeeNAsWMR5PEqckPvlaVUfYbp7BWogTCDHynM7Qxr+97t4SgjdborHETuUmQ1/2YirzooASFlDLLYiZmuj7JJ3Z4rMxbD+AvclFXjiyPVag24mOY8U1oIiOEf1ydDF1rP53OQTyUjNPDWu6L4FjW4Z0PieU4JBQ59C44L5Xi+TPj76COfqrlG7/RUwhaKwtUJ2Jq12pr4PMZ+1+ovr+PzGqvBleZoPefWL6BEvX6vKkLlIJGq4pqHIrE3QBJQDUhsCfNq+I7OsuBe4au92KsW+JEW2nzH1PjdzDOINJ78c/3yVC2Uq4bNyKrt90qRhF14J5PLj8pNIFxLBuZB3kBVaQ4MK4/8u/tmVXOJp1ivWG6R7kB/3I60aK2dan+o143D+MaT4QGIgWz57KFO5hiPQKuf4ZJ/eCpx8fr/ci2jMcNFQsA+pGxKreLQN9RUWZXe7neZHQw9NSKtBx4BxPNMy3UORpGaAuMLQmg8F1s2t5XerFMgN7tIabhyk1271yBgz+xkoNbcunhri0KFF2cdMByM+FLtw6duP9GjYw8ip74MQ1e4OewnbH9Ym7z0VeW8UXrJqhEXh1AugUMYjslKMeulqi0uzDfWdIzPZFwDykWqUAQ+7bKJzOUHmjpskBp4idGBCL+KOo5Ul1DwMKAmlT0RP0YnwbL6kAHnmiUjfPf5WirifwHz3wzMU0r39mjTqiYP4aEbBL8RZUyhfdbWzrdDhDyt84BdY7N+E15I+wiPuEzFpOH9EltC+GaveovSiFH2WTqRCd+z/a7eO9qvtfzChk3QQcJFnYxzcdF33ZYokfdAvrfhNvHZ/V314rnORpGK29fS4hIi5HzUg0lyU718AE0uZBsRuV8R1hZFvJ47nx0ZPLAcDBl+MhXxMdmGsqBbs8O3p47nhXvRK5mVmk4jgEAs+DVbFijBJCVGd9e7+kgm7n4gUOrAtR1+6GwL3aRAVbPu0dDuYX9WpsT2bp89UyqHCEsDfNMYhxnKwgnE547DOxziE2mQEIKa5f7D/KNPc/suVMvub3HoZPf3SB1xoQjNd3BgWV3SiLctkBN2RFy+y556V6bw9OQSGYF2KAFMSgGPr35OgrgD0FpcFW332J8A/D7M4wh/f7wxOoNEemxZgJTGST1QMiv83FZlV+qhWQewmHKGoKvhiF8bIowYk1x7nLJo6DvXvvGV0HdHyfoqM8qaHpnK0CdaZN60nFpMTfn9tPVjOExu4qI/U3ipEHUhPkEK/BqdfL7IFgHTwvcj22hNUMrihXFPxEr6PFPd9Q/lFytuBMDTIlKgASKvj2E/fmmpg3bDx5Xr1249Nh90a4jqI8H/UGz1RQdizGFDy1lfKCO/axm6HQwMqifSQ0qfhL6AG6EWLCHrs5+iqbnP0lEuMxvXfZ0E4y+6RVctRYCJONl0Q3QFi09gL01lzS/3K2lqftLo3FIvG07mmwYLLpf9/z5yOYcNgmuW7WQcc/cEx1kS+iNIJ/nbX7StYTDJ++jlulouIFqDp2RLDR/CZTsxHZlAyzMXYTfeiifv6twYVJeXGXXmSEP0lq28bqVn8W15BxfNh73MRNZzqKn+XGojM7YPAcaqpuYG1uhO++nbWZ12z1Qj3WYJCMDrvL1eJN7rUG9O497J/juihPPXbWXE9h0K83kuIQzvO93gnN/4Jc/Odf2QhRt6dUuDzy9xGSXIdcqFHLzVvSRxRS7NQlzgAmijDI3s8p10zQy+rSyD3jQjp4QtWupZUsnyhjfznAbCuQn/Pu8DXaquAntkzrSGwCfD1q0ruGGR0w2SXncI/LWhbJEFZnt4SY5n+xpaDBoNBL+SAqzfxSnFlBbdr2zbhSjtl7ERpnfPey1aWc4pRWxJyMKFD9Je9MzUzU6mVMJXfhCcht+Y/YfRBMY10t8Fyw5qgI6ItIge0zI4vqmEmWRuFzQi9ayIW3AKnLVmb64qLERlbXCycRSQTCMoWuaQCUblFtwT+u/p57wyfT+qMkvbxc4q5jtW0K/NfUtJ/WvFcchgr4qQTYp568b46+m5bvZMoQMCdOzmgUTO9c4+StHOjI3WokHP1/44HB21b7ICdaWGDaIjF34MGFSzGEc4x+0aqtn+l61EG26tHBc1DTbby5VKBcMa2d0RzTpf+GNikr8vtKHDEWLwqAiXJ9GDqz4g92fFDlzrtncE7XlwDMlzoOj++IYb4JjIH6rnLYRAzodcnyAsLDpIk3mbtMfOUmVSlKZqK26B6e7t4OKiQbYVofXAf91UpCbDxTa8qiwd8eyTQZTkqbriKUaH0JUkwOdpgY7zxtJbGGjTJXrSRaiX9+xdw6KAbcscsSqLbMfVk4CqFI7XDJx+UZ+a0luQQ1JKAdAjyjvn8CrnB+L0AWbd3HJB7tNyDyDtWaHfPfGVyMFwndAhjOrQtWyxx837W6danFD9VKPkPgRdbmXu/V1jhPO3qCTugNC+nRWWVK3JX2U0irZ+xVYh2ayFQyHcyWP+EddheMCsWEcOx+LPciV++th9w0UODkw137gfuUHlc8E48sp8fjX7mK2+QLTgxYXu1neefRgAerTkoNFP+umemIQ0WyivoaujNxQxHdaqFXY8TlVVAAX1YEYW6iRJVkwp6sg8OYVGPhGMoDEPaT+kReP7zM8UZwOEx96zzQTVXTDGABhCDAEYoygKcL985Q/J7S8hSm9qf6DRcA6m/IoLTLwVP+KRq8lTV2fKA5dWrxdc0TghDe6HcQJhl6NT9tLSsJO3SxOuhVVJnX3nFPqIiqgtNT9f5hzRP7wWX2ulWhqOWuokWO1rR9ljmZRJ5inbFpl4D+smMAA/5wYhowdNkJdRGJljnPROlsDTuVqSkeU58gHtNUnQVYI9rEGo5hVT0WZHy13miaaivm5iYzZoEmZsMpt8+87IGkNk/mraKYL0Z+kWFIk5YohTXTtuePzFvONGxYiPAZee4lGddqV7Ic3zUyEyy+JHv8Dv4bNGxCMg9cHG3YUETF1vRXc5v83NspPh3tH3o1qYtOTNrBwhRK9+vEJ7gIrqduSEi4J7hGi0S1ne9L+ymVGf/yyfGDOMCD906ADeIQWGyfymqY5i6eyIRYaWA0CbvDT3dsU+lkzGgAnte6e31obO4Xhghb6IWlN/QGIbUDOoM7aYGnBZTf3E0Hum3b9wWq0Kz40x/5RTtBVHIgxhdtWVHYHESzyb3Dm4SpCCXwwKPaWqAcNvXhkyOatlB4qlW+YIhTxffxWXQdYZZW9ku4sKOjKbu8ay9pSMcmqWAelJfXxogZe3cPHu9Pa7Cy7Eoe0U731gPaho0nFXVVYkUSu1qGGprc1U/kW/JhedY8E8Dehp17v89gVFstvn6dEz6+ArZ8zgBa6cbotAVCyUniRaET3w/PtM9GKbZ9CvZQpOaqGhQ2ri5NX3aNHJ6KEseioQzvdXqP0qN0+lWhlWnWhDTWdDzsGDj+yy3FbRIxlfA7JnulFKaYzUm/qzQYteEm/+ANtS71vuHsq61wCAS+Ydbc8F5HlQRdGpzuLSXDnPLd6lnJXSmAMkRbnY3o+lYzU+W7h35x2lbtJU728/cGDvp0gGyGjCvl8Ed63fCIJJAc62kLmOdsvt/3ajO5QM5Nh93N/sK74npAju4RBHgWOo19+6nVC2ADFsfsauRLeQqqCzvSMqf2sP5O41w49xtcSo0Oj2Zh5csq54wQlMNY2U4ZbfCdY0fPwUf9aLT4oOphz42nKteMrlq69zMY933EDWIRcO0gNiG0OspxNXIYlipienjBdGjxfOTIUah96v6rVqWtqFQXpZhIs06AQ4+3HHD+DspbwTG0lqyZitrtBu3McFCGZHYztR2huZT7Dktvdj94/Gh3psMyAc3EyhEjDihtc0qEKxdk/P3mB0FZiG1qwy69laz8GqxLb0IlT1yFcrHbHmz2HftzG/CjF1tD5aMj9P1g00QaR87E4fwSrissJgCeBTtJVtOOHoIk0AktwBIJ5qSJG8WaSs8hSQ7Zux4EOsyrGb/nkt+qfW89VVYyX3v3Bv4VKyakNPFtxNDJcvWGFkZmBchNMfFTuoF8ZvbOZlSbcxnncaW2h6qF/0Cowlo3BQHOFDZf4TodkNDO1WoSHNzxXGtpVO8MEh/NFZha9Dn8m0ODSe9J5jDpIKD3Mq8CBTVYacnqD/VsAT5dc9MSXN77GOzYz1oylQVPugz7/WC6CEGvdQ9UJ03lgCT5MD8cQILAbz2V3jOjnD3q65rHbxtRgQ9YueEYYBQean02//U9DZqYMvrXJMT9WN9yGimrSs5qXCXvq1tnspAcjL7jB/m+H3aU042lrPB3qKOnFoquOsOrP+iDa5FIeh3J+otRRFbtWu9Oh1YwR3uxqC7hwPBX6GOYOjLd1WXp+sv+J0DfG6aG0YdPPLbrXpJGH6duBGedzKbJTLqZMb/3Rq1nVZan266LGrDmFjH9IJcsAjC8abZNoIEQMHaFStnePcI6AtecXAXDTDPtEYSfpUbufIsjxlj1OxSVwnongV3CzL+w4TpvsVh54sd+W3qqdrpWXRgFWz91ce9UV9MVxNhN3USYC8jA3bYyH7zxkQcCtZwRjVxb23UsFc5TlQKaQWo6/Bxs77yQFCIbMGTZtDOAB0eLMI1IGAejOtg2hoisqYGH4KaxtxYV5CK0PTkCM4bIiPDJiAaZMNkw7hv+HAGoaTJKyRNQyp6eoiWYb/0yG3GA6P044jd3CVAq1rW3o+GPbKoPW8kK/RzIc4IHQI2zMwp98rCD0r9NERq3A3jB4CEiRA5fQN572s1v9B4La9RMenfj1xB5cZQFOS/hhnFsF/MHOGN4Y0qw/t8GkoRENRkaHsEk5ic7glLbwtWCfIHTdaz8oTdZJO4Jtol9/P8G2QympITYfc/pGqozcbiZchGDpUwpYGBu5+ts+JLxPs5jYr1nxpUeMLxa70kFKH1GZfcom2mRBiU4vx5EqrcjrS1IHfPIc43aUeFvSiyvU23ki34KYpqKg1qGC4StpflY4BhuE+/8mMAu2Fkir5HNoNonIsltKENHigBvwbdceo5cwqb/bnijP53XREpcajM4hcwWsUX3+oTpsAX93VAAvPrjTNMSkei3D2xCD3DbYBCdsBPWw88wyiaLsTn7om+5xdUxL2K6TIZvzciehW6KZqQzh0zwJ1LaBaGGjomqVwXEJRK2yx7kEKpOr3J5ynE11MOVJKQ80EVezuZ/GD1qKpBw2cEX7D1AXC4vtFpAj2a0U9ki6crfXwPaG3779FZUCD770Ji1W5zHJan8ophqOCt3RVchYWfxJ1yCjPubuk5s0Yu+bJTwc3MGD5kJ0k7EDzP154hxWwUlQxezK+olxuAmnOf7KSw1KJG77Spyj6fW/XfxBDfh/vCQbeikcm4V4Qj2Q+N6e7sWzCTHlAu7zDHQBAqeDy9p/MeyX1XlLKqPeFozpW3wlReODgcgRw8lfXLJemK/EzFPzpj6cnT0wlZ6cowJJhWAlDylV7K988ZUZ3jsaGxSNY5C04864eabOYoLdQ2wccfhWyUqc29qU39Pxf8tJR3Bn2qw7SBPhqKtX08cNISfB/BpnR1Fj5hS3LBpP2H1GMoIxduVhTEW5J9lA7S9EMlK/75gRmK10GRAArrTg7cXrOKW9H5qdTQPBTp5CxChmJJIBK49/aULtIGkNCf+mV5D2J62u5AHitrVQLkgkAh1CQPjH9SH8s5aPPK2F2hvt5KYSh9xJl4URUkb291rwmdUSTt2lWLDz41TON/ZW2Vl+uAE/NfviBSNScewqF+j2n1RzmzScofwV/pTrt5ZXtjAeR3UvDxEuBqO3iAMJgvq7/jolu5mlyzIT9gEVB17mdQki8mGzBT+X5E3sxcH/1MqJuKBbzC6AZVv8+PF+UJ7LAFvUgzW5X2xIIFnT2l8ZazeRS0JtVdVSib21aiwIkWDYpij6XtqOxSIVnvhQvp8P789tWcCzQuG4jTw0RNh/6sFwY9RRjQ7KmyY9vlbecMMj5THKVvHjpRScs3pdqHQL4TI/AFUerBYdEVQCWngLyKHEzyUFkdSECKeicSeHZQqa3uVKPT+1R+yg/2QAKwkEdk1TtHB/F7jK2bL0ZYuCQJBA41QfsD8sMgL86SYyYbTsBnHpj/6A05JmEpb+6jcF4BZTil7Gzg9jXT2w3X6Bnti9KWxo2VvzX8eXPkPqLSbj8fEAOMOermRD74kgtxaSQZLzJ7gx9ULdFCtPo4msBD85P7KdB7jT9yRJFonxffLSohdqsbuj6sSg6sZgWPJMHHEdjrc9t+EQygqV82gO0fpNwLTlk4KO1fl0zA01NSIUqnni8JYyLilHNr7Eyrkhp3CMrwN5dimBTiFh2m6sVhBNceP4hD9OCL3Nyyts4l2SqsHRDW2neNVS0hbjDnaQIhLyEATJFACvMhBj+bnumnbvgWZtp5s1Dx8yH/w+M67Y1M8p9Y11xM4pwpkiaUtIzeK21g+DO5ghotFe2nVXS3Rore3D8XfK+trDQEpa2y7fU96suEhDNzydcI0PXVR95jQbB/BzUeyN4V7up/g/D5ZxRbnzPbjmNWXS4qi9zMSdAgpjQkRvznn9xVZrXHm8av10/7HlhimLcrYOhOkH9vym7rrhkNnB57kF/tqpfDwCsBjrgugjgQZensiaaZbTPfV1oUvpRkuUwk1RDlx7+JsWNEbLDiipCqCMZVTZhJZevdMIFWcn7BeKuJHXB2T8oSEQCtmxobRphLNeLCjHN8JYtwvcjTQkr3ZYKBz4GdNGANql3l156E5ZD7Dd/jqYKiCBfXw0muErRq5miFCWV+xfESni8aDZyDDEjIa2eA/dx53PHu6HSsY7S+P1ibqMMkuKZDdQ4lrog/bXs/qrskD4h7w/g7D/nw7wpsV6NHLCpqDha4VWMAM8aiHtAu2iJgGUIKSiYbt/Onx7WP9v76HKE/GszSi3b8eDHkZHa9r/AIvzAnMPiguacOmbDPmTPYo/LcnPl0g6WWlycMXx1VzesqFT6fxGCXKyVZqFosV5JfjJ4VFAO1Gp0TtM1g9Cwpz+oxHZ49zjpXlAxYvWOgbctkhsQRQnGyxdqUfoFjBtqASYuhCNyFOTLCJ2vbhaJkylM+pnA79gxBzHup3bO1STdhBN3P5MTPcxg31aiq+Zz0sjibC8UR9MlUMEqAc1tJUdBZ8xniC+VfSeSn3gWH1sIkkJZduoGKR5I6mFRjERe3vvCi0LzSKxjQy7DH2zE/U5aeGcQiZJEAk79mD8YJTBNeWvsuKBO1rr1E/0WSKSS+piAtolzAkSyjeaaIotGfoipW1BuFh8tGw3S5CD/TLrsJ+of4TgAjFgYdruClsiQZin25Z9KPbJ7FuTEHvBySIJrYyC1QHwQwF8/zPce7AY09svkcKhHbuTaFudjzRpdchJQtvRsbk3miEyrmkecrvLLOfQ+9LIKxcelZV6gJv0mf1GyPldbOQbY+mJKsV/kO9JdRZSBIeWcJSzuXB0SA5/8nTU13mrCrNCE8ew71OOctHVByhC46hEOLaTVcpM9neNvcG8aXCS3vsRgTI09vqwCCHwhqo0HMu3ewGuB6owCssCZwB/Esm6FZ/iwa+A65bN9YuCMIZm704RYQVKaPmXa4orq+ZFB4qSm+WKjvibHfRojm6SY+2Walq2/+6EZNi7aFbkmHD6Aie/HRqdoZd25DqgUE5KhuI1J4mUKG7SSMVFADz4LBlp8g4SEl+9Hfb50gRBrSQZ28/PiDo0zLmMA87ei8y82MWBrrLBnBe2qDodYpjBxddZ0m/y4VGsOggO/HNaqLgalvp0M7PnEMAMA6oj5trxMhcX+smJTgBtfdCqzA/ye67RtKOKDkYdIYWxOGBE1Qfwn4Hl27EFBuZl2+m9w6NqR3nr2ufC09i4D5b64U66LaLNOHgE/UeRajq7IzXGFWXhJM07HCzCb6L8yIKdvtMCCJqcPsC6oGVIEl98rX4gpd2ptDrZweom8uNySyqYiUMSL81xNogLDCw01z7amrIXwXwzExSYgc6lBY9gz/83fRGGyHbsMtFAww4Cmx552vs8ZZz5ctiPjoXsEGSLgBKSNsEREEISXlEW9B3rV2rqjQJ9IjBlyx24ryiSVtCmz18Ih+yHCgs4e6GCXjxURDx3y+o+cmPd/kpu9T+5jxXVsDS3TaglTg0duIFI03aflBzBnr5ipPR5CxgPgFjPQgZldcmNU0te7RbLpurIfU6MDTvhzLTogh1G+XwAXrs8m4+LDhjJqBjrkHiDZ8eexcgnQORW75PadJTfoUJlzubNqnZMZbZvdaSoqFzuuOs37J5KCr8/tnH+K4L/GrppGuAv9bs++tDAfUwZhxdtMUsqq4LTiMztPrq7VlkEOIg0beJH7b6X33HlBGABCkQ5NZWjCqAD3P2+TIlRon2IujzUJ+Th+tdbzLnrQCODiHjE6o9O6GvtEzeYM9qaXpRE5pldZd3moVGVa6zy5KtPdBQFGQf3LTAxg8/6A7MYpa7ZIf8uOWzCxjnlpKVuXjSBcgcOtWAVZkx3IQPxx5/vkX0YhMPhUwwEbZ/jH/v10JWGaRerDkAE+As4owlGvYxN6shG+F4ntSlU9U+p0J/KnxFBN45zvOwbZg5dhx4fe/f4nbGcCBq4lo/unRtmZ3vM1kU8lUMFBlBXwxAidBFITd0pa0qE1mV1C0QB3ocWQ2tXDH39o7E0M0lIo2zRvyUbMjF4IT+rC+EKlFRRxLOqzuejYwEWzOAdnV7XBSVijMfsbLMk5yVWuIShUyFKP3RbEMoha/u8C03UV0dIgWSl64yAP32A99rdifTYrrA7X3b/gu42AR0ZZPBKE0Z9E8O0uU8Z/D2kL+fJRz/VWakG9T7evgVJEXZmRj/l9owM3XPxHgjxx6WSiOThZxydjaJ0qj3BJ17oHbf8Jbhot46kdcdz47M+Vzm7BpiyqD9hCH17MIiQY82NrvfaR6/8Gj7XX6sv0D3kWJsymENXl+dElv3BjPK5DCsqoxnsYr5GFS+cErM6Knt6DXmMvjOxo+sbiSfroAC5tQEClpjnrnq3bVzbrxPt+rGrKoA1EfthnIqekbWcinOEfV1XJ4xjb7RtjFWZsPkwqmXe77PyXl3cJTqA+pr0NJS04Os0iEkaDXXAqiafU6VUKdUsYJSgBLnR7Bf2KQvZL8LQ+MlJFnsyiRvEBYjK3MdqgjW+SlD2frhaEjEMI4TcfYfd1og9zmtqYfi72qEDauTUjt+D69TnIWIN7aEIiyAEydUAmfNwDikdT7rYky9DGJLQ+uQ5YnFGyFdsRV6+pR3pt0zBCNcLEeuY/42z0Wil9HH5BnDh/9ENl1I2WiiH1eQWeiQhunGKVHnlAUDI7cAsSZYHgcpsxXNNSRRvx3GhYvewVCHVoOb/nJKDhBOPNziAqN9OVVlgg+z5mjKn5fVFdiJB7EHgWvcn27BZ+Zeb3PKMyVyDq2lkmALLlWRNnxZ9sAlgmV/45ccIiVVkBc1WKekLmA3HKAAXSnt1hPIqjSzMdV+jG1kPFl/DKEc7PkrZvqYT5WmBQDU8pKGjeLRgeVU44vGF2ECTcFkVv7/kcfbrkNns277RIqQJEuzkQTOPsYuyh4kIFSD7HV8N64Azs2xifqC7uwAj07baJAkSRGwKaZ1nrH2cNnHW4maQzu5FZLKWfOX+nGp2KT9ogqFg2vKIRt3/yaBid7GrCkuiTF73/sQ63cmCLEO6UpclHtym4fwLu7CvbyQtfECVWd0Y9jVXfc8Fpnc8XXJcODtiOltX/iWV1nXAkrdJxAlESHhQC6QNzlxdaUWnQ5r3e0M3bjQi+ldAWQAC0m2Ah8hfEJLC9I2DdSq1L70DS1EHL2+5Mtk/bJuJDnwpfcLddPhcLLoDKkLlsHtU69807Br7ePMO84CrezTnOs9w+MknhWxPT+G+ad2MtbZnw1luDU8wfzTApH8lbLUbuCNaHF+ILqLNCCjzdG0zWGw3vM+U85Cq/4Bx8nqOKYuk79vuLYQjcy/EdXxjT752vJWPxJ7oQZe7leSK0H07VW9Y/T8NdPCTneav846TiAhbg8LBGObunWA8i9shF+z/SRnUDSPRB/an51G4Fp1fufh2IZKwM/xz2zUPqiW2AZT/wj7Hx03ridnJ5rmQvcC5Ug2rALVH/gy22ojoyZv7wg55RSysLvolOUmszBar5BQZJyfKnd5B7bk2gdTAuajoLibAm3uoUhXUYy16H2rACKjh6jxOy8ZdDO+/mOzLVyIg7Lr6Hz20ejxbI6Ms7s5Ch/CjrWV8r0oEUtx2+IzNBx6QRwP6Ry7alJGF2O2I7mXzVi22cyROFhGqwGGTKmii1UmY8eOTPMdrOBqBSToXdC28jgk154c+wtyG7U1KYjckkIKmbPLdIKaB8AfDg3ikfNJKX9Wb/HJOtB4T2hspikWyvAPM/XNksy/RUxs8JM5LGZhDGr5TzTNcOTTRlvW/TeVBoVs5Th/GI6qSzjDsKcwfwsUgQsPAQyQaByHdncjjjFvz9eUa3gahclU/Mg+Zm/29lCIkLO9XQkzqtOkRXko5Xi8dJVtC/b782xEam9ChLWumDbuLTeWvRca7T03iFQlwhsfSi9trTvQrokrPrCsoQ5BmlHtY9qTiwJBbZDYxayQ156W0igBawhSEp9lyWjYs/kv7mrm/0O5JSa69gYvY2MTrL37jjdJrablMDTZmKwZtvOSzMczttInGp4zTnDueb8BMG2FsnvkPu8dc6oEqkCuSW2H4lbpgFDkMcSfcmIEVpCiXfru5dbyHey29U/tILoSvWnwYDEdK/RFuHCxL1L0RiQls09ac4Gsw8xj7OBa23OGI+LaPCYijrl6zW1HJ5ZE/ba0sYh7nppGmyjeEa4qZLz3vsumnZ2I6WIqmDBahO1TVuGTwtlM+pIQOJhFM0SsSyswlG6OqC6kAsPoG+ZHi2LTk3yRuIQc0NjhQKpBPMXRDxvRIi5DCWeWIDDv2hQDDMUNXUkPbwLg068Ay6Gtq92tT2muFbzGBbnlHdzfLIjx9pWc9cfO8Qt0cNCSx68u8JcEGgmwNX9wHsk1Ae2ALervGqZ9ufQZcSY18753gDfc1+lIZOoyyNHYwG3Ax7fD4nZgwiWAlIpmkIIvZwcLv05Ry0cErmZaguVSO0Y0dx2NNtn/H1gEDI6HbI/1WA+PrHtRz/k2c0aOSiS2ihbrpZtczMT40Fccj6Z+siA9NALOa3KCDdhrZ9L9nz1/UOHMS+C1juOPcXt9+YmcF3dbMT44DWr4muP7UtVxXz/zMOEEs3i6VF67sWQKPrqNiNGQaXyVi3AFh13FAEzL4AGYaVBTiStmSSDUY+rBG9ihqbwFOa/smlLVSVPguAyks+TWmcSChhgqtxWpCYKIaU+ehEb1GmHwCr85M4CmzcrK0jwbXyBysmhBmLlw21buNwyJwQX83ZCw5nROMPFcKVJqADvKR6dCLsqYw44A+V4Pb4uZq1BSOTUfEpAMX9gozedlmDrW259OMiAvoWeVh35AczIZmu5rw8NWMAAZg5JogATz8ThcFmnnFPn5spurFHPwGrx6litXbtmaxdt+CxOx3xs+ek16w66cYujP+2KRToooebkIFGQcJEH5LklcIr4bHmNpLzmGU7DqxCiUlQvfX7M2yd0Ajk1EVkfmo3tXj5/6eH1Qcz7pvMe/zLK7vxaeTuiEBKlZf+qZT9OtkAPCRNEr2nAAbg3erJcliKyaolFM57G33Kp+5znkkiv4kJD2kCdyy/7to9jeFuC7GjcYJO+axYjMfGbUgFAyQwlo7YZNV+LBgWclWwuMg1Fk/0JJREfC2BjBv2jNJ73oBkep7EhHdvwbRjhpLfRahZ2JRcU14QBF3W0NGOsX1Z8NvcBRbmp/2RPDF8R3mORe1/mKQgU1rp1rCc6y70xIXhtBXyaKxPtAE4gg0ns8L//FsJ8WrRnh3/2d9mhf9EM/SiEdYvB2fI6X8OlYDgerjcxEm7VwDjWMIiMX0fHXsFeH4tvuKzhHzDRMRItKl6dycYCRACgxNC3yUcdbxrKixlH73CmyHdNNsxueASKGYIDKVZcRfRPm4NR21ZOeklvAvIBILKNhPm+BcCbWUwhaRGZNSWVQoM76zP4AYLsNJDV3A3tbnTQj941DhkmRmQw2EzpRoM5K9dT4yUYKW9V5Q/4O5snhMsPD/TNnUq6Jl8jsRHV68vIkH0zpOXaPD4mKq7ucyxVtjDW9geudDg114tuEMPJVlKTO00GMnuC272/OKih3uPSFMjDB8DKv2orIrrYpg/EbFn6O5AghNzhv5Gt6pNYh1McgZ7Ww+zfogmwPhj15ex2TLPHeXLVq8WW5Uvs/p4HnxnNh1u3MOyGN/UkZXQqLPX6WoDivZIniAYUmFBmZJe4JiSNfMH+qc8Id6pCFI3XVLTSkHm96SCUuaSpI08+ItrQeasOIj/SNpX7I0yxwCta4isZE2XzGygB+3C1sZKuWUlYfyCjFPg0WIv1iSPPpzLCq7ERr8ENjWEmf2quUzgVtSSeSEA3oyxhAbZIC3JpvBo8S9Y6wt/1CRR8TgpqZRp61GQ5qgcMw/uZCU+rko7RvMUMqnS1zqM8OIO0rGtIxJ5lBNlbth6Bt+ooaC5TrX+/8qjvW2qCEt0444dnPBKu0/c3AyWy5iXfDa1Pbg18pIGsVMnbIrzt1i0dnoof2ah0F8CINc8vRzENHxtCezDcYDSM/VqWmRm8VMHg6n+PgPoC24BjmXdgFRQdl8xzV4yeGgRJT4t2+BiWmk2oJY23dXOcFHYpicoEOal9xgYKGZWiMF6oAYXTLJyYcRj/uunPCtZaX5g2ID0oydFqsg8b4ccc/upD8XMwh4Q9qa0hD1BazyO2JNdRcx4xkYSVhy/c8TK6fymI+nCO9tEsWqPCJorUv5f7F+nPAFboWJ2OacM7Y9rOXoktdL6YKtrvRqFyjmuSaz/ftoBoGEoCmxjWaCPk3dCvi8i4CG+oWZ4Cvt7LXZy5pz7pQXj37MLRblQC3z6rpPb8IrU16EdbdNWkRsZOLy9S3sZbZ/JVdl8rkahro0qKzsS8VVbxJFVPEt6FjJAnz18y7FspwE5kn/oqbQqrsm8B2rqqMAY3sl2SPfG25o2e8kNiNnOuI2E7Enla+cnI8ZD73OGk9rl3AiZcc+IHYHr1lVa37yNv191qX5uiY1HmX6YQn11I7tAmFptKYy0piKsW1z59Hv+XGoU2RV4czHWnixIR2O1fjfCRkSprO3exUjqgIvB0FwfnuOiADZVI7WFOYfhI8+qMojpN04YGR5ZbAGO2MJZzOjqxVEJUly8pQa94NocTl0t7SnBK/ZweagH3ttWbJhx4Elb8kjuy+sYMBIV2QgYEFLNCeAW8A68uBPPoWcvHyZLZpcry/HasROlX7tudGmcMJw28wiZmatztVV1w3qGv2lpfrqdyGgrJpEGbxgTc0FrDjGLgNa3fSu4CrqyOo/rovi04BySfaiWcCycrIOEECQm53BlwRREd3/vTrF7BDwnMJYvhBKjI4kY5MAC2GKL0I/6+npVudH8kORjPiVN22VvWonG8X8v2e2j/WyzcK/0M34mn19PBOzOr9IvCy8EKKeu9HXobrQDmcubOn4ZsttWt6jJ7fciaV9Y4DSqjGme9wdFBaKeqBQvgqXpAOoB5hIyihdTgTwesR+tJeeBePQ3faegqzW2AiibUZfstJMm0Owc0UxdIrne/sEydMm6dR8zpOy7ORl0MQleBF3/H2og4kt2gbF3+4qkE/jOS4fNpaWMK8+2Ackhi1J6gPAB28vIiaxzgONoAYrjb+FHaw5Nf0M/TmxxgBnr8mlcm4cjel5aGEGAC14UgTvLXd44RtiDBr+xxHkaL9SIKLu5lKwdm/G+K7tkPtjng4cBQ+8j2GkglCkVJrGBEZ2rtMbifD6um+ytDqy+bvJ0e+D8lH7jxIPue7nXDbjSwemkgwZkyjjZ9BZFfrJ1vZdOkVv+/JVc0KVLzZXniKvqBNqoojs0NvgjfPkO8B5gBhbNB5K3QN5sC/1W4hzcf0/YCx2EGMc/JbvwMNuqXPc+lEmMqmA7HZlq4vTOFzk/lpxWxc+oZAnWgNRYfGwu8lD7LAondR2HMEDknJGvxKjh1QHV8lTfg3yizt6ZMBAX6LXwetSbkVRIM87lKnj6OoVach778juRJvhDSikBKhEn6pM3zw7OH0Ev3hCwOq81jDBES5tIUzP93/PUCmiFWeakf1sxsvzwnh0niRHwIqjjWhg10dDkmp+0eB9+40JT7RAjUuZ9QSoVENPsB/ydvC8QTKzDEomoT+ulTsKgkhxIh4Nke3iVw0o7bJjk9Xh2i7dvDFememMW+kUxQaS4Lb6TtZGRhQNIz8J9mqUDbCLIxUsGZSwIwSiDF9n1CxkHASlO40IvGk3Cd7AH6i3hiEgnnUXAt/f3731wj/nkndRUhyMpUBFRwEOH6MFePPskM7x3i0hdHkBa2HiEFpfUvrlvb+PZA7eLgeE/YgaPBpVGnqc+JrKB8bpK5IU3UM+P1d1bJ93+xYiqhEO1CDE9UOVb60tuR9Y1AwMmUSSgTefnLUzM2Ru260uOdZRFosDT1hWX2hDsooEkQDoflGlxMwyURda2SoArv5NjaxtAtW1jUTkicvWsBfZkgo6w/bXueE8qDRorAYMOgmIox+qBzLaiDFm+22kBbMWEcGtuInR63B2fnTpSGYI21fkXk6/SeTetBt5CdQeso/QpwaPvVzIW8a0thDx5VlamPARkaEgkfAHvKSzk4kTENPXww5xtrekSFBhlXm9SR1DmMXGNWjGvgq3cR0Q+JtghGs/mN2b9/hTgDdpxOl0tKT96/mNrKNP2Z5c3R7ZAPI/5tj7gXh4fjcxPi+/96w/aG9oO58E5uT1EJE6BitXeG81X/qmXJ+lUdOXHTe0RSMWEH6hMf+Pt4fOzCM8sO8GzLs5DIKyRBQCnr+6RQAE6riEgCpjA6ZZQTL8IGto2C/Sy50zTE7zT9NQg1n/7EMNHz6GkJsVmtgLs9uFW3LtzLVfIbe7wv8kieTQgdL2Ls55SxfD/cxfSzSPCZaA7624THkQrsoG5Yc+bLlLJeiRtchKjLBZnFW3FKKq+RLEQM1oVSUZR+FvMiLs7JLAPrl4977zOIuRwcHxBxCUxzbAjaTeAa9v/DSrujXcgHxnph9uolDM48xVPDVsxNrvB1gDymG8xayrTJDdPV2OisLuU+HjOcUrsLRfXDt6WDjX6vv5C1IlLX1KCa7II35ku9dUuC5Uk1yWlKBawujRpcj4LDIri06b1MGjv67tdK79HqgijOvluKMPynVJvSg6hVe4NxTtxF3XRFJN56bQ9LrT51djhcSsfFHh7Z30WI+PdoqZwiS2pegvv/g/FSUb3KfNIPpR59o8xLWKtCIgefbOCh0xAKZT1hegJWvrbC37OUZwRn8NAqIKLPFLqdJiMoJG0AZKnz9ta4+VQhct0uoQrRuwEpXX3PbRA0p4UItxFO5UFSpcsI36O89g8eQozPFUmiAQn11WkYJCn7iW5TAZRLCAPzDs3QXjQSfMIiCuhyxCBHP0bOZND8hSAuAoFLX28TNW52R4pLCAEc4i/ns6qPAcCtnZDwJA/LZLnLsX5Zq00WxDc14ynJ4sPfKS/fKAvwNolnDy0sSJv3Qlc8oD2XhLpjLCh6rNols+DMte3hv6MbOeVc3f2K9l8PGfSxPIwAZTbrne09G0BTDydvW+ufFGn3KmBZkPV5cTTB2dH286rxzmVbyh5UhFCPyf14wyt35Eys4LA4O8c+YcX4jQDPBEXxPTXPP3MmVjNLo0KOnBt0BRjk39w1gzEe/C6tRPs4+EKAjAaL5NDgcDOX9hBPr6QoA55geYQsk9Id5UV7pQORr9hzj1t4jsYHk1MS/eriJYiEWKTfEU3RNa+xZBL3FAa9MVbx6YXgq+XO3nXzXspP44f5N4eqaHCYwdVLNwbJHFhTi+fChfH6tk1BfttCyQZ2dyAh3EPxaJddaPiTpL++gnrz2Z+H/dw0SFYdGL8iLxhvRYSJRSa7QvJvZGUcF3v+V4ul99YEcnB6g80DhBVCr+ikpIkHokRALvst9T/YUnh7B+juPfwUi8e1fyOxkIBiV7eqfP16CCcz6BdZRbT8WT4LGiskU+n+TcLVbhF2eIVZX9lDbNHL33wHyoF+UUpCAqFu3fl8YL3LFG0wm7vsqfBoQTSXKGKSIHjhzzNGmcPQci5Rxxp18cRacLLO74f+B9ml2hGIrWdm7WzQMxR4co2dQKCD7MB5sWeaeRqzw/mWcqlP2r8KkJdwF5GNXTtBoChRX49ZiKUM8O2Dk5QvW1dX//cmDyP7zyk40J2/CN5OI8T6ciZI5EjPKfpWu7qhHgjhsNjgY/cCQ9/NAZQGmAEcSfuJjsOTvuwPLnPZ9fsvWEUa3WjexCOYZRyHX3m94mEOJXtqxwXRAhRyPHBeJIzzxdy6PHqOO5KiZ/v/WklqnQhchts8U1tgbIhMtmJDSvT2UIs/0t/V0LJZY803oaz02oV2FTYpd61mxr+Kpc+7XWFsBlQRc2ah+jwGYMlKZadpviLFYvVss59J3qfZLz78H2dVUXTjFja6XUOheWqe5KvQJ58SXKdLHfcu+uBVc4J2KPsgwPl5HuufdpdxHu0cU7I7s5CrWz4kqammBnQQGbrKkehXTw7Qdhg72QlIR5v4y6WZjj4COF+CGJvbhbdNl2bR5nZIhRbRTDBEB6/dXAvNZZUENPlG+aC7TCrtc4PM17/xuUGwYYIMJHOM+PkL0xSE/lR4PGt1CMllyfuBLqf6by5q+Y0Cm0xX7oHAEEijOo3aESy5Q2BlsUxcczOwreHzcRwSvQgeTzDNsiZG9/K1zt/1ZITyO696gVbAfM/pp+zLtFO21kEeX6kl/KRvbOgq1JEyIx5N/xdu23Ueui5VBuL7WGJuu606hL0VRzPBH//D+L3EW0Oxu/b6Dqzjc4oT9q1fe3ZNeG1pD5ad4G1OBr1B7HDXrdViG9F3XwTmo1mE3sjCfEs8W3GJQk/a/QSR+KqRDZy9Ek9sptF+V6mPk95WglwEkx/NBGzwiWw0du65jT1oXjPnjKN+tgcRnEVmQ05A11l+tlf3/oWTPuC2I7HW4PBaj1oWBY17MPRZ+jknUC4jYuyLmIqokWCm7fKdr1q7IKbZmBcnJnM6h4n7t/IlgRL3VuBkGHxsqZbxR9h9jgd+UkyesUQs4sWWYemCDnxJjIOBLij0b4YJyUh9R1wQgicO5WWcVHqWcAExVsTfpLOh2AzQl1DVzWEhDHYEYf94T2FlrSs4UcmkPhm4m0nmaagJsu2voi5mscozBaLh/nS+26534MtQuzWpLPY380IeXs/hSowDvPoiZ/wNX25E8v2ECzinQRDUsd12amQ99mELOYi6ujgFOxK6gxeJe1q8GFm466XZpVsiB2PRdTURszG7o12h2LOTslkCDRYrS9PfmC38AeL9VWU3MVpWned+GSYpoxuynyKb9Tgcb0UhRO2m0po1za2R/kt3XsPG/vE6+7/wG//7X1oN6jmI09IMp8DcvADZwN1it6whNjrimxKEJ2W/pyc6DP833LUXJ8DspB1LvOZXpC4nqKp+L55jSbSy27W2EoIqpDlZydA5E+6Y+MAIAX82sf0WtCqNLm5lOuAXXWSyFXN3ygO3/XQJZkFoRpc/rYvUwRDZDP+BRTmOZWrVXRslaZSeBbJg+Wn2xh2Y+NWw8xnItfIqyOq7rdpIMdxOxzZtEtyn1jd4CeJ4ww0CNE+Xm0L8DvS23Oh9SyKM7LGwTskAlYjgluPkaEI9Edf/sI2WJZTz37HkAZoTRXEi5nBvikWRkMYGG4A5E05n4H2ERfBog8A/GcPG7cH3pDqAdGoyORhGACZzSpoZIe/MHCGSfEEaX2JPYi8qBzx9WpE4Fds4ZEswl5VjYg/04hByoPOjVkCqOPSxIBiyVhYeXPLyJa1Ez/Bq/CBWazO1mOydH/ifJS4/ZWA68TfpwEjkuRmiTSxvgWmGzjZqY4mO7aiOwyTGvlr56LpH8TtZI5FUK3+e3D67h/tV6H0qvIN1xKlI+q3BoCelfsndUQctYYNG8obvkxfEK9p+5IQSpvnYEFiiwkiXxD/IWKEXe7GxC5ci+LzhdEMPnqWHqlVEatvzXDnNwYKs3aezkF6BFEJ9b+lYceDJVHOL7XzNq3HCcN+sDzdIOydIYAunfa6AbOMQUiacplh0EZzFSBdkQeCt0RfJbCNcXcqU3OQ/KJDJkcvbt5YCxsQziTygsrkFJzgECZgDAW92R0AabLwaEE7tWjybOi65iwcBeT5xWQndg6cT+P60sxRVEFwXs78iiInzATcVl3YLWEaTLh49ANOwBtlWh2upEOwWprH/4T/1BGIxZrAOf1CDnViDMtIcFaPBKvO4mD1fB+Xitqdi7d4SlqHK9rrglpXxXb5iE3+98k9lPrJUBqdP1zKN1Bpcy/5LfW5PLk5H6N+z5Bjc1+3O2TDzAgfaq097VHLE4SugoCvmnbLcwXl/ijLaeNLFk8/wtNYaIAAuCnNAIg4edekHsUqiqdXEm2dym6Vm5jIhwYWh1mTJlEXleMmkt8mpXJENOMsO3vcaMskafTbmG9qo0izCTDZxglP0+SOr4KY7JMNGl1oTqx9htjkIyL9FbgiDU/X1RiGUvmVgE7EDI4deMJy4+THYFxrCg5ChPgxZ5+lUwQ59P1qnH9iU+F+lucH6T0tZ5N6igk1kDZOjoTCm4hjyE66OzVAek96cK0tcXRQxyyoivpGaldr0HT/g+WORCdQwa8ZeNRe64Fv6D7LxSmyZ1gcP54GmuwYVqlcO67kF90ftKUjOLYymRXWAk3tFJbRoa3sFjBv6EmS4rwZwuZqjYAcRnlqO72LRXuD3DDPU1jZLI5Rt/SzDG7Tvd1e9a8cbnmEWMuFTlaDjdEbESdllDJGbvQAZsPyZdgoePrefC++uRDyp8zLC3G/YwCHtUlBJNNwwrgwVb/5/sV8xssaj8AgXC6xtl5qoUwQ8MuqLfTY1qgSHq6EgluY8OQAwRFbf7JqRYsjFvmG6W2YBLHHZoFF4C3ES9Y5+ZiswItZBiwZMsXL211hT5rT+yykOPPHtG7nUNdBbI8JRObMpElc5M6ry0z6Yxv6Y4zAUyA8u3b2xTXrfkixamjQKRkc3jbGxclTLmphxwlkkZhCnq7f6W4Op6/t5Nb1UXs8eytQZ+1hlkj/eG5+I4tnFsqoO6kH+codRusmhYnkzyI1egG1Dg0uqVlkyeI/Tp0sS3mawDCOYQBDjUJNW/AmzB+XGlRQv/YawMOF+ZrJbebMdeRePARfnKJ9aD51Yudc/LsJTCicRTtGZTPfzrhTTimE+b63SXuJ8wHzHY265Ayn0KeAltJyb+s82GL4IO93lXyCfA9FsTf4DWKBjM49VWvUkEy6fZng+gXRyi4iSeH54QfW5OekNebANg5s9NXHs8l9I8EvRxYGIn0oBDOTkG2GJD47rLWzv66Mfo/cg5glyFWe2N1AT7EwcgIY0SAxO/jNqedikeSe5QjPt/yK6wQ0XEqNj5iRcBHS15Vchr1YRHm1KrLp6v4GtUFyCOUDiObUNgV0786/+lkjm7sHZZlwkKKv4mxdwn07kVGKrPYEkeYzzrN6qp1r0wtzUHtD99Hs+KMfIsnP7XbP5v+mr8TjTRQKTEmb+2bqss5wW0mOldNfm9alxWnE4odM4BJ0+NyJsN1tw6pYymki9HyjW5P1U365IvEyU3hwmmNXDKNLxiNrYAfCI6e0E0plxc/gBLb8nHTbM+awIWYBXTGJWX8xn6bis0q4usN79frGNrdjtL9RRi3mSi8hHglwa4W783zFEOyublN2NY8tNc1S3PqbEHoGvRh8pjzg5ZP6fUVCgaxQ4Jr/KN/g9FSaxMXBiuKqITR4Sd186TbpxyPAlCQSEuDeQ+TbVnnjUT0WhRiSVBLMo50UaPMjADTGD5BZxThhnFahyyi6+GzPt3XrrCHvoAzRc9Rtc35KFJI9mUIq8PGxpLhiIDj27pn0K6CGiBHaK76xmh8tshOZitfsItuWfYlEkkVVCIxHC5F2FcJxgRjJFGz8mCgDxViTbdixnJ77+/cyLk4vhLthBb/rzRmGkZa6z6lIEu0RgMAXRBSkCrfaHEef2KY4PGPJhD0IRSKrqqfuAC+KckK+nqR2Pq1lfvVHd3v/HxnZlUqLJ9a03kfqGNFO6PERLXIcUQHiv5+gj1mv0V1dRn1oiosLdk6VOKTnie9YcFf6dhscWEnNQGMICM4Un/w8/b+JUOcX3wMpt/dYP3Ld0XfA73DPCVWvjg4W90CclumgX8vobz6ubwSpZR+ehWWLeXLAiMz5I35YoA/Ug3CC9658OL1bGsSVQ7N57/mZOsK3etPkx5SAEf5eBFdZKG/dQkG+lU3i0KzJrZTG2ETX1OnrJKlA+nzfKO1lYHgN/x+sRmY0aHAA30xMuoL+LWag+6LZPA0CEuofX4MsYs0bvdd1B1Zjb7jQjMhz6bNSs1bJMvxEGw0U0GHlyfYTR7ndeXL+ZyFEMiA92HxGjz5wKPpuI7XaOjdFORRViQLBiEotM6Urq3XSck2sgvwYbVa8onUK1mVIIbGygl1tNgkhvm5WYn46rMkQjGeOswkvvo2M66snM3Li9ulSMXg+LmcjhJkP2Q2KvYSw9Bn7kF3U/w3nZ4fDwIImURHk/G5p00GUOCM3XEqjiJhQ+qkpZwcn2u/weH3V1aXINS6/WVRKNxsymuJyA6I7jnv3eeUeStH4CVWk+3XsgcYE45va5JnJcpsdfy7SNo9IQSXsJfsWgl2lrcm63feY2Svr5MpdpH01NIucLGbhFFzlvcMi9yE5XLf5irxR5kODr9nYz7yfeBGrdcx7OzrnRpLUixcyvlYT6u9tgGwL+48TVqnn0zwVmFwGmfScFPMF7DKgmTA35lQHLqvTpm7dXuHazWfutYHRRk2wZkuypx828gYGzI4wKQH4NI0oLbszrjaM3/3ZZOYy3+huf97L3qpVus+byNGNnCc8BmK1sKFgszDGxRVmyxS+pH5T6t9+zzhl+AeigKfFxiA1iMv+qG3hxl3RXOWmWNXSddJY/siLhGuUcBjzbBxEqPPCN+lSEFmyPagS7UWjHtfr156rIAW2pfasNZpXC9ogIOgshJc3McYmBL1Pn2C9BNnhHUazaITKXjmjOdL99CM9TjoAHO1/VEP6c8rACyFpKznjsTVQ++J7mdD1l/jqvo30VBDUOE5OMzxcefNNJhNrlsQYmQQs0ZgLl/OvB6rKWe9VK2tgoEtCZzWFcXkNxN+V0y325rRmfs918hAJJfg8B6qnG6v1nVeP2Wk77Q+lvtzJySqBZ9T0d+fPkrNxFo71MzBCx6AC9SjfNZYtVuCcujJ5a3evEjDDrcCEg92Ay2BtCR2qLzNRRPpDaljOEa5NmMYCbh3vRDl6CHRsbVzGxyIg9Z9d1ewg2gpXASIEea+QhQ2CmafRK1n2QsDgIBxAOCME1DQJkP1GKMdopkD29PsjLTNEKkEEuc0R/XIeEYsmVN3NWN8oR4pvwlbTegHIeWtmWBTn3stOTjUqrdL0iWu7s3sqmUcmqGPC+CibYTMTbzdXQb7SCSuH63pJkFT2o/0eUr08C/bkT5fD/uoF9qeCvMCesVF3Smem2gqjk9dh6RAfLoUIhwhm6t3dWaws06C2LC1JW9v9sCuX1C+0qBDT0UNVUuRTAJ7/4tbUu6+h3KUIpPpZ0+zWoUlHhRmp5ScLHNIv6QRk8qVKE/7GS7UO1RY2HA31RN17aYnSkl3/hMpxjkQ7x8PURCtTkf3kBJGmYOFUMrJUOCpYX/d8f0suipw0TrMAAw2IfWmvmGc++SPuVbHDr86tBWv2jd/vhQ2PA1ATkg5c0xqysiEFDlBzlz6soPdZERzBxTV1WixHYK4Ui8cAOhOjkTtCjttjJFAmaFy2ZTotCBAhimYTlGlLOmGP4kKzwOMOnFOqtcbUK09qIc5IiqYYOMMFe4q4k4k9mFTVnd0NomHhXn+I4kBa8o80k6qTL7vf258OnkomJ5HYyTOihxOBU9y9Cpf/I1xzTGnLACVE5LYQw0c6GxNwsEfmPKnJzfKdDSonhSqVYZmVXLyDz0xGpz7HYep39Seywqzb3Jnz8lWbgJmjunThFddP3ZiI1ZL8adrOBjvouiRO5mq/YHLt/WWeqU5AxEj4JxRmr7s7JSrEXyFNuoyYHBJ45TxaX8SqqOpn0e8YNXcFc0WdOiwAGnG4RAQHIq1qrZ89V95eTsJAhkDch4n2qA0m3otUtaPmJ7Tg+vN2hSemCqfBB9SzfeXV6zxxXabPWGeCmMxjD1Z5myLPb7xFUjvU4gO4crhPwxQFO0gOFGnmcRFLE9hiGBaw5Z6QfVbRuK8t81V51QVfkBn2k9w00jK1qHbLVuW4Slv3L1lKwOTUfB/QzFIgUx5SjYw0p2ycGWeB2ZN/jmzRol0pTECMCmmlLb2e0Ezyqv4ph1JWNwLzdrLz6O/xFNJ6ckT6DkRuMMEDxzA4dWoNIUvf+q2btKYcB5SJpSY6f8oq677Kex+kvBHyoSJX2ZnN2c7M9t82EIASbj3LaCN3wk9xAB27DpC1inPMQ7aybTqq9bpMTt2Lji6QBGXGXdJg3vYLa+FSB8Zde/flchvhyAYOMyvWrAhwVsxjK1OXpf7Q2jUEBZFaFjhwcFaasuKrO6YFEV2tSB7ej462haU6o1q0lnUe0nH3Wu0t+ra3+ynNbWs3/Jp48vrb+KXk2ulPP9T9nQ3Sns36yJRhQcWHh1N1EZkOPrNUqjPhERQuHkbUJ1GoJeSE+dPyh6C3UcYZ4OhWPUTJWh9hE2mBkh6Y1sNPYCg9epUqBk1VmmDzeWjPs67qOdY3L43frDv5CDsFU3TP7aePSdae/GlmxOAZCJYupsm9TwzeL0fp37JEXJrmHpswp9n1F3wRnQiW7RsO96tJu/294YE1AljjdsymhGZUVsGq5b96wKuh62yp/hDadeyiNQIwIs345fOHYl7tDyVYr/DtX4RbV68vZqGrFncn8kFse1lyd2YjEn4zSeelVz/sb724AkhCx1UGGH5g8qaqW2LzVmwGEXR0L06O5fc+YEOQ1x1mJRTlkfRosXNUIoYcn6avacALVo3tY3Je5SaFfGLFh1wrcZ7MLjgmsb35tIYKPRAy0MfnvS8rEQb1ObGGoJvgoab/Wg4qmnPzRegBeMnzlciBJIx9aI5/JC9yUt8EuB75FqwDFPAV2ZwZ5G4CsOxmGdLJm1ywycuvJgPhNcYGbevIdtUIrsn9kFtjxeuADBVNeaJwjJOQWl1Es0c0aosxF2LewQorzyG6zY1nthPjmUC5nRY3EtLF4mMb6W8i2dVqBsORWIiuW/tbv+35diGTAAHnu73BoO2ewsTAh5Aw8cN2aTAEzwEqjM2h5xADEUOnHoCiXpDWPB4ERPTt3/a0GDBld/DOxBuSM8KVgpH+5+B3KeJOeqhwvCbN0RYkikOfmonOtBUn2zpfocC2CY9MqDTnMBn+rL0oDwoQWfnTy4GuqLcToO2GL9nQcC7AXkdGK1HnSqGpwh3uI9KySpD0Wis7XxLxNbad295NGLhxzWgWsN7oswT57bgw3ojb/Kc5T96TEipXG5zWaZAUAZ2UYUScLoD+/Y/PnmmvHTS4fKBVUamZq7DfM2OdS2B55oLuw75qZHjandIsVXWSG4UMC+QRJZHaq8+4M9/QsXeh6HN4pSjOVoHwdl8QheHeygT8u30dkX6dtSASI/ooSNd9HyjzUUH/FO/ts2WDEhmWCqaVJ4d7Gq6c6e6SlIlEh2emr88bnajK9wdZRo8TF53f2evo4gJPzGKGlHeyegW0AoWpllRnpWSNjeEAusOUwwWzEbILWa0yq3C1GlajKofBnlp1zIU3GKimeKMnlRoCkV5dv+3RfRHEuN4gOnVyqUO1x5vHc45ylC1IaDhqfgG3VNByDnJl8uivvJit8SlA24+w5PcSvogR1+lLAuTkhQfiDivlQmHE5JBCDE3Qdt2UXB9PeWFJDmP6n3BN71Z7CGInA3nInw9xP+Baegu8aQcaRhyvOvcdTGe6azVL5bo31Nd/RMBdyZTbHV/A0gz4uj7Z0Rg9/WVzjuOEWS40xQEZ8RNV6JFm05RRzW5GzhLQ98a5Kk1AYOZ1zaLwbbu7jo1sxSfJi80x665cY7Mxq8dpXUm+mjESK1Oxx4/RTslXehbLCfidUHQvBZG+RKBPErlvMyyw8weBTF9QYr7KdKageIMm9kaszaOIxJumg/2/X3IQkvBEATvNGi6UtzEpM0noDbWi6Xblf0FbFLzuVlTrhyrnNsob5apItJ1lkbqSjF9aqD8L4S9gttPqLYKlfF43qul7GxdTbqObA08Zoj/VcgIN0aUdBOiH4Ra0ZbUuaJYXiI+449lkY2mJBO/puxl+HTsFCz0ZHIlIBzPhgY1KJ0CXfrN0SGwmHim6mzfTcmGokFfX7y7NFwuVOYqjVjWiNDh56qFsovxJoluNzWZnfNmFX50/l4ynP3QvKxkjfqKfB0xKoH0S3RHxxE2B8i98l7mNS38BaH/PrXd5gCrGHZerbSNZVe/HHtreYjWI64xRrkvVG4ey83bHwMxlTgFEtEwnRUtX/6iiXIsifPclDB+hX8M1v1k3eJlFi4leKrosNXYGefGSQvMmsIGfUKf3fWKJTi/ViZXPxfp07AK1EzhSmAxYbUPEob/wVA1j4lqgnNOCFXSJ6MtcIjrq/trljZvnmd69K/rOFcMg9/lJ6v7aOey6T8uoCFDCr1H9qkucpmDvUoCrs8efI5Dbr5ALfo9GgstdTwbiL7K1F4+TRNcZkyqLNVbXeFjXbBdS0Sa8pRC/WXatiILUAN6GZziwj7xFBTC5lV5vPPVp7vOoZWUVNLw5YkUBs4Wbnd1zmYkOGkMJC37jw3yLoURv1ftde1YbSWhFyaV3QTGojmVpJt8VVb+mAzx3yUB+dIvvJ3Jbaul8d2+zfvFObSjjg3q/JxLLdjIxLC04GLHy5a33pcuu76mtzRXrOKZu5KAifly8b6wILwB1JIIXjJf//qg9zCGKXBlzn6af9u/StZFZe4jpCy4WwMEH3fezzf/gyR4beP0cf+XqB+XOa1XzO5Fgzm8c/rSr/kvaNnRX/wxyr7DB6e3QToyMBmZHZ5gsoTl1nqGYNt5PF08Ui+VenYwuI9Biwgjbf9KdoVJFpIBN/rcyIFpvE/1Q2mvRrUi00J6p+0wMeQa8fnboehnFOWMd639cscNCr+k8/9yQVBzMeebp7BoOj01SXqPxk4JOUo5jNizDfr2JxJJ6F5etCtbuObwQKX+qQDSlX+w0jcIuFjAByY9b9sJeD5xcnu1ArWClwjwwdtJfzWqUWvUGDwXnv8GOtLdPkiRMjoLgzFydhUjgO6J6j5b5ah40jiILcnY8AxCy58ZCGi0P6PbpGB0Ia6+6n0aPJNOu6zKDtMe2iVn1frHYhj4RpE+xFSO1xklh4cGbm2XkplAeYLSyd5KAumQBRjwdfcKzAbI1G3D6cXrkqjmqX7cDTcxO6DrWa0YZa3y3xcyZ/AZc1+hWKsb+r2mdNw5ahJ2uXJZj1rFTpg9a0radmY3SfY4cFgYqkPC0avX6/6LSaxjeTPLI8J30DXvrYzyho2yFb6i9ylsu+j5zGyhcMCqwbAbfGTFq+eQZeDam3Nzeq7o6/dGRfu5dpJoUmQBCWSj/hwRYQ4mb+ui1/XpIj31whczjBUJS3A5dm0S4Fh9BpPnNRQgQvbA5/aeL9rujdWR94Nf/alXgCnM4HBYwVPgpLsLJDEV1ZgDhDtfK9PVDfNuFEnoegEn7U2lAr8V62rGjwqjn4TrDJccYS46nfT6M9OBiytrIksioEBX+clAwOPAdXTMExBpHZ9ZCqo1NzZqpWQMaVz/pOQVH506lULVc7eCEJQiRvkSSn3DuDWzCtXekdNosO2cSN82kWwDPfNDscQwxRDyJG8l5tL8cdlnRvE37XD44/Ie/VYHmJgWQjxxKyUGkhhOedE/hrPybn5tIxNcRmvntRBaNlL4oH/cGm+9dm3mLHQq2OGG4CzB2o0GBya4EZqbag01WbxADXDouj0F2GkKu/Ih+BX6JaQkH3UZHOmdHbR7lnNsMVMDfFophH97KQl7BQfiyGMeBEtdQsV79CVds+jL588ocbPtiGn5A/S1tQea3cmtJG8fNhkAGoI9fnA0okbgrolKL1AOKgUVQ/eK+ctQpYGSA4ndAiNR5K2UoXXPTGDrnJTQOVcfvq7x0VnLE6TAye0WiCFcki/kJE6sCg19glEqWxJChaovIrjJ9uLP3AcSgIqbXcX6gMYSQ0qkfdDfjILSb/yS2la8E9D7fgjBAr7CYlYUkZLj/qoHNxsNXNEh9oCs11jM9/s8hTvxlRDhQ40RdlY7mZoulGwmMst3AwUsrzWerCdsVKh3F44S6/IomeLuKgRjrc3VEGV18ujZ2sBFL7oYD/+t3mzgPdi3Oe2VvxXb8Vz0Sx69Q9FHkPXxb3zEImjAqwf7PTdWVO17uAvCxlEvIp4naWDfHoJqRqS41EIKdsbL41y/kps1H15F4bP2/6v3zgpV+MAspoGBosT4O1w0yMObzrkgUz4kMvnpQHjNlWQIEfC10INwm6CaXEcgB6qG/OepxyNsvG8+JwxMwsWwpVqSRco5dsVW3ckrpQy+w3FaIyNdkjT4mT6S158ZRbOMWNxxL6fzOoMd5EFByx5glqxocnSi/WkwfuruuDWC5MyRXU18wbYgiWi6Wj4/1txy40g9iPrMSnAWYWo5UKQSXeKpRlqUS6TnJcY3CIGyg7WoQbl5DOiiW7FMaa55hAbu7S1sSzsr2DUlTW/Vu9zxQiD3Gq3o8DhFasGOtr+aSKMWnin/Wq5liCz+mWVAeANTD4+CvBRJfgv9o7iUaKDUF5joQn5RXFhh+bIe8bppNEu9F86auK6s6Lxr5zAwyzzANVHhQmUqfhq0SlgkxmlIyt7hovxhCLGVNsqGJ+tHCmRafAz34ZxDy8/20fPczVWTBiv6tmR7STph8cPqVTBGL1FHfpkmEqPE/1ythPjVN3BoKWu+eIgibA+jiDVje1sD6dn2Odh44ohEMXk6FAFs5Bnx06exSBvNBYG1Yt1gYQIMl96A6ut6d1Y4WKa4rpxfdZeG8G2UuetbZPfkbBjBgldyjeOtDqTPn697vJjBczKt3Sqn22md/fcSIoOa0q7Y2j+WPLoDNd2f4iQ3tg6CXXqQInEg1Hfzii8yipxn2Y7KF+XF+SN7djWDYy4GhTm7NCya+AdqoWv4aw7dmIg9iAlx5lJ/hdoL66/SwY+kkZgEcmt2tw6xV7TFwrfzPwEHZq5S4O0rZmLh8VSpy1IT/ETtaXM+lC1eY7CL7fF7rW6kDxqczLpQeWKvPbbw7tP29pFm5JNNlp3Ijz0fneLbjge5cfEptGMxP3pH7zya8a0ermjyQ48ebIiGe6+TfZ1ns8OrgxpENfmbd3PTVQx/EZxGaEcYu6EBlRmOdYVhiPO+z0sNoX6JOyq4jSY9SoAVODwPKREd4QJPyHqhG1dDnS4uye3wF1VTiazlParojWxVSSOZbCiet0qqUnAVZqGwfBNT1oQF9WF78mZcR8Cy4jmc6KQRP1O5SBnR3JrF5n+HDM/eNBTDAOe5yr2qMkVm/MryqcTWaPo5AcljkjVXvXyXKEX9qNHbqUT51dhancT6VQVjaUkPB6zCHIf/Vjd7Lyd1x/9Z7pz4RYNhqJG0yLVOdsZbfPrwjrDGTg6waySRDA02XaAnEU07lwc3ZS0nXfd2un7Oy5AiPydoDvvPwMIm1RRImn5uUEqVPyfRaMEW6hcBGqaELrYxoyrbUVTzANP6ZJcikN7ydmrqV7pOrkrt9a9Y4jwJw8+XH700YWvBDUdOx1NQjs1k7N4xI1G+IOXGEE92uE7fk2ooqXBBK7jZMxW9yrC3OnJurGWUTb3Aj/hTXz3wbEbqex6iNjC4/x4wsLiewkxDNpmxKNdojRKRvv/Sf7AVweItQRnDzUzTzkLM1zMH66XPj0aoyTjUW2LnXZnvgZPakXPGluh9KfZveWFO8mnnPBQDvoji+Y5GuK0GdlDT9WHW6fV+UuWorGVtXY0QOFJPaX3WxkJWTdAoXkIOl5SPNE2rMCWLANoWsCZNawP73LeE7PmswubMemFAWLyYeP8udWnomkkZWybD/6U7ZHW8jJWtXHpWtYbCIu23ukciR56BC5putk8CSEtoYga09FQ0LcqTkFvmoSRQhs3FAX+ya64zUY0dEIHIv63QDdzKr9IKT69eFcgU8qP7hS8x/s4zf5HFt7lBuojw7FSZ8g3zE8L/KPN3c+C3A5r1WP6hvuNAy567yGSyw6MVMkop8EqRA6K/AGRNds6wT4yMAaejyqRNHIQe9yZvY6j8Ki0W1u0ClfZSkRfY8lTuRCJqxzdjGiXlsithehKPIXmMClhQcFb8GU5tcfbZaRLT75U2ZFg5ADsHg/dM4/JEObsygiaRH5/FEcPg/SWD1Vl3QN5SmOuH8PqIGgQspUD79y/SwTiH1WZN+O70od+SyW0OoNjSAvMQsuIlJof9cmYYXLzR/TSoGAev+/wDWDwZB9JDoy3DAljr4rtvzHbXIt1toKnzuaofM2zvj0O5PvumBvB5IcjfkaBSzWnyB7ImFqTmVVblb5vN753HOuN5azO3NmJqw3P54WtRp6Ymve0ByrDdHPF3CYBeEfHhUqBIhCH0yjHQtEhNS2RoNUFkHTTJCkUuS23Apcrz6SjnJJw+vInESPvLyx2hvahhI0e5lPXlJwT9TCY4c3TlxJ1SAamkrQ7H7iqhyWO/w0sVrn1u1uLQCS+FIYN602070yXgI/yc2Wf7cOa87lDbPXzFiMW1+bQ4PwBUFNfd23ApOJN4+bPMcjBQcoGhbBtq5Mav3pa7s88xy4OreYAu5ol/UjDAIQbQT9myb1/BibIDOOHFNmGvvBZuxH05ldXXHU8WBC6SBxw7nPOF3LwwZl/CengimfrDxVkiCYNA22kx6lKmNEPywxhs4K6JSRI3KL5/Cv5RwNgHsG7VALVlz1hm2nlyBmVAZIZUsO9xp8zs39N3FxnxHzpCr7g+HBujW8sFLZyYjKgeWU64s0l7VBQBta+k2vvxZj4lL0F+q20kArqYn2uuUUNvbkI6aKU8Np235EoQ4TJ+P4gKx3Fpt/49cER1hfaR2Taq12O6pM0jMX87KIO7ESEtF9Gf3BSsSbxnCtQkRWJmAefIuvyWvUqvzTM+JVkpXRDiTXcCz1oYDRyCmR79EXyLaQHU5+jzMe583eRzyJ+QKd4/LOvZVEbUKmt2DjvS8X8jZzmiRhftGn+rVG5zF2g7iV0syJeIw8DhPXf5jBSY1ApzVAPvG7lTUOYKoV4YBOcgbcydKHSJoyCC3R2ME2/wu1wZRUOzM6Li7uFKb1D+vdmH7MNS7bCm+5X6fmMRkKA6kbezQWQhGV5hYJYx2qnV3Tj69rnD0cUQFmxfw2pz6bKX/HwAaMZfRFRVzpfNHnpb9nY3sjOzNKWn0kQrB0vKJT3xG56n2t9jIQNk57LzmZvJs9b0L+1Xv8sVJiwlU/f2x2YZmEIVsKCzoHz3n8VQBhgpNN+LLXSN+jebkWXHen69n6RrY9lwpkPyHN9A3nP0D3U2Rvu8NKEa6kQRjMkJxR1WtEe0RUqeNNc1Yn/YMYiwy1bjFMdvbvimEVoeTBr2CRjhD3bzI2bodzovUe3ohi7v33SV4mgk8UfLm9PGl8RPQRg90y/Qx2TyoKcYCrNkNA5di/xK/A3MJwspmDrde5FDbXv9XDzHGJ0R/IOAifxZru8/NMBT5qaGOH9qypHkODtdLGkwof5P/UOjFU5Eue72IJTf9d05fUusu7ueZ3DvywLGu+FQWBgRbGEMdAodETFsZMkm1S/85c5E5xNU2qPA2S7LgkxvUk7PbWUwEtfK3ji786SlTkJGmVx7GXRJ7g6/f+8RvCprqCXJz52RnO9ZaHb+GaOdj5BI81kkRGKEIZ+D+nfJbORGnbPSFJPi0I9kruxW+vF/A0zsMEzhkPAxbHrp5Dym3VOKagAnUgwTsSdBqofthJUbu/8bam2m/it+S6NFiH7f5sxIAe175SlMSzkB55mki5TqGhPj/YFp2XL1IGXTsDhL6qsL/ghwggLMoyBSO3bw6sF902kQjH6tFSh5c07o+UaItSoDkOEfgHFo6+kW68fO1CRTjOYiSJtCTYTkqVBxYYqwZk/i6ys7nzuzxbu1oCozkIuwd0sU4qfLl+jjBlCAnx6f+WMMS6naGD1zPJzPyncvwAs3nODa1PhSvyHKvvAyQjJn1buQr70YC6EbROS0n0EV1+VkDhadwrNNwAPkHz5uqapH8W+Sth6zBVMUR2WuEX9xtjOtHOuF1m2HDAn5BQz2+sb1sqpGY8BpKF0Z+H0cJoCwASe0wUf8p7W84Ojuqe6hfsLnfFEMd4HjSneIiN/42fBfBLnM3TSy2KwbRX+GENjA5tB1P4TyzBMTqDVl8hAhO6V6m+7ru6fa68S0Ex5ZpfeZDTDSPMK+Yom9bde0yUo7+C6MsrW9t2iV71EqtFFe+o11kVjJzgwTKvuWeLxZ1cctWw5eavR54LRf4df5FAz3AWg/0zRGrd06oDArUwqDh5KLo+eImcw5rtLQRNDZX6AEAn+vVg/h29p7WXzQ5VMla3+6+hyxvc5uHy7afiKOG/oChbkcDMOgVlcQVfBRxlaKhOh57dpNh0lj46UpibaOm1wGlyPCtbpgO49eRqhgMoZgCp57Sb+rnNjBpJfFJAXWhFeYv1lY1xdA1FdiyyHcR27xMBHL+vwd/UW9pjxNG/b7nz0Neo4IJb/UCr5mBFaCa+iOUqvD1ou1RPMGHhfPcwHXREWTh+OqQIm6gF0Ix1ITo5G/yY2xAfo+TaCr0jYMwItk/7R1JgL1ekhjkXs4Vo86t9nc0K1dUtPJx+adfniMvzBqtT4gv9ZsMpYpOgnWWDQwB47sgxYl1lQG/bzs5+ahMyWqNFw5+GiCGpOkYx+eD07S0yVk8VbR3AT6QVqofI/pTR9uhsNaggwYAvHtShksraWOwNgjj4r3g6/SiI22nshmQuUKdbVMbZ38WyLi8eHuq/E01luETzqaiYKraRwd9cMKlcupf4D5BhP8gWWZGkSeelaVmUXDTM51NC+vdQf8SKK5oMAcxhMpHKmp8aDEoi0H7ZT62w66hWMWtuGxj5TFd/WCiGWNAyGM5yG30wvO19ejRA9LKzY4JpqvMreFHYCoTFYpaKwfB2VK0dY259nkkLYqaDUQan+ISgSwL/YdjUvPtMJssTXqgSFsEvX6JcCqhOaxVS2lus2hdRKJGxkmEzkkOZxF6mLYMoIwzRikmHLzy/g08MiL1r26SylZ4dsMi6SSG/v62hK+K33nx1ugdsVM3Iz73NKjdiuxSyqjU7QLGySUVIrUyNlb9hwD8wpMti+3OgUEKt9PRa7FijL5LKJXi2n8G33Mm78e/5hyW3vM/7323iErV8GfYKv/MVjGrOHt/puO8KXpgUy/36gP4QTA3SAVtbjuM8vfLsZ6Ob0DkwtccLsRVFxegDfQw30E5eKfchbGFPyoK5wji9FeI/HFvs5yTGXbINtRekKsFigjldbEDQHmDSeB69GTCKTJ8bFn6yI7mDu8yi1+8sVxaJe2MwUTe4np9RZKVJLNPsLdp+G+si7oZQcgh00UGFI71xPvJrswSbYuf2XeaTz+AC3DQABjuIl36X9Mjtg5xTK5ZikHQre8vGsHlWd5j/tgOXf2zC2W27aFz12epPZaE+ji7peJQY3xqUrCFk1XpCPHEbzuO+I4eAJWGzUVnr79iWRC/8VO88FyeM2wVLWGoBcp/vpDi4KOlx8xf4EdSbwX0dOkLDKOujIZvxbgHYf+/k0NeoInD4xki9WyQFDmxrhe0oQSxuj8roSBDy3zR7jRvc4i9KeLHAa3I8MHFjsdvznl1KM0tmiJ3mRY1aAclx7QbYSjiL5CKPAd8n3HobW6nrHmIH7Y7e8rpav2jn2iiX90xKkcvM6ITzeDa3TC2w1X/zyfs08N48+eTGDk3cl9xmCH9b6C7yor6d1F47kVa+ndEfE8Y5XLXjLXhs65ed6WlLSorwMDsDeGR5UPzwYIlFKiCnsrADY+9rj8Kd8xRnDTk9qogfvVSKvwMhIOvBn1aTeUHNwvnI0iFBdFaY4JP1HZE97KaBWfOmtdoHhKgKJBEp4eM5C0GOHulK//a3XEn5iK+qjij0OrBAa1q6g1JmJgf2x1LJC1vKU6DQiTvd8/q7rnWwGGIEgH/P1PkGAkvzHJjWufvqF0pvVMUuGlX7VRkAs8/kl8qRD13XTgNKCngNlxt0B3yWhN27Xi93efMlpKb4KC8C43tOGEBwDtz11TEomDbUP2UR6Xf7w1Psr0qrGBX1bk+Xi1bApTa1izywr4GIlF058qVpA0snfTbXVXvBzsnGTPI+gouMGW9X9KgPhRemQ8B3JlCPmH0dGL6WIQwLifWCwC3LAo4ggMYsEoeAyTuzOZNr1BKiPuAkmMO2KnxHBo/moQnaMDN2Sr7tn+gli/t3Rr+kvLWNu8Bu4cr95NqMoOU2DYXzGqCwPnEKVcdHot2URzHKuYLZlPKPPRGv73Ptl/M6MqysL0VRvZ+TVm+28HjJbQJfEJFWOZf5Im2HNsEhviGk5r9KGKcrH2riFryHQkjt7TnllRh8mmMyWGViHF+IqJJGj1w7rMqbZsJ9Ify7NlMNNN/J7VpeZiGwfnzR5cRGFsopu4qStUcDaOMhpQWO7hB92ksGhmfjMLcpvkrdFUZV+a+e1Mqaow5vvJQfFfNQnfyPr2c+ja+M1OWiZuAaaU4AmLL6yhmgIF63ujAEYn25ErrG+/hSBE1LzSpXlO7ayZ0jUUgaCght++/apKNEWPz+2iZ1okyOB+qrzG7C2CIfPb+wiJnliS26mDQbvv2hcdaLsuTphnUiDgkp8KKXVaSfKcWnlemUklRbyux1VeaVJJ/+khwUNwQnF1QSb5r0VXKqarKtVVXM+XXp+GtHn07XusabXnL24GMlRY+IOrqYmi7bi6lxh3HvFkvUSqhMcRoRXQ6XW8sNDQmqVNBEMvfEQNw5ajmbBCOo9eQgOJT1JJiOwa9MZDiq+IAI2q8MGRMzi7VLWb6K3Sa1boFXE6MGxtbMZMwGrtYOcwTkWH56yUxYyANsQlbdwF0Il1cnA4vJRDRf+A1kx+G+7Nm5NsHmHaa+/a96lr3Pj6WgKh4lG2Z/dsRV7AmZPQm84RJrhx+ZhYofQw6//yn5PhHQ5SbOPE7JiZ9lp8xjIhMG+h1xwwK7krBBN2/ZoaQECM4E7oV0NAcoBJmjYi/f6Ab8jrg6jCjJh6s3IgPoYfLMEOYNOOs3DYzZC9/IphtHcAJ5U4GjkLqjtc8mKIP04+ercfR2bYZFDXOsdHyra/i/tkvZcQNr8HJiHKmo5KAAZHTcR3bjp29WDrekzy6NvHI+ONLx8LTQVIiqXRFQfsFUXTv8u0eFnPnC2fslVrdHWh1gEXvjU888AbKdr5yyR4zj+1fuiof30GEoUU/7xWXnBTlrd2P+VdeWm38n3zLVUoiocOoh0lsgusYtdl0HMpa4kOtb/CglhIYbP49952TnxG8kIH3zYLHJtv+RyhLHkp9BK+tsdX6ZBqB3rLLZYL95xzmLXAbYBhf1s7E1vBYMHZF2Z82JwV/d6zEBscXfV2UsL6tuwCAsxsQGom66Qy7brmc3mlZ1DErzIYfuATvRBQrp35dgs/e00fGgd2s2L/d6vaT/ZvHSiCt5zQqExp32gT7VeQRy+dWv86e8dOYAiu7+k/NFv4Sq3g3og0GEvt/6ulT1dlFdIOaVXMxMLc8r6GyzxMUUPOLfi5oRMCQ6nYaPdSQHu+fl/Usf2WEtMQl8PZYbnlpXFzQCKayw5JEL5yj6P8LE4ZOstg2AoWmpVJEiPl3BxupvWKQaFjWKV41uuo6jYV733FfRcOnQRKxgOs5OptVjHJiToyUyT1jLhDxCcn2jKqcZFjo47OWgNH7Ut9x1STeBoPNHgsHuo9pX3iSCJBXcf1s35G/foaI2jBrUXULy9dDrfcMcBnHtlJe5JO44Au7y8nPRxMKbiOvDYuuZMbVJtLkdGwX54WEJngcHlSuvYMzXCQpsdkmok49/PzMUUrBesq3xfiaZIbJp33mz4NKdQ5En+f1H23oWB9REwLRKYG53VkzNEVlUbV9YqONifxldgUPf+H21CZ148gcgMdSTRtmQ4FztWhR0GBOyymFQ5XE58/mY5GCuwwjBKT3t6Mxzkd7N+Oh3PiflWk2PcNLZci5oELIOWZp7Osr/ajDX+L63lpfsLOfSKzgnEhn9MDWjR+VVqHGndVKNiIyFsgZIOvaMs5c+2vpwJT7oVIGa/DLuOMV3aqgllqFt+eMcX8RaPItZmHrK3A0EeBkXHpo3xXAomuAXbBbm5lXInEz+LbuIzhaXiHmjHDXDqMDdGXzKILGsx+qjA2LtJWltfGW2489YCSXWKlxd6I0IPu85ql+Q2nk9Jxjq7PZ78UA7x4jOjvm6idAkcb3nXJz6rg4506MT5Sbhi3TvSNKj14xvveJnBB4jdTUkJT9D+EbgFai7sMTY4dXG1ZHVwokthGVbqBQy8vZBwmzPAidzHLX+fHrLn0ptmZ68pH+9pIgNrHGa52KAYEtF7a+TaB8KXOjSN/j0aLO9I688qau+djSm2rKVIRhhceJ3ZfOYp/uvneC/oVgtC0tnZUVhnkvo1TCkbuN1OM5YhkqbOOPdyUHwJu8L+DG+Twc5Hj3VAjANf4md9s8VWhiXnoMBOZooYcZgX7JscL+JfG1SBHFJsi53zeGrgdADABgy8W7JQ4QSC89GCtApywKP2DUYUaeKW7+hzm419nZzdCuUpjP8/pz6h6rqt52mAKCuPPd91035/pM+n2uLP6K10nVybIN5h+5NnneASnLM7VsRZI3q8aWTHz5UaXUqEGPkwp+yw7kYVaPnqTYgnn9cwKR3XftUzxR5qiWc4r4f55FBr+TbtdNYIGSYV+o6+OQKr7/5X9V80eQAkp2phg+y6JW46RHeEJUr7LY9l64LbAV/97/F6FgLOPEByiQawa+vWJEmhGjKyGkQfQNEeJo07wefRAmENHX/nghqknTeGxEWjFUQbQx+L/VO8+uVAGvTQdhQzZLwc8s+aONJxZUpnE1Wz0AjlROKCeJSeqZ8qPMZ880+nxw8bQRt5zLibiit/XzPJ6bIdbG/Q/kpVsjzr249P+IcIh0EiVcVqxvREohD/o7kvKwjFHhgi53sqHVThuGCi12OpLUOIkjel6D1Rv09jbvZr6aQAhlV61Jz87eZy+jJbIE+tzR00xG7zOVekD1NRgvMd9a91bTrmLMiakeuS+6Fq/H6/lct7HHP788JyBEbDVueIvK2bqg/qOyk+TjOcZf8BtJzBH/2xRCJ+tR6pMNTzFY1OV3wjke4XN2RmWDTVEW3ONUUnFt6F3VFCKwuUmupvoHKDCoy2pS+p+rZ/DyzRyak69IydrYP7cV1sHuNRpOWUUv2zuKo7pSvzxMNmqmFqnfuyotZxrvQf5nE2XQ+LMd1BwInU2rBxYjGG2tvucPAPnmb+sT/P9pCntWvzcn57PURL6pY7l+o1HDSn2v+UOKz+ipA6iup7d21jBgEsMUFFDebpJwNSZcKAX4pkSOzBu7CZHfkXeZ1JSvF1objOPmFdYKT/R09xmUxsy/ecnpA+qU3DgtzrV5598NHvHTUMX++miS5KCn7Eie1RZH8OAFZK5YWcRcFlUTQv/rKLjbA7XSSQeqxbxIvtXZbZRvevddRebsq4xZOjcIxsI/tExAG8I9mR+QQmBViL61iuJwiD5sp0EX34+yIZQnVUea2aCAATRhpSGXtr9DZvcCJIs8GFvC5SYV7n81AmXxZ0y2AapEst94mP/8tfU3XIR/kvjbTvRWb2JBrFXbAz9L/fR4b9rOxicu4G1QWRVf5jaM1onnrS1vDRMASwIdjv/9MGxjqFIbNFg+zbTWG/gAxVQJ94T0a7U5y+2HIp5Sb29Oagd8hSMzLQoJxy4lr2Und2hJxBnX+HkToJVeeQMuOay2dbnr7K/0y0VNjQtkqFlaqWCD3yq51i0kPpQIqDdpLtLteex2dydC9GW7RdwhWN6/HqQ1D7dROooBrfnk43KR4s+xujNYWHWQvX8q4FI9v1/FcM2hqAZW4BCIhS4UFX8Ngx2e5qSyZ/1UHOtaKmd4j42OmzwoXFZ8mqvMLWdGv8GJnVQWk/Bm5IT/Ar/izwLw836yjl+fc0pjnvwrAIDNJf3xlv0Z7/Ecqk0shH0gpyyALCaeqLB4txLGTxokjygXjYlaTyF5zjZnvpFmsua5q2WBRwaTC/1rKEhw0ZRNSLNoyNXznQ5maGov2C6iKXRhN8jpTkqwksQc0dqWHq8VeF5dcyUqsGM8ZqoxzZ/5s8bdGV7mN8Jwq0sR0CuIkpZ6vp1QbG8VfbvyOBIV9JifkrDNoVQZ1VOqqvlF/fw8c1iQbPbB7ieuXTvg/Mrv+VLPXmRybVUnF6TGtLx+sWzwVx3FoWnK9/5FJ22PMNRgyzIRDOdLjgAp2d8H/c1giAAxLgE4Hez2HKzZfP52vcSqV01+4OBi/QMxi5miDWqSN9Jx9j6WWOZrfPnbBKCMwMIAJpUcvnciQoKmvXzJ+W/LW9IL/x5i4hWGtbVT7RNbIecQS1H+yCARbjANLnZ2gfD9VXH8IP4kdskn6sAI1tp/k1CCxeUMPAqLiJpTK74YX1dKjx8PTtfiE35tWN6KHmtbiDOKfo2JcpBerMc76NSJq/IqtNwPaqV0gdy7zudwjyaQcx5TOAIyMB73306L89rTFh59kQk5Y7KIuqc7DA+2CpErxH7aKnSg2HWgzcyeaTmb+JR91Ej5scUZF72d5NKn72JILC0vRbbPEJN42yQ11w1s8/2JcpUkSu4MeIeBbmPpb76sVlf514+On9D131KHAFGIZzepa/c4153XWfeMkWLY3FsEqbhXWtFyYMwc1CfWPvYHHeKV4ro51+b6OU9SNgHmcW02xn7EVnz6SAPSjnMBK78mIBJZOReVvyORQ9+7sZllhc+drfWE8fmFO6cSusH+2KPJM0MH8m06JgrcX/3HyViyU6JeOZRGKmlX1AStximRLI20JTiI/lpEDFKfRpOr63yVQ9/Xt5PLDlecL0/LqZqzGd6dySMqHWPuxDT0jIyf8w6jKWiJNdTjka8R/RUZqBrY5bY2zVe8ntHZXkfQf1+D94F34/MqjFIxSjFA5xM6tYMWR5rclw1RsBLIDEPWE2Znl6DJGx1ahXPQC7b+sqUoB6QAUTqPyFT0ybMt7LJH7tsYJOIUq/lEqNn90Kr7qRSkT2/OxphScd0c+VUYosTmjvJ+KNQjVEpvQFYP1yfXj4RlrEfbMBcs6Mkbr0AVNJoDV76B3vqnUMMXXYxsL5Mr33SNyyzEQQJE38SZv7FStOUrxVfThWInzR7uqurdJ7WUoJpNuRyOgnO9lEY9QZlveIGm752Lf196OOHdITIWEWuKU93yJvf7B68AlpI9DwUxjumxhs8xCi27IpzpU8jwDVH9IoTsiNGEI/nfH1FrE2RKzIpvzccoO/ixlK03/e7VxvuGEkH2U4mWrcleX6TS80lgTermUl4BvVpFvVbK65f5SQiXklm0NNDHRPzBx+Q5xtlfgQQ7qnPYD8iHjatnorsTvQXWM2v6U88aXCMyOQ83nXHk4ddXM/UXt3DOYYadPtRivDr3DHfUyBWnI2ZOis2d3GJOZhs/0B5vQQzeh3h8N+Dn9x24xPdrCnFtJE10DuTtWv1W9vn/b3ZuxQ8oBNc6WBf6VFZ6LsvlXDLQEUkYL7Jb3fYE9xAbhg64FtIXSf05c5aySqIRuFIwYqoHUuUsLQCijm4xoBP1llxR4iuHIoScisLlZ4ZZTC6/Qgj1BLdwao2O/4XcQdwUbc3fF7eu3eYCRwYY5/gSSmZhVW5b912O2oiOUaHPZe4QsOFgRfkFA3+/KPF89jALa9GdqWjIJRtre6B7qejlQtzEJANdkiceoDADt8SGfFy9HLBJsBfT3X+/b06pzXgIwP+maSZFlJp7ZUlTU8MkdqUBsIvZd6p3AWV9C0qcnXtVTxtaumHwflER4hUqGJ2PtMOkosLdYuoETrJjZJxUaClw3dLZjrjPTe2pCnaSWJlpeK0nbTi1axyh7ZF4Wt/ayXg8bTZeeCHqQrKfgaXt1kn00vYT9vox87Qx8qOBabdoY3A/vI9cC0e961wCiaHPSHT/f0QPwyPgs1MZ1viCu7aPddCDqOqTOuNXQjiE1IdUL4fW9ZqAkirbL+7V2BJf4mwA0WGZOj3p4zVMO6ncxAxSCrIyeUu9FSIg/0zx8okUMLZIsvkzRgd9wLuhGegNR1iadfcC4ul7rJbxZhEe+miTgr8q8N2xURvwU3tyV+KIZf0ie7YQgWTJJVQdeXTP5Hv0K0IhhjJ7E4LvF5qS6m5q/XPji1ThTu+u/fGMyjLMCjD4KbIghzVZk2TEfVuuKWGFJxsocvVqasWlm/Zt6aH2tYKmZ7QAIMsCsrmreGmHCh9vVQD9rMqTBmh2/zp6kKWvTfoXMjhBU4p6WNx0wsqr3iXLYN5BfdKTDslVFuOZwkP7EV8y9cvgrenMCOogziQMo0K6WhPhMrbS00DD/rnl0CjuZIHcDbiHHKIWdiMaTrspdAoxSiqZ8HKuGcWzyBe3dylBVpokKKNz4f/caNJzO9sdttZNf1lq8LsFU9hBA8khz6fLPJCRshSZMoem8RjVNy4/efAbODgtlwC6kqQTCzBpKSucBg90/83ge8VZmCgaTCkbosl51Dv15rprj+aWivqAlKDvny8uuUOK/3kHUatPHFDx08/PUdpaAE3S2cSaZ9CX8xeb86vfTIDZOuneFUFGAMK+O3zaRuPpfJt9z3GmZZvDejOXOJf9fwFUv11+0amBusIbVOeke6hc1LUT58epCWOBJf97qnZOuNJSDyrTM9A8hyWw1Ly0/VXtDQJcBlyOTupwMF1ozR5Kjllitg0LBkIgcL1Y6KA975Feh2veU2KcAnnjRnK13P2HDtB3Gbhl372XzQk9zIzSQfPxpJPKT9ClcbqxFEaW73jUHaVVnB/wkmNmowUwCKBEkBDqkA9S2Rpx6XblX82jeOhIcS6nT3OIA0U7ue7ICxS7CfSRL3HrtFwATs55vNbWwbBPCDg+lMwZRvDMICCsgYQjOa4zxhfAsNzMnK0x25Wr15KtGBRJbWZqM7OTwqirAtv9JnJujI7IW6TCqaSmXF0hR3dYtnYrpq7+pkjE6xqFomzVupWLGY3GLywaeTODFU+ePXul3Fq5uGYhdt5eoS/xvhvYAjT3S9OnNmLbJ7RMov8x5bDz19ZeNuqmC1eBbaO9LrqG8xgZGQu7IqQHE5ZEAAR8xAXS6BFIQfE78kmUCN6lEvZy99vYohao45os+WPbXe9YzmC1vY1uAO1IF4K46oihUBxy0aKX4oWG9Pz4h4DyhBLrdpzAkuZHARdskjqPU1hGUaPh3jMI5dX6QGdcLmZPzWYgotcaceYiiVqvZ+EJZgzHVJSuIpMsgVAGn3oMcS4fJWkIvxvCl1spna8Q+YZY8DZFdGMiXKJLoWKiFNPfxJ8Kj6KjwOyj6usCXR3hJfFIsuL4DqiEa5Ayq/kQkOITPrjMjJiAKF1g6TZOpZNLlQ9275MQo5O2vrtrAAOirp785ewk8ef2IjCX/3olh0dVwCuPEZL/hKPUs+m5KN8qBEWhFOZOK8xmsTWnWcNESeNwW7z4Gn3r1YqAXhISSLWukXg8ssqs4NhIho4ISh+oqOePgvzzoA0+WWEG5Tj8Dn0OiXpYgQuSPRiPg0gcZfGP6aJ8cRSwLn9eINosZgoVXlEERvOVOi/ii1A7cKlLDT0+sU4xhrQFnt402/2GfjJubBJSw4dNNvQwhRG36Bja5CmLet0SZDDfPOscc7RO6YHpaZ2/seIB59+JMDpSvxc826zKM4lWhzoG+x2h3rjYG0j0PAJTkQhAtw1TA/0ew1PW4wy4iKABKeMvJDQ72fbsAbMSIaBUx1vec/pswNLbjOCmt7UfWIUC03pGc0un4CXxpaB32UXiI21Ciq4YxEoIdl557D6bvd3KjAK1A0GFlg8mqgwlrgnveBPMyIANM7lj0JLNkn7MPD3uwkdOXC7Mhr5bIV61sow82sio5ga5qpmOgUXjd7dDx0f1AX9MkyM6UVrnBtkE7ueqfsblI8C4Aa900UKgZSeHk5CdSM2Gs2PWdTSxpCVVwwWtVKbg2Cxfr30+n2X1/MP5HSbw621kp7RPgYG73CHuZ6EHagHR8IIUn8bGxTiJdAWZjoethFIwr9oTC+7Qv3IcP/yJGHQrH5WY4GQgGbZYPvHAZYWm+UBpA8N0XMp27W+zYFGdZ2EtrhUYEZPZMvk1Ufo22ancWG72zTINwZpn+xpjC9Eey7YaJDxAGvSbHtjvneviVOOjGAZvDkzIu5Po2m62NkfhYD3Q0p/lxUPsduobpz7eC405uay102pQSVzU2JGI+B1fVj3UgqMOp1GBgsspYmguIwCau7cEHGAYFB/n1q39/KJS2DA+9i88Xw0RfBo37PfI/jF93lnKWyjz+sKX8ytbjvCizwKpyoqdnJncqNf6RF1E2H/LeDQUVCljTC8GGsaZu1yiAT7sTqqxqk/MYd2fKNr4WVEcc5cJqGHO/bmAxURqZeJsEEuQIxShGAPsWu4ZNhrIIioz9QBwg/P4SmzjavPuRHTD6KGuv4nWWqtFNKiv2C7MqprqJ86srvksYB3FS1DfA5T/Hyr4PPUZTiT+dQzZNY14cv4OqbelpyrhbgjuYKOUXqqxF/77YwKRqDDyai05HBIP9fIUpY/P1DX8Vazw3OOYvC485nPAugKuzIlLU5qCnYLS+FKhep0c1qaD335XofHC8Hhl+V3Rrb3wEdHt56nRsSwIBztBIasvVzxo0YMkbSSbkbwEmnm1o3Iy+kCznQXSjPf6Q8SyKd5ZXnEnY/YgLs9u6tD5WtQD7WhSRbtbRWQoCKjOqSESZC2zJmP1NgP40csRDu2m6mCZ17TPszEYldNupug+H15z2jKVRuLJ27tcj2/LRToymcIeUSnvxHsVnGuOoR07O34MExHESiSGj/qjPfT++YIkQk4bn/mkkFGWp1I445zn4Uv3XLMy6R76U1ZM6SJOh7x2CW3C1HxBwenyVQcqyETRa8qri0ndIgmlkCGEgj2HZGfuM3Aw2ffvLXZ+9tfGMrg28U2K81CZYlUJLR4he8z1DYGuQWdTh0Sb6iTGvhKkG7sQJsiB7PNlFk6K3ki1YK40nxxg7Fn+yoj4+7PsxJkWdE0y3QlgCqkA10y7hNVS1VMlzL1TaO+jWoo992l07yqY6H6Zl2fysqvQU9iobf+x0QzUbZNB/07XRX7iPKurYtmlW9xh4aogcbKkK/qPWTEc429A2dKcG9LiJTfPpVDOLZA632d58VyUKG/pNhK/A1fpxSRORPGnB2H7WCLRS0kMSKZd94jkL1AfXUi5hmYaSN6UMZJ9kXCYNmefSYWn3ISWDnbziL3hophQaTFSVd47qtdWwkQMIWCTShEeV/WDHhSAREGqJnpSHIcBamNlGT22Hha+1qVT1P3vht8avIy82mzCnL0xnokWN1wVS0GLRgWRgkkx0Q3e/92DJMwUiZVyRZqoLWNMNiy7t59dwAerKO7cTQxLrpViqVE4ElobhXUeXh+ZzaciApQHHrW6krsIvUGcW3iVLOlltWBarLpf+7U6+on8kvfbbxW+dA02pYy6GWAWO+mdRsfRrSAD4lWXLn/LTg3rgqh2r0Wg8Q1TY3ZdYl8faFG6OCkx7CESXYC/q6HkN6qrCIdtCYR92UJAS98Gwi2it50CPAA7oIBpyHhNUxNUSb7Lr2wsj5++mkbV48Z0vNl2kLOWOPtvvqZ9qpGRyP2kI18nqhS+3mgH853otJiD9xgQ/I6Th78W3GsQ17Zrft6YDeSzllx/+RkYWrLpZ3L+1Kl0EXCLphMEBg8FUJZCE3c8Q2yN8d8/vqqiJBcak+IkQv7+4y61VBov40jtdEGgci1gLIYHVnS+H/C+ms4/eaF8Oykw+SriHniAH2QYb2dqEm2v6x8sJGJ6wwbw8WKWOZPJXZBKtKHvoXdjVboFQPh9Yn0L496FdcOi/Ip4v7U/UM3jywpcxRfaxQjkPbIPQC6qoOlj7l9pzZgHpaRjmo8Lkpo/rWX4YT1MqYppsgBAbGCiKBMXMtBjyWtsfbNq5vPPkWzhqkwwb/c1H7OqnKubFVxgiwgrhWZ62r2i0dvWmSsC0zuZbf90NvjdET/By4GhfkCtrdI9Em79QZ2Nav/SldXn3FF08AqszuSbZc6UtUBiVK9Mf9rujUwdGoCXgmLDssn6t+Lh4Wse7Z5GolcFJfQ3wG0qmpqJ+hvCT2LlJMRasuuCN6k2s3ze5BToahFF2erDzzvEdclEwML/o4waHSuwTrEq7hGXZKTjwh6u6GNXSnCIhpAuG40BO4lD7r79EI5h+jX0WgAj1EfVEIe4bgbt+550PjzhpQscELwGA6wxMAVwwB+YA0KhxGlEzpCk+EggPA6yhKV/YC1XZbCjn2VjyC/5CnsIcU+lAU5wuUVQmViV1BZ58kUs7ckqnAlNjXg17Jp3/v/W90CsQU1ZDDBh3vtFHH+Na9NkI2eLOXVkCF2JQe+83JfULbv/WPIQUJ2ki3BZvA071sBwdRCMhZR+G4JUZggkZ9TLObDGeVjMNqVJzV4rVvjdpo5x22YkD7sshh5ygHurbp5u8ZR+ZAr57jZL17+fiJVezuQ8RteNqbMUI7m1I1/pVVrA9R/wZC+yHsU4bHEUCA60NC7yG3up5wyhsIg/tXHTbdnsZyw5W5sVgZmmPZFHv/8wl+856HEkH/1k3U2Y39bDNp+2mpuKYf7bt4nTvqaHZW6hpB9+GiiPgcAO2kvM3h3LzR5opKyhd05PnO88IKx8A7+KDARKolg20xzIwshty6VqSIfaflgxG+tR78BjqoYJhhJVcie+LrI4FfJNictdLJvybXYbWhOYoGAYOTX2AIVOKm3p+ok2JQOpZ3CzdfRH9KzMPgilfU/GxA8e4QVzZDrZ9BBJkRYzzQqDl+fg+4ctRMcbKDaNZagBlagHSEyODk303z8vRBoBVjdnmvOn0TMFxi4SeZDXUKTetmSQQS/Dv1jLoTcy7hObFLExbNjwvEkVkX3RVRN/L2zuavUB1ErE4oMWG3okxhH+htOT313FlwJ3nL+iV8Hp/ftjVZU8Ph8XUGLbd9PgCikEsYefxj0MHki/BbsO2WL1bVsKPIRo1e36TJb1r1Luhg7yJBKXmYv87Lg2b2s0rT5PvpmUy7D34rdiIZsLn/SvPDxa7+dB87yfCKp3EUVLHG/js+auYJ6lTH2KEX2nAYpU0u/fl22j9bvKTMmXNSFIlA4pPoJgipEw55lbuX9MtAyN969n5YYGMqmkiKcA6mRlTTQJd4rpyPBE2j7Mrw6Pg1TBPZ02auqoO/f/3Et/d9LOGKD+/k1+eLbY42hDuyV1/bhC/kn+z4TpMYVSgyF0jttg64vB4nO42jnwQhtNT5KZ87p3ZzlndWPVc7LcYdPAWPFpxMFOhg3Yec0e/FJU4Y+iPdC6PFGAtYmDKNKKBXRBqitj0yzSoQ23wzPyRgUoitoEUzZuqN4+oXTn+feFeRKIPVWksu6Epl5qV9MReA6W0DGsxC9iYD2+TDSM25jIpZ7/pn7jVog1/qiJMZKOn8GI/Rbtt9ZYtU5+ouLITnAw4CDzzX6vO3fph6WI4jQUi54srnc1ZhtjzOet0kFM3/IiwGqg7jkJ81ZfTY/zXla40DQawDoT1LkMXV8TIjgtaGY/Qg3dHx1AsaOz0ji+jZrg1khQe1x2xvkX7jfGiLFUBe6L5iDDNa1WIAvbdYed7rygn8BrZWxYSNa3D/1fKOJc0ZfvWG0mnKtb4JoFMiS4/VLHf4Hs1psjns78fzdQFhz3WSul9YcQdaV70w+l1+n8LT07K1ySA7qw2aIkRvElH66o8Gsm4vqfyOWePDohWTYvKlulGiWOlIUxvhr9OD6Q315PLEly5rFx2+skHlfYJ5XIvVoqwjx9fMyjfVsdxYSdOJ8v7ZU7aQ/YudbD+8S2q5c6Q/35U6dHltrYfqawHHFixh3hGDgoTxAz8rOGU/WkhxInrXvbWsgrrGm/rYUpHkLF3Ie3AT3dLiqnEU9E2PdOHWslyMdQA17z13aNtxwyi3CzmcPM2ZRbuuyOvbBAUak8iu5MqF7bjR+auPjXT/5uZFofTJV1GIJr02P2MiRLJWZUz5J8ll1sqKxg7+XzLeNddWwa7SB39tBtAaDqwrmDczzS0w2V5X5AeOqDV0xgOuM6mo17TOT4snq0OYMr9Hiw8h1PDd/L7ygSBBmPsoIRBSkzUJDZNvT3VZA6uebRcjbnDWCwf/u39QFLn7P1PMbfOT7VM3sVv0SIS+ZKXuaolLTSbaYQx/QafRfars33zMGINf5sETQ5RJgsZ+2yjUieDtoPA2tpjKfmmSaX+VKzwz16PZ/ZISGWvMxU3KEmvMlMOuM0PcACfmS11SzTTWvrb1hGa9aJU9wOqiU0U95ETN1bqMqlr7gKVoPf3Al4BcRf9N63kaTCsLhEbnZ+x0bKtYYpxoOX3VW1MuOfZCjddOo5PfhnmWunTBZAAc+owgv+WkvxRmlnJ/zvxM8sfqFzfeBORvPX2CgtiUnozxWpwsGpVcqgxAgGZpLnyQuXltUjSIMUOqeBfqG1fZwi+4YjZvHNuXN1rRqAxq6fVZhMg47N8YaYFq4KIOYIAYmlJw/wDlUTkmQQH+DmOfp9IfPC/jX4DhDF9o/VL+8bQXu/QTCIa8eFS5cq7GytaaxEu0x+umf3LrEhXUIz6qdDJK4+zXg66usfE8cfcca5Un1YPEsnOZre6p1jJ4IZ0ubHgj2YacPn28N2vrjxwJTNdI7POH60Si0bc81+qE53UpQcJ7IR/mTqqK8RS2v2bjvN5LtAI7ZiP9L/1u9lm8EqRPCXiU3GWx4OsrJ+aIoghoDl57T9rIDg7MooDi0T7BtAgRs42a3Wy1dfW4qyVQhv6aAY/kSnyF9ifu1E0UKLbEuVkXjmOHAY7tk5ndwX9o/wwimUJLGri36SVLRzFoQARFuNMEHmZMwMl+ZcxH2EOFZ1329GMHlceKfvzukAKo8+/dk9s7O+nk8I9xjLwrpy6U1tbWk5BbQuPL8Sq7P2lATr6VyrsL83jl9qc1oYgKCas1IDSy3bXOKIi/XmBdFBqiegTtLCMoiPFKTXelRcJBYHhNWr7Ou0rI5i69w4M10AkNNxkK/qCzxwYb0sT/RrRODVj+YMZaCrKdH2x0yNAz9HTXXNN12x93NFxyLsT1i1L2c4T4aXfJtKjA6JoGasFpJ9HZznoH+Sba5k5M+Y0sAYoo2NhF0Iw8OcyPKvM/h08wcQ5IXBVXOnMJcUV3By8n/4YDfYD7GRtZMSiah7G9cdvRfnSgDpPkR1Jf8Vv+HjPwlCe7cyPFlecMZijSKCNo6fKYODa/MwIw2ZPk9cXt38quFUihu+vHl1URdah2LII4nJbCEKplWKAecWv7rbSDMhK3kUUrNjQjwktloAbwdscIQvLxzBnNLQW4p3AG14xgz3bG7e+jDVmij4qsElMUEDz0loILvWS2+mI6NoPFBngITEM6U6AwxIIfTTL2+00ciS+X88uXE6udb8oRLdiKeRg2JmL8XQ4L7/8CudvyedzAbtM2EKhDv/fnX0dbJPP1gm1lKwR/hhaH4pdo+KrWybc3NCuROdQVAuDxYs0j1wkZrYiTYnGWrGRD0y4ZjmY2yNp02orF3CflpR4ZWMswoL36emg9ac81nqQMnqKJbxeO++sqnSyZr5C9PXsXsiU3f6VuVR5eSYgajseKDF//bBiKzx2vDM/O9sqnxn2Ujm+wiK9WblYHgbIv+A8mzOVr2AIIOjRqjGjJqlczgPSpl3BILlnuuS7xlYJ46D7JGfsv9yutf/BlVMVfSWkdINOvfbEAwDp5xNJIRuOMigFmvwOXRRyPovInoJSVCkH5+1bV0wt4Jm5DofkU0UtwVOdthiFrvhpWT5vB/agxVzEmJPpyKLlLlrUXKCejginE1u+QIWE3FDSghhJJCocBkaGuF8dPgr7k3uME0gjEvLDyHl5XIaYiStqXucxK77dsKJ3cAKR2mdGmfKKS5zSSGvwB9oS/CoKxGBUrVDrkFPpa4C1c8/KfWwM8gZPLAtCkqe2/nMb8tF/lnydnxygEPx41KwMsaVbLkWgLVqxyzBxm9LpGuN+YDlrCJyCA30mRCetB0MK1/Nfe1Xg1Bde7moa2VnUjsAEtSCJBGADT8PcIZwT/9452xEP10WjmfOI7DHzbqXfA7njYXInIZvNJLu9qRtERWdimOMhUZIC7Lmalyea3MIB8MMTBkfc0gBWN9HxmsLUo3xKe7paiZuFp/fvg21vqFO4SA8DjdYqYJT4COYMzvs4InnkqibCGLV91svJOOLDa96dRpMG0zJ9uCh8UOYrCENhOksWXXRmmYerMkDsBSmYaHHFWXbiBLJv5vwXcMqgiA2BVDsGN5nMI1feOw+mOLEnfdv+kMtAE8w4oW99z7uLH0R5qTipoYBEGK7tMi2msQP9dbeYhAAD/NYgoP3LLQ+E2oC2ojsmZXijVvpmCyRYaHWXxVcUMMXfcxLZeKvMI/dtVdsB4JLe8CeBAgoUxXA60ZlcLE+mwsjIf73lGrHjZIIPHxwutaWANYzxjKzWg2hEoRI+iL/8/Rd3VNoLitCfkG4OVmFidSCEicETXKGBESvmZBp2kbm1FnKxeaO0hEwUMgZAd1f74Veu9R8FhWKfkjUbqby0o+p/8TYta8gX51jc1HbtQatyprVx5JeOSsfeHWWJvOHT4Th6glvHezIwATzgADwZfX2II2S3NSeAehRbPjZm5rm6Gojo82TbmQAejyt5hcZ/5Fo4wsWK0YK+1SudM455lnw3McZBtYtpqEPiPH1wkJTe0S6Zy784QwRXc5gZ1wT6I7UN4L+H+67PDsGhc+KCxUBE5JywgigLDEymiH1z9H8CxXR/iHGBdxa6Wvn8mPIdgTuezORfSoq99fjTrRzLX+J/pMH+QGf4ipuz1Lcq69999SQQD+OwemS7y2Uxu8wzwBdtcdk18YS9NAFGPhEMkNkd6fX6CJY1Zl8hvQxeXmC9Zt26R7qqdsBjgRAjCR+w5XksA0GQoT1PSqHiRtFEh7kJp1CpwejoBLcAGY9vsb4YtM4hFLxhPYlsqwDI8G1njlWPrOlo8L1EW2bCtLR4yThdKebldE09c4sZoMQJbR/IKJCCOv/IPVs+hnin1A1ZFmI325glMte+l7CHkZiyK6bHmmsaHET9OAF95RZCQ3tf6lHUS6Id/xk0//LA79eHInUOc+pzKYdeLCTYvY27ODM4MMVicbNTz9XGPwjqBASOAUKG0AyJXJc/ulkLcsBMaHVLTx5XYvC5lYTremL9gsDyUBbY/TADKhWO/gUT3RGT7FJ37Zi/QWImZxTLXoZAfLMhbnNWFz5JWcJoGn3kCrOhmWkRD8GZccbkyIy0cbwM3gLnMLIbwtvaCPvIQt+cBFsXeXfR4YP3cxE3yzRgmqFPWicIBqzuZ3nfe1dXSVxS90BW2gB5uEN4WE2vMOxUNE2viU5kj/3nNZce11BW9FL/Vb9+YmvruP0rQKClsa6IpI2eC7IOT87YhAaBIAsk1Cs2zvxnUfK09b9bJNmsdWy5IB1h3COAUHKxoxqT6jlKo/pjQrqVJpRC9FJSWB0Q5s1YdEWuXxY4fEQu3thwKkfgwqHkqxho2U7vsTtvJjmfr9JSX4l0zN1joVz0NlaZXE1vpxjNUahO1C+oBROmSOlCvEZFMjFE+tGQDLvr8d1jSpGiLL1+80Js46ZYaeQkwyUzWfFQFR1c+Xh0SYv1X7O/LPFwPSHG+hPddW2TYFZoIE7N1TVKG5trVgyCzsK+nmdx8WpXpr5O9OpcrHmkDK9ggGpFJ7T8X/ITPXCsfxivAM7reIFeEi83yGR7Nabc0g9jjgtTwL/zwakH1IrOe/kFy0QBqswy1LWjaeadoENUx5RSvITz5CtAX7X6DBVHT6usB+yl7UqPYBuFsJPEg4rtQqCa+qsj8TvLnt8TIvaarMEf0U4LShyL1h3t7qpSCXjPZgyWGHIncO5dZDoewYqeHWGkIRZHMxgH66nLhvKNpBZFc+iWhJ2WJVnNN8NCpbFOL9RIqzr9hR5LgwMjJBxB6bcjmQ5aT43qkWaL3hhV5MvWUwEu3ZDPMSDI4SW0tjyYb766p0manR2qHZhCLqPDWZ62CI8VHIJkUe99AL3rgCNTrdOk8cB07HCkLatXYcUCoxAF3XCsn+r/Q4QbMcuSxIzyq/CVbYJsUQVjCnlfjE9+5+kDJ1MkfmSEtYI91As4zQVyXH6fy5qfQgRsxr/+E+vmZKwWgLPxVlRzsOGKq24mJFqIuriDmE/j6c25mGF0seRWeYZ0ktUe6RuZL6EVt4gukfSUwEndK8gQ1+U892e54EX2zEEQ5pQADpJFpDJf3QJBzy0SkS7qKLCT8Gwac+82XSod7Q+BfIvHz69nZiWKlTREny3Vd4papmJeibIKuer8TbqM3gKCfxsus5zIIOJFF5JMK4eaU01VRSOMM9sT1NNXXY1UEWJniDd8zNmuV1m07CzYGCab7kri+MaSYmPSFOIvt3SOIspVvN5N6p+f3hpES9DHtHxQwslRlkBLRNLqPAOk+NElKZwWK2IKwhgvcnVs93/C7Ee94duhuLoGPfxge1g/9bFtebezjVJ9QKAdNKsx8Urb9k9I3xmpHWdzjxVBN5rk95gt34zDErBsUEqqXrvKjbG4ibMet5fjISUQVG/8Zxk0quvegHhqUezTBlWoS5/znVwqiV7tk9bw/LILqPyzXaw8HicQO8x1JrMnwNmQy2YYNs/KL7CBriawNUBmDhPhgnxScLyrLhyKPh9QqM9qmIOizWULhpgonYULKDPwt3D0YRybN73geJnf3YI4AZHrSFadSGn1G2HBOyEgwxh+IB73Dl/8/m/HvllYffH7h8dS0b7WPns4/OdkiNC73LoPIv/NzaAtTRSIfDeoNRVTlUBnyG/TN3NqSLZp0ZE6kwGbRIWa+RxFUTUnL2ZG0QJSbztsBOR2iN8ltHajPNsWImD3dVPks9eZEtPKWr01JZJ0kwo2TO2fRRCG35j1VDNeATpVuldbqxqBk8ENSLItW5HXjzvmWx2HtxZT/LnKYNVFgsdg0JdlIfnIhACTq6FY8RjzGy+p7QCdE+fE40spMcYv+fuRXPHdJgB3dQl3klV6vCZ6dB3zkknc9L6CUYenPejpIjOxBKrnNee0PXv+HvSstGHlGuyuRMXIR3OE5nxvfbDJyaNuo7XCl3BIJLNilk2819BJ2SCyinOWMoe651zKkKASHRLd1z+UnRqKlQQpVFSC+wEypf59nRSTUnoq4LIh24poveqkyjHufGPlB5o3JsnXHKKDRDzymaO1kbkNPHOamP66bk/ABRLOhIfoALS42NXXx0HQt6/rhDhlSkx9sXn2aj2tWNxV4UpwBD2ww4w17SUpoJymMxToE5bUaB0J+hHGsVj4/X2gh9eT7Y7M22INzuKcZNVeSBd8ohj3l1rdA9ZqXYcZI3Xaed477FB+URPpTZjCUnyHYZ66wRF+5lA+UD7p6cQ2sfyH154MMOz6u8rcMMkV6vnmBK4MEQ450wqDJR+qoHdjXD7tDuGYPOFht7ixrBtI7B+xnoEBZtRuqg1Fai8NSZ5wlEu6o9eknq4rzJqqE6HkB8wr5Y00Uv4mHLa2Yo1lovaEkDIFkhf3UHPYlysvGtJSilikIfUmpvN+0B5X7bi+lW+mDleJb2HRN8Wel+f8hOt5YQTRjBsHFD0IhehNdtTvt4OULT2+6kv6PFda6ngatBkxWb4Fwmr2WFQqyzMcCkzDwNB8cztrjdLnlOXtUewJVtxLfWTWp0ftxta5njz41/788J+LbIJvnu6psEhzQ/VB4dj8h6nJjQq9dtFIe4VmMyeAlr/XO45JjwJ3Fsfgo6XX6DRsbZ+1TSTsc4/l2o3XKpDe66+gMaZKQDIx1VliVTouyt7NXqeXFSNSFke91vmQ60ZngZ31aP7LnthKokPcmqvYf07zWjN3ZO6WKoqment1L+R2/vpNsP7NXox3Z+VKxqWSXRDW7Vub+MZm4Fk7cnBAbl2ZGbV0lpKIVcBL7js9A+HD0H1Pf6VXejVYo0VcunyAI1ZnVnmk4tPW2o5Z3CJotDYkEzsIESoM/2WLGPWwBNLi6e2Gz2mTyBggbH823h586Jv2brGbqwAk82Bw1aalXxxIiEUVV2kzGiJzTpef32mGmYbgGANAhD/kR/XQlTId+uow4yHEXYIQ18CVx+uuh5TzXbVmGo+0tSLCg2mFkU+DjuZbuz7fC3VEIpXbBtgxn01Lw39azl4o9xw5p/9vs6Z47hCi7OgX3eGqP7Zi2zb779uWZeDC9NJun5EnmCa1CY/2kg0Ub9rm+/b+sF7dpgJCibKKYDXjgxdOQW7bDs/+YLo/sdp2DuDQSfug9Ym70/ec4EWcGT7yS1SymWJC8W2xeroe2hYBdry8qOS0u66Fujsl6ZQpRXtnmHMZdI75esfGwUYtnJyIfb0mL72EGcp3hMwEgC139TI9dDorCBTvyw67NCsa/E42cNONXJuhDmDzLNTMUCkz498iw+QiOqAW3GXEbH6Hs3/HkeF8GxuKRHb48GTfY7k1oAW3hjLEExE+sNE+aChL+wO6/l2DlL6q3IOx8fpq8OQ8/5SuAbGrhjEqVMSryEoKC2jtOfu9ztnEcrPf4xT0OcB0UBS71fRtrgngUu7FYSWRzT1rKg5tkPf9SJIvjfB1fy/9gOmTGFrqY9WL0a5pGUhqV1D6oP/XxNnhyprrjcRFKvlrNXEMUWQTqe+4YI5LdYhrqd6aV10Sd6ipSL+WUbamgRExt9m9skzkgajEk5+KYSf1zWy7PTh90zRGHfWiPybnacHAn4n5R0zuhHNUGHXweVnbufrMSehxe9zcAByhUeSqOaLstKKVaEkkhlM6K+4q2u3iNH83aas+xLACsGrgCIal949UqwNuz5BO+hdVXKUbUkdNXKgPS4gazD705+JXhwaeWaEzidsRTkreJ1SBbNYgmh3fxSuiyxyW7jxm199JIrEuMl1FQ0e6s1zPLk4hltHTT478t7TSswtZgj9ZFXrhjUY4D1TW6M0Lc8pOVmnogJM9eZr0/h6FYqxIYAWeMWCU/Jq7da6BsGXOoZcxBONzd7uYINiZnqXVtpSVxmVvGm0YEoW16cZusaFCP/4DNqC6bPE8aMvlWP7daM9zb5Er3Q3WJHtNc3TjW/cosmH+9aUnvHTgwnoLqr7mSB2Za24IGuW0ZwN+x1mGwJYQI52Ou1lTl8ed0iTOv6XieqeoWDjiyF9BpWydMQEo8U+He5bo68F4iOo2x/ym4qMmIrbbvIZmJeiVpd6WdFDCa4fbK7p7Hh+h5wu1lm0XKv4MKNI7lj0XX2bEEX9D5hc26AByBT1OCaL7T0x0QLwxzJJ9Plp/UApNdTPL3vQ0t4yXo7FkecL5H1EelTouXgl0njQ9xhtlNtXk6jBycxjPTgkFKSG56Zy2vyABQODQLS5q+/I+WK7GzYIMafUZfrZsYuRES8FjlkScSo/P4EE8G2rvC7SEo0lH1WR1CxPXjWnAGPRauDzzKwRO/jzuVlw3cisMqGWkLarLijm+x6Br68GqKRyKfIP4T8eRCa+fcXZ2EllGjEPj5817OM4v2awstBE1TrQiJFlaeg7Jl7RVVSSD8D4ehU3jj/EkzPuUrocBCTW4a3OlESxIuKB6v5dVbmRW/dyFh2PPoMvUYCF24r5JJHm1MuTQvcKgtW8lj0n1XD4DfKH+COgmeC9Fu1evLLUlmupjiJvMABxl4cGJT+SICC2vDWfxL9SZ8C/lALGhASNrXokImOH15hiNnjL0n1G+VNLttNu+0L9lCIG2kIjfZh/yDFMKdo4i4Wm+pQ33/qZM8yN1lpHjVSW5qMqah2i4uJ/o9LQ63078D9ULLZXLtOKA9ZT8WkFm7J8E1avEWCG23H3hRl8yJ5Vp+0B203I3oP1c4N+5Yt4TQ7OQMAklFUCKbOxT43+99rtoytQbPFMwZ+Fua7UEsroRa5iV5gy6a4P0AAbzFc1vdwP0WA1wsApatn7OJZo/wjHuFEASmNuZY6oRE628YWJVyhpM/Fvz8YDW6KdFANtAyd0K6oLOg6f8YHw1iDxKInMWV6sI0vMInh+YDGTvcn734E/LZL1ZoCSfpnsz5QOcGfg3EwLUr42ClV3eHS37Jx6ALio+mIlp7yNgm4m6dwZM/aJhM3CwOGVir8ugBNOIVbCH+R54Qx84YDDzJiI/cPi4LP/rgJCwQUvOA6s2C2b7uKr5iDQq5G2kZV9YVO3JpAtlIu8crw0bV6N3JLz8ySNM/ix2V9kU+n3wb7Q5yx8Q1dLiZPGhaKW3miixjYvrx8Am8WV3e9CniFC2vnFQme98Ye7TYbBrgxPXC3VkxTjcC44/IVzjTwzWJNRoCIeoO3d5Tfx2jTYyCydaq4X4WeenlObotOtpHTEipIX6EbuNHYvgFYo6ebhpsqHBMAOvLN0IwqDujmtVAAFT2ksQqJCjZIQD6Wkk7gQd4/iuuPlNg+oBjOAcWsGrBeBpiFdMG56IWtW4My7IEQtUE1/qsD8SOHfgwlaOVJV6k/QS2N3jv4LcQi2L44CUpp6he80m59QY3z0OxLly3C76oL0QDSEettR2K8z01igthx2UDL8XJ4QsPZGKDTSfAMYK4ITlhkabM6RwC1R2jSpsZOfSpqKZvcgZZQekyce2KPFQX5f4Qvjt1wHVlaUeLgzs+au35jpIJzy3J8gh+zZBAGHyBwaKBQCdT5ZEW9vo9L2oHsk7BxK/DYf0NvjE3Dz+b2uLk/IYxT1iw46UaaJiD39O3o6FJhOqWHrmF5jiobYiazVMSsz1HfBDTgddRatuDTrxOgmYkZC5dzAhd8Xaf99Gp0Bzm7knt8U8jq+r8HjVqkwcTWimgXUp/vd/6+JrsSvFCa1f133eFi1NgrbJY8sqUDOFCa1Fg+mLvzJ3jKxx2kbDB/fExZ4MUVwDjDGB+GZjDEz+lTDP1/JxJ6Sf0dG/eWFbBtGMeDwN28WiV8nV/RnqQl2c0XTb/VUw7fGcwg/XbkAmtdB5bGe8wka7QfQFvkWO3MjrT7loMxf2wf1GN50b6uFPNiV/rs/H25+DrRFm9HMIonGu10oWppUH4S+1G0tu+1ybXAzFQ8mZp3kIsqGM9IYSzs4AzFSNu1ZsFMNz8dcrZTAqFFvA0scYrOFZlED5D1cWOUbF/SWJnYiM4+FDdBvBttmIwm4+FZL6Bi/bhCFrqOgrjy8HNqpnuQNNCNui/g+/kmKYVhMFidMOtUgy3VoCdXBxX4c3Vsks5r9BBmEeCtOb1SF4um/vTuYNwsCSj8uBokSS5focGi1fib+npUX2h3Zy+U3MAbg5JTd9vNtRatlsU4d038olqrkN+JCxsL35ZEKeJDHiXeEXWOJLb/eiIeacRIT/qX6+SI51MpB6jbFdSeMKCvs/himFPpDfHrMOkMPfnwFBbxwzbmHJ3S/Xrz5Is0Ddl7FDdF7YCx65Kzqq0KTE8mvJrXhp0hSAdLxB69Dkd8K0P8OPeBDKOgH/nR+WOZ7afsuMAvJxHlHhSOzFi6BVo3lu9yiYx44IbxtiY2HzveDAjb/0Fh4xwNsKx7XUNibyqUwcELganp7nA2l4CV6O6MEDvz1xu7Y2U1j8FChU9IbVBtkAG5//ATlUQA+mwL2iY8ihQjZl/vGSWSSabYGpImWoLifX8oppOUc7WPj65wPbC3aMtS/eNhUz36cI/gR3LeNgja0UmbtlJlcwXXu+0thDN6JU6gLdUDbHRsFOWW5llRIiaGcsEojeKdsOvOnlFpTDmZlJpUlJayphbE423CK6SkcMLy/ZcGpawfcO9VlVeIHnSxW7rNt9V6/t7L4BwaBaRaEW+xtW1y5PZO1qWjbT7nKlw6rxzTANnVBZbYnXZkt3WBi4NhT50GGRheUDrS8iqVZ03mfUn42Ni5dSg0vKRQw1O8dTBk5emKVli5wIFS/uGn85t5piKM/Q8w3vTOFPgqTCWgG+JLBPx4FnOaRU/FkC1TZ9ST21eWKcgE3H/o1AZLvifvd5unM7YR6z3xacJj/1DF49tdoyLoe3RXwqh0LiKc8oBgDD53GlwYzxbJUY5J81/+M6Z8blPaE4PrM8xVvLrlSKJl9DAmGnYKPbhzyIEWYtA8HzECiV1e4L1LNwxHLXAG+2P0onlOc/1Etm5Bu3/bHfHmhMMocJev1+bcOBwckDFkMZ2pbjNN/wnHGMxmfuLPyMVRpLDBDabE2Xsuk8C630C40Dq5nUXT3I3TALMrZKferFfYLwfJEXKEDl1CQQQwe0dc+ZZzwbw4nhkexogUQloxBQc1GXXeunqDSbO5HW2BNdUKMW0GP6Lz8V8kRBEkfwQk43Mr3DLrHI4gsX0yMZOm6yHW9bgXzpCMitaJiQa/BDqwByHz33dZDdD5XGOsTu5PqChsIfvUI0DLhmoGKA6P/NDAtKq3Ny3n0Ri93TA8/mh6xfCRpZExiykIGHf+dc8D1t35RI9iVowfLzcNYIb5mshcamxIP7aoDT5ADvTQnBuLK9Aa+Y/O/kLaALxgQyIWo30555VNcNdefvN4Auejkmhr4tk0G6RcguGlPa9EyL7v+vrTlTfX7IoFfqAIkc22ABNRWp0+X4dja/mfTJZ3xJHqMUfF3tFHjOwZDWUx8l00atkOxtZhcr/7X+xeFX9egJQoCdkFiGfOqk5xMNAGe6seSJmsCu79vSTtavKElIvJUittuBZeairlJ3RLtbkXlxPfcvdwyy7Ffud79NsGAvlc4T52ENmfTESjfLFbBinIpCWg6z1R+LbC/EX9EsR/NzkrGJNSv73YAOWpOKYU3xX7zfmMlf5b/6R+zkh1kjOIbtV3PTyV+zwe/OEIj9kT18k6sSZPn+YckM818aYUVCF3iHDh6EBV4DC8aFw+rylPP/bJp3sk+UP+t21eVHeZw33KPoLRn3npwgygqA29V4vhlU1zgoeeet5m756aXQHzXy69o5SXWBCHhRxYTYvOq61WRG+RKHY6PZ7sW7zEtpFNC1J1UW4Fww2gwMiiWZf1c2OUG469q1c7lAmeNbhRPK5u5xujF7Wtg6svi6aZ8c7JC74/3hu2DmYlu4iz7qJgaf0fbyKpTzkFq7NQ13Xnrhc+Fp89ilJulaHOPaRtLXznzu5eielmfESeFnI9BpGbBdrLZQhUoFniHMrKTksxKEPDWwJBmB057sjT1v6+czeMnISg1n297Bb5Ce0/GbhcGxbJNQW+MgkzLIfnsixeNO8iIiP9iVyyGDUm4IKc/+U7JFP6jd0iOzrAnlu6R6OroqXKVut5uW8i175yn3bMiq6dwC2sXtBN1I7Unt+J4k0/qJJ8AtdfpBUQcsnB34enwC564bQn0GMznuWbQrufzhP9batG8eJAxWBtjbU2lL52Do2HFb6Y/UeKpG0mThyZiKkqSAdPgdVp4lY8K3VYmjga/fY4pXpOddxc/cV8OcBRLDp7st+bTSdmt+NuyOK//1t6Q6gucuO+hA8m4hStjoeUUG75M/sbArpA9BFxZFqZ3WvoJQw3WKco1/0gN3nGJSXzf+765tttQXTJH9fdoPJqP2zj03EBX/qDUf5zN7LsRvIuP0sYN3B1+p6VY8vKnwvsB6k65O00+e6/7J//MD/FPar25BtyTR1oULJf/d2DSHQI4PeYaQt45f+Zp82J8ttD3ny4rOre1THyM1nwlPDhKkvM/Hbrqr+ksTFxYN8lN7+qQD4m1ek7jxOJkbU9RDXM/7XQcO9x3+302DxZty7GzX/Yot292HP1h21VUVS2TcEMIoD5vy6E5kTm2cPeCvAEXfWiX9Xo1OHIBcVSKTjylw53JDLLfADVLk6s0Yia4LNt9vdcqS9YqmUmJKPto9uG1vmFafaThSiRtl9BlavRS3m0rCB81UAnTIZkq907IXNLr5zGcf9qHAKvhGN5gSKnSVNvvQFfODuUGIT4oY5fzSkq2oX1S+5rTX6iw3UTWrO7j5WwZ8pYiF4ItKhUiPwkS0QxsiBfjWCKRgD/DZKTWU3z5MmSZjBt9KjHKbRS24FeyoRiFgBoEXjKGy38/Sl1c60WqCY6S0+TD4B/FURRMkChEt7rpJQQUP/1XbkpbxDKIF1Xc1nh9Hr/oG8cUYBcC2oVq9Fpj3iL+7Rgv2L/9lgRWjzc6c0fGs+GUNbRZuexpydOWVJvgZm088YeN4giZa0DlRrWduG/PIHzD3IrMIE1WAILSPI3s60ZbzArqKW47Wx+bqd3HOdVzWVVjIOHbHlSrmF6hAjbbYbB+03iTPlp52hYD0VA8a1YyfKOqxEl5fFzt8gtpRWTqwQg8gvRnGyEkndx5F3PvRWvryuK9xX1mx5NQ87+tHxSw0UQ6yW3KAGnyAGrbPYCFwKeywJUf74eUnN2AxPSPqaIcV08vQktYxRELqUEMcjs3vjVBTjde1prAbFKWDxf+DQmBDkf4y18cbuFqmYIOme4IBMxd/Iy/jZijt371Wu2pupPPTQbPeKgfTRaycEtLQkZPu8MiVP47Atxx7QYIO7vfpRkcMPT4JfQl4f6jYz9x0ONNdnIxXIX2oiqcXlaVlPsmRVrgWB+9jm1GNttdmvWUZYrA6bBKckO+0BsLGI+zdZQ9TauVyr0liCU13q3ghBTsEWT+y2SPTlTm4o6MbD4gf1bOmCIqA6/ClUwqdrp8u3mgafdWVZ0hc2oI2ZkHOoCE8p8IJx336ikOy7AFx+M+J7AN2Nl03r86HwAVm1CymhTBXKNhVZff4xAUKro7YS/CHI01JpaqMW9Xq9TTm4Vih7BI4FdfBdaNJ2yKeAQn3u5i1AuszUZ8wpL+UpxNE4uAP6ug+5LQWqNY8UiZDh2Gfc/3cu0L2OSrG8OKNl1c8F9eA1FDDNnc+HDMDkdz3Ae4dcN7E/Fj+YkZYTMRxbG3dqUnuAUDJkdTrR8lynD+UIIjMLcibi4Ie9/EzBZovpBTQfgY2vi6a9XrnmoNhgeMmRLaRPzMUHXTpzpoANxVVFRTDek5x4eA6pV+uI/vSs1I0hf14pVwMY0h14swmMvgC01lxRjOw24dli45T1KVLkxdPm6cpCSvRRUBAuxfQ98Khzr1bL8M1hWLwWez5QDlNqGADM4n1jUBqPdcIbqOhVmEPhSPhl+9DRY5QqBunCSWSIxs5YQv1obgTlq75VekPPrU9odasBYj6WqW50+DvrQo5HyPrt7/3NP8w/WyNLIrkYn+v3MeJzuthmaK3IS3R6ddK8xEd+K5lCUhbIbXE8IznAXWxVsUxOBGmQ+/9o5X5Iyotdb2amzgJbVAzoek/zMqZgU6sSItMkFGNK0AXnw5fsJuIMD4TYYqwywhAhInF6xrCPP3VsRU/O9lWWn9Har1b+dznC/UKvWxiV7YdrOqvtjRyWiSzBeuzxP7ou5O7APnYcaZGCmCR298foV+89qRLI3J0g5dhUikwoTUZY7NCHpn6npL53YkPSWin3iXatDhioM3hK3uyOj6V5s4Gnmigw3+Zf9GIsQzoCBx+gmSA7m50ZC88j8tqCJurMBpbG6U7apvXAGu86ZJU6JhfwrB/qS0J8bZAsIZt4fN1HH9IQbelxcO2YbAzp7ZBMyjpb9AKnEHs3Go5RmNZr8CXIo16/RUbxOVL0ii3MRtku59S1Bntpvv6c7OrKti7AH6uRzWT6CWlSjSqetqUQ3q2t6ZWlTY0vcUhSurgDha8d1LQ2oP3fjIL8hFibviovBDCNvQJd4vWIZnTcxxIk3TuuQwYVsf56qL4WtB5O2+yiG6yub4FKkrhtbSmvvaKLFL6isqUC7QE/2s61x9hsWRrSnGcO+nfkUyLhDUqkvWA5wPkVbyipltY9bPg/LrmUQEobEIF2sYJAEA4VBRVpzk4xVUDOjTsKiJGLu01RYsN81aXJJbnqElai9YEgPnp0mh9ZYoMgMK16JSE83BPdDuOMZ3Vv5t0A2FRE1CMTMT/pE07yDcZNajf4XEhiAqjCGFi1d5jE9oqi9m2grTlLq0LRhemr9KUMyJMKLx2t9R7XsE+zOPYd0iirYea/ZIp54jij7k9DkD64W/mj+2Cdx5fdfO49re798I5rhw36qDh372wk+s0Yu26O5ZvwajIDtcNMzM1AfDhxUWRVFQpRCShK1wO/pHX6xoYZIOJalq3KBe1ollg/6vqYP/I2wHR13p1aO0YITkXTfdaF2i7PhQdiEWnNawDUDcUH03PhETLbcSICkVGmIEvuDPL4FGQn0B1N895ZhJJt1vaObVps7YQy3KK3D1s2KdjVsXZjc5wHVDVHXBceYiFThk+lngu9AFmDSh1ri6ds1OVjrXyAPZa0LUeT8HSMSAUhahFoyZmqfpoIgWp4ovT9ZLBoNRrDLogNkw9Y2iRvzkNA+5B3kVANsksqOd2dKMKis+8Djeh0U6neIiF6HDUrRHbdLK5P270nbEnmVvNtd4e8U4H4k2Xdm4c60ulUNUhlIEwt1+8pVaqCoKgRpZIwo7NF53fwpu+bigY7CSEGGzvPiujQ0Is74tLDQyFeWOKfTUL0Ry7i1nA2SD0QiigIqQzlkpLbqe0cqkFUSh9cI3M0+VbmcTbWnsKT0uw7me/K4Z4EJvqD8j+ygIzXoI8JBvWUfVaV1girY4JAsHsDfWmDoU/R0D4U3MJrALXvyi9BBluMzWgmGWIUdWLdbQTnFU6rwIJeSOCZUmmQnbTmXjd+SIFWvFA2r5NfHST6XCagE+Frrw8hYOVQFd4al3lS+UmBril6fWb6LDKz0qfBBB+PTT0DsU8oAmow1zQLRx+gvysqivjVFMxQf+gM4yijcHNgmf2fWTyyQGjHhZknmOrY+TLPyyhHudQ7BTlLDg5R2pYSBtQlcp6/JpzmdvhzSGG0gZNahSZu4XYyixAhaJlhnlwkeFt0tGjn6qe+aqq9mrLnd9O9XR0y91wLc/0FL+k9jwK9XLJwk5u3B6oD/V32EroeBDW0IDQQiiVowYNhjY61FGBd44UdOQfx0gqa9PM6DICuuFDVs/d+dCWTaSN6f5HHgLGcS/BXdAk91VuSzVC4dxryU2p4/9Pg4USkjBOfgAjWyk5bi6eMCHnn8t9VpLvhIM7Fu58L5itU/1hcc7WtnCPq7DhqIQN0nEyOptIZWUI7+WneyUZgS4b3XqTMgoxsUBBVxP4r73WMzjR6PsYH/jgLYFye4qeJFMu8KwdiNPP2NIThY8WSY1Tu89yxHECNKspQtVaR7JNMOVNvP755y0kiNL1QmoPAaalcz0/EFduPn5J7D8pL6iH6U4AqTMbBFY1CcHHF3FW2SsV5t1KjQhownZ4o1YIBY1Tv54mSYdADN9e2Bv8a+yATWMP0lo7bd8J1PvchmoM1do33xCfThmPhsw0tchDtA4hPkwm6wpmQ74Gw62oz9XPFrkr+F2Hzmh25oHv0Ph0usVOCYWugPxjhKmBvitESUsL3ntbLWQLWZNZY/Sl9ag+7+WNbVK2fX2QuBh6Yt39mYDnA3R3oPB882SH36Eh2Fit2zd8f2oSQJKA7e80jONR1XyilgUeLDmLIDiQYsO3hPsVx5AEQCd5m9qOGHL2dQ1hPH3irMtbISaXqBznjyQ6iO6DhFHnHxH44mUGUAZQq5KXV4D0GlG2Md72w+ElXG167rq3HWu/nZudoJ6Pv+XMKNu34SsnFtgZDkcRipyxfKifjfdh4byi1Xauh7rwmCb5vJNnkwRjt3R59F3T3UPM3M2uM4GeUj0W/FObZ9VVEKF9HYXaLAg0F5aMrGR9bqpp+yoiXZBk3RTzEAmdEPpz+VnjynpNmWuIXG1kb3bdMSVoH9XgTyx7x03br8n1s9ZEHwOIEKnDTLhIdKKL661HTKfVt7l56j5ZiLSdlFFwupq1jGFCfuYKP+90xwAPVbnNZAJig7mIHWIPgxN5xzuU8C2Za/P7RNjlDntgSDjJdaJ/YAxSKkT+4AnaDWwXTPUkAJR9Rg8Knr6O51NtuRYYlunQnNoLsCpfxmE3vUsUcm58Tdq4G+qxt9l+uOjQ8NqNQMWrsJlhgM4bnX9R/tDSRGYDtEpanwDC7HAAIzij5joD4FWUYaNaT6t+2nPuYg1kaVeUbbGaxCHx7ntBAgQccfglkJNWBX0tJXVrNFbmmGfcetO5M9SrtsmwZCNIpo5xj9rNUKb35iP0clzkMQg7Rq9vx/FJhFbNzeWPBgVagBbQiyc1EZqsqhyCCIbWLz6apONUrYOiZ5LFr4NtwaMroyVNCv8ZVqE3pA4/QDhDXar2+Y1oNdzEeERxw/Ns7Qoa7NqtTG2umoYtqbUqRxNqtWoR3WGNHDYS1WF+x0bWZ57zA5lp7gfSaotKCbgvzXhbUiolJfKabV7DWyVv9p/RU+q2sEaIX/P2Zf6iZsYMwmc50KwPVnMDTAmeOTfyu4w2+I+8LvTIVjJzz3iXUxHsz6jgECjVzqXGELzSkxAcWIkANDlJCiBnSb4EEksF0fa9s2APK0kj9K3g4yOFwEmiQQU0zLJiI/Arv7UhtwSSA0cb7OE8Okxh1S8t1zygGBKjbRtQ89gAeY0gkkxlXSEl/w1/wjy68gTis++16F3Kkp1W7O4sLp2iTk2Ne+D2Otpa32zCNtwbxnMewwJ51/SGpGnfHxg6FeGkd4c1qWBlK0N1Oq142z9EIKlThseKyWVmeT8nLcj9YqgxEBMO09xtD0P5FO4G6Ntyl51Rn66kDgRSyLXr7jcUqDRsb03sr3iLZEiL4YKVay3MqQU0zJYtTg6hzlWsIzvmP8XSomelEH2ObEh0SuxpN7nufD3s20iHFJrGv6cLBXoPWejhGsPHymg2DbC7+PQdLXgFfsmi8CsfkUSnQFNShwjlv//ThV7LBRQabuePA3hnjIOPqYSVIJCszmpp2r0wc3O5AHbMDwUYf5R8gbb/owa5gUsD5g98aGryvvyApxEV/lIha5CVOgAv/cDCmQU8ik4sXcvwL+eMTS3jPI+YGFsOPUN4W8kTO7XXEFgD9h8NK3+v7AJ6xO1eSLPkqicvgqlm5yXmH9FqwN4JeNNKIqF2BrzifgBPYWl9+i5fVt5nTx3VRpo12E3SDe4c020baNyHdMXXCjY4JGDDM9bZFb02JhE1LN7C2BxYQf607xGAreZw6SyNhR7R5vbAgQQ4eeF6IaoEmnEcm+eFaOy0nh17n8NPl5kTpREe0r0xq3f4H+uteP3nsxxhiB4dEtuaBW2ziucpTwfflRVnp4pNRKTRYyiVS3eKwhska5pMJE8KWaEQO8esRTrFvzQhG47ArDyVtzTQlAwhbHnxJeeHMu6NUTBi41nbYR8PZmrlKjod2fdfUAeqN3iX4Uptpm8NLppCfa6nxzRK17r6YSIREROBu5e9Qu/jKTpk4z4iq9TOIONGFDC4lHMNIMT7Si7iOgw6FXhX6ugHDG3mpnqJ+l05bxNNcnNMN2yTxpvVSxiak1jucHcsVDqWU6Fx5wShzpx8ctjSnsZH9XLAv/l7nzXgEa5tWm2f3YtjtebMc0hD3DkGYi1bEf1WhbftBuiZvblRqyEx/zHge3zIEaDA+814hfQZpikTVCuVkTQttw9Mdg6Fq/YkyfwpmIXMj34J8fwuOQdY0BfnazxdCi/FVkFxcmv9H61jwjm/g2dwYqkku4iwAk2yK1MgHHJpaDdJdOM3Hh7rJTp4FRrS/isqsvmRN1+1aBKGyE7XvGZW58qYq8rZ+NgYvDlXfyUsFAnOGzpMw9AwbwIoEu9pfeMF+/PKwzB2kdgh0UqhKWcd+WAwafv+pPipxFmxXwI5cjunsHWWVGVTxcL0JTH8XGJDpdLiN3idkB2Cohz9YbApfRw/ciUx2McxVS4MTjdKY1EZyOpE6U6CmlEiA3n/Lp8UUL1LYYbe5k1ZdHp+U7n9PzcmOMl9kYj/s2DTNPkzKYDtVXFvvMzeVIVLO0Jqxhqny6wxkTE6VYo8NmA4MrgqMafEju5mXny++2Xh/e5MQJg0c+8bofI2bnBcSdMMN91DPofW2wcTtSzWe3BVQL65i+WQB1CTUPNzInTVd/it302IpuGV+Qk1xm5NJJ/ReO/yDUJqGYm+rrvq74lhxOPPZahP2p6SAbL+6vUHxkw8fKk73FTlbb8n+XouqdhAq0BvQIUvJReLCdRR6ls37LC5vRG3ccVwZeSiHP6nm8+638Szyva+Z98ZJLBgEnGETUmwn8jCS8fiB541ErbecBUF0F5LoZXjITBfWtBjpxx52yscH9HzDR2OZDf477QW/q0exzHPbzBcJHJ8kBktcwyU5gN4Vf/37gv72v6Z5s+Qjm54XseILYeeFCEh9ga9QOd8rjezqqXkNI8DGDJ++/Gq8xmgZySxBVCiUUfk0Xm2SOXSB57WLsClbEHW2mI/LRGkSPU0/j2qcjJyIjIw4xFzuzJUAVWhcFv71CEgFGT81MLH3EKbwX/UCkwF8PJ2JlZNKHyNCCnQ3BIKArS2e/YRHjqHl1wv+sakxxEpggKd/JStFVSEnl0VkcvFrkh2IJnWMvDlPuT0ERuY5VKB3hv0XGp1Y9i/VOI4GCbMizqbMu6a6Qlu2JJRy02+48oHCJQg1dSG9Uv3P2Umv2If9y8HyxQVEhcc/Q/VAsCxNLFpFU7nrq1YCA41MyRvOhFZFlhP17zxkWhf2raK2XTpDLR/FS/1jGUaQ14xxz3xIP4MtKqoeP0/h4Lysf4tV8B5mMp/Vg78KlxP2xG9eb7vwAoOMsC4dPxdWsqtHScqzrh8HGd1q2EaXwcN5enUeD/2enJ9jWcmS7LlyXkoAKL4mzRn3iBI66NUNrlxpMKuy96cvVtRHq512ZQ3rN2dwLHWxXYsYkjXPMEmGl6bgfbLBEnJFcnVsn5vnZfTjwPYvWqqVijmUsz5pGryfx6vBGlnfaDU50ASsR7ebDv8xuBzFwWD7cAY2rbfDnO+xmAQVRUX0bFMuqkRegD1LyVYCuB3yOJCQuiy153bnFCysxjQJs4BoYb7Zu19XwuTjO53AwAgxUso0KZTR+XXHpnw1TZ/1yH+zVkcor0+PCTu7DlYN+DpcAkLnUiF7DwDqhrgMsIwcRcRoAxin/Dv5pEQgDCNil0GhWHyMj7vsF6EP3BrS4xGTEJz9W0p1B7ApTUfIHV3Jail42l5be2GGZRpd4I1itXKFkZImha3n5TWNkA+op1HfFGTGy+FmZUz283ZhoYPdYEjISb6YxdfCmJ4tpi3OYnqPhjWoW3H6fEPIyHiJnmWzChinvLAq/We1teMAFC8cibEJWaoBAQroBWLoroLyjvXYDnSgA1seKdNu8rXqNmjsCWy1niJeYdJOW1GLbF2VKcOZz6ejGcAx1UsqFCaTEDAquHUUZCKqc6iLZ7SXkofFLus5yRl4gN9u2AQohN9Miwnzx1bxA3P1pr/LK4K1lCjHMvdynKDvFyXdg+s5Wjy83beuqN8mxPFGzamEvJFtPcmkiVTgqhGM6mbGRV/S1JfqLjdtX/fn/aVxZv+8NcoxQGN761LukS1I5tJjpF/RcWpQ6zBeBAR6fJDRJ2V7d4lvhul5obrDNXmVxMPuSbZRETsYp8xYZ/ASKmaNuFqGiF4dYVmQt9pxR1k+zYu0Qjb01BWkaVEvPX8M8SP8woRI54A5naE1GORXTTD6qQLDd61kp5WwXM5AP39kCQkljwhWQ85+rMEtGAWg+cJqcFLSqXqgPcS37D0jV9diqvQ0hcuoVBPxHL9D8GyQD8D7ZjRd/pfng//mM5gX+xKz/U5Ob7m1ud6Tw25ZiMTaJotbEyffHSp+xrU+vJFv0iNmC6n2++I+ExH6dteebxTUfzl8TOdEXrxCxAz2zpk/b6+48yJ56owyAlxOZWzPssfAn/CPP/ZCvuBcjNwn1aM73OWg8xcjtr5BxMEG0c3x3xf6iHaiu6N77bQskMmRwi9boIUAOcn6NgLaz6XWm6zQgu0KPyzKbZiL2liYnp8OTLoz81ePyo8U4of5moY6Zo3JfvOqfGvAtNKKwvs7k59XN3XdlWVmVEd2InAYLd8vz2V6NYwq4sFCmX9GQce6gD3iYmeRA6R0B56HhjnsWoQotAtJzaG/NNRbAuiBDqDuRpW3+xYmsCeZIT5To76EZFmkt0XzArbHYYI8arGKvoKfub+fDRbQKpQdhvh4AJlC8xHVzMBzh54nKUZ7WHZvlFOSloE75Jrp9+mNHj3TMi46Pwb0dbS1dVO0Jock1t7miJLv3iZZNlUlJFKNhmgLrBEN5YF+ZF5Y2Usyvc5cRa7CLvYtZRSoazvSoOzXB9F8ZnED3INcyCFaOGW3Lw2JKK0xn5pEZkcrC3kSXqmQUTZn5rUCdgOUd4fLrv2KXZiButpIfeYSlWncfhf4v6ngIhpg6gmsaGC8AZ92C0JLuLb7j9EiJoeVFZUk1UcYWYqipknpMg9QbSS+njShI8AYCUuyTMdl/4KzrOcqy4PWGzOfbO+8g/90QUwV5OlTMK6/SZVa2FDnb4u/CUoluNgjxg+aqorcmGHDyvmbHc1OGSRWVRlS0lEZ745gWxyRWG8GLql+p1Ubd/Ul1mkMIxIAfOcAErzXr7eXAo7/pt/hFm0T09MVmO4YtmoEql1U/IGNuvFQz5bFnpCxYnMCZ5ZAtl7oEyQikVYGHF42USPovGY6ksnBooKUDEEv1BF4mgraWsB2AciBgMa67m1AHiUxkeILEgATnowb6mkbtOf5zLztnrOujfNzSnSy4rtpfbqxgIXtbYRQx3/DqXfoO6KGln9eeQ34vjmv0ViNeLlDT/3LHhnTEefNWScI/LWAvz02ndI4rGhN1/yVE4O7IfgIjLAJ6wrJTiYRsefUZoWcWROeOwj/ElxCs89f2apRT8j5VQ2OcKbiNJrcHIBlskQm/AaiDGw+cOjEDhowZsGfBOLWY16qRXMA8QC38LlZ+J6r8+KpT43xuK1zx5yrd24dcC9xG2fhRZwff7Snnj1aaDF2SQutSa2pEpPpZQO8LWL4MfskyO9CcegFe/cUK8n+NxbuoQrWvlBdcHkaOD+Q7AgF74PdhjHNnfxn61UVoqDLugq1ZbPStXzGLpvG7ogZDMw14K1w04fa0XAF4Kje9j9CWBIWAJOkrXCu4vAtkd2tVlNpeDh/L1LVUIVPG3ETl6v5WzTxLpMOBqJN7ohIWc2/JYjDtlklJJkqX96j+7F7/8ZNf95ACJXvHHdy3XKq1LlxbupjYevXpnFGXQJAcjgJFIXthGDzE4RAHZpTTjsfBLTjIfuqxuibsMlVo/u1aytEbA5MxabBSkAAXNIhnok/wv+1zm4VgbSPFBt/bHs803MkzlgdSLwIt18SMGf8zsH+498OdFM0PuNOQpZ2JmdwUt4kIteTmqN6fw7Cjpsdl4vg4D2g/iQsAHE089An3pCB0wzL4iTM5Q1c0HvBqHpm8UXz1cJDvrSDTme4BAdb4cELSW7QiubTTFPT4RmiS9fKjWNbg94DcFZHvc8Jxj+09n7nO3WXyoYGY+OEEc16FkEb0e9LoMiIDY+/BkgGN25HvEzBUD2eD2sImlNphtjNNer+w5kbeQnJyMnzYLb/YIibvmFYApxdwZvC35RVonqrAt0q/L3OKvtpR3FA9JdYZ3xV00AQiBEA1hOk4loVacLnKBR1LLGp/PCj1AcvjTrOYizoqavGo2FVETdOZp51ScVzUmZ2EZOfY7v9t1CCjrWVGR+Lx6cpDi0ofrsrGruClGtBDrxQKG551f2SYHL+1tlJLDiyZ/vFW6R+uLj5o9FyjgZ/y2okYdikV0+L6wAtrIfktm79Ltcy9fP7it1w/H0x1QK6i8q6X+Nurnvs6gdndMbA59NTjTy2sEV257W68mj8ItFmUVCZntkf64W5z/ieculQJrG9edHILJYVhRtaAU1R5d/fYUK9ISrjybStwNQ2+GXVmHfqOqt2CrnpMsGYsPXdU/mEYpoK6MM369x0siadCi8vPxhenaKMfBkKcM681koY7HsHMPEH4WK1MPBiXs3OAKfjXsagq4GAUYppHnbRfi4QKAG7hz8fh8fcv98OHk4LtHCs+pmdVuEYo5TWypomH4K481svHRzIg6H7tqynT1r8i7mN1R6N/U/VoyTNYyBS3su3OngV/EpMAjL7fVzOgRimlJzObnft29uKi4XYRJgs6w8i5MPz41zwRRDbaRL7E634KIzW6OzdagSSRy6Y1JtCsXVMpz1z65e9Zyu6iLoDpca59Ypbo730unBlHWV9HLmRKVL5LGxUMzvITblr8dE8Qa5TiLi3lxo1d3bV/ckz45L5ded37NMyt3v1RDC3PIp+ck5Sr4eorTxNhU/GV3s7FN9myifMLPSeYxcI4gDZaMAjFVsNeEEEQXWYctuaOyI2U3wrR0mGdHR0ndX/nxWtsXyueTKPKWn5X8FqVJ0KAvmiyS69H+oquJn0mP0wp+LP+RuJ5lNVC3kjUDMOWhm/SHWi03kfcAjayxMN34WBK0/2VXsZqanDCWG9X2+yAQrfCDgq/K2CoxZMZ37V6wyA79RgT3Wm3t8shGOtfOpINEH3RInAJNdKLjDf8MpBs5jQ7aRQEvkkiRoLdJSeihhGzEap7ujH5yXofjfuzH6rFKaEhsrBFfenBtBOsyYfJ15YS8juJWuTaz8tdgLNSy62Xi0dARhaMkR7lSTQCaJNLJsTXRVX9JufTj7VInnUIS8XsQTcFdOUJcZn0lzO462XZD7ZjF1sEkeMz/Uzixl5ReyT1k4N6psR7EkCsgg5P57FSmXTsYQe7o4xM5vZhLpegKIGJG5TEkKWrbJ3SijamKAJZFR7OHGD8LemuxaGOPnSiAogpGk/gt/c7qFGw/Khv4dPRDa8jboBH6mH8ldSMqPkgz2qe4dvUaofBE6cG7huGoDMytGRbubb0JTzjZ1CzwtJOvI6N9MkCA4tSXOBe8w8oaj5zHsYb1WzqcTiY/np9aqECIuIfpZxQ9Gpf4/6PkrkSej36a3XApuhm/FUpNqOTXBGpJea4NJxQCzg/vMOEFkp7cCpFlj2IzH+NT3nnB2+JVgV164OB3XYfTp4+p5UBoc0MhxjO3wDw+Dp5Kzxj8vLTHt6XjSBo4pZhHSiH8fVk/5uappEYzHM5hwGmn9W/Ovw71/JmVy4Iru32pqyeHOvdFVodtV3IaI44L4cLs29MpVyttu1+D6zDBQEtmlTIjHDoLcokpOi0ho+xnb0TYhEqa4Tz+DLLryBg6kYdcSvnkqMW75HrE/rB5F9Lg/ac0GLsrZ44GPLPuGmYXrvkjGG28CqM2O9HGUfJnpXJc5OPdjX287ZgcOEfvmmJT2ZIwLLmPqk/tyrdMGoH9NlpHi1FqHzZBRKBCBvhSWXh1oSRVeJrwQgGy5/blStTDIQOjiOMo/QMnCYABh4+CVQ+mbior5cuS3M8SRt2mp8Jx/7Dyf78fJ0/7zxSI6hhEeuVvqW1W06XVxoOhvZehf8dJsOEC+1A/6OK3ctvuCgmXlko0X/YESLJ52AKTZYJJnNGkHYWy72xfseeqdct++zHoljURiVpZ3acEi2keXBn+tT+7rNuRqJcwLHuNRm9DMcb1h6xLq3UZWzkwdL4jy7phI6y98y+UBr/ff22VIv7hwcPXvv+z2PaEGoE7SBC1NQYZclXmzQjxrIDXn/1gmdjkRWDbFAEy+ofb9ACgpHfrxBoRMGmstyTwEtxo6fZJhXkWLP+6hI7FPmGCWR0dsC4U//I1uesOr1z7GMNVZS5MWhCRkGoHzYvaaf/Yd3++k8FC0SUtYgn356c+AjwWl9Iv9ZSvHSCdLUeRapMfipnDgVAKAaipMBksmdUCQoVS9S2N5Wa0sDrBQ6NJt6B3gPltzdiWv/a9SZgzRQhi4OTe/oUO42TlJ3jmO3z4lXJEsOQAy+Zm4ykwtO1z5saoCZzQIc4Dn2Owg6zJv1VK+FG+XrLEu+KaGYMw60Eyd1DjH4fP95m8Oa27723o5BnZqdVscGbKCgnPj1hOTGW/+Qg5i3cs3ywdTGiupgYOjA0pFO+ffwV/Vb365yI1klSC0o9RUvnIAVMi128tkKVQeL4BjnA8oz3Liwx18hPrmfrQV596JLPznsfCz9HxrF2rDQudHL2eEfqDbZzeaLTCzhnLMNT3/hFO0yP1/quY5JTDeGHlyfp18fqMdXmw94cPa1Mfg1rDVnU+7KoKhF8NTIj4AeGBRgCyTlqU8q2yPXJJSwzcCnzizdV0vWUB7womhR5nxOG6bGNQWLkcjaHC7WQmtnFqWVTGLohTnJr+mW8gOC+IPm/jW6rsIbi+rCjIRpiTpLed+YYLlVprkPx58ggTODXMrnde1Lw2gnyF4fjUoSMLuuwAmq+00AZzCH0kSFXrmPOO5ZVzDT5fXshHCk553FHm94MrTBLFmaVHkcpfENixOWQHAlUSEbYpNTy+UV3FtNJeQf78dnnH6uENIPFMMnkJ+qxYGasnN1u4LJwZVxhKzDEpn5e3mhlQgn5xD/053DzEUMLB4ztcTNY6lZLuc5tidhThWakabtWnPhC/PBeqTCA0vZ3yibNYnYkUQm1cmZ//1uKbvN5HxH3XMnHfaoQaejvbP8xEzDIAimM3UbfHGTX/vlAxV3iMdlbsc3qMEFgzxf1AsoXeZ7gTH9DSdn/PcFJ+Xp240icXs5RtF2OXPbfIutlp2OMlY+Ftv0nOjfe8bSSsZx2sppERvJYS96x9RO/4ACqE1Yx6ri+OZLzwv7d7zOfF+10Bh/omOXY4eUNfeeimdxW8pqj8mba3pKp5clnvMMGf+PlY6Je/m69BKtRMApa1MRG6viefRhSU2DKL1tM+uitzrBMzpHoe7JaKuI1IWDGWWm2F5wjgyBQ4XyPYuUAJZn/L53fAjEsC5l2moF5fLDQOMaewzgDYklyZ37kWYYTN4tPUFAW9qqcJS6qrl4YyCdrUdwL4Le4oBB9Hk12L7I5SNzhZjfn1Ynl7U37ZIlFZexvP0mTd6nsZor7lnBsMOMo26MQCx9nPixSLlxlC6UstIWwwsC2AVFYdtVu9pGIqGJzw0dC+YaZVzc3FXDVHOFW3fbIS0ZYsp5K2yb8gM+X4jGABLMP/nNHVFMbsZCqS76n1zAoNlT3lNJht+mL1M6NoZBOG17J7EKAPztCWI730aDQRntnePtue95T3FEL57NNSHAMjRPKA+2zw1gGqYAta5e2QYOSI14sp2QlkMmKszQD02Mz4kWaim0zYXKKBt2K2LeYWvYfuLrQY/0E6VYtLudeCGz5W8bBGSu7S7+dXgDMfPZYrzw2Ox+V5hJrFjonvT2w/wiclTVohfNBC6Tj2TXFtY+a/2XvSMohbsnata0SLklqXbK/U4LS+1DSfbVJm9Z4ufJwapjVQ68ujMU0tiN4pK9p2AlYoru5apERaYWvmUVdkvyrv0StjKjp41N6LisYDkdCg2H3od9Y41BNPyYeAYnEPrIncTflTrlVXsLHtaHkkVSarf6y1nl+VezXPgFg+eJUufL5lDjFjuVhk/v3+HZvR/K9uYKD37iU90Mm2cMYyXXAzRUn/A11RrHK+tj6G/v2bgdbYZFfC6pUNBYO1zAiIkrTdEUpB58AUf8NRlk/5DPxZKZ3zRzVTJ0/53YhraWYTPNa2HsRKVhqRojARWIsGDBRrwHFOzMuWGPNvqdiisHBIjbmFrwTuyHxlYwwbkF9l1yThkAi2Njr4BOvm68QMytZ5A4jMPDSl8ZAOsBBouGKEBo08c7yxlEkU2hm+aD7yg60qNmSdsIs80TxhAABPecmsx6THeKHimNUiM6y2/ZODLEhi58RwmDyTb4gIV9NI+SIJ2vuYvUXR97dc0pXvJ6tjCLOdU91ZjsQnVMNSTDXx57NE8z/j9w/1xQl6YaaXOzrFr6K/7nFuAeF3Jxc/OkuUDyte9IuzricQ3xqXnaF3dg2H9bEUZX/xLBxBA2j85082+X0ptQ5j6aomlO4b44FLxFFZv72c3JR9eri/TDmAN0aZLT7djkOXqYwoom1MscAb8Bj5CzM33ON8FpVktQ9r+qfxd8P5lwdFgUNAANWWFpD3a1MEU6gZXtL8rSUtQrH7AbTSgxqMHOsnZ9oLlXxZlEPhPOch6KXp7tVDbHYJzTp2gJ6DyjLkAs3nvTCoV7SkJAhZ9OWTfbmhhIZy6EYoe24tA7JpYsABDPzFCCgH+QTCrWSyAxTDGxxC8mBCeiPnufhpJSQpiRgq+bjJsR0sZFS3EKag3oVej/CJrxU0G4rX4935P2YokGoyruLAH5Q2nRLs/AGjO0BKVNIVdPHTG6ZbInxZ/1WruiuqUBcQdrwQmErJpvqacHTtqFrlzrfITMfnAsJ4xIaKZXDKv977U/voeWbDbVnvgYufS/YwFRGo+ZEuhQpMhYVoPj/Kq7heoI6A5aH1E28GyPExc51eK6zh/J6PRXuocn0vbRRjwE/Qcq1sygulQDTKnSqWvN6fLZHSrq2HjfAAkj7Ji5Y6jAvTd5PWA2myyse2MN9ImmyLOwg9gS4qMJC/fdNdon/R8FsS2BJsYOJEfJ/SmCR0mIkolxe+rq7aXlJiR5OgGuzLw6W4iTlmGt/FagIZEfIxy3bSj95pVfr5rrcRvmzhE//vK9nISXWvfQ1ydd5svH9oWoupbv3YENibkpxcnhUeAz1t78mGAFN94JyMO01p3B2p7U+weC8cysbJQeLGa71aFTxrPLhjEQjvJBEBQsfGUnZdeboLkBR/5ATJ62eY9ALuk4TWMvKKOOhApJ/Ab6yfcvehihb3/GQDzcRsmw4JlZo1rdGOI/H4Ya17WiGANldAv39i8fEfhbS3rdgE6cu4JEBFdMJw2zBO5O21aUeExJlEF6b1IypLIN62mKpZUtrE0cJuhSmrkXhAfAPu++fOae52tAXbwa0WKqAyg82lqxtCQxWdAdOm/VzqgN3CbGqH13TZew1MwnE46nUINJWNo9muBQfO7BZT/ZEoWmvJX+9zecnFmEh04GqZ/iI5Iv03xWBENJ+FBd7aPNMIPo4n+4dNfeWrXmOpA829IQS3mZ1vm4HABJmPazUNCYnUIBKP+N/SaXS7hbhldtzvce8Ct32X1DZJCBfOegx/CpcIcJ40D3T151BE5dxGynH7/LjLhh+wO6SWEHXpZLONK7ThNUnxLO/2n6Z1AWTmav3E3O6JEfSSpGRy+qSdQqf+oAm8Q4so/OGO125C/5oOCfvwZUrjFH5EBlssydzSeiD77Bd5l8OGLXFDiF/pQ9DWefh1XyqepjV+Dlxy+8kXt82qVbyfm0rYeY16C8lMqA6Vrorb12CY7zvk/ooxnm419uJf/pEIJ/TxJC8GHeKZqA8C2aMgnHZL0RoQW63/922iwgJGQvqdFC3lKXmlf0WwlN1LtJ96VSPFSkFnG7SW8M3UgK8MSVSB4eO5ET2M9L6H/LwRCzvEZZ8By/clgwTCQF+hx9ZauPup5oS5QCSCJ8PP7ktgHQkxULWTPCkNRXwKYPmG0fq9ftgPHBxvkCbgU96pt0GH9bdNjAj1WBqmwBo+aow6DAXMVOpeHHVmgUEfm1VgIgjXzg6FGT9aJPWR9xEnPcEYMpvY/LR6+9QNS82SkEU3tm1khT7rl9PRQ69hwYAmiefBhN4Tn4Fxtt2b1jA604BrkvjhEi1MHccS6R2KK8ZMNdJCjxFcXYAdBBDib05OG8vfI57OKw3rm0GECgl88nqP3kM1jg2cNX9p9hnMK5D029kkBJXVqobSKRDE+G9XN/1PAefPWBX+/JCWxKRBXaDbLDfsmK90/KQzWI8LINGYGKcFdcAu4rKqCDiTKFXIZHib1V33DhzzOq05ZNZKm0Vv0X43MLmWyqw/gSEJ9qDIJvJlNbOTQ73FpkA09AxBcFVE52N/tbvrbsJWKJoQGXcLQwnGlBlsjmohfVl44w1roshuNqkDjfnNUOTGITDzCBtm9/tqjDe7FIcx4k3KDdQSTAqb5s2RuDSSeQfa8e8MqaiRikqED6uie1DsJZZC3M0faE5hQ8PG9VLEqN2lnvziRxmrzco+tlbeLZUUy3rE/KWqJWa9CDB3WljeVThnZmCBrCZH5zrjHy3XmneZs9sVxgbl6HXYGKdREs1aVGphq76Nnm9MznZRUZzb1Xrd8kG2zoYf3i/k/bmNMF1SMW+EJIg/vuNV2gBT7GAt32PatQmm3bCZNhaPF5d64qmwbuT8SaOH+ymmxlVj6Y82lBQX0RZlvo6wYVajAGg9Il/xweR3tKYYTEqrjBxgn4Z5ZYTjRxukD/e19c0KOCVKwy+Me5ZyEP5dI4jXJE1cZ0mPHRyqDubmyfClaB405QDNyD1Bep8CEoY211sW/h5FeKWSybIO/ocYHKwsRrznmqjH0FoNASTl8HhtL5Pe5GYqUTBikDp5l+Gcvj2KbTW7d1La08k5ZJA9pDiBbAFHfwQKGnqmUCyyP2HSAdg5uWy/qcVGzGF2bXzzXnmcVLrKN2SytCWtcclw0xr2aVwloIRSWowJh+0oB+WJoEhmJMzpkfYW657QeeWPlyEEEu6bUxDGdI/oSg4glhIgjFVNgZcn6cilao77k0/65Snwa9WUElX93WW1CC3r4a31I4rQoh6RHrU6dRNuRilfedh8Ux1iiyy02yg1YsyagEuV0TP00DPKTBYyPz8XxEHduXFOBhzoA/b7Pvgg2RUBvG7+I6gvGpHCKMeVomlpvmA1MnSXcSdzpr5V+mw7vDdscNkxswr2p3XJd1gAlCt+pP2P0QusClB+KhjL4jrn8x7GZFCwupFw5yfI7M04GlQarv7+Ib5fnYBkWIxEuNFSJ+Zm7kgZvP0Lh2lPK1Naxp+dEB7RRPNLk6VQih1By/QSkYymtOAH9ANGh6rmPmcBpmVjdU0ve8AGTbMS+CXfvTZgESs43Ml7JuELWJQHCRi1TXNss0YahOP5iPK1c2YoW9wDAXzb7uIdM3XdY8s9B9h4Mt6K+yQfl5TPd0Ap71yWVc6d/wQK2y74d7R9PiPIvYo1DE14MnO2FOnNsBukqNfZC5cU2T8rbq7nhS3lmp24u4pxNO8VNKN/aA6fdJ5hIy2pMuenZ34Ab2hQezBM83pBadLw5u24c8viIzo6TrA+30KzmjYGtFZ6FHH5dhfBKkNgFREXpstBJO0TRR9kULwHZC45rhQr2SIY0q04ULMPB4ZFvgfLTk2bJzadpavfc24OXBKCN+qDQfsq56drwyajxHh+yLbRfcJdIO7+cAPzAuJ2yFHoWyIQzypJVaB36jnLuS1Ic1/c5o6NZoyAaMQZ76NhOL3F63r24zDrqcqTL81VE80xRTohTlwewNLQQsW/ai5yfbs9Quqjn/JcSlnm9WAZl+gB6g/bHyUdaqCZSNCcVxGDi1Pk7tXHJgB7q8ussGG47DCZiDM+zpJPSfLvqrTZn7vCM9hlnG4xmTXvzBzBKnRjm8B4aDpDQxLUNZw0cHcdwas4tzJEx5h5T662hPa7j5ANmMXSHsGv24OInuW9Juvh5PdpgAz45Gc53ztPFhq36JwGspaLad5O8PjMkRRGa1jDiyE4/IQEZUNUQXXLLdrxpIqDkQ927w6s9KEeWnWA/nbkWgYpyDpbJ/t43C+Wu8s2jGbcIj3kXaOXSKltfnPawtMsLNQeCn4X/NTGefX8zitWbdxzTfNDR5sJSh5jUdwrEvHIcMJ5eW6taU/5WIJqKAEXT++wmCY1M2DhU+4TESulBlExtoKeeqbMpkS/B/nh8VRMxeRWpPRGycbRLmylfGr5AKLcorA7VAmCB1Qnx9WAinziK+erCqfz3kwAA6Gwuo3c9rDRHKYagaX10zTtb6YFToZWBguatqQrqauhg6cAeWLCX1BSI6v8UwVTU/5XSuqL1/ynP9n52YSckWX1X1UqF24DwM70lLGL9a1soh+Y5jKJH6zxhh0BbjxLI04McePiQJBj84K/U2DjJFZYbOJtk0WDOhvnAQAXlpclT0zN+c2Mz6hXs6BPVMNKUkd9d0EAysYq+W6ogAX7c7oz5FsJoAMlyJC1UUyM9OLuVRD9pc9OCLvKiYEfPQCB6TaNEMHlTumPwq+PQ4PbxGGbDUCdNLUmFdca2AZO6Os+tYMugUZ21R5hvv5ZO2u6To4syAXhXj0I93WTBp/UKJxCGR5Xgza43qM5eotAL8i0zfxmh29L1p+wvVlGcaIS2l0TEpzf47Vvvkosnfdj+d4ODwEwEoVLiMLFoVzEj3CzgoqOPlwf2GUeura5FL+aXot/wP597nSjfbs/nck7QiBXh734xlbZdYsJQKEO+vkCTKolcCljBmP3sbLQgrTS6OEHjVOVSL3cG8EFfw9tC3W0PdMzRwNfTmkW7uag1EVMHdzRal717JxFbYEOy6eAFmzydC9/0Q0lVn4EgxRBnB7E76Ip0g9nzSt11tac+mi7SRjy9M/byZ84CG+j8EZ/TwGfbxNXCdr+nrp5O7gmQR0J63lh/z+hreAeZ3drTH9dq70UVOIpYOB+hNYhKIgE8d2QugBIw6Egi8ZTIyNZ87AAzN28uWH5gGZqe9c5lLxFoujhCnFXc5/oVG6cVkdxB2As4xvInyzELmxt5ocbY9UNCIqsh4vv6Ob7aE9on1rjaJwaD7cM1lNIi1UA+Km45K7owwoGLBaSPhszsjJnrEKiPXYJJ1j6hgFV0TAM/40w+Z0+Ak5hpUxXjqEfWX1ckOe/AEoKQHtbmDFaKXiOV6OpUumysrBKRl/PGGwU5LeMP3knE6DRI3agj/V1y2xxiE0fUvs5OOu2UMVOfgI7gV00c3uQri29pObyBHOP2Mk+blGi8T/xWEsUUL6A6N98aXlkI2CfJTQadpckFvv1cpdlCHnBGpnalTPkJQa26SOLC2hZ7ipc9MXhEiWhVu2KZgAFSh1g3Q6abvpGfxf8G6MWh3pUBfAZNdEaQ+2QgUzkC2UHcXzSCtcS123noVtV9XzU+blGdos9VP0qQe71YXoSp/XVGpTB+JDeDt2EdEQD5Ey/WmjhkyFztXI1qZDeDWwbk7BUaUt6NTCpN4OLYAG8tNtSzr/EJEw5NNADPVTj63ciw9vmK27Yd+UuJEjS0Xmujth86RcKod+aE1xIRkyN6KzUcbZE/as71WnE9+DjeIMjin2XK1k4IEzlYhGk0ntCC9axnnAp32kp6Nu6z5F6Jj7oQATxtA1ljVSrgAR/Ret3gLv5gPyfuDR8KfwQG6IcsMrYjyu/SJIVUImiK446e8vTzZZBDQuYwcVECwFuVl+O6/hRfey2mm6egBVHHOgadUnNTdZZRYtgYPG6l2MsfMvJ/wyondo6VNZXZOL2OTsgxi0U2sNF3d0vtvMib0yWg7eCNhCUcgnBxb+Br/DEYB5NyciwVqwLlAu2r7PUrGbmMdw8HKO4eG38er7+uePeinosLGcXKMYGH7EJNfn3/5KSwwLo8Nybw7If4jLeNE9PodQp+uWHz3eFnqquQQPbPLm+xCMGVO61vsj8ZgzrpFv04h0HLUYm4ivCJg6rPTAeyh79BgFp8huVo/HRotosVNxTYJ5CWJakViJU1nMf4mFJo4ZFG5764Zqi9iC4t6Ya1HKyjF/9jAYWOuyqEaAofMDYVryKxjo2l7nHHtSJSH1uumYn4Cx3zU1RqT1/6udmugDFxyfVpKnojDCg4O/m7nQqPRllzKTB1n3/4jZ5vB0uDR7h3lNeeX/hQ6isg+O2Z7JbGMmvIpOkeH7sU/ZK1Oa/BiDUZepYRnN01a8ga12O5nok5Dkim1ISp8Tzb9P5D302fui6hHw/PpRsz8sHORCy1ddCwnmzt1b5o3AoWCKMi5JqE9XaJw6YUP7HfEkjkgHPZRDZ+4DQafkl7649GyF98N7+vRM3dZ/grSHsS0dhL7Y71AvDq5O4WzdHE/4+OrC+kkCB5OKMoCPJd7qFnpBfI166NLIaBsQ41WySeT5y8G27PAvNqIu3OhydYS+q9oYpuQbW1lK7lgfoxdV/BG/bGRUi6x0bKylSKkilVX9wXqkALLHpZrSAmh4IdpNlCQkjQeFTVZRQe1nVL2TkKuMRYgQRRP+O1tKq6GIfXMIeWnv66nyd3wu15Tykd4JRuVcD+8w193bypBYkxmtCGd3qHweBihUtzt/pZM48sW/VyI2m19JuGXxV1L00DXsmy1F1KblpYHtEsXX3AWUPv7N1QKqN3W6a0xAVzoG7lhVUTKxhy4vTlHAjqq11geIAole9BLocSggSaBRsU824V3SKpers4HaOmycTh97YfThxrWcI73T5DkwdDer/g8VbXgdiN5BFLaHLY8GC4myqRAniSYSO9Y/nWcBuUxrrWcfg9FukDCsIsEuHmIi3hQ2balB6SI17ji7KPC8SUqWPRJnGt9LyaLqA1iC8PeRyZ11yS8UMeLQakKU8fL+hSTl4XSSnA4SCJcZvZGWUBgW9DyMt7QziERyrEanJCLqpGEsYCFqoJIJSp33atEhdn8WEerDn7mWMkqhSZBnX0awnqoTbMZps6Vp3qZyl5VXR7J92HY9Sq4X5oOJpeHnODE4fVxl8XSgn1xXrZBaMZ5qvEej7LMqfBnS3nd8cg8JturI/UEx0uG3LJ56aUgkEj/l7Uv5zPHjSi7tsMGXAjO2X2wTmhzKgXn0pXUQiwSDu0RcdaY46TJ1EnGgDdQQZVcmXi1iJ2URl5+UK4HQN46Nc98Nrs5MACxgMnlnmwotEUezznI854l4+3TQLGqhYudVsZ9cizNkr/5hbX+166JK4LG2NOdkURzJJyE75cCwaUjjFktvPmSpKuc990DMzfwD/GY684tmJM4Aw9SLSrwXbqZD2bKPra800N/X1tB5vUzQkdx/7hdXdAvEezBFk+tgRbYZPmSgRE1z2R5dW4GO9RwXq031I+86OdJz/t7Zs376C+PpO3YpH7R8u8izdCXoEpbaFtwOvjz8Of1NDzpg+fX3jRVD8l3vxROAgUk1816VMTOpICdIuxb2AG4PJ/XCKWiiBu3iFjg6MoaEVeBzoEJ1RBQZQkSqGIU792/Db6DIjOhfWGlHscbLClb36iZEfPpargpBecFDCPGp9fr+d2DGPp3Xmu5skKsRgjlbPMr2S0bkVuc7q+vnh18uYyWgjkAjkXTFlm3AddDmgZ4TpCjnHDd8916K8HFPIlqiJZ4LDZt3YA+TvvRo09KQC0dV4Jh2I+6BgU4KSDqvEQFzbKFVU62oUIx8S9T8fftzfK+lYx2UuXDKWfRbtSFL22zMjr9sa/hjgFuXhnE4cEQx3+/wRo07i03y5UwUlAE3eMPOg5pj/18QF/qYqIF7T1Lkm+d1RsS7OND5ll0mP1RmrqopZRzXPsULAsqXfZVC3D+cMXp/QS+p+YYzbaoH5U81QNIf4cZtgTSUgXrjirewLNJh9WiECZxvsRT4YGE7yXqfNz55eOyL71LA5RxTAFInUF32fYmTJPAtU/MXiZeSDofqEZfr/raFsTV5CPScGq7MtEDMdOGWBEbwub9LjAQhbiqwKJQjYMNdKILIBkcuFpY1GqARSY5n12RPaKwvj9ryO/CyXv/7xskwbgOATUT/6M7NXcZHU2jgPKp7BAk/N2X3jzLuWLhWDy2IIomxj+N+ESOcL0aK1C9xtuLaThREmw2WHfMLc0RjqxA/75GsmAUL0ThppAFTvPvQhKqJBDmMchF6+EGmMTz8qedOTUzNTh/+EPCKXQ/oCMKVCRhg+9EZKKWdrE4XY4o9nNQi/su7CeIvjVPvzZwlhU/fHdhte+8FURSjY68ArGGFXDv/pqgCSMOAPAoNnlbCbzpQyAfWxHdIWjOdEJ85YYUxc4b58F2Z8FX3LR7aYCtGtKRLiVW2T2tacxB4DGwrTSPupWCjZpOv1Gipv5IFcRXzfl7Vgh/XoO6dexSIDaXaPYjevxHCKgZMeZ9yuafkQ1IjuwAyCOLBu+8Jzx1jwTY0ayhyRmE2eQyVWgOx7bhNM9XDYzgE6cqbPqBHC+t7DTiq73+uk+uDVblcs03ky2GovnaHhbVk0H3BirF4nPjfHq0w71xhLexCxPLft+8V9F4GPAvWMlIDNO9cDygMjSHxHPaj6nIGLMcVekKkO2e0qIIOQjF65xPbZpsa73JvVCu0J7M+mMM0F9ufuhi94+FmwO1aHc/VchNAXyZKqxWLSg/6GGUSM11zqkmh/IEplkzR1TNBFjypKU1fEjAz4+RQ4juAB7njfoelWR8EWCc2JDPH/LvbEZ77FTfMHvhzYRsxXaAVClTZylt5HzJi+go2u8bMQ8R5D47TI/zsA1UC3jzx3lyNttQEIuBXBg7+YBR8e/cLSbLgjYNkdRMhlcLQq5vXHBmG5T6Upjl1WCYsffOF1Ncw0+bNBW61JsDVCLf8ZpysISNzpzqLyYfDS7uHZbXD/DfwGriwX1FSPnuaN9AUZqMIdNpYk2vvUgaVoJUPWYTbw6CnX9KiUXWtZAmkyN8YcBezfNq+dMb79QIw5n7WXcc42YXb1NWz7u6DmND9rWuhzqqrO1h2uMPMMX5QnkB1B2NHHBrj978nHOPYt6cIUBamQE0Uo3z2Yl4g50MgC+MHwUN4Bw71SnbPI2Bs9s5qhwWo/FdmATfvyCZwIXB7MYLnO9T0lTldqWFHSlYdGrocAPCYLgFHOc1InC+l4PD6d3i3Z0u+ldpFuk33Ygw4OKIEhFiFMdriure9F08FD7NTC+KGPY3pToFfw206DgGJn9BFCzPhhdH3scLg8xI4HFkJc9MfNnVA16VgGOhFZ+FloHb6hRrMMjrKoxOoKB9B4I1Ksy1IdHLCaVDkE4xGmWnQzrUtP/dGobzaalGAbTXSmm89hqCaRtbb6g0athmh4WDtDFyUuxQaqYvM2iaLZhGRxCX9+AGNzCZLqMRF5TW5B4YlwhOa9VHj+X9tdNLqzmvtfzqoVH8gtWl+8bf/5w8+nx4klf56hWbEmP2fIxCFawYb88KIADzkA4PaRjMe7BwgeBKfLg6I5L/SaQWynVFsFHlI6qwKdlwgeG12whcFh92z5aVrx3Bp1olf80BUkEYcjm3oOT2zZuWb8IOI23X0JV48amY+t2H4xk5uTAAV4NfBJ6J3GWsptire20N5vYWd4/SUVtfm905hOAnwE7cQmc6AbRX5KyGjsT7Lj6b1UKJYTf4Ml521Ww3vG/5Sn2XmV/VzOcJdDwy9inyHaFSQ/f/jZYsk5hpEQ8ik7DZZ0zeLAyxFZ4pT+OkSJwHVZu34ihPJWsjoe0fZz/wuuMbh5e2KWshFWTOohA/Xi+L6QCaCnrbVrv6GGyLHgd1mXY3u769pRg/cEaPfWR2V3woLpxq58f61XFCxVy/Zsq62E1ZrM7JUnPIhg0Nt6DHqba0Jqca2XeOzixc635VrqM36uDjynZ/kN3Dl6GwOUgKbhlkUSHx3FwJxrAR5mkyKJS0ihEtONGMCKU6HTDmEjs9vhixBGG0ynwL7TQAfWDKXcFJ/tebEQnZCTrtUNgAAxvhgcBosIswsEg4KyGOOv3Ew8udVMHmNWugTxnCnWq90mBMN1dFuxxz7E2aKH2hRI5Zugh5gH+pI+YbG6mkLzBBLj8cMvq05zHigvEHch3sSrLiJ/YgZIIyx5jvnEsbuJW7Q9ByeIK1VMx0XN5UZxPEVIFBh9AJdZIi2cifuobvNzo/TDAXIdw50o2BNzaEPdOS1ReCw26fL7x53dn6lhtGSW2NwfZMsgNCFTxsg9koTZ77fUkeNsgRBTt8Uxb3He9i/cFIVBpg3DX3cKkT/akkETAcCC/8Hd7pvKQxtckuUnVBhkLlUAVS6vYXedvQq3Z8hWvMQfTEoQZs7LhGZCIjcRCz2cTVfkjSTq7gs5VBNGIQ6vyAJkd/XLxjARQCcYxu8oXBIePb2aNSuoGe3YfJsUYLP55hYGcAznRZENCxeiRw7qwCsbEv0xguMVqqZNoe1K7O/7OOxj+/eKSOR07P3rgGMuS22upl2YiF362MhZrMhxciu8YyMu67AVhUM2r1I8jnVIPAsxKviveUH69LJSGG7Qf6ipHZFtsjlzaNokNDssnTwNiOXwPDI0/MdWyKvSayqHi3GqXru3BetmMs99BtnSdRlvnYxpz57i9/k0KAt6hPRca60Cn/T8IK4RZnjgdy1rHGUhZh5DXiizLXt3dOwJanvO5vexPVtkxce1t57v67NFz8taFiuu3079XSTt/oQoMyRKh/2Jc1+VHqBPyoRlZAPuiCWt+qkokPPOVA9CAsvc5GVCY5wfDL+VDSeTgjTxbes5WI8GsCgjog2O6RtsZjFdkzuhhvKDOEfCiCw383dw5gZvh4G1XSRyxkJTS/zvjIOh+RB8Fi/txug1adhipupRTM8XQj0GF4lOP8hCVFPZX28GNTq8oTTsDmSpDseFEneVmH8724d5wCrlBooH2qhLoNQU5h2qOARFdGmj77K8c4peJe1k5DWqcfQFsPWjXEOOi1okQ6rXvvEBsPqGK2PtwMxY50vjIFLxnrsJI21sz9Wdgxcax8aaqgZ3Qo1VWSuKstee5VJZlxhSMaGY0N3gCLhpk2wZgBcT/NIQMM3itSugc7+qcbynj9ZHw5n1oNP1RDo/sNrGDKYahxS/o3xS7neRtBDcVjYlVJotfNgdm+L67GxFAh8WjlLo1BMYmNX3zm2AfAOoSLKnDFEcg+W9CKtRO8+SYQzPutWLnAXc8HBaEE8C/abqPV+bK/adPizjQ5wXt7HUUIwjHxQpVjtSG6SOp0mH78g5tt13Vb9KGErekXgdUP7oVHS9s1DErOMmHkchL4Z7PPAUbjSJPKMzv9CsL2kQWpHf3075WxgKJUQWPVMByg4u4r0R6d7SJYzskTGVqGq/wZBz5DPub155M2CaDs/4xYjWsBMjRhuZ+rzEL2iLIJZXDm+CFAreRM7utIXBZTa2DbeU7dm0cwJH/ppQYx3jqWKSijIyxH27xv9Rir5XsCd0P9Vc1fFi3x19mMjyECxgMToatsdHXWKW0gFuBaZUn/j3CLRg6jZBEdd3J3fxEcWOven6CEQVSEP2STUbat8AmD/FGi4eHbb25E2CfoKDJGi5DIwpCOJpjv/jDnyZyjdYBWUP7R5g5VqOEdQY+V0UHehrSvS0BjFUVnyQEZoU8lwt2jN44sLXdXc0mzK3Yl0c23EtDs24r9LHDvz1Il1Z9kI8UlpmWGWlocOK2hilgozbY6ZluhFtR4PWRTPYa6YubiWTthcilveR8fRWrgHcrNcF3x9Nbu6l7gqLWea5BQTXww25vMG9olRhhQWVQbjVc+uNdO44IEqdVh5g9OreNTA+LfJlnrbpvXswi1NZXzCV/HbtkiCYyW0FmO4oxBXecKWwUALeLkJ3Fowss+lSlYLYEm8Lcw/iPsbGBis9IxAW1Sk95+4ZOSyEVn9yLlXSXRi+2aVuJmQn0w16EUW220oiFjVIIXXje9XBOd590po0LuRrQKOJtxKWvslpFeefjJhSgZWEZ0xKj9Ml3Tvjn5Juv0WBkQ9jr18bYUg78yeDB6jwH8/MPzp2sfGGMWGHuQvAIjGfnI8uHfUwbcD2RMUYnpkTsArMNpQKqVYamaUXHEuoQHcU5Xh210KqHIEv04zIT3vykxDPsPjCwJEIxQLteopcLw6OyKyjPoW+BpQqtBFKRo5PHmDM/9vVNuxhvHQlPSFIQiJMmn95R2QrNFxG2kaN9lqabJiPTTGn3LQPtQpqFx9w/zFnS/VUMyZgaPhwBh1MVoHrRb2EFW1AoEd6HP1r5ps6gikus8I4G6IR+hMYDwaXHM0QPkCI4mutDBBmDdlxCywe8gdgZbzslqNeMuVlm2tlk9jF7g5U33qmX/A3Jbz5RluZAk3ZDYpaCpJwZzPETwEOaKLfzXMOSlW2hBW2yTlkCLZuN1prKf6q6Yszcbh9GwnjFRZbCf1a9csLVD36T9hbUpByNj2t4ALaKWKunDRgjCwUct0LxjbhlW1UhfIDLqS4a8yL1EGGzsQd1908ntoxsUvwPpieHvEJKpxD/klYCcjzd/S9rtUE+SIg3KzH7tzbZb/afbrH1IX3SW52jQUtL6Go3EbiSq4cjoj2Qpj3kne8DNo/d+ETFVFuawsthFKuiJn7ofefFp9hDSL5141mdCuHrLsspMTRuNtTf1iRAkfecCjHiPQ5TdlA9041+hGDqcRY+rYGuk2/GAh9W5LkcQixmdY6YKBZUyyw0P23bon7iPKTkrJ5U78bfBE5w+ZPE8cAFViLAIHcOrDhpU1k2A9Dj7sz6CjueWZ3R/RlPuiO/niX1BPw82p0wL658Yaw+Gws5HmCSSvL39jokI2tezMg74KPtZKPR1PNA2GQYCdQy/dWCUK3qRDAAe93XZX2LQZG1xc+cnHpK/bTGqZu55BfX7sggsHM0zgOc/WNOvkqmosIyloeSX31tvsl5jBcFaXdNgTaK4K6U5YniDLoEy7KeP9HNbqPI7eHB3wbaaki/HF3STvy+pfdtkyAnN7JOCZ3nv8Z8Q6RTh2h6LEN6efYfQWYVnSCnrRLajLp2RzYLeSJQ7j1J28mU7Xe8eqFfs7dexGuGSjwdybMd1b3LeNrlLSTGnIoMAvHoCXG/x1H8rDPfB3X8m3xU0xLAX5D34yydWKYl29TcYD0mXZ0O13JHGGuZXk/xTUrvU1UypdyUmpn2R1BGvitncAM0SIhD8hwbVwikoH711+GI4G9FJKF4hkfuc4osUj5Sjh6oTeWTmKfuCfY9gEy6ZY7P1Pd6Dy2vCH7GrDsN0P3LKxRUnajYAjoYvsT1kKLZcFO30VL7u2lX57O2FXDrW1VElh5eDxpxn6w9OUgPJ3kJ6Q3tQrBN/GKFH/wF18iMoBEYP/Ue8YRf0R1Fjc7g4BDqCgLIL3S8M4GMK0J6ckTkxJYfkhQPOkovPgpMeUlR9Dlr13oh5MeL3SjIKHgums+iwS8vam768wq1UEaiBo0/jBQUrdiq4iUElIXFAEnUPE5GxoDQZGFMrV2YfmRmhizK/5yDNpbFWhLvZe2qV8gdUbgzyBvUwkj9vcyYskaAGd2tbAcXF5VksJ2O6dwBpE126Z+1f7ogv3bIuYaBcypOtz8b+g4F17tIXFRONjmLqReAEdkODysiZx2x5KksfTY0YcZyjnxQixYPpvAnZ/Ymznrd1Pa9YIAW40/s3qWq6/PjMuu4ZzpAZOBqNhZ0pB1Z7uNs/65v7pJrWSqYNuWyJgzeNxhGDtVWc06N5y7AuELj9WkDqOGMbR8Cs4CmG/NVEtDNH0ot+u8xJUD0Vej6mZO5xljNx2VvOM7TFOryJkwVTUc53J0uFda8BasYUlQh7PCPQQzBXtOfvfhOYD7dwRG6h03tM+E8C7WSGKptNeX3+m9YU1CZbPbgHVDYf6MoinKpw3gLaOIw/PliEUFCqSaXns9vztOcYUDUU8FR3nC/BCFxXEtjZG1s2imtfgoBu0FJPCATFP2LHnS2sdDLM3e7Cbwu188BFYNyR0/Sl2uWLbBk4xRfSSO0miTdkniV6Ye2v5x7OoExrZP0Iu+zF0S2rnOgBSTiW+iDmJGI+HFrJOO1MLGEYsLwhGdr+rwQa77XrUvf7ag+JKssGY4gphtNP1QcVNUL9LK4yGU4+leMR0ZOmlj9CPYSFXPZGz67wSJsy6NbctNV982sOaogG+lsLY9NUNq/6V9ZZxvEyBTKxiKDgAY78/NMqs6k6XtTlZy5zGlHsxOMFcKEuNGEkxTH5cK8TK5wY7HTOwRPpXvfavUm1M+q/7BnCy5dZ+ryHI9FWtvy3VT2xMyiGOTimYYJTST8gnuH21G4qmGBNw0NAKW1cOx7pKHJ42V3JY494yDYqzdZExgeOQ0UmDIEBQqZHjLu5I0l+qlKUkEbpE4HjUy/FlGXHVWAMVM5hWk2ts9inKjCQlu/cu/sxoUEwBFMOk9B4Cn5HckmwI8K+oX0w+Wb3snEQ04isOs1w4e3wDOY6DUJJrG9ZzkUFWteFYgV/P6lFFAbER6pXPmjnjJ1+b4zjmMXtLHBZ7O2mXpi+5TP3ZCGSfWsYBNIZiAyKz6eImASUgWqglfhkCSVeH+7529V+4BQlIPePga/uS8e23mOvBFC+OfwNFqV1XAgRzDVob14C9T8u3y/u3WBQfsDhyhKF8I/a94uc5SQYcGFl0LA4XGSGX5pZVcWNYKpsiIf65BCh4taygyQTp+HbSZYg6ja6VriTqiRnwWNHzITsxyw5D5OgAfMAPDeHO1DtsOFqxaF8gecxXVrzXk0gbgsMfBYO1y8Uk3PZS5bhnGX6jgjsI/Lo4+hOigCERes1daXiuwEsVNHqX0hwF8vi+vhENtAgGBw1bRNQlN+4G9u/NHddQF26PApC5rdOoJqnX7hpwqNRF4Bm2DmoXt/6X1flGfNLm42+SAEUhgQLK2+YmjgjPK9JaDETTs61ywbPKRA/IbGzwSdENKAiV+Qp0VqLF0J4mBjbcv+veetKC0nhtxG4mqQuJvCNGE0X6/8/KxugJnaoUdBj9KpMvBFReZ9oQ+uYcLeofLN6rnCeGV8uETM/x6N9VXf9uWtnVRhyOJq5CCeoAfHG5w8Zyu62O+J9bfHIUJJx3Wjyq50Q22Fg8YdGQpV5CudwW03O82L9+qXLqxOa92CB70wYJHY54yfkvvgCF8LxCDQlkA0BI7mIgRx3egbkmxOc3LyDqdvr1WM5TosMCbmqnQdBP/9xYHZGBvls9E3kraB2+sWn2FWxCzNVN03BKN0ALFm+MhSK7+l8d/cA2XKZM06MX6l6UP5/ES5rwgyJoV/vCsHfgjp3fraCrAW92NQRP0i4GAe39yt/U8krDr9zpqPonKas+AoX/2mbEhCnjpuvzNMCUGMx+7GiTR8zdH7ohnRdp13/vQuQfAc3uHHBd0RR1oJtwTEucCgRXV9DJ5uv8ozU5DKtmoPCUh+Y5/csR/mj/YC2+61kkpwrnQr7Edy4C6ZV2kEumov4T0WvMLeu0MJKzCwsSULmwh1wODuCiJjR9+Nd9JMazZ+3cXzLtBXgDwqISPPqk/3EG9u6ajNvwc9LC1N00em0fX1Z7sqdqsdYQ9eHuEa/bRIaCNJOJusSr6uS3h7v4qKSuh8r9SDJxS9gaagOOrel5VSm+NQDnJ3vxnEwFQ2EVGTf+TE47PS8CKHMq+rWph4UUN7d52ygsuMs++e9pMbkYZn6/yuSlVhWP7fgxvmZeYgeZfq+tgn9EstlFPnlXpn0mPkw6kQQGUTrOeMdo50lsAvBNoPSegF/X/OaYfKkX9tT93B6uW2t/v29y3lkKTrUJjscd4iUeZ4GRPKc3fwdFLHOcKD1f75zxOWOxDWNTuw4jNydyCZtZr5osG9PGmFNWpnsE1+S+TfbRnQD+oC1x6dKS3dfwpAhOxh3s5M12ATHSd1BUdbl6o2Ru4bzpesZWO68fPtt6IFh3cRxcP+Ve9y+kseAMDMPsYWwTQ+PYK7Gg3kmP6Sp6mpmy5QaLX2oWhmVUhy1RddgUEjAR0oZemRkyvqCv0g51Z6G2vKqWaOKA45Rlx+0n+AIFbE5sslvh/tqJDLihNVlFSiYVqb5sqSh2fxXYzLu4iAYmDNLHiftxPX1j7IpiJPpGfJrMg4TCwGu8h/Zo7g/sNo/MHbSy3qIEX5WQEOV21sz0wClKr5gRp31IybkauII+iohdbVeQGN5T59SvAT1M6It20rY0NEKBiQy1MHOithFHkLYGSj170B1ElGEqFB/VAJZgLpKTPoHTakvBZHophl86XviYOFZn0aLmI7qIXs/9TdgUbpYoaQroDI8O3F+OkotXVasoug4IYY1/dPG93rfjbnfHemaL6mm6W3RekKOnCjoVltfmvd/FAFlb930ob+7q4k3bPBYmkxgpVNDWBgMw9D99OcTLIYCYQjGrfJeDzdX6uWq+pZfj71qHTBlbeoOfwDXpQ4p3zPiao4Z3XpZmbNMRw8YcfLe7KV2705W1vpF+SfTQGVxP0/a8+roFnKThiAnLck9ofEt1CglwqbqiigvA1YJEKItyGQIJ5k23U4Br7pntPhUskhCx9eVTLzOGLSh6SBtKQsBn2BofAyCZk8ORniQnrYg/F1F+8pHN2ZD5L8xmEWFzDKcm54eKC3pkiKQ5Z2/cnkVGTxExODeuizlnKG7TXD3htwyViTGuBtY+VFhHcARaJcOraeEOBgYRPhtJu/oOsIlzJ3M5tFX9gHQ3nN6ks0kJFtens5MF9sQKHU6EC9sC0QSz2aWGFlgJQ04oUcL2ZP095ZWakVmIUBYhTXpd/KXdBgiiNehROTJw4dkksUoYqUyqdNsBb4v/IJ1gG9YtbInoWCaBXAHRKMzv5So96FBdbZYJlbF+nK072XccoE52JQfE4D2VvZDsFW8s3aFPddpVXMNFuFcpYpLFkFrhYBAHFNFiDVYetDpqoZaNc7ZTfMNVygN1+RoYDZibtHjSUV2s+Mua5Y7kRd2eEhjS21RumtxnmdGudm20eggoB9/ALoHV5hu2UN8gLEJKzDjG8vsUh79AwwUmMVyH+WeE/iZfug4EibZ38g8OtTgKWcvVf1W/3z++3qiVihmeCBYjW8Gkb/MH4WeTF7NPIveeS6a00H9w/duz6HDVtpL8E+ij6FWk7gycDSaxfslTJADk29iEdMCnsBKfP9ivl1WXcwso+az+uiLvXIAP2XkMuotdLGVAfxkdWrlWZ3I2pV/+zVFZTsEGsdtcu0LqkPWJzh9ZT34RQDQbHyWA8QULWMVA8L59TgE5piGJ064pZyMvRC+WOfLqFyCB5afp2IBTOz1ndj0AF2xcHQgnUpD7PsGNZJAXKHxZw9kVm/sobuXjHi5vl2idvYE1z32zNlmnGMPqR/TRhw7FrWwE4kjWa5pRbjOc1SqLaCsRJWLZt6jGc6xWSeznI0SVg07eA1lZIxLsaLuFCqFzmumugxrDk6+fH7qJfwzEjHvhjcB1xCmrJY3+iH2YbnY+vU5XwREiWeUpyhjfeJIkh4AJ1YMAph/vynbr0bqk3h9bQ3fmltbzwXM2yZKiYLZgcOUMfhm/TNQEybaHgQYlZu2qtGDsn2b4ptwI5eX32xUmDeCfIsYbexLGmDQY3nH0kvbfiviMrxM/U1sQI80iI414VNWhkWYWKyzP9fQL+eRzPYamlk47Lef143PvOCJ73vaBHn/kArPlxPP8eu916CXGE3ycKihonGjQ6uyjhNw7rFjD6q14b+O0hfSsV2XTmXEbb+IeHdsEEHeFqTL3HX8VXG+DnQXpVb4oQ9MSMXxE3BkKc8WG3kLZAkhgjBh6YfU91St4Cb/auItoKkWPVwlhytGZnLRMU+kcZBrtXdQBClwELOuylNyL6k3UAFWSB8rCJjfmXvXmc1IwqNpXyhhPotXx2+tpTC7aobjQyuV5tXqqPXAJ/5T/AR9GO9AXO5iQ17LacCb5cCMhZydKYscGPqMySyFCbqOjHL2jK3cIg6RahEcRSH/qhCBYv+up0JFXk93V090aRML8X0ARJ6ocQKHJXXT59CQrKAYcIRhkF3OB6VHNCnQXKyY0/aLyO6d7supZEXo8+24MS3uEvFl5aAEv0saZjPprx8vnqBAlSBg+oOX/HiX5MnNuISL56/AKUpCWEd2JH/z3oKtmNQsbqjt60/eGmPZmqXPsi3hXQkBNstCL4WC+9eDTx9XnXnrcZI9scdZJNRD9Jq6qqb0D10DVUmYYfCAM5ndoh9HyKFbKyQTlyTJ2gbNbKxTPZqk1ghhYwSPh6J811RGSm5wHuR0oy1cihvKKWg3xy2h3+NLI5+IdJioE/MEAf70jLIDVTdJ84U1hvRlFcEm3UPzKJmcr0KlJMtNu/SC3cY3vN7cMSC3qYRHhrjCeKMhGMHnaTeLoBn2oC4c/ZsdnsjSP0MQf+HzUnjVeS0Ou+c4rlaNv4gZJx1CwwIXK96z2PZ9XHZXXW+Ie5qIfZbIpgQAFZ6a8IXZDsHpTGLCfBkgPmXyOQctqwvQofk94w9xaLD07/6CKEb/QVoAYB+4hlvLTDn8lqcn3h439rWuR0ItCEmEUNF4C89fzfuW4aJd+mlCQ9gpuj/7tBV/mQ4YGS5a3xnaH09Yyj9cjGtdv9o41nY+mQxmoUeoqT+p4gVaUE104hb7eoYiH65HJ6kcSRgkXRAwCxPvkcSpoKj3kbEXZEfbvnPpYEfewJbQMU852Wyy9Ti+Zjp2zSlH8Ea/TLxHaGUAjL+2CWBXpBiTwxnlTR7Lt+SEyZ5H2WhjkXNSLdRJmDgleS+hRK/rZdPI/i/nxuJJ7vsUB3CBvDsX2U4tb32Swx9TlERZiyBhdx/K9yxhbJM5m6+uqCqDWnEWKN1c/3q9OXXtumSWVufmHs5L3DcrphsaZiUyWHgAbmks5caPKaQ8012L2bpsBxNmEQ39IRqzph0sjKqISxT77X6uD8Aswas6KVz6Fbp3mU/vjHldzNS9OLdr38XbkI4ccrlnVnBrZz2HKqAh/z4YI4HNj+mrasM9SjrIvhPE4+ODEfid3zbGq1pgsGc/5ac6XzDurNZUBqZ/PjWnyz6gfHB3+nORqPhhHfOM38fXEW/Na0vqblHxR9Ji9K45TB/imdPcbrVZs+lLoSjTnNvl3DA2EaHGYExWn82WzoVfzHLM5kBbBuUzBj98UGOrhgUHz1BnbDu21m1GrWsa/ta9W85D7YevJpDdBWj54oaBJtDLlfsiC/IXKINM7d0tUu099Yd02nkRZJ6bd5RKVrucddiAfoMZzUxr2q1Y2/gvEDPoqUTM39zcbiEBa6nBOyoQg0izpt/gKVjWcon6jkKeCAAQaYZdffClwDLBZoqLZmDUxWu4jqeDajSP5i8uklqfSLhwW+ZhnScpTP/hGZO5WzrNlnTZwroqCQzHFrYbPJP3pzoWsRCeut9rOdR9FNJcuGz4FBCXFwWBQQX7GG5lnDLO1J0zdmLQwtEKCemBmdlljuK9iLmdm52v1Wksqi5tIoEEdJSKhJjuvkP3JL+3bwh8SX3DbrAaeBeIlZkXPPzTwb9w1FrYUa79/rgRlClJzdm9o7eYFZoJmMws/nwlohNTTUChdDTyGs5OPQdn9N6QOnrisZaUWz3pJNmzQo2imvuOpAQnHcNVH9bAwu2ARQIuYyeJs/wzNHvYAhOitd09UH6U1Aaj5E3uYYkCHM9+yEnzRjDNMaHoSUgO3g89F9f5x9Hxy/5sbYqbJJyUM7GGixdhLzd9q3yNreBvqFdO7jq8uz0KgpDWZiWvXDtPiygSRpFqR/iDq7HA30Np/P+AV7KIxnA+2l+UG4FUvSRduIpYRJReKqzUTFriHyqfDyDSHQ/yya2alhBAGZgGDtfAygJn60y4dpZvyKMd0TlsJJ5Le3oJf2CHO+ytw4b1TUtBmgiUGNoGRd18C51tLV8veaczA00j1WWtoULFwrz96rEJ3IeBOJX2VwO7FS0Zb7Bbh//g1tjDUp6thxLzXpOWPOah1uyv0TdfoNiIF/B10Fkgz2XCR+1Pnx7r0asufFlgjzW6uxKNthTQlp+hAk/p2883NhRjNty/lEK3WItMVTEl4Uhg+IHUv1AJcCD5ITKqVeED2ANl4VsvGKofbAKVFJURyhbEiDnpLjw87ZODkuYrbTKfYMVhIaDCwx+JO/73fUJ6JdM/mrd3uhQFhF4cjY1p/vypsQWM33uHysBGxun+5+/0LpKc8gzsj60KTHwxxV9tvOFIRDNz9JvKo5De3/aGY0mmWUVrM7gCyhjVBh4Jjhpfij2tWDEtuDS8tPHvRr6BjjYUGFR+YOXnM1hJqxg2b6IxOAxtydhP4brnFc4xMsNZbCLGdCiq7X51ypltcztpQ2MWgeKa/T9ndFgNMdzI7tFTLuZL27I+d/f+g0MIPWOJnvbIAIIKe7dD8NUO8GoDxgZdLInKOIRkU8KyjQpGt0gR3CHw3ypH9NFii3n4PaeeJPm3AmriVpom2qPUDrVUL2cIZNUJA6u5wrpMs6KoH3GrZO4wVqr0SHSalVCirGhqan6ULy2k9Zu/io2f1hFKTkUNN19iCR06nhicWN+7NlZJ9gYKtzrxv3mK4P/qsHpRMyeK/y5Nen0PbHJ22spXhxpx5NjQV4fIz91bgwdCf+XVHXryLn9h5h66pxvBhmdZhWVkIaRQ3fI/sNENFBkXmCE67eQnbnAWWF8kKhkSskdvPyi4+0SWddKGW8naii1TMzKS68nVBhd0Cr33bJky99e5diOJWjjrYrN79Vt44bDQr6hggprRzcKm4ldtLhOUjQ8ikYX/BMchkTP2KQAoWA653Wj762553snmpfWaxGmI+Jaf2/KTpmA7MJxQJaW9lRt1eBTn7XXtPwSSeDZxYD0Bmn1QghClxGNOoNrNzYpAndkFkAKlFEKlJGsaUDnMMQnOJ3PR/uu/HKvkYY/ENIuVhb1sSYDUU5dOAo+8qsJ7Cf4hR0uXGHs8giKFNygyK9UANSrRrp6124h6kPtmICw1Xa0vToYbrW6lAvnqVtjKgr9G+8RDP/ITVCSJE8jAyDFT7vCXgYG/SCTD/Jnkx72xtxKbx7LxXrRd6fJOF31Ci7mB0OtF1ZSKlKlkuWE0WYh6PtZ3SaxYw900IDm4sdlbRgDySZs/taqv1FY1UYGPr0DIM3H7E7rH6+Sge97N36rJVit7v3qm1RsVjQb09Z70Yh0WoTorqAnANY6gNX+rRGrxZMt22zW+35cePXdFUsN1lXvLfLqduJmLcE+oxg8+qa2Sb33p9YJlWfN8eTh/wunq+tB/YZraIV1KjsPMXFUeCoNWRPclrun9gJ0Gv5nRlhQ6OkYkHutxJnbw1bP9XhSeTbRsGxk5C8ATn3V4J9v7X27h2DqAKB68+oxMxtADnJXplYNvAVj6BYOFAezmvq31v5qo+VD17rpsQZnD5pd3bQZh0AHkmj+2cATvBTwYwiAseqcnUxxPjQwxi2QgPz4Ehqz41D63pOhsKew0awKphPcY0aBaCbqNPe5pGH1BK3LPAovJ/mh76vwfgIG9VAPXv8p5R9z6ZLovYqbWj4+tYjOSu/WrTTckSH6de/WOEyJIKo8UtxeI8aQc5zWGtYInW6dfoatIEiUEVyF3sFkof8GETtguXR2X9Xvsy2qrbyfrjFF6jN4Q24BT+eSgShY7QONnYb2pm9WWoo37R/uFrfQhjtYVG4OnhqoPqGnDjW4nUc6EBp2vi5eGZTnKOqXsmevNlWl4LyzlPaTyM8A0P6RWNe0bBhIBdtWYdWR7BWwto0PVMULQ/+GuliuYhqjmpSvMiEAOhf121GO3x4DWKDPvyTbqdO6p6SBmlQAyhwLPJNTf8P4sQAigH4/vCYlThinhy7BhECHJAdFBKXGetK1Q51FWlJVMq/kihkHQDO5ai/cYzQ7caVqoHUVgUj18+k4hjv18H/i2nnGT8P8ttCEVC5imNS+npDA28bx9ze/ncAv+JdKaadFrTq7pErA+X9k8KBWzGhS4IKZQoGnoQKMqYttdJJe/4R9zSObTdE74Ri7Ek7MzzH+TPaprLdIcXBdleVFbCBkK9n5FcFK1XrxPsHPt6vUTThcT2vh0se4aVVkpAADdtoEK95vChK9gMQf2KKluXomaEgvcpqQHCeGE8Xg1MV0OXYgltqreWYFq4ALA4JqE3xrowdvRzBnxl2spfNhToiq17yiW0BewtG6RWaZhf67ZbLh8E9BpYqnEl71uqeI2VsY750XfSCgDmUiDwvNQD+2eoRKAiqZbp24ipUthk64LVgyAQmuRtEhYZVm7XfT5iQygO9JeW26/ibS+Oun7khmlPC8A4KHgi+Gi6F4oVAYdtq1seSrJg73pHub8z+a+BVOoQRDdhajjTUucGHgscODyuVSXCMA42umXvSSvKPYk+uNU2Dv4hHTqVCSDJf07jCOqsZFT5t5WNTpdEHJ93vXyDUThNlg8l7ODGNC61RnuS/KJglVvypOn0vg5v0abdWArxPbH76+PosH47GRYWbS6rDyIGVTLyIShvByzBQm87corg9NFInN63sBh+f0qLc/RrAjFqIUl3yvB7neK/A7Q4e8w7h0jwDwHkcU3PRsmObhF/eBKmIGxj54Yn2f+2rRlJv2CH69V1nbCmu50pXV6PF4+ZVUBJ37YwwfLrdR+vC8i1qgTn3eZS2zFv/jGsR0nA2yErRjOjuemA8+VJ383YquqIinYN/wA3mrfx1KY88qufk66iQhlrGsTCHXTvkG3or3laWC8eT2D44Ed4ba+dodxHzy6I6qZOarJYHkRkZEpVLDkGu3gr6W5cEsRL2PZa42zLzbh7fxfC2JPzk3BKNwc9mWl7ygPMYgv1XBIAUILTTx2xyn6NkOWjrPPIVF9WoK2qdYFR+rlQ0JfDN2AZLx6lKWey78ad/j+mIM3QXgjI7xItExYJyYQ70bfFZe8kO7goOmgcUwhv3qbn7frkk354vOIgKE7VxkLeaKIbwFA3wyebCbPM2FM4l7+r1aytFeNOF7o7cKl7FwoLvgkwbt3LRJ4G1pAaUh3zpa3w4L5drP0/fZnoqpLkUHMJMQoKPpR40bJJVJFJeo3z4VEsoqMUR3nGVYrH9hn0JOB59MAGBI5IxubaktxM3lRaA3XvSL5Ukk2pTNj9NEOx3PTLL1rituRv1r7KzDFFLEgrhKzVsD7GXDxvu+F1PHB5m1CLtxnLTrjlpjRYVE1Zuuslgxo+gtPXQhYEvGRMaM8gTXq3eqbMcdxXtoe3GDpPi5akseGAL/5MhGBAt15h6/HCseoiefwb6n0uqb76cDyHRWck/HLRRIFQK7aR1ZLGztxmXuwA8VGtStKXWR3L+5OghStarIa93ML8etUdayAoAE1IRKs4bZHXshJitWbWYmzIKTOIM8FtIjzMke2pow1/YEqSAH6/SLJ5XV3Mp35Y6K7d+A/tqRMlfLeAkCCAq09lzUsskYFoOUxEqJcjhkGM1EVGegkuColriuqHiXVg8HLqM+nUG5SGO3hXNGQL6z+sJUCipbBx/fOW9S3fInJBnyFkvK4jpXm7RX4Gqjv5jZGXVfTR7hhPqyxA0wPjXC9ESUvdHzcgqHRj5jAJf5P5PTUG3yoxsbrBenMqV4b+Ey6IpDPWrfMfb2UEPfjh0ydiM95Ts33WEeB3wQjFQb6n4pAjaD0D48GxOq5dDEkacLyxaYW3JGG/BLnWQWV+RpKytwcqPeJkOvk+GkJ3S4rBQXnn2vwUwNyjPY/j4WpoexUM99nfOAENZ4dxkiDX9HRpUbm3IfxX/tgCNP0cdIyj3PBCBOwkHEJBCFFTdKiYcdU4zurZbeFwnWLaCoTWWY/AEpY8H8FMqxtT65Uh1BGR/dkrqF5BH1y0CJUAzJLGwXFCZPnePa0eCdr4aOXU/sC64gfgRXd2Y0uppO8HE/0miOPbKg9334eY107DIyQV2nPSqmwajD5M7lcX2FPYPMzNHKrdS1hyYYiPjPtSdAjytddyVOGm8ldao/fCaFE4zaht+SCFSMSCyBlL+Ewu1EvDIwHHs58dqPOz7PfrQuQTJj1DLVWuSu2FYwqKfj0bBgv+l1y+XWoHnvIyQb63QbzEaFEYAhr6+YSPR0rmhnowjV6H+daihP15hOMxvH6eNYoc0LxUpYJOJmjlB6heMCv0GWfd8R4rlklbwV8vz+Jy4Z3v4Vv5FtDSPpSRxCybx2Fh4cWDm6J9H7NL5rlIKSLPgIp91qtdmC5r7klGQj6BPvoALO4mGz0Is9CLszVcdtVq+5jxNQVAkx1rlfVCfJlMcGnzTrUocrz0du2kOr93XKqxEy/6U5um+36EPuehFAdaTND4h4nLaDEvWjyLDuJaxLKXzjuHzZMGir/icjQYhqROViUC2xh1BiRAbfDYnok+IjBzewtx+uERp1Zq5Yuqs+eXmm7d9KeqQKhR7+VlbFddLmwVnpsQ/7TppqPKHbXfoujQgCRerQWZ2gs9VnDWi45vvomro6N873emgUloijJnol0Yr0I3+SN2WWjIn3iDXLeVzPmvv/8i38mqx+85CMq/UWDVqqVb2xrv8IBECKNQdYVzdixDJscFH11HG4TulnME51K4ZOKL+szgEP9T3FbIzujtT72sZxeVllH7yYEPNT45Ro80Nx02d/VLsem4BFt2Vebc//86ll1sQtapmpMHQs/rA+gFvNuhiDchEVNajbyfsX86/mNXSaRH8JclCSHaaoea9gk7QQyJZ4OtZwAodX+G0aAA/qlap+wFiq/83SFEiJZetdsHPTZa2WLB/lCvTG7d0CLu2wySn8oirgPy9+W5fcazPuyBfts4xXmeHfMxiNepzRdy2DvNulKro5DIditWArQcLPY6DSXMnj4WRo3Y3kXUOBNnwtZ9GghN9xw8V7jznZVtsGpUeV4KZg5H3lIwlaDTzgPELbKfYBGtTRqE5Smlhgu1j7ZcSCZiS4ecaYqYc2QALobCunMlJ+fiT2E9byqkkx1+/fA8v8DInXDBa64veAjr0wqA6rmFYsuBSPRFesnXGteF9gWDc+JEhjV9DJhdIPmDLVnpz5mGum78mIUxX04PZE0AoMeljRURZEyHISiK7+muRqy6Qmx0yw+LLGmw2J7iNmoKkzbJHyRK1iT2A5hMUhU29T0vQLbtShYx0qQsHhpJmVXVDX5Tv3DASnxjH8RRI0MhIX9OjLV39bIa4EEwQRlnqpINzZEqnlrEngUAmnUgLemsMSVk/F6BRLuzSEtEDEnIrIhkfR1jdbzdFv/JmgjwQyXNaI0TaIq/aE6i1xlGVWIHa5MN6hVK014UtDIuI6+f5vPmg4DdyoMy3bnLPnay++KGgeQ1YnPwPPNdwiaHiYKCcr0UblY92NEYvR5sCKKV/RCdrK1Rjl4hCWKYa3oJ7dmMDd+DTWSoNsbzzGTfB5J3KXn7UPoheESavnbPD5+Gyj6t60kJbJrcwhe6KtZwSuueTkG5x7mr6FK8kJhZKDZxChaiTdiyiJGRmUkYoVyWQ1QNd//ADVQZrtNB4dgmCDTj2Ne8CRX7nBFxUHXb+ntxY9+hsYXhrsH6IG4qTNvQR2FiKh1kcZYsQII3jmqsmQgpCf4m4yFIvnBnMYI/r0MmSPGx07CO2N0VwM8XEzePoTtPiwbICJSe4/bLF3q7NqfFwd27nTX/jnqiTIeUyElcgiZgGCJndT+i8JKVCssqpDGfDh84OSksL7eiS9MU+OucTSSUyj9i22oSxih6ChcmnwO9W2QWwfUhVm4N3PSrLVoEaua3MAfOjWf7hz8uucKdDR+pEKd6OtEpupkRrF+dEtKQ/+e02hMmq4x6w+vV+6ZXWgdLRlwBDMAGfJUrovdWuwZAiJ/2edyOuDXF24n6uQsWl6j9xlywLhs5qV3Kiq859fE5C9PaI+Y8YDwWh1Zs+rkEs4Q8SvmWMG66rnk+lzgtlk+NrQaX7rjrwOvRNfhJno3by0UjN7w/Ksdox2EMAbuiAPMj9y/MH1u71TPpxKmgnVC4G4t6gEL54j6027D81j4A97i1K61gBFjM/kN7oxH7RXHJo4R1+n0TUH91X1rOTuaib6pIX4aOUU4HQHsA1IkOYqWlr4Bp/C9lF8CHr/bPAsvKojFh5Vhq9IlP2d0dWW0jEfbzldTYY461HXMgtp0YgDs5eHB7XJgnXH/dTrO21xJJWNKeRTlTbTGUDDrt8ElLnmBzyB+xbVKLjvbOrQk3vIWQG2wyXMOHMjtx0nYcK6Tyo2MTmyOqywPJf1g9VM5zYCwiSMDZzZVZM1AApy3rIzpwGd1Dhd3srvFTJnKs6ScAq2EYaqKM4gIBMkSgls2i6GjUecLQyhEgDd0CwXGDvkPKLxzW8flY9oV3nsmzXwbqtT6ixRL9ztxUDWNCuksohY0lyng4kLXHvbJfYjhrMLXT++iRnibEC2AYv1KVz8AI4FhF9pVsn9COohMIY+XDg32yGiXo4lxrldLFTPkFS3wASv1FbsmrFZU2bQDf6muTvCVNCrexNN+yOGWdg54dKImRzVY57jAfAALCEOMmJcTtBLoDTNoqaq9Su3xvm3esfxtHAIDyBxgmYoW4DNBeNUAt04o1oGDYvnwqBh2pGHDN7CC1AAnbfS3aInCoVJ9V4RLdiCijh3XfxNb3IAT27V551Qq2rpgd+PmOOnveCAlLLrckGGyEtmn5kJUmObC6hh+xGGosxG0yRW/ideLjQeiCicM8FZDbVR0LAa2FHGfZVGuI6LFbmIBc746Sc6OL3+16o8kv1J7FGWZDXtFdutqe835sQOh6m9sTexl6Q+Gg2todYtdYb4+5OerlqG8QUR5HMK4vslvzZAkbdOAjRQeJ79mi1GamyVqGqG5bUeJxDcWyz6wglvObcLK7JSe2+eIjnSTgM6mUc22rpc0MUQC+rNZ9fNR7IUu+pU5SpCQa2NTZ+CQmjfDLCM5uP/RF+8n/CGkhN3R/2C4hRlhto7EuIWvwJUMYnNFfaMCqivhxmE2hcyN1L05uJAbQv2AMnZYSCcaU55sqK6ZKYzsxOiKYb+c0l2Zlrjsc4l3oIp0gT48KWiD3sVQn+mbRBNxOL39IlOoy4yKuAaYhFvoTPUpJUcrBKCg9jWkWreg2odAIxh8N4t3mkkDioMT+2ACYjhSAKyI9OTxtPUJ35hnk8l9xeVU09/I44ByyrtVhg3QWrYrVpWGpZKyju7YGQodPBKOqolVdrCc3p5rshRjtUMIGUle8MUiH5e+guZXXflKZgePz7bT0M/dcWbh+xA3Afp3WaS8SImYrA/uEWbsVrO1xK63/pam9odv8aHvdB5HWp6j/hrIY0b9ljFEhKYM0eUsVrNSiq6FhJa9vDTAs/6FcSMo3Gbe2p/6yyxfdM0qxx/yJwI65uawuQDEdfYUpq75zklFEVkoXS1s9lkSQWqXR/nIhqZZslWnTKtsIZqiITKrcBpnEQHYqzgaIBSihWEs/aFi18LVdMPSrhdXFQvf59rw4VhPDPl7K6/yRkYXoztCAi3WC32Znlj2MQ5w2JFhwL8E2s0ziPsK0bmHmbNW/dnFcPwGlgQTyMU8yZC6wwRefqVUAqY97B35P0dCzPEooqjYY8eIEl9PcjQjiSuv2u5C4PskWA/CwX59ftcL4ADJ53CaR2PLksod+/aR4gGAf5dV5ZzniGieYxTABNAQCX0vJlKNjhNOG/7Bn5wMMIcH+t3N8w2HZFUHm4KfUEgOglO9k/TjmDF46rQamYOajyILmUxwvTBql3B7DmYAc4Aga18O7NO7FJuJ0VrzdPMNx3XAe/CDiyd2TY+FyeGykbgQ3eL3GKkQhxzjkWqxvQB16h5taYdPXU3KjSt8sBppRurVMcdrKI6L7CnlC22dN3kucuv5+uYhWpFgJgsU6f1O6KmP6XJdyFXnyvvU0JeZ960aEcDs8AgTt6p2PGE/csjuGj+Gl7f4qzaRumvNYWL13YSPOf3zvHsCR3bLjdgzxFEvz5WdqFFigDsh/mYdyCSYc0crD2dDhY1n8jixgQ7mBSqvqzGXHttJKoh0mzMoPwOKZQgc2fna97nky4P2hdmfUary9U93Rtbk5bmbHHPM/Qk7kdb2xHjR2d1N8GHd2fb9qQ5iLzZ8plcNVuBRhpEyEo+2BfjBd9qANDMirY38+GMLmqH0atyp3QbcJpODrmzrY3dafclnI7gZrXzHnH32Hl/Ef2KsvHIpna2rS2lFaBZb5nQWG2bBV1NL+hmEekFlG9ep8yveB2315/7lKH9eFGUIEqqUYyjEGcKh+uJrn0vfv4F8K9WE8+GGxB+oxhEagCDz+iMSSux95lYDi7paS62FFlB549yylEN7ESrqfM5i8cnFw+Lb33jdACPlsBu5caiAKYzbLj1vv8fGq7OGrWLX4IoTd9ioGbJIKPymIIguYee2U+Jqgng3UMN/ZBRXXe2y1GCAbSrb0KLa9bOnFakuNl3fMuBT24lPoB4hYJ8oAk/79XWtrNgYE5Xk9BomwwI2VG/Ix0LgLnqUsxt+9WODJoYm/KWMyacOw0B0j105bLUCW8Ma/zYjlGiorZrGfXI1XZoZMzw3P/I/EJR333irpf3mG8fBkzOZgHPKOJh9X9b/Z+dl/+K8rrn91gtPNxW9Cf43E5KlJ7Yr5OZK/MqtkbClJ1vr8oAxFd/GKXuEfNr54RBMDT3acB1HIlGCj2MZifQpyju+QMA/hxFRL1riKifYa/LcGXmOUGVsjRx56eDXCLPUr9tBVm0zE4BMqNNjoXjVTqGrXVKP/F2XB1BGpS9+H4FZ7v/5gX+VqF50JLOVemAWPG/YPI3F10/VgZzII0WNqF3V9GE6h/LyVpYGKoIOvviqBMPbj04myJ7DaCAw4d3ajav7MlW/ZZkEyoWUwGNpMN4NG45lTvN/c9/ry/+sRMJiAghokuMoV2RXtB3B4pw28vXvOSLFpkS4UlsbtlsJ3rUDkveuY/ExAgMjHumFWiEXBK4b8Y37vjCRRmr6DQv7jTIfderiO6rlAbf04u8o0O7lpaJbOtMnBZlwmVrcJxcODGT5mSGIGtI6pHB0wWEHtJclxElnKpvHLiy59nxfpkwUTN1/vXs7OuJo0uddDFuYPo3C2lhEJs1ffsqM7RmGNLh9v8vtQTnklWBQA088YkbxOyE71XvFaV+RmZxL+a2B1eAq6vnwMkBZ2z2gf5afSyRC2avq5r7oLW6lt+0FTYJJHy5+OA2o38qnisMf1zHwo0S2Fi0ANEx5sj5i1wAotIJ++wwZW8O0m8uzGKot4j8JN2iHcmHu54FgGOrkNikSFnEKtLllask9QTgQWh755aNmAEMaPvgKNUkJHiPk4Chxtus9uAGxEwtZ7RkE/SDylEh2KaS/KVHkMyoJAP6CZmIdG0GHi7KCsBZgKLlfvCMSWAq5MY8v2sjGvDadt6iNXQIjMic86Gv2HIx3ZNkXDgQzJA1Sk8tyAkEW4j+yivQyEdNsLO8nf+KF6mterMnRZbiL4ALmfpSjCtzjm1bBsVkonLwTO9dKEYjPdY4KBheMmf4riau40h9C65cf8ijw7Fvsjh/PDpHZzDtuqYyxfjP5c8FBj2dkb/dSTD7VZFYymYVDvKA5Wa8AAX8/s2g518u0tZESooL3+ZStLuT/ECxOY1odD0PiDCbvYG+uHhlFWRCq6IP1/dnC8ODkNMg3BwjahcixsXSU64MHgt/s30cQQysnGLW5rgz8hEj3v6pCEcyKJxDgxb3YPhXnx3fe//VkYyd5uKtIWkgzx0C8v2Bo5ytHnpIZTwRPNznocR/Za25c1cmSk/SIFb4OJCTfBhpHgcbx63x41fmVE3tQPRy9eTEw1uqM5KZujiedle1VDBY9QFeiJ++f5SrzUBEVpOx0CEoaQ5Y7paYI3hlHMVRA6/+NsIs1AI1zRiVx8hhTarCJgWT3vec+y0u9NZNW2IvlHzl3xfp1/LiFBdg1j3s21QVf8OzytESopsDztqX4We3hdLzNhlD5v7yi4eV5rcGb0gFaw/2Ik2CeCX57ICFmpgU4ZDoLvkPXAVwZUaRPDN17C1SAXXFWOj+X3Bn0Kes/PYijnhvCDtd5RDRkwyFsIW987aekGTuvzqVCqm2p/lSx14DebuSe12/gLJhwxFWqJY0RKsTRMkyrzMqWNVenCTS1nb4BsL5t9movX+DsX2yvmDQ0RHM+QpySyAOYWrhWyeIZSsh9/hQ4xf15FK9pfVUyL6Klcj6GtM2TU2Y4PPvBeBSQMURKq2hzATjW6jlh7U8D6nKt2gg31nClPWbUMBHVno/40d9kMOba2Yn2u3/0OWpDV3kOO8V/lzRwXhk07CxEXUnf0TQ9VrKceW4BI5R2eIdE4VFz4TaTCklxdhlfsI6rfJZhQgUx7OZL57CsiDq00G6sX1eMCZgVLR4EWqOF/rBClBg4p9GuKVZwvSNk3HowFodz1ERkih+Vuk0qlNT/fOh1G38zf2vBdTc+w4RppHtgFepFApe7R4oXddMLhkabTizqTO5ooER4Cwf3tS6NZxn7OkYuyv+kwOfW9vhqHtaVLMCDYb5V6f6p+rd6lm1r3X/pRY+W+ltV5Ty/bTp2Cj9s+fY0TpFfD1bVANi/oRuFHNK/psaC37q42ZHrbN7fwiJGNLMLa94bS1A+48iRavv9fXc5GewZPI81jxvPn5CipVd0SvUtDgZOhDJG5LXZdTyfzET3VMEAr0WXVs3MIK2PUuikH3JIQkEZMC6Vh06eoDPeJWE0RHNwnHshk23MPGpXBAZ/u2jQpjJIvy581i6VTNBHhUl5PpdJ7IQpJ9eDNN0fR7vJDoomtPGlfbwGxzWqVISrlj7MLI5x3A++KInFnZPlbFjgJ8ViFsSHLOYqd1zH0XTAKv0YVwu6GSQKX7dF/wOh2JYJDGOIRujpHBuH5VOw4QpvsVYUyQgX9gwM0gg9tfbcX4h7S+PcMesww7EHnrc/RoGpQIxM9kL4mMBDlmUoPncnR8AVyYM8XJ3dSUmGh/gZ6m3OfGybXbHE5Vpc2UXZmbQD3VgFH4o7mNBfmCLoPZadntdwlL0DLmXL8+/Sns3qtOPGWDbnJ2JoSi0d107VP7dHmMFMoxCZqGpU3BYhBvOwOnrkEXygP4NYMRyI2Z8hiH4UG6ykUJSubWDRDMxsCL1rq0RiszUbXtqRa70W0YH2sb91Lzbi4Jhu5ZAg91KVdUa9KX6Y5th6NC6LdzkOY6rtO/p2AclqYJPvC1c/prw2lQvNU+SLpksgy0UMtvK5JJwmxB220BGZq648K/F4gVD3QJk80btspUhDu/t63QlukAIgCq7GI0i9yAki3sfd77/U9UcZAp0wEFmwaxnndSLuNHUvfg3vsbJBMlJvW3rbWkL9ghafSz8EzGFk6tQlUOa7t71UmbiZSaFGQ3HjBxPyup82RtehRN6NwMeWEQO8xInE0dxWKD3x3GEqekDb9DYKJTN7a4xROtuxTEfRYgUodpCdC41DHNgT8q+LWU+2IgPWbTk+uHhtowixqH18pGLVWGDpQg1+QIiNV/wPkmXwR2kaA/rHlfIvIp47SrHmhLVegEx/q36HQh2hrUZFPgfUTCvDTmv/wi+7RfMMPiFBss+bayYC+u7KlcB9X5zcfUiCMg7Fi6JWa66HkNYp6xSJg2hKcRAXiyCLLG4bBkeFOz2NWNf6hdLyd+nOQ70R3VPNN/meB58yUOtpjJObMeJ54mDYqAvV361iTAXS1CvmFYL5hImNl09kQOEonTOgvVfnWE/sW0q6l9aXRwrfL77F7UWpJf5QJ1oSCf0fJPWZpMgugt/98GtUMmfYI2J6L2xbEcssL6jFT7arI/bC8qcWjpJPe/OwuL9TXfTdTcPjtv20Mlu9UMlAxRfRKDjSHFzoM62KkA9FfObMk4ybWXPKLll/Mkw6dtL/FHa/y3P1/BCN70zYnqd9z2V64ia6lVSaD/sJ81eKpr+MhFxnPl9dotgOYzTbCznUhlKq3b2xfMZS5hCU7mzmun5GAjZrlmL/RX8k2Me6lM6k5tgyEoanDouHW389qH9bxUl2JsNcil2KpsjgSUts0shrRAGM7ejlp8HiOSHeRSdC8InJ3BCyrV5fYr6f7vvmzj4LWGV7bWnL42e2a11DXQvz+qTqu+FVy0F2NSfF4c4743ksdkbtNUY+HuT/caQMvBRgEnzca9EvFrVcBRDpBKHYmmxD68HFpsLGyByNZdRWumF4EitCR6zrM4ihylN7Ma15D9PRcmO+IQ9V20h852rjj7DNT1jF1QBpNuFjT3sBAzhVDOwTnj5YpdPk/JRFkiySNl5f68KviBaHPU1PiBHDQ06xz0ULOTtEuLxnS7f3hBUMYP4XHemV09HnGLU3noJMkdTD6kcJ7/KMblO/DY0bnl/DQ/pX38yutNp1R9ncc+n4qQAP21QwNaXI8OajC3GOqusSgEFN9Ihyi6aT2yHDoGmKjJzHJx5MIZigxalRITDnWalzas6p0HJcbMPPr1eW8hrVm5zO6Pwon+0uWbQbIzWpWLco6eqWmPaHRnd8356f3PvF5bEj17FFJac4mczcR7tU2uOenCn/syTF6FJI7bk/VKIXbOy+8lRUP+esBW6vQhF/N1rj+e6cl+fGuJDQ8Wcosy1HK04XrDH5BWljDYBvLasGBUsfs6ImKCyl45pfzUao0dc0XSDMXtVoMdjC8s4Vh6fM/daTXXjuXgSfS26bYAcGT/5FRMxw+6Z33eme5MVqMZxKLv5Ck0cL7ECR6xbSoG39mvrOrdhD5uYq78zoCSO1WjTp0I81miG6crMWyUTABcN6BgTJrjyZy235E1aikJdItN4XlxBy7oiB2x4mkI5QFjCIIAQ8L9oCjtAXgH95Ib7mxmQi+C0rQNosisHCS4pOwG2/QJqzQ5tjSGhwC9ayL8HXmUeUdeIWMEOivQXJup3xeIfLBt0jMZqg7PDtuBPgMajmtGCg1weMID7SMSZ6gkiLE7oK0kermFFNZkrhn7bmz8yUzhA/EJBcWu9ds0qXcwUCPac9ox4AMo49BEfz7cu4GIgv/PwupmHGpDPOfglpENFOB+w5w5TnrwQC7FcJG1J300blCubrR9EecsPsaPoTsm3Pfj3pxaRGm0fH7gPTFMSzD3x4aGC1p4mfkrSYJmvuXpholOkTm43DJ122IBB3i0snZeuyg7oiQDnmvd30WedldtWGVIawvplfB2I7Hxd1qgy3aiJTpikDuVOLgfv1oIH5ugbOwZUgm3G+pL5UQ1ErEv9vbV2ITRTaBBfLBQbRUWcDogQFlLyBUDhIu7aacPJgOu6LsqQVpKayfr6w9lix5cAfDKWMLDU7Dsrig1+LCj+cnwNg2WA86SGT4PxbcUxIjIwfxgc2hYYYpgNHwZmgNByGDAHuxf30OZ97Qj+ibLv6tsHfoibYkEwJX70noO632W6q+VVIbktyBNDW+msTg1A+iga4mD3je8Ca2vahh3A46mtCAlxLij2XEZ7QDFeylrZfCaBxDoLAR04irNf1bFOaRAq3DKsmXYkUHwjTSGo2vgU8Jej7jXuPBzUBFwsAFQaFAf17Fs6eLhM23Rv9Jpw/26cVuISLQqxOZJmvvJd9TnyI0JkEQ6onAGlRuifmwWl/U4wGLUqq/4R3LXe/qxsKaHkcseq9iXgfxQo3/I7gSumJx9wOTPH4GXkFPl5ktHYO+rpbol8YT41NKI+1IhW9sUzSFlNcZC5ZLWvuqsmKBhloVX9Qqaex4GVsYmaAdPuPhUqKyHZy6G/Cuer5orr3M3nZXKuauRvfAhPfxIuZINGaKkwu5OVxB2nCPX1yWj91YSt/EPHQGlsLlYxBnwoUoRyDLDuPof758f27pnvE4lRrYqHZfKjgXAAsYJZFUIHwxCC4dOcdbxO3IlL7UpMDMLV9eZ/dTII7rJzIbAIsvtFcLx1Ax9snpR0DwcFZN+5soPilvAlAhU+rm2qOX/kJoepSqcjfnjJ1A8oD9i8CD65nkpvx1281qxHk36Zx2t7ZLxFdOHN0cSJ/Wabx4gJXVD0oGCqKMgsso0rzSBbRWefL59JZJi+fbRV/DFRRsgEZUZI+Bz+E75mE9prNP2ap+pYwy1KvILDRt9Eb3OZgF7xzxC3LV4s/gi2ss/zcuMBIi+YDpntPKOMIOqbPaAEqf9k1k+hQPv+4UiCCg1tUK0zNzHi0zQSfe+QJ3pQ3GubLqVqR96k98k4QuJjm9k/ps7tRqa8ip4UtEfZwIOCIliVGGEIZxSqlgddkS6tjo0TN08JTPctiRXCqPptYY4CvxsK2Q1L0KrQ8+5jf5tikTUBNi6Tw2KeNkdMU1BoFRsBH5xpEAXcX9Cc+u8+VwF7SJU7DqTARqtsUXvacrHkBrdfk3UA+k3kTN9SSVjjVUHFXwj9WTQ2xB49ga698k6pPB2M/E4E+D9c7gDcqQgoJ3PFjAX93CYesBmGouJy+xWk85RmIDISMAXwNgCExEIsTv0E8+TlBOXlHtSATvdwNTqhULkW/T1+BT++pMSNB1/N+YIXmr7YaQLt4k5CvPxLOd6+JurvkOca7ePqs7B5a5sLkfWNvb7ROdMUcAgblhz9ba1NPClCNvTuXzLs6YOIrm0dnN/FNZXUyn4ZoCkac7Tnce3qSVzQ7LdxHwfjD4MWuOxARFwbc22QSj9nuJDpCrWQA4SN/NAhF/Sra16SbDFSmF4QgW6NZVgZsb6KVWgqY5FmKu8oNQGKxnK16Vyf2JQKKEFbndSOem6irWpQoCTCZgwaTCVXEOJLh589+CipWofW78g25kE9VkJAzxUuzgw0UODY/zu1xv2o0IRoThBSApHedscXbvqThdD3ofnLpxo7ZdhzC+H3TiTEEpy5MV+3gjEiqDXr8Q38o+nu+TCkS1NCopHq2oqZSdddTdjAYuyZCbAIHjLFvl5BeM0ekjUOzUkUBhwQWWRC6vqoLFaWHfV3pGTkYgHmIeOfFCMGXDStnB6YbM6rNj91eZwgJd49bsEzhlWMLQXnOCOajbp2iZmlM4Sblsty+y2bAYVw4B2BXoyQJpN20RrJ0NsaIBpkOXfBv0bVqglQTBnLcjlHr9rkh9Gp3Rf8m6QDq7gHjv/i+5uJSwLVZwzAHFPurjukvVJE15lcNrA5PAEMNYwD1wFiegFUtxELSwfyBs6zUhzG/n5yYl/3kUWhUrD0xwgYkR9Kq/XBkE78zhGrzdleLqtySVkpR0FTjBvoQJjuPDrcalVFLgp/JCB2gzy9vIIux8sk3puGlpICwxblFuJHILvXaRQGet93oKArEA2ywGC+3LQpqRwEL4pZ+HMY9MJjE32DbwA5PB+c/hqb56xRPmsWv2dlLV8coHoZQxlsdPcHDclDiX0Edqu56mKFzXAE9S9tSffBTJrrI+NzwUQ1DC4iFuUmtqO5WW6e9hUzELaATnkVNOhdGp3cJNb+NUd3+VM1TL9gMOiIB1ppBRWPnMetp/YNvwxOaqks5NZTnigYaPbmgqlxYpt9+ukSypTT1r4eGl4PHMvQeR3oQYVeBXTPwGGmqRrxs+1Gza/o1iML3CjaCIsGIjB+HqVxaDkfHeDlAC4VhMMmRIz8GwNxbHbp3Ef3IW8j0CHSxKZEpmLXxYQZS5EkZmSWkjgPX143Cn+g7eePCK86CK/wa1tLQ9jyI4Uh/cJWEv515WI95Uj50LWyXu7mFzH/WWKn8ZoAquPRWgRSh1akBq1i9ZSYgnLa7hQrBym9xsQoBoSHHaOh3rVKBUUsa/BOU6a/9gN8v7ZyRqLVaFFd3XFITgWhLXpOFI89PQSnDux0a2kAW/O4caSFNi9dyCpNgUbFgt7ASbvUjtT6zKExg0a0ky7cp4GAsBWNirleGzkqQch4wRfkEzrsZAtlAOFIRGbIyk42S3HhybAkPhFbpzqR5UM5a7hzzkWArxrT7bqxMvmj6+PQHHyY6iBtb2ye1BW+/xndM8IRh2Fo5bwvC0vm1ojRfuPre1l1PEmdMTiM5sdmGoQ+8JqDb0mStJUR9HstjHlo9KShNK+T+z3/EfsMfWbWFapbN/rQtM74DdNS0JX1hrh+XnSaf5PJ7kSKMvlGpxwzQq/MR8cS/4XwjHN0pnNBHtkWgaR+vAiUJmOk41VtPjKyqEU8Hlg5FNUkR94EHuQYDM9IUlirRLi1lBewP++uLaLFx5nWGniqidHOXQqmpu2bsjY9p/ZttDem2RHVyorWVSiQmcZNzlGog9sYIh2OmirCH6Z9Tvfft/RTnyr4yGdb11sefLfFkQgWUQ2ZZTrTMYaR9CpZ9E5aunn2eiH9+w6R6XVXAkxM+7Xb3D6KVh/eT8Z+e3eXYnMmn6CBQGKQt2l/GKyafdOWEHAc0rvARTkGPVpUD9qy9U5evOZ5ok0Ttds3MR5OJZblghor5SVC7uiSxYsaSqqbA38Oz0MmdaCGWbwVgDXAFJhaEMP/ASXH/69PHa//vt0ceuMAbXOYMDPIXK2pCuhXq19Fo4xP9o2z495tPs4zLjyv+O+AuKKm3Ra6YKA38PjaxLGbi+EI8GdULFgd3i+5offMLd3u6jQ60ZVQlsSFgmsXIjUzrADTRXRIWnKtjSrs1IS7Ef/WHeASZZt6bmnwIbBeVYnO179pH59PQN8wM0AsCBBX9HxWf5qzJ0IlcbrdLFSiEodwvTy42TGNF79c3gigOWMgCbYYrhi4RgiSYttlwaZdaKps2r3XN7bhvfQVqVatdMw6aQgsFK162kji5bboeYfh8TgAhW13U6BHmqEZwWpTVpvx2yubDnlZXOMLW/sZIGZIvbjBghvWuo+baEHGqjxBN9PSIrrhrRo/fvBgR0S8L+lsxsneOhwWyedjQ3/4R2WxARNqKDbfa5gob5pIJMRS6vd8aVsdY30e2yoiIE3p8Lze0wfz0JVlC743mkaiSMMr+mi3xNGvlJvJ9FC23TUAsB+1gU/gY5r3U86M2RdqdGxh+LrSEe+qxT5rF3ua57RVzv0ixHTj1vLwdkSqsaxDW4zYKhNsbPORZQ1Y0QWIjKK03hMhPmARz6nTiH5V3+/s+LGbZr7F9mGsHzXGywgSh2qJO2ptbbCInczMITRQdxp/PSMGf5p5PXk/eUIUMuRpiZp6aSjkjSZmINdqKE8JbOUprY1snVxBZrGYLaJb5I+e51Vp0s3XigcfDz4CEUjtK/vt3WwQbSnn21qooSroIgQn/sRbuDvEyZ+54sb3pdKL2MA8If9lLTcekBHhV/WqSZLC4peT4DquGr3dGic738GyDTDpCwIBdQolr8CqpHU+ngmmjyABDly20S1pV5/m9kiUtsO1TIcgfbv9zQYkv6dzlDxe6A7sW4TQtzJC3ok8GMFhXqQMVs/mlxGW13jXJNRoIwB1JlxcoOETPcyu3/L/w3+xUoMPWOcQfKDsKs5fi+/tgMaGNTuBBklHqhayWmmrlXSR9pu7cXHOY/UYE72WqyjxWe44zDoH0rScjeIEpAWYNalqEBlOTk3yRb4lB+A2m0MSg3UJI2KXI10yV2yaUpl73ycb02tC0XoMguElzPa9oqQMkzIs5Xu/Va46WhjPwm9Gtg+r9AcDyqLSK1IuXW/fIJRO/Zckkx7qEDhj9hWh3FQlq+wDZxbNyGyNxNHGEd4BPCKsL4/ksXMzeSrScCbs1BgXnpCYvldgh5/12WETjiwciR0y09MMyFaNsD9jxz5WlHtsQM5Mmp7Tm2XNnOBxd1Sc+YzNNxVLblwa+lvx5+gHY+alawBy3o+zgayBCwHLyKOzcGmH2o9viOX8hBO9VuTaesqw1kT6bj/+g4Jhi8GK6kf2r16yNPO/TMY0uELXpTkWe8MMs91gEIHtFsf7+pzq+s26EMz339ZZpKm4QXlWIihz358EfH/O3b1bw41zLZAApfA2PZGwRMqffJI/M2NVsF3sdPuQmd5btJDEWsY4b00tJKNCVbO9AyWLExoASaY5x69nqkHWPCFYiF61csz/pHCnfcuEpXev/5/nwrnlrpNXdacm3PHatT8heJ6bBVq1JpUlp4mwQk3ca2/jU4MC/9uGlAIBBa1iwq8esV01BVyutmE0zBnRLbS3mxt65bTlew6V4vEtWwpV4MBKV5ZdGCezv3Gd3ariX97Y5DrgJwOqlvXhYyQf7F5bgYWaFUpbswvuTG51d9Lj5R30NUzoqAaXl3GcHDJKzefFa0QNN6C1oEKCyhMNBp66sLVIoYTRyegxqjAO5e2y61B/GfctBXKId1vFPd5OjisOx/pKfTnhShDy5cXLIZdlqwrJuY4y30CtxdknF+kEJ9bw9Dg+6Gzyb0KyeH6CTZ6Mz8Qj50FX98qC2ftSY2+kmoTZucW82q4eNQFjCJ3zP0w27zFjMXZb4M8EJucaBUaJxFjkIgQDXsjK1oIowkSD5DwYRO0j2Eis/Ude9uiHI7/PT2ACepdhV1coIgYLU0yCSQu368sA2vop3LXEBaVZ5yudh7yU8xKmSLEaVy6D6wUHSIa5wqKbYFlB5gFFazfginADEd+tjQgbzK/3VhJxq+1/VlyYL2OS4ElQ4FrZk9qpsHz+S4MeXMz9U9K1NLBu0wLsHv1wTWN65csZaaPQfXxWlg3n4OXHnYeqfHQe2skCo0FIEfomcaH+3aLU7O4Tflr8IIaWTwAxkk/5fzpo6Wdg75wGOPvMl6VLevBFevyk5U6paPu8PXhoVvjozwRylQ7xi5lIlz1P6GNAAiXOceIhIvJXwn5Fs6/7rJRQy4tTfBUQmgEEG9rTrNUKJ6jJMbmWI20h/jne7oXCKgzVt/+MZwIofJJ2AvSO85QPuOMnbxdPKuoRIzmEd5v8x/06NBJlZgHctvCKjD3u+Vz38jTM6UZm7FglGUUT3OAbJEhi/7SES/Xm95QfaZY7G9Hk7mJ4EKWujcBJiyhP+EcTwy8BcYSbacXpYy4uCGWd+5tShTjBb9QIf2PoWhTGCdsX6Ngr/m9J3ux85QR0I8/yjZ69SBpCsMmkosXsKRUMkcz6Q6vmekjB/Xbvt7m+n4ABaDiwwWR0MvsilcqpmyWiTlpEENFSz/0jg94dl8NIunwtxpwMiv6mLt3NW+jIDwteiQdAtYZLScCzUjqrnsmaBbMNCQM5iZJuLmDPs1nyHyT95yPF6JZCNv9DmWnYtra/5UB266sS2iq2A6cUPhtoIFKMvOqj9YYMAj4xuxLalSstgWfdUVN26DAQrXAM6S0uGXaM1FFycg7dogYFQT5+W+lMl+7fLTQ1DvqVW2KNHIMqSR/kXfzEv2K1ilFZxIalAvEa6i9SSylWkrQv3/cEk4pUMV7jygQRbbVSEuFAv+fGeFSN7aengh7Xb+l1xwUD2f6ksfbTO6qUUQwo4+kizz/pyAi9lAzVqLEKN9vQb5yURXfm+2BMsJKMObJIzK5EcroHgwU8o6beqiRThahpdg2mRhBUkwBhjNC/owWuAfMijv34xmEF9mFBkNqJillgfeNmlUcluQTlxb7XFn9L/gYt6ruPwoAiQHuEhTAYE3oQRCYvQmf7uXBv1w6PKN6irnfLIN4x3ZGSXfev4l3OC6uVU5Cu8Uv610+NH6xK2c3KOcOvJI9PmHdnpxqMaNKJ53b4IpvR2UsEUq1qAVxuUTZZbjxuRRL9Viii0RLlV3HBMflxw6h3vU4hg6thnJ/HZ6sAebyRlJGdM2DS2r4lhiYYDqD6bqA1Tn47v1oNwwQ1tHv9arEyAViEI/YmOrx/dym5XGL8oc0/FX9WwZWZow3NtLJpJoxVhfYvbVVWJaz15GrBzGAr1U5ijzNKbH3Vk9pjPjMUdlgKBwQAHlDU4nFV6YJBOX/34uy0DLECYb46JhXPappKUIGMas+8JMLYv5HiiEI+seNtoiqrz/mk51dD/7OzP5UajZ7zNF41DvROUTamF4MKrq1RCqFxjiwEUgQ4gQyeGdbvV5XFyifncAbPIXoKXVHRXfJcvjWMHQM8azZVJTZn8BUcbDDbeEp2XLM7EMvYBxpQV4IfB3mC6zlcjHqB4SNsoqMdaHOmHLF5TL4IC7iC4qghKRCW1+A51t0iEpOvQjIhf/KnfTbN7cm9HZLCXpMNQyca75+0LIxUhVXgBpfZUILoHl1UhvXT0RAPNklrkucDB7jfT9ClAPXZSrAo6NETpa14qNlyUtRRfL27za4vYsjxQxhDcTeBlSf3hnR4dKbf+Z4xkc2klSYN1YwUfGweGxivwr7WRhSIs2yunvCikzvwYNSWrAJirJfvcKYVsgw7+Tit99O4u3lNGBGE32VDdxhTBCrZbMC9Q1n/nexs144mAVKabNttUqIZLswz5AkaYXsWb7i/wUCcQfdYivpaQOTvQisOKJUVRiRK2bRUD1ySbXRWbtLPyLQep5d9+/DfgiC8+rgvoOrRF+24M6cIvfd9NflYcPpbt50DaNESzMrSpZ/EucUT4EkqjObitBpdHT5ZXEFSRMLs863BGY8+mGEI93OSTSbtcd4hBjQQjm4lSJ4h3vPeuJP/ybciegKj4MCWLPbFjGtCvY+5/1kCZijwC3/xbW6ySoUcwXrd0/wFx8lrl286x52zQmhlZ8aZ8OSK0xbjx/SQS2/Mj/o76go4Upskz1TSLL/Z/J5K7Oz3S+GGyQpChd0cn8CEecbFmyK2wrMojBue9GpLXa+qxFo/4/tQB3nHITMrN2ao4z7XDi1JnQCuF2SvF84Xnrs0m6VFsN38bz5ARQEcjwIHoryQr8TB5A/mIWCU0NT0oPm6DXDBSBmNRzODXXXgjoYYUav0rSCrEQ9d7s2gfW6N17oPcXuMXOK0UF6mFc21i9eUaR/meF/tPYR6BRm5BYzOWpzqbvgKDtKICTVbD+cnauPwXh61lRJcsGAIQb64e/dGmHQqAiVwaQy9ZmNMh/xcVFvdad1oiRQ4ykere4KfcBmkkiBiDDL5G6cyc8sQ55KwEGMvo/24X1YIhYE3qgK/OPow6V1gdOWmIr1xzabp8kmtkE91aU7H/fZ64gKTmeYmovXREMP1xrlfAcf/WCS+ZuvnJgL815ZWHdOun9xDeHpqDXEHI/edAlDDlFSl4lLuoIweYQayMwZ/klupB8k2801nTQB/ILcj9VuO9Hka1e+5Mo0mu36wsghA6N4fs33cheKQ28oFRaRX4+l66Ix88g8puh2XAMga0pY/NXXNzQxiHqNGcK02roQSMtchWy/TEUkqGnqwZ20YazKme4j4XtINzIBJ+5OJM5Bm0aqbY2mFmWOsgYDVdVI7QI+qrbNume+PyJLOShcafTlrzLuC5E0H2wqfDAOGM0iwOJ4/0InCwSRfwk8/J4ZfUfg7S23DhAFNiLRVsdWop6ASNqAxas8Z5XxT8kL7pZSMexH7QA+qxS4znsFE6W3WnlMVuYYLAABQQ7wQTvDOvvJjSzoeK3ov0jhjxqhmzPxNKQ+AbrgvQvk6AHFnicZ1/nmXGEZ917q9jYifMx+vFuAKIh14kzHZtu5GCQPEGXrqWwkgJDVTYGpa6OQjN/yXoIbZ0pDxJer53TqKPuhKm2juZ0uEkgRzToBznB8+4ByqTZOaMKhgUpWNMG6rntMPV3yAwkZv3lBosgrtJrEh/K2pGX+wDyQJezODNgJDGfc2KoGjVZLWD/ISLND0nrIFRX0pk3eLgWrScvq1siBRSokN2ysHIBDOma5RPsRH6sPr3NLYDglTqsnwqNihWTqS1RBuN1DQ9uKFTPXhHNvHiP0+oV7EPSbpeQ+ZGynlileARTHMB03k9Te5lkUWocb6xeqXDYEKRF82KBwLOW1Ev+h5v/jYYRf6I6gKWZa+t3G527eVMwAevwvhJzV/OulkO3pfG+Vv9aJoVAfi+0txfwtrss2QK56+UCIXrbGoN5OkqbLGO+tryvxWX4nv9v7qpwOkSKoeNpDbQx5TvAjPqDHK74Q1lyOjSN29vh4DO5+zt6aBrxhetkRYpHTzhRsKXGLQsqwMIdATXvJ7DVumcgEaiCqLVIQ7iwHmSsEtPW0Yj5QkZrphebdpKDvh+az+/hgyAOvdT6aPv6ofZ6K6AxZoQ7i1HTMBvveBpp19gXNkc4rVR1uF+/l0wghe3+Xfwol4E+XShqAtmDQXt7jAiPZMDG20qN+0hCCvgF55gtO2h7Cd6nqJdnbqbfUl6X/ncL3ztKsPUaat5SRTT+Rh5xMOJLLp7/RfSY4UPlfoFw4ByAGJhKMipb7tC9RxyXnJW5A0a4ZTdtvtjvYM5PJ4X0JVft73VNDflCMaMtJYpMJqimm0RdAnHX6x3AY6H98Rq7jE64C5SR3SRbOt1ovz5pT38cnh9/b7Y81ux4SVOSIGM82IQ37avabjKvY581zfcKs7l3Nz/ZTNPCtVGHeZKSABMKas1pR+tjBg+03dQK/UQVU8NzAbEiRXdqSpI25Itr12BNUI1yMRRqvG8r8ZC6q8j+SnuKN/UoxPSda8EdFJLKGfq7e80qOjyzPeDkMILj0Hah0f4O8NJcZSZGHtt+xVV5Jbjh6VMYluFe212Pb0AH/zIM5jb49l4wO4cAl8185neWVMLJE01Tcy+b9ZMC3sxJSHQG4BCg3jCbAqYfLRALNt2dl9F9jMIbHdWxwJp5SmRABTh+TqlG8hfWHG9NiSZql8IUlyTFBOMPLew1V4YGUaR45Tc0XUaNz3iJ3R5oSA2hBrlt0SzMeIoXie01bFHJrymZjms5HC7+Z8sNokQoiui+VQ2k+yQQAj+MvGyrwJx6Lv2S/r4qRClzV6wYtAIhKt8YEk49VWkibLtmNdcHn4im+9VL/3m5xppwRNTC2NblpGvSQZG0F1kf87IJ2FhpPeb325LJrhG0zwWzEbqdWTrcXmonuEO2fSwjO7Y0I+RBzYp+f0jGjrfpRcTu6j//JAUZlEEAvYiBPkNiqmoPAuhl3isse02A3C8CmjNK1ZZP3cGNpKl9fveAmYGdEM+tlNpGnIzKRxOqI/oq7bgPG3XQL8YeHeyHta4qlgaKZ5gGWA2xJVWtRJwRLPRM7k/1/GFegHc6kHymOsHfaVy5eRUjz0s3NFybAdBNw6fIRuhXtdnFZE2Ngnn+oslQFv0nEThvqOyVVXKIkUlMqAc1WI2bQccBvrgcP/mcrV7TALI+aXpZQF6fr9ulpjrjnJzxyI+Lg8LybekUsS/o2Wy/7OVmPSZFdm8HzLHUUXx9q7RbddrpQw7QcqytQ9Eb3YHeda7f6KPGtqvGpfImWAn5W/8Wwa4hlondm9L65uT0O/7bFbAE9htQd1sWcy+KoNjApOeLC6tJnMwVp54G1gKdjrUCMPzAi64G2doGVMcN/7uAZr6sUcrtiiCmP8ZlUzElzi2IPvVIA+UTWnVsUjo+W9ce9Pin0U9k5gMmJj6qv5hYxKnQOUSJ1Yi/XmGKAaR0dj/DHeK1hoNAEzBs1631qnRHoL887udQyiudMdlfEXskspmrJ+i6atzIc42xdSFMgRZtLusLu4mPkKPTMUh/ZSWRtHiIN4/vumKiSnSR5VKo6Mwu4vt/RhPhZGhrV3Qi2BPNQ7DtZavnOsyUnLJiBTsfW6gKf2CncxyQ2w3trCYBz8u6dwws+2+FatvS6SqzQXYBWdb+2fzcEE2TwidZR0+k2OFiVqqNC03eQFWwQiYYj+4XpAPC2E3/D4tyZm5WUK0K3RWahfYQvpnvRZ3HyDGk27B0AJ1bDdONCptaDttShUvZz5KTQNDiCjLSMDl86ngeTy9SyaSjRjwNRTWhkMPYQpniMjMXYZ2Wb+u8t8rg8J+uwPXQdkh44jbDiRyLNr/E87sbpLhmr0U9k9jRIzcDU+E8lMv4LObFZjHN3FLAFy0vMB9fNf4GPLwgBQ7w1Zb2+FuRDDYaf05d/+e3YmYkQT0VqkltDAlHwl4b0OcK4RQFTlYRe6ko69sUhLszW+B/kl6XlvfqO7gFOIYgU4qs+IyYZ57CGoBEqN4MShWFhMtOqQp2aUXXGRwUxIkgWebhuKGXaz42yQO47teiP5uRufLAPPEpBNi/616v6hKJ0fdIL80jDx/L+BqWuuojX1IMJk1uA+ap/GQ1PjWpLchVEdZZfBYeJe6ECb1mMd6copaVbEfa346yNX7o3z8CFtEV7YdRIXME0vut0KrOaeAgkDmPyjiDxtyMHrR1luogFx4H9ChTDL7k/L1f2W6arM+7HCS8w56pkJ4dXFfK9L/6Kpno+Rv/J1MmbBZlZZ0oiBAQ27Yehcarr2WS1JaloJrvgxu6nVVX7vQlSItkoevpDLXUywAjAc7J266ib1jNLaD8yV5fX3JikpwfuibqlrvNLmPl5fULOCqsdD8yIZ/aLIwoplUNSNhq0GYM+F5uYZfAXBQzg7i3hvelF5yDz9P1z0Gf1TZY4BR0Fd8u9qF+/C0z9i9YCpjbfgUZmKX4fbIQAEvphSefUiBzhB7ZID7eoUc5UIQVNJ64Q4SDUpzPYHQWR5SICklY44i2ymFgupWWegNVbxhy/BCHKRbt4UptBq0eUHo3fcEWlVQZhTpCQtMdK3H9s8bHJaLBtbYmm0dKut1h60+Fm4Mh+GQKgI122omNr9Z88Xks1nVmY+s/jd5Ed5I7W35uuW+Xmluamycmk1o9oArhq83MoctEJS1tBbCfUFv94FPP79Y94kC3+2KurVOOuqNcLsieWu07bY8xG8AwN8fjAxS/HLYcjMz5vxvmTTrElfHJv/VjbtqbirZokYw4if/6jrYanyARwmmEI1AbC5GEujs5CeF1xXU5Ym66mqdBd3jeGeqNRhKws9jC10ytETwai3bKUzY8vVnj0A4iIJBz2KSwfh37fXrZxT0JKByn0xOOrZTc/bhpD23nhqwS3dIWPZo5d1jQXUtLHp9nbQwCylVvvnk++BcSt55VLSyuSEe2xqlqZG4o4EUPOX9XmZCSsr+I1ow4pJAWHg9HQ2TvHLLX5kIni1LrNVKO57XYUOTAjdVHRn6ujgnfzcbYUh/GuXC0hu5tBJrRbMGUfmBnptu684sd55FVrAKjB5vB/GAWL2d0lQS1MMVMnJimi5O7An6OhYHuUeNfm+OE81iukKuGoygumZgunLH+oSC/CIpXBG5ZGR7fqVsGWvjPKpRUlJjiDebL9OLJbuIxfn0HqNsvFunBZCAr1LIKxUFVIbJeND9QSmESNXDXX8jTEJ1EiJPV/uvhvZGzYTkOqIS4TOfWfCty7wvuWSdXr+UIqXz6CsXmQ7m4gi2aiX3AZEq/8bIqW2ULmlWHahIyntyVSJeMPL1SxXI7us/FvMmzJwcqTHz/1vHWilY859hLNW/b7d7TtuM3HpG98zHwmHjwHMVcsKsCOHgv0cj03Cdk+LZEfK3dMMVyTNg9+FHNuFJrcMPb0BjAEa7b9V6fUv6q+394L5XsgcNsnG5obo3wE5Gpu9oTp8x758+Wx2A2+8xp760Yqsst5XHh/gnbfjoWC1K5v0P1troyuue4QEhVNIAEMFlyhuAI0oereeBeRBI2BGpqfXuR/RfJBVxI50bmxw/AR7FzNbczdRnBhZVHTGEW1cq5cToB/BiIfGDbKiBDlw35JeKE3ionmxmdbyp8fpSRo9IecB9FlAfkEWK7CT8Bnmke8WLDkp40QBwC+q2fZCUB/yJPr+AxoeDRYvO0Ro9AalfqfJm/3Bu5dHljJRrqB4/KD8Kyzi3ObZzl3dhVRIpFaVmwNmRog+RFgL68IuQYOKHEUHtu+FqcZIX4YsBLegTjN8YFWkPTUaW8czdPMGXGA/kxIIy5sSpVzXvDBxw5pOJvDujcvGjY06b+LzPOu+vkoKwrhGY5rCE2Z5CG3mosCtH9G7dkqIl5/YzZc9bdCUnUW3EoXsFvNDzz7/ZstFvDIUTVBpHRIH35Bc8gbEsWTkGLCFshX23O3KFJQr9QPyzrUjAQvDog8Ssn4pzqGw95p+GG1Y/XU1ii7NJpFGPPxtK6B0Jda7paajOsTysg1NneK0ucaQdviRn27b06eVnAsfk5jr7nJlG1h+6yzzP/shbHEZTbXGbO9lgvLQ06/241OIIHDaGYFkUq1WKcD/AbPK95pWqLgtO2yE7R4vlMPcgrDq5DEUu3CsWBzS93XjLhrcUINDDds9EtIpT/elyDrztHOy8J1XpPEQY2TZcdpVivI85n4NDyJDmHI3t3ptk3kFYEf9EYaPC+QzCdMRiSQXHi+9gP4ZF63eBFrwDiDMuXWtvibCpAtP2dnH4kRSY/RJiaB3ntvsgmhj5MDTDBikevPzlgJtIzd1zhjPhurj6bXrNSHwHYmbnvagkV/Q0O9DSlVzMMi6QrxwWLJjSj8oK2Amck6QkMkCN7zJa9el637frKqhWRG/c9jX5c0FY2TqhzWOB6u0J365jIOdpZ2P68suUADc4CDpqCrj8yhziZzkOlrmm7vqMz0iZZtxenHuz2r1+4rZBSx+vzadUzJh/ekGyi1FZpbSRLv27ShsR5EsKmp8WNvxlG5I6uXQnBhC/ZfGzKBoBRPOAkkzp9nM5AviCK4ewOAS+lSb1nFOn/aSUD2LIbF8xLe6Al20DjD1k28/u1AqQyFBVs8b3JseqnNcgyXJt4tzaax2P50vbJcLrfqX/0+NNa2+sCkW2JtsQQVkaA4fJfCHcbzrmrTlgDZvC/ie0gXRnUrSss3Y9SQD0F43EmJ7txhvqOJy6ZE5Wo4xU8qGVhT7J07HuXkfA3UyVVXNlQTkGcVFBlsw5I+cPwLLx5Kc5QqeeJr6QZDPUFBMwx7FdWXy0m3HypCf2tKn7oxfn+/pvR3/HnbuLoDYlxOOkxLJVE0KkhtSxxCsPEgFkYbpeteqj6xO/RwqliZgDVn2SN8ez3P8vi7LKLlJlD14S5G9wZ/3XgTBMSlwESGrizkCo2B+LhesV8qgwVHH7ZQbaixDMTaNWtkrx2RBSkkAzanO0JYw+TUlBAgfHUUeMa+yUb4r8SDgE7uIdADBQ9zhJyWLp9EX7l3c8wz7hPCih5CWJ+hDEybzzFR5QKp9h5tE0WGwDfElXHq1Y12CRSb3wqmWZ7Fw6PHvbLcyAM7DL/VavTpdRVaL0hIP5Xet0+KVOZNz1zPxyo8Us4lmzgh5ufybYblPkxSe4z8GDBKymNkmEi+Olq1vRHUzPg0VVqYEIR1L6gvpo2sLE4dQ0jZlLo1j/Zuyg9UYHV5mmPoqm3DURTul7APycRTpXDoxnDbHVn6UGAd0jVVLyE5BINEb9sRPDGAmSHn9ouDWO6K5RzgdXhfby5O7Qaj3RN1i0FryKjjwRzuTIFK5eC918OCemC6zzWIuwfaXmNy3mx7RRyQpCPmW9Q6kkfce462lP9s6rTDQZ13Hq8LauTwt5iHb9J9WcZV3J6mNNQS8cw8QIobB/K1wgBFX8BTFOnC1p9dP+vH8xW7adcwkQufYQ7MYubxfPeAsyDZodywDQw1KDWrb3CYGWaCKdcyrW9aTMALK7o9LTimPfD6mzTXEqMgXAVTwT7n2g77PbrK8efjcSqmEb//nNNacLghg6o192IqMT4h7+GRODoDjYlRot6wBoSR+HE/ZZW08Fwe5FwNbyyJktQUIy0d2t9g22masamb9bnoL+Ikq08rTne7gFGdltMFFuMsHLUgbGVkbythyhfhhQcaWxYq6hpdQrsoRKns8T/aLpoVSontrkkCZ38YLuV8Hr6NbWP4ILj9YNgRTm2asAC8zqOEa8biH/oya9m4jK5q1KABY2xruqrbViDUoc8yTxmTvHptZ+xg4OFTM/XfILpdaakmUJiQoNf/qaTf6xq+NzSJM3+sG6Q0r50Qe5Cy0Ji843MDO2aZpveUNa1aocTp47gHeVCMInslEJ7EDDroXxm4rFS++lx8HOpbuX6T/AKHiy6elgBu+DcDIxujiobU549Erhg4XAq9IepyERFLMYoHePPvT8dhTNXJcdyCKorrZRK2peytX/Pvx+8axna7rwD1P9VDYvrLoryRDpeK8B2x3f86V5ThDwp8b+YM+7VFDT83MHgHEWwPvnedcY1ACxDapKqqvdAcHTj10+O5UB1E0vf0QG52GIWg+A8Wi/UMwA4vd3cV75HQNnmjk9KJi+m7VLAlo8lctw9E1lChfa8OWW42uv/i9sq45l7Mrw6qcDbJn9ELlTT7sdyPp6hsG555ymjE5PUZYCD+nuu8EmIT3kYDesm/kNFogsTjHuP6X7cCKqSViHMxRA3xhHF2dENWrQ3NY35qe2yDHvxSa2OFCN5XVbkpCfs8k6C3cBUo+HKuElrulb0GYsh4SXlQV7tIllbICCcpmXUcDUczFG2mlnijMqDUUCxFQIVU8xFQr4KU47iXLYytxynqMadJvfJvm6VgnUoCQACZxsIekXRwuh4EAa88bMhg3JhzWcQIK4a6a9YbPLAWZKgeFKVpKKhVMxyZnJ+1HAqRj8Hr/5YFHV4XW6GZs7PDnUqzZeOdT4wdqzmfrw2hAxvDD9ScKX8X4Dna7BCM7BgsSCpgK1ZT0SekgHf9ruQcXGdk8c/OTBRlCMCu587HMei6FvlqO+hEIFS7z3fDHWCPBPvEcf2uH8az6KmyVzPOM6Zg8NB8+HHXgGUlOyaRDyipUjo7OjFx0zswkFO/QonFSmqIDCy8JMUN+4bBKoeK/5oDtya3sANuG8LCbFGQ51Tm0ODQVXdOJOMMdMaaBjsFaO+7H7Xf1wg1Hjgj1vdNE7jE4gaeQ3bjF42RTiMM8/LjhtyMFgKaTOSI3SRU0VLen4CZQ5Z1+EYjM5CUbKF/OpqKXzAtFLDDDqg76/V7x6ULnox4FrAeLIY92jWJKD5J+xUEVrFC75Swcpx/Y7qGYb3hE/DC4+OjMJ053qOno0wZ7WNRpKkt0F61Gzv3wDIVrpMVhVWAuSzmszxVVRknGIx7Q3Ju0BcnDMR6BXojDZyauYWiRNeCiWJ8vUlzJvl9teMRAOk2TCg3aynOqF3felgxpABJAvJzxEY3g0aUCmETtKVpZc3MGCXpEqTPKMfEiz1RWjkTWU30jnSn3RuEKdBNbVmb/+P/i9R8k53ZZNiLEZHe6an1NNsl3ZDxtHP9s1n7ICcmL0rKkxoJ7WrNV8ZM7iA9N5UfAXKonHxJAfzntowZ95zHO0DcMaUArfUkKFc2L/pnlqWffAKy4BHyFinMBbS25qs+chJIOkotk2DIEtWeqkjIbJCu557uaj821ynvjNP2J7pZYWx6fLe2R+eGB3mR9Bbo7fzuglv5Po4O3xcxpp1RB8oYUkFMzRI1q1IKra9Q1t8dZIqKyN5WesL/3yyoZfgSuGGqyUF9GCPgj8v0ue6FkXZTxQOBzfzioi64sa+tLjQipbBnj6iKVShEA9ePf+yR28NiWblawW8hCoSPeXb05jk5DuSqBTruK2j/lKcifOJJXDqiCeuz/svfYvYGdS+zEs7m0JyEF1CFjKKTEEppsB3H99rQsCUiIcnLNZoevtebSoqDGMvytQr3CJEU7hwdseK/xQSfDZ4G/eNnWFiayMDab8Jj/jbG+FVuKEQKpKqUfx/tAc8oZlwQRN9VzjDcBWbq4lf7Xb1z25zajXRzD93/QUEm+lZuO8W4sqi57kzGDqsR96ZRlkEfe30t7rR2AMt/nQYT2gbPHkg2h/DzVYlAyMEHrV4Ne31P8HjB4bTJRaW/Q3w2/dEXlaqhgysJCZPlKT18TxPUdT8xqoXbzk4UsiZr8q/cYm8X/rJoe70Gx8MxrLiE8NREpBCT0QDpfqGiL/IxQ6q3SVPFsHBkZ/uaEpIePwpTWYs3hFLfOW67ZNz4+j6mWITTLgihwM/xkeEDGS9Fb6JYUbKJ1hB0o52KNmIqTzplloVDL0UJ/ICoiOcWFx51k5KGt01t5bvg6rAQAR27zDq//GPGW2gVHYcH4gi9L2mxHfAgPHTAE/ppVGeXRInu0AGjLYL/j2gt0hGUbmC2eoz594+Wj/lq6XEbF811bxOLpMyHeiCnBOsCUpaoFaL5RXj7Izz2G+J1hUPpt/jutQEyatsRLqcLJnGxQ8Pn0wtAZp5lnbY+EAZSloLSxSraO/x4LspKufEx5SeTfVf1Px6t5XW39uhkmvHdxARM8mtnJjTQqg8/rQjqQ73Lg5vcHTRmOdD0EOowo4cckyQBrORKee2PMbTY+aIPn1U4XpE99ylLrgJumB+JD4oHn9xwrXquERRxM6v+n1ZN6VLhTJuPsBlKEh66OcPLQCJBsbN7W37wI4+YIwSK9LhJJsOU6sFXrpZcBFUm86FcdOML9538tm6z4s2wAIgkXGZns8JLy9q2EMKU4jmFk8oL9ko12BkF4GRfzMPi8XikUCv8z2KW7waAfaKWneGFWZREJ3svDxE6ymKdRpm/t+N6DMvlT15ZOMxT2iwt7MnC/vleCB6+eGbG853RgQq2TZfpchk+cjM9BdtjdFC31VGDjCSU3IpvBySrR7bDu8wZEoTDjC5CVUl370tDdgLISHBDTO0O2Aj5u+PRE8xDkiGbTEWVBAQpXR/Dc22O7nMPbANDgR9juxKs0fFiydXQgF9Kir24eyBJkKgwK69l32e4CY2WPfcDCJF47mTsQoZIGNJzoqIeJWh8ZUe+2id+B6B96LIUzEX5VRGy0+02bp0eZTpm8wAl/fqAuVWYn+OZq45xX9wGekk/rSRFaGajOoLcpc92hw74GWy0SMYGfSyxTC2W2Q+R43M4zfbiohlg0JkrFXG7oNcTw57+j82EjIGGmaTsuoVtspnPk3VTG9YTbZyrGRpgYjWDxa/iBTOMUNtQNnKS5Q7vZEwJwfR/y7SmfYKZWymGPFkTtPzS9BncTZunEnIWQrZ58lhPwbfPKFaaHUw87lAjBwBTKtdsuAodOWMcnM6UIknJAYsfrhQVE84O2diBrp2TF0fcD1aubcb751s9bUlhWNTX6bouoaXWOIxJxRO51Yt/r9v/WJIAIamlASworUr75BA/mzpFgnb5fdSPY4Iy5GAHdLY7uZt7KKRvCA4wGaZxniTwdF4PbZDTyx48ETv/Zz6RE9OBKPPBzGEbNglhWP50KZeZdiZavOptjO99UdJ/n8/ryNDCBeoaFHl9acyfvuWaiP5wjZCDT/QeUyPo2v1cx8fNRFXcYirnwVTx/Bg9wCqsoWBXrNcKytuUA0b/60HqSLzR/+Lop39nPsWWowrEMKzSkAAQiIwr9AZltCee4dF84ITuigwrfTUOKVPCmAPndX9v8Xdzpk0qWjr6wdj31O6kHP0QDqsfxvvydNKv2N9gus0W3FsBzJcGzvpXvJIAih1V1a4Cv4ljEUu+hq+lO7bC1p6Ebv2CxC5Ukn/1Gg0skj49uVrrcA6jgYIkgMQhY51Bv9sSh+33WhwzwWYJDfTssj0utVV48G8j4NYohfJKS5nKCdlQUWmC/v5nDQnBlsD8/Qq7ZmvPBuJZ0W05ibYQs0W/BXEQ5nXrsQniVgveNyD2oKFsDi+/jmPXu2LT1g0FIexHUGMcIhgzdgm2yaQUBXf2s2N4PdwHzTAvSpz6q8AZT7RbWOjO9KRSchclGWuJCbjdKTxsv0oc35f2ZqAGcBa/I5Z7iNSjFIjtW6j/thcBf12tEwOzgnlMgsv5Sv2zjlj9FKlME0/PBlpear9vE0qsCWtSx3jqiAYuen2/KNguv4SiZoMIJpjlURwiJFmyxFDhCh/HoysPU91+9WZTmjRvwJAumLLcTBLIikf+8bRS5ClAzMUADXkTp99P6icQICftWwmmFL9VzHmtE48e7ITsCX6OzbjhoNuXGMKKSYVwkqQk3j6NRCb49CW18Ssff57/ZWDrb3nKHTC4m0D+CpycAMU9UTDJHAgH4cW9K1vR9c2k3TIwxLSWOH9nANInDyBfNqou/s8AST0bhcY1EMAMF5zLRyjxpasqUWoio9Vgi4OPVQGBx/K2ucdUtzb/8Rbpqv7duPGuUINEIqJyNSf40ny4BfqbbomnxWeo1FWCnWmiOj4juYnJVLGalVDpI1YNBH9AVPLtpWty07FgMMHlRHPx9U5C+D6msdx08vyd+Yof6hV6IR67zxI6Z4vjmUEQiK6hJDGdloo1olpnrRyuoRcBaeSGG0BWYyfIaY9i9WXwOJiWa9RGaX3XswB+x3EsCMjk5QsViNx/ZFWAE3k7h3MRbwPJcDB6nlo0hNKG6jOuZyMZpVvjDqxh0HV5oIP2KnSu28UdijfsGAjg560YRQf3IDKtQzu+wlcMwnPZuZwfhMx8behSjSnUoqBRU3CT73TqBmef1jPQ4qH96439CJHS/hR/uXlKmytewu5JDEBDl8ikOgqKvi73bUumvxkuehVgYy4IRXunYwOVwu5fwsLjDZ25XFCmRkKNsYk+m/PiDW4bI8iUk3BHH2/Jp8z79egweaeG0Mh3FsOixfD5Y8Q15Za29A4hoNAvhYHIB0eH5hDLF88Ej0LPo8i3Kxjwwqf8DcNITU0vuH4p++1WipvzH+2rYrtRrMsUnaN5g70245ZbMzuOY0NTMXAh8Tt0NrAVQjC0mmHn3iYEpsxm6ZZCpG23AZPjC8+FYf6/NspAlBKpNGLyoBnGcYzcxnboaQy8aJtI5+7nS63nYdeBeNwgptXE+4AJHrgzKSb799G/T1Z1ZllNLfuYwx1d4ZJKOceCWfK8z8uGXW3dL8rbluRQ7A6Qk3OyvSYE1ficU4jrLd/AwjYz/PKHqsM2867/DWdtHJJtsZKQpirfnP82XO5W7CDmCG6OW0T1V8Au/pUlYeTXYL5PsrWpp42g24J4De9RDJ5hN075p02H2sgJnqxMPAQtC8OzQPKK8GIVgwDrpKxzvjcnAJugtDB3ruDcOKpXW/g0iNWftlZLZHcUERl39CmFMJuFCOZP8GdxFGOJKZXReRS3c1kM/L3/E+trTyWZ5VH993UN/0CAFN7Pd0bCB1sy4/5ojj9H0AT6qKiEp8k6cqZ0HuN5aUqyThVdcEEcXzb9tP8AgM3gMsswlBmCrZx7A7TiQX8z1dDqrJy+neX7U8KeBKYeP8muCziQhPWMF31wr0L5HHX2Ujnn8ibvk/R/vAyqC4Si5jqCN53Pv+mGqiEo71WZ2EXegCQeNp+0u+kdry5X6RfEjVckH46GPPmPTJMA//EBNbdkQq0zpYLA2Rn4v5Tr4bl6u00rQHcJcWE/jaxFfI//obEcx2q2/0cOcgbjFhC/Yz/KcL+Z8V4/tOHDAzfE0K/eEs0HBSsm+m0YDLlv3Vrgj3JXNHGMzEwiKNzNNSAVv9P2+CQjRL1wz2pdnleFQsLQA0yvqZypk0kxA5wjx1WBejGy2KbXt9Wjx8OpMSC4Xq9z2WhlaFZDUcWcjCnYQSPht5S/jh+yeQ7vzRuV7F9gpvQI97NU/g1lvKd77hGloiulz8GHyKlGCOEqSO4Mqham4i/Dz41D5AAkUvM8GAC5ZxjgSstlis0IxupNv/5ULwMoE2yYcT1zzeNfGAIuu5IadlFK25c5dIxZxcOa8t28oe4PrWuWdIRw+R32tZijM+qZlHCwDtOLeteEmaKYxeBdPzNDWLN45W3PMe+yZ6IAx12GSf7dg87Euj9DEmJVj3BcZ8xYa+1OkPbwiiocxrAWeOGSxh9zunk9JCyJqN8AOVX0enTsg/tipthulqUG1qOJLkTzyaHuNQ1+bTeKsFWDW8rZwh/FUWUf3pn1u3QFZp/i4vdaBBMczddEI63dIWDZ3CGwNYyMVi/J9BNdTlTiO83Jvs28nMCrQtjWv9Jxbvji1IG+HnQb1UrGauAvgb7ReEMXnJVD7B9DGHu6QOaxZvbTyzyR6TAzJk/xQLYaYh5wsSMG3hq+O6Aq7x75NVj8NxmG42lorgM7/3VmF9T6C4G8d5pzn3w+N1at8CFLSoDUYpxE33SKZVZcPzFujOcvfr6Fy4mpI1pNFT++a/NB1NtDrpDiUrz1/bZBNoo8O2cKXlGXJdFQZmIQFRMaOY2xbH19+8o0hPFP0hn+4XVPdTxkUn3ox8pHvC6yGxHrTc+2veWd3czLUjZbyUy79s91vDi0F7Cb3vzHTLUrdrM+I2IN/PpgAuHS9daPo+yPsFKfl/qBGlowDs7Fim4Tl7urjWMlxTnmOfW86MZlV/w+jjhWF0Npc/+6Vwiw7vLCvDDnBvniXbuCbId28yH1I1Jd3uSyu1Oc4yjgjvZs797djwOePtlsdw+mBymjoBdQ0AFLWk0mpMxP/saLYsk3wK8v5/rM9EESy3d/ccU21O3m9JOqpO8KChvKhq+IqSVe6MpuvnEzBzwYwEY4VSYxRWmLNfXpzSXVAzAX14fFAJOrRYvzdprTr/0LE8hNFQ4YEqHQsyumKSHQwpXtYhxPaTHX4+mShz/aKztdWdUTe3yHkxzWmfnzX6s9PG9TTpPnrklRpIms9M4IEOLrO9M3zQiOpRPZp4C4aK9RILdwSjc2hAVPicQ1TEm3x54A7i9CMRzr8zgQoOL/cjem/4IybGcDa5riGMKINCfROzZuCVuzZMjNwD37NhJislSeo+zNKZKGr+s8R9OgVNS0xHC5ieIJpq3od++6HL6+9E4psNaD782m0AxfkfGXC9ncgoAaurMn6QFfgnxP/YW0OgAFpDfqqU727Wjw8x+0cBajuBuWJD3FBJZ4kl+YFiDXwKrLih30NSfaPbbB6Q6md4FVlHgS6ZPF8bw8p2/zk/vfJnspGjeMyrgSgFtbfZuWfJ914fcH5VJpRx2JX7XMcMno2ewHLUIrb9U5SAD4javItRrf7+qq6g7C2RjHJg12kM7nByUKVdL8D63B5oB2+gaxHu/D0vWifsG5s7Ba/WeZX1hBi4vOyFfBQ1/XNXiTKggPY9W9R3/IPjzrA5l7hB6DDlnEngNlxyXFg7gX9SdvFkDfzzIBbMgTAEcggawhD882XfWtpaPdW1gQgmRWRnLyv2fqy56XvYdt0mCbIIp0P230KEDgBZOhWC7IqHpUsvhWXpeaQ12OOtp5BCzyFR6KCLfIWwzCEe+1Eq9NiqK9c7DlTMgzboM1Q5Ip8knKR6vhS4OmGHbYnd2h9VrmLeF9vpMa26deSoit85b0+xSlqosPjxN2je7rUrUteGw6nPxu25l04NvHc+1JCMGrmGej0veoLYjip1IwEucXJGfuDtxabaJ9l35YxaPiSig5h/2js/jBx3+6TRz2pvIzn3NAbbXv3isjSHOpdawvJ5It0QXAlMvIer+nfJ0IXPEQFuf33c1or/MV5PYLxPyBVmPvZ0WTTSJAimVASqjhC4jMf3JtsHt6I0s3o9mHdh49dBa54+fMp8I6aR9YFdHwTVBAUWkm8TN2KGvF8SUMCVl+/XPO+O5+JnnQtC1p6SkyLqDU8iZxNjOAzkIF40XKdYL7/van3utxpbEHZqBBnPdm4KvFznjtxTlZrxo4Qfz/cN9+xqQpB8Z9BZOzfkgBpAFiXQoR5TwRlcH/0aLUiCdPdn9jkxtz9qy5+mRdR5FvfWPX519/eKVHntpiqvVBg+DRel1jY4NvhNFOCxmO1SUITzxqtpJDB8VJs7BKw+N68t37p4F/FT/GYBmk3x0lCoYvoS4y1tYZvtjRQkgkxagC6lNIv73scZwdny0Frb4TwJvPAggc5yIByGStfb6z92ZskFzlZQMyhhoXf0hfRTN9FBOKRad/uG+QdhQOCXvOGNb6IkfFWhc4KIe6G6RKOKZTpw2q6w4zfRzPAxXyoY4lHwjPr/yvTd9cnfX+wMYg+sZsbKHirIr2b0AfbuRCAhyX+km0F7SagCH/qmOJOdV7u2IFTg8L6WBgITqAeIpsjsZQHDdz0Hj0TkLgeW6D0xiPipJ8vOibiVbOM9j78JTKU+fhY+eNP/cR+DrQivPz7w7AP8fiYiGulb/RZuo+rscDeF+PyLsEz5BpUn5PYT8YEovekBuYbeSGoJH+RVzYHeFP0HW0g1/1Hf2i1i7tq44kHMpoj6kvu2f3ZJ5MfXbt8TB4L2/YEaeZi8VAcLA/XFh1rPrhcaZyPTshmmyHfTAwtSfu21X76yqGft/tN/DkEmC4lEp+KC3g3Zc01SIlHRX/ft2IA7Fz1Orhu7kKfxv9K/HNkHQJzt1MAy2Ek8P37sDPTJ1HoiwZVyjXk4L4XwQEVCtCLc9PZcXRr1KShmqjstdZp9ibs+Oz8w8cPu6DwbWLa0o1kIqNQrlfqDdREGCSJDuNTA1Tj21o7jgQiItgiFg+sgOF3pvIErHukM0tnSX8Zr45h/jVI1+Fjme1OoEhwVpUtcn90EPvNfk/E1dFpqp2jUaQwHhPTWnxx3FJ1B5IGH4C7+bLkJM0YvqqYZ1AV1BRsQgac4ZlnlaRhM5ayOdGy2VimR9fcfC5CbXgfyQldamWSGvuKtQXUio66F35sxgRUWXf93w8qadVidjeThjRFkQ3aVzc1xJG7iC48zL4uSpY175oEKVdnh7vdg0KKRuCgyoLuYSWdztugUkGGtMetTddtuQtjEGN7a2qJzSXW7Gs08+jfAx94frXpdcNOzEBaqThmqypCXNtsjllBNCFMRIXvPUoBdmB+5qvkxvB0+6JxPHwe1qbWrlv9xuE9KuIKrb3JyQcBnfLzAgDPZ/ar4BB5uu/loCJ6NJSmDj8+GuyP4TRT65zXdCYAS5y8Uw5e75oPXgmVXGk2cdTcym/NFAPg6Rc0SS7srjFJfaYvbj9Z/nvFOw2mC1VtP08yFA0ScUNE+eJxT+Qo8zDOY6IxLAqxwMoPCbRvdT95FP0eT/aDut0WlkgHtMeMe5rzqBhr0fV2FbIwV8mXDR0t9GLsNwKsWB0t6tE7x+UOFWzS1cL3XnyfYbkY9bsiqAU3LUwDG3xhNS7GClYIo7N7S0dP7C19jBJ3orfCxZU5zaIp9mR6qYpohJu97rj7jPzZHa7tTPB+v4SKwk7EJsDrJzw6lu93a45zapzudCcNMffIDr2UcBcFqvBmdHkhGCvn8w3rVXpdJhUBFNXi17UGa3h+y7n11lnJwGmsRdW4jq57UJluTFsg+MDx66kNQKzezCuRAdTVL1WIqvtwbbMP5J75456m2vNh3MnRiXs3s6XVoiT1IhXtf4W/PpttOt/mWMuXUj+G/isBW7JOWLHxv8ykzsmKaojeNpi4+lNMKsDdfBFY2i9sSZIzXRmmRupW9Dlc6BJEX2P05LUFacWA9dOPzEKE/soxORrAb092NL87dYUzpZvAy0OwoPeIPupKdOL1gDWAUAqrD8JHHUU1pOFClWugAMJZjM9rTRsPKjhDaw0G4Q5ZJgFMDfKnkcysBUsspd7NuBF9ULZrpIzWsoezC3IBImLPps4f0erzGYNq3rg/AHf7DhJfel0lv6ZQR605iaqdhslhRmExocVfLUkNN+WzOBJYXV7CAjQnt63AgiTiG/4mPgdjO8HER7LQwGWK0SE3jn1b/5EXQhnXDC0VFmxjmRtIOKJu4ZgVAIGzGBQMjjWBU8scLTuukI3djdi/DqOJwtbieCZztDV6gYm8jSomShLierChzNsLNfx2WitJZ+OnWzs30POf8C41KwJtjd7etvKsciMSbJhrdvix3C2gYqpjIqrwyDuBb0/bhqD4tsu9rIVXVjKTBF7ispqnuBXx1PnD971VGbVvmBt5vdJYOjbMjffsBnJtCkhfquLISmRV1E1kCBg66x1lC98GFzuaxFfvorspL+4HcFcN9b2/PwdzpZuIAnbMbWsVHVzIno1s9BJUtE6pFvB76OnzJLrebqwLWM+9y14AxKujEYOe1ACtd4oJDJcuYJLrMSEmMnhesBf1iXdH97ql84lXUWZSDNwS+oOPQPytmHCN5MGhuSZ3VV0d+aeI7aYUq+mgz7/G9JwcxMKz+Om2bYSzZ344hqwmQHwkAIF166mgZMr+KCKhWL1vDutg6Ahl0WP5YEGZxvAUwLrfWPNea5MoWvyl2BtJ+GUv53vM4+m47e1sNpk2wxKJZ1gLo0bA+ed+g1K4UUofhBM3ROE6ZzPUgJI0EPcj6Vp3NWsvQCMayu+02vNIG+uiRhu8OiYRCJAV0qu0YXBI7AIYehwSWhSjLbiPYxIbjRLh164jTMBzekLxTnC2sz4neOFeOBK+e7MCXAWbhLDrXizV3eJwVtnCrTD6auhRYZuRWN0iyelIkSQPTu5FvEu0uFy1solb0iDbDjljfbGry1mFGXyML2Xp6C++5Pt85obGTnH8SkFDWFZI1cuW3d//S6kVzey06sGWLFWTBgnFR3rGl5QgQVedpsccNjzySKXTo/DZmIhHHFFMDArl/W7j1Rop/rLp7hW2hiPaTXFWqdl9HoazgCk6+uLwwLBnZ8dffEy5bFEn9lrbwH44tnu8MLaY6oCdfp0Odfq1t/7kaGMaurn1SdQBJqGjU5qxa5qniNSiSMpHgNcQ6MPvhJC+JglGJrf+bokz3IH27qIaWaZZD8I0Yk7r4V2w6n3vTY0Pw6KtgSv1rGyPmv5CZ6wmNZ3ig1AGuSuoN33m/oykr50i8pCE650KMSoahlxMw6+JvWXO+PzRqjcvOolk1/skcvLBu52HasAyjdT9uqr6UOWZ1IulvGKMtXikhrCBR7st3ppXOtmDbd1jwwwf9kxc5V7/LstqckPEyeQzBUik7XRxuzJHzEPBPihAEZ6Z6as80uCGMu+VEbsfjRrhl2na80NNO/dW92JuL4Dw9PW4gRT42bvkl6wq2W9V7CqpXYOVP82Ga5LL+54nR2aiGy6/qE7MUSHQBmrHQFBaWtCi4H0VqQl0PHg3NkwbC4b9PBDVuCPoHalx28SGK5+IVIix4mBK5FP8y3FkHU57qWc3aaLboEjl88x5dJlt9zISgAuczDdgQH5LbT8ZR8dipR0cd1Rb1muNyHGBgUURk99NqI2kbUrVGnbaiMK+YAaDRmqgxgx9oYH0vdQcQG/9NCIc8g3pA43KppqV7xi9dIcLYuADy/NXV9xy7jOsFmWIZ+dkUYQgdaYLP3wslpy9bSsIQ368kFAjMQs/6pf3eeYugOqUUpa3Dtrlasw+xUGc2oFraMuEx3eZGAO4lQ8SulwfRoS++rP6B2UGwQFUnMlfAw+KtFSgNOQv5YNNyseOLvXr4z1Mv8N6nHBwIJ6/3T5PGTq9ix/Fbch6hRVdzbOvNdP/6m2RcYFT7o6qKj7ScwT9ETWpssAB5mIhuPX54v30cbTBO1XZHsIwx3yqJgQhc+ybHIiX4TH3Q/PMWja5qDFVbvdszF14bZ6SxW4TXqUai3KkOH4fNL74gG8mQYUBZs4cHVS+zrtOfg4g1/RobR4ivr99aLy+yoEEvgeZHVtxEFVIi4OLn7P7E3qwMHN92s1RPOJZSJTL8VfvW1+iGhVLe9MEedzYlgtRXs+iU3lrHj5IFzUoOZ9BtisDLi9tfygiz/rG9+zj9lwonruAJgKkFP4XLiPnZVFvtyGTp6/pOV2DyhTcbb5gjSZMx8+jMbOMiIVKUzszUIVKFg5WfGL2zM9ZJn34VmhyPjuO73teAgmqFcDRIdMj36lkCjsoLx8N7IuoyItS98Zf1hFHWRhjmfgEj3OuSQq0JJb62Txbf1tc3R6fxcGzgf3FHRNujWjVQ66Uv4jq1Q30K/xSPfTkxSrQLeegKttyZwozM/LK+RY/v9BtrabHp5jg7YiuhlLcTk22djs4oslfb6WWWpDTP81HbZ3kRyCNsHdktBj//BmWMY7c7JYZX7YuixKuG29aNR+Xyh5Eg4yg+dDSca4HktwT8OdE6ukI0JZsM2E8VBW19uJ43npM2N1e0J+hbRKF8nywGN+jlbAMRPcqCfxbz26ksJ25yDEjKgQOJigE8JH/uAz/uREtJMYFYoV8Lklj8Q61ovOkQwDQW5iivT/C/ZlerkQ2wKC0C7qmHCHIgTg6NhW7IKIuWRj0/M8Z7hbeK2Gi80JaSI8cGHaPPwmWW+ipE7ucg6y9VqwLzi3AAM+SI/c3JZaCHmw+G/+7BvXT6wJRzFZA454sKFBgP2fsLXXeqZwTppHJ9lPDWFLVCSHjkEf9c1QTYvRp8QxSmlXpqJv/mjjhNdaRkL9EnNrfEqKN0cFmLnZobUpc2BGH4HjfB+20MEIkchZ3WlTAhWrVGOYsvciUTKRikTweDbIHRHosrrm6ecR/N7l9nKWHtdZaz5LjDMp25jwpb9x5sGtDMNH39UChwaWIQ4wTuskUaqz4hKTjlvr7Vxyh6lqhIeIK+B2XFuQQD2UYUKP1TpD/vnPynLtU2nWQ/vFtn3tpfG3e6FqI4FPKjI/0sEQMiuIUF0QBq73kPlrOZ25CDcHDfP5PBHuaDceWk2vUAID7QXArTYre3Tjy2X77dQU8BqjH6i9vpyaTlI26uExwbhez3fbEtwdAO3RGKjwoos7BbZ4vmMiDMLEuMLoJKQEy93g+7dxm0Hb9HzdbdpyMu1yuh43R8gAFyneEp2Ffqd3Wtnwimgsu0jSTjjmHdqK4ml9DbFdaf3ZAj9XI/J/UCsRJ8FDwsF5T/iBccpTDtRLkF16RDyrtt1QF6WcDenqsJJIIrCQrBsRFtlW/UkoPVA8l17xMdgM63flCQYa+ucZEeZKCTmMte+wayIsl58lBTSKrUSSyBhXH9NRr9JmB9JgPkgNYUOzRkj97Bn0cOXHvNq8pwDp//Yu+qljYbUpVRjTbDlt/xS5wp5l1+yk0ycalGkGmeBncwLvCK36z/7hwJaU7/Fd0U9YpmkZNwoZcS3KCb+D5v6JMsJiq9MISovNo7ZWXbIUoUWf2CvlMHSvtOkLKSzO1WWXE6JZNcEX8vcOpfg4juXIK+N/neWx66UvjK/1G91/ASxBl4DSRfu1NGO3bqDDIOBisimtUpKERzx5CH2xrwU0HDx9pnUqmHJ1zbT6i8pyVy+nFL2gK2/o9CxLYFC0Z1VVV9Mxt009ffw+8F3TYcjcsx5hqO96573UL8vVy3yL/m70u1IB8AA1orBL4VkgEhgJ4DNkaN0IfDvhaPCpzAHwfAUUB++S43nQYQ/Ub0CNsQHyeAPYPBnSRzLiVbSA4nFe/53PwqJF7OuxQSlmkS9YMnC6qW+9e1ysBhgceN/Xyp70CGZfE1DuIhblAG/VhXKupNAaIU5nNKeaLyux5QUpX99Kx1O2Fx6ON2c3oiLN2n1H2LA+066kqBloNyvRaKZYz6Nc5KqrIEzjIZECYJcOXAGEfgpYA08qjBf1BbCGq6BzF+dgS7cJFqCT0d1inMKFGLn2vxXDYOv/u9A5vIXZesp2BTQwNOtb5FDdDe47KRUzcSq8MLbvYsPGAxYdq0h+d0nRJSJbaCtHuFlmhf35LhmBPAvtLwHO60InkVgAWy2Dm370DGUpEWk/D4oUWDeO3+ndzo3bdKFNtbSawrX9kuzy2hIMarxbCihyqEIEGAp62mlgFViuBxTLJK1Zh90v68rzXBHguJXbbdizlMulAztwLOeSi3MRO82sEuhozRxDzYOe/KCxbkujQ4bpvkwItManmnKAiy5b0kEZr59vCLKFuAN9iPx380Z7W5hbHtSQ2RxCrzTKokTop+ohUIMI/+TJ236wm4HVJMx8R89ajVHxsyAlT51Vwl+T6BCvw0seyek2WDDy5wD04hwCGFxO/nVDgcJ6J+GuufB2V9mEro5ZOe0sUo7FWtrX4G+6NQVyGv9odabVEKkCJeUpqzElnpHfncfT9IvNc89M9pzBACY88oXTZ5mNh+/wefvHEmkGN5sow2UiGo1r85TRATx81e/Jo7vfBZ+WiG9resEGs/kDDlRmmG4DuMLzk40uKW8kLYbDqk1lpkUyGMMSCF/NW4TBjPL0yM76yfG7VoMGhzqQNvaJ/7cpaNslkk5TdjJiHf5LoidrWG1wKVJg6oh5Q3ikXQxQY3n6O5lMuTQuwca/7dYumUoaUorrdc00EX1Qf9yHKbx0Scrs/fa/7bL52akVtoatq15vsBzf/jf3zHVU09i//3VS+SjnUB8clCPUB/r5JnDPHINFB+J2WYLmExC//qkHuevXUaGS0pEBZv1Ts8oCV5yAgoGd7RTV/qZ3t2O73814Q8GndaOBA0eW+OiQVfb2zhqknB7+PH/Nb8PZrDKkNnuDxUoawFoNrMqin6SS8rOZ8WOyJW2+33Dj6FVdN6RpYmcAwVl8N0SyDgafBwrf41MwZPNuM0FPTEziTdUuXWDn8kEUTmwVNLm8bQprbSN6XfSYmxtNZulWuT2f6HFILpmpLQCCzW6X6dtlS2p++MxYK1JgA6n2QI+t8jRK4cA4AzAM7BlfkQ+9bWQyI17Q4aZ8tVK1224JEJwv4+d8dWvR8bnZaWHUO4lRxe6d9JoqS0MXR3cLOMGKXL7QkeAYy48VEVlIRqSf/KyrLd4LzNxEcFNtjot2FlKp2G39Iy4qCZwutAdXSsnfZAa93kmNDOxEGaDsjkdloYVRqlcxS+Lg/qUWzZXLEW3Nlfg7u5W+kQkSSnLSXocLmOPtB67yg+cgr/mtkZScHbbvf9mF0hZfArDQ2A9PNart4+Q6YnM4Od0KoHI9vda+UWd7gkDNoM6HSSkvawBPknKdjYmrVxjgtfAPJehC67ZUmteTzPrJ8zuCvj20os8Qe64zF+RtURhjIWHzmjTglP331Uw7z+KLKP+8esXTYgx0iii98n+j8ADwDWnGjA26VgvJDxB92vH0ajQRLEkPRDEsDTffEk6IERoUDDUP+jzCfD4PffrLmUuR1DVIZ/NAf9NRwu75cfEGnIAxpNFN7ADJSFrpncAPW3AlLdrnUkSNLfGnEx0Hmcq+1NTe8F51mXp5aUSkdQ7IDRsboZVdogqtKvl3ifJeL1XSApQdJChQ+tX4u5OARt17O74EBMpKigldaZWXR276MrHQnWkgdlqsxcu9AKjaRfzY7lx6KlTmTmg2XrUGyn4Mo8/+a4c9MPkpRXh6FxzoIPtgGbkoM7SOMGlMY7Xo3alKJe+2w9g77xlJ2E0UGlR7LZxDanDV7GfWfOMz659txxXTdpBhYOlJUBkhn6RWIi7m1QoTr0FiXd4xLnDiFCfqH+IGAkfWVYHRhHHoK/C39NmOO12smIhrF4sxL17ihYI/alR/4dzEdF1IpZdOd2wJeMF5dm+VCf6plnUy437MIKNw5c59JRCu+G58zWceJhQbpMlL2glecPIptpVMDbXGICu0e9WggTl8b9hUL7H0rLr8oXsBnJdPmmvOcY/V2yP2as0XnSOlACnq2gKH7LHrKWyQZKwJm3IS5B+AFXiDQ/CJSJIdzEQtMEKA7rOV796v5PNAnlN5bNFoC+tMF0pYLIhDlRYfFgtoKaGozII5SHlDP1fc2g3pIf+AiFTnfYCE4xGHwwkMudpiZ1Sq9w+Aa4Rw+Y6f44k2qr6m0YSHEobfF9Ixn+AtkNC5WS976fsiSO8iecwGDrp+q0oFdR9oEFxnXa74zrPlwzrO8NwC0Tsi8O7t4irovo05y5EmoNSHnEF6sZ1VfUEKpmiBIVTp021v/k2N7TrtPfoAt9Kix4K0IZ1PZiC1gESHLjNmyPK+N3TKuMNvk1Cn5gWE6uUTSMOIViofLwDS56PuPCLzPVCdlittS1OyjrWmBIpIlI2HTkK7WLFK1KSNwenBqHKATWH1aT/90AH6HQHO2LYSrqlP0Y+H8b15iMJg/VVSGKlsYnHMJ0ureCDJkEwudejtgrcWw1eF2a/JmKtgrWqhp5bZoCuX0YAdaDfT5+AU6RAZwvydfiTMY2rm74aeAekeENq3DPU4zpZV25jYy1IBRwD8GQZMv88pT9c6gRNA4RkMu0ozxbTweEjfzvcGZCJGk05fglox+rgYyoiHqi4A7eccC13fRh7P7ta8qkcP+fxHFpDnOJs82VMXItGAsYuRXyszL8SL3rAPu+NMeBMhpJ4TeoIgMKq+Z2+qvOyBYz34fs1JJLhH+VA6/1K6R4Cwe+jkW1OF81dGAO5ndTGn9QRFmOQAWXE0Sg0EtMkQbCHJz3LPdE+Ba8eBimHl9f5DDAgzW1F2bpc5xejF2Mu0gctHHIN9SD2FNwbt5sYPyIUyDVIJWdglSpu2BJe54w3y107/0HLHU6OAMmL5ge2ClnQJr0ORvmHeK3GK4T48p6SPQEnZXfXbxB+rgLXX1MVOpyFf5iXVOYCg86mMO+xHMYX5lYOk7z6lueliicH0rkA+zXYCinwGex/DC3E3tVIS7E7nhW5lVtMIXyb44ccURUK+bbAiAIOYjtqp63f3e31HHgU7WesNPfbn2kfCyP/81ZmUJFm0/6rQyXI61wWL1UdEp5kpKzj/Dynp7ted0Ju/vDakAFuGKZuvpw61ccj+KUBV3imK7yNJO3DDWhS+WJ3v7ARVu3zrrE9VIrV+NoXITFQdC847hRRv2JRuwZIBZbRnyWPn68kXNBZ0w6giBeIaRSSHq+NfVOtnaxPQOq8Oc6nB4zGyRqfAMyOLTHMVBx9c8zWSvUpdDn+IZQBiLTUfSzuevt7CK7fUECCI8VvAEt2HyvsaRoOH4MCd0LL9yozPvOy62LjRgoLmV/zgh6me4sfFjYbAlbX+i/pW3+SrInp7lwSl3KFvX5JrviwUG4Pde+UKaEoQIuLZw2R3D5Uxee4M72Nzt9ZskJcewb8QtHrM3xS0ACzcaKmKaNUWT/4Sw0/fpxDKmnAEFhoFMxn9P+hjwtQgkvooltTdeQoo/ODmTa7oXFDI2Ep8f68tYNLWdhWcaxkB5IkY259qjdU4Z0rWIar9DCXvHiDW2bhmxalwFIQS8ueO859IS1nvZrwvE+e0gR8lQ+PSEaKKM/7W0gKWZniUa2UQjDvUSpkvD/+ibZBHXgFvcQaA4/rv5llc1MC+93IChM0h/IO7JE62R1nC6cGWwenVjtlg+DoRee1dPFvL7umDEl46tRb1gJNjhwsVXfx12Zl0MRbN9ZvNzKXlt1e7Yf1t0YtmmigiE1JnfnkJCFV7R4kLYd1gFlaNqcAquYNAV5g88rlejOxociw08W2ZfPNObwEZwlOZgaTBJ1BC75yllr4ptG4DhNIbRtVogW3Q0Vxhx8kLDotjaMbksfQFWaRTVBXmA3HQHCX7LZS1zAGbReSToDVAxiEyZhzxMsaHGas+32s1NAdHdeQs1Z4e252YjAYEB9scD9fTg0k8Uce3Crr7YHrKPcPTw8RNwGU27Jm/d8qySLGMeLunszDMYjiv0Vm1TkZA/69uMiNkpbOpNoktys9ZNdcR+N7cl4zO2l7cOSALtBNej6gVHP/BTle46P3AfqrwmHlN7L9lkB/ToFjE9KEZP4b+G1DFWpztMo2GNIsGbdWP5rkJnnzMRcAc51ijfB7H356bYdpOp4SsHnPERHzCRZ0QfeewY/GRmn81tG5mXzwddD0FbrMMp8iV0NIpYjYNTkDzXoEqavfoB0T0RIHtuoTaFHwCDvtcdb6pN4w/sSnqv6sfZh3GuctVzXIch7UqQsC/Pefl/QreAhT1TTyo5SdH+JDQ6gC1T+ZYkQKiixImmH5Y/CW5FZInAziqgzBQNuiOQI+sj1VjX7D9Gh36vvgAz1jEGqO2JR9rhZPsobqPd/NSjCxcXjKtDl/51moCjdJ2bmDfbFTNqluEVxLOsR/qyjDYUsovnq9OGZ5WIBn5ghGgQ5lTIy0+6XEgqhZB5zsZ4wCIcUoI3/IBI4c3IMDuQh+kizaccSiHiEk1xyXm7xIHHnUSBH+9kXST4b1639HVmRWh/eSlR0yoVxkiONiTHUt6tpm1i+R2nEoIniOcOErnB5vUqO4wGtWLXeegUnHD9JTWDWifbZr9BhPmz7zLkOuTzRknzqoD6z+hWlvCRAKSToUgI2J4t2oPqCYPPt+H3saYLZtmFTRoIHHaHubv/8T0hJ7n54+QontluRataUQHf7oO/b6d9JvVwSQiUxj9Un2POegwwsFrTCuzykikFH9urNQdUB41fvReeSdAmY57/F7RZx8fl4pRKmQOv1/UpYbRKcsz6kbFz6sYs55wZGtpcJDXN5f6b2Cn1Fy/rl6HHCnqS6dZFPTTtBBbo6/YrTgmwqPkNoG5oywukvb4QT6h/rIR0uBt+dEjeXuFreO1GMsWIwb1XHlZ42Qzi2eb13iNazXpmtGaNlg5N0/1/4+fHPgC6cZpTpdvh3YfY1GEXizF2yq3LA8w+BlFcxYmkLylPfDYO6tdfb17PFloexI4qGcQ/f8bVdghSsMN/dWp99I+oCoqJtH/TrCE+jA6iLIi52nvvoiyVsFcL0YT8T1igyahN6acAZfk9Sa/xuPyRtEHCaj54TcUO2vuKViy/DSMPafCt0B5rThBv5Tycpo/RDL2DwHt6eE3kL1aNtDnAZ7f91dBUiPxiFTB06y0WxPYVGxVqXtmcjIeeEzhmspg/eZvPpFYKc0/lgKWCAJBFzKf7WW+8p9g5+RglOm4tMaPVgPj7AtvtoaIbyhp7ebSqQr/HvtjB41wK9PAPTIRh06imsZ1TDsTBD4j+WwhrB/6nfeWRDvVHL1FYgFl86oCvSrLcFP21A3JYavi2sTXXQZMKjfehj824gPLSuKGEJEIPk4wsRDlqO+SJFf4puiWhCWC+4JdGLGG1NsudbrQxO3/rG03jSZVNT5kY9sQlWVR6VzUwkxHtTFbTjEYegTm2dcxyDSvS0sOb1a43hPBgBh45ZD4e/k7nGiYOHSv7X3ROOjaeSxekV738cicg3T/sjrIw5/tZLFGuFeqgyQH9Nwukj23v7U/7kzjB9t4a7ocZ3Avoj7B5AZkar40Avxf9cJoU8SK/x+eyAa4oWXr2UKXw0wGAD4uIAjdTucZHUACrZNotMBfPyzADOUf5QA4UcMP2jPUTTFLsgapWWA4Ir6esfuxCpmwuhgK55HPhABEhPlkQ/KQAkAgZZN8CRZGFcO8kSjxaSOAv/0sjqWtZ1H+yZau8rUE4TuL6/NAjG99YdzwgTANQth4Wl0b9M0Pot1j1PYR8uPjvfynpk1GNWH64N8EbVBKwE5nwdyN8it8MerGzL/ZBFKG9yTOklXZqRxgeAfijG6B13VAw8TNN80fqWfGXqe4C3XM204zn4BT26VDRMinthyEfFxDoyL3P9VtDjjl9NwQHRWra4rIwFDJdaW7IIRArBTF5ECHWOsBDkGuZkYzeJ7XdZSwLcEccWwxq4FaRc3q6slwgjcO1pP6SET9EQbegJz+/uPaAxcOibYKzlVUXRFiWhbRwhBokm5pw2Ngys1wg6ek5lJKv3C1SiTVtbFaxB0RNkoWn1VCOFBKWLVa4iaAyyWfiBB5sqHIT3U359GLpyp7YR05D/HJZspEuMrFGwrHVz9owwZLBvLJYhUKEgYdubam2I12SOFeDPAvF97RJWNibgYLwMGqOWH1puVuV8PxTDIBUzEq8QLY/g3spvERh3TY2yJoh6o10ONgS5M3Vl2gBz6GZv1leayk0W2ICDx01rzhGU1du1003adIl4SU8+17Ma0jfHdfaRKne8neGZ8i+poSCfaiS+90h3ptaKUZ1q/r3a6WkLeH5tJ8yWV/S9VmNB9f/IxmbidFjWxCiR4xl/cavclK5COcNYuGD0bE/7m4FeZR8AAOnB+4NxBaxblJ6MkyJRo/gRyACftqHTLQsc5aJeUvp9YRUz2b6hWkFaOzX/OF/GzB7Zwft6G006WClSmMYEMAi86oOIMYSZxHiaFIzem4HBhseEGeqq+AzKeyh76ftLJj0NctgLoPN/J87GUbez4PWSRZRoTUruQsWiyo5uouC2aiC5yAIk9WMRxv/X1cvQvCnlIf7cP0u7E0pktLTcQ2gqRbJLhzSzqfb4frhqd2uGr5aBVrDb4UU0FTUvIWPTMdVesH3GTPf6jsMo48tkcEVAXR0sOrtEEIYaGC514jVHfpGY6wv8JHEVuTdXFkkkzVSmwAR8D+wvFU6B3YzLj66ESuWeMBgNxIw2yT5mlxXCKd67Ofvrll+W86F9BJftI2uadv4ty6+CX0RmhX2cRrv/O8CVaJG7ZOGcCCr8zUA5v8X1qCwpThw3JdtU5mfICacjCgkelzTsbrqU0uTuzKpPuhRFSq1+X3nP0f9DCOHki2W+ag5CV9Ta/7t4fBC/nNkwURrP3/p5WETHV1tx/QhDC4K/Nhvj8P6ZMRL2htM0qKCxqvsY3SJFnqR/sSYA0iA0e1MMDToeKFhk2MUQ1vguNhWGPfjZvhjkiG7QBkETed9wbSveQtZj4tTXmX3lyhR6AV/VgK+44AOAqrsdKHCEYOvzg//GJOtSxVDf6lEcyf/on8m1vMJTXFf8qykimRQbY5ISjw+kVYr0+Fvc8kKI8okfmErniBgOEMSk4iA7XnMSHuULuEBbXK8zGwyRWW+bSdBchXzfNz6vDcDiNk/OgfJ4Re00ccySuI77NZnQrbUlF9gdPXalLEpcLDSDMIDfNvIRBdFdTGW5IDDx2FGQMyz0SvixJLleTKUOBjCZ+KBoBWE01XkqpW4cDM6vP+G2bpfr7EJj0HRuMBdI8B2jYD81JdIajfZvR4RnFakjkG5zeRsaIst3/Op3+arl1m9tXw90JTSfj6ddpTNHgmcAThe3jAB2xdmj+igBdgqx7VRslPP8LLEaNZdX7NK1HsuemgcoS39pWnB03WiFSo4N2K8argmoI3Ty66e3Y39EN7uY8s1dQe17L5cufVTEUT4jBPZUmkIaBoPUXMu6AnENsQNRoRdA/IJVtOBGLLfv1jwm2wJUY4u3tb09dma1+TtJHAy/5V6TD+HRANa1gL2RsDyvdb+ETKfsz+4NGTNlATx3P1WjFe5uFaq/Z1pGzLLO7j/axe30DpxOq4yZMRxdVTj0BhSSDRBDVeckfZbdjrnS8ZXzszwrQGEdtuyK9EoRTc9gYmafFpMBFMMzj6lEfThXnxuajDfizg+8d5RHHP47YZVTrpU8Ee21ZZqj6MuHt9dokjWvy/TCCZM4fNjKw5cOBUpNNeY1ZzeBZiOtpk6oHmsNSDF2laa5mqLCsvCVi15XYM9glAqy7N6qecIJd5jkAT19PlJWcbnxnKnKLb4fTRWlU8PFlEzg/ajT9V3lAtvc9rt8BNrezll9+ZxOL+Gh3aRE+04eGA5yQ76OTpvrc1+fPWSeS9B6AFuflhiKm0zO/I7DHI2UfLWa/RTxWHD49TfiSRziULpeHDQJnswJO9YfxSTUaL+jgQuSpWverKyG8xNFQsj9qPsWnjqnyg3BdshdhANKcJNsLNWkEIYoKh3iLyFwjNovN5KgbnjhmRV/MJaupXTf8zcvtRccsyJdEKL0eK+HgXn11bLodcZtKVcmpXq1WM/GAD2A8M5vCZfKR6D5XgLvW786cH1AzlPrOhf4vpQKBO5Cys2JDT3wcy4evwGkCJJHOyiLqMfNumnI6FBnw4wBvI0PIMLs/3zr9OANhTz9bzEkQ6B2m7n+aNlSpfU3sk/1K5Xu8MDomnuUkI6V7YsM9QZxSayb7NAbdzcmtprErWitz6BZby4mWYfXemFW5QTRfZAEfQXvM0pO2iVz7NS8aPmwWY2iheyuRGCKD+U5V1n0y4ZyrcHRln0yr/tTdeA2B1YO90uUvfLL868RvkkpwrkkxvL6HNMa5tIFo1c1E1y6rVf1nhiGgvrGp9EBGy0coan3kWZQ52MwZZ1S2FLvpxDCI4jw9Pv11TOsL3kDfyNaaRJgQvDDg/QneDUl0rDLYufSgM/94Ze99IAUfLQH+HJa2PodqtE7Ca739uatHsHJX0uhH+szqKeadrWvC210WNea3UgbbhV6QTdsmKjdnKMxmBdEm8YOuZ3nNlMzx4MDHCl9udrSaMDyaPaIUhfeGcQwc0oH00Nb/N1+yNa1sUPdEAjXLv3kn0DYLa67fUGvzOUXPaq4TsQBH0lgoVZctsXlQAxlGQ31wk28IeggKdPMXg8gtjehKdAWweMlabcCfB2Gfnf2VibR7aS+qSX/yXTZT3RtQcYkeidvEKPS9Tc1WqNRi2uru4FGMeKe/C/J8o7XtFE9Y2dg90ynQ8XOI/nSkv6klowURsjd12Rs5hpmSIQbTalj0a9t4usfG6hhCIMxOiXrMJCnMlFFg2MQNqk/RLxKm/kEO+KMEBPKTh5Lby5vmJFjltoPsXHzEzmjB+dxAZDogEqo/L6WYbf130j/1g8A2nJSmJXaxQCsXDgW/7sdoM5KLE8i2zd8PUDA/KmPomCsIkCb/q80Ia49N3A/1jn846O1lBMnAnLotA5QQ+hsWxRbDSloanmJs4Xa6BnGwoMpWNTePXqeIR7l3ACoVy4VmWlQ6LkzYW5wuJcnAfS17PJcPtKSIsjwG8yYoL6JCF+2DTkVR95dHzpfG835cdQTQq5TnBO32pcIKGEpZG5nNzz5+TVTARi1nE6i+y0F9xdaS0gFGaDaITYWeUvaFE+67fusfEM2rc2mbdo9JAINvrWVcvVGb3UJjUB1SjWSGlLJOnqpYBXivTo7VolRJkpT9AayL98XP3kNsorNyFp7Ic0FhJxTs5FYQgql/jfeHCrybpy8SyJTl6GeYbfAJMejIoNJDaK17WnuqodfEOVO31RQbhI8Lv8DTjq+wxfndbNC9FvRXHWjCs+QxlnfNXMQ4tfx0yRb4MuLEXy+AkMUPlVMty1WT8ZOOQGbpMnw/AC5uirtcFy0tXXDXGrPaQxUQIBfI0mJMIXaldiic9muGtYC0KTSqjmnRmfpKh+rSc5yIpA6dlk7f1Ne0cj5Pdk/rUdVEtqgwyyF/jWEMKR379SXfKdgwXcVd+uCtToESaGzUjnlWCveJHAsHqSg3bii1FIxzIk45vabdlvca/tgpnapHnJiDA8fCtvM8JcAsYtl9CCls/zGQCQ7pcDABRIaCExQCPTLTz8AHyVIpoC8noaB8LT0DIyFmk4AMSOJWE6UJbNDB3tdyBkxxwg+VBHj7NXh6/+WNjsmQQE/5tSx5P1V+Wcfck+6lcgDqDRynw2EPeQl3NKBd+J68GIL8TNt4tIeMaUI3s8jSZfp3wKO5PDKzn8pryo7TxB0UGda0cst2t0Kaj+zNfzp8MR62tc6xv8EEbYmI+gbXjPwaH87A5ya8O2H+8lzR1xQEsB/MccHsQdUGqMeqV55crsF1RiJiOjbqFj01W7cMa7mLlWNvzT3wcG3UwX4XKQZpaKWGW7J/+x4gri9sTkGbizIbzNqVrgfXzInN4Sk/jBRmZmzvnwDNaLmPEZ3J6mWkmYtiAukxghE3VmsOmvRq1lAsXnizkzYcvplS0jOeIgkvSY9uyBYXbE3fJmM7HP11ufsyR9OEki24pKkuAGHN/TWeDIzDz6rA8URjcoGqSbEoNSUcrhAt6QUSC31uLfW9uAFztoRGI61lf9mWsKnjFm9/VmBMODX2HToDSZkT3rE8IcAqhZjyjHhpHECps9HR++0ntCB1m0BqVmyzKrZTkypa00TDMyBbPHat34r2qMR6XRBTRzG7yjuwi30gjV9EpBL9HcdFmo9rSoiB2NcoOEOQDlhO/ZPZ05xEz8Tq1rVCGsj3H/Whhf+PuMAdLrWxhDRlTL45K4K09wZJUvK4DUeQumnKquDFgNw8CWCCyVf2VPBnj+nvVL1hh+bXWbR0qtLpIxAIrcegHfkOzmBcWsTz+wJxmEpjOKOhy57x/qxsaz2MOCpPiTa83mnCl30W9Hdqx6axX+leh0ykoneWDmJwOI3+BvJOXxRmkeRUTraKMvqSgrdqZe7S0ey8wOHoI1B3ioM3fOMzVtLcUoIWQFUNoCSwx1lTTU3nzTc8YCd/Zxlq51pQ8ZfQEptnLSbiNuCFE+zRGkOgIOivo8sXePxJWhwioqDZA4d5w1Axj9PQlT6HdgGnlcDK1l9IjouN0MX3JcxsfBTdNKRKpgMVUBtEuBvQDspTVDVSs0kSZSCbCeAWe6IKP9iQO/ITMy8AfJCbZWQJO3yB3Tb/60FTxrq7DfPi+2NdMC8PizWtSVQQ/AYCpt3BcNMMKIsgQKoZTrjRJexn5y4Topjj/gP2lnRqyRTRkgXC0u5OIIuSCaz4BOUksauZihqxIvJy8CQAExQAoyNx++CZQMjQMGhZIdBCyFVKe5m5HJaINC8sqaxPHE6LQLXd6h24IZz4Qz0SeEkpjqrCgkerns/Wproh1EswLEshXAKxuBzIeiTxS479O5y/N6E1Vaw8j8/aypuP3Y2L/YfDQelO37mZid4xA5nvNNaOmIVV7FEvemB4ZDScvpiwMF83kMozQG3qNdvQoZFp+sp3Xat0USzXzrRj7P8ufTimubHUp8Xdd18Y8EK9DUPY2iGd7YQxgYArid9qJTl6KQ4eeB2gqTupiTH+NSIMlDBnpe/uggBPxFrksDweak6GqbhQZ03Q/EuoG2paOkXN3hYVQR7DyIW7xuLBur1gwEj+c71YCypvTRhb7nsZ958sZc5BagI75FqHDhjrtlHaJ+pNO7H09Pbinh4M84dywu3SF24811bCZ+RsdXoA2HbCfOpHzc0T+ueXZ2sSKJ5zdAfzzEW6rm1r34U/FEiV1ZQsXPx/BjcnHGOt3AuYtMIqqGvM18FCfZXiOBccnuQ2iMFPjD8IbcrzT9TBNbWE7H1D6jgp9adfpGy9KueVfTDSXDRw8kGlGchljlTSOORGjyP57TItCH7bWWRkWX2WdHt/rUS9kTCxGxzHxzduC3R2z2zT0ifuLsi+6NH/FM4Z/WZcgtAZ1fG9KPUQdjg7hoLkeY1YFL8oEW5EE7SgWqMUa7GrL/DtGrfiz8M1qIAomuUujJB8M4kBDoAr6Tdj+yF861//QXKStVqZteZ4kK3yixKGHtpmEg0JrQK8/vC7X/vIzGwa5qMDvOpmloV9XM7hzHgFVds5QvryWdn3Vpm3eZUjQjvn2zY9QyavIIf/fGtTcR31a0v0dTu95n/5JLDLxjk5onVz7gg/Ew8nLxwGnDtWxbNypJ+0zZFs4OIIl/x5R2PCckYEtx03TthycOeIWMLIjn8EUP/BQObLfoaIJqGGFTQFsXDVui4YEA5KDyGcsd0Mzz2jaBoaro+by14F1nLR9eC/T+XPC8BzVbzVCMtpNUeMk+TRpoGpjKNslKNzzhT02x2N67ufCO2giVLtazcjLss2I3ozCVnwDlvC/V7Q0i+o4jTqBLouqA8Y7J4/Py6D8znA/tAZrZuYK1jMAD4UFNf/0MpE8y9Qoityv1tbBJSn68RCXSq1q4NKv49r49W/wXtwMr4m7XrLH8U5//zrUDtKkOTA5P/1kP/Za37CD2VJzrY5oyzsPvheLNG5ruw9bgaGwvzzirtF1pXV+xT2fdsOgszXPTLO5y2NLy2FazKcELnVN4HKWpFAlHy2bzXpD7Q1kN4e5B1Evjj1y2iA3AKldsceI2QUnjc8Bfgwmg8p9p2Dh15/NWBqz0Y/R5JfMaYu1DX92+45UWgUMGsT4ONnPkGM11eQGAbO0vpdAZkbuf/Y+v8W0xDP4xTvQEcLt/5hOFTkz15nRKQXOnJ/cQA2rxAbadApKMy+6/Hg9RvFxMXbvxwFHIqkZOTruvOQuvKyw1JwxUkl2VxVA9Eayjw9CijfbkXYFZ+Nwr3VSO47SGTKeQEcPkulhyulkYLZMpb9HfqYib5M7tt15aDNmY//Ncenr4DLeqvjmK4i9j/XOq8naxRpJSE0wr8Xi2VNt/8hZYLuevk6UK8bpfZdTbgLmq2YyjHSf5z+dUVQA2XfjvCWCucOWFeLCfn6hLzylWuenTo6tXxwYPzaUrRQn3l7qcH02olj2BHFN4ZfKWHj/rxB7QMtet+qXpziRNc6cVa3+JiMMpT9gmO3CbQewjh1SPvf5GSbtD4rMDM3e0a0hsXWVCDS8wwGyJv29NW9J58VpFs+CqaVaVFgdmv4iC7Ly5YHnJ+NeNYRsyUPdUkklTvrUV2Cths++pMcyN30j2n6sg34GARCQRjVZGwOB7qsJqwUrUeMZ+fRuSFp8VOQ5wWWd5lQ57oRCRL0SJGK9NQqmWhM7yjPEQ+mYknth9h0NR0iAxfvCOnOvupKiqIEcc31YRrrAKoZQt/2JSDsRO1t/cF/E9mcwTsXhmMZ8+C4wvEPUaf7Fc/mCfVe1EyAR1lK+2n66Eo8KCZAvgSj48QtYLyATQo55uYAbRjPkQmLC/gEFT9YW8/w8Bx15INk9iKoFrtMMqE7uhSFcdJgaVP9tS19AXH6lhk8JpV97s59/j3gR1LrflU2MAI14FZgEGMvL6KZIQVbJJBCS1hC4/tmdElx5Ob6LMHrXeZahYs34ZYGjQRkhHAKgJnL5D3UA2GAr7vag5y3osMkkZUHIQ4jmqjOfg/tUolT4r3uZsX7WDv3wHSRmA7oNscNI6JtUeb2zl0Hk4kukrcZJTHTi+BvapWOYCA03UuJGZteAapl84H9czqIpKw42GUknfK8Sxq14j/1I6EzrsFlr65fFW0lylUkuyQWu4w5H1TLfgElTYXfcpH4ewe/mR1Nx8+e+CCKYnSODW+mWNDD7HbX/7bAwWYoCuEO/fLkYQSlztGYu5x25zgd6fPZJo+lLZuDqq1GG4h6XwmSXZdmKi2pkjZryF3a2xHAShIxv7MIFPDFagk+SOig6BOL0+ATF4A8Z0HiVHGrHUBYK8B6wweCgLTYjwmBam53kdTxLpPeu1YAkDeCbF1DZVd1OJYAUXUHhOI/17YEw8J20PDNaOxhJEzU20NJdi5ZMPeB/f7ZA+LMxu3IybsjzLV+KqpKngeQHDwNZL3D3xCzxzGP4biv80DJWlLGfDGv8B4UypPOLOyhJzH+dkDLT/sQU8gZZGv+C42DJpnlUhEkdF/rP33AqGoT5QqYs+FBOB2qvVZtbonxwwU3CR0xmADStaVMgui/ntVYlcbiH+SYfShs6+yA8IcOYSpTA/DizDvcTVARQ5SN5yJPMgphEqp4VnjGfH6BNBt9PdDFIVIsiM8C6E2vzc53m62UxU7YuD4kcDby/l1h5ghV/3Gqx8RGCM0HVhYvdaqoJOuVMlwBeZc2jz3cDeFeFGvwnhlZVFFrPnhjhSZ+GIxvQlk15qBDpiuO2mo3WyoRSTTyKOUZ/fCMLf1dJVl06DjWjgkFlskEbKDcMFSVHI//58kHEGurleUCwcVIyQ/PW+f4JzXUdcBTqPD+bNBMXJGUzPlaTNo7BV9T+3BxUk8n243BtAQq+jMhOSho/EgV+eVM8UApv4Jde2UTznXzF0z3eHeL7C++0B1YpKO1hOF5/ud2mN8ayO42QUTwh5OLnT4QXg1OATSH5S4/KeLSbjyFEdx1taLbroGbUxoeL1ofjxxGRCfnGSOm1lbWuIoKPbF/sOoNCnNxD5PFeQBZ6TTBvnhPf89TdKy8iliZX1HczJ3Ihe3fUXJskjCbYvRWGAla3DCBgGyw4nlQrspsUP9j7VoKNPsVq7c/OnTZBrAzf9QAOh+dfUOf71iG2zXNz9gX5AgW6baU+wBeQgP/LnhutzdmTAoEcS15PFR8UXsldx2T/4A7hbr8pfcMHqxflJ1pI0edPwv6ikZqiqm6bnk8de6pg22pd44Jkj3YxZoK6vv2j1H9MhLI1zmt8Dc2I1R67y40yWbDauZBcPjC+eDIYnjl/I0yzwe5pW6t5mMDQDQNjMjlyZpfX1UjZg0W4Oytf+y7syRNJZVn8MRtvYhBTwdiTUmw5k2sxAnA/FtqPYIlZ86rFgLdQ0Qb4a/Fd0+WGfVJ0n9LGr+6VWIeiHz+lUwQkWAiD+phOMB4Tu9CkdIO/2g9Xg2ozSk04Y+b80q6wbqjL/NF2wsacJyNX/bpCJaROSI3nrYk8vWDksf/NrMmeJBj7F/hrZKP+Zv1LVGwEjG9pjvvvbdw/BWv4j+G7Ee33vfioOoV0+Qo8Jny1WrET1xcuQ8e4ctGhvB5wRNyapsa2DoOTfPg80CCnEuy4ejnFcNNlAU7QDHs17tGU8ZApbChgJwkp+fH7tyl9Vua9cav3jw/5GLg9FD0HJ6ilov2Ai6JsEP1nD1FMcMF9Qa+ziXNNqn/+81Pe/2fAzy4QEgDkXLTGa1pBwJ5uxxAYWJSRvSeBJt7yrMPPv6TQLSBmf/t4IYoz+iNk9d6xQmTPSg4h4hMDAuziEMiztAVLKWWOxyoDtHN7ubQ/YKURR+yR+27fc2V5ftha/eh2KuHP18iu2w/4Vv80iOUJzZsn47+4AMOIONs9LBw0bbI7fHEEY7Rl8pGfe/yHSpmXclHy212v3F7Q4hJL3goDNmJAnvH33Pi9u/khzAaGTfGl35Sl1Tpy2JY0oxdhZiGpu23HnBVjxfEhQ0ngzn+KgNSHnHH2OYWfBCMGN8kkEbkjqH08rZAg4kg+mDLwQ0HGzU0eWhfP/HinERktiCR+5Da0IxF4H1xzMk9mv4S0yFN6+CcTx+hQ0iW0Mx1cHSGbNi9f/cuqCMFSAdCGVLXwGKqBOTPb1Qvrf7qDVImM3IvxQvha59qK7lQAzpXHzauKO6av8U3qV86pGMbPiL8xra1veLjJrG2P/uSEaLFoK75oqnebn02fnmReiAttJaKgWToDS5FjdCmFI+rdREP+D1exkfnU6oGoQxZpLKM35pDb1a+/Zg+8gXY+WK6xIcHa1LEc58Rhg8R1XXzLI+ijUeCap1hDzNDK8GdFbChwpyZKzxPO5KOGxX2zEmDwTjAbumFfUteDyE0oppXudFPc0GAPIR9LAoTePhuWuPTIb0bTi4Y4SWKkwlMKC+Bm4AwMdgfBLCfJHNKt7uctxkbdfYjrzHApyEREJowGlfdKHrVvXZd2j9x6V9nIlDVHOhFjX4nB2diqMmouRK8ysBvgRuSq5rrbfjvIxW0GcsWFF9TvozP1Wt5PDzXjCWZj3xD+/KDtN33w/DQ0+hyNUKreYcLOaK/b9IsN4sN2y5F0RQFNbKvpTt+h70DzFU0zZZaHWgNuHZ624lloE2srWYnbF9Zf33O81JolO0IKkEiDVUC2/sg7d1CMG/XiuMEx/gpg0iuP67riSCk9dMBM0bxKSCJdsjifUs+2eUJFfttt3s39+If+zrg2LUkWUlKZKasSaTIrvh3JT+yqMccIH5a4ZvMtR6FfwGBWpmdN71CqR64YwcpXv+PnVM20l5enb8FB5yZLISu6TPW6W2p3/x9JTwQWyq1yPq0FZHQmytInVbV85cBSzoQBZXwhcGoQvkSAHep5iI8lY+uI4fpiEh1AjsIuvpTFvP3mNmf629dOoxUrOmQMrKlUqdhKblrskAzdHCo2CSuiM+MGXeGvj4V4wchrzEhEc1kFlxL23hQvkcEWQbY8gG9HGxins1AEcPjs6e55yQILgL2twpIe9ThFsw760PvD+m/ebwj25joVRS9N5ZvthnWJh3qX7cMK9sxCMuIIQ3SOArcl7s32fcdYu7br0t4bhzayuzWpKFTmVYjhlljyTooiKbBFqlal574YCkR7m8eDFZk7Yg1RpJFUmBRqFHOxj9yj1ChMjPmNPUnJ5FMGd9tXM9jsAb5i1urGDrh74uJeVURZa/qfag5PyffN6S/k1Gxn0OcfK8zcuLSaJNsJa0VXL7YbQlLAZlGofSPEnMDk1PQ9eSXc/BgM1ibSNXSbbpqX5Aehgx03KuhqAD6y+cHXblW2pk3SvWSEUE1yuRIscMjd/vmjb1Rw6fU0xXDJcyK5FcNvfCCaNgMftZBS8t66bYox91g6iVyuBcIdkHFgtVrx2Gct6jFsxNYy/tr8ucoLDAVNsgFbSb9PeKSX0s5XEWDeRc7CJMftxENUmdzsyPqc7Fw3nJuI2FLq7hYny+myzRIfGeeN+062s1HIxHeE2ZwGV/OcquoohXoh8cI364B34NJqnABf1y9DJQh0LsdMVtHCetPS/nrLLymULvzyLO0aJN3lDbL5+XOcBRL8y48oKiIYosJlfsaV0upc4jbtN6CwfXMRDq8NhbBodb/rUSI6VKC8X6xEgxLVFP98M8vaBdDn+uLOhZUzkYD4zhsbu/5p74axnYesjjcs/Wxd8l6vmzWOqnAHgG8t5Kl9i/PDOFJ/Xro+SwoVJ0AhrFThwjr9YbAkmGvqZjjdEa6c+k3nKXWwKMvW7tk7UKo4kAAuI3IGQyVddSLTJ+RukJL4T/XiE7KGYk5LqJ6QSqtYJ5itGBRO0a6ff6b6UynBiI3k156I9d9U8AEzpXQud521wKaChMykKrw0iel7VC1VwSs/EToc2vcNStMjriUP97Js3klb3ZYD9dQbDEMSosadfmgc7gk47miA7AVKGc97Gsq5YqHM0cEHc/SiV7+I9MVt5Ixl/W/0cPlnKnTwBwK/DgnOgT3shaaRUIqFLGeVUEwtnFQPSk35h6cLgpK3ROqQXnYyDZ5b6vW5gWYAXxxZPc/c4yJTQF2w87r6wlRLa7FyiBep78d17dfa0JoxjbOPT2OqVif7NmOSUK3ryBLcXAtJeLJ6YBs/9UOzsAPm3KLbw2MXzaR5lj+aNx+RJuxWVNkvOi94SLxPrimGffd6OKrzpBD5PLCR64mFuogz45YNTf1Cl3ZLUpnsJ6xKH0h/1LXQCHx7Xdl48trwzflPNVIoKDhh9ONE0AYBCiDHR5LW+QxCUvMyFm9Prh84JgNUY46C1Yb1tlNeqwrEuMkTAUJdvLkl0au4ynqcBYml7nxBbucqtxsw4s40dmtpWO40Sso5AUOnvmtroGbfgb6o32Ej2PA5CwXf2+nFn6lRbXiyhXW07AZo6QpQXxNpayMpfmZaYT8EspSQm77Eu+qoK3P/8zaRcGrKrodvexQgKL3prjLR8augf5HS7N2b9WklLdQ6wvwpl6S2CAWIYf35lF2VozjkHV1uJgn+6CHU+4wacOkjQ7zSqTGna86Rb6UK4DxHnP6Se2UtskvuW7IGEH+j15DJrpRXfMmErKDSYBxuO8NusqNchYge/9d2m6iQw/sYmGghZGkA3Y2vA20oWxCLlaZDY/Pz+WhkmwJKBbyTSU1bR0Rx4z1h/DdZrd2qwQF5uMMaUep5O7sex+ZdaaTZuYFLPpnV1BLVZcsNqBOzd4JF9ZQ3k803cT39bSqmkAC+W2zkUEUEwF/GhC8bMW4LW/pzviqABOg9IyUqdP7xeIAnj7wtXtdp3FfIKXUsLu9ex0fgALipwLb7of6fzykw7zcIZsBGPEvblUrdZjHkZRrPVSMAqmal1bVkhmHsOkes3BuP/002ziJy10A5T2Qfc+rvrgyiHe8q7I6lCsMThjw87u/+tXUETQDwmkZXIA6zCvTHYZiWMWdqDRgFUF13M1ZANWVrHCqEp3MZbS2g02yyS0g5QpsGOBCBM+A0FuRxg7Zm1BUhy0ud/Q62ft04NNAuV+fwSrlUkBgq9MtmTF85At2ONcsZCGv6Es3OqiFAY3z6bnO+C2EOaDa9idA+TCm/I6/6Hc2EIyDimiGSGJ/djViHJKQ+47v8qTAjvBh7TxhqWqPp+7G2soxLREO2Y2wE6X97wipmR0ZtMtWGH80a/Ab0AA7+7RmDcUvlZnf9gZMs9hRrc+9IVe87ZBodNotFEtyaj41mTnCCQ8DFhPZVF7ujdEmm42qoYpHHN8jRh3S9Je7wdf1DgKtLK11+1gBbso+yywVOeXjH4/5HCYpTk+zdJKdTZIRMHqdV2kleSYzL9qkEhNG2GRwsp0QWUq9dQa7etvgZmE4THKJ4VSaq1pESSp0YRIKiclV1BUHfRcqMfNrXM6IRFtq2czbmBtHMN7zPpjpls1gF+vsCg1Gf6wioV1Y7jMEppXfrWfI6Z12XgY3uM9WikLfDS1VakESKYLq3M1KOlp1GH+QAAedUhBIDtJn/hFA7znyY350qOsMkJ/iaktz3Y0DKe5q4MDdE//jcgug0qTgXPO7Qeey3hqC5Bdhh5bHXd2s9MWodAlDNNVP5te/txMxTBcwkMiIvcrsrT4wv990ukQNyslPi0t83jwJgST8kl1vk+iAa4PLvWjHQaA8741Hjem3CeFxUcBNTIQdY95pdWDGVkCqivYl5vjTy10zwutjcuyTEXFyaqbUX8PnQnZsJ1uP6Lo2kyRqHA6Fdao/XWeA9jftCSWbpwnun45VS89YQ6/w6m4n2/nlhjtsBWTC3Tmly1fgSQrSOE60El434BtaUpLRfdM8LkIgEpKUEa1QoxKZkapnE6mOn7MPQX0EQ+/xaqWsNweI3MWtJueHsVCTEGx2Fd7KTnRBLSRjMMOf1XMqq+TDGEO+GD/rxdeL8Ba8nmBtSX6iyy6VGSOFx3mh7gVkZbMzpzIykhka5+SVaBaqsHGsiUZd1yjUIyRcU4zQ3xzCoHiaVhKltjR0UPzWX6GDmuHE+qqEI3X8WwLbES40F0fM+0Cae1XXx9r0V94opxBxYTGul4FjEDgEF+c85TKum7E/AGrLSGD29Yj8Z9tLYlE64P7pcXiklisyGhxULYxo/NDXMOgnwIYQMN5KdOD4FzfVBaHuqbVFH+05i8G6Mz196dzrmax00xxi0FcXc8QseXGfDL3JB1jya3S8K/a9x16bvXkWKBeO9JXECQLl88GENHg/o6FephtAIBZGthP6G0UfliD0yuHZYS/w9G4gWmcyT2/8ArJ8pa49qFGhPUClp0zF171lRJwUOltM7byU9Yq1rkEM+nhftEbju7PT3oTI3X7IsArKIFTFVqEiioXFgo7NOuqWqwOZYA0YfiP8tYN3abQIPmSzzDwxMKce9LC6b7sWcbMSmaiOgJGhil+D923rnzUlz1QNhHf5fKIVEVtPiyS5xG+MCydexqGTT3XX8z/x9narZ+sJBVGjMzJ1HtDHXPvN50+6+3+TMNPmcbbsMplRCwaeKEnrrTiywGvg4EGN2u9U2nDGJsDAiNLWKiXlbvUClFs9hd9NUOC97fHSi5ePIRfgKGqUFZUbula9n89OBMzZXmMEG5IPPkaKwUVM3mLP5LkIXl2u2jWGpWfOSvcb6mJGI/iB30animh4YHn5FrffNC0DzTraXxKnyBcbHV+RijGNd4xiXN/0WeAf3Rngo5FKxDxqRwj2etv/VCyNQhGpJAThhP+CSv7M7vZsh/6/DQeqspsKnsPDS4i5S1PbM0WVBU982bB9KHUsOqyFiCJI1XeCiePIfLkPc9dMYceQ0NMYTHj4/8dOXmXiopE3xp8Tt+29ub4ZIXe7AaSoFbFcr2AUyCiVM7lG5FHnxTqwXCTE+72mcpHU9sEl5jUP2YWPIPGUtqmXzB05ghMlzqSh7ebPjtxi/9KumZ8mGLX1F6v2IPqxbdbyO3hr3ETrBBunhGGt0QJdWUqQCtncawDQAhmIsgna1WoXl0mg7Zrrq+4MnHHDBmHpHvv8LZEDwWmBBOLfSzQvvJwZAGgw1xQEU8IrPh3AevMrkdVc6ifea3Z0/CMvMm6BdBnY8PN2CMMHoQIHmSIb+ZoWeYj3fztOy6NkY8sRrEX93i+l406p2revndAdRuDMjBlWE+JaqK3/YQiEyeMUfd5adEW+S76Z6r5Xt0zwWCHKZE5qKLfJglWtkiUT7K9ppMiIlOnqgv+4Z/PkWhhZ470QdkXa3pcZntMwOlzYvvrtmhA3yrS+c7dFsDINR6aIrhxVRBlaRE8CvxywwuRG5T5T0iU24uzOEkOgP5AyK4vHpXvS2egOMf9BIliCzQWtn0MP5zDE4VXpLPMiuSa2P3hTCfsP2yHRE5DG1btBwstBOo99pw159XrD5uxQ8qe5S2J/EHc+Eq9fw1M92tPd9YVTgfBGUSPd8DZOZvufEGt048RnrpI0tTw2rTH35OlDte5gp7c5iWWoAEo7ZDfblB5eiI/JNq31q2kYdbnHe28g/4N8hcAqdUGKiJBhZE+pcOAMg3Z4iAgQqFiMVM9QfHSYei+mWfxnR3K2ieQCIaztH3BwpRdTQZjj8I6WccXdZHM0keAzUi7DGYaxBlJc+hj7E98L5eM/hl6H2z7F0gSuDMJ7etg536S4vaBTkMlW1o34H8Osatan+92lEmnOLqDjaIXLIT3eDH0zeCHSY86woS4g5hPU+bihXURgZP2QIFFnyGAXEdGGbn0VlMEURxk8w9JdcUQiiLTRMOi1E7Q82gFHPdi0xZUXL1/yNh2q9ngQPsl1JGKaYB3VP9Xxd0CVg1fLI77rz+4LaLv4Ic+IRWW/PAbY6SulHzYumtc59EMTYM5r/TYhu/xbyRe4I2kwP3R0WgNNuoIneFtaQLe8d10q2coYGnGKKnQ70PaNgGf1/cRQ3dCTTvqGgRYT9GCAX9heG+4bx55s7nhtkqL4FOXg9rFdO4pCz3We7DbraYThGQZLRgSy0QUlENkZxXJsPoL3MZz/rlfw+UcLFMZlvp8Ky0AhvVDbgtKJ0+6VNXKIzufjhFDyOFmyhKvvckLsPXY0y01Xyy/bqiCZb6LrW1N17Yb8Ey6XjZ7v1+lnHTshrLTyKPX4ElSSNNpJEoOp0hLzlgbgbpGkixs9QM8RPs8WZuTdIkdz6zuSU1+3nlQJQPjKiEuAokiZSEii6h7j+UhM2igh08NlYfkWgHAnVP2TYci41cCAS0NUnsYF8IF5eAclrhUDD7Ssi7B+nzFnrhSqA8XWFJnCLQDqSJ1hjZvXJNuD/3cU3aGRRuAJ1hds8PefPgEDLaDR2Q4Y8G5nItmRiLvZIPgsb56m3VCw31o4A8Aq5P7WbKeHAA7U8oRWZr3pVR59ZAwJ/98Chgz6AeQ7sUEWnleRrpJVOGGRTtr6Gj8FBfpfKhFIlSHl9u5uUpicS4B3tintfS4KcivbyAwicpzZQ+5/+K+K8qpqWpykY6i9SLC7OiRBjhB7bW8cxgUlEO0OZ53y28pPKKSmIKKMZ3xVMZO055Sv79VmxpYmYnBHCkBLKAGN129LrQ4DG85Jd1YPWW8wfPk+/Ovd946uIA+22hceiATVQYypE0zng0kAflYS9CSWs54YDMsd1b6U7iF5IUfafVqVjUQUmE7p8Z53d2mvvlYProcE8RMUeAumRJ/8pSJw1Gi0BEUdwhNYgEQpDM9mO24IqIr8caMqtKXnaWw/OpOYLEONE7gl4iWKBB9foYYthXyNrmvyqiQJJKUx5s11E/khXhFXAUTpTH3u7YeUDh9PXCDDfOjX6wWcIqg32+wlsZtu/9T/mmyMCg8bKB0tlAvMUNDSVLSA23rvuwYsTB/7fTTckVxyV1f/tbLIzneJistdyRP3BXeaoPwI+6PJ4YnWDpofm707EOcas1CWdrVKsnaPe2bImZyMXnn/W/dDEau8tkS0pSaDbMnwsuMuw8zVK34rHKKOnRD4JfoCYdr5g1soMq0bVD1/BASfqXMcdlj5v4lPboBptbZUrIhvLtLgCNVuzIoUhJsbpI6furbnb01WclOy26zK6Hi82LxJ+q1EmgDHTPlvsB8giNHlTwmJ/CtEiSFkUF/nmVxI2KgIwtfYWM9dqL8zMoB9/xdnhsed7+2DiM8UgEKdRwu1ALuSpoKZfPkSOiE6ibDzed7/PuQzSzM1V7k4cyM4um8jkT/DXEs8FZaS/g9X0+eKA86Z2ryLL5ZrD6A7Y3mtn7rZOPLexKJUtigrnDJ4Ju5Q36UCTfyFSYSK0Jp03OePX3n0U1od1X4Rubinr8F8wmfZ4o1S5I391qnVL1tlI2vnRhKI1hHLxytFGf3q2zh88x9/h6+brbhgXZ44kA5rrEaQPxjX4vepTJCn5oTinWB2zIfJoLm7gMwtsvqZI3GHRIdAciqLoZjHSn77Fs8LvKCKp+KVrY2AxJPxjJET+mYaIKgIYcvPlPkn8z48Pnn+l0VoPnSN+fBJXK+Qfv0CFSUEOHeaQs94/fmBrytMFzFc3s2+Nozi4gdG6qcIX2E4n5XOASNT5iWkwmPbRO8kWdoNW9JYLwcdV5jIzWg7c0O951pXLyt5tSXDyJtT8z7OPevkkXaw1qZsq/yKVeILwD4zkw1fFyF+F7RcaQkk05EI7N4A87AUeVYzmnQ2hpAjcHjrQmcloEwvrueYFwe+9kz8QyQaTmlsGg7s4rzL0AfgwGjXiviurpwnj0i2vReJq6R2OfI9kLNp3r8WbbfQjqtGrmfKp+e6RQFBIEAYuerplsPay7cVSE16laq2Gw7rKQIBaeu8KhrhA7pRvrUCjaaYOmg/ucC/0TP1Uu7cfqcXBn/H6S1G5EZL23oKzutvoeLXpFTVGrV0Gf/QzzypVaT+H2wz1QhlV97EZ1uGfi+WiauMoNkvpJ2Cyo3UyTSRmGZTbcWPIukK2O1XOC5YwQGeCTJYctvZuGYH4F9EE7jnBxLqVrQbJb4hcCOEtIsY8BB/+7T1AL789nLm+TRun9iAbnFrHqbwHxNQjaIv20qwPtuJDDmU0yEWs2bdv5/MFQSdK/YllAM0PJqhVsBsre/khDjpfeEg+yKgxC53eT6DapbDF21wNFZ5kHMWC8yG6dxUsoopqbO65ih2AFzpXmMGeG2KqefiM01r0C1cpXJkjfhTcUtHlCG562K//XpS0kp70l1Tc7sQfIfBurKY3LRtGwTbiVPDAyQxHHK76dwI8aYMk7CrE6JWYTxOb2shs/tpYNF8TRWIDxLAz+SS4Ec4WNp/5nRLJcfu0Miw0cmtwFodwi7z9dkMaxCDw/xXHY1ymIa2P8ZtFyJrsWk47ggdfwj+bpr7zgDRcz/7LsPUGlYy5TB/hqJ8L6KmmB84Z5E3bTQk4B+0Cyrfl1OsmRxycUXOeBYfQOrTe8VLMKZhcPIvsWK/862ieLxD3CqNP1hPj5+fyq2J7jBNjgkrusO1wwwOcVdj/QttYvZFKgBHy0SncVQ8TDXcCv91BB/xkgSy9V27n2+I++Q5QDdnbgd2ESyec8S+9MOWpBHcsDT7ROuHKTwtuu0CRi5OfgRgEbsEg2TRD7RtWnLIdAF9ujHSGK6/bhZZWHoGuylZODDynVSUZjpkonQH6caEFq17a0lYRkIOaNW/9MtXbr1H1sSYQUR7DGTky6/y19D+KD7OWXGiIV97HsjMlcl4bGnrvDjbQNpXWzHeYVXXZnnfu3DRys9+J+iqzCefdN17aMfW8x9rJCWWhQZBSTWPzB/MKt960VW6orhAFKm9EejZklQr3L3oJAnOnxhgDhxppn/Qu/Pvd/rYUh1c5ssWxZFrzZpHGkScwn+9IHhBC9hbqKYHUfOvQq+6GxOpgAdKNzNlHGEpefRDd682Th/4Wa3EzK8Gh1e5CzdAy59B/3TxRD6zmgXnEDFr7wBtM/ks8IRpWBG33fJCO7/rtXCchZQ/BSZiAEdW98/1wHsd2Ry7F+X+cIX4FFEOKNP5paFcRfsS17FJzNzvuItdMfnFXY6w/BOeQYWpcURjvCz2PISgkBKkJoe0MbQMfyiRayn2WVL3/9S5oLItXZQqn+s+z4n0WL6/M9tZ367NrwlXGwkPOPaTPhop3weo6eW7TdrvsbXYR0n6XQ9ATtfd0qYS1G23oMf13dm4eMfjC9XBCvkmS3KJ+9QIiNLCaYCqZA4I7coEhJevXz266yiIIzEYdHDmwtlKhrQwPWDap6woHUMWlDb6KnHjXa3LEyFLJUtul0t1/pA0TNTqyA8hf3WMhAhI6lsi4BRiA+TJ1ZhA91iq0TTRi7xfb2MKRvZ52uP8Ht9JC3hhV7r9Uwshj51nFDr0ZTEsxgLP+RBpT/RUc1EHmrLFzOxVvaVpT4T80PnkiSXC7LAE1rZT49EXykpAoCjNyflEAyjDRhByF4fnPcVMRAajARa79sVqTrAIMnQb/f1/vH/Ozjt1MTHUIyKhEvz9PBe20HtRdm5fRkSEZsYHPe0wQsY/PUavkTtpj1KhwwL68Gr5w3nCyw49UUy2IpcOYr4G7IlMKMS1u/dMoMUjYPY8Eh5b/OTeOBeSlDgfrx55LWvEg9jhonuEJATkP3zfih3P8rTnMaBFjHe6k/iTbLRBgh+zn48m2I9bJ4ui+tx/PDBtN6pk4Dkj31Mo2QGcKAxMx0jUGTYcMypEm2IQ7nePD5JDXX6m6BgK5XI3cQGM/xnaUU9UDovy3Fm+y+FDv+iE2d1uhzqn7tWklpr5Aafy15WyzMtA76lDWM/HKpKd2gbjt5CuAIA/ni3nHdmYGi+ogtdh248QlKq01xBLntNe4DlArr9jSpWI/p2Qg/OpOM7GTibhyelet1NAu8DZ+fBplge26wKoNwXrBJZHyBk7M7L9FJr9QjXU6aaiPahagoDU17hGbJUdchwWbBiAYPDqH70I/dK1YAEDEM+xjNC88Fy5iV6WLLp6DTvDMLrI2sZK4EnTz6LQVRMZJ2ED8Od4M5qxupBON9Wq0qrCQ6AksR9Fdqn9Bn5JFKLUWpbWEk9AQCGh9ekJ8VVUfubf+SJ3e0PCgOUq7gSOSgacPiM3PPAMH9l2sL2fZtAJQpLlFQ06SqzYxL7Cu/pI9bGtIGGCYu0ZLaKYTtQjXjntLsOIxfEkLaulSFobWrfDqBQ8sEoz0O8tecJzW/CxP1vk7Qim9F/zijm1w80wI+UnzO05GHFA7gKCbX8CvYDJyUfV13yYPEBywjv9nsAO41YHtmryIGG2bNMDQ8NL6HttM7VekalemvhggEorzpKZPoQtJXuSlyxd9B//ymHAiS9I42p9MpL9RNo6JJyTNAGISKiGZz3lpAb4JG1oLppx7kc0g+UNc5B6L1gGpzytPZq/PtP4bnC0s3GyqW0IvtikKxQ9pDSQTRJVkqvzTXc97/EAxJjtaP2ZTEEEXIngExrO0hotb1tnnoH/TyEWnLnjI/av+wrqFotrPeIVY/u82xJK3nFoQ5FupwmzBS7z+s3CZ+ki/Puy3/AipSt6QvsVPWftMHGABqSACvRDuRM5iQjAVBWX6bbzcP+ozZ0/U6YvlkIQPdDZNc3h2cEgzmy9on4+CEjQHKYHHEJPT8tS0PX5FRTOOXr20D/AFKYeT8Kjj1lEqrCD1ULrZZrQB4uDxUpmRF5KtqqPWDL3w4zOY3yJieHNkYJ9ewoHRph6DmCKbVNhOUlH6XEVaGTf+qyUN735VTHVNejU/nZI937DdGHKqgh/9QydAcNnmb8Eh3cYA3oJxc1I858fIxaacFL4I21mXrVi17FGow982893mDnb2WSmt5LkXV3Z2/nHKOc4NJMcfsUtAurj5GeurwDhl6QPy+kVUculCwA04oWqdSQKG/TGZ87UTgNAueu+BX8YWQvsdS8jSjiV8rhGFbaUAlJSrWYrxUDqcgNQHKmX4nPkkTZLV80z7gJ1UcMg65rdjChOGBL7VpeqM+1Et1ZSmddR3jklbtnHF+hrEmwMYh+dwFBnZSHm4bQrjACFro4zW/PBvALaIJS5g2IQp89D2MsiaG7rfWeOzbkm9y5OsYlnaPLu/hDGCVRIEYC1gONqIy9Vq25kAb5SwTbyhePXaRe2p+g6SoAsuIgaBVwYJjza6e4t2mAPAQYkVt4nNEnXTub98P3EsAornpZDOC/au+YqmCatMZiX+QqGzNn6QMTKpLGf6tVw6hp5tOaM4qBco2L36wIXsQkzAWE6snNmu3uDW7JIvKyiiUupoAAzwa1HeKU7yDzcQ8ysE7VbHu0mMthZ7+OicDnM74lU7SDFBI3ZZaQ2oNBDZ7DqCYeF4JFHWIoZhnlnTPBLTvHlNOWLGkc4EL1aVNZYABUVOMrPIlN5UnIFfWveQ6uC73bcSHUqZ6zIftAtw+kELh7wAudqlI72WRhxfXk69rV3DTncDq3NSUXdMc9nBPsmsWoysNXy1iifJtSEcuXjxwkVZ1loFfv+cq6ouOeRR+Lk0xKWGH4jcYHxvxJLlj6BrTY8UtunhyXhAisCbK5Zwfduh06yTA9lnUDyLHhJNivnxI1+sAWNIJpX0lKDDQz1rFGINWtY4Isajx4zbdzyE/+xoIBsl72jH17UXQqVjloUM0gdQ6jt6zBgQ5HuPokGi8Dv1R39mhkyGjfCcGjF1IPJJDRojJ7QictVKVCW81KzdCOevdCgXjBX3laPZvFU64ljPm5SmUHQYCLsMXp15wq9Z7wRbue7CmGZkHFMglG5QyVGaZS/UacFIEAZcguridCFzpMHgOVouzvE1hqS1PTqyVv4cSmFmAXTDNueqTr2VxG6sx+5SmVkOBtktj7UEaCmQKIepWR5UebNH+NRjjwobpY+eYfw67t/UMTyE7/qdkZNLWlecEju69u4RrznLDT11Ow9yky23qSogIWKO2jrLcgLQwRaXgmI51mfh0Q+vR8+6t87d2HZ9TsqNaRNJqUVXGwOpnF+Pp5/5cZzPLodlcnTL69aOYO1O8Rdi93SyVz16YNx7Djp5Pzh3ZKI+cRUgJyvA7RMehylgRQAFbSD1Tkr+3obTbRP/KzasD3Zl5YirDsFp4vyKM07qQRA/nt81ltqr86Apo7NKkGdWjxGMI1Tir8M39U45Y4eeQNps67xTBHBPxH3MmX4OGgzBA7sxpLAEdBKgRmeWQgQwOaxXtdEkbYqIgNw/QLpgcyJgdqrMGny4V6Sv5Tad5g0TpgEGZ/s+CCcQr6Ov04RcUGYQEnWjkZ539WHSa4GpGiRJSgPeS32uDNTApalrVl0fMF/GCFvVXpw2yzdKipGimkPgKhICRE1GMQjNrUo0TzYarphRm64W5fiH2VUHV0Hzz3Ni9CIt7++T4ZS2PcKC7PzWoRKVwJjejErEBRUOEYprMCux0K3gjwTg8GjOkU9BI6kko3waCfBbReRWysVBCAkDzq8mrMbOZ85eRxHnMoONP4kWzJF0friPBvK95MjnXY+yzs3LIVA6GwmR/zxKAbUlrJ8BW5fUnWkajoIBJvGW3KqBIJ6wbovkdjPFnKcseEu9f0sH2x50I/lkTY3KC+BUghYPUfeza+H90gtvXJ1yE94SyoCKHsN+mK1Qo0R/5CPs3WBLpfMjie3T3fgL7prjK+yEx8eiFJpPTIOaHGbDtBUSnEjfmmOfBW4hiBDp9imS5KDE62dx3KtnIx80y6JlsZvyhLQ2NMOeTudvGROgCrCA5os3mWOMkCuGgdfjmiy0fBZfNKAtfQzeJ09tfcMxjgDHWDXiQJbYcIAWhmb3uv1ak3QqGkcHLvtfk8edAo27N5u0MaRPoCWoY+taWZG/2Pg7m6NRvdts5mPKPTYpJjAmr6mTunG/PreLyvMzZmJimAm/gyU5+xFQEAGU5CEBgHUD+DWraUgu9T5FPaHwbE6hUA3lfFRtjJgNcetLgY/eYH7idhiu6xB7dUlOcXczc4PhGKohuXZ2rUP/Xw5D6cWej+U6HhFrXnVoUlc2I02LUk2Rf4oR2Q+dS0pW2P5k6dIeCYtBezpV62Mn+SqBil0t5BrjYTwz4dN8o6wvaZt5LWr1doslDEudFA4R5yEWrlxJzRmfVeGDwlul/09tZfHDtoW9d7ywUPvgpA0PMqvs/itpWY3L3hiLccocj0yw5VrQ0FMckUeynIWt2aHe0fgd5+ssYNN84GHHMgWYzNKi10G3gBaf0oCn+AT/LuLEx431SxEcyiUp1/27AZGj/tJ6zSQ2k7VDivrZlzoxM8d0jhtzROkOqsJVh0Sp0vA5VBkVDUxTBs3F0EcWDradIz5hEMnp4gQ1upghWxrVU3rtGbKbPNQRQUS0OqCz8nE/LmTwPBrTiRGwaQR3SVI2Sl1VvXtv2FV19cjmEsuJ6q7lFRdoxepWqs3+blCQZSdr4MpeCiUznn6b/h32QtoAuAYYYNAfgWWLlbrJY9gmRV5VqnNGtmCl6s7yvzf4nvtX87iadkS8kDrgkrXPfUduyeqkxWXzTxd6rUkFpjSjdaBe9HrOnCHvbqZvMnYdiRIDA90mcefuRKQ1vj0IRQdrFCqwiuHKyOqy3SLfGGTR+PDxU5Rij3LMZpvf37F+3q2M4TmSIAJ4Fpy2C+bV+q+PZjhXQED8D2QAfcBWvtia4Sab47mO3iGbZnWxnnENOkKz8tK6zXV4XZmXmqoVL8zkuQ7U93CfhljdSXitsMKRDkKakWFyuxkW+aGmMqmBM+LNdaQDXoVPBJuWBgH5Hiaq9eGMKYvltw2rjTLho70om3ACpRf5HbjyQaBgJnX05vH9Bo7x/SJ7VBBOfquGCCHpGQvKfjRddn7HHGPJnfjYf9rqTIJwS9KGElODT4/cYxzshC/zHbP6o8ppaw8i5KJqDCS/040hu8kZWKnJrnpSrrVSzP2Jyh+fplt4Qgm7sZBWExNT3VDxF+W13XSp9yuy4DZTgmvvdFCyH1xR+fQOsEocGCW65yvhCjhKqhcNSix3DKOJ2s7X5Fv+hC4v5XI80Lx4wNO9DCrjYQOm5LgVQZsJ8Fxez+FxcZOvn6gF2vDVM2fWU/AGib44wzmbKo5WtVFZCQnt+g81nzulo3CcVtJYEVQg56ourbz6zVFPSwahVQ3mMLsP1s7sioNTIZK9Y0cVxkbSGGM58I27U/HhKcZ5ZvTAuqlEW5uKg3lWmdBb4awe1JvUWa9UnrhNh75oZK4EosqeuRURAHKVzdso4Q7on5hXznT39Oc2ji6dyUuiK1MsYVEAE5QyzbBvGN0H38uLeeeaq3sUYreYk2Fphbbedd46SWqi+6ZNu7IW5saSihCyQ/xAmFE1D2feHTGV1P9U7GRTLev1/yQzWfjGYBfPbWTYBie5Fc7TtsB7NmxmB4z6KegCRXu0BsLWV18exruIWA/Jk2fh//3Bbj//TVDe21K7nmcp+SGWC2SH46XVdHdC08VTGefKWe3kqEDMBPRHSNWbRgupzb0BsuqkZjahbycoJEtDoQ8ZLg/bL8Jz2qq8RmA1XXFR7EjpunQmIfhhbNgZBMlGfQjmQETYQ8caPrpC+6QyZXNniz4JaSoAYmfo76dYFToab6FNVG0UlVmh53ji/Nz5branbSLKszFbWyhOWqpINYu+Ok5dnM5O0AU3xhyfgNQX5JLG6NpmzKwg2Z27weL7P5n3wKnwK6cIPRr/e+GXnhTqlT17VDlLcg7sruW4+//uVIFjN9vG2bYOy+EGDmcusvFBEoEDvKroGGxYxikzYkvv/dFjldbD2ssXqm7QNi4dJqzeWgtd4bLe2zjejGXqHmVggFjEnokr6fo2PY/W13UDy6pp/qOolTUWiL6kYZWygoiffXIRPJRWeLX4kZY5wdBaR3Sa2zSqDkbs5cNp4xJqNpUDl2zY1FXW6evcrhcOwtO2IbPP4p2FrM9/okM1RltN39Q9epd5JB2kPnNMzK8QwCJtE2GLnSfAxX23tv1Rszp8orxNqBu2zK9UUVcIbepTErcfU3Ii5Ry3bAN4Pqr9yOfU9YltZGjonMca5JkeE+3W2fEPEL622M15Pw7KYZcKiUZ0QqJ9vudvAF6bFZawjq5w7id8uf+qc1614Man5au/u42sSqoLlvqs620wexiyH1t1fMlLbl/lanDwGWcKDEfHIviS2Tz5utFF6O1qhP2i2uh42dA/2u7KdcEW+tE6UZS5Gy9cHclEED0OOxQHS12XjCvITcWj5RKk8lzeg3yljYhTwxvwQE1eDJp/hq1YjKig2rj4cYPDr7eaRMLQRnVcwzQnz/eY2pHZjsw06JA8iIEYCfxOY8CYAMQKBqOJT4GnpnwQpu7DGt/VkUACe9BUEws4g856iBVNOujO7g/Y2BfkeTMnXb4+tsPo0/fP9+XjivSypnDXFG/gbShEZpRd30APBEQ75nkesYIXaxEO584Wjato1wBznJn2RotliknH/K+6KKoAIVL5qsFkKuq8UML+UdECH4a3YUDUTV/wy8WFpdqDnQGyjYW0FhhaNN6jYF9vPGQS8CMGD3YEGiNoA723ZpArjqo0uJtdLcKpBj21vEUPEYjHgr0asjGJWGrbEk6vP9NmTe/EOq8M1Q8HvrWZ042L07GMqiMM7YPGL31w82shIx7CAjte942WualYmsiZYi9l8Q23qu6xxUlpf9hDPAyB8NvBHqrqSwwyFV/nMjq8V71gkQO+d42Fg97BQcFmYIVglTACJX3J8nkV2Jq58NbyaNF2Uhtxl6YudEDh/ajmFebgsW19FWhnQGjv3l9Tk3vU05UiH0MtDHcOhbtFiCTwoRNaRo4aVcB314ZHtd8Pbl/zKuipqGEGEsyoBaPUPtGbcKn3X5oDcHcHweWeZyyXpPwrb11uL7rsKzh8H8N6zZVa1yYwBIs426WXVl9xmckiMP/5YnZwVapaLM0b80Hiff+uIRb4YM+VQMXEsqXh5N7DshO4HODrMGbvQVVf22Sxkv+gFiwad8FKF09RYD3NzGwX2i/SjQEW25B0PW37pZFn1rf0Git08kGSS/t1zWMsRtqLfyp4Wq9SmtDTeVq8MJfvYtdlNmYBZ8/J6pBQfTQXLkIlDBG9LftArqRit+1Gyzq4RyfXKISRS7NsbytbUCFuuiQB0DxlhhJLub1ELJPpBUv3L0Y5O6eFMQ8yJBGGsHfqD3bZQmdhCIZaxmW2v7mKJ53c8CFW345istFI4m6NCPOTyjUc5iymAQF+OHGrLV0mzSPPl00rlINTzdPzMn5UBt7RdJfMwnmy8DQ6BjCJ7mM9hJGqTu1i0l+thjEfzicXMS/pTlApHRHm6AgG9N4Yb2UsB5V9479NncDU36c8h6UVy0b2a/rvScATPlWIce2tZvIdnZ/J7MPgNrGm8lTGY3XybSg8FRkraX3AlXXHT/yANzCXz4oFwKPVFYqandbWA/1FmF/xEEUCtJ8QG5A1f866NZSYDFWdKAZtKj2Mc/ruqmzex9ghsMl1ELUUK4LkrQAPW4gTap6zLJXAXiiVZFrJtCYXL4U/pJ58wGGwUo9/XeeDo99UStufKl1stiloqODpn0SQxl7Fg0V+s2/qv/v+HWdAgftX2VnQXjIPIrSwuTLzrb+DIdcXMaUoPpJ89YpXQFLS5SSQgsAgpXrxxpl4O3KTyvJ6g5My8XAW6IXHpK5pLfsogFQGwbAeDJQghODxDAPUuyQZzmfFcQPVBmmP41aurjE2xN6wQcWerwgOql8ELo1jCrl77gb0R8uqX2tCMV1gkxXvEvYX+oWQ+8g6oKxasCePhyF+0fHXO/yD4KTj77qmqL4HuV9umUE1HTNCtuf43ystHLMRetGwy0sbibxU79oLi0fuFOctKEUbGLtXEBor0EN4u4+ndg5VjXooGI03fAPQGTWQpprCqDuAimlAe2n8hb0TcGp9+0iEjTRHjYynt7pIwP0k42e2fzDxsMozS0zK4GJRqnBiNw+JmtR/8NeMSZoridss69fLYh9DBdv80Sc0CaSR3aQVj9KWDJJUVklY20/vhJ3N8bHBUsHCj1j+8Gtk+rv46NzMABVMnYoYarzpxUbScOxe/cLSTIQYwkNbXimsHFzcgQbpmpm3GaPi6HZ5r53VRTzU5YvpX7jktXR9TxmDgyAmPHwgVIJk/uDAeEeBb3PdIDnjWmCAVi25qX03tC7jBdzYbe8n6FRPomCedmsCGKLRNPNw+DbRbFXTS102Uqwl4R4Ytye9xcYM1mP2TATqeVWVSyga+mObsxvc0upOQHTh+MX4XaWc0mMHw0kIUihh1MLWnpBz8bzEpZrUfXVPoV7fMEi4vnIKLhpfCCyOx/hdmFoBLwudCQzJI2qewN7IC87NWFlyc1jxWYX0ownc4yIIGOoRSb1Boel4WGg02zWk5FG038w8FH11iQZxb80jmIIb8Dolpds9Gp7siiv1a6A60l8qBKgxqYDRCbZdlq0IOtykBWg2muial1uAa/zaFi5VJUNz4wRRcJwOsktn/oV34ergK0++hatlYM2IWKYrfQYTbaVVKNQ6S/XzVtvU2o4ATeBBVpw6Ut9vfAyu1yJ8YRzbKrXxi9rP5m7cXnhOKzGyGVxKGZaxLKPOnz2SLI1jT7rwuElENI2gPUfpFtM3Mx/6ogCfrwcoGbLKkJgktERLDNxHokoeZLDCcWvHlGiMs5YKL8z5jFOjf9jpVS3Mey7ObrkXS5XP3Vwen2ZEBsmA9sDmbZKtbr8dNothRMOmnW7gO33vx87olN8ofEsd9DziTLkYPAPzYRe2HKhJZyYbY2gzehbZ5H4vq3ujA8h0Qar5hX6vIs/HYNRca25OlLkFjB8z8UJfdgDmnGMb3LoWCuP9FQ5Nd1HXE9Hse/jSVXIlXuviiSJGtT4xDX72iiWb/pvFogELpPli+mcCdZuJadM8rr4hmwx7xws3zdhvD+Cvg7SGStTW2BMRyHTohJDdzAEZUOrLuK/+yGn02V7Co6j5lyiaga2XjHXvF3rEaX5CSNuluxMPUEA0L3+XOLBsNkGodGCkMuSPtZFns44b3Ic83/fJY7MM/fl/MBEJEjRSCDP1ICE/nTg1gwt2Sg1JDiKWO3ajspM8+kEAwAOWuvsXxCQK/cZ7nlaguAAIJVFsbE8u0pcS8F74vnEzdQ0bBcP/zVs6f28JgCiqOlZs4XIpSAAc8CZml3DHJpcilLZezi3FTkd2BkwtEgH+VYO6lA5bjEy9AYbkSsVN2mXIId+Je5bmQ54d80jHVv/aF+UgcTFjTqAHP29tiGlZs8O837KvDbTjf96l27zUm9MwrSplnwYrAdIrEouyl35ZiRy0VeN0ZHTOhpPO166GOgWd2dmi3f1EutfJpmjJds9TdOzqvFdSOFZL8mS+l+3jP8KjhYNWkco351GtA6pO0g8ZjasKBoXVC37IB6H1ftIt0D4wjd+9+c4FMJtBfN9jzpyvrNqdhqxB6zq1Rqv4oZwBcvKDcFGL6mS/PYMei6gMFqjLdU9sT2QPipSjHkSRN5g/rV9TV9NPyqiN6i5QL+WqByvfe1HonEE2qDEXJXd8B+uS5tqti6CAI9TZyy3DP+dOkPlG6v4+IrKwy6GlwCf4qNXDRHGvOiJpNfqw5qkvb7r63ViMOk0L/GjVZPLzQC5KRuQMMYN3gM8OF124M3+GLDc2OeLnX1TnBs7+4hZVXtLgHCWkxOOwxMacMMYfpoC6hdX7CPQhW7gtmj8fQYjMaeUFbmAfoMNtNhT1GiT0PSqusn5O6NAVQ6kvIpj9g3MZrp1/PW8YpnijgNk/gchIGvw9vA0ahWUpErJSPA0c6OR5Sv/oCopz15g86pGk9b9NCMvoanwKADUv2u0FpblmD88yxyiSoVxdo7ntOf0QcgJufGGbF19fKtwzSzTY/DM5NwttcSq3oOSgWBifNd/xwzOniOYSZzO24fgc7B421GZnF3fztdS7C5e4luBPDDhVwBZjOoO0VXK1tK34CRGKvbxfYzE3FVMoCgTU5KyQf2FncGpahHy60xenjcPn+5K7D8wozFDIQJGA8wsS6h03ItfZ09yPvWWuEoU/GaowXzIz6LCEpaXzl8YkZs5Wk3uU4V7NDEE3nTX872w7x/FdBbzWoPIZua7CppKHs/RRFZH/WlPpPnB8kxFjkVFQt9TP09dPiOlLyVokmdsaIDumYpK/oAkE7OfCCPz/l5L9bBWIExTsrYxUzEPKjEdUe33W7iaXATPa2YcKJdFup+AvQVqEU/n2xVik2TlLuFTjkk6Hfe8yh2NA98wiu+lPuAsy7GkljTgPrbBseOLcZ+lf3m6ePszLYZL3woez771p642Pfp8rZ3e50bKEuMaOkk2T1m55We64xGxp0udBxdhh+SWeWk5g1LbK0Czx5HMcWQb2bhGNULUtS1mo28/aWIimWvqEeqpbkWhZWaaPnuFlyOT2ef4J8Db8Sf1uTOgqZRFPt3xuEy8gstcr2xSeXZELuc4YsUS46HQdcvOTYrP0g/J7KfV+3PmdNjYFznsNohLQWTWWFuCV6wGC7ZSZzlH4XyY0kVALS1QqurZPkB5l4d3BRUvX8Aeg18c+cSOUWy39Zuj6W1g/mvXEJJnF5a0gKgwR3EZ1/gGVdtkkIjWMS1E4qa4WcHZCX5o1IllXtCwJJvwbGCzMVIylM7cZDs09cHaQxo9ZBD+9MRDmIfNML/4R21tM6ih7Eu/EqHcJtMJDsTwXaGKC6CfieOQNoFF2o62YcVV6PEEZXQO8ttoXqS1SD2HDwYhpZTDM/MB0sIZdb7z+lPnMoBGkbL1VZjS6yQisLh/ZUILFczVUyyHPAXuIocJLiiZqkt8ssCZ6X6/r6L+HIifU63qoYXdBeowwlpj40rnBeI3SP7bPGVhO5E2hiPIk7N8+WiF7GhocZFvMZr9KW+S8LaGhT3Z+LAvn+RA00BxDmkkZMCrO5xdAEAj6TlD3q1ll3UvCfgpIL0TvCGutf+ua88LjVnEXV85fsBK8fQYPOH68EoCUshNfAP0itox2Jao1rLzVUm3m4BkaIXdLU+S/HgKc4ZSvOTP/z8r2N+3r/RpT9qGqxweuEHfX2obDmovZsBJj0sy+/b1w3bbIMvqvUzHVF4NZNMXMacsAcZ5dCl0+q+gsckqPfGvXHKaQRvQS7/Ic1siyuLOYxAPnqu8FdAV+EN6fl8A02UxVfteXsCAro8rg8nmGcA26+Gp8ntn9H0vV2oxRmehxG5p6/84nQOv3wO5P/eyw32StaH3b6aAjNcknFP+86Ol7jmyGZcS0Paa6e01mzGV7xz8nOujswRMw3h43aBX2YaMsX1t62KyF4bmcxjDcVWZxsIxR6gwBHTCAeqFwUsaObTp1b4B/5W2gvs0AJJBKGQChY2YU99YxO4kJ4Xxdoq75Yw/lso2io9/iVNDqNJp8VaIwFMaLFprcUinnXiO2kOhcPA37POuFgeN8NJE7Mu48ajlQkMSVZ90ZM82DuAUNIuhhPsU2A/7lb+K2OMTtefjcMka6bdi2gmfBmQfkqt3wjbDUuuntzbBtfR7gXP8XpFA9fkpt1oKjOYWPtgKF/cZWbwW0LKwysMWmQU8HC8IySnUCeKkkzIjG8ACFo9i1065arL82QqpfZmKJahtnGcbQoo/sBPEYSlIqPwbupltMHGQCH5SDZWHukLrRFoqfsVN/O1DzreXUyH3G17poE2qaMarsxU4mZ7X0vjZLRAxjxnOx1MGpz/MwkJFNOVdqmp3mIKJU/qZA0t41OYefFscs4tJl7aeWYdQgIt0K+ZeXx4zk+liqnoVDm2OiL9UqKnr0fnyf8CXb5ENieY8lglS01Cks0y2PlStHbsLj+YXP3kb04Tgh/+YKVmm37S8SB71oibsHGY409e9OmjEmcmT0rw+6cDpXRRoSco6k7QR8tRUNLGROCVLNkhk6MKRLEzS5RtQEMwTTxsNRjHCKdde183fgB3f3vxwGreUkDyi5iV8BGLhkcKqYZ8vaYRstjL7faShh7YY7OUSc4LGYc1ZYN2A+UrJ56No2+kcIAvYVP5HFrXjlVkG8Bk1S0iB1Exx3Gn7pFu7yJdBg78lBs7UB8MDw5S8GZY4XQ5IH0uy2f9H8TytY3NCAFik2hXZ8BEniy1wtgwvkPC26v3Kd3QuCcsTl+l8HfibsDNDTs2l7dyi31POkN3kgs/Bcmwoj3J+zE5WT5u13XTG5OifPFdidq7QVHY7gET6amC//3igkv2zNqfSVw59x4y85kwVnypulnguAIACGbKAWXgSbjU5usp3sMtirZTznyQeN19L/o2SWMXUDgSefRenGzMEdT//RklaUGKXaWjaG6w41nh03h/+UgdlzdFVoKmmBe5h7KVqs/FdVf9uJ0foSquGjwewOQU97PXk8/bboUgtAGnqmW+3obbVlRe6t8r4VdYVaoOrvjZ528E+PojZ9VZUq+JV0bk9v1W2xK6wkl2RG+/pnfiD7IoXRaJU8YkLZ0tUEJyjHlUb99WpssMACoeebn/UEyHCJ5k/Jsoh/jOWnME2QWQG5NIYZ595sYf7JxRHkK8kfvIGE/jtpipzSK1e+jAvwNIoSdfBdencv5iviKYGHQYtb660rjfArnyF//y2amIHcxfS9PgPrhI/19czF03jfznR2aigINlLhtBFFQrwqv9LuOrfu0Euuje2TnnrZ+5I5v3tJV6epj/mBXUaNwU+Szq5pKX/AFz2EH1NMehe1FJVQEPQLscwzcIws3gjJymXoFM1lm3Jx+xMO0WS/9NsQai0iwrAv/+72Wz/drm+bWViFeSbX8zTEa8xH5BlWzzlDEKoU+eCQ5zpjjmbMzzwmh1nB/LhqRCqPpEFJwWr/HuWMUhlJyTBmjI5KbCXvxqbRb2BmfIaBFA0V7t/f3MIM9JTkSVJaObAriBwy7s4MUMMrHFUAOkHjgbBs8xy/bDmfLiUMJLMp8ptYPkUa9dKaHRnvn0FrtaWelQdma3ai4qv2K5SjlYwL/VMSXHZqQN4W/X4aarMM1QEKYIWLLRGQ9warvYUcnEKtdygDT6eSXpDd/nyuvfth+noEQMqQVctd5qHbh0PwAJ7Xdez/4VUzyjlDy4uNhT4EfQgrcXUft9T0dieXZRlyF7yRRC4ziWSWDH4zfyV5GyDOw00AFypGvFU26W/J2h1ZHITz0EWmt1g3lBZu6upCLV5++LU6gI/Xy/MgcbYWDbsiKSIzdX9XRPako9ZlrFjqm4CTVCsYE3VoTpZYpnwzNFwVP9YseVExIzMS+SO4iIE+RyTdr0WX42OZancd8B4PFoC1OigWIPwT0C6WJEMTPvtFmx/6z81393FesOmsiABzHQ6C4PoZTbaGODj35MNouR9iIHb39boT480rt4GqV2Xpy1iF9uD37+uTC43eyOKXEME3iJ61JzZyWeQm3yJB/mXcnKin4k5Id0suYwl2uxsegC5xg6XgfkByCRA5Je7ckUPv3lNnqG4z5hBYRFZ0TZI6p4WZ9fM77nQbSYDKhKjx2Q5+S2ZRNToiQbaLC8VbT4B4b+EI7SM3CI6X7PVDyA6UZLAFLnO8D3UDBgd7A5GzsHdE34mPjfB25Fv0Nilge2ro0qvYNB1xdG8vksyuxZizMKdV8GAGU1IDP8szSS44BncxhSk5pWDIKmewDD7lRQhvZkJwazcUCvDtFlFtJ2pgfGN1X6yltxWuljn7HN2BVaWp2GXCUUXHmbKuruGnoxNg6RfmFpK7+WslnLMYnbRu8wOu/tcgTgsojyNRQpX3S/JnGSmf/RDAR1wzRHoFLDtb6/R5uBMuVh4v/UwjtXUDirmgyncts+TcgmGLcr2/t/3l+gyId79eWnbZN5kXxJSyfkzXO1Hn3atDAoE/4xI5u8+RqNZJqcVY2Y8k6H6mz2VtpL4wFz/mgQHAA5Sdr+DBbNRVxTJWZVlesRLmBqH5PWQD6mGVe3F9cTFu8iEUUfBxfyrj6Km+7W1Rv9rlKclzEY0AHhlSV6GNK2FdWbLcWmIqYnWoMG4j98S1hcndtwVgiC3zmv/IOZx2IOhKJ6r+kP3FL7qV/sj26RTWxoFqq6I2/b1hqC5BXq45YaXo4e6E3P7nJNa0iPCVPt3QBNnVABOeQiv2/gUvZLVu4DRHlNTEr8MJb1AmhQILJ1YNO0mXDqmqjjqR0XXa5ybNaR24J1YeQRWgvRNgWQeJDugUFZCEHIBj0ciXCHeCOssv7iVNZ7+GDJO+9ghIZIkoRnyRJgTMUflzoiyG8/+wbMppyU567g9M/i1MOT0eRBOayP/bxOojQjcT207S32cxu8Wg9yqH3fGU1HOce4wWZgLu+hjHG3NtA39NxjRwbn6MphqV5j0FAZa6tc+jDeot2+ykfKRP4sX/0hHugBfKIxW3Bu7x5wZ7ZqicYVp95tPEpSiPx6vAab6hfEZ0lTNSw1VqZDvlFvGPSp0rO/CWH1pB+zig71L/pXaozomFvYbjklvPAob0PquhdpJisMUMvxhSmYjUvnFr3SCATlvdxk/cThmRcstu8HEVXxytA61KSkZg6gNjOQu1C3QfEvDtC6kcHN6P7wGYdy9T4Y1yXI9dylIVWISMWmuRFEjCMYTYO6e9KpYUY3Obf727IbkBsTIdyS5TDiPVaizbjmEK/UHu5ss5RvCQeI9+6GHQjkJxK6pk6ehF5KVA+nnmdwqdVq433rmORNz/IJ5cb/Z/9bT9EpwTcGEk1zjg/flN9VqTdoScPXWopa8ThwaslbVxiuV6zA5qm73uU6U8IA34jqvnDYb/lkL25ITZz5nZV2iVl0XDb1eNi1V/s85Z7EUySAI8nBDrPlMJng/Ql8cOthzEy28aVgLUlX/WdeHacK08UqOQ2JFqu5Hif4LSH/MygjlLffdsFh470HOsrVSiqniLHOx+8vzkeU9JKQTkYKYt+fNo/ARZsSAX90f+c108EcYMt+tjCsJFTKC98BwSl9ksL4v8DJg+fkh4ubi+gtdE/FZpAdfbFpXxNRZTU+cTYKaigz4M084rZE2Zm4RwG/QV796t0rypJf6MxUgkNyyN3pTLlsBXc0ByFR3Q5ffwfEWUmdhSB18Y3asbaZF6wdAC3/xrCkpNNkesB7H/K8ZuRU6KGx0dO+LCbpmqWk4lsuOVfST4Oawu6wVl/nSr8KxirlkF/OS3hjkwUXMmjyoH4zYdkknoVwOub+lgb9BvP+3NHk8SgNqxMpkK0ZMHoHZtB6Ui/t508+9PZnRK53ejQy493PZZYVIQYs0fDfswb29e6H7x6Xwe/WL7dKN4RIm/VvSn9l+ph9x3rz1VjxIaCYSIibqhyF1/BxoUkdouZLfhOaGljQSj+zBn9sKTi+MuxGqmBc5jgPEH6+T+1UBZln0TmwwMaaSnsSyGK2VlxSe9FU8RHsHiKoU73B9qF1bGhcKFp2T9LtJAyGP094+3uWapKKvK2F26IeoXJre5l+CDaLN1otc7Yvc6WKToasfJNu/3zKL0/DFyCtw+QWLiABIB1vZM4STfCVwlRk7xpHvDEwijo5G6H+uGzhC6iohNkHrqSfhzw5wE0PSJMfTflUGEqmE899/IOiOc6nhuMTr1S0vHhnrFrvJU3FhF9Z5H2kcgGof/vasepXi/1Q8xT2EWY6m/oHrPeP9h+gShhk0xhkjVzH8Mssv03I9gZaKpi52QHcFjK/JZ5Cr8UiYDzhqqacjZU6v2Jay5i4Uqc4ih+70BJYX39Ycj2Ge2UW78S1xs4kCViM/6jGB3Ep0Dx5RLW5fAZXDfLPhMZByWV77culOACtPoLjmYJU37yOZhBupqS0HBjg2HnvQPXA1jMF6th7nsXikt0QfoOGNp6Zi/12sbdvG+PDFD98UAILEsfAUU04rSXAYD8amSXpS7li9KNfnnPVo3hiy7T3QzeWe0fq93rB1aKvvPMTxMDN99yblxYBZztpqUdK8hhBxDutliqoV/Vy//5GQKKqswZH2fymi0aYJmc83cMdeelp3fZDlSIiyXvmBp3pk9bbIDKEFKCFaUbTUy2XBXa2FdKdMqwI6dk+FAkEtPc7iI3SwZMLX6gdwA0Y8w2NfCiHWPoB+csGq/iRLA1Z7UqQeQMcIIx0U9IsLSRmSDCOlFpEA/TFD8guG2nA4SRu2lIzmJra1qaWuPq0iepP98fJLqdzbv6zW8FIdy2fbME8hPKxdWa5OmX0ughRvAGdHA/rSgzZYnyFtg16egwNPWY1PcOdkhCSttWl4JQhbJZEzDvnXEIP7kXjG3yXAhNOoG1iDL1kJXgYW9RXQ/Pvibm5hGcmesMclsnhxsFtqNe5LjO1FzzeidA0Ipik2lQH7yZLCXsaA8dB/760fIOK5y+jv8GJmBB2CiEXBN0GRlT3nPTHpTfod1FeKEiMA57U7FrvVr8Db2KZbSyB3uiMuwRMdG5yxVvKYG6p5n9neAvsJ46f1CGX4tQXRGqHWlDsOoFJa4kX0EX9UGc5efHoY6d3Gv8TKQCFWbyXfnAw6mfKhC+1mGg8nOsLsAXOlWy7v0kGa8GucbI9xPF6hJha8ErfPD3d39tCTTSG0QdDZllPseriz4p6ihUcNIWhJ+ZsEGoirHiXSh7kpXzGvoqov4VieRes2EZ7lZpn8ig5NzbVFc7Egc/lp1rrHfV2qKnXHUyLdy6qYJ/MhmZNPlSCxtEDfcI/MCiSZjMUt4AnlCSCjylvRf/i8Ru6JtX/ikvAxo+ngULkaroPwNnHclGxrDJgmdU5fWN973XkfDMuavmyiRKwpZPZlGwPm4WHa6hjpJgAgkYdslHiRkbSNmCVpg/yyV/5qlT2P2iBZS1P7dMK64WWJyEEFAGWbhYgWw5Sq4Qto2MZYBdf6fARs8PLvLTKIqhv7S0PW1EpltwUA9eussxlVN6l+zDrHeeUg0ZM9W/9SIrriBenFYbgCY9lkaH8hOVudXkt2MWdsKVLeLvi43T3v5do2jteWENPFlc4Rtsz3W4F9dplCeZSuxYetuhcwSCdxPzuA5AZRkp6FhWOn5F+CJijs8XxEAqta/ZXn5hIp5rF4GmUHRkfRqFoAOBkGE/t1xN5RlePA9Bz9YbvXGEXqv/tXJRJX9vDJUdd5p4g9mOvvQpYVZILxFNjW+s0IQLmyHtTZ17igDSApEBlhlfvbFaOdY3ygdgW9UrertSC67HBoJ9kgaWspdPYqozhSPiUw9vYRyQEg4SpxuK6RLwVW8KrfYdnrJvTa5JwBhZki+3Q8yjNAshg9IkHHBLWOsxxJw/YsZ7qNkjDNA0XMdQRkIBC5FdgAbydpDWTTjBfjSHp2u5gDlLSEjt1zIZmdNxtapPZw2oQ8K6/QJhPapxH5DEeqFKVTb5A+PgMRLP4lAMy58la6Khb34o7DFoswhgUD/P+A75WLBI7bwkOMbx/2PszIFpH3O0/vPIMQdNCXfJZnI352aYpPx5Fp36i/S6giePlXcLxWSZmr6p3aTWc+QIKpxkuAOIjizI7u8roTIY4OV2kch4GwK1DrKVS41QWf5osOC/PNNB9ZG7KMEZKAqvXiwNXtlX+RCUdvf/wX8ywP17xmHc+Mw4t34CZvNfWXNGN+dQ3k4Dr7AVemFBKF3Lp05n0Uyqd68zDa8rDrZRgIBckkG5haVikEcSp+kFji1BmTTq95xSuk6NOVKfGjTTozoibOAaosmw37/OHnahoqThXJQb23ezUjytmY5uFTBMRkOXz9DgPzqig4yN5+F67ByrW6Buuo65KYXlksuzZhvIMobHFaQgFhid7kymK98VXTgLsFoYuuUmH/860P8Kn20r4W6Ej3ScDI0FgLXkixe5/QzZY+z5QCSZl2loKdr/k7yauMXs5pCoGLdZYjkkp4rTwi5r7zY8Lrktt3ZTX8PmaSdYGaYXJRoEuLxZQzmbYVYwkq655KIxSM01sBN90JKIgh7eBpmTGPTKVtw23fCsVmkJcTraqegW5/Nhfjx4tiQpTjwebH/E8tgHJViy1y0ajUkXMexnjq0THixYTMxFLIUTDMpUZGUr+0nKQLf1wAbNIxFfQz5fVnDfqPPN+QBJCleCeGwPx2wQqQeqIKrSySFxvsj83JIxw4Y7GHUph4gog7rgq7QOTaJYr+jt/5BG3ZDgBQ81Ru8jEV1Cik6Z5czgyjnFZ7vDLZCqDFzPRF54e6wLOkTFmsdurBCcJrGBlQfexTkh6wqQxBqW5clC1Q2rOVdXyQGwmnyXB61cTakUPzbnjkYZ2d4rVPZrsiV6OO6QqRLWVjPzT5wc2kZ6hRqrL5YFsIx8RMD4haPUzeetTsVuxg+107YcbuepWAhy5c1EJw433je/W/xwf/yrC5froY1DgIqzf7bX+/4gdolXDYibnlrxCPSN3IqrgP7HDJCVRDdjdNYoCADUw4vZf5vGshnAzJoq7I83iv6PedQU8K9kk377PhcbfAKBLH0X1ivcPMHUQgIm7+EEXy325d6+V0tE5L2btbUjxnU1tFml+TBBLFKhMD9T45JCNGCPj2vMFcwKg6JIM8LOPlmiHmOYQq1C3mdYAd3/AWQrtD9pwMeiBAnkUQxEw964F4Cr4Mw0kzWdOuXxAYkT1wdKGzEOv8KOmN8lr+g2BUv2BYf6H1/zdaVjuAKSMN//4tCe8idMd9QEEEdcUONsoqBe8hLGf7+dAbqNo0Lu4xNSogxfrpDpWebvYVC7dvrV7PmxpCicSsQytAbcuM0K5vzTCrnelAVqONpMi7Cr/9HqUGmkLcEVFdbRd9FwUYU9uvNK1KIVQ0onRuUwv2T0TZg3Z4CeNzBUdq9QoTMxbHQKxEujaxjwgynIu6qRFF7NGX/Kkufsrm6rSi1wAsXUiQzrAzPSmGpCIaM33N4PCJgV1U6P0j/X+LPV+GHtRMpHCvM5FfHgE/KQeTe0ZUPUifPC4u4o6CQh0dFhkTBKG9f/na3m3cIaPNELk+uNTay05LRjD13C2CBhu6y+Terh4bC0USqVM6N8AywkGbKx0g4takFXFuJLw2pV9LPG154PT6NJ6wSy1oQq1Wh8BW0egWO2e+l3T/8DHgYT9zsF9L6VT8KEGMNrRI8nPQQ0lHtocIzk7csswPrMhKrFoL7MEwL/SFHc4FZb4ZKD7iZrFjbNRsiCp0oX0AxV6DlJhMq46mYkx01M38c9TvfEjv8fQbRVaBl5q9N+FVCh2ZmTi/YyrD3V5mrFJAPHiDiJmvWRGyqUfNgVjA2BnTTOAOQOR0nKIyIA5zyJnrZdY43TLOFxDpJ9LsFGy6jLDhWpYR0ADcaJFIVDSJrhWj+q/eG5C2YQB2/hVjbG4JNbYyaTEoJ0l/y438gO16xOS4ho7ys8HWfaeEpUarBQZP2rTSLDOxmwucqvIqCrd2FV5mbbONoeziuHjy13EtnEbU98S7Lgee29bAbW/aXOSqTYuG46KfqKsFv+l5oNAx4GrblSbkMbDoGnCghLGRQVUlmhMuHp7HLC19GZNfmzEQFW/MvlH8zSyBYMH17+wADwPOf6IUx25T/rlZoeQ+VxURbSjgKE8hNVos/mr+vVGyOEoUW19K8bJPOC2x2jYoJ95zVlFnyHSbbSNX7k1qPcpkfybM962c4ZEFO4V1KINfkq3vtelxqYyEgvYU3KjaGhaeZTY6PehP99UjbINEOMcKqsi3xTWE9OIXK4pIqn871TRQ5B84qa5acoXqFl+4UjRdOMHP6hIECfHYVhKrUmRNBbEzVbDqfqKCEEFpwbXhMHS4Ww6IolYx20ELUXc76P+6ifqG0ZGUmYT8DA3mB2ebI+PMmkQzH8dc/IyDbtVRGerzTNVb7pZIzC20uut5XLqFo2xEx3OphgBQVUzhLtnwbQl0LuIjirhfapWFnds736pohoQYfGkaJ21BDq7649OUG46kIfTvoeIL670x4+KAbf3qZA9zWMG38/KOc6E9r24i6PLMLbpMhz4S7A+6WRuTiWFCTnCz1rhyVFbIQcmzw/Imj/QTeIVAlmqoykOHVpL23WVa70dLdkPbjXQTwuWEu5AAJck/NZiTu1eABaoH4CUYZkIMw2u0973bjVW0E+JJyuoj5QUuLee/etIlgivWURMxpCH4KCQEqXLIJH6RO9cYxNn3o4kuzN5T/DTf9jaAkmjOCTxQOFi5h3EbgmsMXpr06CbR85sQhg+TtkDbmLEgWJP3QTluP4GDk/o+RKExvJsvtQKB4t5ElejjF216xLYjxG9B+XR2NGBKldj2oS+fBN6CytiVP9rFVvC19FLW7blvH6WJWzwuFLuqwqP+8m+qaubsylRjimZrFigV7f6gqNj+snvlXUvyIId2BZdtJnZYcMSDlWIgaDII7463g+dJ+4I4o93a/x3Zk6JiODGOColSVeCdmaisjQkwmyZLu0vsanDsTqNJet3y8kjW0BbddV+Z2Rx9cS6L2751fB7ta3AbSTdQCRrKN3uFHJbPrskwS0WgZ6iPrwvxFzTz1JH6z3SAEcmVwQpDbE/dwhhOkLmqWEHz8Ip5oWb6k0l3f50eAWSO69gaqbTw6kWSZvjmt8vZRFqD5JMr+V6IG/b0Aw4yu762mR35ymjckwnlZHnu4AN6Amj/dseW7BKyUa1C1aJRmM0De3AkbPREOAcvR6O8NzXPOrAiCO6vO8jwA8J9xIWYDlPa5epJhJHemz3nniWXAbEjcdvQVDpS6lUsMopRGdCSanmJRQ8Psle6/OlnvXAH9UK5GkFWhGJcCjyJOe3IJuJDzWir/wWGE9G0nnvKjJ0Eg2Bx5evXZY1C+tKqSxTWyW6jReun/SverA2iaP5P0C6bKyrlEZHy+btjs2TvIWOjI7hFRKtHQFVZZGwCotgLrArZB8CHBe4dsZLJ4179q1PT0Nllgoibw3Kkb41N72vWT6NgnySqFZGGkEhJboO+1NSmMm80sEAHMVO7tcgftKCsRZG0DnPkChDphWEykPpMdxj6iImh5X5L5S87B6CkllrTMDRQ4LdrUwe9Aa0CUg+0AHMxewwt70KwUOeSGxVvBB5pXn41oWvNHBayVyYrO5PJaweCIq6wBYL0VsanSAlto/ToqzsWoxUgmd25PlfCZ3d6Gl/Lc+Ykxmi7hGhK2Ydglor0drfdnNhQqmPxCwiiJUmtCJHulSaVxuoEvLxP4DOixc6nl03S9ZDgScSBsyC/FQjQIGzeAAVnqusT6d5t/oX4d5SucNX/9rz4GhCcIviena07dfp7VUdg4rt5sd5VPfJicpzWUOVJjjVthHltBci0v2IjAt8DzAgP4pNHDemL870+nRv3RpJVsH45tVTbqgu37zTQ+Yg/MtNbIJ7JGUx1uEzL5Dz2+oJgMMHk2a9Es5pHWyfe6XjXSdqEQcCCszC8g3qGHYjibZtF1e5kM3XZjy+asNuCl53JIVoQKoe7Req6+r9bFMXTXR0qyA+qiqYviFNbKyudhI4MRUFrtENZz2VKsfJnGJxY09UpB04/gap3x7steIrHC8t9FTzJyP3TzEO7H2xg+TJtWmMibTHRPsk4JgA2RR8cauvuno6xTYyWXbzBVtd+O1mItTe3LHIfRoYe2AUdUa816eLHlyPZ0Q9gezYVzXuX1YqPa7JBMPrNB949p1d4uq9BA3sk4W6oRrZHtdvO5FJe7uEnzwiFFqOW3CWV4z8ylIT2DlnYl5/BuuxJNHvOR4y6QF+lwoi4AdPSobGcsLIKaLVpjw6LIRbdan9wIy9Xdv2apye0tMtUp2oOTUptcmTo0rOK1fWbvTIiweoTNqjMQG9IeRh3MiN+gepPg8BjEU8htyR/IzTB76T4FfSQ1vpboJ7qEz7fp7DaczD8eJ59t3wB170Wvvd8jdP610m+4jUYLHtEC6oT1/5A4En4PR8UYOrNbB4pASp8mhqhqtKU05UCZkD+4QGzmI/5hKvcKo/EKLE7kq4cMtlD6XOrMAY6gggDma+rZXK/mgT8ToBtdNgkzpP+TXF2Ce0ieNJeku1gzXeNcigjQy6qWxmZ9WRSmwWDAFuKxEe3R21Rr2M0TAZutdHu3Ncv9DE32lOVP5XYzN7uNYyC6HFof+jZIZUXnrBUdvfPi3Pl1bHc70guRrDbkt6wSOzROdC3Fqpe5BV+HReYAAfcGgK8nsCxvrt+CfVXDOlCRrooqOTt0l26QiF96r0wcUxZXdz2X4sz6l3qFx9svKPR3StCWc2KxzUK1W0CIyYVM2hsj6yse2QDmWB6Bmk23h8ijbYCAcqRItO1N7Y9BV5MYfGM9mbyKT89c3ZmQGXoj1x8zLuVNwAYZ0E0uS2SZXXNZ6PnnrZTHqS5FcYCseTNQTBVHMDrlMtq4K0cjvaSiXIsUBlI+LXNXSQXx9AUpFlJcxVDy3K+yfKa6KA2hoStLMkO5OciWfYqIcB5ldFVE5QTOo0JvmNS3TT5dYw4EhtEw6K5ToNePcDTQq00DJH1O6R8NnRAxNqGzlRpTjNzqC8sxvg1Ez85cV+JFgiYQbXZDyClwhWWntYhZEVg5UrQZGQVkDbhsRk1/YQn5kkmfRS+MaWjkBNcRYsYG4nY7Nm7xR0/2Z9vHhEoHbXbdxem3KsUcbUHyzgSIru58LG3E5v4v5pumyfD5jfK71uLJtYW0LHe59buQRmYGALoKF2bCtNOXutpuMqxTirdAmLiBBplDppuZ8dxOy2EtvcWkTdJQusl0Sp+Pey9i64m6RZE0t04vL/K7oenZaVBK0z7nEvb8FvOww8iBmEC9C4WaKMD4EQPe/siJbgQt+K/mta0YZ2yZKqualse9i+5RXLFcmGtyUSa37O2mFQaTrKhX0ZMka1yDst17cZ4tAX7O6MbFwwb9uzvEGsTkOirB1vlf4jLugRGKjtZ4iS8BvMY7sSrzWYp9zZYlyTyjGuIJJpPe89UaPK9gsTNEi3bgS1gYULyqE9ITtBM9/0LFt+8iu0HNMy9eQkYJzAQaHN717N5aIk19r83AFlCxCiA39Wd9IjYliMr7mqPeVZ1u4HNBCh+tVUpktCNRnFq2BjxiYTTNSNjx3xAZgvmb0sJx6CpUE+dTZRW6pB6FLNeUFWDgpLR1if+QawtwA2r3t2x3MeljkFri73a2hoioVX8cKxYwK38LvOcijm1y7kGfvhsVbZWKazxT+90kVQgl3/qyMkePS1pZj3CRFoeEFPF2WPD2pc9t6/4VWPN3KGa1dzxcQ+bh1BWjOwBnhv+vu/5KKnyWLH4A/uj2yxfI1JNMJHMGq4nLpL8/ZhtT09WLIJ0Kjgadf70Uj+D2hu79DzM8GgAve6aWGs0IwVLwFIXX6fwN1M2CT22BjFC707mmeuyicFL+wUtXihYs/fYPUrny4AuFH8Ud8oUoNANYHHCVDiwyOCFhZnKUM1XtMw7qMXjAYiZ4hukEiU1+dMMCIiEaGJMOVQAsMskQzbdKJ4UuvmTRoMKOrnc1dTxVJVAfVnQVNBC0RLs2jKftixTG6yhIZjO7/7GPJRsxZj7CLq0kQyFArI75/lFSytxdgYdaT5SNNbYgMgaSSu9eUx1++qVvST6rbaNuvXeTGfhiA1a2lTZ645dbZMwQgFB3AHnFd5FfDcjRjsLa5zhQHrIW6Fs5DM81X+8eQOJvxCIQeY0MthRZ4WWhV1NpGEbGyxN6thKQ5M535RKAySamA2IE7K8J1D3JU1Mp6WK8e34mOZ+f8XDgc8sADF+CTwniZnNkXdJg6zUgiU+lLo4B7qyPoEufi20DC1VrPGJadoNihWyyZnjje0POMKRa2B3dUJv73K7J4YBAeYJ3tMCKWVtbK4l6RblpJTFUQnNQLqxISpd0wFMEXVL+Z4EFs+uoINFlOLN8MPqfw7n6Je6tFFPSNF7rwUDBJnm2LLIBN7DvgPSSZtplevHxNBJtx5JRpX2jwhkd5SLwtas3HoId5FkAynWZ3OOKdfnPxwax1y0sT0Vn0a+NNhF/uFGCZG3lB68BGRRrmbLTQFvO3xCVlJ2Zdf8rnz9BIVtmH4KV1HAmeq60KLuicR0QKzXW2qod14rvr8P0p36+WQtj6Zo3hPSx1XN+Apx4+M0ryysdiLla1b/4jbfpIicJCuJps036xrOjkL7M8OFmxOcHsewiY9UMTpl968UFU7pWy7R0MgEZsFZxgmH60UjsY3YbqcpInEJ4P6ouZ98OuSsTeZxOJ53zsFUfuqTlkUYxCH0P/ghsrATHE8VGkVR1WxYoOWIprjR7NMl7cD2AEyXxhg6/ibeJX8NS9WWPCYa7JagC+HpVVQCWMt2AjT1zP5Xk16r+J3QWETbUClEvmx2tBY63VKnHX529RzHSO6tFBi16cseCccSpeTXvpDZa2dVaE577xdql+F2092ije/AILD+E2tlg7UWBcwXJbIl8LrhbLwTdmhuEX0GYN07hsotPMM3aTysaRpOxKqOY6w2aJ7UxBiISDx7h8vU362ilR8QF0Q/rk4XoEQ5Vz+sxY8wjYx50eJA49beQaA0BeSDPy+OYQMW2bk0khsDD15voxd+gqQoV4NkLJ1jqIwY7C1wAF2OAGxIS2OY0XBt2996vJ+BXrnzzvQgZe8xwqngV7jtPBjgUpGg6dpnZ+bn+8dKYlrE7ho4jfJrVPueFIiCzcV9AkQRdBkqv0YbfCxyQMHjUL/DyoFKwBNJLDWSLetkk/ygcws/YjeYHBVlxMuL867OKqURXYDJnIicBJgCE/zW9wOA04m8mfj0bWDzpD1moKEQIAbOzU0ZcDfsqbhGjJTyUE7nyRH63v/RwOwHcaQKwpQrRTf7DVSSjn73fn2iZnLqbRJ9QMruEYiWvLQBH/21JMrjF4KzCgRbUyJZBA/25slqixuNL9IKVqK2fpe7Ge0vhQpDtlg+IdUe1bd9SY1cUyqGY3qKMBpcLCxN1EsfWDqKYQGYL934aK53qjq9WklDoL3/bi4QQt6AklRG6jk16QV/btaszLg2XLx82kbXFs8gKge8Aa1d9zw8EtWSBE4ROPAEscmv/5EqZWXV9RqbOJpn/yGlhmOQ4z0KKTxfkaN/iiDhVoRcBVPGW3E9HCOdsI0VByTURgcghlTRcazFDW/QDkBTm9ZR3VV+wB9pqDsnHiYGrhHLp8/FGgg2FGI6ifCYoqGcy/4HhDiMGOwbYmevA4RycVbcbAzLkHRexgLvmtTtZag6Sim+yZvahYR+XWdkscyO0+MXZOKtVRMUybl7/d/Rvb/zvDogBzdHgJLfne9V1mV5Rz9GapFRpDKHJHra/0hSBu38k7UV9RNE6HWtqrJFSfKgasWuUUbF+aMQZkAbXaEDg37wd7kr9mZZrcHvES1fSB6fZLzKgDowJ3lVzb/gpLjnezFgzWq6bXDZz1f07On9+avfkduJIk3KvHKzomGlCqqekgwL2uv8FRfqZ948aqd4qduZKzp5obXGypbd68S1592X9YwQVrKvOfZ9ib84AKZ8V/Bdii1+NaIKrDY9+ayH0C4vtBO6I1k5Wtk2AGX2P8TLf5ck8eTZ9i6Uv6NqCdcnw+UYQJWUkMcDh1TtYehwtbLB9ydt5rGGryPGBtdSDin7AFXWen/NecKLlFYRdmxbXsNcBV5vJGn57ecNu0yZCO0gTGXeg+0OQ78BEPt/29wNWlbAaznG8bIIsC1GglAEbFgOxBLLUKHX12xrWHhK0Jljweu3iNsZ+uknpQistkSuaR0ty2MxlCCFccanDatmoTjPYrvtV2w0BRqjgcq1RQMv78nFuS0thj7mbl39+efOTMygFKyYwLGgRzWzmwU48d5G8CVnX+v9bW/udvDf1ymkszt+7jOWgq8ewFCSltQ1ixha256wM13au46HxpGv/GBm2B+jKc5yp9dLCP/HSnHWHD7SzUoTOXPhV2h12mOhbQgpvJU1LnEmEAJvh39ctuyPHAbuiP9u1t76lNZevzv2Vf/eH65tGq3cXEjJLAZJ/KjXZGOz3664YRscXQk38krb9K7DV4+Gyc0OiKkdVrsqbmkqIE99/+SHxi3JKsrXKQIyvC8ujwfjFODPMtNP/LYxrRWWwpTIviJH1b6nf63kutRHnNki6A46qHVFp6tq3sB5jSCvYPRtnMPB4PsTAgVSq0EL9vmNKfenZXfw3ouTbNCqSgiGz8H8MSGTW9uLjHTxCJf+CX/aXkabP+rxeC//FIcuurQ7CfoqSg9Mgup86Me2OtW3bG5I5ZNMW+t73l0lfpEcrh8jVYetHrxNuVOFR0D1NW57k+PCptme6ZtMhvIlil18XkssFrsHIt5ezwgSQRI+eJzEhrSNkzBzsKSF5fAjg5tcfTSfX5fyPNE6c6oWeZ5rgHDF/GTo0AbT0lxpO69Ko0ZcPyTOwQxEtHUIePuY4PO4DUE8OIslncgguCkMT/xRYN+oHuhUfjWznkKsAl5k3ilhAnR///WyB7dQYguGtDj9BFNhsjZ0Frlwie7KFQ9EjlrpYmz/RJBNmVnijR+bNfSSntQX3ExEBmPFU6X+CDXlJ07RMDE+8OKcc47dkGO9yqZyiT/81q65PXAULD38zmu2Q4kuexziunsZeRYcQ4nn6lZZaakTIQBSBsShtiJZLOAyYDebHHUap98SqjsLrTPPi79Xdcb9l8YGD7ATatLZYyZKqVFbH4RvYONBLLih+z5t0SjU3DuzFhU8AeptYjZJXUsq+tKa7xx5nesQpPHvD02rkWk3QEcUcpiizZMfggcAj90h11A/Abd0+99xjef1l+NlFLDRgspLl5iVxGyRiERaD216KqU9nKRvp4e6b73QRFJjqkVFSEl5vSOXf37FpnxmscIP4XvBrnoX8UrP53wbQ6KpHCgpZrKigrZOw33p6mkl3mfwd1pto5S8XwTgvs7BWxs49uZSijOSnQxlgx5pnIs2aCgDz2ScNcwJSCNnHaP3ppK8ASFjKc4iGPUQc1b3QvR+phW2urZ+K5vaw/fyDzcJ73Teem1jMILxG8Ix321IHWJWO/HEw2FVSp5W83Xe77A+KJixltUBKkj9ArGNHLLl9ic7oB0nX1DbKqTppUaERW6J7YrHmr7Lna55qlkTMXmzMJ5nUoymyBIZWji7S+fqw3L//Kyd7SVM0KKLhne/m6ONp4WejBxwdZy8URAZQsYfwh1MbIBm07w982cvGp6QJEJONd8tkcFnI9ORPwKEjuLBYH7Qh8ekIXUF45x239/6791ctbe2EkDYIp3W5gCV/Yk/ttkXpaDESdfqwOKomes7oZuruKnD4ci6VujipKJ6IciIyX+qWy+0L9NypFKfaPhTYfcsgHsxdkt5Zg4/bxN9SMJWmzF3vQ6Dsd2GKZvgmAjk7imvL3Ltmz+wE8ZLrO7EbGmynCdFCmCnOWN7z9Q5es2EEkwoSkHANlTjvhScTQxj9p+4Zf0tFXzSG9GDMEKg4urUgYrReftJALe3ajfo57cldQfB4QXguPWZ1t619ukb1gaYjh8iwcyuO1jqClvGyETxQK37KXvRUyAI+UlsafOHRNV1aTkDEgCDs7g2aeji5wjPGpvRUjmgHxDrXrJBMN9mCuqBf/sDZ3B+d6do+9aH9PxPLCxh58m7KUdkRMRojHMFhzJjmSm2auB4Quh+7mrCsYpjzu2Oa9de7FPRsD/GwkzZAZkhuujTHGTn2VsEdOER5bCM2mbIQp5k+sb4TaYTU712HRGDblexxgqBU8uYcPyKWSlZMtHv3TuulH81ZkyFHKA7kqjmH9IW2qoKX1HeZe4zV4RifIXblz60A6kh9JGvkF786g7dAsSVQ2RvIOpGb07rIvfHJnNMGzit31Cp9ZcUW3pe6hYpUSig/C8PINX3DHo5q9gGTB51Z5g24ENDQjYLHG1LZmJY2N0rF5Yh6c6YLB/xGvi+J4P84sE+seYEhkbG4hGFc7c5nwcJAKPfRUX5W6dT6+L10wDV/IawSdDelUNUt2nNk3H4kSVWsAelwTGbILvqx5sRjm52+7G94BqReXT6Ei0ao+1Zr8UE98Rowbef2SlH9I/9Wim5UG/+ksTu6LvemnHpbKntky2aSB6PSPQjSid8Klm6Kfbd93Ydm0JFudydKxAPO3+v5WcTeRNz+M9g8D1uhe69jkBpWHHEzQBtkbaA9z+YIJOTiFxqtRnPhGusNmw/Kwim+wvU/u/vZxD359GiizjA9M5xeMoEmAjbvjvvP/YYNu4BC7KIHyH5foK+l4UgsTPWSIgBV1obdUhSGMjbxCOCz5n6KbVGkKoq1J0YQ+1dSllGNbf/CAVcdwYbF5oDzV2oG/9ce1UOTeEi9zLC+puVowAcrSESuGZBkxwoFpsWybig3kth6zFQCiRe4E82qeC5lOAamlrRspAhvfLjbsh0VAZ/F6vRQyV1t4bjYBSGZmHdBabu3QLbpfeaWMsCTuwQCXoCT40cYjAYDut5/99wXSxmFxJv5ay3uix+DPqoVq1LuJN/e/VRRCQm3+bSSPB4clVfIsXS+PTDaWBtHeWzGyIrsXTMgwuuJDtypqjWsZ82DI67gkGCZO9+PnjY732bnwpoZprBu3uiwcWs2H6O9zr2iKOMPZi2QOBtPHf22VKnhII7c18NLZ/XANxaF/WgqKfZN+5DKqSeoXAbncN2yMWuZTqMAB+seUEYCIn0D3shcrmy2xbm1rWS4cZMs2UbuHLvPdWUlUKY62hy1736ouYCoTH8ZVTsXkrrL8uDYwkhAZDYXB1dNUz4adKCvqOFFtCyvUlULVGGhltrgO1Uf5g1M1F6LJG1H6X67b1gKVTUKPqOpMeYL1Xz4TvAaoRzUtAwhiskLJrIuTzt46GP62q3E22aCLDaoYPayFSCZSK3Kzz5excqTqaJnrvCFyBnbxPLkrmYpiTD/7oi0jNouMtYw8haH27aLzKC0pKQ9gz3N0Hoy64ECpeW56wpdlrKW5Ln/65Cm/D4QJRDhv7TF32FEZ3n7wm3+npMHbbgQVu/J75HXeF74up27VBvpiR/IumSH4Kbs9+CaW3NwmjJaLTz34iMpOrmq773mkadFHaF0xdE+6U8IY3m6pfG4q2e5Nmhvy672iu6AJ6H/6D5Wb1lh0ac1agAkk4+yiqCf1Jp0vgNDovCAGsxGvtB0pVHoLLPVLXTqeGZQgo41wcROB7FBxNm5XZU+J98a8UrmX4yTje98+KG3RAWheO0RQmXd5tyQkV8tWn0W2S1DMvWlOjpFFKzsMxoj4KTe5naXLwzMAwwmw6qWqJa+FUZWE7yUus6A+DNAWcMq2HMDlt7oXCwqeUFXuzj4RRpks9ZNO0EY81x3jR9aBLRhJca67FwBlKHAoyRnad7cpuFY5PGtPljCfzPoukV9i4rKqh112QM5kn0L31QJ09PkqNprtvOrzjrM6tNutOtAp8d1SY4lGkAlpz2DXp4aVwmqPIKiYc9CjVKWdRlshpseNOxvCtsx2/DQRRF6vt1YF3um8mls1KJ1i58b74YGg5SLz3pIhcu0awf1gOItfsr9oWnzBl5coWglVkUohsOwfxBAREyXGPz2qVyfsUabA2bXGzvdSjCae1AU2AqnnSiw9YkrepqyingcidCOJQfIqiELM92woUlVuhIeknyy3iUiBYefp3ntQwJqsLLu8+0JCMwMjPhKgR75ZPKLEAeh8AzHbB4yw6pLkTkM5roDs9bUpUM4103Iqcc4KXTN21b30g5KYOfYnZD4brPnvELi43IPiX5T7YYlq8+qzxpz+vNBxKCtmk6VCla+dTHy3nGLLPg3y2EMfVj4zyGesizMZIBz8ZiFw3VCwfPgr0GQyEbnB27HqBB0npeDT3/OB4qFwgsDS8IYjdEtb9uonptp9I2orrhp+/xkBRuDSQfsG1htJWniF8y8+/yjZ8mMcVj9WMbDxhvs25QaOKkr2fJ39R5uQcQbSUqVH75jl4hmXyW+Loa5Vi+y7K/vzlUygjxw5KWWgF+HuYyuCQSyJgr4rKHVRMIkG5aPYkTcCB0FRCXPz874MzpPyKWuhsgSLoAsbSFAFhIgPzcggHmsCjR2qc8+R1WmQ82bkiex4FOqs77dXO7kpfgwRfpF6iEo2QfswihtjsDGhi9RdM1RchHB9uwPb4H3quTGtTxXeOQFG7JqQNyyx3B75YyK8ORKNYVOfB/66N0Fere6mnRp4sOipVhF2KQKHJ/ElQOonkqO8TCLXObE/8ORRawcZ2NlSHyv3EDNm4Nx266xjziHVXiIn8WZhdyswJTH58pkpHn9aaKfDfzco6sA9YaVWz8PK4c9sIforNzt5uCOnYrL7Xmtze52Qc9VhxoOR0VWEPSXDXY2SjZTn3LGAqyCjNmg9Ijk9eb5DO+l6xrbtvkCALFgWInM1i23199VeW2Syq0CWGG8epra6sOkFmFq1l9D31IZEgdHK0VlkwlVSuLzQKcAn0XGBLVEfVB/drzVkV2Z0skVYHYGph1hgg6WJ0ycLTOX0zjB1wI/EyYN99gm+MgGNew0vdh01ooliESLPbqPT9ADOwzv5vWxnQWPAjH5pw/oGyO5w5KQDMgutvmNLLhf/tCWSRyh4MMlwVUCOhrhz6kJ2oS4XP658fF8r97xbTFBhTd5zF62LPVSVOLyC/oW5ckQkDEfWvNkbOaczKhg4MPRd23M78JW8CVqjqRiqUB+1rN1KYUSmkhKMAiH/jUKmcsiFYDleZ82Ba6/BduqImQy4R1WQ49zG74cvDm6WuTDlg1lk8UuP/0dpF7hUo1QWoZNDmWRldNx2dP3bXrMCfhFfH/fXKxB0JP5+t7DYN2aQQGlHZQ6izkohSL8NtidTEQneGPfLEy3cBfETvwO2Ns3zm506fbCAGegt9Fncm1m60vRnh03CQqKHpNyd/tLQuu9I5XBQmOcfmwAVxRSV92zwo0kOoh+8YlSBrS1Ewz2nivKSfeTPxSO/7KkHzj6Hntsp2Oce0CEqoi8ht3ACsQ1/NmiRaD3T/nvxvpmnTfPpImqltUfSJYo7emDnndbonpoVD0F8leqETWI4bCa/HkJowgB/bWgCpaUeNGNfGmS2R4+W/oMzwIA07e53k23PVmlIv5BIfuVbmZUL0r0tv8NYYYQHmReYh+YrQSTGtw3awBLIqmqaVBauTvsGZxCbik9Qrw9lDErWx2MK8fhbw8YySjnqzFN2QWiV/M+msYsmH7GRHMymg6FhsMCdwplC4fmVAUywfVkLpex96G7KhaYWk73EFj2fslbF0TrgU+PiC9s9kPc4aJhGA3Mz6YxyzMK1zT3NtVDjkKwDnt3q95kZZ0y8KVI78SgnDDRvspIYmSeTQMNwRlFiJSk7p++Yp7Cv+WYzw6xqJyL9MluNlvAI9vTxDGIiEzXdZ3bk0XT9HQuDKTkZGLz2VVFioW1LUPdE7x7jnb8PYWaW6Y+PL4wSG0/J1rxdYEqigQ0UVHp1SSx2JCoNFhcjrfczsOYIqpHoy4J7697kGsZ1pswNpL5Gm3QWXtmfwjg0b6O/36duLVNv57y+bPp6hXNHrHfzhOfhn1YFIk8JApex83sXd+nLZ4TR+IUXF2j/VcnunD/APjJZBZvllcPiYtzOhWty5WQeOfXUMw/e80dhEBWdZW2GeGnXzwsOw9OpABN05iD8JP4oVh8Uw5k/TaXm///ajFDNAGDdMQKtGQW0Y1RfDZ6Om7etNfHr33MG85NQQOzc3svd+XUrkN38g3lVwUYiJjs/FJ0oLpinqohbdw4wYAhIU0aXlFteH+Ux4XyNGygMSarMhIMCo30pxp4W8epaE7NBBVk3Qve4onx77RPW4/vpIob0C6owuQZWxAoGbhIbPOeRFRAhk4O97UF7ryzXeT+sjlA9lsdXLhTHyg8S774BrSWq9OVBAu+hqcLMlg/UA0GPVog32Qvo/Mb477m4TEkgnMxXRs5Ai0WgdlTqawmiBYO1HIXDMXEqmAYJq5yfa+5rRH0OP02XeV7RrRtHxhwYEh2yGAhlG07tUlXlCDQFm6KDrVyz5mwqXUF53TLrdtS3bCMT18QgxtAtW2RUVSAXBodzUmP3gtNhNgp1/n97HbBt6SJOd/Gp6yo5qkPzpkSjOwijW1ezo/PMyYBWIxvoH1D8XgvR47wcHP+2pgYVh2HfF0+NXCYilN+YVq4JrHTZVanfzZ3FZPSDhU2UUfBCqlslit3iPDL+tiRj9uN0UcfRIyQbKW5ApChRTOzhTOe9oLz5ZqpXdyvAfdtWE2p6dP6GUkprGFRxGbvqOFYwdYhCmQIVh4/Sn9jGq6GcnHmHz1DpcaVZd+NDEmRyVvKIh9SaVimaakTzM/hcMJmkeWjV6VRLdMcp5a4ZRfhK0b/WACopX+XAV7Yqg9UMbkmEUYmCblhcdMtc1mI0pq4mScjPJyl65yBcJTtsOmV4r9W/2HqKUsjXUgo58myD43ntdprex3/p5ij+dUzqZBV3dB/+wnIFZ0+0hjYP1L9lkfwL+MsIjK/WoM3T2leJcq1z33ZXnRqppN5e94zqvB3JfD37Uv3fKgxulA/mBTxx2bCtjKuVZlOF1R9hhh9hfHY1k7oH8TTZ1BQSUW05kN68LaRNLwg5mIwZgVuvwSk1UN3JLuFPf9P9fh+9iV1eYhoOqkJxABm4bJHH5yS6wimMdteyAFu8K8nt0LooiqzR99GO0vbdutYF7q/EgWIoTf8ZO/Sp55Of8swhB/nCMjWdB7roP9eIierdo8qYjdoMjkqi8A2UJn8KY+cz7JifKRRV+fyrpWT0+X9woRtltbQV0tCET29/wrgd9Hlh7F3k9kc3ZHtcfSrYM+qoejYI31Gb3H2mUbseZnhzByk2yQv4Oy3Texw5ZriVOeT/my2jq3c9eEoHJoTebA5nYjHmGNUR624o074X9S81MQILWLxqtdT+UhOhPzL3g0QEIYxH8G1Z77+4BulsfTTDyCRk3FTKKIZM2xjXfPKgds8iwlvGC8/B5eR0P8FKJ9Vo8JXoRTikbLe0bCCEVrrxFc/2qju0OARZhln3Fqf2z3EHfUZ5SiKhL9d7lPgGXZTp2Zw5I8dv+K34YoMAeKT9lFMf7e9rhyGWmsacqvXcPYjbWqJ5Fh77cmDqXiPh/kTzFLlPUXvQsmIDZMm3OEuLXtsCo8u4rtzaP30RY5vqy4apuWo4uWi20Ozfw0+YB0xzjJaSvJUfKKbHJsBopo250k6nLHN5HdFNf8ZyEbeGCsOt+XRMnZvBw7jYBwehdjVeauC5IN1e7IphWbo/MVBwoF8zJMyoAmmbaPmgwy5gH6HLvxwaYtD0LTW8gqvvwl3IGgcfWfth9gFIvxAlxyV9IqidYKZ4DwaiwQDmQhTqsVHfX+TGpkn/mSQFtHL/9cBAALi4RJVNu4msR7AvroxwJdzYPAjLZX7f9LfSmdISNbaAP3C7oDMj8W7QMeSbC4Mma4zEosi3cfuCHKvLFkku3ltZO++Ma3DnsMYf/UmL8eRuQIFpvR1nn9YaiM+WIDcPK7YOOAYAAmW3KrNk37Z6fCuUCkCPpjjIncr2ZGMMofPA6lkEugXiECzKxGNbM7gkhG2J69AzeXCeCJoLqMx/nfsa/uVzNKZ10H5nJArVWLt2ddcGz262Y5lq4xZtEzpZ3e37KOgPHOLmX8AGq4yTX22L5darHj8YhNddC3CD6LfXAALi3pV1HHhCVJr1TuW2YmvJHj6r82NtA44c5LKXo5p52sZdDVRhIE3OsRytwdnpEONoeCb658HCl3JLI/h/W/EDb1tciGAHDcRK2rwpoZVok+QDogmmxG0pTHe8bOdMjeaSB756a0B27QDJOvkGnu7Zl0fe8MhQts4ww6OcrETWWc9b/4Jyygjjg7r3lHc/yizmqD3Z+BqHr2f2k2bdvmnKUW4QXYYUm6QSLeL17dD7+5170i8qZnEHcIU1Hw9+TcTTaH9G+EkPWdeL9+zf5OiYVz3T9JLfIivWP3Ob0Y22pvISkQ1FgRY3EKgziD6fCiwjRXw6UVb6CpWjuA2FLoQlptliRsekXxfFl/n2sAjUgsrJOjzcA2jcl2KouRR3INQCj4vYIdOOtDX93UeTFcqBj8l4IOyZrpAoQSDTB5tH6dVRoWnBBoS4vCXeZoAuaY3VDnI49QhbRexe225W+WOoeNQgNCu3LFmFr2BcRlcExGTHF0bMF9cKLVCeTZBUMZqWb4JVX0mtqxjy0fBebAVZtB/qcQXID2elcfdhPCt3mT+l3m37TPlS83L2zDhfpOuQ9AiSKgFyLaHgfzPx9ic1dlI2CoxshARJlpF3EQfbH/cJ2/vw81UkUeuvE5mFNvcUCTfvqPE2RLuMGxSHsTaHBgOAIu92kmj92SVKUP/UOugzId3oBGLfoztxn9c1YqU6/CAIkJlLQ3V7VaERexamMKYR6V5tCybmcFk7PAH0SS4zAe8Oo+MR4f7J27kTw3u0wq2sOk4mrKj0Tkd8n9JMq8YYktvkPUt9e40wCDzDtNGEUi6/cAZSv67ZWramhEUWPlJr4Ux5l9quKZrNtbTg8m0IUK65aM7IMH6MeWyTpORpPywihY9axrjfHf+ZV12Z8BaAObOK1HTDCreQlFJZjwXwcn/827IxBa8FnVIs8ikdHghT3ky1anzOKn2VLpr7lxRbnNKYCqIGNytz2HpxuIVmaJHp95DQkEqA7cEu/XLuaQIvp+HlRSUMQX7fdTdRh596zwGswCjrLap343w8u2+5/BMaMEkxgE+NsHsXhWod7AkWu+WtCMMMUOlPte8+pIh06jLnt1f9cTPAINMFMOgdwfxJJDf/wZkP7eank0s77dlp8O4FNfqNLaLhGgzhQKTw0LYpzC9Z0Lvt80j+KZz3/vw0fCzmE0Jtlj+2PAUf2d6epHfDKc3vWBZ2qDOLsR9nVL6+gy5ZOZbomjeurA7gOhfSwZYzZnimaxV+iMn/36ZD+2F/DTNGDjHuXE9qWw/bOU2PZDp88I2wZ3H+z2JhdK7HeqCghFzMDPaQRSnc9VgnLEU9ANKGj0FdvU2R9baekTKoQpZ2sJMecizhtiGbyRJMBVe3cdXznHVSZ5XPSd1+sWlqilgcUDoiN6VP0SlAdT2itYUFzInXmaNJujNH9XkEaephXk1LCB2DGyaxHWLOnuOpkGOlO5tPIs4NHKtHWyGX47db6vmh2a+Zs7wevNbrGpEjRqk8z2nLrXjkeYOZNcVyGd/8dmwhAIEIgZuzkAVEmFnv92n7Oyc5TAMua0FVHkeYFHBLWaUFaT/qfs3+ygldCqujdy3QRI9Eb7fD4kADI2r84RNKa49Jq6T02XqLkpXyTjmMQT4yoS5YOiRwIKD4NdvNDpUIc4sGGD6/Rn7JZMdBgRC7s86ZtrDnVzgYOvsL/lkmC2GS0geL8z24uEnMcfVKCtcjs+HTMGjfPuTz7SV62emDdHstbgiMQ/V0bQlkyj3PtNoQybt0qQ6MWVlT5VgGR1DDx9A/lcQNS2d4/CgW1Gn79zeyZ4LtPqqi3r6w+q1NotMOK+FvI1rhWwD2lw82tw6vrRh66u0j+gp9P6dXlfLuMcblaq2LX5MRot2lNaxiuPmsg+c1/EPJz5mtT2+E+8w7OucFY7tiNrF42geb96Er0vtUa8XJMBqUdr14ufU4k6AqR+R8q49Fig4DLNC1CqN2swIzL2Csejk+rDXy3e4GiRXTr6/NfzpfDF3Z94kfByMkYbIp/ViWR3laKjhaFbtC/rJavlixn1hRMVXAQ8aLM9QtJbHC351OTthZVmcWTmAObd9u+iXDdN46RLIBcUBWfAno5tJNwB43Nqt0n6UfWjd4OftQk9iJEKH81JZy/6Xrh5/t7qfnO/JS1PbB7MMzvl3V/iOTR/AjcphBk1XYbRWp44rB74ja0JpbbhtE5pb0tlYqb3YM1ULuQk0J5f+G5G5noZg6KxpB4TIeuTUBYILzKnaMFdv16ri4UjJxWmuw5oDfDz4pEDtceOl54Dw/AeebjW7MZ19fL7ylCzOn1XJCxFOqb9RyTZfLzEpXs06PQhvxg58dUJ1s+7+UvvaImbhKb5dAhSzs5AZu/ni6FQ2BH/GTa3Qmoy2BElNp/B/CxXJF+JFoCeZz2VmnzLt7M80/Gx8iKbSrFC9A/LxCQWbvtJMlgqSVoBh7zZVcAinQ+RlLBcyWBJUo6SskXR0VOBzLTfvHYnbXMKaxPPCeJSWFTx7isFhIg+BaaJ5DD3P25m3F5pqxa9NmjLZ+jiA1u6mtc1pbHIV88XKjciEglNMZ9BEIkAGw/dZef7aBx5nrUv83i0+RZTRJ9M8kfToV5I83s0LE6inFDP+jHesXhck3PH0AEqaU80/XzJ7TSjiODv8SDfGiMJbQfl3e7hTJmXzJV8e5TDMdWGpQIsOlmKNaAb1QUugyduBcfza4Ygv0daAbXlDNaDgtoOuLRDfCFPh/NBDbDlJ8Q+Gf3DXV1ajxppS9Y4Z4GeOPmOVeCQWNsUDxHMr0WbV/zigLqeFzESP+5ws8H7yLzraPgT0AU5uV8rsnHeWZKcBl4dRqVIqvInz1alCboOycnIeoszZEoSvFAf89KUGtStxaQCHIHUx6Wr/cL3etbbRbjsO9Z15I5UcJWMOUqP24O2JwWZBNL/krMiHKx/cRutSBDCZseIbkEOUd+/Vb+L4+Ttw9MtDnHWMnx6ADQr6peXU8xaOIzUoIuD02IhmytuWy+7nWMyLMyL1XZlm4RT0jHUXBuZI+JcrE37ElclxSa98wVV+EXIMXl+/hrDdky6hqSY8f/rcdTkHisxYEQSsAh7yZO0+dExgCKvHOLdVhUqAFDmJuNAu51XcXEJwDRj0GfzyYmX6ZJzdKcZz7Yr3qF57t+FRObSqwIGs2Z+ZRWaIMqYLX+pTtJEpqNXVKH4Gmi2aVRsfPT/Mk9h4NFhC3izXQPaTeGAUNyMC2rGAdCa3PDmCd6o+nDIg2YOK4JS4ReMZd5E08xGqmXH7KeSX82QOlLv+Ywi0PUH1fp7iln86HffXsMNbLHtIZ2PANS4IjNWaCSjg5JtngodrXaW1SqHJICqAGOFhusNzfqKYdcJ6u0BKnNURuiytDhmWW5oTTVL9AB23PPI0NMOIkkOFMxlH5E6VWQHFZj7kixHk2Afaj+r2Ob/urjpguSyg9JnuNqF65LBleZ+GrpHfDn5bCgQQlcMy7a7/Di64VtPi0GAlp3bcwi0oaKvhhYnUToMG1waUXJgh5URfvv5hQmYD5fVYxAdbsMhXXoVLvBwjKr5rOvDqbbVspBAItLl5MMhPB78H/rBhW3D82McWpKkkoOfKk7PRyyr0rhxaNjbTmsIQbh1QCPQzsbGQ1BPt9vFFfBUS8tG233UczW2EteL1pXrrJFPh5EZSBxfzVu5b9aGYkZIjclCkzfT7TIjyH8Q3lHTDiCdBCJ66PdHmAGR+XQgYNDYi5T9WeUoeBmK3Jsq0xraC4wz2BSV+hDZuCZmNvdt5CYyWB+KJJHQza+PjYaEIJ17uoyslGtUkD1I1YJjrZwBXrtLeTWHQYB1L+qmrLJFpucpEzTmVQKV3J/A9h2nM/QGjl83eq1Q+oKK06F9ffQqTWNOF7+hlkvPzy0LAcTwW9q32uB9ezLpNom7NGWwlU4WAtoCzRsi/1kMi9DkRDi3+W4H3jb2YeaUKmHugBUf4gepX3sDPCLbReYnJZiQ1fFm2z3JNsx7C02qAJr5iZFph1K1n2jMcMCKaHkxjMjwa8THdOA9LBXYsPF9TY/rU3avxY5jIV1hFAuGY5Bk72jgWrCwq+A9jLVMCD7g1OsFvfALbNiGleTQwt7tlMkQ3xue8s7TMBEzHr2W4zUfOygkOGu0PoBppsZtnXMnxTRN3MAalH0vF9pUTx4LUxqwNd90ovdudmH1FvIBOH/vHxFxndfbO+zCiUlU8XQ7jQqh0gqfnGOaOB5gMSs4J5q9vyjQ2S9c9/RhX8CUPu0mBSyTvfIu2ukzI6mh/S2jKFEXldpSd/yN0oItW+uaoOWzcRql4GV7X5brePjWvqpNVR1pJ5dex/KJn2TsxY4DiU+S4hP+ymak0KhHuTJjQZYS+lfFK1iIVdfhIeyvpM0etIsiELmk28SAp7ym+steIylt5JkhCSVAz8B2q3cODpvxuNsgJUn7vFjHHJjhxrEopJbGeHBusgvnWgFFQ0lMS602vhF0EBVOIXm69lVrOvbFnCzXGo1NAvseQlWPViDK/B60HYl3AZqMuOjR4OljpT9lNBPaLauaRwHHsQ4ioIlhX7OBlGUvjLKE4r4UwizzZilDIdCpOQDRXcSYxxwbkMYn5nu93pvgq6cC3kjOdDOh8KoqPgOyeQlJsFx84AKt6t3XKnnHZiKgB7+iMgNNM8m+sq4e5BShitHtDSZbRTw3irzs9Tsk8935axJfFtkW92mULpn18o7Nykg37fklN7qMVfqsLZQgiKoa/ErFIoagZ3jEDbmQ5a+Qq/kvq0I6NNmfm8FgX2szakDtITVdPdXbO0q4dGfn6qjwaO7CYXvhu8bbM7y3g2iNFGgBqTz2Se/BfbseunwwV0bAro/HA68tPrhLL7XtghFkwdgz5NU0WFAKH/gBbfQgXvxztuigM6YQ81DQWjwAglYfzkumrDMApzQ2pr/eH7C0LZlgyYPUQIm6HnEydB74Ni/U19NRwDPP592v/mLCbGVlrjJSiES07RSWe5S+5EoyhwGTkTpLiPMi2+1VvdgncQjdcxX13kBYdCyUlMs5eLZv2Ns8Q5hTfj8rWp4Gk+hN+IGtSHP75UuLCOGoSruGvWyigbyT3I3UA/wPOZpNi6vVKVEalu0pgLLreQpgz/qOCW6DINcrdMHC2Ldk+at4TGJMV9wLcsWzLaDvyyHs4cdXyrmERX1m+MY1kC2/eX+y7dhOm6IpcX6Dnq3UHSAMsrDIoartXoMx62rMRApuMkCEegRcGPY9gH9HYM8FP6Qth/HlREjoJgahOPHgStUcp1aagG1j8lHgjpGU7k04ff7czC1WdfWvMImu/yzrkVP1zAKYkIvEGKaGB6qU3krTS79XCXNStd2feZwGWJ/GjMZzFJvrwTax3Wsf6H5xRbSw7pQhVmJevod2UeLGBz/qPy6IDPkXHVemKK2e/wxgJfbVe0duixvtsbKtbheR/txApl6WTDfxdu/XddjQYbI+oEJBfv/7yyc5fbFUwMQHqwkmGRMEKDQoP2B/pxGu6fpQ4rt0xQOOUwx/CoZINaWHz79cSSiEc7BpECxbLzVlYQr0pe6ikhhz7qiOg6VaKZ8/dKTbBPiKWHzpIOZA6/NZzUgFsu4AVUHh08s2ws+bks9DftS/3pDxMtN5d6B+/Kdjp7MV83CIX0RymYo/XBbdFLe8TyW+D1r2OSyU7FGvCfeD94T6hNNePYbAsa7v8wRm2YYZXCSa0KVpXzc2a+1Cc7hCy8+Kl35pNpiyoI5VvY6lHMm66xaYirwBcTHP1kTx8oKeNqRzEUtN4iytJXX/RrTqbQD5OxGDPajr1JwfL0Qh/YBBTTHmmdTGSNSM5VefAunwglVeWv7xka5CEFu8VtiTOib5FM5my2xD6luBftbYt6UlEiW+l5ic1i5w4g+KV0El56SDinUmpuk7jVvkoX4PXTNEyJOGKKq9iUpXoOcKFyZi5G0FogjnjvA4le7hUaXM63Vk5XwuUm4V7b8yzUkc+BgCTimn9jfoWfulGpvWbi8d8ey6gFs/Vipyi3sIeBQSROhk/2eeTdjhAU35dWAYpVHOSTxqN2C6LMyKBwjcgne6LxhjFZ7u6mglpoXaSRx3DGaCz2G2qE4pv4/b27cM+E7/EEVZoIZyuiPjQmtLkdvIA657lkYWCVIpZePoMr9cciM+1oDCqlm9TOH5WmHebWFjRj0py04upoYVcQeNbUvZrp4OORIwMam//mxdAtvInSUKqVoYFdagaoEGi1m5dfGpi/+MrTL7ZfqnAPaPt6lIS2lSgGeY6U9iYyHsyb4PDkof/ni+uQyRpgRN+IuS3KZWBpa3xgBAf3qIm5jPoWMa5olw9Y54VcQTEjBtXkmRSEQfLOSKz5p3huK5Map3zIo/6lpktbiXCaNaxwV9KAkvh16dQun59awikSLP4MLjc1b5J4fAC3pdT4zObbTqVJPlw6wYPzQSMlwSTzf68upcEcmYiV0gMzlKbRlBLyGhkF/yb6wtVnOheLXbL9UnXL8wbbOoAVZm80ZVP/L0M3ygnQBdQt8SZ0aCQxxnMZUuyHmaEjpJA26DDEAgmw0ZFegRMashqnUbnUmtm3q3rmOZ/1ME51Y95tCNp0lFp0u5T1XEOkuG/LJpGarE/OQQRg+jwe7UM5QeSM40q9zVTmvS4JO6J3HokWpKXvnk7xFppIW5v+Knpgl7DecPuv8PxPEmYMezXEnwd5ocg1s6zxuxcFP82/9ntjCrLGJ4FPJ44MEY2HOqOl4c+LJQaSIRbAzR0UsIys/S1OCkFZH3iWh710uCqFVe+dxeRWHXI+Fqz5z/HReGOxB0qFpPv1PrSqCNgFz+Pa3qBTNkOZzzIwlefqsB36+Qz/RJ0HbLpHgE3AUk7WjjJUAeLM4wMAATrCvxFlZ+hsmyQfSfs6R659azAk6WXMF1hDaK3E1bVmKMxv5iVkgJiZasyzuR12Dms/dPR0iDCQmzuC9Lug2vg8Zq+avLE6mcUDMvCl0MGvNo5cGlb2WwClvlAKuROhssaccGz/ValoNEPq1xl6qCQU1UlwzCfRxInpiZtIRXj953a0G641WbxSYy2g8Lc5lMfzHE8MBmOKdE1FlmPIOM/dXzA4goJdSyGzSc5MtSKPyanPlgnMv+OzoRvrG5Sg/VLenw8VR0Pl1aqXdtpCsJtZlUxyBJ4X8W8F5OXUPx+u4eV9ckFknaIM0r6CeovZYX9GWFO1vgHg9MUP5i/ujMBhQyRZDUbgHN4Bn+IsNxh9Mu6GQUNRtdbDbYo+8G//QRU0voy72wlcm8mB2ywga9xHovd5kK2nVq6p2cXhwp/lWrqpp8MSFu6mjm/7zA6Pl/fEFP3+GpwUtVPHvYWIBitVl20dRY+8SHgjcu5AR2oqfEbByMMCq4iCnqYkBLO+zN7OF+9GaUXG3m1ppFQl14BfrMflD7hbcEaE9xQ6eWzYM1gJluSSID/uvcO6uM85tdXwPkiiORgV4xZX283sr63mhCgo5ZKhgz7kM4bVGbg0MrdnV4LN5mT174AY4NwR9upZm0zbfeVnRJjL190rQdXyOn24eG8qWp7YuBmXmpyTiGotNVbRwp9u/H0WGQFMZG0tWqlce0NPtKXimKdb900diyBpt4ywvNHWIrPXG63SWaD2aMdJHNJVA/U5KykSj4YmVxKZ7q9yhI6Y5rN09kVZlEdSE5+yuwONGjHfg6ugsU7cK95HSbSTBvrXtL4dy4gfihIFk8sYRXq7VSDoOGb542e/x7KbRXDDEWZFIbtZI0lR+8iQHb/ciTpqrLkX2tX4b6lAmpQZESYulPLjn5Iu+l+b0//DiYj4LlVmviX5Z+++ygyg8u02zYw602v/8FUj5xBKttTXIw5rEO9Y4Lf1hrNk5IOxVLUvel6/PHBl+Ls94fK9enj0I3ZBKqp1ZATIjWy3ZvUyk1d9yNrHDDF9G4TTOqv3Mzk6sAYWkhhcWHT7igs5BLcNNLMNfK3hcRnV+xIrKgwTV78dQxW6NIXO83CqxJTfPW7+w3v5sYkqmBm41j4MjwIr6TBAbWCNkVYmhD4BbwRevp7I5/xf+GOfQzLK+70vh2A4w0OYfTf0e5DX6R+6/2NNaAVvOZnCwcmBxzbAyQj8sXgSltBlyc1ktGR8b1pdf3slYAeWTAMnmWlU6kIiEkdBzz2+dbsJUjiSUYnjKTTomQUavPpi/V2SWvOW38BmtNqvISKAVFgFh3BEHjr0Ed3DdDuigUXOjlQBO4bqLK5oyOGz0LRKwf9hI7BdeQGiIMCEQGviNNdAn0X6d3DmK0Gi179k7xmf0BACTpMynGUCUValiGVTQcSn4N42zt4QR01sYTeqdeVoMGzK4tiWJ8VRg87ZztXtOVMtpTm7GwKYwpB+vc6ZgCHd46pNGZffqhGz6G8TzGEGucH4qsCNEdAWFhtXzcwzXiuWPPf0WTa3eWtWzS1Bl7gEFySFVjXKg0GiDGrZRQGWNMA5gHoutdB1CEpqMAUwBSZlfiHAk7ohc7ZJHdBGqJ5GpgL9hUR/S9rWWvDYhkbskM2ocs+Sw4m8rtPj+d4Rt+fbEuYWoYD0SlGW70+qFga8eEgRLPQGfr3gxcq7i093WS+SBtsv0zVuQSzPEqKZVzWHWeVui3ScQYYoEKg5aYXqTz/viwbrvsZ+scNC4nwtUM71B1QSY/HyFu+OCF/MFg6rTT9+X77FB8Sf+DUXIFlyA9Lo5D6h8huTl0l0SJzK4zcnNygyXq0xC+9u3s7i48q/yiWZ20VIbtX3Vu9u+s0IbK4bC8b9Pu8wvfKCl4Y/pku9ky/nlpDRb5cH/mtaxrNOe/unxUfWAE917SKx9DHp2njMrpSb+cjDZ7Kq5pwJGeuYkVgYJMgYGEbMXRoGyVM6NFNHgakG/xgOZ3wd5lL86hkBto8Q6RYx51ZDKXyEEifC57vghbO4NJw9WLPAFZ+LYNIMyEHamHLaAVTRPP8/Mc27RcU5WjZAyFac3HfL3yZ6oaWFt7Y3LP0rxGD2RpLFflHyuAHL/w1n8E/6Ys5lhQPEm/mdi5qEp0MRvpGW10B6qZ9hO78CSBlgl2E+RlUPAG3pVr1O5c/nLs0liy+DAB6TFTOrbgucJU2pPCWqUICzT2DZH4rcbKxT1g/XLhB1XC3gr57fRx5RaAeOALLM+9eVj5xUAX/FKi+3igqUhKtus8abichvmPomayTnK+2NNck04M2HSeMFZABUJ9nJDj5mRxZH5JJvtMKUQ4tbInXwCgH2rEuByfYpKqv6kK6HHay7NXsAG5tYlnhvMxR1iqPDUVCvbIRe1bbAkdgzhOPaJOQseqtdMJnKDSdXtbmG6c64ePim55GMZalRIOuHPZ2t3ZGoD5Sau7L3qoCTeUbudbdgsScIFqYWqfVE9M8kqaeWVBAE8H12qjmFKp5pHn0OIygwJQJiohxubsejwkVEEwLM8gpcWM5vI0d3xYJPMOZBK93mKDo9w0K3n7DL/bEsbs2TIxwJv+bq16Z4kD+nrGw5ImdRLx2hnt+EJu8E/ref9LsMXImhRdsi9v6pXogZVE6tnLHiBhUmgpXOr7rhTyUsPsMSInMgnB/usy4mb50eWw9vQfYKVCV51+S3TDgaZlWfAhAxcV1Tk93tlmn4cXRGNq5gwGRzXUaRAqscQIDmaKcfkzUoVRS1Zd/XFaxuvhE/5wbDtYKHsS7gycjVn9mw8IycVOFRTX5E9GddmkDddE8tjNZyhXOuoCp2quYbK2JHVhUZC+PmMTd+7bRiXTOaQMnq3Y73jIzq1MFqqXjdl6yAX2rjS8JULAoObi2JKrZ/EP875DL9Qf1x01X/nSaQoiFBiZq6J4tKm3CCJvjTZpQBmFWyM+dmRJ1RRx8uJ8YtVoZMHQyT3nbGcT0jmXowz45xKUVyCIxsFMtLtQromrYUjARfad0VXrc9XtiR0VMcAcsgHxtPXx0BZ2S3RSAS0ivhtfHL7Xvu1EMT62OTwoZ8JgFK/AMMn/Odkr/KhuCaX6tLwk9Kkzsz427jkh7joQPS5fKjg5xt7qCnzzWFfOJ1vB1aG9EarTQa8C5AQBkdFHlEXFzWBDF5eT3vwiyEqYopePQ4CSbmZ7jtSPQoxSosoafTqFtPt4vFTYSfLXi6K+xVu7VtCPJ0Vhazo4iqOmY6JMkjg4WnKrwnoPPHG0UCUGVu17tGoaanv9UZq2NC1hEuqC7p/sB9Hh0fOOf5wLAITzj3iuFKccMeJrYIMimSGVQPFyj9VVb33giTomR0rXs4RRjnL+mWSHE7hurtGjXP7GwfWNMKRgTlbtCMVBQlqge8pMbJIb+CW4bOw5GpF2oeFB/DVBIFy9rwaCvEEVY3oHBkWtdT0r7h76CEwOUJZ10eg0vOQDs4GdS1PX7yxLcKfRbb5grufmARhP40VfSNRR+eUvebgJHZVjo2ccL4pDz9tSziaQlvb8ewnR4znXSfpC5xXvhFa+aE/UJsXRuVfAVffGmPzjhs3mmxmhwv7vlxnyT8Ybauhgxdndn2KG89E/xVwvVKy7WT5KTGhu5btN34BbNAphyWQwrvq9atAORevnO5vH1ih+CKanWZJkpo5MzWrHqsKwXLKH9HksjmdG/29ua1WFi/RougqKwCxj9AWLBR4MKNl23yGhELt/MIH9BRNGTu0ml1uzFLtydasXQSOhps9HGx1GRkBWMFh7gHlEbq0EqZ9sKkGWyOVqTxcnsq9hqSMjNTvaVkmYrrT//yPSd+/RSslCz2kSqAitPlT7CAOqO2lqRGln2ZgLaoWnMt97lKpE5g0ywpZ22Zvq/UrF7fPGO/NMYn06Pwil7UcVXtY/US7Gotyk8+hb7mjWBQ9/ogpJE95ELdklGCJW+di4h0zcJk0OiCxsdJaOPVhb9JvQXOXeKOk2dyhyXckLYU4l574/P+oArMQ15dNuUsnJK0zmhPGkfqU5Yd/4GD5YNME8y4MLQaWlQtWyIJ1sIlet7PZJ4e9lU22oOk7x/pHNm2/NzwQCfKXsbFH/hjpp1crVFAml4pgphDLiV7nuGnNCiWcymRqm+6SYrWNGHhDoYwW47P50fPpD1FIEQ6wIRT2CyIlfw251QwBeuyTy6iWGqVbl/YwNekGuJ+kcHk/JonIkA3XnCQmSF6W9RnvyeILIDc69TKQCfDjEuCaz2/kTBpdmjYHu2ZCMEqaRw/oSZAEXrBoq3eKAthD5dcEm9+sfy89NmCgtJQPiDxRZApNdIE2PEDz73oCxeQu1iRZYlNe96nAzitaQM99MyC/u6fWsbGVwakOKf4k4gQmPZqlQtqmncwSs0slKaYlIBMfUCSY0sQ06+AfWiqkxXRMFA1rtzza9sF1F4RG3MSsfrDa/axrnRuslLcnx4oz4frp9u70DJOmvYg8scpaygIZPcMSberhT1GGv78t3xPZeef4RoGnyLOBgqw+Mp0KM0S7zmgy7qgMN8uotyPxPifZvF1lY7tcdZlhqBnLEwwAjmwairRsgpIvGKl/qok0JWQk6l0pVrYyQ6TkVU7vpHzccDnMKjRVTLQdMc8XNxKjkhhI8jM6kstVmZZVgcQYEu9PkITvGrrPhS36l+wuHKwOZ3PF4U8r00AzsItrxiPloy8xQ7LuzDZjaHjTKZcNshpgvOVmnNV2JlzXmKVFVlYdhRuXTrPWwnC04lq84jxo/7ov5xvXebxxvw5lHRkd1p60rfIggXbypkb7EZvcOrpvuoCgq9JKrK4p83VbSJ7KxFfQC24QEyP9GamxE6BP91wnKNRIoxoMzVzbm0g6wYHiWH0kG6YaUxZw6wZsRln69fV6cGzJ/C5sIEgo72CSrDfQ+c74IhZky3ApczdpHQtKI3M31Mt1KpoHG8vovVHcfpQISYrZLhqKKzOxqFKWKNTp5inzi6b+HwAVaYlfs2WwE47HMVIotWgotMB/l7DDxA4hvzyeWYDOl5R5KAoms+9jrjQ1c+7Q7hTl3JFpb0iUH8hIsfDhe5etqcs7LIzWKTqz/UrT3Lk5mS8OMBudvFgDYBy00OXSmKfC5DU89ceb/SQDJfEoy9TgghJ4UqJHS6axdhq24YADLYBZbQcTJv0BsrncTK+pa7xuHY+U7Gq3ZC/OImrzQfUxjvNb6szZBNDA/ZTvK2iWPpbvKjO/tPwDpczsfcgNn97IR2SawQB+s8tfPPKfPHgqZkoG7rHVr7nxVtzF+ydekWUxLnTaSiS/ywRwKsogZBDrcgFzVUKyb/vsIJOG293PfA7pag/J1o/ZUyggwleolSOFIrl1PsIVft7eCpiwkmnpkftVI/asbm4ukaUrZhcwwD4rRCIc3gKdkC0rDWObL4qoid94UNR2aYVqPKIP0xiHIFHX72umKgz1E+7vVaZ5Eq1lJYCwA47kMJ0p1mgU12J+oDo37CQOL1Zy+/39+mKksL6H2MRRNIWf1G6XOsVyyHdo8AsaSORyLZbYj3h36IBMv7RYaNVUkKaPHek3nUyRjSJVE+VUa66VgWrYZBWFrdCmt0CYkLY7Q6iZiawQfNTZxIjVRFf77BL9HKm7dv7Jv1zbMlfVBnJPJctwI3IeupP6alkMqkbORx7Q9M3p8zDSWn4gYRf6f2L1ZwjKK+5rBNmSRe+XxAFV+aQB1STPaoTnvn9ybOdLRPdiXaMfQ/MXZntTFSPh8ZshHTG2lzXmMyFHQQLm1mY+nip1McYKU3cx/oftuY+SRsSQjqMTS5XXRPs732X4qnj61e0ONDzYOeVWUAsZYu6xHcBOmHgOsWORCJfRA44f0XW59oqJq9TdB7OY0YG0bwz0gDDXYIbqoGzfZ0+BjCWlADlr2CPyQcC/Ppe8NQ3gzy3QNS4HuoRuxAOUA06S5blTs5Spt+fAZWj783lH4BfC2FqGJj085i0YT92s1k8BuzmrcdWBTxIvaHh0VPxSKRrnIfui18HTDbme7QWGiuOl8Znd7vxKOt5PO2DomAAT/pT46COuT7ECbXh/PQe6sMaDK4NwVrkNcpBxUZdgS++VWPDPpwxC3LerSVY2tUsicohc3bYYVgVt1BSt5KOrYFXgF9+Qh93PS1cKt9bSdamThp3ohUeN2iWuF7ooOPBUp6eAnnkX/cSea5bi2bAkjrPH33Md8+RAC+HJ8HQvJ4Jc1UoaMVHuvc06+KzA1DK8bqzGJO5ATqY9UL25kg8LyKZEbUNuxPKx+PJ8Wr+XBuE1MAPpHH2zSjLm03NA/+8Io+Na0O4CHktAm0buZ7aHKDeg9J4n1DQN3ocEy8pgvPIHBx9ocmkbltaTtS2dELqoI0N5vMNzLr4jQ2ybT12rAeZDySmaLbAgTD7ZXZng52+v4LoMIMBNzLLYyJATGYvT8+iu1WQDtgqiztJCLO4X032NBRPh9f7kFgiVm/zhNM4m3Uw3PY5ai1vVLmnB/dI5nncQIJjUDqohFaIGsyOq9mHJFipBhGvYcooheW/BfUbah+/L7gWJh2Kj6EwIRG1UevnAaqcEAmrf7WjlCauEO+GU2OW72R+TtytymgtVTUt/GxAQu0MzYPaghhfma2WIt2owjK6URNjHolRTpiaLDk5B1Bi6FUsQXMop9ckX3H2x6RQvIoUi9WSl3iGOyAqfliPbClDD18d3QslvLhmfXX2vhEWhOLJqSEMNMAiC0aUWD/7+uJ9RNAnDIMDYizvAMCldKxC4Bb8+ZVLGCINROZqQLWHp2pu8DHqgL6CqKpAfd1uPc/Igs4f//JFTHP6ZEfvw+RzrDJGw+Pl1rDH0bH5udsk0f0ga0tX2iAGfypPYkuF/3RiPexVdRIvSLRlNlkNLvGOZZr0KFRN02a1AMr1qTHUYpcxt93/ELzPVkgaLLwShuK3U6/HqqcSvfip/tfcmPQc3JXbHX+cxCTVTDhzoU7Lnj/KkL3C3KJGxFxc5QMJff+IPBeVh23XZK8EcVZ61B6OAsZpgN3OvJvQyaSIfFB5U/6HXexdWp5jGc/FTgfOZ5N93A3hrlhbmK6xa/NR2BE0JCVtu5wOmu3AGQs5AX+9+xcPyiwY3w/ltrwTlfJQR/e27nO1m8Yswaxuv/3Ye/joZ6hsRkKZ0jgjFtjwCknUaUOxpE1Lj7FRuOn/YMOhw70synwrfXJM2OEcazsURONpAb1PomBP3GLsw09f4UgCt3RFf4s4wG/vzMXEh42fD5J2GBX0zE1yjreTKfuHQjeIg89Of4h7IExzMkSrREkCXW/nsjwVKPmKKQH/WbcOPtIEEVE59fLYwbbdxhQLNvH02nF+1oNz6LAJi02Pl6PIb7x8aE2Uj6DsSTKaP0FKD+D3JN9bWtzkf5RCg5rMJRRgRsaIsFLFN+TX5FtYt52IrMIYUt7cUcwqAERojjVpbsC6b+n4RtC89p6U6DP5MjgVF6dIS8NyP4Pf807upyFAOX0GykDyAEjKUU/dePKhoN9K5t1EbtT+mDtj38dA8uxifK2YyZKF4z7qbcXzLMfxfC+dWR2e8C2wwXbWYDwsuveMqAlIOgDGgFQC4lw3B4qUkuHgmUxjR4YGZrAZLtObFeZnw4PffwnfK2xo/SpIVuR4/ZyQBDVqAAviYKXF5qWqVq+yQN0pB4wxsxLdfElUBKWzRdOU3pbxYTaaE8BZoYn7/uKLs2fqZCS1PXUqW3zIQkl+FzUJRH+PJ15joOlOSk5iF1f7ivyvQ2WzSrIClBsrGF1DINc+YG5U0y4sdFIKaq4N0nsphpnyTmvyJBlbT9JafuELQbnQ+UZIGKxCqvIcKr5dT8H1NqPB4PTYYX7JaV7/QCQc7iu+pEhk5e/7dCJBhh9i5ILltEKxlXNkyry3896oOvxggxTCqCfwU3Zi5Yw2v5c2GvKg8/uii3nfbwegQKWgjYBQDuD7W+U6LgzNiz7wo4pP2bEPnP7/GkpGylqZ/5VZJl1w+SkSA3A7uA0sSaMA6cJgSQAZR8TYbAAOTfihdink7ni9UmYL2oLk1o0n3mgtwEscSy7nNAABTmWXB9J2047qWcXor2EHQ+a9wGDCL7PGWxW5u+JfHRV9eUgJKbt/x3/dfMpg2NqiI2WACwt1rnYURDpNYsDjBih8uBu6WlaIk+a/QHT4EzVI9Z9ho2SoW6SihG7hguTInDmPpLgx29iPpBaf+gNgnJ0h9pZ5YSTrwRiblUxPn62EItwtWSEBRRtw+DEMaaHC6mUEo9GViloFmHmglyLgLf4Ddpmxu7lhZw2M7m7oIsSim5iKeTezRWIOuU2U0CC/ghUFys2U7ROeTFGl7LaXl3g7sgDEtaOh+Z/ZQzlbqG8QIZQIAVTtEzbMtNWFhKoa7MpWEZ5OZR7tFqZpxmyuJyzL4y5TJbhffl37x+u1+drAbgmJCSc6TRqc0GYdhPzXfN2pTIFkOhJK5iP/xy3YE8XNIvzbSZZSJldB8wSkNF93rNaBPGVrycqVKnjfCpWPhlgTkBXgixN0wdKXz+giV6VxrgdeHP1D7uQnUaOG6ZS7FcNMqHO3Zjye0yHnzkWru/j6fds3UvwJ3PDhuqSKLdIGiKvy47ZhVlagrA+9JN3SD7W0G1ubfUFihOB1YLjuzLUwSMKrwGH3uVsjTuPoMon1z6QssWoHyhnR9crbRX3wBI0+65BGDehiw3IEI4NWb/n9tvDG0g1iW1XrLYtTnS/NNm5hy/WJqwoQpMBa2kSTQAsrANj2E8WFYBvEqFOUqLXWjvCePryEieLorFJ6w8q39H2xD8rwoKCZtovpM1Gh/J0wRthswJ4NyBT0KeP5Dvd1RPW9DVv53saRZH/Tt/VriiNntSGH57q1CloT2fB3MxDwflQwyGlCLnWnHV8HsaH0DeviOTgvP+0KkoYeKB1us1E0aBOkzSfGo4kvX74bmfpIdFSV7gDbNqkTwyUY2N4KJV0OfmQqNLY6KP609iQjSqiiS1esKD8r6Ra8bmu+2L/i83WMJqMAvCQu54sM8+HlLl0Qig40ot5b6qWxd9ojOr5AK+RDRaPbjDYU5Nh6kiLquHFs/5dJL4/gaaDFd3npOnBCCRSOGiA9hpqG2p1erNuSLed7xb+CAE7eUFpSUWKB06Z7VHuJviD4LalIyyH0Ll2ry8ZxR5tWN0vv+hNSFXgE74YZfQpeqNVbdbUl2TNLf7jEWfYpQlylJUf6jR/fi7HPu/TWxx4lcuqWhO5JKCDMLy2L/LNxhrrJHMP7Xp8/cguJdyX7Iwb8103bmdBFvi43JFbQj5lwXT1PWIvwxWFUm/o7X7pwt8JVXMzV6gG8dwj4Zdh2zcjpI/cotih4VuEmTaaR3WYbg/OFkfB02UZo+8pBtuGTHghTGvHDD2hzSXtJk+Y6e08mvA6AEg7iqfom+wLKvcG5hxZXGg8L5VaGpqeV8vc/Hpz1Cv8VyYAPAR5HLq3OCplgxhwO/dHKueOBHOG5VTzndOH9Z3ia9A82jnEtI3PmZUliVUsAFtwnJ0h8fH86g0uEygZe9sGZbF6epq1BVX27hT43hmqIfx2pqbH1w3R8lpNkRp66BDu2TM4brJjcHngXQUXUT/fqDrTceQujclaBXw6Gtw/SZ/CafZdRZiZjQa9AmJqt45UkP2fv28NDSF9fe0xP7y4HIPVd1uBqgZsgRWlPRS4IHaD9Dby7UxIJCW9dV4eV0t4HglUccu43lp3uJ+51Msw8jSnvYZpVt7zEOQqn/VlFvdZ0oCSBzanY4cfyg2W5pGYPw0h1Q/Bogp9WTxVCn1RAWw+Qi4GNST8dQyYNVa1SXU3Y/NF7xQKAOJjUw070IEztfIELNAItj9BPqVCyHpB4me+TVtkqs3sW9//HDv/+EuoFpw0o/G62Md+zfOwjbGURKA/GqWwo99gSAacmRAe6Y1zp7pv6Pl2nHg2a2oMkqziM0QKUIgBOhXY4TedC+dpTQkygD2y0zqPP7hhvX73aqncyN15jinm5TWxD64ydS737JytqRTZaqlR2znhb5OT4AwFEnPN6X/i6xxGu5gER3ibLXMLSG1aG4x5jsfenQpBDbrGs/JD9Anu3RmybGOgrfj/EWq7FvMHCOSYDgkPfyJvA9sA0YlUw45a2woZxVm0e61je316Zg4FdCUwXuUuQ98v3JplZmQDReu/JV61O5nnyVk8E9HtWHG8iQ0HxjoUUTIchPH2cnyfkD2vcQusNSpSqXP90q5A4bunIllFS077E+j5DFXVGLeOyB38tqw1qpq1Jo7Vk3yhVGsllEUlRsk8PJ4vGkL69MHuc0kuNiVHHDnX3KI32aw0h0UEKsRr6ib9+ugPWit0kJUrhGP+lHPI8h5WYK3OcLcrW9VvjiEoiTQznNlVMdsLUgCiai6IxoKIuvSILKGgHUjV3LcESAXaTGo52WtVdiX0/LNzXtT4pfsKfVEUS1Di1hgiPBFx+XOhjXhT2lSkLPEzpEe+0pH3yYkHpYYJ9Dffmd7nixBPBZahVKR3PNsh7TQAjnXsybFhCK5zhdOnspEkS1Y4uHNJD0qdA4eTSGf75yFKWiVTBzced1X63vIWbu2Hf80bOtpuvAU8phAjdsQ3IgX1Q+iMWhrpsSvpfiWmAKt+tAtSihvHWwVgZ49Jd5/0FcHL/cNhWIOV88pJ4MbW/nTmUwtjZ0z8mXEbG89hG5jwa1o0PudTosTC/MGcUtxHjEZ7QYP5FLUtFEQeke3F7PVXe1pR0pQ9qHFpzCFOAfg8xhiQMFbAfw4/C4tlk+y0LiX/2mYHzvjRMmRNgZnRdzh9bthxxrXO9e8C7QMlxeAzZCxlePSHcssG77ihYrLOjgn29SFWtdCJXoezVP6/MNFt9MHz5vIPNVhugph9cWla64dXfAAX0NVAIgsKFpHfv0qJutTDYeSeAnpEcDloFnNWtmI5ZIlko+lfD+ts3z6DG59Qd/GriACPKaXcnwVCiOi5SvDm1o/mSr3qj4jlTEcCEUuB/jG8hZ3u1Lp5ogGtAQgRgvVFT9DEY/31l+wiVTpEdcTjiupp5yMq/7g7xC3kVwgU53dkxuyb49OmEYP/IeWu/mbLEwGHP0PkRN8188YluFT5x/ZeB4D0KpdJPFEE5LAy2i0tk4aO3SV9OwARii8yfoatL/9StzBDB6B/azIqplF9uuGuwVFjrI3GCiovEkidZHgZFVTWpB7konBcPk3OvxK/h3VEoziKH+Nlnb4/8uyFuGxMZnORic1z/PtBOlFxr190FAeLwoUSYaAxRNzE1gREUiLc9UZNyqlFskZrLRIgaMFbHYuoPdmiJBHg69oAjf48RpYfgOHXZD2BUE/5edQhDZUZYwNqG7ROUi+dbN6SPfmtJj+Px1XEvHR+Ha1jgOlDO7wf9jKoBQN1q5x7LverW/g7BQj4TSMHqjk+aG/9jPhp76auqZXh/v14/UFZr1Wk7VTjw/Bgf43HYXd1sQ9jpBjIky7uONzsj6TupQvjpoudLKtV72BYiXFC+mig2DadiHp9PTBYxR36jj1t/S/vDX7GyUdwJ9N3edZONXhHlHisZa+qVxujMayPZUtn3M7wQTOsRrcnB8TIDcIupePbw76m/bx4phjNfbfFPgHg30ZuRTvunsev/jCxIujH4AafQHb/LF1rPiopiu25Ti3ToYUjvJ2FL/Uv9uKKRMcS9mFGhUOPjNgRhfJeiH29WKFCc7hbOJFDwFIQL6iX66DTZAc2ulEnKt3e96itOW65chl7/6DuEhUAyoSckjOE/JR264JV1yXEc+o7aJ7q/G2l/8IArxc/CY0qMFdoCKRO08KOzbPRKYkullfrdh8Q5fQnsr+mn3qYDUZ8dyBD/wkT2dcDb7vsPE/17Pm9ZI52qv9ORX3rHPG5wJlfTgKm3/zAe9FNYb096vIQot0W1eUYXfj7cpOv0OHqpOtWIfuk6+DR6FmCaiJgnPOOtneAHGSHnIoe3zOPKxryt2LB+/paHzP0uN8ydlllfKpF1nlp6COhyC6OU6oBvIve2T9LX3/CK5flGkoraN2T7+aCEqrT3eSOBlDjfSCyPVzjI+PE48gg7GwvKqLXRwfkSExIaBxCBJZNS3F84LVK2ggclWf/07ROhEdntsqZRviJle1fL8NJo80y4lFpR1d8qKq3TcWFYLT1lWPTxVvzYj2JqrP/v8PFNMjWqAcUhGnH+W+swtWXA8swOweCZ0Uu06ETSWRlmpKFCTcwLya77BmQCnopcMWNg5l0qcWk306+YuaAIB5IXIxbt3GLRyaT6kcfWGHOyY8OmkwVdPbqR13fWc5JkzLXol/VBrOs24h9OIEwK0b7d6Oimlla9ZMjbbeM1P9bf4kT+oD6slXRFsAnutMO8/SkOeQYo9KrQEeV3wWwr4llHUM8CpTzsNAzotl4Bccty0kL+/HKlxX/hGKEA/z3Y4LceuqllXvrM3aCyVIaMFmFvnY2TLqf3LTuR3n5G+koXafvjatr/ECN0/eXHrBWj/BjZ+JmLKFBRPv8Lk/iicDnofutF63swjUZSyPla6vab/79BbaZnudPZDaqFvCWHld4P7Aps9Ch+KdZl3bMMejgy2eIMYNpcKE12tyvIpFFpo9susM/sWoA05cRnfGyJfFgItnepnrM6EHegmCdJ1wgLhzOBIG2QjYxH4zb8gelAcGXyK/+MhwnV9jj4weT4nIwGpsOKJnnH0BOgKa4JHGqYpmpUtcymzMvSvcc5irIofdONYo5mw0o/XyEmBwHt9UXDBwBHnEAWJjY2bGcj9I/00bKTJc1zfCE4AIJOMl6JKxxIDtdEq2Wx6rkUODo/hG4J0M+afYui5ozpV6Cf8OxYGHCkXdW5ga3E4RH65BfEat4EbQUPo3vGc1+E88V+pvWMymmW57dZ9elo0wgx4U89VnN4MIFge7nDJD/p/SCqRUz4wSY+I3cHjDf1xL4PeYS0OOwZp7GVZD8lXDl08zeFN0ZxZSStduqO/4DcbLqJGr8dEcQ/WAESKFrCQEandXvFDzPLcF5CeU7wjZg2HgzACimYQTATfBKhF0JqKrpX9Za2ryjHKWCcAjAXA46EiWsnXRMfyGkWEhoOMmiCkCZWjVZpcriUSmItU23SZ7stLi8L0WLu8Ht/ivMLQ72/oKiTaqyMAxSbNRHu3jbz+PNS+gIzqMTzxOaN7aj/m/nNooq5pLQXi+a9YiTyT7vNaIdeVU5h6YV0GuFP6pfECVWN5EtRoibmGaP9MwvaLNP+KxrJvUboaCIe4MN7cnQxXTMkmLY0i7g8rT2H9lvtIEcsMmBLTBSXJflXf6t+CsdRQNvci5lHxfinKR/cqsAkgGgvgcvP/SN4bP+8k8dqXcmaoq5DKmeFCIK5Kut92fzgYcYq3bbsSskgyQnp8SmEatCoqnV+EgDSYg2eokCF9+wUKgKxHSgRIaJ8VH+ukLvMUxyoIX/GZfvKSSOkCj+8mK3X2pDncKrb8o2RaRu/wZ0Tt5iYsH3cNCh1yBa5iUVA/RQ78fwUTS7yJQmCXM3Aa+Do7yb/Zh70Jf3zDkBd51P7mCFeR3YjE5mwmEQiO+G7jmrdSKR8Yp5tKctPSoEL2xby10rekpMEbHYfEfTaieueUS07mBnpRQw2T0c+1ZMdg7AXLm+P5I2ecIRlZZbcpKTekQwPwKL6r0QA3Cb/uuBu31adPVPahgzuWYvqFdIdPQ7iGesdCZuY8r2IxLI93RkUHp8mGg1ng0fR75Lyj/+Z1vXNixOhVHGj2S0tKxzyHdGFst5q2CYfYw3n947/Yt/y6Ve3F87HfTiwBg/2jcCLcB+jhk7M3JlWSYr4uh+dRS4U5m91bDB1qme927fO25xEsCEI5kMWd7+ySP+FoY3cWsHM7VghpEyk/NpEAeWTNkkUzKyX0bmW5lnrCBVwSvBPz+09ydU1IBm19OPWlK/vizImp37/wjgM/AeBjKMKaugI/JRxJl7SNRuHkBm5vazVTYBJO7/Z6uwPVgBqW8M0Ia+JzDBz/9WFdVSUg78NQpjxy3vmEow7GlM9dut8Pc5wrUby+fLjoDz9uC5Bkj5GRYL5FeMDnKzJOILLsigLKeYfxav1b66dGeWyVtgJx2wssDiq7179x5Yp/ijqdU/dRJTwV0oiTW6RHamTyi24ud8wiV2OWzkBpQ092yN3SflCLUYtSe4JKq8jr4niGuw431ypjGrj9EFS9h3cF5pLhVtlvJWc3/isjfY1mUCUlQ9LUIp1Kjnj6CZBrRTR1AMqrVJh7C77xIy5K34/+mJh/pFqCa38zZs1udCICiDU26Wbe0kXMx2ja771fzFzAdjEvgw/uKGGi2Mneu4slJXaK9/ylKIwZazFClf9jB8ZFfk725+oMJa1op14+7DqFTkViV0em2EMIAzLZbQdxgICiwhU0bNvIEF3fLiqKpdCM0Ulzlp1FDxgtNH8AmkX1AidG3jMcm2luL+nZWZiqaqBqpUVpYcosf/sj10GhfZ2/pn+CIjoxavMPeb/9GDyfWKRYHdSR/TK8hoxH9fseHPRIrXbdTLTKOkS4gTVd642754CKeL/8SrFPlkSZi5enkYfl4b65m1wmShjJ9VSsDhH+86gWXXFcUIdwx0FG/bA4w3IkonGT39O86XOjxokK9C3xNyZeoq/ePXokgqZr60SSYX0VHQlOXmjgQ9JT4WkVxvFnAUXxQYINIaKawdkUqjpNJ5JWdPBwntpMmePClfRtDNNUPZsGxPaRdkWt7e16KXvqK5d/LVWrncucl3FQ88VbyVtfS8JsC4jT4H6rFCljQA7hUktAwuSv19BmrLVmaT0CdTZ/pPH4yBcj1YIEITs0lQEPzYWIa7PHHXMIxF9zhXYCYe1ZX2+jLjra+iaSd0UAemydUZ0GOrDETCHJ++zv3FI+eLdP2MMJShaJYjWKwNiyDFzGMYrTqs+VjuGL5cZGUG3wurlqM05AoWKfcU2SyvG5WudHoZloiwSNsPVjwIWIViVUCjX7JGWH5q0eqUsss8iu9xtqUqj4e9no40obBawqJ/9lZtwqfMOdSdK+dJUlj/gGN9Owr5DWdVGWihdwBBGRiTw5+QXAuIVEpZszplurpDYm8y5CBRuBgkO+A0/GeXFQsGcvNOFbt1EZyT/eJXb/wNaBSXRFnxYsHvjelQTYYbxU7RCLaEBoTskSeEs/ykVvEFiE2O97f9D0MOFbseC+4HWJ6glu/chkFyG7w1Bey+rB66dadT4k/0i5NMBH5/rEjgjp6v0DiNDxfXSYPdHMJPTdd4k995lmpBhL4nf1+AVxpR90j03LswPBSjen2kxeaoEXoGPbBzqZHT/yGS7pbFj62To/TUGjq2/EVbrlZftIQ+t4xE31wRh/bfu79D/7PytN+L4vLX/cp7FBF26oRqgeNu6iQvvR119Iw/PWso3sCjqNNENyMFa5tMvupuC70AOiuE/iY8/zd02vygnWpLZ65I+v/Wd3tlx4W+Lclqa130VJt7hgDPDqmtMZU1raNMsrLN0iDMPrW3i6ToLiseX0Bc5yE3ge5SgBQdj8k9pxmNKjm6ZZHl7YdpZA9aG7dopwG4vKJSreTvghlhyLBjqQg+GMOi2TmMvbfQUdAYtSI52IHRclJNGqC+BcaOrf5ZRZl1jU/4lnwdOFnD8yDiGyiOUql8bLyoiE2XueEiY22vo7kbu/Md7CbbdULfOMxm9jcdhskaWycOnAwYqDMGrLqmnrRzZLqATI5fpPV4SyzfQnEoZXNa9QkVaeFVGyTrKiQq4zRdy/YqfQppEf/bbd5uBnrFftcW8c4Yft3z/XQhM9UnHvxKtMzyA3J3UimDqtbNUmdjbf5zVKJN4hYLQ4+T6qnM6wZIOmAH3iwlOrrkSsXpuaPs6A4jg+SXaIXJTngrzUEjyyFORDJRGgxUcFyrpafOwq2IqyEJXCHb3HnGiwlzDboKT+JvKV4DtTOObQPd59zwtwDw8K5MyFR4N0wUg+/mmSCsowhTxSMXvCsrO54HANjKbphSIgThhL1SlEr6qVcDGd16hkSahJKqWKkqHmfi7McLJ18460FGQtcQWbGwkAGA0RI54/5djCYqZyBFek8fCUCXpoqHG0PbqjDh59BQUvyvY7IMtwJtJm9bs1gvebAYxlmxUUyUTKQtXGkeyoj0tOHq/YJOmkiWaNYgl9oyqmMbmpVH4wDLZ1grEfi/9zuNJtkGbhvvYFfJSYqcfvLx9EipXfGdqZQ/92CgTdAsenzyQlffsf4QcOFMzAInJJKmiyuZrPR0cuZZRUzTq6hX0C10jSPtEFeXj2LEj2burvIcvuKjo3KleSdUXLXUl/1KKg4UXeqHGORFIpBXxAjPRlJjPP6Ujqk71ickZr4glD0jF5UW1vWwtDsBDVFxYS7SjBJSziI/GtvEK+0Y5E/GU8GypRE2bMM/l67KNl4LyPqs2jZm9HfW+3woUMrfIDX0Wx7n45heFOKPwSOyMzRrmmiLshwVM9vWWL7nthTMfkRdHJnX1xc+80kpmU2Ib/+Ushz1QryMMg2InM0N5DFNDXqq4syG0Mp4zdzU8/B9msIxrRI2yGaCaQrTW0ZvR1LtKRO51AfHLRp1iQNE1dqZwEV8Ge6VlOLFqdMgl+srIMTF/4wwq7NU3rAO/5dHMBZ5vyQLfVQcLg3BBwaJ9Q6n6k6wC+qowG49CCX2HHhIDiaDi8XFe3i0vRJuMstcpi76xpJELh9U58NXe2qBg11ykZ/7hrTajV+ws5nXzXfQqBVXIdO8k+n1gpQRSudKrAJQAzIVCXsWqDWLiCwgVyqyQiUcpgEcOpbXT68Yjhx7p3PqFaKhiQhQ1s7LwDZsmAf3FhlKW3W3xtAWGWnP3rPNTZKfG9qE/QK+mqCfsnpTk3tzomnDtCkSCgoLbYYc+mUc0IYPLy/RW6FO7d6nCTdI6AMb7uB7jGe8nRX+/PLwiUNGgomOhAOqaA0c7U60q9i0kkzy3BWdsro/jO4rA89Gud15NtW2d1SQX2AYQm7fJ7bczzl3gtbSi12duw+PPyMxuT1g5YsY5lqiI7VfpcW9SnMWAB3zgIGSrjjj0y8kDdN3slZQNF6qvkT/GYfS/CQo96wV6W0I4E2DjhA7mDdVlBfso2CEluXiv1SEN4kF0A52Y5G/BCT6hmRYrEsvorG6ENNTlktv/GTk5RKErTFb3hti3GzmbxsjngdEZPaeJAntV4ZJfRRwMzwPSTkF6WdU9IFrwW4KoO6wIcKkK1lTguqUf+h7AtOPlYLCWTedEv7TUoqZoJ6w6IJs8iZgeSDp3WykPvkMDu6HweFQdweSil6OqKJ9wmJ1FcxLSjpLN6NmNiTcd51hIUTpFkon4CzE6sOQvQnsxxuzqIpMufY3tclL80Dv+5gUYF9iMHSyDeFUUCKviOtpNIH1ja81LeH5NIOO5kJO3SDeo55beUO8a1B1eMnvlZgzYXRSfcluveU58rte6bCQ+DFBK4MRO34JScaoTomh9ySSKhjvAn0c/UueGDiYnsX46gWs0lHRDRj75z80VpcU1oZIJV3S28MQ6/AcPIoByQqPHekC1SSX/np62jC22XL4ooB90Pbku8qMfWz6fHYB0e7vKVzeVE3LCIZ5d4cbnYKwEaNwx1ZxLnjLhgFGrEdqxsnxiz1cBeaOM/6QkCk/sXME1YJEsY1ITFct9BJS4zP278d116NH2FHnkUSy7RagQ4hxDaeKM1wXuZPClW/XuMXClQfqRxyX9uYsfUGf9oyZ4hReq8OmzFBb5DOey3t+G2bXo6iEOa+2k+uL9n67ep5//7OtYzoLExrPwjzjAfYinaYHGquvVhySKWfXOxKN1iMlQSLz+G5Ii0GOHKTtOQblcYNla/rvEejAzkLQ0nENsYvZ3/3mgSIBI7M2gkfBsfYhFi9Z0qpEdfDipnCTNvOXjXdIPVfWgWsOy/fKiaIVc/1Nn9qdvahZQhBmA9jJzv8ZOL8+zDOos8Iz3hRnHFfxzKlyyOMa/7shSBu/CTgYZxDK77zqPZeOAcMILBUYyqD6A2mjsxiL70K0w1dDIdqGuYM4rWHvL77e/LAbzEPtB1iF5RRTv2P8RiGgDW4CN85ZrrasrKQRtXH0+uMcQjvVmsdiyaAvWwEqeNdZYSBrjso7HUS9JWT8131uZ6a9umWT7tFkaKRCJObmpHsK3N6uHT6G9tpWTpFcFTLzVIAysM6eXZ9GyUMXhGD/cuYN7tGud5KNHub//j4dr3u2QQYSr+lcMo+qIvOEsmHl6FERNtRqKCvqGTlTCh526OouW/yeKs3cv01bsWL9WV4S6fA9j1zt+mo9WBd6KHMVJMooUXuiPntB8Z+84egCTALY0YNxmBxDnejMaMMgyLeEw9dV7Estu4sC03NZyW40FnXDC2xhwXbZbLxfOHxsC/U9kL/UtijA1LlUHlu9458/pzZB+6JNELVVIYSqCAoZbKs/HWGgRFTSMvo5jeX6vfmYt6f9ZptJZAYCTV58r4B9FvCtb2uU/AnQedjBXFrdSsQtZgnAML+4MtNI7CYeK21kFIFCL38WoEkB2Ix4Sf2D5YD5wEEEHM4w1q6TtKiNG3YnbNRrCxK8RwtHxLcxp4qENNF5BASsc+v159190ygklzm9+spPL0oABv5b5WHcglT5zWpj2auJ+xaBDay9vxixen2mg8SCOK21Yn1y4dutDUFsqoA3V7/Q5bKUyqcZHVKhtOxv0wL9xSeTw+pnJfU84Io3Y2CH/PhHklwLlVbqXpZCDJ+wnrQAvblQtIdwNiCj/83Lh2AfQx5Nxrka1Gc3uJ7sFY44e5R5Gv862QUzxSdI72UVqWqdr8uINGaw9qBYZ3qlnNdGdAWkUbZh0yeooEmSrzPeSVfAQQyhZq17oayA4j2HLwBgenDc7PiP4TdXULEXNRlKo8GnAoAzJ0p8f8klKbL9HgnnjFZ0aXJUUQFdzwjWNsuk9CugkKH1Q3K5Y6VjoKUpPqVVEojnfbbeLF6SClJ4imtd7/KxvjYbrethEtPXzkgH2HiLOn3WRMKd6LreAB4XJeAfh6V4DI6ttKKiD9weVJXUzKaa3Y7Ursw0us/M2O9zz2itv8a6X07JFqeYQ7SbHjZMsAxhUTXPSt+9OaQefoCiDrM7urnyQIoTPKCQ6MHZjmfGp9/5YW6PbppLA2MdolC2gyUx8c+R/b3fUfTdo9GZ2z3FVLINJRADiUbBtOrGd2VIyNR7PwuT5LmvPpommskA71V8NW0h72LxPjMnFgQAdk5QBvHJHwTz3wrJYpCKLRYHgkLNJ2//ApbuvT+awiQYP0iqGBXKv7HiBh+QIbiGEah1AO77C5Z4Lpv6bbQhmNfiV7VpC0MJqOA54Ttp70eNqLAR+u9xpKwBc+1+YphGvQNcWDpaAAp5FPL43FuCQYjs2QWW2Z3z8+zHrkFOiRmqOZbFbJhBN1ZziYfdjM+ZPOVy991+SHXE9xs8Z9HdTYgQD0OijbaF5e6CMr4TdTwPGe5ACCm47G4wjxgaDOX63TSQOlF5NWXmgrBlrzvZ3VPq8yXmS0GnRKTyonEZYKJA4leLcnngYigEojxmxJXR0T2M1MnCR5DOZ2sVcugEFqCJ1EpVkGJkOFXBoBx7oqorYPN3n2fgknepVZ3MBa7qtCQIsIydDkLd+/VoDpvqUN5+8vROD9P3HuuYCck8MZj/veoZa4EUL27zfhba0xWBSglFveevDPrcgacDYj2TZSRlXIc3KyGKwipCdRIHWnWF8KlCbbrYCuo1UGt3pqqQPOwh7uvc3onnU68Sj8RcJpBpHtONvA5Fk/ED9akL5V7Seh13OgV78RjTNYAAXMdScNCkrlhEVFBhwYoyGW0cweiiCbUievGI49ankO52bTeB7fwygOrjOpcM8FmQorRbvv2yFN0wwW8N+UA2kcdb4JfOjE0p4nm2RTxd2g66plFJUyXHt1Mwh78kH5lbm4gdjW2dDsxy3P6+RPCaia0Whhk0vdIHEG0ZINjJe1/1Tm/YWHSQvK/EzlEbkXOUzBG0KmP4Tg+RdVmduGJJSNbFjZBit3E1xAz7UuoTXMwIgjDPt6ZhrgQBm7OOfC/A2m/TKQYlUUU3LVTQqVgk3YV8lLSWuxa1Z8sP0tWf5Sv0gxtURzIKmBN/Y1KopC3/4+cLV7SZm7LjI+ymAOniE5XSKYxdmJYJUHXTRBt9jSKkTlzT3t8x6i93Vdr2FQB2F3gt2/1cQ8iWXp6MgrAXQa0lcea+zkTyc3l063BvkzPKpgdohQwOlCn+6MsouQDt/lKtAdfy79hR57tqUTFvKMmLJ7ukqj8WiBtI7pwyBezQC6KqdyAeSzfNnc8PfRjfF/4K+TLzEHi3LFdZD1FLhU1bRkeh5HVK1kvFgspNCRxCuOlsb3D2kvbEudEIuLhG9GHax8LS5bWnU88dQrqwx22rp6iMilCLFrRBjoKEuWUloV9YYVf8TSpZIKmUf6JKum/q5MHY6IJZy2/avHPWN9gheF2iMj1zexdt5es719w1HZgDSntHxgQCB5ilb0ZFayC9sFrYbx7bcazI+VCZLuedVj4qwhKSP/PFnRJVOgOm9Nqd0f44VHP75lbsRRaPTXSe5CD3d2ev9g5W7a+ixVjS22rA+8nhusupcnG+BN+4jRyFRcMg27ivU+hV6djGG22I5KZ8g83p7trY6jhh52ALn7KfQPabxqveWT+HJPaRj2sfQ7vL94hG1HSoEgyuXShE6+cQ3NHnU8IztCH481QtT69vuSkJyUHEG1R92+v3bfVzzxS3bKd9OlgDibF+Xngqv1Hf/WyJoBv4pl0A8n3C+WSofB8RjLi5lzk2/ZeQaYP673jI584V2yJu0XMFUA6sJu5k/ShdllnmmNPDz64QZrKRqrY5WnTEuIzXkffsBtXmJ7NK9osgmnpoXMoO9ENJdbsVe+ooZTJDnXAJ1XCREXpnAmKh/HFTgFl6T3mrfBFfSKxx58a5w9l2QX7ExPtJsRcI4qU1wKpVaARA0/4Nq/XBd2gvWCkEGKx/7tPZShAgX9J2loyHc4Io2qL4AznbDzNgARmORabXF2qUPs4IFZfqLS7g87j/4plE/wpQigoV1OU3O1eWMpLsLAQ+ytQtzSBYztzDml0eOrmjpdG5iu2+dA/+mX01BH5RtkhpNW2Hs4TAEv2YJmdvQ4eX/eM+hlw5JOEFcdTAgcM3BBcPrdxQl9KKiKdloJb3fSXN2Jy3ngXOnHDoJON+xoCutTYYvd2cnePADFxrs73/8uG7iQajJPXNtuM1+P89wqqkQAUVphNjbJ2aSYf53kddZiU2QTeq04Bsin1Yu4mawCNP8xOPo7P7A3/u5SzxyAG14nWi+yKnVNCZ5P6Ah17r7apLHQUsS2YjLP9ByrBpELxJyFJXNATYHSKjWECdLFTdqjWYXL5SQZEEr+VT+CbknnU3ZUcxiSbGKuBU0rKtaTh6MMmDf6GvsqiwVcP+6xjJlbRrYMLnn1k07OBkPidRDNCcMBLJz+iwh4NEKBaQhsgbOmwx4czdi9naguvhtypj/SL2S8D7pEzDIkLfhRZo8jw1Ge4hzvM4LILUXb5MPZNpV/XGxwXyXNnL4Yl3cqyfWkGn28YMauMCdtbussIkdzmbuWXYX4qfsO8Noeh1FbG7oOv2JTHNR2qIHT+Zz3cL7Vrg6ajCSrRCzgNzTmTIred48C2G0S8/pseU0iP/Paz/5vJXQpUS/dexYdCicxoqp7JmuBI7zKb4k9WrHsDtap2SY5GT+GBeDpAwG6Va4K/qJiCHtsI8arCykZefj850YeVGEdDf2gIas33ylAePKHTMKA9eh6+cqQXo1S3nx4rvXc/mdJ+Ov9j0yAsu3XtMLqdmJ5uRCTMGXQqc58Qa+2yFYMDjqXERkWBumre6ftodH0zQkxoEG7nwkUgpjhEaerNsoXqj4qLVckVz54W0R2l0SCqbuhAs6SeW1RjKUuEe/YvNnIm5/3eBean+nTlgjBWH2P/BRsRP0bUKeLrcKWEukQjANyTHAuJXgbQileNLM3F9dVsIdsRc+7ganeFtwEGz6idBU4hCXg8HzsQFOQ0naO4E/uhmcrDXHCfxxWbcxQt93w6AaBAJhJ4a1T4sB1Af+d4yEN5SwmAcGD1q9aMzp0ldIt0VrrUADbaZgpotJ8leo/0QE1cQrCXoM3zkDz5HyPLwUeBCgJqUJVuJAG9rvDFTvp+jzT4acNSpDogJjjjhNP20xo8dWwOaKJMT8JSqC0axbEJ6RhdvFkFZJ5EGHxpjnY+IPfjhLfl5U0p1ObU8/i0swkwHVzUVV7KraAFF6AWYCeqO2i62YhjuQB/zTYFsDPKKo+JcxH2h/dKQHDH6nbpTmTQwGch/HIUOTMhNgmU4YmmekZ/Z0XAjTVYd6WzlkSC3OT97KOSBK3Pg/De/NMfVsNs+IMfUy89ZsxfaewWIie5wa+DxhUr8CNlOF+lNIYMLKQfa2zm5RWqI0uSlxaXd70ukmP+ENxHfBKWceDnOQfZkNlPmPsaGbtYrHpj/gfQkj6hya7lYH9HOQOEHUucy1bnMcm19kw/dw9qpjcMRu8TY+Wd3cdII8rtQE6/viCkaW9zu0BFe0HKIWxoOIYb660v5sUtykWY+d83xuJm7GRQtcS33HGczwsBH19eTaN+7kSY+OWvMR1uBt1ban6Wds07lGCQgOjbDbzjK1fRtSws5ylS6NzB/ukGAAT0L1AuulN6orUZzmmlCmhXViykglCuWb8yIPQe94aBy2Aiqpgir2QYuLPKX8NL7Mv5QdBBWQR2sFeBq9yyZ4ECXTgVFjwGg6b5aioXmo0KhWrrHZpC2YeJgPfNTolQ4WKUeze7+GgruEeZcXHYlzyoZ0yG3S0fsBaY2n5Pd5iyMcYpP33fWS07W9EB3b9skypjEy8zm8vdraIssHthmMINpQ87m4nEelH3TiDoMETLXqHrRvsmrDcP/dmK+0oOOQqT6RLSD95W5seYnd+OJ2rhNhd5e4Kq6dpdjcXHbxHnbC7bOM0Vlzqz1E+56tO5yYLlU32wCcMiy5BI3hKbUUpJDa9QCpbc4+dJR8vbB9khS+LQJlqamzdk67m8tDLbxkD2eS8f/MGk2S+4dQX+4NmN+m2lTmTgcdCf9fFbuIdUeF+bmBFs9430Lyexpw3HPPv8qAk9SytciBo1ZKBbz2UHo6hSAsoFCyyKFyw8dUzbKLA2WvsFDQj8y5sZ9EI5aWRSxt46JZFVUKJrNE8a28sb7XLyaRSsuQ5x+Ns2n0gR74qc3alQgGgdnc4wZ+6WuXVvxmBblFVIqeZkhbR4875gg4BvvLNdoECcUmvEDxmlRgEIrzogNA6QUFj3rdOtbzk2Ie0IWHy53b0R6YLMUHAaAQaHUgQg8nxvU0dxj3X4MLxwR1uTffi6Uo9Hvf96K2BtclOWLeh7lnyabHAiFCIELO63fAY/JMR3DdeMvmIMl92vNxxR5dTEfI+XjOvo8AwWm4HTHoCOtQBZin+1THv1mDFTvae4O4SFHkAzKd9LT1CrJ+k4rQfOvDX9gCKrDuk0lWcbz6VV4vpg+BrWKwjKXAO/sHcGWuInB5OFPD6ahZE50C2knCd0xc3gzDLUvDXBjwUYhdsWY37YqjkSbFdQQFs7vq+G3cMasnFYb4+JBhtGbs8GrwrWhWRqT5y9w5hi4Ckmj3TiCnGvgOM3b+okDz1m8gYRR2VNuCfeeNU3zcgC9GckUpgcZ11ZBmPI91Rhdu85Ixfoh7z4B+nlj8as9QWv3VCTthkm/PIZsAp8wWwUhzWwomy41NnCh863ioTmiRaFrrOVCuAA1MMbcclVZ40HVbiRHFSEnrO4mdVGQ5K1uTuX9+Pxkw5H4ammfQ+GNlOtEhKvyg3hf8urQ8jmensrccMQgXg8gOHnjM2RubaItCCpa/1UkLRbrosHo9YEPwsYaSLuEE1oCvPhvAooeXWrC+fJqa9fNoGVkP38Ro67eT1D7Ox5lx0Ae9CU0DhytnVCszK2vDFYylVWZnPt17Zjfv2Vq6Sce9lgWPQks+Ye9rARVJdT85QKLwdOxTwShqTlkjXpJebn/KoKFEQTbHkiK4Or1BR/0Ko72xkgeRx+1bCMEgd2P4x2k1uroT6++AsOcZKig/hOIEFpOUQ96Rdvhk21+Y1V7FPFlXTcL56mdWZ3tUHhCCv1r6Wk0do0xsniISD2JWHyZYdtHR8/LehDGKWFPKy7rqtwAHCAQUnvRDy+tX1AEoyPKvT3CU35b1zsBmzOhTeXUcpbs+9G7WDw0SRK45bl8f1B0c6HyOTjxMnTuD6jdZeR3KixQeeaCyRE1OmeO6s6gZWUqoUAmUvpQjhtRhI9n7ZIFXhoOtIItJzuPQJ5F8rEWvQfBJiuCC1CTMhfFH6pi5NMAA7sRe6T8HTdAHnpgYXEGTtZnONB1CrV+URhEfn8ziQsOPb7gq/G1y92LULVwxcWYfY9VFE3t4ZBFvy4h14Cf0fxJOC6FDPjYg5BhAZDKVL/l9OxaWfnWOJksaU/ngXG/2gC6aFRvzhzvWM18Cb5IA71+dYtrCj0Mq/xYpgWeR2D8PBHDEFUXkXi/yhw4X27yX8hl03Dxr4yOJwNldZ5/h+4C7si4HTMRmph8VSnWl+gzh8wKthKzp5e0Q6OkWT5L3VvCAvPpFEdXkhEySX8Kh6k5k2sw7zAPbRATyQxLVdHOzk4bgl5d7/9WlWe/Oe3hVz08h0J0FUZrdPc4GWOLEDlYOFyrGGnR5a4a0wqt171PagFsUqn/6UwN+1FsAPc09dFW7ig9lAnCEpvCZfGMcvzsitnJqU5abxU4LrtSJCLqwbccaIZa0yuhl5yPJRySD4N0GSGbyLJAKmJx0AgV37hCxrmmEU3M3kI9CrZ7zWOf0jetRkglezID/i7Bw7G3PLfH0gZosuocq5IwB/aOkWqODwv/fnoZkPh2nyIJt0Y3qCa3bqTcpR+umIXFf/cD2i7m2MGdXBGX0pPB8Dsq9wwOzVoUIbfHP9BqoZfHSktOLx4vCku2i0a/u3RSViR7KEaPXpqCZUGcHTVroMux99tymQ3Oj9GS+s5T0tenlkfR6kRd99w4wv+cHicNBPL9voL4dSXzXI1PgiwfQIn0CZ+hGTuLt8RsY3nvEXLtDSNr7h6CN0kE/NnkPg/CKLd0+UYJaCVUIItX+8nFBckwjI/uKehOaoGUNl3uJ6Rd5qoWiObE+/I4igjzVVE0K8BHnda0Gwu8qd1LU649EwnmpAG5DoQH2z8L8ZpOcvmT8wMAVa+2knSNB2Q+7YoZWTvqnNneBezpnyQT5TANNAjROYX9ZXLcVsmhSJC1S0Xu9hRA/PUoenjtq9CPd77FpAooLNUZGiTAg904ebnuB1L17HRb5TZoK81aI6F5z5U1f88YM4R1REtSuq6Iir7rZdNRQ1FKY2lLVAS/8dVlpYHjBSJwI0RDgaGZCjy+ak75BveOwhWrHiuNCnq9+m4D3zHNMy0Dhg9VwL3rgfH9IjbmuixCnVB9E0YA5Bjk3+foAc305su0oIUc4f3PmNPIC17zLtBTaq9oNMT/Rk9LieQrJ6sNAq90UZAd81Kg0ssrxoF+B6i88/E6G6509Ml+gpcbdTX3/bOhiulnripgZ4VuyigQ4qRIP2rO8Lm7dJHKKTtJgsFoOJLpU8XKS5orzBtM7UOl0Fgryea8WW0lBYXyIzFeguEmyOIpO76EriDjgBJuyojqfpvlyAjYQ7LJDzGC4OoiIspvmdER+QejHagZfp8ZxjN2wsgUJGBryYYg4lhOtVWnSv9bWFocU/unG1UC0fIZFtwA0NXI932h4anAyXbmAMWew+3aEI9X6ngKl+num39BZvY8HekW+qlajdO8SZ7dsuNM49yIJBtmLJUSopbmuSL/RPsn+Wx0U/tIuapwDMiLuJlJrdsEeUlF1vUWODUzvBStTSre5iVg8ELnoEn5fQgtbZ4kk/CUKo7NSyA7x3tUddHbkEry8gvIgB8nSrYQQcpgf6mv71PVbTUa6hvbvaV7rKxYMidswpypX5YE62xqkicIwFUHMaZ6ndtbI3VyF5rJi4Q8wsss+GbdpdPUhv/1KBuobllee21Bg82sMkFEo3oDUtwLRtdPpb/lr328kxswlemFi5PYqHdOb+Pj//clN+IJrZhHhRi1mJEon+NTGC08mrZfc94r/LLwnFBVGzo2zUeAjRRvJaLj/c24liaPCzWKMJR92VXKYGXkPG6umljxLKZVoynrBSEqWsRgZRV1rRzN40+63qHRrJw49Cge+aVMVNZm6+Z6hbnoWVDQfS7rZu72tmhyzHQ+e+CTevgR4M2V+ZmCsN/BB5ahDlyy1J1H0+8HvBi0EM/fBefrnOhX1tUfZ6/YalyoxrpmdP3SdbgxfPkVNl7A9ZQaoanwQtT3R2ojucFWWGkwDDzE/YVlvlUATcASfIxhsVV+gIP8Ni2J2k3irKcQoq2G5lEb6s6DSejCtfRwxpa9m63tfGxxxsfq9YKE62QNJJfod5yqPY1GLcsW2d1h0H/DBDoJqQF8swvAjTRUi/rj79EOpf/wBcsolMf6kBWE5aB90WRzZ5SqlEYJpjdYYzS85uVRdYfp7iv7TOzg3fTC9OA+XXTXZGZ458h1+wJuU66S8SfI8OiE+6Ul4B7RbNVJBnVrrAAD0PtQPWZ5PN9yAsKr1jFM7VSkIFxx5k59tuDx27/jv3TT1q0kr1jDkowzowU6zKc6fXmJDc82PYLqAh+CyignjYd/p60COpxvNwEGr8o0MgEHubb0LO051JofSZDMyD3rLtKy3geWLGf19X03EZBvzPHcxME5QWhViFJq9hgcgRx64wJb/RKpHHMrZzW+MzuMdtI021feL7I8sbHRgJk1sGFKXKqurFeDjuOONHb42QR2gMibY5Bi1y42PP4Mj7Jf4t08nw68XLgvZDfEHyEL5trYR0i88E7jvT/Hqf1KjSmscBFGXm5/b3oNUSZ6uJRb+g4F7iwmzQFzHW1iPsIKsw2ag2YNvp0Ebrfvb0ztEVKwj3Ox+I8kWcwlZnfC2IuYZMKFY189Gm2dVSqR8zM5vO+puiCD9heaWxDWAXQeTlJEu2vpnzwTDFwKQn9pDtuLtN/deRPD4MuFJiYufsivY76RzzcUW2V7n3gIQivkDZHWHsFt/SkTfg016PC809Kq2SZKfs7RpofjJCIwiHrEzvRUgAPWDFIzSzhLpfX1pEE9QwLnvpvqhEjEOKgON8NvlcpRi4+gju+mlQSPEWW7lxIDyYEn6oGWYLWbgwYkLOGhhZkTN986J1+qXjLmZALbApwtSyJz9iNIAuOM3G2YiLDLMxUsgXMHnKZQY9KfZA97SZoUDYQ99PPyDERYqBLJrXAAo7g99cdrlaKyrv46CE+ZXeqwS5oOQVhkHyvUjXh7jSNZz2VIECLdNMkald73jASw6pO/XZwv9qZCf5xPW98Io2ml7UVjAei9NVSTbCZkHrgcmiCwmzM28Qdkqb6yRYr98NTWsEzaqbTeNykJISaf/C/RT4lO7Z3iMUjPoE2WxM8naE60f54cYDbPglJ7OONUZgGzFXsnfP9fOqjqp9+JnylL6P9gK1w6Ftpid9tgpzlc0OT+/GXejiLYhUF2vh9P6tClLRWboUC3KA34kIfSoIdsjTM2cdI9IuBeTWq5ACHIH3Pl1cvCvpFGPxW8sOYAOGPGATMBqjy5ARfGOniqO4ek5GHORwSw4lOz2XQMqzmQt/niunt/XgBgdCBRXBcKIvmqY3XbqPP4C32IMccujMYk23oVoIIhI/UnrbKzIEzN09hlLRWuncDJUmIWsSc8WfMtpNhREaaAi17kLVnO9ZDLrq8TyO9ZKAJzJjDuA4u4Qb/T+GLMpr0lOpTcdQgdDjT72bF+FSvsGCjh02SnWcGw1bs5VJloDDhVGy6UjU1mmdpsDAHMfqyMnO59bkeyNgs5umjXl8bHvnhI08n6CbUB1M7OeOgAa/eGnWe4pgS9NaiTIWhCBI5N+NFp1yj4c3ywueiRJ9o+jtfczWDYeCA5Wr0p73qMSt9yM9hw4zaBaKCfYWxzrXlNxRov/fZO1MNEVdjmXnGCFxYByEiy3EjPZsszAdIUhZvu49qa55s1lnsXJKXHs6IchLAjtGH+EUx0dgo3pND672LBglyH8Kx4WRKuWHnwOhFGifrgmmm9xDgj8Uih9XqPQ9vf3NaOsFlBislqi9eflceu1SviLfhlSlrlBiOL9P5abSSq7f91ocCbUpuwfKYB4+NSMsgiF4kZCk8RgGz4b9Ns4+E2swABjhvBFgfW/+L1x89cU2Df+wHj/CSttnn6RZ4KFjyB7e1M4lDabxUsHzgsEzeFXmKqfSz3meCc+ZHsjc8fgQeLm5WtT5IYlj8RSj0vyapeSrjjAC3v93fAVfoiI4jKz07wEDJhBwfYgmzIkUo4vHNWG6FrDi/eTWJtFbjdfht2gbXz6/wGqEu1Bmvq3B+lxHM7I2m6on5uzj+6eGyENb9NreijjJGuG40umHm15r0UErvpn3o8cSxnUbsev/I199+VWjur5w9zQcyUJ4+i9gpM9FqtdhheLPCAb1opcelGMJ8lPX1thw/d81qKZ2hFlK9vYwHZwtPwe8GZFX3b3eo1GCI9ZVMJZ+yGPlt0dj9c4NY/5mAx0p/wogcKCJsIr6aWPLNv0s6pcAtBbFHDGBCZIpwsUsxaf2JwYNBgHNz1taNRg7u1p92s1foyd78/cfXIhD3PC47gQWIQpw0WRH/CkMcVde9f0u0FY3sYH+1mk0ka+MyssQhk6yQa9e1SbmCnIhPGr6zgf/0J9XXdEzgYLJDRu7tm4hkUjm0Gq0lqYoQoNXgbWSjo8Jua+pB5PkfEjDlJhDcsRf/sdBZafAu5g/bsfGYgVGNlzVzgwMo+ByaY1GkxiYdCPdeMYGfvEEUnWbNvIZKlM/x3LblPtHa/+A1A6JHuwQgKPsKOik1uC7LvvXBHERYe9tqkjFKEIuEDScaBTR6FJv/k5nXWal2JGHRZkwfDt3fcTDfV6wEi6o0kJZhJKdLca/apn3PZmSxEw6SDYSZZ+7AWwOuvYpOGpq3kkcY6YXXHBNglVjA77zOwLwMoDvhvZxt7g4R4JRqO5c93FfFwB8+mdXABsdptJ7hNalmoI4ndYczPPTwEpoizHY7QQOLGBJquF2KULhkylXnYV1Phd2f9IcFU4yuY1YO6/aI1cH4purSMh1Y4iVCszGP7Oc35c2VL/RZm2L5K6LTBJuZKtCteIJ15GxGtgUL9hWtwaYmhAiasLctzi8hCXdQII6kyKEEGXqMdBvFthlqc67xNpqWlREdszh4ApX8lZhMdFhHd2s9D/WfW4IVooP9sQMb/f+S10llJ1qvuMZ+ROUOdQxJ2JBvgy8qOiyM9ycIrQA/INph3ZFoRREZT5UBXC8ro0XujJ78RToXHOQkX1MTStUwMNSpePYXsYy4Lw3BhUccFyGuAoteaXPTlj2JFaotvttZxIDtEiamWIeDF7fEABh0IiRynNB6EkF76+npVbKUXK0KakBHKKpNtDyqdhCBQkk0Ph6dWEFSjOuv+uiQLh8kgpH9vuFHu9v3c3/vaWeg0SUU3ZiZMG9VvPm1Ptj5KhMxJd6RGO9wkitLwfW/4NZYJu3i92KjUxtIR+xA0Kmnw3YpwaQXHo8xW3U5li2Gugd/TqH8qWWbuGQzqsZQIujKc4O5bAqW0WooEnia8EMiorOf86byFQe3HOoQ3WvJx5SEAOqvzZly0z92a7BfTV4Nsw783B1dbtgZVPABcE/AsCpoV9+FUTt95I5aoSM7HaSD3kAnoEohzfIElbumikofIhWsIQJGw08PbeYurJOTLpzoGBBnfGz3anhJzYQQJ0SQUYPwRY+QuJa5kSRIkEyF03CGfzj2i3ekOXxN9c1/lGydy0eFeOTrN32aKhhbJ7K0mX8NSdTgY7W2sC2AuJKvXBrrvMtHkQGCsbwX8a4HfwBrIoltnwszb5tBRopDdW5B5TNH14AM8BKseTuUadK0goExDLy9/TDIfCKa8gK+HCx9Xt+74D2Krze+w33axLB6mxz4Hkw++fNoEkJgfyBCW5cGxZ79zsCHdz8d2+5mNeSJzmLnA8Gp2itrKrg8fbm55XeMVEbzpMR4n0AOie/hBfBfxwX3Zj+ncVQ+jcia3207IHhFtfvS9w8NfuJ37RhGhiqMo6o+ASOq/9pCNpK0odgxz0DMpP0hJfmIyfoSgsyS1nVzk38H/PcLjb12PyLYpFJydQm2nk42hX+iBwaxcWJuSzi9ZvKXjBZBFJXSPatlo1ckspJtglJMtJ7WUMPMzIWfTsQcTEjDtE3TdPpwsH4emdyDaMPe8WctONzcOjhv9AWOSM1mVl/+dOkoQcOkmxongNfdYSDbjTTZodS2UGAZ6aZxes5DviMUiu+D0KY1pDqRDmddDAEPnPUeH5N1opsUr+SdzX0/jne+qVYjh1ygwEFdxrwJHeT2NJL2ja19o0o9nZWWvTshJqvGzx8+wpJp1A2mGVzHHIiHaf5S8PyMXdomxrpInvxDm1HGXX5RxQVOjDeRhmsG72cOA2oNSG3x8MhbSKDEEY6NX/6dXj4+bQGkquvAK8Ks0uQUh8vwXE3hkB1Wx5YBIpi5PkSi59/lKSeVmA5pUeQStK/tLV104GvwUGyei9hC6z+ZKW8sUo2Ialspf/1tKTEnuKDJZ85zlDKNpF9mR1H27ZD1xD7Xll8FcmHLouuls4vpBucUgj/H1Rf4VeCLebxNdbVed49YjUBWro/O5nGrRyBAHuvnpzCO0h5+ve7Scd/YeFAtY5IqN9kFTWYbirjyoTE7pvkkQ8jlrqB+xqYgF5p1XRjLUL+cFvkjZL6WpkzjnuyHGdEoXbgORdTow+17ftDRnuCDx8+w8kEpIoTeEPA9ikQwcXMqn0CZQMaFS60jkQeS7ObQ7gL0Br+LXsy/5UnojpsKYJwC0x714JLmlLvXOa3t2nky+lHHpDmPN6qNLDB41PZfC309dN1gsNYlLqIZ42KLIvY8j2wvpQXsvo1gXLIkff65bMclK+tsbMhBxg5C9yRmqqDiTKcK6fPQ/AJwOagkptx5bek47j3Ro4rUpe0lw4+kRRDhV7XTYSe4735DPqfXLepHMv6fLfK6zocV33LW1+nQF5+oJtPRDp6YwgiZf8yH6Z8AN7JSIVDkVScNKnEKhyfDPZljsoPQfyeTBHXth10AWnCrYRSOT9qcufPiYTrxjjbrcK0vGo+e5UtOGL/U9gfQWVuNltIAAp8Jlv1aJqWanxoTV/lcaYVSGjeKkKAJylGcar7XjGX7LFRbwZ2vxZRZBXJQqruhRPPY1LzDByL9G4fWwGdx+zmgBgPyloh6ueB0akp23S85Yk/YqeJ6zp4Rk62uJSWRW0J1vHEWdZhREFtE+ciowxhe6zz9JTavClhdjrDKW8HhMYXtE5Xhg81hRBkern1H1HcZV924kYUQ4CtWzrQdMePqUGqjpMXn1nFZ/MwWwZgNevU4FA2PGZW1Z3tMQkm4N02d5owXERccn9mQ3eGUEMo67Xj2vZ9Bbr/XstCMGvohUAFK9Z67Nt0PfyeKjFprrogT1xXYWxCGia+yqcrTrR0M0w3+fr7F7CJUzRfUYJaq9BPaAFk1O60rD5gBi8V1GEy4eGtEp2pEzdo6vSdoh3ZW0w51q1HwT8YDf85ipQam4ZjHm3iH8t57Wk38DmAj8h3Si4id2NKFmIsCYmXkKX1e+zIXINt1BAs3gVe28MgJYOcLiTzZ7dGpB8VNWFi7vkuAXClvZ4maqPDL76xQIJdd/ORmoxguLsACZnt0FqjB1VeDobYrZSpZNdBPBRy3jIyuXtH17+bG5RbU460CZvzkbaUHPTCEisP4UuFIh01OBWqBGwpoodLQWv72jOwx1gObkN7HI9vRZzFo6qzC8Ab6G3F0PeeD/0xM2lMXfkbObXJCq1zYF77sWGuRwJz6YeaM1haS3UEW7MQb25ApQfADoB6xW+JoE/fTLIvidcM0nTB0JpTEeDdURNJEyjJE+d0IZuaa93iBBgFuXTs/sh3ixjSTGLVlloR0t8bEr7siITWtTMCEc6GIvfPI43a94D1MCmchU5UaKV+DOudi5uzy777DpIg0smxn7TsAZBCIidqOONDhvplYC+ex0Afm9UlLCBe1raNSbBZgyTCP460+2r/OtUD6fi/cGBZoahlb+McirYrqWxjL879WaYYp5nz91jkUaWPvBkEL2ARNDRwIdt7wrUS7wAuy9i1CJmHOPWpyN3JjEaApVkCgiR+5HcCIXLRRx+t1FXy6BmqjzbbzX2JaXDqzu8ruS5T2Icul2SJgLpFzo2yQCWm7ewy/QuZowpTivVW+VaKaCwHhOMU442HUzLDDnZ2FkxQOatuTDbJuio1i4DQJJPO0yJseFDkUmNZ4BqZtLW5wnX2ckqK59PRmeQOkb57n4Zh8tarP4xbl7qdARBLyGqaUv0MbCtBvI+FMUMgaXgaY6dos7eX2qQ1WenGHYyrsd0RtsiU8H0Tfx1vQLgYrj/4tX+YHp9UwBkZDpOo/piFIzesa+tPyNblYHC6MDMfbTHfwlsbUYPAWRbS3ejRTQCT6Vao9sGYEHpwodV919hPqfMdKOjAr6nWiWh8wfwzpBlIOYcI8aL8BOQH680M4nbGqE8jv64x9ahKtljoEZiwvTHyIUy/FxAcOhzyUm4+zUgMxnLnkoNhkoT5/NMdN7t09jIMsaoCNJR524+0Jx+AWOU+P+7AskqGD6jYWCcI9mDY41GgNyJA1RpXACKh/ISH1xRBwv4uUg+j3j2DcCtVnf6aNJQ/m+4ahezB9JECd8Psyeiz6QvU4NuwDIgbjPXTPyme48IKHdjQl94hvb7JK8G82viS+XCPsLWYMX+L+vwREeSH4hW9oTopYXlXThpfASUNyVJxyY7QXk24E42dvv+dTvSw2Lq9l05+YwKu6wbaR3QzUMqWB9UpZEd2NSqL9IzMOOw8b6DmqnoUPftilArochTKZCRZKlfkN1XqFhjaycZIsDS9yIp2TEI/obN5otEhcgHTnmnKpjAFzjw/Uug+unjZrDWqeAZFjwYDZPlyU13Y+ypJdk/I/MXXu2MnIH+lTaj3kt0HWyOJcmFOufO+VxtJ8H8xIL2WeXYkh82oCNd2QHrTi9Mmf0UKLsvo7hD1Bj5X2tqTrssFOkE+ezJByLnlIqHuesw/BpzqWVuGaD/v+SUgqpImoGgJIMtERsCyqhrEqoExV8aJcOaEWiFt5BsSJwqXcPV3vTE9ztMlq9c1AxN1NFlxnPM2kjVitbLVYfIo++KZUtjGDyKBkG5Rj70yML1QvwlfS7bU+R0IFr0QH+fDPejIAjpw+yKA8PlFd0tb8afWIdHY7JUhnMJnU+MkcSBhhufAxZdnPuhmi01L2U+Ys6nC3ixhOOYJ5EJftONON92B5CSzf0ldQLoiBndZrt2zJ14NhgVY/jKUYlZMeCzhrb+9qP+ODWhGBQwJW8yLjySIVuyD+5QytyzFhqgeBeop9Sv/hEOWtulIbbvvQnQbql/21uFdOW4742YuW1q1mHpy1jLU+uatqwaGYWVBX0y+WzQ1gBsU/iZb1sFtDoYWHWPBvfFhCk1EuNSu7hcWa3+lQbqTlt5FuSib2au1ZERZtXvvye/UX5agLyGoBvmL+/4GJvowyde7Rgqk5iiqbfS1tA87yAd2xqQTjmL59MPELfHr+4xCh8Fgl6AgKB1BcuidO2K2Cs/og4wYnDgT9HHNJ8uitovun5mA6Bh0UT3Btb0Qr51pQDUI+lIfBSjol31e25ivv1O4zwT4QEA3eHut5734T4xxu6qIFDce7Vo56pj/hsN5ytJoG4iw2bP/l9RWGCjmHYtQol0/ekNIbUbAr9g0/M7sVKnvRfyF6u0Gcwa4PwNLFxebgaTriI0e+c1HlVxqLi/PG6isyMG3pXlXSd1Krxw1t88C+06iWbrONFMfduA8DHr+OuZpPL4HrD/yLQ2lFAhX+rYIf48mMA09E6rkvcFhSjPL2QHEUJUwoVPkJ/BYYlct/0vgCnLlaDI04FEAgIS9pwHwz8YWpU9QBvexoK7smngxKt903ew6B+qDdSYSe6EbK3viEyyR22lDo/bN+1okDRs87LkW+JC9oQtNrHttzHlxQRMkNLs5/vklD0Ts+ep+GHgloAwSxH1zMEYhgJUNccX9cqFQVOCH7/uu+gN8P1j65Z4y+KU6sAU7Dz3u4zguBCrI/tndbPwm6+25EKS9IS6lnftfvzxPsrNmVcaY2l89vkmnL9QzDanXeeJyKplz5KRzgogacnTMgcfs/Po6EeBnhJq7NgTn15i3p/JfFLuJ0rzSfdeDHwRCF53r0eNtulo+75t0H8OePlws5tTWLebfcRH9olM8ivDr+kTMcNCukxBiJAofWkH5yuMSnsBDSayvWrhQQsE9GsdU8UB1NogUmcmRj6VfoE2Fmoh7yReCQuRwpe+CVCDSvex64xSmzt57LSr9kqfNQHcZhxlpZiGaFZmN/hpxPN8fejdGW3M9SpdUOLE1tiDLis2snexZNbDtSfDu6CAEXiV92QyoeYStgehwJgY/t72y4ncFA/065X/JmniZfj8dNTbdGA5gHa+x/t3Uc49P2dL9CVp8JIHyaf0/h81aGg33AK5z+6HXeUOYJZ94FXdIfwFzF1mbkucwhHHv4l+HY3vPZ5mhThk7p6C3/hCvvvKTYf0EltVVjJv16Ta6odqVM4+TRrOHvLsyGIlyxt4/TyEHD9oPMjGSxO5Viqp1q9LZvtbMNYy1Dw1h9cS4kZ3QSX3bn7JKsdzSx614WPIJdKUidhyp9oyXTz+XGXvsQPbDuB+PjdJldrhcBs+M7SPD4z/zE1IhszLzmD4Yu1UD+HX35gFJ2V6WwWki8pnKugt/soBDD/v0xgEV7DpqvAL/UYZerSdbettrJzs/Zqxv1i/cMa74lcc9X4RjJ37H3iRO3jv+IlKdymyhu8xCr2iiJAPk/jP123L8Yrnc80EJgj+HRXiLk6Hx3AxJWpI9nnEwJPRW6qb3G5N/jxxfZ2V1fDdb3HPwgjvBTboEIDUjHQdEdMwJgFFcE3Hy0DyQ5zmSwiJgZsiETgp4x5GTUV8SHhwcqasdwOu5avRPXZP5mZd+Rp7f/ATI6sUrCS4bDPkl32HoPUPqMFtH+wndy26BEpocwzAt4dt1L3teEOelYhx6rcZSJClis8H+V7qvHqJWVj0/AXpn8i+CHx3BVgtRC+CI2V5SOAcb8Ip9+0lA71j9WYyv312hJsQuH1Y91UlbqooIHZz/TJ+nvetBLqeVyXBxWgxlqSQaB9bphmGSBkq3QJluTt62YkEAYVuSITszlzfWQZtwPydVIBvy6w8IIF5sSK/FcoU44uqm3jxAVQplfH5fTcZV7wDrdObA0sx51OIg/IUHyz5fYNsFCnKJrOjjm0eVVtwtMnxiJlcra79pFJtghdobQHklvafeHUsu6Zrp2LpgRYb67KyGEev5RyrS9oF5FwboIM5hMf8B/HlqLhLEXgKH0X+CwnojMTVmnmlaYIPH/95cPLBdXT4Zp4rEUsvCiiiC8b1qELF6VyhgMq5Ly0WthkCp9+vL5MN7MO/HjvzLb776FwfDkzozxrIlf2C3cWS+35oRrh2HzAsc97MB512VQhyUHz+VmEgFgIANC9p2dFSjtrqWXlVQrq4UG72AWYXWzgFiDaMpPwOEFZiU5qKQ1OAoq37Im82aQsEfUFOKvCcPK/HiViv+WQ91Hu7TYL8nVaQ/QZa0hlltt8mmnSaejQk0jcarFWd3WjHui5m2UcaaEuCdZahY60UEEaFXsuk5OOGQ6NeZNO97zR73eeA+dVtmrq2UR/Eui/AuxlM9sWy7Dim49M9yNBDnDBArnu+F71nihSW31Xa9Uh8yhL69sa/KmtKkftdyP3n13WikhWSEdu4iGCrLU0zGJcYu4rTjNaWkgxYK7GdWTACA2NkwAu4KdFCsGHYRX/WYjhmomCxn8X7POiYnpkdzCWD5DkG69uMVMuvdit84FijZhB2tvzDtz8bga2F8WDyKGmmkVfKcjw+z+YbQCcGqOU+o2NM6p+gjd53tvq/KNnF7evB7d/xTTJKmPf7/qrqMrUaiWI++ioBYuS9q8OmzC3LB3oFoMXm1iGDrFV+Y8QBsfg0lhQoTT1naTvYhjXyMRpFpXT2pizMdsx/JGrEUZCcmp4O3OzAIyhUZeeFCOnUrZkNOlQGuCQXO7IsnxswBkMR297y3aTDqrTmipIea7yrksTD/nLdVvqckjENQVKmojMi87Kvi/EOxJhX3X9b/+35xx+nN//E65aOZqHrJp4jX3KAPLQA7xEQalksHfzvi8cFl9zllJIBIxpCYPGhEVSDBOjOg492YFLjoGLIFtFVTk7Hxi4dMezFwMPHwGFgX2WJfNrXZF24ckvwncRPj5AP3OaFQ1hm2nvnAFeZG7Q9hlgq3LieuyAJrg/4R+3rSJZatHL515rtg1glvtt626LssM++SXPnf3TzJ/BhUOvD6+jl1BFsCsTc3n9JFBo0nyHMIsyIBinqMEWMLTflW0p07fdH3IoIWvaJaKeI8tsm0bhFFAnyl16fEd4/4wg6e+mt+7Ba5HuixS2uhpullJr57bGkup8DRecVMD+UM77gyLZfquv1hoMf7NJKV2r94wyQQ6r2WIu3nmmW+Zz760xtHAWXHM30uSRZujVNzTFKqatu3cjQkjJDyZxRCaLBHK69bNOhGQ+pUjZDrxtualWfSvTuBto3W5LXyPehfKRQrKH+Dpu/6ZGnXah9isoTpvVAjnz2Gzmj//fZff5WhffKQUEm5GThySYz/4CSTdPN58X40ASC6jxuSXdrlBJ2YcMpJsaMPX9pqf727SMtuYIOoiV7Tk/6bF0nFJxc0KHwDvIN1BstGqfZsHgPz5fT+rx3OsyGljHnjrgmU/XXHwxWSvmjknoRfX3KFjXvmRkdsqXCSK+eAsaMk7YRvznFdxrEzFGaTz7X7fPw+q341k+owTkYGDCe6AuFPWc5WRcATl3diJxmHg5jZ2WvqooETSu7F3Q0aYlr8G3w2gYKBGplvrnV3GU10RStegUuCuylugQ+aUpO5jiJvz5GnX1dHx7HiXfTbhLxCWtch70xdrj/yHP/mOupLApfF448BffdiHOBtzajhi+CcA1TCSYPN9/ydUPmTqYaHYqw02j6sg5Ylbz9ashYKfTsk3he7BS2uHganioPdfijxzVoUwetJaxHRClIWOAmkibtlyt+IA2MLhFxKf6uqwG6jp6506qyDkUy96KlMJCc4ro3kkEyacv3P2CFaST2r1XGvOqcwY30SMU4h879alUUVBU8wAvSCwlmfBDv7OH/wv0pPO8ebd80Bha6dIDrTN5sfejTIsySLkj4k0Enq5r2g7hKdQzGMKuhvtCx3YBgf2JVKmAyQzeufipReKTB4lzyhXmT3uWLnzIMvGIzHJF2gbjKOjv1IPNHqIVCsOLlWAqNsiLyqMQwROgFw6/r2wZ24hlsyqs8hn4rro74nrAxp0vPpKoYD9J7q8lZbq/2uQ3GLhAx2PVEMasJ3tYI41dshC491fuBF4JZt/MTOepFcmf8RrPfgUu4svrOpLFOd7fRqZ2Xj3oboV/ipm1neLugUi3Iow/U5KEFjnZNwLNEDRPzeRUYhAYzl8cW6CuRSoDgGuUCMArgyQ9oMje0cjWiITAiRaZkTx6VSd1VyvxgaVERkzd0UZpjbtq2xnmETfI94g8yThnXpmi6/bKuPZQSZVz35BGQm7+7tHsgngwJcB0VYYmDga2B0jn8I9ohonndznykIF3zBz55H1Wyol55poE7iOBq4ZtTA+FGhvAC3vyV7OWYkN63YMEBs9OV5oyQuXc9Schlcn1HskLnubKoKitV8PmAMYtpL7grPwffvo3bpBIBGGjFOFbCm81vnmYiA4ZydG9nZzsrEIBBwcFvqMAW280mKWCsX6yHMaiA91/TAcTU9vjZMdUZ4aB2+cXRR8MPbUA8n2O/avbcUtHSYZr78dxMhZk4+uI+BY8O4x5avIXsMkmvZlEdg9PEYhG1Xbleps0K6rkqica8Yk/5hAhutiP2WZW6ffrR2Nq/vtFhEcndvAMtLJAWOEgfiZ3F5tkh6yplOb4D9k6nfotAkToGXLbkG3sMMNzLiIPs8LITfO11k8PWjPfd6tvSYnnO2J9XrChZiI6tzqCduCv0ohsOI04f2k6Rp4TTKXvVvkZTa7Yjpe1qFoRCYwnyGzMZnKVFauw/ildXJrH4a4/JTQFs2tAaUFHSL5ur5d/pgX9561VmIBVi+2w1YbT/PKzMdWjzDoQYdKX0N1ZlvQgZ+1r5fTbWj+9B/cd+Cx8ZHHAkq448zqFuBmcnfqVw4DA4JyLJevq7Rkupey+/fIdptvH5bbCZogOf3N+VzjrJalP9DPOEuTzZuGL9ugS6PRVb81vW47CUy1ZiJX5s+OuXAm4QRB9kT0T1pumVINvMYlSbdqSnU3YyF6xfI+Jxq0SJfdl9vW4Y6KFGFNAlzh1B2tDpikh+1ggsfb7ar0mtmW0AEl0VslXcES0oP3ZGT50HEbYZhnBoZQ8KUTyhSauAQwghfnYp/6lBdXrr1bpXYvYdVkZQV2IRmaNB3b5OqyVDWZ68TwaeaKPcTeSBULuP5g9339Sbv66lH1ZGLS+ia572HQhCjHC1x8P8h7LM6M7dETPwzUw8fkt8q2hF0UTGECElUH8SpQWwt99gm5zCd2ARiBtDmHiPTPC6wI1D0LEtDl5B2Sn3Zw+22KBdizlw0J6KP8SGlx9OU2GoztIjgDC0fSy2p2Q7wAznMtJqLPHDleq50xxiYkbHWmvBkU2iv705WQzr4mVg6BPI1ABzYfhLkZgZ4FJNpIh/7S4f8WW3tTbCiVuMUaAZFyBSTzgc50lMvjY3WbORgMtKZOf7A3oqVu9x/sLLn1ywGPQFwpNVs5cXhkR1nZY8qnMPcM1zs1xs0IjQrUMIMzVAcFewTtPB84iqh5Ua77Y7kZepyezPe4KeB5ZY6YMD3JK5riob3srPh5weFdBAW5ePirH2/JKGHau86iO9nQmYzNqEmfXe28zIg4euU6wuJn9+rx09nHxKUTPMETMPNdI6m59Mjeif3tq9NfUaf1B/NaYb8XGO/D/U9hpvXVBEMWt6wLkZNigHCXyBH4Fimd2XGqGn+FIDyO1r4fN/bUjYC/CSSXZsYtxoGwW9BhomEc9CduYibBDls+HOkkVZT/6+cMOaEL/cVUR0RlTQ2OTYH2xqnSfqeri+2/BF4jHWsyfupFm94KM3W4ctO1IINXVHC/c0HhDvLIa53c3kZwBWLmmPRjhtgah7GCJMR+okmqbArQOoYHKMSH0DfTWaBzKQU1BZH0T82tWLG19vgEI/kgLB2jtqnCTfavLmafxXVinT+k1z/YRK2w6wQX/8SPKyx19Kp02IHo3Dpl2I2M0Yd+gz2zQo5Rzrn2qofZVuaaX6SsT3r4uBnRw8+q5UkLKRU2amkXYj12aLZkf9HMxPVDvxx9PHa7AzOiASh2Wtqb8fUFVrH8sdg2QpouIHHTQDfvNgxwW1uSc1b9wWeOx02epW0mujO5cdXy2dm8Uwu26TcV3MJ7tzSXJ9n7GGl8RC6NaX/lkhss8ij30D09og427tHEAMoVeZNGvSUQVzB1qNah6w5mnAA6Aeuw4u2KQk/DWLxa+pvotaLyPRvjBPnTPFrYw08k6nA7QHwMpDG1BQRDWDvF3nX5A481PdwCvj0TklAAYnk1YZ+aQ40bDa6EPzV9P2SLIHniuz4uNhZTOkiDda1slgJBOs6GhQ+tnV+wvRvtJK/sT/HMVMS8aKNLYIYA4FlcXAzClUan0v9SwWCc319e5XFhhymrF4DYKosadr3oCFdjBREnAa+OQfMevBLjxE179dbJmPomFDQHDFMiLD3I+pRru3sQpa9iYLiDpg2O5TTBp+0GTF9obZIZCZ3zX+ckyzCfh49L88VoeLEvY5LsrBZ982MOxqagscKyB75K1TyRAgQUQXmmke48vbeVIPv5VH0ZC3HqfvS4jSSDuIx6Uf6u1vpTfEY/jA9/cfaNlcAMV+E3i1qXW85OXKkwLWUoD9XMdQmZoJTdsMBwuodDaj84V5eBZirYQSJAWvbGykiZY3d/kDfMPUuG1q1tGVheByNweSe2WqbayjbcSkhPgFiqdyIZu4pQR+x8q6egPSeDCSxO30u31vLKzvgShEGHUPVOHTgK7emL9SNbK5ap01kz45lNDiqRz4N/fNGgjH5+4xMBKdgnimhHSVGPUxd/+1MmGE0wSmcsKPU+M/XxUfQGQCwuK2QUT+hGLQZYiDrgLENo4JV0JO4ZKQh5sKLzkOSVYF+R20746xQqbOIolL2EdJDM6MGxd2Ysgr7v98lV+TuwGT/jKUjtkVKPjc/FnmGMyI0XNgh9q9oOE0GtKXNuuhhvzWIZQHO8Zq5EYmgjv9OfljqspcPHBswQVenxPr5Rww7tlbsBivNqbHkvYWdZtKDW7iz/hx+HJminoo/crrq/VnM7oBDvXy1nOia2aMPk+iRCnPTuJSlz4NzAFG53ZIVzczXkpAGMJ1gbSEjVLSWsB1CPF4XByCiho1W/o/qNx98nU8iwvFrwEHBfSqtz4cwMIeBmPFqtrCxXJ5+1ur50W3E0atKb71xh+p9LAO8tnXC7CO/24Gw135MvRvxClwH/r8hRgk7XrQfU9CAH8d7iGRIutlb5+abslh+O9Aq+Orh6Ofirr39GjJ9Ov8gZmv9sSTVkRK8dF3b2P2/AKdsX/AhTPjnA+QHhcS0BJ3wu2ylMWWMcof54YExDxk5/dFJeSlDC1OipUXDZZOXJQ8WQ6epJW3xgQkaAFpK2LpKo8D+dipAXnSPVP7Wnoj73bLWn54qSP5UDRSzjfHWp2yfkZvYbJOrUl1gCYfISG9zBMIzYGeCfsja1f2hfuVzpOECsRxCqopgLRryKZ9Mg8oWnGDAEwYYQG0lHA8niZozvXXXiPH4bcDIo76amXbigjNBqllK9/vmkIvsMAjQ240pExUeTW5s2iOOk8T41o5KmSrEz85ZT+Qne8C9cfCEwC98BxOP3CS5hJN4fr+hLpQJq1pSRgbrCvM8T+fcqIWmRU1fruotVP7c5NVT2C5NM5dwU9xoXzn/qRL1RmrWHNjzpwEFqDbnIlf2DagSIX67R8oYcZiz1BWBLxhwHh2TXDE09e77Fr/ZI6KA4EdMiFKTbCZLWn8OikGaUERZaLA5+MRFJmW5GSbznS7GCL5b8/papw8Z7Yvb49QP48Y1rrk45X5VkcvQsYb9JWBSuucEixVRkoX2Qvc158X3yosdX+Qon0OQAKnvIDdRyPrFP90LVPdPWd1xcQwZJIpioCtd2UiHEyaXFEYKPBsEirbhczg17MaU18xfXQ079Rnk49G4uy833+NwRa0m5s3U+UkXtirG5oxR5Qu17KNH/WTEfIj2lVhkoDJVQx3fXcowPOV1QL+WDDpFwQpDfTdlQlP8cm/XRXyuCMe5i14aJQlW7AlVx9GhFeR5jVST1xOdclqJSZxdhzYWFRn6ghbJ0sESs+PH6ziN6A3YNsinOty8hDsZzrp0hY5kTkO4WvX439kk98NgvLvQYHEWw6m1nlBplYDl6Lxw2i8gImWAEAbDvAYznTHQlbluU9I4y01jrAQSuTrNJSoDjs2A0MQf7f6Pp3WBQD2LTztqCyAMxPmvVwqdMw7Hzy1KF1gw36ShCiZ8MA+6iFjBLL1/Xv1EKJaYuwormTzKSkg8cLmXf7Ic/PPIXVE4CwGEq0dPo5QqqvP95qmoaqjAW2hUJ6kvXTJRbLYi0qBi5+jPPYu7SmDJndSuRBkhVAeVJ3BOMjetBq3K8/iACmgjS4jkUOpo6+99DvAwS3/XnmchOUCFxFegLrQtyStPp3lKHslw6psEOFl6UbimO6oUpJTjNDaMqpgh13Ldz08fIGIRTr2O3kNzgz9JjURHKIv2iGVIHQRleeYHpvkQxJNduE3aeNZolL9YiNk26yWW1mPptwOlRbWvXAj11VkSut9IEd1JHbsOD974VRnONxRVGF/x4Nl8ToVT/+zzJghzYnR2mn/hfQSucjN5nA9h/PCk6HsKNnWw4D9PgLLcypPo2A1VsB+kPhJYliH0eKcuP14YMp3GlZ9igccP4niArQlS21xBF8bBRM35XtTC/5gf664QWM8hVcwwSclZLx9+ep5Ncar38P532HXVrFTEs6xrZssT55OpxBL8kWfK57o2V5w0plvAcFDCZ/vJkhnO3DBLv4zyGAZVdf3T/rXaSTk/pVscyctENH5em3MYl7P/7x6KOzHM4o6g9LZrB4D8JgHZx+cR5232n51XT0gX1YnpuWmIGPbV+cg9k54udcIY1gvLZdAu/+NBISWtyeESUeFkDQvarS1wfeuhDyEXPuQZv5EEvYH63k2xAgmGOL3H2N/UCIMboW4l2hgbXUrAwI/mVIR8Sh609Buyhx8ZdKT/DFLbRRJdWuCe/MMqgMYZqOATOb76VBMICvEd9h2+nucZ9OmDm0WHM7nRxj7m8eaczQtqCn9nbNjuvByLGHGlLZjIeOAu4x+gdNg+PhQQfxD+EzSwzHdQSVKXbIQb+5RC0exPfaxlXuKHvePOkTjzs3yNbkA7Be9rFdB27QtIf/lhMaBUID0uCYpQ13dSC2Ias3eiaqYh/TU3Ddh+draohOC1ut7mi9lQbMn/EYQW1KBYQsgKOyZRT8CUDmQx+zR6nLkv6nV+v+zFXmmjrJCrpTmKBAqTw6iMMMYXkd/FIhEsmgWL/asRDoo25TUnWKI7bhKJS/gnaPREFTTpKHoopuBeJNWsAvYFYdy3QR8PmRUaoxhAJmKKzZTXmq8nUbg0wAp73F5gQeKUxUGQhiT5H3LQRv0h7KhRbZqTw1DKs1aj9+RW4Xm3uaWmsa0NAohIiKI4zglTiCv9umzVDXn1jkTQeqHpZo5CqiI8R5u1Gxm+rLpYF1r7gKapmQRnTpGLWtLhey9KWBaZM6gducgfN3ZSM+oltM4L2pXGa1SFTbDxvab70RLXfCjcgR9VDhZu+493ixmyq+pZxQmO89LyuyFDtdwlm8TDSwa1S4MwTf1Lztz3eFVkqs2Uf0UfA0rOFRmkDfH7YZ3i2YRk2u3ke+QKTfG9o7i5d0HS/jyMeb3n8tdoAep9QJCHIvmqIrlr1s7myxDt/m7I8jc6nZCNSMK/+g7WLwF1l4ED0ixji9K5ZDLeo1PYaVbWESTwWrOvke3HueMbztOdlSXwgw0q3CQnI36ItMNFu4erFxlkViNNx/StS9hRr8tjOGp/6+peCQg82L1IeFj9JNhy+ZZ7af08yDOnVLWuiNs4ODCyfDI0nhRr/oqwAJHxAo8hn9dIttuOAY0S4r6OxrnyJRYEqTZCRlkR3ipG06+nGg+sVUBLhyTq1aYTjYx9Ws3F5cRe8KHwpGmsyLGh7iQX2LJs6kU5cilFm1HNgunmkSHuzofhO8kFvylW/LMZr9bLvApQWQstysqVDlcN037kaehf1KDgw90cEXUIrlnj4aZx9RBuuC8wkW6RbgmX3WFf3I77d/gukmrAnWtyLeiVPH243EifhSyFJ+fuResPowXy03191768i1HVBYZKsX3Rri/08iY7A/J/k2bHB/U8/8nvL7F8W+BGvgbbZe4RKZJ2Xlnv/b76gN9sBb5a+Bb+4W35wS4Tuq+cvWO5CDJSOonFXD7wt+4URAqDAPAVyYyjj3WrZfGF2woadqlenKrvKggUUnoBe+PS4qKuhgpopU4i9Xooh3C4t4ReZjt0Q96I4uWekptJOUZBmRlOg6vwzcxW7y9XIoSLWGZ1U27dT7YaB6FUp59eRRv7iUBbjJXqFenCNqmCj9XU67ZVTBpzvQbKJlN8YBqld18VoNo/1tcVMlXhNZShsqMkaqPn4syvCv70pgBr+0Sg0CLCPqvw7MG8uUnW1Uk4xIjScTTVFHxAzeG1LRGsXC3cgsiSMD3yZiq+80i/UUegrhInTlYVuzkKcfmlKg8+Dy3aPRdcnGAK4tD7f1g/ZrkRYgzPWBvux0kHzk3sP8Z0Es1wXk9D7UTGGdE54St/806Pdk8a3YbDCS/lW3qc5Hr31Mygt6Gd35m/gpwmhMSA2KjZ6qobf+RuAJ0lXpi0LR2avKpRfKDsLSLThSxEGmQfHKyNWNKD4CbqzJxNSJMHTnNsCwOst+ToCgb+rsbl9KNvt9XkvDrR2PeE6/r4yWOKme7I3Ty8lhjQjZVVAd80wLr8B8hxfkYNlt+7pKAk3gtxcrKpPzPCbX8Q1+mSdFWGBqoTTRCaP/bX3yfWHolpe/+yM8I8Hg2wabF4Su2X+f1TqogETcGj+VgMSvzus3lC1O1JkiORcGLxlR5PP31rnYB4VDxM3xh4ARbRBcHaF/rXnUbHm50tcNqDd1UVHvbaSkK4E43BpREvhHVX/R5MSISIir6qyIUYXLGkPaD6Y1UijXoul851mvnt/Pj7mptzGrh2QZWJMt0/icsYGaS+uZE75E7MWpXPbVOotMrr4tnUp7acaGk+SL/4WGzR5ak6cWMYBMEcvgz9WDc/XbBEZe3uT6k5V8JqrBScN+4bzchX+s0Z6348QY3VIwRPWhUHJPEHH4d5S78IKcSbMQyxW4PttyRLM3c7Hoo3dcmoJa1vOMmeDwCZNpXkN4hZhyGa+Bp8pDpL8zysqNYIV6vvtkUPQKcGaZM92cKfLnb/WpUGgNYoeDp9rq8yF4PTheNEyOkBIFSqgO4mQc8xjcCF+mMZuH93kI28t5UhxFW1sYqEiRGaJNBsLlxKz38kMI5dtipUSivkxPQrlXRMMu9UsW6NPs8AGEvIcTfSSUS5RFuhpQiWo8gkmcwZCwdQHp+80FWxonzFBGV1REmwqdqkUe0vg4Kzt067Ar4bGQvt8kK+NGoDudAvRhUAGxywNB207D/rIlF1pXkQGIycJ7AxiLKzdsMIytD+++9ogI1zY6USlfSTsOyewV3emTW2ihhwBrMEaXib7zXbp4FVq3QGs5BqrWCJA9tZMaGb9toHXQDr3fpa6dyTlqJWYo+7CGoMYKdgX5L490pV9p1ktWTehTcBnfUvTOBtKRY8W5R94oGLiRqolyCM77le4Jf6G4es4PDLC7iZeP1wow8Se8vhL9AHemIuWeSoN61c84ZZJD5hlsShXH7aowklocBxR4Tl3LuG3NATcPs0D5XtEeX/wwu7W5UJmp+eQ1U3asFQHybpXBz7KWWAjzQHFNnKsnsvZV8WB0+TYs2aj19mj7MB0+220lBfpR1RtHUwueQBsu5SGnwqOlnmKGnD2gChLSPzGKPBbwSvPZCZkFFRtoPEmIXiFuVqnnlXE029tllzEITkkbz3yOUh21gpSF+Bhn3IFycH4FS42oLIrFInvXHNAM6phckLssd8qkRrFwX8ravBcUGz9568Gpkf60KtF8dCTr2dwt6CbVlSoplAVOpRgX0ZKDZamCDFBu0QoohLsU1CDsZwOASwY/8xHB8WUfrrg8fJSMAQEtnzZM/rjBnCHtrqOYml2jEhgaKs0d2yb4plYVGTO2FsPQqGJFlFkyiYmoir/HPAxlv9JYZUKkOnLEOauEL4n7LJMLGQanuSBMWnDQm28gNc/OPy8abV+c2B9mahlxg5A3sOKpUQVfcPTM/DJaKZiEPV+/2MN3LybHxm3GtC2vCGcuS6lbfgmQwyrwBd0wR5AIxGU6YDn65YBh3NruhFTexYJWy15ti1uwBqruHAojx0ucgdBri8hxhrpcLu/mI3vHdO/GFiTYdUWWBFyvdgXG05bvc5W3+1ojhcTqN/BT0SNICd3VcgCmRcwJzkdQxIyXB46MuGogOPBc7kLRkkE9MIlSiz9dvmX8uX/sAicEHOMMaeBO+uszQXvkOuw8FGgLTkD270t7a/ZrFAMCblcEFEs3H4JpV19PqLQ6UdUVdlKZa3G/skaelNvBs0lEy0v0Dbgr1NHYyiwgV101/K6CrmejLpHUwR9TQj/M2u70vZLniLfFWk9OfKWW8RelsONF5N2QpdD5uNeLtPASh0edlv8MPDlVkHqfRtd5ANPDexfvfNJ7X6nIiAK5x9OtBjT8MWLxRWox7A4mI+wPTMcrbuBypXrYBO741+zZPTUy3byT9nwLMdMwedCLZwWf0B/F2JXYxtKKcAG8ohXSJ9EqcIw/R1utm2PfSPaqfoEuJ1QmwbcQ+HRo5jIe/PNcf/MBAY9MB5rXCHjCGP/lMMaMIBZJ3WN7KK8fuhpC6Q1SvpXOqqat0/tikNINnRIgkQ3lTrAJvQALljJLtb22jcAD5Ymfs5nB73mGM0CQKbcY9yXAAvbFOk66DgfolRUhLzVvKiVSaT9kHwZlPSHQa4jpMby7tgegUWrJGl6Gm6HeH0KLhaR3lX22JYxPEHyVnwww8yN1ardY94mekJx54CRe8LvBlX8qLCI/arO7mPBKnL29E7RP92mwH4z8w9MNreK9ihj4emdwqE+YuWaGI5MkhCp+wTg22jCEwZkGEt8c+h1HH4JHG3ap5DJEBxPSoROM1tOfYDZzoZVgvLq4tKG1bJCF1afggFmxhKARRUhKz/9vMZOvNf919RO0/AY5d3kPiRQvqU7I317o58B7Mn8Jp1Vc7vmfn90W1v4eRUp2cgTPjiPmJsPMqNMfSpQq6hCcEohzx1OHHs7qppJDyMErSv3YTkhjVMr9/Kk2TG/AT4PZzYtBqc0weGxS/PgAHpZoCuFoSPTffzzqZ0F2gYIb6KROAjjDvLB4esiHzYcV6yzkjV/BYefQbi36MvvnxmRbwdg+a9Ck0jl46F/kP6RZICwLfFiwS5Sn0ZSt/bC9eQg2H7K/gSJ9Vb0Fy1PD4fm35mXpdouuIUdU0htZPFW5H+iz9XKszptoZlhFUsQKSQer/Scp3ljs1eQ7fDCXj78ZcmXHc1wfBuTbvDnuKJ/7TGWAE7gNuCYKOnUpAAuMsPGyVAJ/gfdCKreh4CIuyx05DlykGbHghmGtjzWGmqVL5AilVh4zKwLIoBl2GSqFT6/qQ7OeChtBG+yQoXn1/NUfghpqAzDmaRjOKmZUFNX/8wPewKoFlpDFbycSJwxfD9uMW5kxX6sHSx47FdT0DnpwdORJG7+245e0rikW0HW2CLfHcpyymah80OIGaXLkatw/n6ZIzp15ODwtJPMrnHeiTwrg/JgzijnGp2DAGBpv1bh/rlJKfFd/wrsMyS273FY04vxT9nXA96K6qcLEq66lZ4+LAC9xPCDaC04HdQ7zubVgrX7T+FRCnGbOJyDcrhhUBZ8zf2kBMst8HXZVBl+QM4FJXgSLRzHWchCQRTw6dAiHLzIHADJDzqLVjo65Gvb+392FJsAgW5QidFunHeaW+aSPnpmxk3XtMOWb1A0xLE//Tu4pFejp0qmLBEzbduoT/zGH+/AlInBLQGiELb99a5Fdsp1woz+tu5CrnxhlEJYd++ZXsOI4P5i6UC+a2vdm7CbzeBbIszm+DZqSRIczFMZvZi3CMzTloNQKjBtdQHVwoSxftNCQjp5pPwISqBAij6++nz12gjeV85RTVu1Vgf6O8hRCF2vLglf/ZHjx6VgdPBO4PblufOPD3q9KKHJBEeAKO/1oUgEBEyl8mwGpeYzTO4Zi0gphtm/wnR2eWl44SBJa8rujxWPBT659mXiU/DfCDgAVZlZAz48W5rsjGW8PQU6+WQnpBUTsRqJONS56/bW9w9F4njqay0cLkBr0uh/UTsR+baASfuq/0jvD95KyHOnABnMoO5XKi70qVS02BVin4LA4tlWESVQfA4YbfDfWN0gZJp69yOgv7iUolfHxOOoE7PD5g+NX3kaxenCQU3WDUBz9itlVjyL/VcT9+tKOL74J7Q86vvNrgDf0Pm3mQ4zRUgYE220rc3Dq+PwPWDzIe+WGCLji+lDrFG6VwJqrWC6aC9HLtjZWiW78WipVhnMt1bZbSKXsc1myH1qPhx+Ge6suiM190zssz4BRtQd+RESSzNcOSe2YrtgGRbOeviDFlEGOouwCbTBDA/pQFPOsnGKvOo7BY22Do/Ko1fppvW639E4vdspBGrZ3Fyt+iIXeaMZaLNYZa+awmp8n8x799CdkurcPUo/h5n99LYv5U4fnyLTN3kDnFO1YwcFXiF/vsbqz+vzdBa7Xhaajs3PQThQIYiZI1Aqzgr8Xq4a0nLkj0UNaCWQpHYmRG0TUU8Q+tTSK2wXDn9vJw+agcXGuQIaoSU52VIDXeOlXdA4fbo5b3lpv/pgI1jSGSqae2MeHvkPIcAdzmckWHGfYr2zSRGTdf5WsWx+pTnTF/YCISPr54+TgjCKhnBwVP33s4Eshn5kQcwSlm992TrjH2l48/qkSUA2OrgU0oHEfQFHwSCrvSPSdKNhtvPigDuLFeWFBcNpCvMhB/SLnDBo0ydd0gwkLs5cIoKX+5XAOhE1qTjj7Du7hl9LtwINCm0emwVYIrhzLPNjdBzYrwzT1eorq/9jMijb5yoGyMA1H4gTK/tGs/MmYtSFsIkkaZNBxaIpS1r4lFfS18+72lhQ7QvijgM4mmRYFeAPTr/AxWIIp92P3/xETmRa6HW4pSC/M16YynaGJvVpUhW02DthdBbtyloZtyxgVIlEcIi8KT93hYkL6PIs+zLrsZ9F+IsaSBRkk2phair6/4jmfq2v22uO+sUdCTra1zweFOiYZd3c7VO0l+FYsmXL8Z0gf1dK+9O2+p98AkPnfycPGvxEiejKwaHhMd/UG+ud8FDkm/YkqbwHmCRFr+OPLQET0J2q3WsnhzV3+AsoCZZTCxJGCcdvpLmSBxEFGOHQUq/a7AQdTOKyE5985hA2/8Mp1I00GvqVu+O/yRsWZcBuL3zdfnqKvwtWS6SuPHiS4Cd2OrCJaRpeqdQueYT4NyFSWhj/dgynEOKI6NyL/E/CzsOkznmRQETRI8iDKvKHA69UsybHNYtgQnfzk/RBR+9m13hNz2oskExMBI6I9ngb/h5bJetKfRqetWTRftaYl47cKkVe0ITVL8FjrPhuOR5aB8Mk3h/MXZyKv3rU1vEs7/k4DYLaR1zSG8v274JXpaQ5NWyyKoBxFBQcG5Q7sr5PC/tgc79a6yU7yScW9dLPsp2rEk7NADpO007EURAss32mlv8IEUeJQuKpxuoztV1h5By29xPqKVIch6bcSnOYH+m4bFsnzhVblPFavAGBlxeLDRkyq6fl9xRBMtoUYqRoCWW10RwL4luPAkqPY4GyOEzqCeVL+VC7ZacuiZGM7jOYXKPiYIWebnTTbRRIE1Ul7GaExJ9o9IzGdE/hX6yeKodWIhgX9C7B8245TpV5QxbyuJhUIq7TAAVpGCDdGhoXPd6ryd8m0+2MsBbtQEvIr3mamyOKAICTOF2yScu3woBOhuuHdYuzwIva2QhQd1/OUwKu/MSO3kmADjBcbJQn7210bON+3h7i9GoNor2+JBtp59x5PP8e7qNZxR3E49f/v0aF0fQt8qfAAk2wRgZEjJkofH6dfNuB3JcysOrL9lnuqFbWJj4fH0g+PWAU9D0I14J57i7fNbLv/BiExadj5ZIl6N/TqT3fxjfE4YSSWZxWkwZouH77H7ABrxXJm5dAUjTStC2kdXLf40jzvhaMO/LXYZ6Pr6yry7imzj9sJCdVqtB0I2ugbg6UXHeImeaFFHS7/EY0DYYwRtnTUcKrmNJmNbiJbDDGbWBHukT7Mc15WOMHW8/3Kkux4KUXuuCIZHHx1l3Q8rvCcOXXFGi6CUvLhwOxzzv74zM+S/i96KQ6Kmi2oi3Bws1hSZcO9rmD7jPqFa9CcZNKsbFN2/mwfL34KSPghQwj+BxdoTnAC+gVvkq5GlEbrMTiMpWtSuATHo/tUsEGI32z9Mo+t8/dPw7tzbL5zdIeosyNPFNxESgh2EUwtGv0FuK0NtqiNBkHMUV3WJi2gFzl+OZV5dmf+5lVbBXsgfJTvPOjr5idvbCa8d6zfXkX8/ifAtrDv2PNuu4MLZdYw+HVo0XHojnPgG4MVlWbQwG867FEUQ7N006jN2Ch/4/68T12GXi0VoyLfLWguGL3hzbsvsYEoJbS3UzsNASSjan5KXV3MTJ0QfrWwWtycTjgfGlxzA1+o2MUwgpt9yfxfKlczT7JPagSivEuBT/thp4k8fmj1dm8UedQ5gZtTf2pYUYljvTzYD/VMu9V9EsZqR1oiSs/Tup/z1UjKQc6fE9ZFKXS5lh8O7hYum7N8w5fwBTtRTDHHUs8BV+OHS3yYS38gzYFtuI2XAQYEQEL3u0vs1/9LXlWaGqBGXddAgiYUu0cL4Q+m2HI7Oj53blZ+ltSRdr2BHzLaCcktTG3KPyUSAVjWDcj893ukuNnQVLwwXFyqUueMX2cxmP7D/xvUNV/moSM6r6j4xX9ru0fKl1jNtCCswT5a3M6w80focIGou2c2MyyCGRGSvJKN+dz4Touufm/B0MJxro2zcqqg3B/JqpV1bDze1axP7Y5+oOu8++9kuNeaDnaectRU+t2jxGTBxCY5fvIe7xfbPCBU97+gdQMvf3iqJTg92SsCWZ/91RlskMccPsyIe/PLu6YdfhF5cf9mRICar2uq/tp/uj0x6Ay2vSokp5+Dk+mv00XCoQd4qc1CpOKSkfJPTz/zrDLfc86nh4uDqZkzg4AulzzD7vXO3kh0XJ/zDOFEkTs7m7VIrwKZQKtzZE9IArX/gX0LQyFCizxdBkdDISRAy/y5qBLiK551z5sZYbZLOoECRzLnCnNRnscn/lVAiEldb6SYLAg3ujCjMIopY6GaPEiaChiByPmhzkaF1vWIFCCw+mMqlBo2ciJj6VZVPgMCVsyzqAe4mi9cEylRB2b85eKbRvw1FH0WBW/uypOnQjrjrKmRLoJIMUU/mHctg1fEN7HzsC5UqreO4G3uw4ez5dUaStCU+R0J3/pkqtquefiqfAce0dLKPs5vlnHg8XN5TnI/KK0xi1DQzfdXXzbD908pMSDLkc/HmvQGzF8BLp/+HgEi6pwCzQNAp4Pzveepv+6yF35rCuxA2vG4WNH188+hXV1KUQpn6aKgttIchL4urlcVZfFazaA4MXVheyPXONvoVx/sU9Ap3rIq2wYxqaShZcZsjXD8KUAv5q/5jttsbVyFqjuu0ly1pICPjnVL0JWvuguEezOXh/u1mUwXX3wpUn4tu10YpjVi8njSX5dldcdSA6sNp3J6FNiF8L/PxbhGhnqkclhTq3mLtQ32tKE/ig/0H2S/2QJY0Jro47i/0/YcqYa9OXIpR9u2OMO7RgsPDaXZbb7oDG8yE4jVdEHNGVsU9DmSB1L8y71BkQ2aOc6M2VhgVstyBoxHG+2ETKrCT58BjcF/jnrs72jhgrUZ/a9mir464cDgbLI0/Ylt519UOApAymWqTzD5jmqiglyGk2cveuqi7tz91jG0linBNAKL5Zcjoo/fIP+l/kiZM7J19uUseMEFt5RUJZFtfgDFGHMHo3Cr3mC4vLh4Pg9PwMsxL3uvEPOXsN1BWOwSKDpxXI7pPiZDdKuLEnf2gcAIiqYtfkWB1WIJnOdOTXUsLVW2rq1hH9Grs1lFQKuGacTMtpEHQcfidAr5lBVWEFuxktGtLYXfVh8NY6FFAbji5FsAByz9kzggnCXxNCQcdUN/pqBTIlPY7q6ksrUh9799oGHtI1ZRc7Ro8UzBWMbUMVjZBMuGNIWM/wD1j5KwaYFIK5gNnQXcdf5SbN4sGK+gSEsVJLRfoKbStDZgy0h2CF6vesH+koGex6alsNL/grD5z4ObpFyb9zC3BO+73NRY5o5DlxQZIoQfiH1XEb68v+z4VjAr1Fyy2ifAYXHBro9gJ9rYp2L8a15qlG3Dd86vCntTMZ37gBVb+QjrY2iz/9AshK4m3Kg2p7e3JfDWpRHWMHRmL1h6uIy8UfisXnS6oH9YnJIXdciXBsFsL9ycBHTlEuNGlzIpGfy4o1vDeqA5NgB7VdGylJHI1LsCdTNpxfDKY17QrUwuYvnCtjSmZuyEkK0anVCDmA5ZaDjl0+eTq0q/mbkNgsRnPjABj6m+0hUCDhMY2e2XeLGf3Yu+yy+7+CtDdkKlHP32TSXlC0JXGvshOi+HBxVvao+a0zSv/lA6vaQEJiGePgooJRF5jWQDWgaBT3A6QD4aKgXZYjnb40BcooR0xH8nGyqK5rgHceTxLsYQCXrcarbedn2VjtIbR4dNk4wSsMFhMoUNLXlPnkaBM6jtC9Ub/wTmPFC2pq56QInXnrMmd2/l1AGHkkGoIziHZ2wRKoHeWNK0Qk1q/SA5nG+xZRSsreg4Uocc6UIeBmUxBpZHl1isuP9QtqReIAWYFQdhWiN3NiYKJ5qKGcE9Dn2QtFq5KfQs1gnPf/6QvoCbsdfdaDaFOyV0WANSNZaRhxHUI3C4KC6jLll3qSqwivLHwlGyBz8nQ2suwuZ1wEbzwVoQbwX8o1d3591SkN05Bi/vtR2WkBeVe/QCxN9JUQVLJBYF9ofH4i4luNS9uXG8x4ia/KzsHVuw3ohUGJNAzfjxM5VmvTV0wlxbbiOgo/59Wg0DGmG1pjO5FuNK3I2GrWah7QSe2MAo4tmIQ7l8sTNUWcRY5FTbX3UzHjzlUdf/YnSywTYBsko9NM73+ceKUNutYt5rO5J7l+x68ugiHqh06vepuoZCpb4A0/sCW1onxvCWRzcuxWa3D5EEwGPOibzCjXEUQaaoK2A2apj902ZZWz5sdHcyL/L9bm/+ejF4rt6+XGqscGMw4AHmSjD2aVO+9Mw3brLPDZIncbb9e0TDO/BEZwf1NXi9qTbAefckm7FPPdeGnO45SNASp7bq4rR2kGUifjwJyeaZtMLfAn37Dvlk1C6/8p+IP2Zsw99KqKXhVSJWNz+3ryKIbeCZlvLL0OpRinBEvTtLPBDF7iAd582pWy6gLsPqNxusiK8zMTsz7rWV/F20Rfr/p0y+J52kGK5P/hVq0/meSbnlrzIr8gKFkRBwLi7YeIw0s1icelnJbYE5e02w+rNFv31iqncbg9+ZD6wt3TMRSIikm89iPDcFSbPSejrwoocG9U81p8s2fzI+sV5f/uztEUu2W1cn5kAsOWb5dzORWWF7Icn/H8v6GgDM6rSiYBPPMuqjTDfXwkXxLzYXZg/VT/AB5eQ4Xsbe5mcAeZ8e4rBy3Q6ADcSPdeZh7S2RJCCLox0rbLxkgDGSqvyxNOaRm9moMeO5HKZxJt3HMs8ispn/89n7fAw/3dOc3JddKGRJlJn8PlUW31n6bsCY0TZ3juC4OkUOS8Wj8FLKsQLVE/XNGRTAYq06cO6bPUsoZouD6MpiY9KbMgpQrBs0jhyFLViwGASN1Gm9T7hyuG3tNmhfHPhMRnNZy5f+zSR26bXZvprcldbwYWLdrS6OMkJjZHX9rQX4iTapCeA/3MHVcNJ9uXHCj3EKocIBCB8PschyBwBBzwBjW/pT4ymdHRqlS7ce6jCun/B6QecRD3GQ1A7EGVIxcHf1wJ07M3PpBS3LS4eKHSwCbRtQ5hptB7RnKq4k4G6LSslfklcKjDUbi/wahjIPAdu0ySLSL8tnsIPjfSa16fJ291oJccErjFupQi83eQ//HKsRhD2vUTa5Yfkswk4foDLFScvISIH+u+kA3cYEpwui2vsHj0jENLfW/qxd+ZNdoOLyKWjZDautPFqXTV1cLhmLv1gc88jtgAnbURf9mb+XztLgD79oDr/uz8s3NEZaPWFmSCubAXMM8rdtKUuInRZqf00t/7UpDUX2DghrSbK5xm1CfHSTJm551pmWrhqspHZipuxSYZeG+xjMQEsjkES28zSQq/RP8ciAGJmM5Tr5WgXd1Ohnl86kWDG5DHbX923SVODmIFrt3JJ4X5FsW3D3hMHZsFwSbCNibe4GAjsehA0t3gfz6XrValoMxBAxV774I/IR9YLMrS0XoabkbyihYLojU4+N8s1qxq84kNXNsvYh0PL+GeAzSrOhnC9BJyGBtJVpDb6VKSU/BPPlAIX3UI+lptrE2U/1NDXgpjhuZDrhgK5rMjCeVsEu/CeuBulOpTbEfUbmZBaZmqjza32jif3/ILR7cPyu4BRmw2OfmHu8OebEM8/LvYT3Q6ggsTIWL+8CyJ9q26BU+Ffhrb90mgjQlNBMSfXc+LcyrOLUOS/5XV4NomcmfkyLCZTYMMc/2YWdrHuB5JrMEdasPrtclDMLPuKk8pY4ovM2ZZDku88tMI5GjkU/AJn2lCZIpuJOcko+b6GeMHz61hVW1Z0xY+UrrCMgJ3KQCFXjGqRFBS9Hlbnpvkvzi3/bDBlNcEvRhQtfXzpmOaiBeFyVEC50lRm90VkCw3Ca7BG4x9LY0w9W3KLGd63OuuQmpzELUIiq+By2Xq61tIcQ21MHg9igxt5H5w1FjQDnP/VibnKJNiq0PcTGgyL1Q1+6eYUfWC84JseBD1gpYJkPwpGENMiYbv+ty6MfJs2etun2xKEo56O+1OaYfwPgiLbqvNDrLohLRx4GZN1NlbieL7mfjs/yRX5hN5MjQNYpRlG5JkkbwTb4X2F5waoPcUfcnsDZmeQ2nmuO/luEw8QoGMKGZ4dy+IOUsQxkjtUb01uIQCfy2Kqs73mW2NAUjsEyK5Ng4A0WM3ibUr/Eb72W1+AzEeQfa1VUwktVnq6sx1v0fCJQzJ/I+uAtZiOOsS0b5UlYFqHjsedt3ZqE9hmCwajo8/cJaFOIeB4bQWhQMD6SkbB8PmLiC6HsAF62VITSQikQRgnI3HAYbmPKoFf1Eb2OFW6B8b5XLe1ThY+ktF8/6wIXnL5PTO/3bPAB61qIZ3TK4ZtRhBZv3FqRpJxjms+4bypxwo7sHH0puK/m4iJAD7hTaPrXu5OgaGMYuw76y015vAJ/TA5amcVqZ9k4OX1DQRG+qMptaAhq51juPtOYQRbYHIv9JVzPNqeYlSDScDs5JIDd69hRZd737Z/ZG3ncWpXvNgzj1eG9FgagJ/czYly2lxv9Aa9cAgb3PDemyA55QQVn0mpJcShEdJuawzDbd11LC/5UUc4xhspK+ZvQT9mODg9qkRaRTcAAD7vpKcu+kjXNQx9x3YxVGulUwnQAP0a7wY8Wuy58x2GVd+SzFfaXQ+vUiBirWYTDjCjKrlCBG5V9M4a7E5pin1ymcX0rJUVErvSI1BlhCY/XZ1dm8ek7MKgOQoOIWQbiR2hZqr6iNJnW6PnCGayyjrO4cn8PP6y0vJO/VEMOIlBsEZTav12FYwsbJfUTxZWFjSJOZKH+H270b06QUJJt21E7bBCX8xrWWjtYlBPAAt19fBHaWYpXlyS/2OGuMjFQB+61+TJgxJfUStVbth5huLvP6zzFAU4KI2Ir4QRXtTpbAj81Pco9HMsq8XL7m6dIoeZWfx8E0XtGAVoiTuXGhN7FYpzxssoX49i2nC5Ratlp4QDRKCds2FYFCUqewhYggNH6rTMak9zdkSZ0u1/KPAJ2gYP+bM9rrm08IAW9AkPWgTkrIEMctcRCeMPR/gFVV4bAJwWjIxlvfKkMlvAlNCTIPLEIA0NnVupatTRNfjntfcyy7cGk0CIdAAbHhR7LaImjjzyGmHdyUMs7jN3ERzZna4wEJedV7IHIcDzsVTEPiGC1fQL7OzK69BrdNizSanL1aB9YMuU3iX5/VzURN6U1e/ShXZSvpTFH7HKdH34XV6+hfrHV7f39PWeTeGfWQAJwa9j44qoqWjaSebmj74hTTLjsOLWi+OrtHHva8oFVh+xWuT6ShJ4Al7vQrNhVETreSxcdD0MxrCQ2POZ0EokCYJaIQ0m9/AigOiih+EQkpJNZea8uLZL76VSWzxrYAQ5TPBWVdo0RSHU7gybCqjYkftk59t35+aNUZ8EYBvllWwhNzg0aGx/9IsIw0H9INF6gOn0VyoG8qErXowyZ4uT9UryHrjvXwx9/Dp54GKlHeSIm6+ZOWH3dBfZq/mkFp/81VgYqhJdWYFu67XZfqRFdZYKApwEveKKeSFTzkNwRw8T1gHBktKBvRgwy9J/0y0TfwQN2+tyICarTUCa+o0Aa2lcT7i1vw3mgXsUVy3bgdd9xS0bSBtH9mwmzTAy47R0l02iD8cvgofv36Rb958siV1UzSh8yO8zW+YvLChivImrTwZkevmsczDmC2kZmxReAJ7NeCFcbqQ/63/ahMyr3Gm/Jyvq2q1rbdvK0ErGqGaDtFnzCZTsTvg2LiowASU+1L4ITIoEiAjcEz3XNP4yNNFsX7t2INIX9FM3LLyfGaq+EU9TNUfucqUzppWcq9kmSa+BNU57WHfYHDS6AYvSL6zRUmmkKWl1QdyDe26jl8rjgwCJiw33H2mdJ3/zjfifMEqktQZfJj7hORlxYl9zciqKykfElFklPRIJsDZumNSG0gOPp5M+znz+D2x8HtM9agKdiWUIydlgunjH9dyc+za1JabXh2TZYkMdwsqC+37XgegtrxFzxzK68rzv2wwCHhpZzzGvMV97t/we7TUdPIib7PJbmiaOlO4LYHru5G4aaPPhzbrW3chBWOCEFH43aKBLooYjTiYhXihPO865tvDSjLWK9MMorWKZqS/g1cOpWToMv1HsxzYGGM/eB5be5mZoIyR3SURqM+tG2rC65sP8uEVfjqCFRdqlg3bAGphK1GHyKyVFwyBom/xQNgZb/ZWfg2ZWwJjRmErpw1ddJbG5fBBt2j4qe+1A7KRXK0N2wyQUc9t+S11xVRNq5cbs3iM/l9beqfUUImjmUecPJzd2OViGvOh/zGkrLZwLVoZus10ibdYSSE6ev1cV4X5IF0YFvPIAv1ttnABLN5wVlPmMpoPK9q6hQC4OpgfzTFMNtoM128QqsLAtOQuEGLtHKpl13Ic3u8PqgiTofNDpel7GgmMZJbdh/llN5yuGf7EvxaQpPEzJzJetsKR1bcUngbxcZzvxNWjnWKGzE/dh9igzYh6QAPA+XLFpV4Sa5Iy3bGFfhSOc0GdTmFtEsDfQPQyY54vmu/8TCP88fAXgRQE5Xjc9OmUQ68RCzlZqEujgKGjJFujqP74AzdiaiJ4KZdmbbrUWmR8D6UyRHc91mPA2pt0UvpzJzAqvi7bJduAJthddQqQhhSas6+G3nbhtidoeaTUib3v2iiFKAnsD5OtHXx5Cb2e0kbHu1AhIZKQsjME17OsCUqAFEo7a4HRMyeZGBktMyqzpylEgFyMI5+uumsAe2AXU8s7egwmBbQ3rzuUjMgFHaxvCloNoKDSMjhSLQAUdEG+BQIG6MINaoNJI6bgHvNKe8eBUJgJsD9QjiS1+qlLjjYfYvUg8B/EVDJSxWpbLT/E+SqYwW8kpKCZgc7wzAEPV+khPI1ZpI9SOc+gk8sGPgHI2TzuTyMe76A6pPskkhMw9H3HJX5LyWIxHp/SpdXxl5+EFSocdO5tlrqVCF7PVwd6BBiIcT9jg1PuzDYHiB7HxUb0AEt4t5hKTXHs/5XnBC09onpmqp7o1rIrxJM+srmTKM5EIXTRzVcfVgEsd2+pGSEcfhT9we5aA/lkXsbhLLgZulSsNq4zt9exEBXLPkQp15RSwzCZSDZpIr7e9spLyMJdI/ur4ysMP9hCguuz2EoqI3z5RDKiiHxkHZgug6lMXa8+Cf/1nw4nNF2Y8I9CEUEmOiP2JZ2i/+ky32LMy03WkylaQ+rrHhWyodaMjM2enjGt3pscHyYYb9CEZDBekbP6xmlm0aHOgXKoN2oMkBwPdAsAdbI97TbPTqxuhu0PHy5U193KOPQPEPLt/pyUA6XkAa+Np2bK7Y0kr2lNtv8YoEMy+og0+bMdFo1UNWC80Zqo0VALMqKQJ82qOKxki3UT+2PIlqrSlEDlWFTX0L9nf40Ww00Qg0miyOHQXeSio2ab7pf+UjYI6slWlPvLXfUUcA6i5ypOM8RUeTOBUhuo9oEuyOrp40dMKXT9JC0RdnZ8m1Dor6h0v9w9ZUMgw5R8ODWnv5HAYgabA1Expiy+lnGJewsg9278Rw57KTfBbnKIro3etgU0OQpYzLPRUnDMfLvkbt12IAwz/F9zKUybQFQ1d2icCHAiRlkLJk5Qr8obdGOh3Nh4UNa24vrkd5jBCp9Yg5Q9pbVaFNlmTNKDk7OOnksdbw5LyMBQKw+IZLyipSd6qr1TeScKSTio9lQKfnLCC4sGzLn80uXDa1n7aM0PMC7hFyDYD7z0cdzZJutQqfcFNueIu+4d6YMUJRmvj08UO8j8Rg52R98/Bo3rz4RwTOHURw38E6KXsqQXiMSa5vY4YzKwKVo5XxaPC7YWXgF5ng4BNS9L7V41GOZnnEY6zIEIFo6HMiK/KlxU7lkh4BNnOEAaFeBkkBF9KD4y8nFZlWrkWE47wgqyemOy5L/ZtleqW31emzAxKT3hvcQoVjmEJiIj61EpaodHJfXmauu/nMMWf32h3mmvnqPRyesGPji2aD1PBkLa+WYLFopJlgW7ZStKs5RdJbWbJ9ujPbAi0bfVczu2xhV3jJ3jGrvWTpFKMKRxyjCMP0Pv6bhlPRKLJoQvvJurrNUfXorFnNwsQ6wHUPydNjCfPHqT0QI84+oSuKgFPaXjgNZDpEZXsWfcKPbH3QIw9GOFPo4qLYAn3tZlf8Xb5uyqC/dAd6RBi1GhWyoUox9Ya4CAG47lam+KxOycctamgA/4tVumPEXd2pPMpyLCsW+e0auMG06xdlNcfai0KzY1uRA+1W6Og5zfmNkdmIoy9u1ZFzVvbPtC6EATeOdHXeA64I26JqllO5+C45Bwm4Z7gO2ueux4YIigeYj8BAF+2br2/2N5Dc2gUyqFlCKSWT67tXXy7b9TrymhbFc/S+Q8Hzy8s/AFs0+FekhX7l+p2nfWR4fhXArUg+amFBmy71aaYtjyVK6bY0i7q2y/6Rwb+p3jRTyh7e16Z1fKg/XE5Ok+UKUDI1wn4HjQ6df0sb2DEQQ4Oq2prnkqEbBq4MqzXUy2qFTctcgAsYPeuNp4ZNf+YC4L0GQ4zmScf5OyK2UhaXOW9J1dpDVb2FuxgNrmo6CTfaFRws8Ax/L6ms/CoPLqkyPMrdsrinyXKpFNhyUGesuFQaitqtgmEPFvB3NN94QVhpuXgDKHuG7+kYa0/kqILE9hV+1d5O6Lsvswx+6VlyKcwjV/0Wz4s1RgymzqoTZAqL21H+XU6eeEo25Ni0GvTSEpEom6gJAFO3nViYe2LJKHFU21ZYkmOXTd7hdsWZ0XHbdsITehItLwnVq7oBAmOe9bkT2VR8zDUvZMSR4LN97Gcfjq/ppzBiwEsXNWKilNDMhTeF0ZAsVprN3CkeCX3NVzb8K3I0vfkySJEg1vJpLWOQnVsO0fsGEd/aAh/ol2A1lRDMoGvS7hlmukb4eCJz7EUc0AF8AYSe6YU9NxpMbI7X7d7Kdh+xpu63yi1tXfBGgo65Ka3lfqu5rlkSs8n/w4pY4SlrQfNvNuP58//ds38/oMKnSX8TEbhkSF9K7Ns75bMmB3E19DM7OxpwuX306rpW58mgZi/tini200mz81rMG/FYK9ZDvZAAHZ22eIwpNqSMOnB24nZGcE/0zXHevgUhLEfLELRpunSLn6DKnOONWPhn2VNAp8gcCthh+wiG2u8t/dZ0Avjk0hgqwOdTOytBqIqklF0oGbhK4RiVGrsbBK4EZZEz1Nwgj2MtDlGy3YPWKEkBClNw/WvIe41UlWufgLUkAHfXK+SlpYZW1kIApMHQzOnoEQzJ4pc+4sRxrXXNwZ+oTLSxGXTa7zsAs6tRy03Arnx4fSno9iBWzLAGYnkGEfZ/fNppmt81R5tY5ASW4Q9VyKo85CEznIKfwmkVmYZUOwyzd5WzEI7LWxwZGU1TYqCxRu2KX/iVYlb/y1GQncPAYEig28Efh6A30yqVCKosmgV0LH+uHVBcljSYf/d+l4hPdReydTxSucYPQUZj/ue56jMuRpOIpbJa75xJTdN8r5JXZ0itewiZznT5wUtTiub16zyk0yofF/lqjS3FM5KOtui9wcSiMU/vuDZ5MOnV2fp4mwUiZZkivjGbc5OG29uzPuBU+6pTFjiHipdXFuBdQXLm90Sl2WYJtZR6LgVNUcUgAok7PO4sMKrmlvavR3yQpz5rYXr7RuXx+d6MAY+6kZSVGTp22MFzlSV3PA3RUymYIjCbPKWBWqMj0RpxkuTYDte+q4ucP2YBjcnijpIYPpqyndfl05hyz5blEmwNOL2MHtnAA0Efxa40L3sEoDlTEMqQ036niKvGZGhtcLKDI+hiZpc9uOJoGBX89Zlz70E9DOLw7rQyV+4ZJqQIivLzS+aQapyb76SKaq/OAZ3GtuF99ai3C/1RA/r454ngQ9fWF8CTz4VGkDVFpXKOCZcPaVaG2uGTCaV/oqp/dhbU9IE5WHHH/6Q5+gxblnp0nxOZ8yMbE9E/C64AcGA1DnYWsS29tR3mNjNeuDT/8SqCDcspx5wD+220SliXzGYYbYbDvY0VQ/8wB5wk0bT/+4tH/w/txGNgW8Kc/itQS4q8hdwi2JwCMlzTJZR+dGAsc5vvPt/PcPnoR7F/Hy5cVfQuNp0CwYGJmYJJAz2PEPMtuXIHzI1+mPqnwq0oVsWqVi065yVzMSY8TKXQY6fG/HHvNTs3HodgXRCGjM/zMwP0BhD5qPBiYq84/aCrexBKTETO1dpbunS3pvzwx6dyuNsguTcXwA+G3rjhAtuQT5/cKnyJf8UyhSmKOkIZV0qYwIP4vc74kuXZrVG09qrgbvO8k4iR9gdHpMvdYQwugB8hIQB8GxVFmmcbd73GVzAgopYYIL9f8Rx1WkzSE4lb+NLgRJiKMzlsLpiTH1Mfv7n3qo/YMcFlJY3JFteZeYlo1You7/IU+BGbhesWfcZMbY1ActF6569bbMg+ivOHPBpvRDtqffHtqZvw9FZM781uTBWIjwe+0EfFW9AsF2q/dDOTCZiO2UrgTIXtyzmAk4CTnkLueFHlYYx4Tk1Ebpd9N4UiIiMei3EiNNBXhXUBE0EmJatgzgH0N9xMc5MmEi2TkifsXlYs+04P9qHkhUMlU3McEsFCQseZt7413lEhY2r8/3lEsEeImnq8nM2oSraBaEO4UNqk5nZUP22lrKvGpkU+JPRcy9B305II72LKmU10Vn/Fj1H3wmFMzsdGAEU2+GYxTH1D9+cM9lz3f8m3QduOWMnHVq7QlSJ0HJUnCb8kqp6Cnnkbv3BLeKzLRFDY9GE4uCAYHo1JSFkDPv03NmRe+WB+OF9xNZAXjcEM0QN2zolZks2zz3cMr3vZjn5RhE8i8FJAlNcopLv9Md8d2Tt0HUMNC/wMlnSHiU/pBIEg04kqKXLdCIBYn/f49ecQ5IZ32ULlTU6oOi/DFW+GMPmo3O7FyjOuxZowzT7JywmuGBSzrIFSyFluvr78cw9bYNfcTgmyoUwAXi40xtcLvhO7q+NCpkpbGf6ib+nDOj27W/oTyBSkZpgTbAVr5MhV1wzlUTOY4hoDv2Jzp1tIdSjrCv3H0hkmEVooZBIXGOdY6tFBjkEQK1w6wcKGhImh3oab5tg4bCpbAY0+lO2ix76J7/RWhcJIG5Y9gAU2T9nqZFl9RjOQ3a6WFYQ6pp7C4ogmsNxzLPqyBSd3mR0P48QURcYkm8p3JAKtNYF8aIFDcxRtr9X6xru+FZmAF5OyJOvh3BHAGPyitYL/RfohwcH0lglSZ/t2IuYma9NVHUUNHdF9vsuEoyZe7OrjN6l8ET5b08BNzECIqdq2bItHLHwdD1SDoC9wMpVHyeV77V7MsECCY6+EKaDnaHCK5/Fuugd7k0veHqUs2Br6f+YEy/34a17mQ8Sasv8b1BhiUdROq5ag7snd/Jgjid8RUeOfeHV4+Q9PO7+OfS2OkntHcFXCL+0XMPVAXovpk5rzwfW5uutPuDfXFRWZpocVimbyG1HY0KAheniU5tlHER7tRvkQqCBtnL0GjG6yl42hZGzNjqT51vPg3b1infzdK0YVRPG1qJWLioQoj4nQ2bIKgy5N0o0wkrxae/np6CCAQEhki/SAbQJqsa/ve77uDb4wdd3HDCvsmDHi/gH+8kItxfZyMagpckWs09gyvFElTLLX+Sn+y62pbfmsvPuxLKN2jL5gRMDq64bCXzroHWS0VwYHIlO0P+Yp1vWaODTtDHpD8L+yFV5BCEkP2fzGX1/R5XYCKWqWqJhMsUAGG0WNhCaIcYQXCAQfcD3rc79XgyQkCtF3hriqh9i2T4JN8f1E+cYWPsDeNmXcheQnLRV4w34AXmmauzKhgugVp6OrHk2wM4VR5TJAIOKm/OKP3OjSLVG25hKo5ZX9/n6gdMegpCPGo/MOIrqdunFjcDyau65EdQli7QbaD2XO7EOOKCO0mZcEJsGxaNd10BbTWC/qD3ZxiJnB8VV/O1uVafKN4bDOVKc/Q9PSkRdiegWzko5n/qtG4YqxdrF8fFA1/ByRflArp5io3WBNbpcUeKX96NHDrmBqymFgIdlwwtFpmNBOd7ywrWt8TQQJpthXuR8gfuh2Apuc7TXkcN1RX1sfG8s5MZBgKQog7psyYHVSZi5rlwILjPYIxYLhCSJzlS6Vz4Ag/gGqSBB0WdunRaEjoQM7fGtGjfhFGpJOZ2lHlXj0rbabDV5ZVXdUCOSOZd2PWqw+HZ7/3IxdH4ShpoxaV3Fly/GpL7PUjPbGjJ8TXtwXNTQU7wp9BecP3bTgQ0mUPwIqX7GBCJOfi7snL25JFZEQaKgcRDsWOGDd5kQDi4OLztyfZa1KCXhCUl5X0JEg19QPCIZviuT7plyj72m48r67tGDuIBDPmk6ZWTfgwKjvGdhXBAAolimgteTNH3NL5hl/5LuBN2ckUMomPHnZlxyPP8pj/c4wPkwwa4Ucfwu/PZw7xsTPTfudds6d4rcfIujtgwcicpJRPiPtQS2dwyLz9ML3bthLewHocSDQmOSGIXlF2otzbymNmkzIGdvrDkCO7QIHhzN67sGWD41/giWaQEUVZippX+ugpxRKtU13qPcDyEBmaK0oRrNBwZIsKUhabu3QqFGMFuuiN7N26sFsrg74/zXEcq3aP8PLqLpZM0QxKE42g5UeGt6XR8NV5sClz3XXi40NI9LDlOdbHQ7k/uN3VysAj7lOR7mv2yuiPJfjVGnsmdFKQ3h5OP8iZtrPAUxQx927bhnQjoACgGSTkqZfA9CmHcY31XZ97w9isMe8igrE0Vd61NeMpjn/pq1BORypVe2Jk5RLahn/qlasxIS5ARpIbKQh1CzeinRYDNAaFTMEnVpngyq4LD4bCU8H5FUDUR/ON8Smr9gyAYyMo1FYu46DHLe23qc+jnZLg+lJwOpKQGr9rqFKwKWVGCb0YRxkzJuqaQlyPI7h6Ctz8FHbKMPGJ5UyZ3iE9WUvVf/vNRLzmvTOSZqnikHl5/Y4nbyi9V5XIkdruirwq0LW1uWQ2RGyC9x4oXM+p9yRqSr2m5IAPrxxwOsWMBGSJlwqNllo9WG92MHDpABtHOjC7IuINTv4adGoXvsNdlVB2RovyX6Gx6AhJ2c8o2S7yBNMpsM6vVA73ckjKWYGOHgbN1GpLqjB1+rQABEFpltEpzEnTzPm+6vyZAPCgRRcIodvbQmaSnMBfXKg9Nh2xmz6w1zjLRUTV4XXu2oqY1WYbWhgq2mpsue6uZMk6X/h8PMuRxE8WkWH3f2LtM/Yg26C8Ikui6IWVIjJHbWeGby155dF83rNaa62IF2oDx4lKgvbZX4oDXnfgWxFOFqlc3yMV0acDLTpZ9AW/eYmdq5V3NVjDIXgo3Tv4T6rSRdW5/a5zA4eg7uyWu5TOCyrvms143ONmMEIjf4rhuBzd0psErDRhpOYeZ9Ifd8TALHDh+r+cpZipd7yWCifIRTJnMfO9KWkt9oC4hl2ck/qFx4XtNA5Yj+SuXRAdkPh8+iegdyxdZ3OxoYuy41qQLRAlkIB6XMVVU5A6Ma62GyCXczvWV40mOUI3kQQLAi3PiesR0d8mybIFRxn8Ixk7pyUPamI2GT44CYuB2QhHQiqi9G7kZeZxj8scvvfmoswBDFB/csZQg1Lumj+D7C8yNqxUgXs4pHXitfA2S6koRwWPxXwBTk7VXtM1jQ2zB2wD+Ou8XX/9E0Cr/h9P7n7wDSrf9kZokAv5Zuvv3lH6eNwrsc7EUVf9lLzA0qXtxOPUzfzOqjjOD60dHGzCjYEEnv8dmHEFZlE600IzY4OBwZ5/A3fYGA3QaBw0JQ4cateykKExOTwGktKPmAgeFo7NHTLG6n20KkFpraGG5Wa+/pvC6GJSQPHuPud9D0SDOfkXeB6Yw5kXU6J2K3Svo5IxDaE+PSzZ89/smtTvC11YI0xrNn8UWIcMYPElF1USw7Suy7vNvhu/kCRpDSd1bv9EKP8izYTGAChxX0BVr+dHOg51rAgpq3MuwU1DF4d+tkctmz/ekipYacs2flJcFiKoYVXgiSLqD0SgFNIe139ycxct32sc7bUEoZS12+nwEj1y3a7Q386BYyzgqmrZrqupxFSTAtgR91Uzea1z7d4HLojdxvnQ06ANrx1FrG3L8eAX7RiVI/5MH0AHSoEzqxyRvnwjA9feWKQN/PkHwSfdiNIUohF7nYzjl5W/ocyq8NerALSWFgr8ApCHEoBZLs6d+peN2WrMS+u+t5tpuiBnIIW4QSLiFQm1tl6bOqhj7GwQVCu44x6qUNbuqXpbf6CYky2WJqVBRHeFvVNi7ON2Ygw2rjOfPRhh3m6J7N3yEvXPT2IB7fudyUIqsOxIw4AfiY2vhmTGLVfN7sQWxhey7tV2+nkZjOO1OZvD/KcaUYIrauL/j1vi3710UCQEw+7gpBMUXCujlN9QAnn1sAUVjgb1trkmwAYmUCO/FCgqhYOUylPBLgY7StuzXLyj40yFmF0nQD0cgfrrcj7hJZe1auAO2HECDdi6Rfj2Psh5edG9y2i7I1LQ/sDTMzremtyuWTbNwZ05WQIa8CPcLEp092uhc+rc5Q+TB7qEUNj0b63jB2/9OcDYXjRYAl8SnxiF08D8sEqPonrakWSUgrayu4G5+s/JSvUbBLK3fZWcZCyRtIK5PM/fRmwgCNeBxYuxK35SpM+IUvE4ITvP5YCsO30/J8duKf8QmtvL/hnb1EkJXd711gDq7X6uRpDBxT5yBy6XuMCiGAPrtPzT1tqVbXtphYbR83nXsjiWKhp5ru54wHldT9jFBOATeJe0QJQM9kCxq7imZ4bEHOHgBC5MS2sXcytrUPlxgtqpiC+zI7Nmj+k8hbOkFzRN6TPPQpkeuamlaRqGKtYyj9Hj40wNNTOLYLVFutRofkl4QK93LvQfpAuyxCY6BMr6RWrD/R0zJcxXfQzoUVy9ftZTL8flNy2vuUk4gxUPSOeZ01hmYt9JrD7FbdhdKDAX7fYunWC6xrig03y4TCb6hQWnfYxVq96AbiIOwVzeFP+3r3iTTHGDkJa1pie3JEMe5EjdAUipK3qHjsimcyQFo9tDa5wqAGhT8TVmJcwsvqYKtxdmf86FeSWFPinpkE1wZCQFVfNi5m/EyWlFwQAGBj6YpVZ1gyyOy+8P+uZXhO+BA3hI39OlvGi7RdzMpJVjAPWQCCgfkIR3xgUaXEGEmokeMaAbTaXwgZcBwgpCtUtDRZ9T3knexTHcGKg1qt0ronRS3h1hw3EukFWlR4n4GsnABHi+sfG/NxFeeQteH5lfYDSyuLFWxCXy7XetLg+R8+E1v2wCBz3AlF6NqKBiqel/eFa5dn2n1Rcyrn0u3CHYF5jNqzs/Fb/YLI6jUQTwWum5euGI7rLcN1MZhAFTtsYWCiCjBrETH59UsvhxWhDx1kSErWPABQKah6VZT8nXKxS7RF1fiNZM3c+YYiQHVgpSCqB5spqE+rVHWefU26fUrnU09rrpJWqIgsuCDKPmy3FgwM2hLF7TauR1DL3eJVZxuKoDQb6MLKE5WiZ2hPcqlpn4/k2o4QsLDZ9cBkAqfLrpvFszRnsiMSOPWw8aoYiaRMKKdAb33hugBcuLRpaDY70932sE7NxMC7uAhQqaTrUn+7lOjmhqeiRHFeIRRZ4KmUVmB59/pexpa9ZUpG5BEYq/ETyLYgCwaMZ5ODto3tlsXqM+4XK3Iwzv8JECog0KLU7xjbDy6zguqLm8rozGjrv9h2lb6Sgu9IjMVXK4010MqUIyYh1rcc8BTPsTcmpODuXA8eAfegxWfaA504JQr0foOT4+eu8aKVtLaFOMQIwjI5lFATTMwtCTh1+yx8qI6LCLusR/r/9CNiiOy63JM4v2R/FgstMmsSGM8YojaoaaeFOsxcHJF+zzB06q+n9E2gZvvKUTwgaCfGOJFAhrspuBalnLQ1MDMREL7XyJ8VqxyOoEmH+r9X+tYcHz4HPe9Ae1b679S9Md5v4kf2V55fFKQrqNO9BrylzeySSU5ULjOlvjAz4gCmUhpe1BysKsUENM/EBxgdYBOHoPA0ojqwr2RXxcE8T+jyups4Gcj8Qq92O66PoyB6JuNvuAVvdKKOCubeyF/sc80AHvmfsKLAYSeF2AQ8M4sCJKZJJyzMAeU1ZopuiK0XSN0MgCOn14D+ErHpEc9jGFHFICY8zPnMlYbHjAzmP+q4kW+QGpzfPg9Wo4L4e1ww5bU2oa7KW6GbIZHIQtths/SeFOiiYMPvHBjh0PXh/clMIFQoK9Duf0pLLs4qjQtawp/L3zOcqKOu3fWyncMfsjNLNunmMtUIOlVIL7HicwTRgP8wDW9Yn8998mVYzKwRFHyv62um5/PhKfRk1KjA7f1Bz8s/elQY2F6KlbstE04NpWjfTS3gplS/6vd86p/tJnEXDIoegPkjRBp0ncpmNCkLtT61YeKlj4u34k4ax4RUkhXphkFSAIVCdDwjIJjzUsqFeYvm8GU2oxSXz0JZRV5ARRJeYzhcAsuzWq2eiEU5NTKTtEeE8pThqvAfb1XZlutQy6gS8of7vFIbkvB+jXH/HpaPjoRuvmQj+LI9gMJQbnGv9d/m+NtVFRcFdIhVP56pN2dPUp+1NuxIK+iRcnEKCnfeD5hAh94Z+QZPnGcHGTbTiF5Rj2alwgVEu7tSR+ucjVkJVgWSkmtgVS1BYH/IgH0h8e0WEx9xrhgJqank562Pf+fnZ+uv83usU+zcfiIDjNX8NALeEQ5FgCt7GH0u6AxcFOcy6gJKBNAsMYZjeO41ajUuVLuuqvk+ballJwOWiv3XSqOXt8jpKkXJXDNk3fm2C+k/gtah5dK7NGJeTA71LciC956xZjwlb0nLhzdvy3Sse5mZhgrGE8yE82e5xA+7v2sN7HCUOuxkkl+VFZ/C11HjxnoRXYSTF/QY+qYNlNX/JzE3/Hj1zldFSEspL1CVP9sXsNPkJD4uarer/0MqkuLAiyD1K6V8X6pObsiRsrgKbvQ51OAvYsTDO2fkBzTq+Se2yUb/tCzL17xUvtDlAu27ypM2dEJYOQ++IaV4aNIa40kht57HVt1hWAjUxUC9TeLo/3QG97bkZl3HtFolHe1lznnnQtP9ST1eKiB11OSDLtCUy6PyzzzbOSK31Hxn1tlUDP87a1iPRx5mEnUtHXGjqNBO56aqFQxAzhKzvAuXlHagv2GyKeEz2AuLtXm4k9n6iudexF8KiMplnLr6HRiYS2m9QGhGizsG5Ry8f6WnhVZDLfYEZ9lev5d3CS5lgyLIwEyDHXSEe6Ff3PCrTXrWbBn8heO5PUVktOoQorR/pLYSEOTAQfcQa1bkW2Gw7ANyB58RoUDbSxqpgUN4KQU2EzGxEv7UUSCcrcayRB+5RL/PdwdY+64cuavkl7xW60L8gd4aLWKUD6vyibkUVSvwLZ0qCZDEJzoF75MSzAfEx8STolCJTNKHePrK5iRw1T2GCm0n7KMfnCnOls9rfEn/ZB6QMsMLqHgqLahjlgZ9zLwEsdSgz3xICSLIHKwyAgFrXeD/csymg6KTVOxeCJU5B0knN/syw921N7Vhz1jZ3kqNzl146a1XAWidjpj9/r8a50GSuTUbC283VfcjoJrRO5A15affvDV3Qh01bxCyc77v99g4xusz2MWerRdZxx0XKyxfbzb+HTtJ0uPrR7mAh/AOG1fTkBgtchj87YGf9ZBXhgBbGnDLWqATQmdxR1oH654Zm7smYBGVAhjN3n85jFgjDb6dfgAnIGI2H5XzzFKZ5FCsHZB71Pbonr3vzBN/pguTSbYsA7fBjTvopI4GajaYuOhupAfETCvWbJ2nvax4xfzTT8bL7qy55LXQKLuL3fwtn19BLAs9X88JLjFWKV4VDiTZBQo2TeMW7KFp00vDJQqx8oRIgeqa3c+ya+i/voSNZvT2b7pkqzimfp5aaZZArG8r24mYgIs3FO4pHWz/1uE8a0zF4Vim+6jnLsKsDr0puChpT/KPgG0AE/1pIP04aIy0U0F8LSps5/1CKz0o6dp7uR4RXyihUthcwwlB86BnDQHjAXnhacRnBfQohrFrV3zCs9SEZXIlVQ5NnfmJ1ubhOytk9rgiS5e66QdSP7WgeGJurfAazVV3wHzLY4iBK7EQdbpBO1O1JuJ/rgCSMNByKsmB9vZhLiEGYi7aKd2CZPweIT4GZaL4SqslReDa3JFmLSR2C6zxx8Ro+kA7vkMX8rt0N/stV05b3HjzaKY+ZsHel4CyNFAMy3KA9qjaqrsR9AEDlYoApvFPaSZptWtDSUJchnXB34IkPobQD+sK6xnkcCSwG3pbV89P/bOoUNEe7ygWxvjLLRuq4Nfja+xYvlFIULA7bdyqL20MaoYaBhF8/djtwDJKaN6rTia+in6UmFYgVp8AixXwr1I3d1wvGIFYrTBQl5aY00XmNmt6yDp02HG5Oy3atdmTp8KzOdCsCpMRs4cx6q5wI2gwZrUtAJXOHE5pI+1uL544sCbvNjFBbeA+3HQURMj+R0QjQe2gQjASmBdVsObf0aHsBa5kgMpWb7vAaIWLnYa9W9uSmffl4L4W2coFXIDoVvXzno7RzabIXpFRoqAWObAFC+kasHJxJfb/nTXkpgjdKoAptlH8upx8UKH0L0dxJyU4jaC32Lh6lad+mM7jToRPG3PoHZaIdkgx8krWPy89ZnFqxuyoSY8gVrYRlZKvY1i6iJRRdfqCjc7wC3qzoNVoXUXDlwq4DlQ5u+vuZOK207wF4DbSa5SdGRbx9IFLOiSbwUs8Zx+yWvG/TXTpYkeOIMkrGsjT+C1orCesostlX8PIDoUx5jJj4kc3W8dQ4dwKQ7JoDjzl8b3hwyzbOrSlpSec2MJdclhHoK6orCsadm90IEaqUy2kk7tJIX/uql89XFbudxezBIrvV5qKj6mqjpN0q1KcX0Sb66lDjNcsYkU16iNWyRSmQYQKq1//rO7i9zUVi6Ork+7XBmtxzLyp9Iu6Ufa+c9IaY4cSoGVPB3VSb7iDGaNnUY3oenPATqOc5iDbR2B5Gjplkb8sLcK0wwZFAcv5L/ftahPkRi3h0x+QSDuJkvj3mEbDrV9E5oPOOd1qk6tMjPndowIQo/VNKLGHyBp7dFIqg1VtBdq7t08+hpyi5/RScDjW0fuli+RYdcThkZVbJJlzZIkmYjqlidk9Wf+nMQlXenv2CDdAyGE2m533Gu+oCyqO9Dzh/OYwfEwmdGXpyHu0ORbkcYt603KFpGFxfP0PNb0QsHLE8O/Di1e56VvDtWqAEYChREZCRbS5xJM6r85rB8mp9jTo/exsi9P3Gk72XV2vbmB4KH1mIDHW9XHEO3EKnY2urrdHkX4RJkZsk/JfdBY9CQ7SkxJUVdHGezRpSnJuqlFCzwvc7HADqLja1KfU6e82YXBAz0BZnOPMSy71hL7ce/CQWvsMzCYtdiGtJFJijiDvrGv8nz90lakchkXXRFqoZCF97dNgGPXdKK7i3DlcDvyhyySujkl9RAabnAHBdPD92tF/tTOsxMuep2mQZ4pjSbrSYQlOXnJ03OBk7KjQWWvw89A6a8jlRSMSNPOPFK325KLO+7z8ujxFh8xltRC/QIw3/Ym6/XzNaRIeBZOo5M6yrLQkSC4tfV4fNGyKpeHVt49JIcwXQQuJ9dOYK5VyScxuTSJ6sWhW9tTVQhhtc4mIQ95TAMKtoO3RrfsciTD5ZSmz5vCD5s594GjSc8ZzSggyl6iwycuwW2vuAG9oGaA5/zBSHeUzTo1HJB25jJcn+8nIQcSmDqb5GJPaui4AScR/xFvEYTxTmQTtKZL/4dxo+wmNBSztVyzquZKp43mSGWsQd4p+x0pOMgNJiCa8SImq7O9ezhnunHotSKbZ9Vi9/ykqs3t0frOoN02DXa0ltXL9cETs9IunDLedLDGT9z9diE6k1SyLoeHGIH5dPNdNBpmF1ta4z7SDzjmVWVugeyc1dBOhforhpLFSp8yCYxWwHRnqI+VNaha2tVhgLfH/Z9CEQXJt/Rru/JY5g9KA8qCZ4Ph7SsQlqX2XcqDC4bLRhgilIi5b71KGe9y6jLjKFF9AcFURLviFugit1+HpxbDpXZ/nm1IcU857OeNL+vapd+EKcWu1zV8mM8/zq2jOU42Z/gxL8gmfFGo0MWTPVvhP0/52pECDZBr+hamFvOObOmsOnoEAVnvUOspvBGv3lMMI/1rpo036GqmPAt89gzFLWb0bGcB/oKqxeibGsZkT+C5MTMsGxAQmXYTgy0H/OndRiRjsFjAcDRahVFuyYHStAd+j+h3EliKcGYG/a2KYPZx97Hole4NDRHHykRUeZlM4zp6p3tJQDGoDW73TSjGsNUgPjiHXnnS8dUHyHAp8O9DXb9Hq38DQspMWG/a2Krhx/ctUNsmrZICLB2A1trTR1AnhS02G4ElsxvMMS6xS5U321jtgPHaw8nxrIaRqo4WfZj2aaUuIHqGLMX4x6T5JPz1dYYKCOfYvToq94JOyh/g5nFoEKKkAnimA5P7712Y0UOFm9L8zqFPi6dtQYXgJSiLD5byYkCCsTYqabAja1Wev9jWBwfJEIG392WIpBHtB6sBYIhv+MS5GL1JgV/t3ehp/bemDwjLFAlr1QX3R8bXx41FRv0zcx5KoufXkUrnqxwgyBfq5UWREdvzfw7JYDPCFWZ6Cjc7UJ+ypRLO2IrxSyZ8nxu3wxMmr1CNM9Z4X3saR2WpWenotJveobOIssdX6VpI1zQFNtp7dtMC1m0bUzD9AXuGdWCNIVU3F0PnVdFSwiUhfaCkO+sQ3RNzjGHel5zShCeCMSgiUXC0slR9zLaukNlSxx7Cddq+uOySMT5JMYC9dUH0ah9HJ235Q35FoybXM3+eUew78Mzcdg16QWp0e2zD9ffOufLW5QF9fXrIkEJFEJC7JpOsRQbP7TVDdnKK5gwAFpoqWqi0yDd3nUQ/oO0BFEa2/5QsonPrcaRjkc27xOHYG2ZT8+Vqjve4/hTTmsq/GdL4ZG7T4ByaCrowuSx2j6pEeA0XF9jYHW0VOg3A9YBZo7z6c++q3RKY9i+FR1qm0i1Aloma9dvUb+Pz4sxUQyThduWJ3jecOHV9W6CLRqjbDT4PCwTZ2P8/x4LB8Fi6LJMR02lYQrq0D2LTXwyVHn+LHhSDcHY7AT0anErsmwfo1XtXuegwTwbmUC9jgQ5ePPiyEXpLA/1dDetb/7bdNYMKw7nCcGLL93cExJLEFDH6gKuwj8Kigjz2TAZu4apOOPAw8DD2CnA2eKUCIjPfD4TpP9k5IdFJTMmEpzLapFnQYwQbaeN9S/daS0qiuYhosj7jzEQN/k1GHOGgI0HfwnIlKu8GWLdlaQVhz53t/tr4Ka6B50fg6teKElFWPlvxNOoFFRVlkNEeiXrHEZBF+uWk3/98cbvoJk/olTjZ7KqMqDTnnoxtD4iS21Zw0fYTfcjMkkqcLSsNAAAUyYcouvx+dh8xYf1EZiarTseubU9Qe+RRJFCNoinsFRY4Om80b4nI05fSUoc1mvJXtaLMF21aX9+t+/oxKI+Nl3BFsLQqboIsdW0S/2P+JWAsw9RkZ3JAKQIGAGHGBbqn/Ihp+cBJBF4mVWJKq2CIfzKFTHIoLM3QeDqRlmmCaxiQ07fy7g0KJiT9Z0miY4xBfRcXaa98q8OAA/T4tAw65BGUllps0IoTGPCrg1BjuSFv4uHIgYrWBiGs+csJVKGfvmoP8ADD2fJisoZ4eEG2yTNImfgYTnf2ew+mc5HHTrD1QOxoMv32zlzwz0BYN4+JHcgy01y5RS+IzG5Wgvi0XqJtSnMYwGiEwUt09936vY5/GTYMxMSGkblFPXqkd0fVPtCZxW2Qh/VJVkIN0/H5OIYsKcxiUtFuLwcgE1o+mysFa4oPqHRaLNIvKvvuoiwNN6FJw5TfsFTWkRk/hqpYXCvE8DzujxuB8xQzGA6JGeX9jBmzxeisBAOpewCd2juQq9Qm6eGE0FHlkXzeRGLey8E/O3dUmycf0CUWKIXSw9MKW9kQTbaltFoXz4uXkTPVQFmgaBDg2ta2aVBzP7IunNhIr7EWnZvWNGQlT9E47AsKFIJzU0UXQ2zeMQV8vNPGF/xNvJyC+iIxUwgTevdJVL0rJtsewDj70YdhP1mHLgthgVhZCy2h4mcC76Au4+mdONOO91ttteTP7Sto5DFImJUNYujHfr2DQZbaWv2PTqaLkIavhhdM/altNTVvzPYR2JXEYKwk3MoSdX2Yj5YyD+eYQA+ob+DBWd3h74uMQLRQBGJFtINzNLi4yHEP7lipc36wWCGc2/Kry364hueNLbgeYELHeGO5FtQrS9+eOJ8OTGkyQifqKjAuvfoyJfpeeTUT+cDlIHE653uaNKxS7G32nqtP/VnHMLu7HCJZNDExCniXhnFIEKKkNtEcqDYAHAeiW28CvUkO4DUI1SdIfwwoEXEYuRXK85s02WVA6i+LGUgVWD9Bkp69WurFToy4uHOKdJQ6h7yu+WTSdH4FZH07TxgiJhRn2GK2RdplOLcV9C/ufLqTgkZ9R/lkWwptrQHOP/Q1kDkFadtOtoaPQoPNw7ZUDBuFNmGcBUfvhrE5zAF/URj0dYV8ZP+xPPQbgj1E131NSpk6QNuFxzt3iKkCFhoC/zVZndWJM+1VpaAdPoKxenLsA/JIszGl1xr67uj2VpZVcZ2Sd1w1Ta1aZeZ5VR9iOVJvGSJFMa1zTzxuzLaoDsuukoS0g8rw7QwAtX9stn1QicqnrOSJnjGaOebeVe5NuT9jT2pNU43OwlSXv1B/fOu7bW2Pox/74/ZBBr0WMdNBgmzwCDYBpuYx25p9afDTh2HDtEft5Jude99ug8KHK2kppwv9WQuAO5pHHJUOOotHvKkJTpEOLl+/8No7iNeqDgTZdEnoRSYvN45vw2XIBIOrKKRYvLFMxt9sD/aAuh3DXHhIZQvGt4RZaMMkj6YVxtohrcu9ZZGVYsxoPl/k81HFTNQ8YkVb0kxBDYRC18ztjsqshz4LiA9u/zR5wQ4uHKoYbggB1e0Ye+yDILr5dKDGPBb6KeIbFC2+Xo7Niwc50n56BpxpZK4WrTDxyu3btfh4lrIIWB6M4OuIP+yZqgUHl/FxP43Tv14MazLIuOkjsYCbzkqpfUfKBNoqiJaWcSzwvzpNVQTJJin/5PN2acDb1eIaa+6cjY2PB9CyL4j397EhrgVxrkdCIau8ibWOO6EPZehrRK2JSwfoQTLa+fj3iu2kPUanM31YwV/2ffQZGHhjA1l+BXgzdEQDLeAK5efclapwvxwR093atQ5ovAznFcPvY5+X4sWo+HMJZT4qGfmmE3slXSpHvVioQMeXcSVlwZHwTLlMa8BStvYjVju99nHTjng4MJAyr0pWkF92yo0KEV8vj4+nmPKVml+D9BjC/dUWeZrmwl1W0Fya3FM3vcd4mvM1RS4/UBvuKQivNHtkLKjK5hBe2dA/z64kvUXhfNJSJSrvTqiFxH0Dkbw0YelsWvG1FUaasNVsGAk5+O68Ua3uhH+Ox4WJHd/NaXswY9NaLD1FNDhuXArWEgpobL7MHGoAj6/06XmrTNOfOOgir3cDGVOZaWIWehRi+VD1PNLSuhQZ+SIcHiWOW2VCZXrArbaIi12QYJr8TKN4WJRCKS0YTVVovXCBtKkKc9xPl18gNL++M2+o1/+3zTqImh2QY5/cydCJq+taZ7Yemt1NtI66HBoxu3TS77nr9bki+P/VUbI3Gi9iHS4HDlEJvLTbLA7ruYOWGbQmB047Wv7ms585fBCkPgqpVXsGk18sD+UtwlHO9oOjvfcu6czn4ybPN5eDABnGm2o75oVHMmRYEhR/KkD5J86IN1jl5thugUv2/FBGC8WnMy6qV1/W8TVb1hw+7QCTSDlP4XeKcFuJhI66syrLjOCAWm5Hr3SVPhRL6VrvgvR/QUbHVfmrDT4dKTEKB2Y8O5gf7fRaoVG+1NVKARPvkNyuWr2/W/S9tdMi9TGqm3DyRwnUvnoohpCVal2h5DjcJHZcNdFkFYC4A572IgQxHjx3BkfhA3fczlFXepvOrvXlJm6VkfTPruP2TXupwFtkXi86ITyLkYP96OoB19eQfLma773v9sTPSGufXE1W6bK59UWlc+eLALybj21tiC70KcPv3BLpjaOD+QmdtsgYfj6gLenSmP/mo5ZwJaffX/jlA1MiCERyPMc5VVTcOFYyX/O41PO8pQOSWUc5sbqamNesoY/A1jYjDvy1Y1aJMXNQ/Aco4Uc5I78aTEOj0zgFznR4YhXyjy43mIa7xIg0OtUGX3kvtnU16agiMNdWQPZY/dYpnWQAXyGl/5GWuyWGK5KSpV4jQJi1pKTcwvNM0g9NdlzuT4P5BNC/Pl3/JBGuD+ZxmH0bO7hBGGF1r/gNvDrviLUZr/I9nuc4oRtAjQ9sN1Q/nqsIQ9mufPAm4nzx6slUD4d+qTASYwGMNGwnPVzKxsVZ3et27BxJTAOYJNx2hXPrYQDiqC2ZU0HtYV14itgYgKhzwptjvwLO+U6HaNImNM7oJiRBv9ZoYZhuniyLt83E3Rgq/IfNMJv5Ly5QKKgwhOyMocZjbDMah6VvbbeYjBWk9Bu9SgDYHhLhqknZXJNfflkp8yS0ohHZMnedFfDDrQ+cISJlsqbS/yoR9vCCg67Z3RjOlnDJH693zQCpcIUyBCZT2Njxj3T9EQ6o1MaorQDVVDu/NDkHWNJUbfpfkxqRN5P8XhJP9CJTodRKnfIgkzMlMuzYpnrCIALHv02Hjzbcd8m026PnHZl/JThm6zRjYO1yD/31NELkWkP6sAxCsNDcyjqyK0aeDSkfWEeGJv8e/Bs4HiiQT0Su3OZ6ZKtqxZeAjJrCSjjlkDgOWIsf21reoyGQ0v8wHzFU+Wzk+vMhF/yimkmWfUAaINZnVNALLtCjix13aGy4orQLNH4Jk7yIL0INz3jImjaDqRHNQaqyKCNfPUfIXXfvFGE5MlQ4ISgjVQUs+IgG6crqSZJh1JXWnvn8rXMonACIxbQbnDcB97VbMspi+3EymqUH/HH2b59Jyu3sF/B5aVCh7/14eYUnWBtu99AYQmvmHOVuNGb+7tBI8Gyv4x6NAROtOeIFpQ5etnFW2UadeIHxbcLIJEADD4tcBeZVdSGBDYNtcRxiGByCrSfkoIEh3RIIUFzup+fl4Lp1KCrfOjO9koLP8nPQYiT/OoU7+hLB1i90Mq+TpdHBhsg5jbWlJB5o0R83IkiSva3+i2JiB1KJltZS4eMr8hLKAdHbvYPpgpb2yDu7uJY7cNXEX5FNkJtfefkqmiyZFXB0awEpZx+FOiMsI+i39VtD8ywNYCO1sWxKT29z47L8qUX+e0hc3XIiKlwxBoJSEQR6WWfDpjK2zUM4RVWznlLywSh8vfyiSW0AV+z+xtPWEm8wWIK7VbwcufgoViGv2WkVgt7Pgx70uSUY3zr6iKDDX1o0bT++hUYTC6L3X26vGHcLx1o/cMJ3pdNAIJVzluq2z1xrRN8QKnJHh2c64CxcCBXvTc7X68nwu+zByrN+hI6LFcnzmrkEwxGlXzi2yfc6OZwvC/Gah+Jzid90hdOfbSOCf937194kUhrwaxiryYTSkqOs9BR7UalsC81VQ9OwqjGEeKY5rWMbyIWe11Keb8UYgWhlqdKELy3KX5AFiQA3n7v9AG4quYjq320DeKmVS1EUsAVuwDhQwA7ZP/rjTci+OJ8REZIU4Y/hu9KCm124LsQG2vM9dvUtdqrGjP4EFkVJ8QWOxOwYLPuSadU6pH1D5F+FwHrfwAQZHKUmDZcv2YSdvTZcM+4D6TjfHPktUW1R/e97LI9m+pUDeToCr4SdlJtXO7lgmwitD3kP/S3ISCi9VYWVTawxyYFawuSHEquQaKkiU8FbuMjAOyWhVLhuicJMlIMzxz1DEflYrukq03WxMbguAsSkPzfyM4z/5dhuO6q/jR1dTOQJgK8tzR13mTPiV31Nvqu1kI0VZXCS93HZ4Q4EXI0sMcbdgzTu/mCuS+fscMLFjmO3O7ddxKZvgUZQ6F4Ja9mBjXTwZyBUyO3b4cSkq5JiQcMyhHuQW0bY9CbgiFNYi45pKZmvFe+BfKX+ntHpQKEifcIqUI5a1qCMX448+kUlBzOUYvAKoZJhHh8yOYV9wFAzDxeFTmdXMoyZvJwa75jhOto46L8NO8GTIn4Bb2GvuqU0I5XIVwqgIbwzx0YJWXQvmvHJyHZU5HpJU8BaSsEn7mWorRu3UZuXN7H6OuNHb6wytw0NouPbYq2SjbJw3Lth2RySwOOhatyE8XTl8bQJk6GUi7/HF+BPdTwStmA/74XDXNHqtbGxvkRF8GPLuFLR4n5GV2CnLN+8TVVUYm6ZiFvV2jWqccNV0hZ0U/rUZ6h4XuteCaEUxJaGYoJl9XgVOLNSCpoBvDisqF0oM7cTJK+Egq//U30ssP7IGY/BtJa7lsTRPSaG/THs5Y0oOV7w8PiJSUWakPv6Ce8gtnu7OAqISfi9Za14o0J/9oHLCAcQ/1m0CqP3v9mn/cpSWay/VHkiFYr0Gd+AeoqAblIkbJFPtTBWzSO79EFFIlhotpa15smh5/LIuwPWeoYz/FUebpgVNeRzFXa5JRfg834f/cDg1u32PuLnw1jeGJUz4Mu3mPcJmJkqJW/z++UMi/fYmyAJwo4vJLGPr5zoxXO6RT29mLM98j7fG7eiSYyAHllMmDImnTuNTlIDcr3CiFjO6VrNHzeTkoXhXoRhNIqAHEoI5n8+h9Hy/r5Ot/dlP8dXAH4n11Ga+K9SNGU+oTsSWj3zOuEeisbadhS8RJ3M9qUyLlmvjPBHxD0ZvcgcbGhfcH1sh6hyhenN7ntISBy4WnWeST1MSPy/drulrsSIlpNfiD8O8aY6CMblAMrNODgRWUl8iFZ1al6cj7KpJeP4c1D0HoBVeDNuPxDx+TkaHIuPVSaqj3bf3nojQJnhdLx9reEdChHous37jxrlxEDm/4Zo9xHpdq90t6RgTKlnvusV6eX171KP9ciqFHclkRk1Tk+HxBBdUYwHaLIo7crZeTz0re5fzl51C1lGRVI8+yD/XLrhgq6EhXHj8tJF+q5jlzIKsjvc+ushNotnU7FqjZL25ceCZbav2ec+fa+CdGJDDTCKcu6lSPNLosud+CF3b5v0gOeYX/iJN/7F1Sm37TpqEN6imQ9Uwbj5tXg8X34lLtkUaSd8FUEhGhXRmqL+Ui7J72VVGn/u1CKRiJl5WaT12YBgJiWYLsg9fr70UrioKTZ3AJdIHYbIYLN+c01VYxTP/jPDHGo8mZNX2Yvr5AHIuSeyHXfdROHWe/tI/BxjTrzXWfQAFSAQA4ayDQxNd7A8MyR/6kRkjnShT/UCfHqRc/bHZh6c1a2dkOcTa6J+MH3UZ+Pl/pzleaadbwYmb29C6xck0QRQjDTCQpz2UCOCw0A8CfxY82FSFGaFlKj8ixees63OjaNvQswhl9HLxhhcmLDHxBtXmnXDUKE97y34jVujNPY1PBKaAfaNKkdls+yqQYryqb4jQA2Epja42+TUblN97gEVaHEAvG4l+r4Lqd6LZeVCf2Hl1s1tePav8iR/VyhRkCF1Eqh+QP/OxVELH8XmZ4VgggPihrlGUjRg6P7DnfB4nTLX4HcMLyBm1obefzgVYkC7mFN1cMmI+IcDotmGU+NxQCxW8erHj4ernkmpxGedoLngDqhD2TK516TEF0qfcVoFyNo0huEL/U+TyOqMJp+SOUs1TZgy3FNaaNAACwsXbQ8KsZxpx2X/P519AwjzHgahCJgitZE5WaSM7IhjxKbkD5C6oNrLWfysbXLt+U3Ex9JsCL4psIFRt27DJisb21RqBaobSO2FDZv4M0p9BrdGa0srvCQ09jSaovAXhhMnnuuwLp1elKNUKCDSDktebsobUPELkgMu5jvdtd+iX2tcM2UQ0z4NEFwAYGEaCoSiBhhyHr+fecyOpK80zSbweiPrWOZvjf1OfnfJIrsrK1tMNJ84E8AcfpV38SABFhI96yS7tX4MFQyW5FnISXLfCfKNx0mqYuOkTjwO94KpO4eZzjkf/2mUWdlHPQWraH2uUdxsbzFHZOqMi/PXU5kMe8w4wuXneVmP1H8pynGkjJVIP6XdDl6HmnSkUfxduvvTr1q4oDFOgiMQRkV9qEt+o0ColQb1pM+KTqDlL3zolPvsXoIpIM4f4Rri0GoW18evNHvWMTR2TTwcXH6oPcQ6klG9vf1RxJrtGBiA8iUPwwWDyiSCYqr53Wgz3pvQc+LpsZ14TDFjlpKnIAJM/sg/tNtZaeMZwdUiYdnzzNk8JllD0FGnMsus88I4Ktv5RFkQ1FdXxWn3JeT273PWGXVWle3nvJD5m0K3D/gx+HWw+3+ZRGmw5V7SAU8CjC+i+HivGLup3ONBsy7GiifiLAgKhylKiaCWh9K5nmHEaEFb0FULvH1ejLZ1jTF3Ceb1ukpuDfnJgfWOipBr/ecWTIe7raJaMtaOAk05YMaxuJKrg2JL91RfLVyIVzy8GBKQLPlThae/KeSGpPOcexSweOk+92Nwb+CJGSxpN8dBkQIjOVMbh1qrv/nlGdrp0LgHc5bz/VTi813oyOvKoFPdXw7GI9tBNb+j25N3CSZSy5s91DfKuoLJbB9gfhEtnQ7jx1GeOyKATIFSlagweN42JmyuwwANvA51xm1uB17HPK9KYqlVSUktOZMAFzog6Rsacls42FrTuIjCb/jEuW/Nili2ujcuCsb8WXcfDIB5lHljXGzIhNTEVjZu9sS4eTMekUUjRLlaZVBkXUPip4S7krabKP3mFGBTRcj54uJ0BWL5xa1t1y1HJkvRZn/CJareOTZwgOz2F76TQbZOWZVF1mMCJiSoSSt6LuDehzsCh4BkuPtaslTP7qLXafAN1qUkFj0JT4c+NM3RoWeIqR+JwozdM5SYDaOSnADorvS8hbS2nianC2ETHNpu0lV3d46Bh6jbD0Sc56UHq63I8wuXYmJSnfExZJ1jiftvCPmbqFEXHAQbS9IH9VYEuUGw9bzfzdU4h/GvWtxaEYcjsZ1WYqLOfpCqXmJNZcVMzvA5oKmTjzG9P0OYIwgF9iI6e1c9+KMbtpEtRPcd3iAknqRq6xOhnj0LS9gkKlMc34ni/lVQwncGm3AGBV18n4l5+c7qBQKGDyB0ikWYRbfW9BUYFShg++W7bo97q+9HmMQngbBKsB7Ny/aj+YADEBOps63+EIVsnlS94S9rDPSnptbZxRkkdN495C13ZmT2Qz+eeAZH2PN+XVfMkmx5Dp30m04vuFC39Ul5Myxqa/WmL34KTswPA/7rmepv2t1410uzaoztDSJJKvdsb+0uwIEIBt+iexVQWtm1g7IShETpr6wm6DctC8QLuTUa/c5VPW/awXuO8egWF7lEqXSbImWRovGYlxg21onaOr1sntDeSe3XjG2HzTuqyZ7tHI8EqUrnDRChZnOIOwZ+e+jqsakZVfHMWA96x6P09K6ydI0Ry93+5bia+5NCr0XS/4pCAoXSlYN28YgNJkt71SQo7Nfp8Bmazyju4+aYvDE5azeFQOlWGYNfymKAXknWo09g0fH8N1K3rcuwE7tSC0GMxBJasY5QzcZ7icIQXF5qeq7CmHUsWhu7fL4MQc1oLJlIxh1/lzJolilFNEvTE1xDGl+YU3ck+zXBMe31GYaTA+ocQzLMHoH5t6sP4W4LXHTCkMddn0z5Gm4Hry5y16wHJhHgA0ZkNn6mHxW6ao/VyQ1TzXM23tE9Du04msNe4Bo3FhnAjVwtzhXeoDMVbu/xztIEuFvzcNzvypxhLuP89IWl5Ftc9LJV3eiRc4y4ihxueiHPZrpiWOk5k/DRbx8aFMhgFhv+yZnhrkkFw9LxtJJWH5+lYaj/tiFjbvQghJJqkL5GHcc6sKM4MvKQWlFoIsGhsVX4nOt919tTPr6i7xtjCy7DrbXi6LKWSmTVXeVoU0RJkRdm8kH1rQoRCqb++WdUlP0m/7ca7QPMaXWfapFMu8O4LQavnwQ2HbHKdpPVvRXJ5GZ6zShPDU6qwclLJ90q9ah28M8LrWXxq6ZoQIzLoYqV6h+mKmytliSPOacVY0RtCY5xdfq6XrwdJ9XxrgCpoOsg3Tnq5dJxQiCtS9CvkkV9o6AOhyIQnd4wqfh3z7fO9yTklDJRmgUa5gdX8fMzWm3VaQCBoEaBHAokdReKdqTG/5Q158cCtJIDtnmzQSWT9yvNycvqSJy1AQ+7sd1uB3MgULbRt+HsZchLMGz1LA+hPaPI/B1v5jymCBvRutaUta9yn+bEwadj5CvnUjx4GUkx2pralO7Zs/WxnVIY2H2WfL2NYQ+/KWY4eP1MTpshpbobpWc8geSZD18LW/LoWKJW91uDDmzUEpC0i1pYUWYnunGgsnqDg4I1OrG8JqBI/fnKAPG15zslpcqhGVlFdcJqzjKN8GmzLtPSRU/USlk9wwZ7X9ujwYsHce3xlUQ5ZecbY99VroXCWMcYOhSJ/cJKKkYeA6dX/LC4iiyW9SSYisLiM5ZGP0drFCN1r3+52bXYVNDGJGFCryiyaLLe8fQFaGpgTaRchq7a8sNM9UQ90+8yLOwo0wIPMS4HipueRSFoAkZmHgh4vVA7MvF4wVgcJEj5Z3yGl+SoK0IOefwmGmWxLXfzZG+gJsPyUxtDI+xGgG7g4Pn1p41ZnkHLREsKU848RMv4U0Lyy2xG2VR3JvaGQqHiCd6yw83MKTuLgzLqAURnfPv5wAl3PiMyFZZz9s3CGsyCWs6+xgMK2DLuEhqzX4e827FBj88YW+F4nJM3BtJ2Zp9I3CHh1QOAkEhdA7aPrCd/BtGF6D0yaU9NJOhjFhg1Bu0O3lmb++tDuat/gT6GvxLXKOFFdP07BDVOzVYR0LxwvYX94XeQO0Lou+syJ8maTnkG5QtkEv6cy6zG/4RodJ1RNZMKKk6A63FFL3rrOKwGxRukZOAqv3R7dBLoh1VDBf21T9ZwgCwjgwkHsS258cA+exc1bKvYUdg+DIDtfTQeYvzEeBrQMYj0rccguLg2yWdhd3TTtBT/mPphUj8P7QYGMsPc0pIiLH+bA84Li5z/8suFwp3+xb9B7UgobpZnmcT9qiLaeeoLeIpVjYV0rm+x7KigM9BGNrqgppQJM70mv9Glut+OyrU8/LyxMdkadVg8wggpZF9HcjyIv15Gj4iVhzLeYG4tpdts04NSYQwCqmQqtbK2UuUCmy0ydqCmxH0upJdVxuKDreIfrZ/zXUYoDBoaZw42w5tYtuEmi7DEuYL+V6ULEw0Ozty1hO4CToywvvkKMjEBxIzH1mmyF3EFrs2b9tldCM+hZc70nlQt/6E79mm2IgCJuouUFGaMW2M4rlV7TYfquc8BXBLIb1l0BJauDQzwFGn0TXejn11XF9a9LQJ6mSr7p1ggnA1XarmcHwe9BklDIv1LYT5h0JzTYlJ8e0H6NTppInKoRaZqDVBQevKpexAjj4JYXC7bID0KUFGL3zCVesqVfg49DGpUJfJxupRZksBQDYp4mfRHeHgwjJydWYpzflWZsUnclVJEZ2pGufk8kn5ObxVM8lcfCw5Pq5Di/IH0lFxpawTbF2HFASWQdz0fk8CjvsPRzq59IV69utm4lgZoja/YTIIp6+a3ie9LoBZODh6yqp1UVbBSmxHrGAFZnic93EZPraI/CIWQ6blUzKEi0KqF5fqrW3ZIcKKd7DY5eGf1g0N+HJ48OQgNKxVUvUolE9Tlx1xG+rR47X/eFJI6M0hPk+crpsDph4Sbo2I4zpWYoa+R71TiuzF0MgOEFwmTRvPTUTU4TNfDvZS2htBrpOHBjoWz49qyc4hWsZJ1OWckbNH90QEKyDj2s5nRynWWjgCbQ9RZnYem+Jw6AX/q4mKTrla3rPoazxRZHmoaULreiK6afueMIJDGCsRKOgFQkpl8SgOE55cMwLzYwSh3DcDpd3+1id9WvFQcLlhovkM09UOQRGpi1zKVRRY4dsjJtq9898PdMpWrLcZHUNhrr+MlX9PTTSOyYSm3ZyrPsGMUlYChuLG4chjq5Dw2UvrCBP/Frcj0sUo3RgwioIcrHn9tgBu5qeHwcYmm7RdOIm/6dZnZ+/uuPke+fRv+g4ZBwyjx3UxClEiGY61C6Nx1/WdgiYAcXeIbsiGWok2UHvMgQEewu5F6qhrvbJG52DtshJR2H02QBH70iWCG4sIAnReL4wUm2mVrKY2ypW47kAxZI4a6Oe//2plJzl5NXyp7/pB3hWvl9thucX98fNtu+4cyU/g5r1qhLc8ivp/2hJZuj0LD0mMZJ7+CXuyZPdCh82JnbVZ6MosvYcYYN4SgkpvIo+OLhDjSv2T8MlrS0LdgLMt46m4X4zMX3KReRe+zzzA7jVk4SzI6/Zv31SuOI6MFQ2VVYGeDrOY5pehSVOTLLhmarm6e4XxZbKalWqnVIQzh7AbNt7DLwfwsQyi52UwXhHCgOrnfbU7uEGgDEnt4k4YhYS4YKwPSngZ/MXwUe0uaKVtbUMhH+XNQ8lKcQssRRmjLV8cOY5PF88IuuzkiePOLMGg0Pg2C86pLbW/13b9KOmpfGTUvSJNBMMgph4POykGmtRLl2G4WDm3QVCui9tUhiFqTfeQgRWtxid/G9V0A1NbAxlETe/ZDjYKGBG8XOPC4Dsbcmvwtg+yQWoxfP9pSmCj6a1zI9eXDa35o6526IXD7yWmh68P+StYKyu1e1f8pVCoWKd2v3Fxu6dQA8mFs0I/IKipkAxG8HeoZtKRGAN7Sf2tCpoWAnQmnSVFi4TiijsMNgm7q2zeP7LXLXBMv8v/mMgcvuYfAogHnToXSaYXIP5vhpF95V30TwwpNVo6EcyxdH9MQIHE1kx9yxqNGAwBbu8XYBRJQjY6iUoaStS+PXoMBZnqKmJSgzHpOvSXgly3lx1o6naIzdcchFsSuorp0KgCZ0oQkO/V7v/+u4umn1HiFeC9XAgtyAxWHqXhu42pfYLxIRFF4gKK0UpvtTmBumy+zWJwNBbYf44lJO48S6MtQpCKHiNn1y3Yg9xDpSuQirAOxvjHCCcYOkfvfSkRypO3ZxmCgJipjFIkDnYK1vdJB782LSCuAiSPeFIVu328YzQOuIVEC1p33KNKkoGX/67+503X98m2Qca2pEPIq73GI/ZBbzC/cEaHBKEyFfXTjOXiQXhqvbBX2a0hiJqqMg8uAkwiDt1oqwyyJ+uYKYlcnGGVr3uqWVcatpUA/IKiE1TApmVhCR43tY95lmsMkSCqZ6DODzhiZ5F6t3tvAoI3f/OxweFtagGZxyumPfqqWQub+glrwrMPquScYVu/t5wtTRi7LVRNLnWUPQNhplDmZF9VUsDcZt9X2BPCftHjBb1eDwGGMRI6XB4J5OYcXmwbIo+sgF+C26dIf74HJDYEOPMAkqVKP2lJKw14Nk0dlSR0Q4OC2QqH50zB4Hqu1bQqRH0HJduKzWBn1iX1egqR5V0yohFpuoi+i5p9YRAZdWq1ZEjFy2DSB44t83NUHCoTJJFuPFX3HLKftcYR5OCnFphKFHS8EH30qk2sonfndYFslae7I7CwTy8ylvNrXVrnSIVLrTpLTgQlhrRjGqFYjWYWA4EbTnnDRzFTKPWAZiodT/cgKwrSXgRLMf7fF2Nyy8kmLDY+nGHZ+Zomc7tI/LvxyOKqTga5QSM5AaE3coNSKWnjeow6MHy02jQgqBSbo3vc8khUTEWX91edRofVs/q8swCCpU8AvOEutMjbrXcEeEwUXja/dZi0EO6Ft8yf2E58+1ebuR6Tr13YV8fKKUlPxFsdwewz7GpLRuSObnVE5TKWAoXi6gxr5rfaT9+VOfMqxrcwkE7RKg3YgqVKJ8l7slMOEgJLiiauSeGmOg9OI0sPeWWm8QdNjryEStVN72I242xB5rDj/7IHLAEB5hFqM6ROFUdUUmtyqut4al4Vig9YK6ToYcazqFMvV3MQYI6G8FxH3zWW20lIin4QrsqqBW0gDrBk9XCuHsuuA5tF6Irmaakczrh59+6+LhGbaZYpREPM4KMOXr69oGHS91w8BQC2CAjupnPIPVPuxDVOPnmOwm6EPJCJXnZfuaRUeIwNyv0spWeqjA5T/EFgg54CS7IfWTqBxVB1N3BV2QUgEmzs9mUWgS/IswLo5XzHWzvEGnRu6N5OKhEJjrPDSc03xYpa1CYKcrD0eB15/2aONLWoxiG+XFtu6waHzlV2jRj87ds+B9PfzytJOOr8ARhJebN38c7xPLN7J1dSMBp57gUJvXRLQrCLSK9/wVlO2ES71ggAZHLNBFsJbTRp6u9eJt2J26gYU5EBSOT1Gj2XXv2XuCi/Tmx98dKWn6hMj9C+DMOtLBgtBoh0IMgFds6Vha+iInf1LhHWIMovwo0/NXQgm/y/7r2wgRpKkXgW7LsDMuoKe8eTwqXApgGlVkM1Oy5Rk7W7dhitZ0C8WhnXkX2+x9Dr05rv+B8IuKOVDmtKiUOa8DDizrw6p/F5MUOiFA/YwlkYTz3YS5uirOt+l0FZtI1oqGdBoIopImacI2Aaxek22MP3UP+AA8JhPJ1NUoEmkcP/D3SgJZUdQkj92e+63Lh9NuSVQKthBldZCvdhF1VDXrsSsx2B/7kSK/+xBYTyaJS8hgNM5Zrja3g1XUPOi6DYHdhpu8iHy3X2t2Vrj+MxNY53rXiTgm3UJ0ZB09aovTPpufJis5A9ciRLq9hlVC8d7CKaGQsYBsSnH2guEGaso+l6MMJaDZIeFTKuK6xECI6oRn+qvc7jHroWsWXs5b+Xvn6/cSz6IuUIPGyei89n0u6PZ++2Y0NekkQsqsFPt6iIqYpbz/qXZ/W+Y/NY0LUEPUCgCRmRshol4pj6SwT8Yi1U2dDU15wB9X8u5MHWQ6/Vn/ly3YRwc/DB0jyvlHiW86kdfU4Pm7XU1uIeJSHU5qb6pdlWrGGLPvTTRCtHIi6hEvJHI3uk0lHEpuEf2bUMzCA2prLy0wpILgk904iacic3LoLGv7epvtxBVzfajMkDw9hhubUNiu+lCPrprOd0KRNpcaCTNroSMEgQlHi1pvgGdN+1AbTWwleF0waQkUn5Lc7k56FF8WRWGti9erU2ec06xztrUUvilDTib0EFX71wakkTWE5M/1gFjUqB05JprzO+lK/QRtJRRWjqlDV3OfHp1fUEIyD0Dfszk2sZGOVO6fMkwTpQMukj6spwKoLr5iB8Ii8250Nj7QOH/6k5BL4QOM2YnxKlQOgss3zNFDK8olzZr3dZUGs/pO+qAKJCYapw3+W+c0YWjcbu525MQjWwz9XA+oLcKQs8pl+glw9IL9JQ/fS4DPAZkzB718iZpoUMDwzApghTskwAn7438zX/V7gj6OFOw7xS8/kLVMOB5a3Gz9X9lP8s/yovJHS09z4bCr8qFqMYrTmWDMlfPNvG9/GoKgGZOU2g2VDhEOCJjYpGBfEzc1gn5ESDFNW3t/uAxv9zKfIyYr7vx7yIHjUJuy7piplFVlULQOMtz0bTtze6xXoyqBXJQe/WOmmYK4oUyqlNO/y+SSoE7dmIak1SfVF5htITvoS55tec23l039IkrTW33kVkwKUV3iPwwkW5X+e7/Ml22HE1OjY4S93FuX9XLoJJ4RMjC5AKpcMNz0b6eNAFbgUPuGaMrzBBqjZv0F2p7Xg436PmHFnZVp4YGsKIGaVmAd3WPkFxS0NB2H1WizPgIT2+KSpdDKmyuMN7zKzv493GJQY0Tt4IakOlgua5kiWGA1H9LU6sv5jp4moda2Hfs34IdgMRP0pQTWeMu6WtnyFU7W6zFig5XG3N+KK9wus3GrqvdrIYTaHewxVyvquXui/RJGKKZH6SQKX7LAi+cT/h8nAT1v9KjJRyOXH/qBdnz46GoeSxAZ3zDq0L7rUFhR2Z3fhKz3/OT769l/ZtfoYgMzG3AJAiQrro8rUJ95AjEQMLpti3F5h+hy5nZCDBry5QNe9kxCZ+bPFdbM09ZL1lGOlIRHJ6NJuXrx0BENsKP9w+k5DkqTsabUGm1CZ3no8tCokF9qWqs4UzYMCR3s4DEyJIoA2tWTZTXXMPd1jKFdylHgxFJ2+f067poKFnhs417lqurOlB4Bj0OY1MdHK5rpk3T4zYDwHipXRxjWcxTsmuf7NfQ7UPfLkXF8zuez4qHbgG8cxrWsPbsC4jt/JTsz08aq5OgxxbooDnOuifDbbxIncPOhGZDzxbhtQdc1sduHW/gAQsAyrD37MC9F5iUAFKW/KmDaLUFsa+5oP2qtvTbw54xPAMhZqAYClro7yJY+on8JMF/gnvYOvZDzdCBYfr+EpGsNcBF86X+096Cheytr246U0H47ts+T+79jn3hm3oQgrXc3pbGhhNYMPfYH+BlZtV8vPTDP/Q09IqBI0i/hwQB/Ex+t7Ds7EEsGUKFaEA3HZfjgK3/1LMwO9mZvK9H9v6/E19TjpljQntMARfNonoumEqahXWKis9kFKvHeeGe0KvAg3jAb0AE/XxEGlGjxVDHAsVUGcwK2aoMI/Digsanzc1J6vynPyB13lSRZ9jdPoRlG7lFM1XF0Rr8ZHXdUpv6lQWK5qxKcDRiL9b2GlXfQJLiQb3PvzbHB/sKYIeRVTxyqwcBQrnXMLXKI5PZag8rX2CJzjeGC7B+X5ziWaN2K/fRCNVnpydORmxJwL2qrPtYK8C9Up4bXROSfmxRXjPs8h6JT9WU8CIYSHz4bOKZpBUEY4USO0ITwU1911aQTqXE4v6J52ez0n7g4iPlfjnL943bKjEp0zZFyMNBhSxhBohB/D4+rrTkN1HTSrpI2dNp1BAcrtkLuHQb9cAf9ZFPx5NnJCTUUP/J+ufJNLCxYlcMeBZeO9X320+ee5rd4Ffsget7KgT8Iat2vxyV/WmERGRZh1XN8VvdGnRBauz5FylRBPbHixUDX/Ts4a7/mpA1xyQKDzrqYbb7fW47KQsvs1K8+uKXGQuTP/9WbJWRKe9zaAA23h4rG9PUx1YYVpbLAgAEyQdf6m/x4PTA7oQEwX6dlFQBp6rGP0feEdnzqECkQZiNZl4uM5H2SSYLZkw8I4i0y2wJfYge8QHJCglNQbIAtjf/yMPSxsEclfXwBcgKnkriha2soCNugSxONfZi58uAtU03oCX9L9c6DHawoe9+eQo2DHKVjr3RLQ4T6sJV8DYP8CVJg8Qewb2btO/FBvjuvsWsO7yXBbg1yLA0SZUQra/bn2DmS0HnmZ8ObUuAjm4arz4I4EfqCWK9sjKYMD8NuPk/lOkTjoqbXYPAStdbgwF3MCeqc7bDd1HJfm4ETch+WHyET9Tas3ujEoG34TkI80PZsqo5PQBwTExDSAmDm7Ydu0NzUVeNySfpuaIyPfqMkiBCAeiM4QA2cK2PgK3yyj1fPL37RgRC/51IalGlbe7PZLqMLN/bd8SRkUHw00skVROJmHBY7YmOK784+uTkRK0Sri+kELtvUuOSa+egYrPgKvD1M4dcv2zvtyQy1iekeD+QJOZgrSsMS3AZ9Yr5BSoejZJb/iLpsqVbaN49IjCdTJWZd0SNrwBcRBzsGfKavKxYTtrEJf0jZGegSKoSJon0IpqDBdh6395BL5bw+wCEMnWQw8DNkwi0cS3RX8idGdvFnW90TMgREUwURspqY4WpRDfYVwTnajIqH7hEssJ6VQqVHxxOEaOFeikV+Uc08DZGpeMvr6zHC+L5xFspwFd/ItLIo/GgWKT0ewKZ781SEDky4oBXMAiI7CJ0LGphWLiwHENu69kkYgqvk4TcKFKSj+j3rUPoUwDiLwtpzXO2V9Yadl4QuvUqzyXUvyi7sUQew1oIksIXXkOx5ru+xYM/d2XmCcQUdeWeR7LbJ2GjOP6Pl6PUVPtD1J9KXb1fM7FnwvehuJy/Q7tCodY4sCOSiRVjxKZaMlWlrwmI2b5JgPv9LkTcClSlPNhU3LaP+7ob33W2CU+zvlHfTJV50xOm2TdP7KqrKeFIhgGdLwpczsALliAe0mQOKTf7rsYBNHcpJHD447W9Ag7RbpHhsHYMsXE6xeXd1fw1GC0AxZY/uixP5cRPi/KGxUAg5ZVIVsch7Uu2BfGQMBhJOeJCabSZf6zoI+NkEy7fiyMcdljB7FDU3KwMfxxbE4kgAIuI3P4zJ4CN2UJf71LUUe6TZfuiOX3iUrKmv/FEFZdI0MUPmhM6VlwQLW5oQlxGxyuq2co2Y/K3eFvjhEiiaG89oz1qcfVieo8Hhrrl8b5LCtgal0VhNe0w9GJMIZOB01Ly+E11FHd0GsQJNo9ifr/qlMiWXmQeLkYBcYgawt8nNYUNmPPMwryFyeUFTt5UoIfu5UVd/6eWHW0Zxk6zHConA825piyCG14g0iJ3LV3KhheZH6xRVPhS1xm0SI6pSiq7gwhjtaJI+6DmtwiKlf6fEFT5IpjnIgnIiyQzYixTYxsr97YpY616/ETtCHVYRiaJ3k6MkT615/wSkS1jkIVV7MNFR+qdTgQFfq1zZynGZmsbjeJx5kBni3vYMeneqVRdnM/ACzAlpFpalzYGSggOl8SOfPGsYxye8kfibpKfLGbnvny9h+5/Xot/nyxW1g3whkFFZgv0YYj1833miHBjhjVmwTwHKbMQLi4VtQ3KoF8OjEDSQACMLu/yqN3vgndL/KNSIppTKpVongBfh/x2YpyIPzHKo3m9Y3W2MN4RLWDNMv+u4GnLprlCUGJtjI/DM1/ejxXJIpxx6FOkkDGnOE9+A7cF3iO6s1YNrwF4L4VkAMcSCtTb57nQQJ2Szj9fZv4v8+61Ge06u+g8xxkA+liyNScuCBexYhNh1i+Vm7VHErHNatTXReTeid8o0jIN+hVBeE/elSFw1dr+bCcP9FLfJpZrpeuGWW9viZ3PTuBhgidjPbbv1n447t1WefliEoPYkSnChtkUiGRVzJhGM/Jtn2njopfrwXDwob2aSjDhYkXUEuEpvgnGDhwK4iwH//MvfNcFV02rx0gktnCvW/XKpoHD/mbuaaWphjR1JGWi1ncZZDcbByC511hKtYQ6C+PKXICJT9Wp7Mqw47uJ7TeCs1DwijATIquHSWXd2n6L9tkVyYGBK5xJdXJgQPrJdNI2wOsvtBosqiWc9Pg7vQAGioYkGRwEl6/uhHGwpjMy8fDraIduewDnHe/CbxFpUiL8yDk24PcrcWfUDYUGjRGsxy0j+zIwuLOE/XBy9hsJy8YyHjD5+i/5rz24QqKbuA3JWA3zeOq45dCUovg2PIuhD4BAH9MUIvETjtgJiO7oAS0E3RNj34ng6B6aHLgGwBQ95dj0EijVt8q7Fr2xI1ShSAdUw4Vt/B7RQrkAFhPxUaYCucbNpO91AK3+khs69Ef5uVHG15ochM/lW0NhSXT1VNCETDkuZ6EslNjP6B+O9SVdKxtiq6PD/GqFodP1OZHExy25Zh7H912JacLfPRp4JZDn6heyv4GUnK3Tw2auLrbH+LR/UV2SqeaZcu5ucmwmSkBRQrJlXsqmvHU5okJY655eRUAOC6DsyWhcqt6swbRgoyhkgZKgmpfAbIcnxvrvgWkTJkKp1jbUnYlc6ghU7Scuv591r2bqZuZgU2oMOwv88N3JKlfog9kueO5LlEpkjI8VtwS+3wOpze3kwQL6TtWd7AFmP2wxHUXcFuog0PtIu1UWkQ3U6c4MTm+LCtAsZ6afwnQ+69TnoNEWuL8nkgk4lD6oJjhBjYGoy4dkr8Vn6dzLFnASmJnjbw9kdnK4kB88pB/fSOdGSSOtV+XgXHRPzL97WTAPpQQXk/4HQcIPB5v2w5PhnhUcbrgbkgIE6BCzt0zFokyW3esLTtFwBTwzMZ04bzia1VdhWzj7bPMXiu1CGsyCjMAUebHFlnIVdU6xn4aTEOFJipDUy4R9VRqUpjn1i6le4kwL9o27mMnkNNKhsGrTkirEF+8c+y35KgWd9/GExNcnogIC454YKi2EBY/NGCf7GVFEoITwmGA4Btq6xKow+1Rr30dLWGZxODjQGh7mrQPbRVgEXzAX2Smug4Kid137OOpFe30o8nou82aXpybeNDegdGIKLydax17PW7Uh1FFm/HUQOqECfnfg/37r6OjbX6zG8QxWXojSL+766/QoG9yWgXu7eAwS54VAaFmcYhHSTFAMfrEPtLp+uTIoslyy2GlkiiXNbQ17hP4qigqdx3n7Pot5L24aDXki+2BYy+cDqdBMEouEVBC9dj0vD6ko1BHf4tFImVn97Ei3ZOi13Vw7a2gohGOPp+MYz+/jGTSwx+rYTizk5qjIXwW26ZFftRBppWkz4V1XmfXWBuyUtAw57o+iNXeDaJIno93bEYe8qAInRa0uHc2nK7V5ep5MmQ/BTrjqkyRQ1HVgoxCwRdi9GZFNmcaRKAZzq6QJTzE4kiHZ5AuV/hmcBMwuK08Om1f+QGXII8P/biJqPipOxDHHF++FVKavhBvDbXRplzttdsXaCpLH4LzeCG6Jc4j2YT5woCKiwIZ/njKtwaurjlRrv5YPTEkoCD8IIlJ4s8tx19Nj6iYv+Cz0npQLHzbxbfNYIoUHz5yTFPKJjasoKkni+COvvA6sKXfZdome+dnT+Jf5SyhBcJ4TKa4LjEQZiB+KR0Vzh9zp1AdY64xPw0EyOY0a9Wg1P2teSKlN6d3dcZpxwaXD6b/Oyc3DbOGHFRmbdb+ww9tOxmd7Ub/UlLZu1I1ByB2iG2+AwikqwfvH7ducR1SJmXnmzq9eli1CwN1xcrP6zGpzP5zZXi9fn7snKFNPW+qFoXdlV6zfEVQfLx5sH8yS6uJxB7k3yP+PL19BQgnMvc+T3IqCMx7BehYp5a4ElWfgVOzmlxWGOSgtbZVZS1GGF1IneJ1lyxvV0VTGLIbb7n142auslEtnN5BvXj+2ZCKxDzs0HHuEEydmVwAHbzhue5jjn8seQihD2Qx8826yw2lnnmELXD7VUkh+sV9IUmZXeBZZ+LohCCrKLfUE0knU3t7KzHB9LneeDGv5oV8g1+twYwwPYr1VC/+Wvt8RJwaZ/6PIPvYIfdN32CDIHvurXIQoclrtUZ6IHeEfkn+OvbpLQeCxU4lXUBaTHIyKaK5O+eAcDsps4UoM63xjjUwAOsypqfLlqSdIzFB47KaCwbajJq9XWx1SpZQEuXwVyZ5GBbLmq9KwUqWpk88yx9i+5M/9X7XBQQyfVuUVyuzRVgPHB7PJUO95AWJAI3TuecKmaEfUIG/XyraF+BxVOJDMT7DjCpYyz0VBLlM2m01l+VInVtFeWSP2Rk+kQAYY4sBpN3JoMgMXFPJNk2qvVUdFU5U9qW1uaSwOApfYwvcV8hRxh4RlY+fqSk4zug3pPfNGhLBEzpvPHveQjlmdP94gWXDYntIoiDWoWyOI02SE+pNnd/Cq6uENLqbpHGg/BfMZfFbUhsaNfSvUDenSjZ8e1jjSvY9n1lyUlmpHJXqBrKHWiY1Isb8jjFEhxPM+iRvKPxKXmy0AGsySTvqyOhb+1vUTwaWZkb1+Prniwxym6vzVYIN/5BG6emNxBWPq/0e+wimNeWrGuievcXKjKl+XA4zsUQEMYySmvx6smexL4luAmFA6APY5OHneKiF+IPRHkEluInQcJD5KVoQaupD2q4ADUAnz9b3VolbbOE7fPi4egYoWCOHOhZjFNRBijmPmA0LYoz9pcx7c6EUml9X8B9A7oMeYhsLr+XzMhtVIp9up6VJfGpRmyE3WDfM/Ow8iyEeAEMXqEj1clenUqQmbyAcXNU8DiIc1hP/TN72zfOfoTtWh26aYFz+TJc9fLzH8arFuCZgYxhIDQhNJt15lCvI10RlHG1XFjQfodllxt9CMQzr0S2zUUy9HntyEBaSHEnYpgMEibTHY0UWKZ9UTYdDhVtxHic7JYyo92jPy10EpktMFcj7wO109pq9W1FpOOlzf06i7GyYPovyXnH48pENx45uFls/q/MmYunvvSzFg34UGcLQADKiWWWhkOlQ8bVnjQK31M0vd67qD3GV1HAYUQopMQzXfLRGJcxt6qUE+wemSB/zW5KZGIlKJFFo3s/FY9xo/LJP573jXax5uRjidj775Ab2Ru/48PtCgSIEr20C+u3Gbj5/GNljASRe1tMKSl9R796ftFnZjdS5zswWaraHHb6G87I4FAQEu7UXEyY5OFQrrJx3Pe6dmS3y3L/JunnOwTsRaKUgmK4jpJiZM6no/rrbdeGpAHOXHHs4m3wsSl8rYtZl2HQh3PyJkK3eUAsriT5KQPSyReAdaFQ9xQvKGAKzemXQCsb9N2qiAp2G2l+T+aFGNbxKoagnxAfUhQzJCdgx2C6GUdnzEZ4O5NnF3dbbuC9unvKRKJrg/ZED4j2P39UoVfoAeIK7VzQbVjKhXpvSn3Cyc9A2Jtw80ZTihWt3gITRvzAobvdGPE4LeQsQNSAsCcZTjcSi1e8GqG0GCj5RPYdFu8t81j0NvpBFyT+y+ayBVWHUnidMUK2sZuOVHexGfQf7gk7baNbH1ej1u1BdW7qoidvR3wIuYC/5ImnwN8kgzHWmpbac5ZlsybjKmYHHIJ3Zda4seBhqtE1qEmEDONkEbjZobVCeHLGSntaCgHzaGEzLOKW3eLnBLkR6UKfVCCwpqHPB3PQ3Oqi7wIfnK8SDGjbsSM+KB17yznPUOaCIDBBXISwKY/wMqzkL56Ij+aGhegYS6vXK9cCQluVcvOjn+Y4t2tX63SPfPtsZcMqEGjcCCo2I2T+/sYs9zfh/mudBW1vl2nKmt7bx9nzl8YXPeaBKS6NB+yojkc2ENzB+nwIStgPrBDgc+I/qzww+uxB/JgN2JVHG3PlsGVyxpNUEYKIMOMKTrmkud3poP12Pdcpi8viU2gBwRfJRT1ew9+4xVJO4UrFpFzaHU7vjlGf9Zg+d/VGF/2xfFn84E+v0pwp+gU3EvEtfqyfPpwf4Vvp+A1L4LutcxMm6TkW3XUIYXBMFwg3uAP5uW9lkllov84e6lYbKiMi8DzCS2Qu7A93tfzWHXqktGNugpdiVjzWa2dfBeS8K3TG8QiAaqj3ptrddIr9TcG3kajqH3PkKm/RKgwktg9O+9ybpQFfp+g/s2VBxMt2x+R0npbkdv1z1SdreaTdt2hxGahtydAYWCDBmpogz0zQBDuEhlz6Y7MukDDUWiKgOOQ8d9duk47dl0paI42c8Lwf800VVS3sT2iLM8+vAnCEKLzpLqNIiVjlfqgF7XI88OauFQ+wC5pDh+93j/vqe1AD+n+1x1egMIZMriutMHdCGym/DGIZ0nRcjv7hHU32ruqDgGV7r4yFmxZU2dkkt969YREuLef9NOKZc8BFyx0NG/NYZlsh0ge7g56NX5/agfVcnsgJ8o4OLF4aleU6TOyxkFftRVxzlVM+1ywj0hoWOV1+rFZsnDjW6VlHYvAQ8gVzN6xAllZtf7ShGgR1lTnfrUojO9T9g/ygZBGc2s0lXYupffkj64UUxC7BlAatjknbKQ8wPib7eNnv0ijyOISZ9DB0MY6BAGQtEAb3h50rL5pCT7XuaZLtJMIJR+DjOGKnN+pRxMGauvpSSqyNDnDYHoCKFPOzCdA9QPniTKcUXAYOKT9mxGMKmSHurRyM6NLvOu5f4jMryNvHLyP12+d+ZZ7+QEwdwjm9ZMKua0LH3/bsnME5F7w9ojHO2Mjob+T+4r2HG0bA98U+MqgjEiGWaiJZASJ6om3aVyqaV3sSOLIaUV8ZuLjkf1CwTRqmxT07nImNF2C9If9MFXCZoM+qNPXSUQGgkaYgqZG0czbNicvePjEosYkWysXjl9QyhD5YmSmCWaKSLyB6Gj7FttU0eskzgH2D3NRhFshSgeB2DR4tuOK3FLpNPXqCMked3vVJvsMuZw+79Cp//LbaWhzj7/NdlYG5S0/q2jSjjhNlGIu2Qj+9q4XuoaV03kOJ6fz0mZ52zhptoWz/Ss1hlKDfYX9XQgR9iva0e4U6WG4SKOvP1pEJddJUhAGQe4+aiXBavW5D9DkfHbhHp5jHBEZ80DAQaFzYUi5k0Zx4ha4AOfJ0yLWwqJJaBby1ffw/xM9okDVNJhF3Jrsf3vasUCFWgBhYNEYUz9OnQle6qmSHeY9zSdxEdUDjvlyDaNPJ8Slkv4IPoIo3LCg48nM+egkjcI3YssnU7WZLqdWKsHeLiObtB82y+JG1TCDdJEjBOt2QFoUrdv0IRxchPAZ7TvwGuewV8FNhQyKpuj16unXme2OzBsWjMSIjEgawfradMmWhdi72i7j2J4LtrDG49FN8LciZ2fuvmoark89yQiTgjt8ztCARV2tH3RsRudvJ/xre2U+i5Nt0EHrbWNlb7EX7qqWkjQHtt3D6CUOwoDqH0uNMUmJKbScbYQh43QrjDVjWIJYhQ0Vgasff7KGc80e6f2pjFVKfM+nsai44r+bSs2IHv84z/cknSKBFaoYJB5biXlNw+uBL8eJrXjO+vAACTsgISBi4w36nE0dBSWIm4yTBUUFo58FC8xv7B5TCk6Lo6Blr47A+53a1atrF185KQNgomJcGMTp1ekI8ky9cPLmvf8z3Q0hLbsA0tnQ80pcnV+TOjdJx6FoTvBzQAlaY8msQx0N5hcCPlC48un0CQsSYXpQAPmT69C3MCezVMNCkNEiRn6ET2cnjmC8qiePGN3nBJsOz0sweUyW6vFBPrrWHjnsiFp4i7pEZWz3q+r08aAJQ32lyIqhI/hGe3KmsTSr0+vyB9kgfUN858Xr08mjQ+mz6ReSuqR5o63/GpDSShppFIVmqbObVByO+jSAaftzMap4t2dFoOsuilunkZqw+E3viDlIkrgz5JjgXYBVJtfVT1xo0qxIY2G0kfOG3b0Wf5OgHFOcIUEO3+VgirBcIw6cfafgCy1jKRvgMtVlSmJCK60KuaT3+Va+u5/Stj0HO9jX8I0U1f6Hy6Xb4ypK2EeivGYOiQ29TDVQfWGAKRSZEYuDdkaEkHY5i2MNSfF9NhosoxE9wAxvipM4A1xPdXkhOulZC0YvkA3QS+ZS4fUZOm5IJg8diHCP2L7QUKVSOLTiP/6RLjqF7pVXNicc7laOOvqewA5abwwC3bcOIHobkUqqstPQzkqnlgd2PagS495GJoEz1BpdS/TsYdMe6LlvbMvNkBP+tBP6ytdn75jiod30hruEuOACNwyPBF8SmXFk2oXRzOrpJZA3713ezPRfBGkkp6TxcU44MG5nqTH1u76OcA0H60lpb1KsPXP+3rrllnWmd6PSdPexzA0XfsqtymJKfoTVeppScJvBVhBpnSXVF56+37P63MPnzzmJRnFd2a5150BVop2U2WjOrkpNnFLMnkXGmYk5L9bumOHHtzO2O66WLBS3HWxq/DClMztdmAEN1RIzLr7TX2tpLyJ/70Yxjcc6QGTrGNboR4E/tTpkGAAylWpgHkwxuoiAltQNg774vyNC0GpFiH+a2nsj/FzXw7O/QBThyhK2ajd3Hd9yk95HgbMNnqdE9mjXumxrSKHlRqAfC5K4wV4sphPckPQg0afbj27GEFq0Zg4GfjTtcmq5Py2fth2Z87uD6kRNwo4uZTRQ2whnNNUm6S173HqJJMPCcdj7HCXHR87prHj8VUSltq6HLcBuFI6rUpJm2QZuWXo+Q5uYvDIj58gN0yTUKMSuqbWrN24CE8UA/IXknlJi7PFzD8+NEvshAQDCyniEUknxvg0KsU66/vbfsVkKDrr4SMYwZlsNO/VRl+DTTEczExH7Fb3X636pveP1fomQygf5JF1TNK/AAKkexCE8ddkfT9CB9LAsGl16Pfe2urhXEJEDFqf5Bo6X6DrYYmXrRnYccRS8AXAK12UiwwciG6cIYDZXWsKDrdmblLg8sYd55oXhvyqGWkdtpWn4vitAPMwdG6gBDas+WJdIyf03XoTSwOh1t62endqXzeUuGr41pcfqfAVi4pQL8fgu7h7W9vwCfvovR6afWY6Unx/2cz2SYj5+3cr2ex2c05SjiuaMI5qJdwkXuFeBUzyMNpCWjpX5C1NfXlDEN7Qog0uK3G3Cj6XdKqwXESd/tftqPCTM68HFyk42a2GhqVizkaJTbLvNwxOK6wDExfRPPr+dIBuyT9WKTaxDTDDW+nv3yRpGrF2pmLmWmKKH54H0FIUNdtKb5II6V3msk5cZouQWNmpS/ILH8l6B/zD0ngUuA7YoaI9uGb51MHgxDfCcSPLJ6nUREySVkN1BX82El4mnOZZn1Xr9DriK6ahXf4VfYQEaiqWt6yOGFHAF6QRIfNeAe6uroP1C8uWrEEhoAutduY5PuP0Leesl1seZhx8rhCmmgKcFytAG4PLc9wolyDelQhPYKXrZLLyLErxZgYQCQYBwvBQTLOcxkAuaFxr607RW4mOArMxWm7GO3dC9kJ0lj+9pqYrbUs9j5GM34vDN/YDAUbR7/ZoWRs2cSl+C7tlXzPg0vpThIN0gebeI7fwRh1Huig1cqxZuEgon37LMnhz70VKbwklsGIjpzcPssboSruAAFFt7FqmLaJZkmiT4YLlgzGQdxFiFBAuKw5CtE0+hyirb8a8GCy4iXwGjJCHbCnGrVHQgylBZyF+5DLPc4dQ9UtehzMH9wIMbP+21MyxiwvOoSTQOnjd5fn4DseBPbWTlt0mbo06xLNN+ZG9u3ciuyDUjI0tiNNwezHENX8fPzhnSzePAC1rBZEBJj5lGubSbBKhnpCrwWcdN7mG6kbPq31tY4gTOO102dCoN/dbek9xvq64FYlZGyDczBBVAoe6SmqWvzJt3CKLcQ+Ipm1AXxDaBgHwW3eh8r3LTuBJTVf+VbpBTrWPJ2uRccWFpo0uimNSwXZGDWZaE3+C5YhGzfpf5oZ5eKZFDI61c7lhDQ7gBYvoBNSdfVXhshR5ECeHLJIzgrtBYc9iaLbnfzExWtIDsrcxUhjLgZmdXqfSX6P9eut5Fvos5uV55QZM1A6lpZqV72d38pXAuOsf0twP0b1rQ3sD6DRDKVbIkcsBQtPNQCGKQKYhG/G4cInqzEjUrZhFson3Zo2AMgBelCZKHuJYVy2Yqx4akWVNQUpic7E3ZB3PoxyAz1TA6pQ/oWpN0uuVsgn+SZQrOv/PuTzs0ehGokPOK3vNMMO09ucvRMQo3zYXwRytsm4sx2lL/rVaT3CgL7TOcxaCOOPROtAdr/3PLT5GuhZ3YpAa5thCQQncZabYgG9W3SEzdHwlq7lkBAXa/91ur1HBdTeyvw9zLtBD04YOWBZW0zEAkLCSB8+L7QYxWETzqyuhSLY61Nxg9Y5hiya3S9l37DbWf2IJA0sdDgxgMDsjGFacmxApK3kI1Su/4KrkPIHQNncvbzx+EzDWWcG1wFWXRwjRVXvCF7h3VOqWwtU+IAYKKSOylOA2+tHXgCECckT1PCWwuWK8qXS1K9scVnIABT2nCpg8M96Ls0/4l6W1k8IGfDkN990WU7WZ4bcBdx+EXwEW6jkZiMCvZnR01vaHQ7CxMbmgg7o4MgmAxFS58P51ZxD+cWTsLM+QmnwI9KoLgEtS1GvN0/k+EY9zMDxs79hoaYjxaUKuhufWZZst3khDfZAR0M3grz4fWBhcji+jFdmdHbBraHWm4bslU6Yyi7+KqNMeL24GqGWGosd9/oh2k/1LdUKq8cx8I7LLnRmnSCqc63vmlWURK/J++EKIWi3YMVOwA/Dt4+shIinUBSxMHOEwlE04Fl4yVnf2uGqXNgV2DfSerdaA4t1859zg0DEVopStMyx4k6LHwlQ5WhfIBjyNmZY5uyR5o7hEGfsniI6DVuOhdPsHMGI1EPl9MM3mZWadEnCgHUNWDevRjTOeL7W2bAPmZIYIIObKPWt+w3Pe75I/7j4acHYju6iZr7uvLCg6XnJPoa/mULeZpBWOkpT1+I4bdH9K6BhNY4MmekalPlvw1g91dgbWNAdGRrop6noZIYMmnJBv5nY2Kjf/Da41J5qNaBxn0ZLhMkxLm+Kksi208gHnN49jLqIu4s/uTw1WUt780O3xxxQBsXsiTo0MG/Hz9HZ2CA+BopO1o0yjM1jvH3u4lYWaJHvCvl78mN0twyRZpDOAZuq4KA2VMh8740XUeP3yo+VS5Z0Ld5fh09QIEyMafyOtwhBONXMhRr3O1S4sSeVMe3lD6foEndzXJZfR0MU6jYNMny5erbPkwVLxNK6dOyidk497NhE3LrDHeZLpynxjASO5F2N3rrTXO4cGdXT0QBo24/jChCR9+4fXN1UYkDm46zlGPfI1/bXmF4ir3ZzouMXWjYLkqTuss8di0MhyDaoaAqUltrfggy8pLaR83uv3qANHGpethL1GXRDKf6OwG7SMaSCUKO6NwrlKwMsu2jn8Dm96q5k9lorGVsC0PWvMzj0k9EAmkykfcTxH7mezvf3yaNE4HbqFBUejDu160mzVCT0x+wlMVjm2DwCirxnm89Si2xpSqSqkK2zBUNCnqEWgKZlrQNdPSL3yf9tEvhlAVkZUYBwhtXwBLzgrA1w3HhNIkK6edVRxYbKdeFJbFQCQ5/G9hdsUpRHZW8J5tkYPUbixsA7JxS1UPApNgXPZWyi1BggFxaX4isqs4r1r4RgNgJr+MxpAbEI03LSXNz4LseVp+QZQpIq4alCHBomRG0U/DmVXNqNM+zEQft51vB3PIN1Q7KSbmlS4l3KMramkot/K2NVzg7witOlwwMmS55tqO164vqBoeoMp4TaQ8IBOPAUwbTxc14WNQjSZ2dXfjYBTkE6KUtaMgVo3pdwKypwXQrDA8EjoLFeeh+qTQzUkd+PXXeKnlaW48FFZz61rNJQvkljlrPfPC+iwIPscD4LXR/CDPaWUqNO9xVTPBkdAGmzKZNr0pU2Edx7C1xDuclV/FUA70JxJmkDh9cfSdpo96VeepPw20at2njdh8L7Unxl4tMTUC2xcF2zE0mhfNvKK3IlbuthUCAvJvhNy+r85Re4cv0wNIHhS1+u057QyDbI4CR10tUrF0hogjIV935+5n55g7lcbn6zfuXZxYKVgdm482ibd6pdwJgDjEQICXGd1PuzCqjCgNFMHESfdLDe5n7oF/fjiUtGXt6TkkzhISPlL+uMxqo5bqJXorzRh191Icn+SFtpfmV9pmN86jy3rlPf4k7zxazYYzb955dfEzWpTVhHL3UgE5mZbaekzVRwCN7m9cpmjMwGJR0Iyk8DaSw3jk//8si7o+N+TuJJgsuyogmP+5sycWwBJnNcwrsCjk3P8jieXE/ZrjsDKLtUnBA+rnlCkBHXcyl09N9E2uWab94TdBGpJ/oEC/nkQ7u5gjAO93tGY88+nDNQcp9Z/7SKs4/l351B4q/36Fvj7DhulTYaT6BL7sq4nriRtUZkD5UVOvbNxB+fS8JVv9tgEIMpwTAFEvqrwW0nUSk06zvg60R3h4f9yEkQtJOfbnSLUDh0vJG8oLYFEXR3bUkLPE7moT/KYvJsypXqgGU4ie+F5vn1G0GzOChusB5jktFpGcA5Y7zUcOT9VIugkc/CRIBz9M7rfreSq1KtcbvwSdl4/B8DVcWyn7U6Uufxb0NxCt00Lh00g9ryokLNAo6b/JBZ7O4tOb+oMyMr0eQW8g9IdnaI/HlPchE2E9Y2ey11OWI3hU8Cy5RnmSMNdRttXbKF0chM3AtzHi/I2ZqGGMXLrEEJLjDcLODFghRWI7WcRcYGE09RkaX0dIaMlf/todCITrH//0rXu6tPlEx7sQsWJ+tLTismFCrzT2hztawexELNE2PZlUIW8035fgfb36ZdcQslGLiach3g0oVWRg0/fZjgxQHOV0+9bCFmO2lLnWmd4p4GJWshdRD0ngpWuB45xBOP3PYfpQfmY+J7+8tkNeZhRrk24lTNC0gKzTHH3Bso3mYheeALPKVKlp3Sy63yb3YfNRDcMsBz3X/A89wP15hceBMYnfwNYSXlWbnQz3NjyJYeQY+sq5gS57CRq30+3egdJD5j2QygTvDz4j3drhWb4ERdoK10J8TcMuke+Z3VKr4KN2bMzzpqNfecIFn9gw4jPwwZvR5i0bcIHOFW6pFsH8qodRxWuPmHGnrPzX9K7aslrFZ+Jx6EtnGUnr51BKvMdtUuS8vRf/scFggTlEqLntj3RCwkj/ogpPACPxaRdbdKHzSdo0RFPgLerOmeDM2Km0pICnxHUlB/rjkKmPml+fmHjhfZQRmEusps2o4GH98FcVL4Eq785pTcXVN0zr83DOp56INkrQy3hGJ6D9F7b+e2pD6RpFcikhgQiOxqJfr7v/uvKrj5FNIbaM+ol5/XF0qGeOpSCgV442/27Mb5aGu3O3267fbfDZTMLBhukJb9l1q0rrNnJcP1Y/G+RKAk51QFJc/sK3qbjpdH9mkIeKDctl9uh2EGi8yJlGX68zPpXrRZrksiN9t8xxp/2B5l80OWenkEn2P+8ItUFSC6+ozQNFwiyV2+luLL9QX2ZHvXkQqSDKth6VqsjJ8ivkigwmGwqD3ihxUIzc+74LhrqKzWr+aH2iPuva3/q5bQnaWpjIiNo9iIQCC6PDnswJSKEVzWHbIVRNfO95XKb8ZKRihypjKIFfTJA6BK1JlhAmrZAz9A8GyylK9CaaQcwb3yatOO5gBCWwdPLsP//vpwo4ADHKt+YZxRxiv5mckPvP0RtUiYzGMBnguWWTR7BCyygOZvcefh/g8/ucNxt2LRQf5Du3HNNcsj+Lwkrn8wcvfSWAKj71BZOx6d+/9QXvVX3jbMUUsPrpdQEdKDjD4PoZtAu6ch2w99HR+fcaedrVpLg4qnY9HL1YQy3SBjJgOe89V53PXS9HG+he7feQbiDQDdWINx4Mlqchp0vJhynN0fxmT6Qg0BLRnnqgQoS3lLQ9wKmTuiZd9xVusIgDwpszC+uLk7T/m96Xu7udH0/7pIuFyEgtIgz0ne9IqnzIzlCyGfEmPGw9Uf/Y4/TLZ5uj7PwClu9q39eQn6nDuTxHNOWY3XMVcNbjYFrMsl7Ey4ZXpsaqC5rTcd44zjsfrKkxh38fY1m6sHN4dKXHcburKlx64vTjyOkyLFxR4CG+mj/hxUXk3oK3M/tAjXeY/sWJiEWZppjojkttMNqvKZDlc0y7plH4fwFTA6AlK5J1eRpNfrKVq6x3dAdzbnSA1l1g5NiUkWR5wD85aZPDkFH+wK0Et3PsfKFamIkuUgbmrGh87eGD3m4FEV5W+7Z4vnkz9xYn6h3kmLGD/Dmaa3yp60ZBhnRAwIDl2erCvNEEHDaJbHox30gV6IRBXi0/w/4XDqMHLX3YKmlUoGW78cCG32YZLOChbGGRBZZ0hJz1mKLk15/o8Sk5Lfo2qPXY4yM975j6btlXhSGo+HhH362aWyx6ETmsqphi+5iY2cW/yJscyohjaEeHw/uqzP3L/C/4N/v5DFBc4/dvqqesyDVOZaioq7SrffxUjUvT0Ba3XtXhFWgPzje1AxqZnh8btlnA8C0T/U8pjlvr86EoknvX90yhKktp0/7Z7KNPKrFbSZNhTbWeE0R/llIC3c9ZX+UUoPFutx2aVX2/6i8efoPMY48+KOZ0G3I/NKD9iXgAGe4GIff2YLZnSIPG0sMCPQFD0w9cxiJ8HA3vsU8ZxdCfrnY5w0rtEqaUxI1jcbdBeeA5bDUEQi2qED2WrBFyqjRlYI8ZR3jxk58/iuNVQ7qcvgaC+5Viv9sB0t4TLP7rmMr7sYBpkJ6NFLOHP5ndglMZ1eTkqlHhA07H1oNqJ9l6+zBckxCKAzLJvzYhicfZ4nNhOwcdt786wfcGoQjgyQJTu3IvfPEBu/h4ZEOTaGPAS3WKPfbFL3DNyimPiBXTKXBLXkZwZ3m/ATkBebXbtItKdmCl+F30KF1dRQaRGSduzBH3oouDBow52cs5stgauc5h5SqboEqe/cQEFlQWnWNOteWPspx4e0EykCZYqLkSbbUKVVLjEOV5qTCLtBHa/xF+bNwwiIzQemDpuMILR8+Szv0VFeizk1uNsADMECQ5Ed1gi7TK445O7q6YAzA/Ke/44N4mWyEWfphbkPYrFmacDj6HkVf4cs4syPlRDP7tXPoI8Q5TJNl2dr70f0v4luEK92l1tRBoZNEfEw5+f3983+66L8umtXZs71pxVRfGLM674GvW8j78Adb6FsljOm0+J0dF32aLMr/pZGPjPSJ210z1aroipNHi11/xqVaUBJBFJHSA8yoqQNFJ582tZJXYMsTysj5uf04mdWYBYalMCS5gE/n0z/CkUJ3xHv5GqI54NRMMk6zBYCxiOh+NYLeLdwdTYlPdJXPATb6x3UC0cU1jcI/7kKUoF0QHWQyEu9JhyUHDKbS+8eCMu8Y5j0p4g5fsneDc4Y7vozDi8zcabrH/F6TD6tpuEdfMfvdvOawvYAH9euDThQBNt45yQRb17v6FupIfK2ygeoTSq5yu8zx+EHeY54dQmQUlxKdkWput6YolWttzZM4DRnaLn3MEaTurym9o1vaNMp2E26YdAwUd3SSumMybF6PxNPxPfvWSw3h08+AYJI7SFjn58hC56yH5mKP1WNRSW5CLccIzvUdygdKv1JuDL9FasFHRBRwsVo3WKF6UWOtR1AChELjtVevkh9K/+g0RhN9syP6xDJ/M6rG4FJSdAPa1l6jK2xYaR3aw4+87nFECcbpt5r4w2Xbkrgi/r7CR0nP3eJP8LfX+eBOD6DLxotuV2lF8/RJG7BrXRZXI8WXDBGd6PDboV57kAZAhobpydnuhB+yN24sdCeGtKtvYEO4D+Z9ihrbi3IOSJM8YXRCuAqZG1x6UyyzVbNC1/lhMCvnmDP9PAy30lTkEX5G3J7c+n+EQgiiFZV3M9GAVVl8JBaCJLNVX/vendwqQP0eoVUYzhpdFd9GEoT3Z3alfrq9igu5MAoC8NjVGzO0/YSuvZJ50et+YVxKMXPjFanr48eN8q/l362qXZPQ8WvAnHXz2ft/DSEi4P7YcJStnkSLKnJIeFDcq3CgmP+uonBd4+xo3VIqBJIUVmurJfYPx7MnsGLLFRoFtbtpebdWEWYXGlqwc5+l4TCyGFfbtEG1IEsU4g/Hu/LYSKK8NnzZ715RcYz2L3HiNzPo/N+dzvkrCDPzJ0l4cJQLjrLtC+Fqwh6WAmkPVKf1uHAxPhm6uSQedkWopB3WqpicbiBPopux7cpDu1Kp/AtTyDnVxBkF0vaztiHE3KGeIMCWmUYOINy8lOExsxvmB8Pvp7VYdFUGTNarh5H2phEvJzZod9hfH82Y94o4ELXXg2Fan6SysVkR7lLQXb2hV8F/UBlEWAKXK1zfdpMSHLTYs5cob3RRzzMM7XUXC+pv7SOUL9ttnmcn/3uogMOYDM6mJd++DN4rUpuWOokn8kiTtcjB7gb3MVhM9+CQiOyin+cyrajad/F0XhLApGUd3MwXAFRYM1JIPr2iP2NjKFFS2EA4M7MBClr4qMp7AU5m5iBc8gahtjkY9rUQzx9SG4Ag7LtiP6xwifQkIDJC0cDlqJcEH949hwSthcaGD3PhHleEyfo+Z4j6YHjL4tG1fqrExM+YQO6/wpEpDKMUIJunCqjLmxYlz5RNGMYhw4hZfBsmN7YDfsVAD/0S5C+nwF1aEZobCahlUUiP/NuinSk2RwiXOvmsm4cj+APpt4tJOU7X8huV3s42alGvqQ9qh1FdAQ/zTmdw5V/FZ48+1V2rFw2oBsqzaHxXGT96Aj2sWHdNaQlWAhR+bIzxHrTfX/48kl3uGb3xO/w1B24/0daMfBCmA1AuSsrvbGBf2hrWarELz0s33Lr7Ryt+raMTLER+tO0zOLDpfY7m3NJVRnfknCmGm8k7gxyqDDVO7b9cuZi34i7w7vIo2p3t+Fg3YDnSFcHxrHxaVA5d8eeZ22oacN4aJDKftAAs3vB2kEDvp3e28r+R4aEzUCw2FXDt4giiPKTx/Vs6dtr5avehD/sMFk2axq33u5Bd3Crc3ZgmzaV7/IJhQNJlg0LSN7CJ77sDzwgM+L6IoxdtDctGNBs+tzj5S5psfhLt4wmeJbM5nOKk1282Q0O5Rebf4fU03SMekxRfkWspw3PX7dJ46gZVR0DVmPWnX5r8Tw3XeKby1fG+d4aiwzr914m6SyGbKEDR1LRR0W7cELOjQOXsMK3UcTpcF2n6SDUwKyxeIVxSYfMJKEF4Hpef4QbCGdSWgQadkfzi/i8YzJprIWZdmZ3SZxdxeTYe08r4Yu1jSsO9ZVfWGznK2nl2JWIblLsZZXgUx9SEJXHR4Ljmis8yjO06m+9k4SuECe59ugIHH0bRr8xK14GXDUqaRo8A1wWjB0KgpI8/bRgc/a63r+eVAY7tQu35lZ52EaZWfpW2wDI/p3SGYF2T3o5Cl5dyqDATwNEBgUyV9lqZgnrd+bbubUakI+OGnPPH7b/Ys+fyvJ4T3tmFuMA0k7F0irwB3t/GwdFlEYxAXYr5A3mAg9Gdxy4N6q8t0/XJNCj4cbhesknB3jDPiti5ABlGOLIGf+tuFj4roeuaMJ9etlrZINgWSqL1JEAbuRLEHJyXZb4MZTCoTkymBnazBxFf2DhJIkORXKAsnVlDxhBgpfo/gufpW0Lo2CKWmZX+Vs26Q2+ahdNvTGD7qRH+8hhgwGMLHr5T4mYXJPf9NnljjA8AfekaplFawL8qlHYosiiL876daNLjoKTdSOxajRkfeFs4zV4xEfGCsLa73KktTiw+RrsPyAhOEHuq3oSlhUncP+LhjoBBtDShiHTOkdBwLkCjxPQR1orQmBDjSGDRdzcp6AT7fNXgh9FDsUW65S3vFrDW7yLNuzUKDgpYlWc2UKDlcGZlLForPvr1ZPwpmtXogQCOZOwmnTz7GsQbEyIVgC1Vro7bv8pjP/UgemoBUj7WjBaruuvIpnDQBQ3B8FLDk3Jvdjoj8eDuFOWC0n5pk4Ow3xPDxFbuaK9xhXOuEAXi81zYNv25vqlPHjwEmdw42U3pNTaOK+5GZATGsHSfBgE0F4x4wXHWFy2zWgu6NHnEv9WkpwEkh2OZQDvm7uhG6qFDbC33ULDmY3vDQ7r/Noa216mtAsTAvPisT8Fgl1oH1BqUy6tjdmQHKV1nZLCNHsTCf0XF/EoRLsHK5mcwjQr4FqdJYW3Wau141luD9UbPsevet4JnbAPB8bAWbuRLCm7/tLR/EyXWTHV9nBhcrtKDdRb8Qp+cq8TGgIBMZW6Glp1Fgnu1UqNwhWIwLGYQIF0yteDP54C7G/oDl39PKEqAGth1/6102GsGAQcAI+23SQTbRFot2qDeKHPJutZY5so4tgA/C1lwa2KdoQU1rlUFKKdVVNpCenARUAMug4FhSoRglF19YoA8YdjX/cvRDirj5F3R21yoN5QT8I07stHtJw8dFziMaH7qE8KR3JioPFwyCnEXx1gEWqWul9svFJLiOW0C9zeoBPZAVNwslPZqrcJs7xz0Xdb2t7nAeP9ULuBwWL/IMBvdjpurX1rKUobEOzHRTICq8PpGOYhtWnr/kZd47hY6sqP6ooHIMiSIEzILP1YLKjfzvMiuMM0xIFj/TTwtNN2aKAR4DU6QTplpjBkplkPvQN5E9VeLxfk1Ym8wVZJsI1ebRpn5gAxXlB6kNYuaJoe61J0jeK6yKIXcsFlw80j8d2S8LMy79KIOH07oSO3xdBpInY/CQl+k49UYiHZ+W2XaEFZB4uarqgwBlPXWJ1e+Yd6LyuNUH1pMUWe9ENbhkCXqEWl8u4bWX1g753BYKBPwQIGktcXO+/OBBg5gND0syjBapOXYcKs6Phgwhv+PUiNlYCnNitqxuzzjmtJDDl9baRLZtw0czNm/mCCATvnPC0yNP+FjyD046+7h4zL/VdHCzsnjyP+nYRFmZRQTmZZMFfheC4UeBtQtLU0gui1UcO/S1nSy3bt43mds7TigpGwHXTrLEvZUnMLpoM6V517rQoTti8yFaagvy+obu8rcChGTi6NF1yRYwXLdbWPJIRi/YecHChp8rN/y/09wRHCzFVYZSOrW9ZMcs06Ch+PiYY6o5avZ7DqoIbAxc3nNVxDT2OuhswCIi15O8a3bbGXqXMqqhRroUWopZi0A0eVY04ViS09DGEIvUlZa77iUK2gCgo/lodhXN4Uj/0Q5bJrbWK+2CM+kqOLMOLlQuXXt1J6fnxRImSb66tZlniE0X1UjA98OOYR8cjVbSZwMUQEiBb5kb95eloVA2JZq7sEtt1O4EAJcPXc27ifkOVw1pqBaLKgG5/xs6IGK0BlAGWRCwVfNrF85DIMGycGYYlEhTldu6XaDQhJUloodXnvs/yohI2hqIPaqHbyhI1N7FfECilKKa4MwAiI2DMg9BnIIrv9Jhyz9ctxWOnkhHpazznsPx4Rva1VNuoS5FYuYt8tOM4qrQqDGEvbYgFl9eyADMF3Qfmk0+tf+GBnp2WekAjXupf6Vw6UlsNo19qRMNfDhEXJL20KNkuLHmiP20pbS8ydERAQAal3cmiZ/E7p8ZlPNEZdjB5HJZ6Hja/VrSNrP6qlK0sSGH4AX0Us/nEUuk+g6DyDZWrbjwjW1HbsMsbcokI61dcXB/vG94LRERS/8+2DcKF7YjOCvAjxH2axryranfgijXq04ratuxHhZhngBGNLREJl2QZR17tCe3UO+qqdnCuWP77NgkZiTKyYj49p64TX73nTrmUTFfHz2OsjBH3OKq8RX3IkU9xplJ2DfEH99Mf2prAyB5RXm/ae0lbdT0OvYvgbbUjQbXwdaszn9wo4JhppJktgMdycZSClpHl7U1ycg/p9IGW497/9euRqvJoyc3M4V5A77CYKLXmU8plOvbUkAOe3h3WZ76VbKtF8/2w/bes9rwbtw1wSoUI1nHD4dplkx+pmrUP9FkjF89H3B+5e+lsSThlbSh2fcOVofy1jgOWplp64KOPjvMK3kosaTJ5RWSWA4nlR1bcfGhzYUlrskhGM5QXU4K/x0jgVkz7STQAddzt1ZlvUcmSkduSnhejE9i6UF0eXXUbtPyfKMXr+5nBxDj7QmBgLJWJshfS7nXDvrxWEqT0BxE1iJTIHMGNpALrSfTg9/3zJXzFjyEswiEC/FPLXbIq9tPC6Uytce25wpIlFDT1c/soIn4sm7HejMeqwvXFW8idjQWM6aKXgxZ4rk48BIjgGlJrPd67022P9iJnb9QBh3WyrhdgCYvekW1wTcDuyKOeWPhRrgOviD7ylshzxr+MIWsuMNS+X3U1QsZj05rjKo7S0Tzt/q8StwlNykATv3jU0+POQHgraH9Q0iVlayRlDc5x10jK8MW/4VsLRMM+EwGHyvq+rgeR+Z7A/OWuiIL0UQSWu0N1W8EmHY19qy43/It26YpqlS8Gap/XK7kQbtjKvYFq8ndJKnQTE9s/PFYIjz3KzoszWTrygXqzy8VND2SB4njDDOTGpLkWfPhOmNbqAnx8v/P3Bopm+PPoUiSTMYShVhcgba8M9xNKbEAXTxwwMt+GiLnINkiiMLdn/GqE/2T4ui1hJF2Ms0ooK4YVDoXSzZkpKzI00N08wnZjCJm7bCDLtm2fjKr2oyghRAr81flb+sEDa7TMLd1+EGviqXVkApJhMNQFIVo6siMYo5hUvjkQP+5i6NdPKoMsRg6OFJe1v8oJaCo1S91xDTsYsLegUiJO4zVIe2kZ97GU5se1pf/puUwPaRQGzl0KNkCcjP2VLjFA5GSCnv0LIbILnZEtB6jxkHrPC71hL0ONrTdjmuuxN6jg/TvWO/xdQozzwMDEoriMLdFPpXlHQ16KxRun0JQZO8yRItklJLgbxNjcZPWENAdTv4luTt7hX+Cay+vfvo4XSohbT6uaCriPTjvdOH3GX4PJM1XoGkTHbx7bJ3HQuR4heocI+Yvea87U9W4H5yP0J7JCMo3YNkxa3aqueagdtugKjS7l/TvcWID3ng1Wm5LMcY9FLW/GdvN2osr+V6KA+tW/R1emQFmerO9u/tSSYu/GXhmwJkuqiZnARMtTJcf8QJP0DMMZwfSNfL7D256qa8Kq+unoN0gCQbOJCv+yBt1pdD9f7+esRfXcmj4J1GCk/8CZmOAYGqTuaJTl8Eo2FOxvP1hfBxkh3aOiGOnTURcS/lqoOeV/rprSpTxBu0KLuD8VO9Gjyr+TrHRu2WMOQBuvE7DukokErLup1jpPLhm5uZeQccySffdr6zb9wlzwzuIdTLNUUHSRXlEI4nkUYQ0AUdSUshu3EbZE1g3CPNhJPFBm3EWByFv2a8B1ejDR/UIh/NEYXXsffbS8GLOKMZoXe82GfAJ8QsPpzgJSqedEXniZwFMtULHMJWWj9xmzMywLhqx4vSRzKZWX9B8PaS0YNO1RMRKkXu69m8/TpdADuGyTJHdgHGCU+PMHlV6sEOMrDJYOaW7NJ5MHT5sFvDPdcgAzjwH7i98GN8g9DRJUsKjo69IE0pPuDXka7b3+wn/p2VxLfMAPw3I0TSatVxQ8ZmpSFDwdd2FnHM4XlTIumbSNxW9Gc2IWbPLliFINOfTgvhoEoj6LaAa08qhjGrivKGqDUmb9xBWgk9ZerbD53RnnXGZeEUG+Bz2NWP0weZR4ve4JfVmhqPAbcOS9EXiXF6ZJLAQK1wDZgPw9Fyfk97iYaLJRQVG1HrikKQqw0b0ocPycUY0YvwleU2S59FUZMTTxiB4ybGY6Nn+2/VR4nc6hfMHX/BSngBpVOIPfHAXgL56ZMAhWGcblEUdxQmu61Gb/LElMtoJdswYcuECC9+aFZDWw+r9jRJaS57WF3H8Xl/kvkXoQaT1aFUuziIeorF/LuMMvkX9FCiubB09xX2Scww1/YRSKWpkqX834A7gyEzAi+6AVam4bNo5NoP1anrKKT10ADcmstnAHoezjCCzcjrk5n0++zUQzxjTPouu/pEKb82l5OODPc+lADrdb2bZdBvaJYpakon9DKFgYaZDaT2+XSqtztEwF5+wSstcSDEVoXQHWKJAzlI8rNMkKwwrmDpprNBQMlLUkWyyBMmD+cH2LGEc1JdjpVIlJdbCsNhb09LiqD5wejOXK1wQljv1/235MCJUCANihzvSBaDnLIfW+hxX+6AOe2DN2DJh8HXH7C1znMDVc9yiTV0UEZyBhayUXk59FUJHA2yQWwye501rCDr8AjfRp4goPd74e0s+IMwYR8jbr7Ty2d5yURVNe5HhDf/UPuCYPZ7olOxUdspKUvSwKw/qX5T/ZCBwCIhxI+SNzJJlDRy9rKWM3CiUrWkE1LDLLe948a/2CjAH2Q+jFKNZxZNC96Vr7u/9dft8ASrF+Fox5m/yt4Vi2IRMgZleg0Xz8CfXeW2A12ddhKX2KJNstzgkfqJVSS52rGl2wTE1ncVoOBsd6ViIThsxk+XPMRMY+mtVRaHGKeZHdfShDdIB6zQc5Bm2DC6P2Cl+LJMtUcDhDj4ykaMoibpOcBl5pEt8PZjS4RYpJs3Chguug2B+j+MDYbr78HUUJ7+089rk1lqFYPbxKpurm8P5meaNzeIFoDjgY0stKcFuTzutAHUz0n2QAlpLAYwfJ8Q9WNgoxgvSYPJo/h6h5JGbm/BUEnrvdN6ARGypZUH4jIa2Bmiq3qXstv1WcHCNGa22emMIU0M98h2iR5eK8TBe9QQdv5OF/p9BP8ge6LLdrIOT0zopTJMkRhsT5klXBQlE/QRovd8x9ERufTveuqtMyvkqfoYTQERXKiHRjaMRRcsBPuS6wARzpfHXx9ayCIV3vAILLmbVDrFhhvsRC2BsYbZdpPpTe3sp4DXOG0byf+mUXbykn1KPT5QbRV5gifqszTbFMHdqMfUfswzv7Sj2FoJe+eSTWvQ1w+y9yq7c7YDiuIRTxLosnhc0qew/SYxj2Hfp80whQYhXGgjXMYyZEsZ4+s10OdmUtcrpdJaEzY1jAlEhbc4S2EXirD71yZlV84sWRlmQAkIihJLGldfA1lu9E7q67H0D10PS66rY5Y6N1YV5UrJ80sExiY/tRA190z2Bj5W57NplgUq33R7GnChdoytIhmZt5x47wN/YZ/VOA0r0acBmpgi4mEa9e8BhjxYTZZIazmLRzQ/uMVlDMSxC1XTltq0zAl2JXmg0WoiqoPRbgClI2Y4Aphrc4Oa2PklBPTodrY9UAzYtuerKhJf8wNmj0vRwTw98DMc9mqsDzgD5p/OJlcHvNu4IjDuHTzJRZPodygzIxDFYpVEKcW6jyP45rbTyFO2zfgnUG0MelUpi6YObTJVkZTeklkTR3Fi3VMOxnLaAELm1D7DmwHjYQUr8jgVYREvrwpRw/pyJOpIvi27ZpBJLn13WWIMJp+4f1F7xAAX2iQIAE61L4zv+Rcx10o2fy8KcOz/2n+kvwUVIt9phXMsfxvA78c2ImzyFiNx5c/9kcPGTfD+09XZYPRAEhME/RJFmlXGQf1dEsuFsNOL6Au8wbskPuPLDIIwVWmAGnoVjbxtWrpb+/fqW9xdFnvCePLJGjjPaZlI2rjDbg9ynh/Wwy+iQS5PdxlDKv8GCHGS2Xmnor+Smy3I5eo15h1aQcQId86Sa0I55YFUQzKXqW0/Elmui5EHMnfIuD52lt9bAlxUsG3AQ6HEzuOy/S+ml8rqHm9xrNTATtZzhTH9xUFrqb1580b0CiZ198DsegaIczxdUeerCXsgL4IUeOI9i3coTq+OYevdeNfP2vaiyhsgjJJ/pdlW8ZXOWMUGk7IJbekIGhOZ6IcSPValDhakGHkPenW9Knms3lQfN2iVTn3nZsTQZx7+708T6PM4/CqsNPBoHjkNZH4B2It+urhn+yJyhEfB/4XSjT4Y67AEgFM7dDNUJZBB6y+NoigpzM0dd9/rh2qd6oCcCckKQgHTxCO8PSMPOeXAo2Bsd6GdEUtq7K7HKuFyLElwIwS3VMeS7m8uyWBvum8SBTEqiPMF2bHvPAvensROp9IJ62BEORftppb3SKjnYGPxQL645I9Q5HBbFDitVztfly+libvj+3OP8RDbs1fX9E2maE5Tz2+JOEB4koZms0MPKCWyNCkzLx5mVvGr7F4j96tGWBhde8g6A+p9FK7vFKOyvkUcSxe30qdTeB+x8oYx2m3zNBw9vOyM1nmKO7f2XH2AduI9/WEM1ltRoNDW97PHkLsAglopo8Z+rkSbgrHB8FbIlwh2mHDNyxYHQjZ7R1F5NVMjmpm+wZYewNVH2Okq3GaNzs7AWH1uT/0r4+LY/6rw24vwpHqhMJmMG/C5EFLB+OxTdYaYeQdGVmnrOxarrgk0nooL85AcEQ3wOHJDAFyswyn40xlBqBnkKW7TImrMPU/ZYWwroxtpmRZMELlFYhqVYsFA1SfFaYlvS2lL5jmDVWIpOOFfU2V4MRKqeV8MGLbiGAzMpxbWmxrfNX/bpZabI6aV3vCwQLn1Q6b1yn0vwoqb2IvqKo14rd6KtIt5/Bx6lwF3jvMSdjhfVi+9kDgLbRxMz+rLmNIMw1OcuEq3tX6XXNPzX//7efgrrJDQuD6bbt27f0CGwvqoD0i6z+eiPA+Vqu0qJUWELf1/CNI5omv5Ag68mwbyDjftlIrgHpHu2OWRsPZYZRkYsET9lkfNajrJQ8icZcGU0quHxlA8Qip/IuNzflnJDxWl7hbuPInx6rEEs8d/JcD9RunztjezCZTq+2ri5sYxS6RwmaqOkaToNf/81d8ctZkIQkAMjXQZmnd56N9bHb3rzyElBOsOTUBy6mDyyxt6+iTdbZL5P+c3/JjY/+sgEsd8lQrwOn1KEnzkYCf5+jklG3FdH2KNz0OMKG+pdwiB+ZLT5xMUcjxkUnWsGGZjiakf5brQkVXAQr1jWpUSRG/XCG3pE8/H39sIbPJXjDniki1owg0zCZ99QYlILalQbTNt5d1MwaBbPYXK06B/VrTqseT778b1gxGJoUJRBYwpPAdD/Bn0OA6Hvl4F8tEVduZDsfwb046O0dXpG5qFIA6Sl1PaeqLtRQC6WlPgFrFlcxrV3JlztNaBI1ncuuMHbIz8tRXDVxf1+j5538xAdj0gaa9RE8UDzUck86YJPk1M+sFqR7kL3axCHFy5oWXKbe8aokKJ7S3oQ/NQlblNTqhPqqyHPMApXRJnpq5fE7XZ8fhEQQOJW1FQ2M44p0VYMJfuL7OlRkJLEuJdmm7wIBNnm11UhDg233m0iRMAmMkvR3fQFaUYf5j2PS1PRZOeNHDwOY48CQE6DhI9Lk8H27LOihprzaWpHI7u02856K+GM6q7GIMEl7k/4ti6JD9aB+yIrqeXmMnpShiJocERLk+BoZ4n27i483OGv8iuheO5tuthe2u8j9lCAKcCNVCagYZw7qrqk0AeUAHHzkc9WSPeDtiCkdiL12eLaFBJHbPWI8381cHrzqnNfj8+yotRRw+rZ8pdY7Lij/Wh7ZyEUYRRVzuZAhZUg2Paxfa+OTtVmtGr9NWH/NNdLr8HW+eIHkn3yBIrEOYljM9TMMBzQJ6BlJcUX4nBOFhPKCCW4aRapnX8uItjHusV7Uxg8H/PlkuaiEHum5g7qFIVrij6mQi7KA+d5qD8s1e14n42lqeMvx6UjbkJX36IfTkxnN9L2AhwJjHphEbF7/jKwvODyzFq4qwtnptubxK2Ic2CRst1qL1t7vWvjath7YWSZtitzA5gG7StSAOCnQEgJ6yXj3lvIoGn9gvpxoWuJO9jX5RfdDnVWyXcYvPsyDab6nh3vHINHSy/ja77xf44RKRb+l8VPr2xDllQUDrnZNY3NGoT/srnVPqHFwn82ns29HAiLUX2yMGoVxvY5+gtW5vwTRjBB7fFOOUygthFNWxln61W7ncQvTVfwo/iwgsgLEF0Kfzz4PDECwXR57wsnzDR91LdYz+zwq7y8WA+Dz/oIt+IjH904ZGPSGKbIqBLIglLdXVkcLTElsz+A6qhnpNJX+yRJ6puhwkBqI+2CWC7AyxIoKYdxoobib3KkblaHvgTlCZw3ii7OxUuyk8XwKXC35VpyjP7rX+8CJ38s9U6Jhb1IhkYAI70+A2LzUNq5wPtJbhaYOEkHx9Wy/Uq1t7jdBo+bXEMKs93g86iqOf2+CYplII6UObRlL7a6LEM9Fpm0TEabkHEfSPZmyd/3qWEv57Kpibw4oea3UtedABO+wclnv4PebzLVyOzP9J+TomzN9a0IQc1MUNwvXhAdd+UgOx/ixJl6n5frB4jJpl+eFb4WLfrSf7j/enp648lm2026Xypqb3aBVYjPuTBn5ivf4svcceodm1ClPB3d6U7XJL8H/Xk4MMgJEBExiQ9aeZtiZC/dJhBxHqW/+B27nkpiljkU6+e0+uZWfhDxMitZudlrPjLWf0jRT8Q0Pj13vGMfotylC+pX8TUVn7Qu/gaCTb+J6r4y5V/syC8nkpa3W7RbbFYoldLP4zBPVqy/UIEFSvX9dOYIJzy7Gq2j8yGTw16q9AiFKZZzZia0I39tUvkL7cQmhXebc8siNOkLOAC5SHhzW7YexVVYq+aJQdomcTLjG1d3UF4YPUAhPLTjTLBxb1kLZqSjh+r0vDgsazJSk+LQbzLvtMUw7ElBcRvNYAjxjhpZN3H+laCKTcpxvBCItJT396YTo+gGcqq6A+b/5wDqUPzgridm2RM7fXPpCCaxfwRjuVYNowCd0Jp0x/n0Lxocdt7xNW1hgHNlaGyhoE9JubcsvDvjnM3FP+ud5X6Uz+qMPC9YwQqY/4YUj6ILYx7uGcP0Fksio2X9yl1dycZWnUDJkg7MwCEgM48ghbUwFUi8jjDKlCgNB1muMRzeeXIjg2hdrVnqocgIqgdDaZIDaX7z+bhbwkwAgW1nSFtGTolB5Q/O7U9C22Ar7YRZXgjYeaurRdnUFJZQ+p+5vx6uRXgtYVycu75pttKb5FsOF1Lu8QyfhsYbPbGYa//+2v7SuwXagxZlR5vEbSuiUZj3ODZvaeWPKbi0vU8ZowwdQbhF35u+ySHKEKZnxHGxmc2ForAPHcGUx4J+a9wr8LUtpwNk0bJn1BV1MjbWG7no7k6QBwzcdbrRY7hOgr2eshPa5tp58obguJu25GwE9k1an0rU/7IG5fSOEldzSzoBObbld581FEDJbolzqkWnYznSIn28uMQV+uJb8PNeHzXyvOzFujOp9iRSo41Yt92WSmcmS/vC9W3Z4q09OJwn7IPifXCQNcC67ruoqtbOFAelDPqHlUxzrLdZb9HPyd1YeMRAxOvILf3/u3P/WSNxwDltvX8VUs7/Br2OlqvrdusE/4E3Y8/+8vg/GffxHe19q108Ozj6BKNvKzPpCdSWRSKxkyOUyC2qVDSp2EKoA7B00Ljm8N93mZjE3PbgtVGCZRnklzmcB7wQy68pRZH3O5q9AqFJsLdL3Sf5dH/ezHo+1DUi40pl2yxfamHOpE/5PZnPfMR05xFI20wNDvVBW8Gv3hiex3sErhYTnOVNRDVStIH5L9Z1y67BEFu5naieE0MmYe9eCSn8xuBBuF7sZa+iUU2PcLgXAAI2tkZjy+Yl0BPh1VlQ/ZMO2vw11OIRr1WrxLn8OLD3gv2xyRLC5e/5nfDBinSGTFu78uLOC+N+iUxRnvS1TcnyaNPXko1PYTVPQhsTf4DnXSs5UJCYK9/sTp9JFRCub9yyYgaInti7oOIEyKWK/jVaP7XY8PizGahl1qkCdl9SvMZ3iCIxdXG37CuEAQGcRMOu/RokbtIkhh/qYxTBOnlfjElFAFwHOIhUHsAeAV4IXCm25lMSvCFnsE1C6Er6PmRpZPMtk6/XKqLumwHjyz8lmJHOGOttTEtQ4Uf+JGKI6vAfl8ezJJUrTORK88AGfS4AaVWEW1R6V5FB7P5OOgA6YAUL4tfu08U1zIbfQAj7pKOKLhKEvg1q2g5VC9N3+PqE6Ek6SOvzdWAjm/OZ2txhApQ7fKiOlaTqfbK2X+sU/e+3pcuydLDVa9NkF8C3d0NBBbMTz90xaVSZBsKQbGMiSTHCzTwL2QiMwPUvrAbSy5cdbUl19WqDLa3BcAjUNbzVFp6/M9Aj1xVLKGH7IPHEncsLgNXa80dIVnH0OIhKPe27NirIK3us9pihkVWKrdyIF8zPS6gQ6/bKKuFJ+6s8IDBk3Y57y4wV0JjTmkhm1OliJ/6yOKpUSh70Sac9+evkpbwMCFE97lJF630EVOo+2AR4n9qm5vD5NwG1DFULcTG/DX9RkP+Nm8lp3A6ikADuEMJ8yYUdJswbkEytjdE+tbA5rWxLajpPcz9QVsnY8Ti5d6c1nL6TO7BncDWltWXZ6TawyS9kFj2rznxxotk398pW+/7kD7zfhnXNZSH+AFhYionmbFY94waYMwxNI/wQhI/DJeT/7LjkrpJ/PdAJYiAlRhQHdnx9CEWaFr+2FXHc+dYeCUPiFppKIRr/7Gzrd3crzfNI9ji0B0GjWM0M9JUYcsgGTx5VSkbTq/fIVryy3xSEeGqgFRaSqW5mrijlad0Psxi4twLTAXJPudldDbWHYijESmkClEDriVUp95P436PTCBaT/DFuTVMnOKeWtuXI0w+QKLa+B24cNJJeaWTdIlsLeCQ72wpTAR81MWDgw4vqLiA1I5po27V9ThW7JT0Fin0NZUQMXZpTAELF0PRr6ywrb+MsBd6f2jGO91u2Xonp3RsUsST+Q/GYZocOK2MkKEiZknyuaXsWz8LgYUzXICMZzyLJG+sBpTbKuNIjjxOLrf2qJ+h6RZET+nbidWzoBFmCyHIqVfVQpu+tvigdfL+zv/csZ74I7Sy50BcHCzLu7+G3ouuMMhPXUHgTM6BjpB9iTQFOTmOD8e4zrRUM6lNYbZbedxlEBpfJaF0Z9+Znz4k7WQtbukHXTeOjVGsas/lED8CJ/HZr1tWgnvI8ISH52uTmBXC/9BLHBeVT0Hd/ew/u0lLVmHYJZRRAVBgPGYLNfGpqfdlkdHNbg/FJsgePn/eJonFZDkBiK5OLU7IoHC0jSlwII06EJR1GGl832C6hQdKuZKgOc71veal1n9/eIxSZEBJXMp+QYk7TOCUAIXMaNiMexUjDP0saolVKGw+Y4YBmbtAuWV5jLotBU15KEBkYJpuItrufjlY50HT2ZKdqvPP3rj8G1jJuNZSx/PI0e/vz6SVLkgnt1QXvfbk7pmxCW+HfJJ/D/IuTBUygb+zRf836G+j3uq2aRHeA5OpTv/c3vn9HphdU4bD1mOY4TGxmEOMat4MtRSnRAGz1ETLIB1772T1VShOU4gB+rHsYZk4GmHZYQRKWhxZ0lTmpCHwXKHJkKGCNLS6qitWcHVJcCE0OXeMEs3VxUViQxYbG5Z0GYa215hD1F/VYos1RJk5cA3PEz0CIgaKShsFUDZyHZ+KegB8hbPDzX4CLEHhEujQv5X9mf/g9c5refAPVtutvrPlxWm+LN5Q7iWIytTzCCvYHkROSf83pWso0OE+lg6ZCy3Lh3QEaBXPjzfBStYKNksCTRZpFr7pnBEdWs5trWVBdy23tcxHWyQwTptNYcUWxOMTYgW/jlwAtSz1sJ3hAEDbDSSzB557k0vUL3sCJJeaRXlfqbljRSHMS7slvAkztMu4N+28njxiC3XWlDXGhALZl0IZIlLJ+xX6cJm431elFfuI3Gc65MjRhnRy/zhbC4hrrPJxDtl1M8wBgRT7xRxlc5nyUpmm08SBK6HsRTT1g2q70KgYjLHZYCjRDJZYQWiRT7LST9XGSwz3958UEZ1xA4n6pgBxZFNouuLwCpNalMm/2WhddTh/4W+9f1/aelQ1+J22vew2SjEev5FNcBZbi9xzAkPmjCsMNWO5WXYoqJCdFSKHDjOpos7Lffw5dFK8JlIiTGQb9zJZWv+5AvkR7hcBb3nLOqUi/+GCQJeHEZ67/k8mY427gjH4UfNSfy3fB9hsi7K2WN3E0i4/tmCd3YaBRoC5+pZe/ulIqWJHaUKxUe/J0uqhgJABdLrfKc0U99CCnEKm1puIMJhxLNMdHZVYWloI6l3QisWedzZV+S2z4BORXKcNAyR5PQfEP7/VVPQ/870z4fnuZ3SKZMUj4u2equsi0FmOYz1Aq7sLCLHi2yCX9sCrQL+57URskRnDougPub1mMURMD/Pkea8knAzdJZQ33OWaN3aqmdVZQkcj5NBuNhkh9FT2sgDpe6A/KKlb9OvsKTuwvaXwaKKsA9RE1wcXoytQFRvuKMPxyGcqZZlFHjfnlCpNAGV8I28JvOpxYudhBj9joAbytgHnOe0eWwbiTNL6q91zqjI5a4onXJgnmHFezXc6wMreK59pZAmUI85fRIDLiPKCWifceEkxsKf80FoT211uFt+CeKee0hkXXzyADWCgPzKRl0yn0Hxl+he2/k+9SK531l/A57O5vw9O6xbuJtsj2gN2jgGY9xgOHnHROTZuqCnxR5QHrLOKhpAhE9fahhMHgnySmvMKCZHTh890YE5FiQ5Pk4GEVQaSmWCrcBBqZz8GHYSvaDTtKixBvjeyt/rtq76LqBmV/Wp/EL+OmgDQVvhW+XMIW/noHYwNe4MNtIrcqzY9VjPPylyYtzTlgGhOmdTphhYKbwwsGxYQquG9tRatyl6Dh9SwFV1qc6P8cgVjrpyXe7KDzDppwEYl4X+IVNZ0KLgtWApu5FnX1VPKYPm3C3d+mF/sXmf2c7/7EDJqThDsY3YDfQ15bwyzmlNnDo0791TAx+URhYxNC+uLNUNRZmSktrnbeHzmK/PGZI07wCQp1T7gJ2q51N5/pxmx+cEuveIdf7NLn4deF4CvvJnACIYKGqJohr5++BJvmDqBW5qk509XQXn80QXez+MSjxBdAnXvSyWhQF9h9lkoafXt9nRWnbvhpWAxxSh4NlP/lJHfKmFdpqU/I3LKNyDCmyLgBwwdpPEDrOvklonqGysRm5+zYS1rg28EbziDL3Gkgza6Rl7w2F70sEh2WC50MJRA1HwTFNLFJJGdvYVkn5zgg4Oa1AGxoAw3Z0NOtqTpChU+hOJGjcV8wrZ9J6j5SE6QFI3vcI8pp8fZaVfqwLnOejIx0qyhB7e3BeN1uGO66pQlxqP6PfmngA0gynzWGQZ444SeLsiZw7dpp5rHPGXZZQi9/UIrI/L0PGubPddcGWTNYmmGkV8nkVH4Zg4Y0Qzd7kOc43m1diBTkEnAl3Ag5+cMH2IgQ/E6e7pCCnXezrZkrkIfxQQS+G63C2Y/dSdC1fk2Ej80NnCI+ujzMjmpL21EMSyaayJfxZicvzE8OchWYFT1jzTybdzVPohCQ+o6d67xl2i+B69afYXGchghhgXlCjtphcm8ESYY5jMqe3r5ljyUDwstwhDo0zFVTNn7rFs1ftbq70CJmFdsPJ94W+AbqeTfTzt2urDALjmGNNd8DkD0mvHkRr/r7lztTblUHyUoB60Paq4KjMmUc6eht/xy5LHg4ao2y2f8LQ31SiGF3nYnmVODcyYUq67fDYbMdbtoa4dbIR/Hg3ItxEcXqIIBluM43R12db8u8q6xLHTMb8t0TwT5hrOrGm+4I4vIdeYXZYLlnxEKa6mWi56yA4Q5Xn3I000rI56UTiYukNK4ukW+Etghy/pbbRA1L9YVRTEw6v/ZNohqDVIBFGtBzy9HFevZrKXaZ1eCU7Bi/fAHN9bXGGdx93JMfXl+w1RrB+HT+UWzeYf8gjMVKhaWsPfyhzN2aOYgOwoj83FvhBPHn1JBHlQsRT6TFbcqCUbJIh3NneUpbhetYy6PCh5M3jQHompSujTGCg7RP4wK5HSeNFlIE67IPDQpb2z0J0Y7+l4rdNgSFYGYchfCh0NK8qzs7fuiX295MUpaOdXr5hzPb1vrCcVxh5h/S9n/DwI0+WPiRFK0YwCvqOvcEN5zCMMplWbMn1XZrxrs5brZchOBDhBxNEZkDabZFf57XJiJT385dDGq2kcrjAaoOO+SMtEgmIPxpM5XEf5ilJyNMBF5cRf6LB2jWvyLM18qcPHtMdtgyhHcn/mGN6JyPvxrdPJIMqE5LHT92OIl4jqnahsBKCA03PaFx2cIK2vA8uuBVtwOH++sWZ8hH0aSuMW8WO4yTC0dSV43NnH97YFD+ud5Y4Y+vPXp807NgCeNBA+e4HrnH8ULBV2TR67XUk4TrbWxzaISIWm7VH6o3FX3wYfEcAaKVgTwJlF0DD5tuKH5CdX7pA010lV6eIdJy9tGLaonl10OIn+ilWhyiRvOD8+IstimbD0x7VQPW8x0Q7PmHCBu70EEU/GeWNNtXRtHeXfJ4B4UqoSAZxAczfwMbWwiE4Hk/tl0VK0GYrmqrwm77U9sI1aOWFqXkTZCM9iVILLzLHc8x0Hn1FdpX/weuvoR520VDO5tHoUDZ8rB5kSlf5mqAL0cdLxA8qBrZGudolYn4kW1XRU2h6FVpmeptZIK/gC6cJ6FXSNeydG4v0/xB7YkCdKs0x3794IsAZnivozkckiLuLh/viq+LHXWayzmqLNMhQcWQnFXW+CxHnKGMtrhcgdZJQmFhoXph/U2VldJoOlP7q98MWbIFkeyU3wqN1QHgb81CtXqOIr+o7nwbGdR9cruf9gNE7h+sXZ7Z1nOWmXsrexyTo/CrBaVEELM5PJlBN63ruaKXeo/UJnAru4dN0RkMhfxFCD/ssZJOwmjvi+ak/DKiNxZUQk2m07B2aMZm7+JcxykXzt+bShKbon6+rPB0MtYyZpAOgck+GSZcxuTRlmHu0n3DFOWfMp21NfGDdZAi8bF/LtVBnOw0eSKYM1rRCE8B6MI8wm3DauK7CTJBeRo5STgu3Ce0m1FL7AV9zrGrbxhx1/41exmYZSDUW1127wMpArKZpRggVWQonrkaWpual6c/+SQOjd0DtiQs0HuVRdQIOoX0Mu6BvQradMvBFZ6PrKk35WCAFROe4Jw24eq8f78oLdhM87jjz1uUksoUT0GfzzyolwgEB0wEE9GLThjiXqmSCVI6K3FuehRzW9M497c6SEXAEzN/hCXqwdnsKsIw2h+1gSraEvNt2B6F96xtSN9WFufhHrFQhNTaQyH+Q+8NBS+i9gUOLjw0KZ0/M9R2HMP4xF5+9VcfPBo7uEGRt9DHRKvSlFQARBNAZgjTPr76nS5ucLFx4zeav6haMwKHPrEILaM484NLoI1H09X4+2oFnzAezXec5oELtBZMPkmTD+n0azbxe/Y/xsCOBrFRzuEwSZOnVEAaSbhK7ybuNei9KM6w0hbjgS9Q4gb1n9H6M4UozHI/nWgS9dGoPquRRPD3YZCrHz3QmbhMPGxjQS49Z3bRFg3ovc2JnGaDck0CTiSClnpBjbVFPRSZidmwJNvdJc/MsKlKzlwFjXpqiiTECsmffQERtHLulG0c4kvdgCXdY70jX/VF5HJZnA4ZQd5Emyd8Lb80DGqvHi54w2aCp253IxACexJeTNCjJTjMJhBsp+ZG3AfhU0EMTBTQQrbpIyH2/iMKZ8D6JnqtrRJunHTO+WXp6G75k90kSON2hUfci0jMBvq7JL3Nyb4Yz/sYQwF+cSRdPuRF3gPydOKKVeVI8eLj7Axq+crdKNjgNpIOWt/xKwzZB6QzHsVYOWSdCd6+Gj44qT3ZiwTKliM/B8R3C94Px56aMK/WVRs2I5G6U6clCnUzyo/Z4hR3dKfsmmajZ3AnENr3lxfUtlMvK6p2+xTKL32ayzoLtQ3oejAAyKXN0SKljl6RUK5YJKfZXOECsxqUHrfQzJv6+lEPRcF9yqM0iezhRbSowAmJwT9GkVzrSNQKw9SlSEu58jhAlFbBZtkshC7rWMNtwNpN7bV/C436EPWz8//HshZ08VhcoEC8FsfxbcOnZ/Ts+1yJJ8Q0xN1YYWEqAYOABIqSXF/Q9+l2RHmGrxFMfcwgbdVBXpWdSDE8YNMN+oUOL9qGkfttdHL0hNUTXGSk65FUimM9ukRa97FIlzknv0te65tVGOBopzTzN/Y83/mja/ijQM2tRzI85hYSYSAeobIYN99raN/eGBcgMGUSP1VTe+79ZrRxFv2UswLtWJSTK1Zb4Mk3hZhOAXnWl0ZdfLTMuFyN70sVkXqeVMelcUFuiyEZodTsP0R16uYU/obGJmwmVSQzaUdlvYNQCGFzSSaKhXZwVv6IbcRa6KJfdISh4vHNG3WycXtrUSO5swBQHf6Kxe2FIVZJuds7bqhRSHAcZa79WisDjL4jLj8bz45L+Bf/FyzKGHG2/bWe9nz4H1wodXr86RCBCk3q+09ZWDB8m5VOGk+lN6hVxN06CmHK7cFawji7UtgrUERCeEOVCix5ORZdiyqfhnm1y30SNs3xK0xH75xJQFTH36PsHEnOuD90izgye88lWw0xRAhBXOIpgC5iLF0FFeywcCBJpm3zpHb4IGNtYuTcJjTGyJUhd3FtBRDug+KOqzYu/WCPCVmTPLpWbIcGLL6ioIvk9fvyq2cqIbaKfji1hSZrUd9Lwwid8fPqFHqmFFB1keNy+mt2BwckUjrL/xDc9ZwhVqj9H2hdkOpsOT2IgA2ut4JCCiEJUmnmGoeG3MkZAdGEeMdQSdfTCDsmqqrcf2vt7O5WdNp6g406FfycMeV+RzMMuGa7JpAR+YRa2w4wiAWVNCHeq+WiEdsHp634IM+MFmsuabW4z8DHudAnD3fbNWGdNUPAMZqCUJ1ePv8ZFWhbXJlzVtk3LqkMhMBOIl8hLIy6Ae2KLbgbdRq7GVsgvrrHMA6VKnzJuGjioe7TZojFYIEP6L3xGioT5iVjJ56i2Takp1cHpwG75amTNm7bwRWDN1PjCScfLHteaom9VAGSD6OXP96QkAbVGHq5rAsXn7uZcwy58yXNu0hw76IU6s26MzL7lunrnRY17JCmi+fNEnKFZS+xQ77mHJEuith6VdSlG9RlLHZzHsN2j/pYlcj22xZryPC2anIwuDonwefcXVGvHz92wP95JQUZurtz4+Nig14BBWWLR7tDEp1iljMF+xCFmNjwDCR8Wc2J24oXwwvi0vbQOBGMenyQmXN8ZQxGF3wou9DgStTd8reYUCA3QUMzRtor2HWtuR8dZd7SuNhYjxO/BLJj7xLlh/l6zo+OaNVyeOd9COyj8AKrIEMFZ88xDTmacYdLsnfns4mrYbDAVAmj3ds3Qfs4TyUpIU5juufqbl3ToT2Xz4oVje949YZb+WL7IoApkaxyJPGT53yzqPKTX2jVxNWEg0uSIfv8Bm73q3+/yvvtMf4RQbIJZbdN5sVmJi+w/kTu9oIBPzZbnj8TcfPxOG+r8cNadl5wYrLihFjR4fIP96a3zW29SsNq2G8+HD3K4o5RDX6hRno3j7yAROBH1bBKaOB4N9H/APzMiL8g+mPszCF5tD8NHzA+GcKk0KIJGKuYLgwxi+w0z+C5VpWaenyqNLNtvT/YoDpJMTn/iPU9e5YpaUdN93Kpst1Y1ieK1bazIYsFeGScESF/1mqW/KZtNKo/UTkpPAZETJr+y7u0ysltr+euw85Etmob3i0o9M2MldrPC+kVsL2vihsl4gsfdKBhV6moDfeEgXYfTDc1Lx3334j/cMj8AUc9c50aFZdH6scMRQXVcznHHo2ZgJ3kUTZ/u23WWfM7kk0av6mEMzIySg4NvvcpMYLnYHz8X1jItFCbe+2Y5jzzRzHC7B5tWMUOxRoDNHLfIbSEMp9aWLNdnVaZdhNswcCRTgwBVGlBqmWeZlNhxcybPBTeihJDj8YRgIsDAaTDyNi4mpJQfsCIGuJh28AkvJtKlUpw4zjpm2S8PGpQwAZvsTvM/pfLdP7bbsuP0FUamEXmrA5gX/GSxjTN2nk3WksC8IAmGOx628VQy5ZbjLXJZ+XeLQyzCm6bO8R6Z0xWCTyFejKJ8YSHOIXNbBCvp67fAOSbcXzPcmD9QzoRO3ezYkraHXt2G9S+a/IpH9z1GXI4lIR4bEUJPfiZyaqGwmD+II91ukIzTcyK8fQpvDR88kxl87nP7zOGQppVNaUUA2A1gfT/NGxuHtSz5wWzt9cihlfNlPvqj/L1SdhUV5G9trszMc/PQ97yDOgvlykkNtSE/MCMuiUkHV5ZJ5MyiYMlzR4cxFMbCI9DB4JkYPkQfIfV9cJgEFc3xU2XcnfEbY5yZQNlJzo1yL2cTx+emzdBtZNWyie8qfhw6hPhIU0UrvhdQ/LNPpoibt+lj4GUNv9SA1QihTf79atuiazX9g+rWCgPW/4CLCsFIIE8mn9cOdcqdZlOuACnqcmLntXiBLR+Drq9xL/7LD/8vaBvvs1Px3M0KeH6o3U31mYoYd67CooujMjP1r+1hiTeMBV2QFslTz00zoGz0Ru/Pua8TunsUCsDBLV9RXjFwch9POTQTi7S7z/mfwmEOjSNFjuGq7cslmHTA87kpuFCbBIXWiljiWteA4DoUg+JHSQcaI/FWBS3tIYR60c8OW2LfCEFfZud2galjCrdIayBXFqMVgpG+Yzdt2wNTZLhmk/yJKBf6dmNefite77LkeABkf1sErgFJxE5g7bVsZL23xsGvzltpbzcrdqytSiyq1Pj+HJnh+ScaWRWmUeV23egTMGyFYOeAv3PHYByQGa4ZlTZ/zAumjJwq38YZnBHefCXvxk+kM/G/q1L/7n+eM9W8PwLsPYhlPQM55XQWmjHwq/vRMezFdJZ7H3tw0DTb75U5ac6pxxZpobMX7wSvpvA4ESEZkRUrbfezILxTlowUMlwRSGWnOj4cptXsO+ujB3QUZLiZ72+ttdiNRxkNM4ycQLsutQ6YLccmPTrZV+KUnMycW+Mq+Bpu+vI/I799UuNQO42C2TE8XCYuj1zD9W/T1vGqtu5N1+Oi0kozAA0hzOquTJswzwO/TKf9+XJm0cqRdlajxmfZzLO6Ga90aJbTEdz8LjB8gFkld4Ns2KpdclXsMJnzRY8YP/gr65F0LYqXssc/vEAE9fOn5zxCCpwd4QSTeqhJnxJu5qa3YfoWPx+PBMha6MXTEs9BaMwqWobwaP0dkF06Z4u9EndbSnsmAM1FCOaGCBEyZKkWDZLZaEkfLF+lK4ign5wVlSVkin/AXbG2gkadSbwayMVaU4FBht7RaZKrWymvczaY457NemTozwMr4hRX58UKB1yUQn9M3eqQlxFisiXUL2LhXj5w2x6EyhAzEfXUweJeexwwF9LR4GWOBaqMRk89N7sL97QIVTdbIhBqnfgVoFdY3yoJNJZih3OzM9R8MRFCuSEem0PSNHyVlqV+Bt794OGAWZh1TFPzgOSTQi7xc5VV5xR60RZdlSICzYklicpPx8vrJ8z3yBoEBKEg4fJbK9zti1e3WzDGP/Gye422zH8JGUZrkdCVzPvfLDcK0vIxAczabfxGH6wzNjUVCoNHKRrYoxerK93e1QMwYY68lY/zdkc2UmIO2xqN6wlSXLLw1w/qk1iV0uIxqz5d7vNArsvcHPtzg6egmumQ1ikTXZ/DSBmvKwldUZwL4HCiONtGoQQsmBNieuQPP4R7hzpmvGMQFUgSwcCyIMm5Gt6D71Iixu7YJwFf1xp9Owr00RyqEGR9OffJAmLDi20LfnQnf1pzJvoHabcBj7ZT3KstnIIthtUKE6i8A/2mqBQNO2SK+HbuBtV/DoqUDjogtwjDh6jYJKPnLvhqDHwE2OyDm/G/hIWc6o984RmfFpUo2P69bta68bfUMSY94QNkUOwLnACRkvEvrtUfkv32fEJYnjJgvgE15IldYTH83r3hiSAdw8NglUpiiGc5bfRNbI2Oq0CeE1nUc7plKYo9ZymwZkgnw3OpH3m6GRnw9w2VJ6fL+mIpebAQuvBmcAlco5C3tfVW0aVAnC7pKRtzIMXvXR4T3DdX5gD0iBVS0Qho3LgWtaUvqS/lLu2CyQVTazp+RjPIuQiMd5oETxlV/rpEfLSX6A8RhK+wHbQSuk3vOS3ySweDrnW7TAgRX7NkSU3DNABpIl5sQ0Tt0B80nr9IRcAmJit91XBrEbusClR+FcgeIAhuhJlHuRDDfPTR+IEY1muj0cHOVgws0hLKmRPYzarg/KLVNH/JG/e6MbX2U8l9l+ZZlprP4kmYdn41+mpmASE7t9M15LXDUDf2dgyGTpsy0tJvt40atKkC89zG0XVRPucGOOl6+xLmwBOzqsvYzU7ZYdx7go1BGLBFsZ7smFQnpyiHe1xhdTk7qsjODYHZQ+AzwCtPkAJMJEKkSYdk33a4W7qlI9jZpdsJO5RCvCzwAznSHMHMWC/l1NbN+k+MXwwkkCNEkUcbnwfNhjASNl9nBnFkofvtrivHuMBd8peiJSTh5fwpqmz/1aHz1g2+HXsidpwCWWEXwp91trjpFIXAnGS5BNosXWDGPS/MH6Ftu6+AfhmpCpkp4AmD+Z7/Zf/RNSrCamUE0QyRLXnmyVTGW6gmYUK5nydz3g2tcJ0TQnaw2mwIyWBMDSx51dWDktlrf4lH2v9EllXMuhzNQ9anw0YkCi1JT5/nuEU1B+ZDbXJX7hYXLSqzfKUG91Unpn5+ads+al+ty3+vcljGLrANA38ReVZJ0W5Aq3zXlQt2NfkGQlradDUeeeITvhZdKdU5xfOpDTsGdqoze2m+OMEG2W8StcCOYInKNOfVmDXq4bx8dlFEinj3U7217GHVHYbH7pKXR/qQfKZDHs1t0Fn9A/XV1LVhjselQ6wwDLkZZW4RiT+jP+JIAC5vFOrBZCEXM6/5TXSYPWpyeuv7CQiPriz3wEDfF65DoR1LeyI9+H1IvPo+7b3Z0WYAIwj7xk037eSMwfleX3/bjwU8lMXpsD4ysQGQzDKmupb/JH2Y2cgZImd+Lg7YOCVMKW+YX9poX2evRH9MSxgmOQnvn0E+GPz2nkyzdAXSCGwYFGiRic6/E1h/lwUoLVwMnIeAanvuu9fOJjhB8xdWHnDzJq8UqKT+x9bgoIRno+emilG5i3rGlHeG+rIjVPOp17xeIzJnHN+ehkujk01msyO3zYXUhCcI0jtuPch/Fp4zWSDf5M3vz9gj2vazA+IOi96BA4dE90M/HG1HW43DAiZIMWmgcbE2FRuavIUodAlGGnt3VJ8o5FDe1naZUyM5jIq5lJA3yaz9FoBKbd0I/6rf6j0bdS7VnyOP7cURCaYQosB3Ku0EHrY/DPD2rKywW7/3FYuukw9CiX5EzH7Tlgu1j6TakDbSzSZRXCylkShpuo3QUVBjukktPN/Rye4AQkDjbs0sLXU5hyEbpj2eKv5g78D1lH8+IyamBaP4X9sOrYE/oMz0XhllSF2qNaAr5/cDZYERVpiV2llrLBQ04UfG6yZEsxYFn6FWbEoVUFVyB93d7bBXFjFDYbjAnOMNCwUL/0t3lcG9KxJ2Oi+SZiv+VlaBksWHfCc4uuWovC1etv0aiwkursuNLnyXsLsyKdPdGP/HXyMdKKCDRX/lxsoCYM85a9jfYxw9jKBRIalIOLiwLfhHbnOvMTpgrRtVVfTbYMC0W9LrvZkNOfymqJG8ZXYRvRVHBuCElZPRamQ8e+38zRT2KiPWlFpa1NLGDAsUMltzQSz0oUImj0Fn/fnwR9yB5UZrnBBZEylXQr9cKNINDl15pqPtk0phDOFMHVeHOa0fHF+b1ah2O5qsg1t3NhFrQWZU66/GpwF/jqcjzaFN0hzlpZB3YFoWyF/5z5352xMAKg3xF/WlFJCjK56DpVjioDP+FHVX2yAiWXpZgFqvjaN1pfiEFgcI78k4USY8toaf4G1b5OIh/vjdczEJ0796ag1/7xKtmdeebk+PySxaaJXC2m3FBGF/8vB15KNlpfNtDYyBvnWCpthyDCq9DFb20MqSu5hzYFLvgTbs2miUNCqVMPWR8S1hl480wQGugQTbk431cXy84v/JNhwnOCysIzOMNWUYJ4/KD5kDl8Q8lcN9B+6Uv/lWEmNSyl0VdwVL0km+kYHelJ+6hc8YL8dfFRXIWZmlweEZADhsX/yOIPGsUxt0LIScddsPXZOVaZj+M6qx56iD7T4O435AWPME7PfCWvc9Xy/MIKuuNneDwy1vKcb2HYhWt8W1ZT+7Nose59oGZ7OJntpXMRL3yxb1oLsOyLsUXO9zVJtKB7hDP79Wv1gsA9uOyfkJZQlphkN9VLu8jBtj0xL8/O7NbHqez0r3hK+XGJN5l+vli/gi/SzqmOElA8zJLbadvvPv3MZvYJLEmpnzJLGfyujMFRt/O8McLXzSdHrQnvAg2gfQBVK1UMI5XRYQksyO6Sh2i7jeFI6/7VXxXMiRagejDNLzQeYUOVOWxz5PXilBf2deL/f9GlJhU3UKnGtYzV7i26Gsb8PLISFjDhjwePWTKd97ZR80soUfxWY7/nfl8X1CPVWMxWXB6sVPLTBpdwH5Rfen861jGreGCPaKS+bsTw6w26VylYbBkZsM4+Ngb42iPfmUfgpGAvse+38JHBVrZoah+rV4ghby6aiT7Q56tpIcNEbDt0oac2CZJdBuSJ0twAu404hjdL6ziAWrU4ntj7pUM8W6/bjJDd9deoqG29cAvsE0VdlcwJ26xdw1mxXhVD7CPhi6jAcUocDkWIr4I0JpxCRo7mJGK+jAReRtwpO7dCr15BJr4sJzKb8FLPiEc80TB86wLFLJEABUA8bRCJoHIuQyZQZ4KzsN14NOeUmAzlVe+vn4ZIE1f4Q1p6McWKsklFf3wHuO57XQ4LGoWP+UCuYN05CY4yN+QZEateZwgeZWtsLu5QbqT31PZMZZmqE7C7iC3WBdktwBvCXpjMajW13j9fhfD+qm94EiowzPfDD0N/cax3wI+1idU64KYEk8KXHrvRykx0WfIsUI5TlCrfuIbKEHL3ipdr1OoPbdUcj1wlXHJgGAesIene1HBbCgfkyCbwDzzK9BiInw3OVXbPfKnxOpgL2/sbhblXq1g1qe37i4SHHxNat838CTQb1gYLKtcaaJwq7FQ5NyGXkwD1hoNw3sOCA/PuSQ2Fp6GdJltJE4XjXZ2MPLZ/vcWEoeNK4S+QPKeIjS7dThZLw7m2tJwq/5GGmNMmxFrN3bTNviKz99RqNzFtMjDtUViul9mxWbizJa0lV9GtSSE7BefzrTkobtNCh25Rik5+HTfPJhXidKTog3bknlLXt3+fLpHOi2yq5VJJmFNweHsC6ECppcrb65XhcFPSBQQlANajviqeZCXW1s52DYL5MSrle6SJ0OacgJ3EfaZj93LXWprIHCycRx+ZYLaFndIlgT2gd0IykuZlv0qM5D1lBhNZAbsfHcegkM6thzUXBs8ef88H7FNnT0FNSNm8P3sDU1WL977flfWDE3c/i5GIVQc+apNs9zpAo6rCx4gl4HotLY0WPCtXKWu6rCYsAdqYOnNJBYqiQWGBep/m/0eUMNncGIHX/zAjWGs0zYli3OTW2xy7Cd8Kl5e4wHYvA9/uTKuEeCzDKAVHbkj8TQmGEEKbuL/6N1uYc+ziuIXPzZXgUEjBuXSKVBgcVm7x8duGok7jCErOvwcSBDz/V/4K54vtJHdGjdciQ3/30PJmrtCYhD1CNIT1bkaD4QsO0z/pbzIBzFHUvc5B6jF+YFQbDqbi/5+yzx1nf+L57ZyE9TKo8NR0JTdUJrjRD6tebvsKgmRs3TZivKZpcqAh+XJVvBa3YtIxzZYkFCi/eSQQC3WamHo5ItB3p3iOBSMnabc3q6/W35QiG+C0JbWV0Fjoowxfkx8Va1J7DRwingG2tKUF+OOb5tg3PaSSfq4cF9GDwX/WSUpaV7Sof6/4PPRdvspWBm25t7gvAynn1D3shQUL49AFSts/GSNRWkq/3Pw48Ipy3sKx16jlDIxkEoPRT/aAmeAQrEQJnlEr9AHJwbdq8XW5AXz6Z4Xm98sLaEFBuK6rYdcYfMsgcmKGvPZze31WUZr2SX8NQog35UjD9IjObtcnZWbbObCkc+Cdlb6r6Si8GX4dz+79sQdRnZOqHOIuxp4wG4Gc4CobQJuAxkUIlnOyRRrjImHP71Z/Sc/FPXWO30n9iqwa4H8WCcNM4pAEXZdaz4Dw3iNv7WyTOEcObeHCz7l0TW1u1LkJi/PHcy3kOxA3kYTnM7APc7gnwPrpJtfH331d5q9uqi7UX7p+cyDSFsso0zuTzLm67MQlRX5gwQrREbZNtyIv0CA5NLtp6AGAzPsBrfoLuZ14W/6F6HeQbWfE2Txj1dWNoaEhUfW9on7YL5WQchV2bMJyXdogQXfhzxvvOxS0HDqe6gxc3hdOYrnT5hoMG84QMWUceD2fUDY/PCVMmxppJQcI5/ZbccYNzlhbXnb8uF/wmeFA4mwr4U0bQQEakA2D025Syfdududpc/eZb/Mj/3fi9V+3+pW4K5jGacfJduogrGo1aIAud/mXu2ixq74dG9QcY5/rbOpN/w5KWEqmOo0dFkMcCZNoXjZDRMn5SjGFptn+UUdyqOAE1KolUxu4O8f+Zc5lXITi3xIuDVfDEzNKeSN3FZacCZlrwZfXBXabN7cDN6KkGakTJrGgfk1AaKRttcLP37tgNR+YI5UZX4KiLEKZZzkvNOQ3tA4gvv9qL92wub5mgLpqyWgHM5T3LfrsjsLdALpbasfhYHKf1E8P+WyZMx/OHqcjOnSY4wYOP+BDxCZDshzsWzOIp4drWSHVbN97078jAV/DZE+LPXJT5oqIJY1uOB5edq7I7KFAvDEZn5jbenYDR0Zu/lyaGtLNnofiLaFebWDPWokyZfgFBx1qdRayy47+i3p+ku5t07rKEuJ96dxasA5V003I09eH4u8/dDBYc7J4Uy7cukIzkhkAENhFIwNvz1ABEBtB5sYI3r39aMgfL9U8LnKqwwagPUazp8rhiw6LzsYU5VcRGig2q1rUJc4WClubWGW6dxTgtChc5P/EzlYweJdlK7GZtaXBYsggWdQXYkpe3jx0A9BZYlXrq+6STseZvYOGbSLs9j3Ew1M1YeDgaSHie+uMQudB7HNWNW1V5FFFEdSVbbquwo6CCKZY4TaQKF26AyIcZVy5jtJdvJsb4pCQ+LUqfxhehaf87ym7ALJu6+PzI38Y53nVDu+TtwQFFHdel6QDT6ogdxcJ2VgS89QjXQ4c4QFljkM0K8Rsy84LimjeVGTR0l7+W6Tc7SK04R+ZQLpo6xExtbpCNGOoFQvZ0s2Rg23DFOMBTHuS0PZKuToGV0PEdait6vhEd9WHia9b1b6/wV/MYkZ1QmtfJaYnYZZKS7h8faI9LUEt+XLQD5xDBAqns6/UB+UqLRx1bNP3utm3+54aCaXvQXOat+MfEk/eOkxLuTaSWFU6yl4tU5930QJoyBtXxNyhR2q+PVTEFzzuKsVWkWNucvmNCqopwmuD1IGsUgtfXyDq0aZeV5zpLlKBhwZvqpUtWKu19czeRhDetVOxNoRhmq2ag0HRTjRjkJ7Dd5EnzBpO221+Jh5m5zmLqn3EVK6vOMrC4FFErt/1KuPz4Ks1PnPxBNVjBrdv/dHm2NxjcQKbfYrY6JYXpWhkFL718MeyEWhkxCUovLORzyaOThsZO3cjjlZbWeP8EL8CJ9cd0ux8h9H5EwC2SjHr37XB0jO9iLRf9y+mfEux/e8xwoo5cPp1znMEiDtw+m5yFvKLE7hAD/oqK9OXFL1iC2f327rl9U7zTrrPjyZO/QXOm4x7xD+gD0xxjr3wyLtHiMLKIS1ZfhaIHIQfsvdHoowDZmWxWgBJ52NAj9jnMK0ntPmdKzgnXdxvDeUj+TNWqz2dOPRbd9a6RLQTArlIPdrw+biPHN3kjmlqX6wS8yeUTrqWXZptwCYUnPSmHBrdlBf8jsuTEP7czZvCBazW5j6Iu49BPYTPksr5OyuPtDcyYQvDsHVfHDBGB8Wf55uXTNLkz5AoDWFCvBqUnMa0fUS8GUL+ev3S8cXd6XK22ok9oKAy6wBCBlryqFSk3ehXJIHg/cMQHZuvzDNN317CTHVv2K5DwjDpMsUI9gfWaMz4Cgm6bbYFaWQvi4o2OgK9fWeMNKSGLzfdEXecGLvRe8/mekNogG1n0lvj2cXRBGaUGbv8i4WrW8mF2+Ydns5I5pobJU+/ZQNRB9epuYY8ueni/k2NHJ1XzTEVF7XnIPzQT5mW+SQVhTDia1fHRUDCUnbqmqGqHLHcOrHSdsrkj4a0bIIzfzAkRIkLkXvRLfsf0r7LD7xDngmI8PLdADYPacfVyCZNXh9mVVKbIONK9YX4Un7JxJS+f1iORJW+ZTvoNYd9KMKd+lqqxyOxTZUxJoEKZ26uSiRE/E1DTo3Os3Z9PT5IytKpFxfSm3LgGEOUq2OGpqbEQTrDeZh6hy4fKgwe38sC4X1BuPd7EMNOR2ZiHiH12j4ABLDvjtRkSrcbS2mFPMSm4vjkG50fXgHmp6ndP0PAKmgQeZc85IRPekdYgbE3RJAjoKAUhh+38THlGXt26jkMEqjshER9xAN+rlOMS9iGD608NOHZSzNj+90nOBqOF2EHFYK8/BPRl+kTM21w2nviY5KQ1cmsoRCn67wiF+BLaizU9bWWzmbERYzsfoJN7lPGCKs4lE4ol2acMD0LnSb5FONfqRx9PQ1OskEdd4A4WM2f9SGFOHdk8pf9qq29oOpDqi6H1ZX9Mtl0xaaVL92+0+MzMZc6zVZ4tckBMtvIW0qoqp4A3j3t7zHpB512Uzb305K7MqCB8TcwCoSrMKXp363mFthhSqeWaFBtD/9jQUsG485IvqscynYiOaVKH9BgX5u+oL/5gPrklmSTeUGfHg5R72Mz32sXH+tbe9hlT4g44m0Fb0uAbUHf5eUP3ePFvSVOxybWl0GJCL3vEpdEIOY9xPeI4BB6x/rIpblLQVXOCqRiPOCruS1yeWUnSglz3ZTfKcw6Yb5CruuK3Gn7f5upXlJ06DCDggYUOfmF32k7ityDNJ52wL0TEqLfO2uQwX9qxoamH22A3R9ts4FScsBFbLzrPeqKa06elbA9GKyguhj2D07IhREbCurGXdB0JHSr8teD5qkglYYuI7hbhDVDLrHuFNoZd6x4ClllPmTbqhdEDSAvTRAUvT8cEDf8HiKKeg7vLY4+r5ZASPjIvUxt68WQaYeO7EFJ5aWTNhXVyMufrXjhLCBSYhmCkUc83mlCDk86AyR0jlxE8kze1cfFUogUMVDjv7nWtMjIK43NbNe6InNIu+DwYhO8GbZ/47q5h0H3TXmIbRQH9iJjutPI/12a1jXoXRTKolAponYPh2qfSrb4L9TxJ8OmgT7rQImX3SUgf8/eOSYRPl11ocDmSr9N1fHx1tDlFLFjGUY2UXL0PSUfSYTHbDo/7kRgxh5P1GmTecPESSFLnOWD0UQJAZKA0pMbMQZPm3JGwLlup4Zmrio8f15VCGckCe29Q13mXOWsBp+zfzzn+XL96fhE9PATyo/T3RP525/sp+cQBV18Hq0lAORNb8Yl0snMuZ9SXVg0vTC45P7zwkA6isJt3kWmlqpNbYfCWHIKLNGG1wNO+UWYkrrJYCQyHI9Y7lKaACexyhpSaKY6xxve51O0bwgY1olv9pumKiI8khcOleDSZeZEr153pZvX+xrGNqNeuSl6lFIhRFIyWvmdoTRx7nda5QUUmX/NPDMRo9HcWDyKYlvtWyp9JunV3h8SejR1S5qhGG4fmIEebvURtgFmTid1P0YP9gskHgm1M4roJ8r44xbmcWj0se7KVFE56FsoqE9VioFd2SerU+0Wa5nK3jtAskhcnjOHxMYw1xI6ztDddKWkXZUxqznuN+YSdoCTIOfVt4u/LCobX6wc8ARy7bNqYXAZezjzNMo2ZINMnGU3pC8UO+5YmpWMxvB8RreWWAhfNiKN8R2GErbncd23a6BffWmM+wSxy1ifkVTYwTfZIVooSocba7ODo0C1mqXX7SdAjG8TKpQV8H8E948ZVSCYYxFzj6UlmZ6ODrcB15KlDpqUf0sD/0NFEtPsqivqZgF3u6R8PtKxyKPumxBRNtFGG8SOb684gJfGjVjJik+j1V9H9WuGiIFLatFKl38FFareCTtp79/EcfOGCS9oxdmJ/itR/bfars1O4PkAQsR4YbggeaLcH82z5o25mI4Y6jfrDzreIuPVI+hK5GdV99lF9wS9EUjBr8vhAhNIIipBFcFEBFAQJhj2txWM+hsZqQbyGnShGLy4d4OeM/9BDF3TvM+x64H6w32SRxRT9/pSHBvdxuouOK4BAVp1meisFtKvbp/Xb51J76XQuqTH4nmFzlJ4FJC2tWYHftT9OYFtSN1t9h99CZKwhqfqfvueuEN1mS34IrEXd8hzEka5KI3tHC1GXER7K/EiUegoU5kv5m1nPoMjac7Mp6sflnSuuY10XWm5QufXL4M4JjkhBM4Y6r1FfN35T1uuy+urxOc1RCyhOsZ1xFl7ptFDb6NNh4FOO6UFrISQBQed75AGmxLY5lh/egSNxdY2NYPblwtWDqLMq0zedr5osrr4vJIhO+SbwxtH2ZThnnGqwBwc5Q91+et2dl5i2xbQKFQ2xE8fCXEHnTkP8WN9C6ikvHya3qGSPy+Ho3EWYT3En3AzrD9ryr8ydYYFTV9fK9B0K9FXD6ppw0/A/6aRSXRB34y89nOs3SxkkhBX3DtrXRvTEITlTkX2GW0x8gRN4PTN7M7o316vSUQc9YILuTuMbr0eAso5GC9ZJD6ezrVMYp9RLcSjm/QqBDLy8cE7hWNcl60QjPElE4lPm/T8AUAfi++J4Wqi3SFWMCrrHbMJrJmlhpCHnnf4VmgSjuPLEeTzQ/JwZdA/l6YER9fqm3uSGw6FlahWWZut7e8CUpujfp1nGGBHlinBi3VZKglbxZdDrLfG+ZOsPphRdZVIXIVZMqX8iDnwUb397dSP6GjDQyjoOyJLN7NqsbqREVB3L4sCX5Nih+CpduCXl+0cYaxo/wl3l8scAm/w2yGHCuQwsZm/67UXviLLJCut8G637VvtbDCTz83yHtYatLJXw9byUII3rX1CN09IA32FZxZQfutSNYJFLGzddGG2x2B84Wj/DUrGP25M0O7xK3M8fiWsei/+n4ENUd21jrXD1XWVjOds798PDEIhz/vuc7pdDc77160eCpWwhOhGWSHUZjKmzSgVxcUaSOgDCbN5j8PkJ6Xq2wvDdLPIXI6hEzHU3wO1y05jOqOcKH8D99+8HZJi7XQNJKerKXP00QVPkyQb65xXHHGnWEUPq6FW4WXS5TkzAzv9ggwuoNadMDxcNLx4HGdLPQ6Yqh1ATnXxWq1IcHpzyZhyAbHsaDStS9TTd1Lh/oASM7v/2WRxAO4JIHH/ZVoVgZUT4pHYd4lGVOm2aLEA3xyhGz1qTqzdfohmhFRFWF17DaM4EvE/q5PpeszRX2o56KASMUUz2uDv6a72W6Yiu22TDsqLHDaG60sDoVHEUm4BkTVVjHnIRZH7/oKyOZjUu3orl6bkvC5cbeKTn3VPYSDtolZsLHKHJAj1IUSYvIFdSgpouLoibhe5bOiWIMG0uUJ4pVOQER0FNucCuM+oLskHnz1SAByw9OZ05G///JXSUDJO3j60YNzwmRgRcDjbSqSmhWRLXGpIr2GrS7wN8xTxJ5CJ9QOMkFQDCsC/Rq7wtku+PjpxJ7GmqkURBNGrC1N3DqBr15JBlAyq/rAUKh9VbTzm4PsA4M5gT02IPuLJPbDgImN8iMP90nNuXsBM2PrqJRKrd8UBeMbrINArl6pjBdJu5NXJO0efhevtc66/3bJw0l4eEitmEsEwFdxl2AmDvwNsj30TU5moITLry7rSFUPWaVFuURGkBvEiKDKIoOxrbtWlX4r1ZlQmuLVu+ZFRqfKq5tqn9ToXSrRjTlKZUsrpxqX0NtvLsUcqGLh3dXsM/7l0Xdwl5LixFtsGkEeZvacFljSdWc2c/XBvcTP7xO9NNfGkEKtu7DTc48bMJdXt9ka2pduyBgfB8XLCrVwZjCjkjMXcI5BOk57SGpE9vsH6DK1nBb/SQF6bOZZOnJiXVjK1Tw1wcXdcMC/toGkc7yR32bvVsxAXDEEM8Z9DufcKm6zAUFFpB2doGj+dpumt0/vHYI0I1vSMqVIHjtZSRNVoWT/R832ETQS3/snW7ZkAr7gEBdPxLaYJtc+Tj3eu1mXteDak2LYbcMntBxmTf5inDZvXGSZ9Z8eXv6G4PszMBeqlyXAX+jLU7sefWG7gM8qqFyxIPC5vnvNz4PXAw4BKPSYnXdYQQi+iEcVpp2WbC5pFBorzxJgdk/TQ6uUcO+apJwJ3i+y8qEAGZlEi/K7KchcRYsHDU/cq+vaybFbxuHhtnv+SqZ+dhXidDn440FcNo8K5gc4lTFOqpDTuVh+Yfhbr1xJp9/+7qEJRKtI6in7R53RXyPtuxsvbKDFDF42jihA1m2pJCk0X/0iVpXVJY55gwDs7CV8oXMqFW2w3CkAJ8wGBYKj3Lo7ba5cjjzvz3gOxQ3Q8qXVpzc/KrGsrh0+7/62PCXpUhgJWFfrA5uPyiRVh53/RUnj+EjV9u48H9lmHK37sPShUoaCVs8QojBfHF1wUWwlmptj2NXHKSTWM6joOk907FiFF8gzLGSW1sZokrZ0Yf5ZNEWy2+NP1zhfE7svxBbgc1RwMUrBfhV4f15bmE74Yh4Ljr3hUzJZMY25kOmFFQ4Lg/w9/+lyncvejtOf+58SciXLJHMGjTGI8WpNtVyYtvggQ6fE1jCSpv6MokBg+LGGrQS2CpMySWKjIZ2mZssk3zlFWdARo4UdKcBgrkmxgNqTAZQO+npYM4XTcojQ0A8wE7yMRoS6ywuUobB4xlBOlcDsAb2MWFCT/19HAJdBuJcuUcMhGkt4BrhRssRvPjU5hnFYlRbLQzyNn3otg1oUq53oRF+k4bwffJzuIPNFsC9jDvIbh1RivsZyRda3f3BiKRJkTMe2qmO94jTaiRybqcxj8KCFDfZh0+H8UHLPKJSP47ZxmDTu4Ne7GIOXGzHcKl8KezgW/HriuUcgbXbfyp1m/9jo5mrF/M+YqvLG6E81M5duighChxThTzOcH4GptV0LTExE0z3YBekzeEHHuFuudWO9ACEWPlji8MRHRHQOjojvK+8Heut2dUdJ1R0aRgYxwstkiPA5rl256UliUtrRpODCut5Ln4gtmE90O2wWGKpQv9x50zhYByoaXVmfXqU6w6Gp3UGSbzVotePnyyV470BjKO8hj6gL41h6d+zR18Pr7LYjn5hvwbJ9TUhz3L/vG8iVmniRSNBLHZ2UL30pJXknTrhyspLY6mia/cTqxYd3ZZ6tEUFKbiAk3bKzLpHOkqNCZot0ZDEY7FBQVhJKLfa9RkON9K4Dg23coUdClnL6x5aYV70HsEGuwXb0+KjUqTXZLeJKtAkyuaj2wSzTK9+/uw3h1vF44XLCiHEIunZk6Y/DtTrEehvmyH9Yscx79AXlbt5ssU3wGdmFtoxoOBKHM5FLoVaDHPlqWCmeMp/7cJUO5uHM9NyCW6STmAVT2U/xfU/zPOT+FIBTDw+ZWUxzbDuAyEUQRgl1rVeQOeCMwQFC9abCCTk7nWIjHNmtXelIHML26/WEwLZ6iacmNegyA2lCgyoFmUQopkdDuVuOLDHH0OWAIIlB4kqf+xgzjnjImPSAyvhenloeMqDpWl8XgU0leE2e1w1tk168Xr50UacthflNSJCV74iJUDPSv0NhvFt4ow1mjtxUqoRGxmNZgYYiUBMXU/uVJb1iJxEIDK3vQNtciNcrGvS9fuqD9mOnRuwLDA8pC9h5hfwNCmOA4Ba2LbDTCFDPuMbHPgY1Dg5tMxMzP4VESRHFA0f7rJ3SQTC8KoeJ6KxvgWUaBOOMgPjEjSxnOMqrhl5isQQJK8WT1Um+9EuVRScWEjye1psyzHXR5DF+LwefwhsQVQ9ex8eM6WEXm9oYmwb3XqBve4hljl2jiCSvcXoNZJlfXhjg/dsEdVXN+ZmYYPLhdt1rIUapipO93TyM8x926kroJg7m8PIBuSJ6GohCTn9YahOlE8rvxVp5xkFhvnBtYucjvwJ5CB6AYltJ9F6Cv3AJxwtmkirOcNmP7I0GAoCpx8pX8rPuqpnXDhJ8/VxcY3nAO3U1Oa9pl6toa0hEjE5Vg2b8MnbKFfHPxzmUHchRF+/reABb5odF0LgUV0SKU2Ju4iepaw0ufiphRobSdLIqhqCTXCDq+d5emZOsvfJAHMfo9xU5wm200Y9DwWTarmBCcEYkPz4BfrE9BKaQ/sRQoDF/g3GLn12wOJHz2HEaVwTXKUhyBvEboNA6VL9uZYPW9osX3GblfWsgTlb91vOdlQxNr17CNiELT/QmVUAsfCqptxnz+rZnN8cdEunEBOdRqbiIPjGSrJXfmWDf+A5vjBp9F/0+4EfGE4j9IMvY8tEqo8f8tgtIi5+N2cVy6xEHrPIbdmgkW3SNkBq7oKHTx1jFnOYoxVTka1mWU+4uyQ5aXoM91OQ4emeJo8P+kxTxQbfgOmJ1iNLf5HJNzOyNm9XbD9JagOLJfI7UfTYC0Zkx4m42dHlT/qNg3p7sA8kFXYxV+p/dYROCkR7uBKSVQ59xjVyg1tIA6mwcujJDFjO65062HZEe0w5SVAnswSq38GkpLVtxlarPTUUSFc/4wBIeAeh8jjzFEfFzk22HNi5I43IASASd2V74+4dgw6OP5DgEUa4QHy0vQif0EcXWE4qhtZHYNV7j/3sdHq1WvwrMMeVSs4s53Jjzu2WQYleFYNo6lVHB16lICPy70fXxyHUVi1xgdMYmmaVTEqKLLwYS5UGsLm3NDgkSIW2ykjPtdgrltDHiv2HFwMiDIfbqbgv5z5aq1pPqhqNvckzr5MhrxzxpIRzqEHQ8ku1DK19QT/gY6xS17hR517sPBPKdPjBK/YCt83MJoVTO9gVpYcNmOAMNkcQTS1usPQG73Ke04CUQKDu9VWeCXBr8/n9oLEgfDNXiKRMQpymn+pJIr4mvT2OfamHq0qJY1MOKn0MNu8phNdZ5AGMXUaK79DnXdP4nj+wNv9L6T59EKOnxUgCdyFzi1FGq6njYxZVOyhbiHA9hr4A8DXuKLHS2utpzUdEjpEkysI8cM98g/nl/fB9DbIs9c3eSzJ/rU61h51iQhQWjiDhJwitltVBjQuzteJJKMGw5LeOzy0wQ9+j0Vah7q9nCW0bskiECNjLwbmEMYtKZRKsAiOs6yWGYxPpp+V85eQU2OzxLtOuH+PeTp6h407r7eECStdop3KpXwN3dlaYwEJV/96jZ47yaYEyqUHQVJJIn47SwPRWnZZ/lsyRO6KRZBj05CjB/14D5tcPuseKm9DKgOLjHILKvCmkNDb9la/6dw7kEXtFgkjdN5+Y3vv6/fI/nhVyi1W2EVoxOdPIn6vpNY3QyPZ7VaJYyYVIB0WUxVGQS98j/5y26t4SOiBv+h+JcImNQvVFcLuvcZHRzavThqcVNvlNqQR/DqyDiLpMAPJPjcHwmGmKBpSLlVcebW0tybkTu2rr3laqodDmJTg6Wgge8E+gNI4UEaRI6ng75rOLq/vrKplkY8RTkun/hhCA6YDOz961jxFGtgwWaZ7H6giZmTErivTAko+TjGozvDX+7MxjTWrD77TSNX6w9yxjncltXSw/gVxQstdSH+er1ILXTCr7KbBjDQT7y3eJzodT/buhN6aag8+vRtzY439F2c/QqIk0hlJvU1rd+Pe5o+JN1J9x21TlsHQt80MAyl3IEUe+1gM2PE2d20A6n678Ye4t4xQSqNrISjzqyJm9NVJIUN2hKyFzMk8llCbDgZajjhmbJ6zzxOMGnDYGcikkk/ndMYRtqYawYz0Meg4nH6ADArc1uCcnJa45SisBNkHPrI8CLrU1lqGgz39P9XtKr+Y2TaNdL87h0QDerbUGyF8tOkLdkzIieFyZtMKrDJOTeLzODIPzQwYyqcmkz2Np0aWd71Wban24QW7Z0SFgn2t3kpgVGmmsnzUOmdB2K+mcTk/5DddcZOzowMctj+STrs5kD7bN/sB1+7MvBJWjvAifisvVcEkQMHftBB4P6FjRxD6X+LhdZJcSREFBGNayX4Nw+ctQuhjBQcPyIBcx4LODhl1zVs+F1bMIouO+4V+o4WO2tMHbl7D4lOGSsX7Je5c0z6ctM48IK930WAQI/TLN8iGQ10z8EUPuIkXTG9PMYxn22UTN+qZnFZOdhFzFY9xL+UcxKMjKZ2qifjDIjThsK5oxd2baEmqOFFmbECImdV5epNuOka5Iu/pxidsiLytOXr3PNiSuvbQGjbvHZSBRZurg3kAiUkyKGWM4jGrtnd3XwNRyNnZGHtNDUZQNJTmLctY2DuY+wltsvZ14pp2lZ7qWXhS8IyP4KoBiy/71kjVwWplvTzY5qzDNOznaRmIDaep4YLzqD/EPYfPQLW4MNmLxS5bK9ro4WrPnti3eWkqTprEj1vaHqDQAkBN+qgjgPXURvBBEliqoWi5JWk2Jj3jqEjEusMBiF+vODLTs4YlLJ81mb3+2u4daIXPl4enU9VBQzvlDpTPpacgCUCQT0cYXe1deXWW75KUyGz6g05bbOSw4ZY5fxEXmvEh3L365mfcuBvMEVPmvwhE8GqG9qA1cb3Vm8s0eNiQkRfdKWIL0gHNxIGmoDsavIvLH/mB1romEtZWIeKtz+alk5i80e613lPGAa8I1xmmMzDCF1pRVdWAMhUYiwl8dHpTusa7A0mlGJlrKlEK9dOVgIjeeGUNMWJlDltPauwqpo2kHtO+rFWFoUyPyZYUh8B4vqTfQrm8M0ol0im1YIQVV1EhnqJFNewHWqapcGL6Tjqllzb0ON0Vtkx2iVmUMz3/0YmY9KShukLnCXR9T+Q1em9pMJfDvxNNWrln9vJy4jtzokrAPMDHCJB4BiJF0HdAQ/k821AoTBbgXqKxy8MPYH7gzdtVJsu/yiWErhglSMYybgdZKrzPHkjIe7jKgiQrB4Sfw2sC9gPRJ1YZC2NIMZ6Uuplyc5dgkpwO5nCeQYvatevsw6JxqvtxoA21VSA+JOwulppS93B+S2DRLDpX4AvcaZspVFTZvaeqPR203jj8qG/Rr0vNwo0zlYG24n2hb8NBQvS/XPTKQs4l4g1efCHfJmvN1i2cRV27EHLvLAcsX3IyGLZTMsrKbBIkkzeSZYfcVIAd18vHWD8t7+v2qzX3LfkMZTNNSysEd6NjWoTYMTYYOd1JvBluN61Dqbe+u4oRvUMNK4gEfc11rimVTT20GohJLfGprxmSKtS2APh49eAtPlc0CyVIJx9XW3FSWjjMi18tuZZQj1110NvZt5RixBYhsErXrkErnrl2ynmKPzRH4BkeG5NInc38MKZdDfljCdhrtB3zsQF+8ZFYM6rBWHV7rdgIFMLzKRteCDEX4LQyOszkAatk1k6lxCtti1CcfaScW7i08qAY0ZZ9emrfoDuwop6wS9zaK9SFVIZEqbB8FHilX9lsnUX+OUjDdjbRkUlGc5ghENU65oTeq1USZ4EQN2T0jZlVvtGAsPmD0HgEp5cNwFPRVHqYJ8Pq6u0hvjrkksYG8FZuSHwt1oWiquEHyeExq/hrn57cGSnjt2ylOzL14MA9ZBuEDBcjxKqnw0rZQctMKXWbFEDpPrOxLfS4lRVQ4DE4qMWPeN8zjWeqVDX3Ob1hrWMMCGI97WL9h4QpPDa1Vh3SjfhsmkoiHaqYHZbebn0rt4mmdgUnmrI8f7zt0Obvv9+13shLKcUo7zyQewR1aKIYTpzG0OLzl2hqxJwBpRTiWyvjc1H+Sm8OsSUAVl8PI1H2chYnb4PWuZNLtrcudEAIBsQmsiZiEwE70LrP8OHWRxrLpsfz6U7qrzTAkW76Yiw1gcs8Frv9sBAeMQ1XtGUECpQ99EmCtvFtU2JhQjR/ElagtRwy5R07PItkavIS1rbnjIht19wRdGhoL35GLPxbkXKU0lQDVwlrdXEJ1prOAGKKp7F+S2NBHSECfxcAvGSisT3lXnoyhqwsSEQBklYYelssOAFXx9/fkYScC/abTcUljVPAjHasHvIZPbvPnwhSauHLoQrIjZE2YlZ/B/non8pPDzqEx+a4FmNaWpOISWtofrOJMGVQlOOGq9G9nGWXJ/olCSqjjE10dPpvSLjMeahnehZ/0pEfHUM2ZhcTWpkEgr1RogLTtF8PYadwzW+pBJTsl+fJTQQ/CosmDdysKtlngbol8S/on+gHjyXOlNo8Dx5jGE3aTdMUbAot2S9TZN7kceY5SG3VXwSuFsOr+g9f9KwWrjMp08Ei5flpj4doHOt71041uVZDMhN2lidbT0KV5l6cE63qr2KPmwjlq3mjCytVR6TuVC2kE+qz6Sbg6TQk0vf6YkTdGnKwZ42PF9Il4YIvXxmEYUGgpzuhXJgH7ZHPzgMmOz1Zr2N2c0XtAhzzBTlphRVr5fwM2+m8Y0h8zOR7XSjfsf83Llm8mqNwAKW9WKVSV1vEg++rKhVN8WQx8Az77nXC13p5lliNzkXMV3OyxWRIdmf5K8hMwV02wzOxGVphs683Hrt8Mw2/P5tSjM4SwCXUIlArn5CUohpOML0CfK3T1OqXXUq8exZCArdHU6YFWnLNZL+XAH4FOhyAx+VVfvm9Rkp8+1G0l8ZniHLA6gl7MV1IeeLnvxxo+h4P+BBHC+PyP8C+8RKFk3GJueMFZ8kWfj7t/dAgXD/BcR04s9P40tl2zHq4Zkmmezco6D4vDxOdeN/rG6mhm1x3s0qvciKm3KP0SQu0y+dSche4zxdNFuKJMFbLA9GPl4Tt9GpqVZUuYBvIscQISXzO/yNlIJgQ7TI0Ep/ZLwoCXvy0ali5QMdl/L9+84OEm7msbULilyydD9yNZwnueKsFG8Y5YI3BkCbWVND3DdN48XY2xjc2H81n4SLmAHBFH/faAY9DiCTw0BPHVhj4DnaPqVyZwQxt/kgTEC38v2FClNRFQXVU3jFGxYUD21jlItH56o0JF8LQ5YGevHzcxfZof1/FtMWEQa1j5INPeU8IgJdnsT046+05+Dl0YW8A9Qk77iebPFIvgEOnT4JASdQMs0SSewpSyxs/iKREsWmX7YoDWWw8Vhy7uc41dVNxw/FjgzXVLrIRZb6Ofj8js3O9foFmTWDkAnsoYHzHfME5x7WvvDckcRwA9si7HxvwItyDlqVNLw7ZU0VrvQTKvNHdnaaoGI+gxGV4O5ru7fWCE5v8ibWTOVYnqovj6N+IJ3AMWZyNMrfI9qZ13D1pTwKF6rvb1BXrAEf4hy+oVDtWfzWCtPuPJN05MR3SCoFFO3I5I/oWLrBQ20uQK3Iwy8VKqEJ8uAa2btUNp25rypYXXQREL1fesUJFs+1y9AtegoK2gQHmZqLfPSuSbrYaSEY7Bg899d0V0ufVrZJjWZKelgX6HaJuIlFfTvP24JPIhlIsuE+iGRHC8g+i3pQdClSh048/sT/620mjJLaAYml8XIr4Vwx2oCXRccftLJ3Gz5Q3aSRFDA7xkklHX56Rmug0ONfNsm1Vpcb1pLPNDgkrZM8ST2E9Ed+KOHfyxM7DaEQ1d+2FFieIZryQFl9g3EKVksigyoQFgEgg6f8bw3QpRS1+2nrdRAnpGdmw9e1JAt433+ijL0zQeKfJHrx07tSRuK2h/zdQOB4V11mC418cMNBiCpGq7lEozO9dOEswtefBFbosa2h+o1vtzkXnYxc0+GQ7wV6lhxCuy9o4RXbDYP8yCF4j5p1gzcyBEUEEYekaOwx72Vfb2EUuVqlXdYsK+yfjVv0u2OlNXRNOVccr2R3ZOGKa3/XN2WWsvs6bVUWyY+yfRx/9c3zjZ+NcfQlOLTWZlTl8EUuN4byAu9T247oEDD+TK004LTlYi/Q8bh/Qa+xPZDKKkuBqJOTzRDIxchsje3MP/UuCJiVEYNha8TkPZXcQlltIZy7xv/cse/0w2GTArihEPXAKXdnKvZcDc5z5sLqxPTgFZaGoccZRf2hkN0yWhErkMFW9P1k7zAME2hPTjABiesgxugdK/zHpP6TI2aK1AClMDUM2s07pZo50JmEVUwjKalFzoBYiueVdToPCXM1DyB7jlwD1/hhindkzUU5476vG692br3vvc/1RS9IHoB3CGq6g8nYE/H5BqUClhWRnY3l0wupZJMmyBdE9DL7FtkZq4qp4iAJAOmkDk+v60vZNvyGFf9MFo2G6DIzpdwuyF3Kk3mZDGgyAnGZlegbntyNyFKOy1oVZazCP01kXB6NX/+gxI8mpbU4uHU0HsMvLHMYmojRcDfFyKLmXfHNvHHJAoZ+/06xFJNheBum8+HBmA5H0/2DxSBzbx3fnGRXT5eK80l9Ub7pr4Te4tD+K/eqKP+F4XaiicSjkDwwUtRnJ/FSNRtYJjd4kBkp7iVsxbc/UfRAe1KDzVxLrwhxnCYQqcc/tQMlOJeQ7Ufg872YE0MwUaPTdwMI4xO+eYw2XBQOhK+Wxw9/iZ6MvD0+N98eR9tXbu/PT2H5dIBsNu7xK+h9jGcZtblVrEdQDah7FOv4Lr7TdY6tBs0Z9IokxF9tVlcTKSdgxEArN+DWcQNwIMHP+sC8ZGorSAxNScuiaVuwk0GCpxWTGOzMs+HG63QC8Svr/bMznn1kFSbHGummueGhrybaSGbvtSArZ0WzUfxz/t/ypegAOWZGHuWaPovdd1S2NCLK7+OauzbnmyhH3b4nJNZDIBaw4g3A0p7q6fx4vuDmrOmyvkMl1SJzVqLabapKomQY8r1R+oUgCiuutr32lVA9y5H4SMXBsGnYWBTv3UoP2/0qhyN0SMixC1Xazir6M0CQkCToZezugpOAncGivCaVUYyQaF2xTEjpJOTBrbD7FdWbQ8IxA7OgUgS10RQZtO1uY61fegOwZqUuGKKN/U9dUYgf60Nva/p24Al7eX32sNIbTK7wdd93mf0Tce+9fogT3ctpcwe2OHnXZ3Nr3D8dUAvHMrgAk19cS4ocBI7IvwCRjMuFhK449ASuUGdbIK8q9YeevjpSqfaCDQ3xYr1gxPi5/8JYB28m1K/kz8qElz1W+z8PPfDr3SyFFMqBAxhmNeGE5Ea8/uD5aUf690RdbBo2utL3yGaTveAeb5c9EQsS3ochhomcOZtxn1ss960gs5FKTVZtCRmY/mdj0qjg5dhQ3Q7NFQNfBUZTs++T2j2UG4V5K3ooFNlyE0LoJEKGYv37TYIJB/0TmLAacfd1Wsi8TBDJBUx+hqjy6dAbM6FtR+YUe7U4X/6wmQM81v1vtaRVfGOtF93GdE+bIpGhE2ypFSd4vXXuWue79K9lcQAW2SoOsUDxRKpZqGi5U5PsMnlDkCk7g9nfq+CEHI2mIof4KwIcejTmvYRLK9gW1zrp1PmJGFtffQ+unKUtmMw3Mzd8mUQmXv37NzVMfNnyPCM1vfFwER8V49puBIGrRsclfNrBEsGcmlcG14UqFSLsdduoxeJM/j9DbwHr0wuqGtzxdDOBzSGzV6Tnf50JHbGxqJbvcKhzqYIjQ3hHI2y7syfUMvak3LjLn8nEs5OK8WhiG5FqLHYKMd1k7h84n5NFZJNPpWcbI6zia9hD8dcLhyZPawgq255n/TE/w2pK+1019IktfX2a+VMnltmynYwt9rU7ULiofdvdDvVJalKOV9J6QVJVEwhidkJju17Kti7Ydb8WviRu5TTHWc/3iDwUCpYyye3Pz2l6OC+ckIPA3KtUfuNcSaBwcTYxUiDxZWRYtkKsHgRaW401LyLQZcVSC3d22q0ZaE48rbZnQO13aj91JKTxqxCVizw9j2vbW86SfAmfPN4WN1zgzrxYE/pJ0VwyrbB/mxt42T7CAqIUaKwRdvNoPpoB31u6ZSbByooSLTjFOgdyifpGPiWhfIv2YR7nqYGw01L5UuBrUMZuNnPKdEV/p1Bkk3BBVl9kxqctJ1yP1ccAa4VUKyrIJtKJOqZ59K3fsOd9en54+Xti2toRbD9MbxYl9brnoJgFr5J+DLQ3Tdpu0K1cdsEiCSVCCal+guMTe3CUBjAE4QbCfnTWEA3CXfo9wc/wW3qB9MNiCo9+Oitjrub1lg3or2A/j7kbF6QqJcYkuxRYMxD3yxB4Kew30quqOH3NpGHPDgAY+qktha3q5LzmEK4D0TJnMmlEGRF4Z0gz2heQGVkZMFAwEG5yGZL2tTOlhChsBGSQQzv54FomMoNb4F02ae50SjFdx7H4Nmyxlwp9eYb6+hWE9+dKnFiD1rpBVDVV1xPtK7Ld8SCwnMIPTNtbzLN+ZNjOTNAHdRabZXZzAgHTvINnTpoTXaemmZLJywwMtMn6tF0WcqmdLmM46C65vsttpqqymNjHz7AeUKqjcDfa39BPiOtQcsgKrXWDQ8KIv6M2wRAzwo7jPo8G8TLVE8VUQ3Ijzhhrl/VZxwL/NGiC9DTO8EuPzRqzAyit8lEqZ8dy2w6pBYewO2OCWY6ehzZ4GQU3ZQIvp/4R3Oe97KCi+CPadVhH5bC/GTcRMNF4wxMDxLf9f2U+tOHF3mtdtfzrBSyVbLPCbwyvwHS+sN2JXm5QJJ3GBwSIefK0r+Ewas6ksT62/2zNIih7xlcH2ZwPJ/MUK0YDECC8870b2T+XiDj64U81Kz3DZC++2lFfGkdSnZ/4XB0AepZu+uDwGxBK0tCaL49E34mKUFHIKOBY3ypUVrwr0o5ZwHG89YQ8fopDtMTl/yyXWiUqbnoNsO69nAiWMjI4heeamKlKM2bZNNi7aixzVA8FrdXohwdIqpN/hHuJe7FTEwfG2wnIf7EI5xl9G00ADHexPlWNBsHlwDuFcKPVnHumq342ch7dBlFemJmtiDidch+I/O9yHhYGOwakc1mU7mbRru1DX3X2z/ZAjbm7fV1bMXHELClu/hfFBrI5DnUXh5Rwy4ARwA3ne0UxMvNv12pQJZgFWCopnLMldn7kc45lLByVp/PzgvV5PYdwb6FFw33g9odbAWrlL0IVmtkIeVWOndhlVmEiTk/evaFxpEZ5y4D2OLeTEIWZFtAcg6rjTCrQlpZPNoC2Bkh+EIpMFqznc1ezMep0CjeeNr7bXWDhU9gP4H47u0OHwsZINiswP6Dstprtpvl0vFQowe4pIcHmEhj73KqFJEJYWdiSHGQAvQRHmOJk/cblej6leHpSFkqrYCNCryb6CAogI1rbkeEfMzblrY9eddVbl8mYJgz/KhrFSJGLFoDYkbUxPB2kxBV/lsoqvnib2w9cp8jURiTlUlcUUMM6h1NiApXTI7m3/QkLT9Na4agdQhILOA0y20qjbmyYe34PtqbifIWSbIQyMNSBvzSuWYRJn8f3VfxKmU/HSo4vIRlsU0rpI2mvnFcFoD5JQ+GN6SvIToQXC7WPXUmI/Bf6cvxTw/qy5neHIXZ5woCcABPUpd0Tc0TJXOgdgZAVhyQNaoIQqD2ZdKtpm3n0B7OVR52zelNfU8vQ1C8Tutf9Kuk3yHLC6v2sXHZj84EXWLBRO0hQLvnIJ7momedZLlNHaGxReIRJgGfMjPQaBOrqXvy952Cn+3hOd80Ht/0R4hwro1AvtIDsLD2XE23RBJ8YkH67D04PsxiRjKEbt28oieoMSbmDGzGOAHlQjIF3TmTO+8aAjODdptvVpmru+Fpnd+ecxu97neRUrslywxfoOzNNEz9GWPZI0VJoeXTaakGOebHaIXviuVWr+4K43EsgLpuZXWcId+PM0OV4hCp/KOfgFQAHEdXhlBQGQ5hF/nTyrs0GvNZNjnVCC18HRDEh8+oWn0a9/bTOtIdkPFn+AAHq0yDig2fmaOjnnwtjhM0VGK9EfOJFWjvzVe/3eWuY2HdPlCbzSyTbBygr2VM57QpsN4XElIuCcvUlLXTN/aMYA/WNUwf+hP/BwTN8+DqZhEeCEwAT/zJvHbwWvT0NtlegL8oAJQyWUtkfrRoBWmELzIuLlTKwkVU3VO0BOFtBKwBY/TM3mIPM2hKlruqeBB0u7/9KoD1wz6Vr+4FmPzOyEoonHa9gaAe1DcV+hhnCC+bxewMddNG00s61QxNrS+bwLNjRNPhgllEXTrLnTgB8olnuKdbeXbd4pRt1ggfrxwD7bSg2BEtO79TQryl0/7vfnFh6VI+sCh1O5rYKmLKkjWfVKbZsmZ/7IlwUWOmXwniSPaq67pdnLqkzdSyXb5YWUKcHaVHvZ9yRLozsOvxKso405TPFfTRKYDRHkhqKkSiUjP68VySkmE/mehDYG1JFsnOsikqRQjDxetNNsPDK5crwmC3irXrDC7Cwl2ArTKL3z8kBcrIaCi+arcr75EE83l3eBZ22a1CrSOfIViiJji9paU7D+dw2NP4C/CHmGFE/welrPlLLtlxKYIWwlmdNLurWeDmD+yOA70sK1T6XmMqjgLdYU/KNKk0jjDUx9fdKRF1sQKtJU86SHwqxdKGs+OIHQZwPSq1kGWA8mMo5lOoF9MZEp6S3dVguW166KOXFb+2bS15TNs9V9diYzgIVL6jj5BRrNlFRClr417peALXc7ZPxHhhoRtN7oC7624oIf2qdL89ZLniPbluMtmUVyDQp5OnqquPPvKgB0XorhgptwAlBJMbOJsD+AjyG1VHot5gQC02W9jglWE8CgBDMZfflQ6UFrvA2nyYHKPtHOLBs/rZdxtzQ1fsf2+M5S9fE2cJYebXPA48cDAUBhlWZeUvxXujRlLHerXEQPx8zzC3hphsV7nH6TlkcpkTlB3/LyGYEqfsnlSt8mB97nrxUFT0Kq2zfEJjKxHCUCTBEU5nvGMA5fB66/wW51vWd6EJDOcIb2OlycXgZM42y1ChFjKcHK0aGuLe3uc8d2ULdcrGIKnz9BtBRgVV42Rb/BJyCDJRSUUk6JQB/6a2XyIwEvVu8W5w1/wbftqG9olhTkxmmy9cnBtluas9TGEgUyEthfbHGWuWyd7R9hvn8nVtVnrcTTM/UD7Qw/L/dyOuub7I3R57vvnP57oXWMzjV3rb2SdXEC5QFKMu9P451cc7ACUdP1qquTUTerrCYlhe/Yxw1GBMuq78Wbtb/df/8Og9+WBuN22iRkVkIRpGQjWppGHHywT/YLK6nviN9Wr+1zMTUsSlh8N5QeMcq2ZrqLTxZbt98XaMedYaAnwCRgp18cVc7nUiJVj763Nf1h0Wbfm7UsERcWiDLmLr1Pj1daTdQgqGzYh3otXKkV7rqSRgApJc3JGwuUGZXT9bSHdE0aakBEuRPQdLGYyCEmJQZy3xcix3B0vb58BG1avlxqr1Rfbh5MU9ZI+RrSWjBeMwYevuBH6XJHlEDLy5vQHth6LuQTzw2TFm6TCv9akzTQTep31V4IrZa3HJFAQLL2WaZGpK+6PTlxRTpLYztSE0/NLoRi63mQ6u7LmVEdfv73ProoUSL1TFQH+zsceMhsTFT2jJiXk+rmaNlwK6FqjDRoqCWuJycGDu5NDgr0U1iz67lIat5AQTfhbUduwbeHbK+aejEPevlEYbtFNaQqj9F0S2wNWZyKz8fu3rUUTq16qNf7yn45mdaQVk3SuW03AdX04FaMbt6zgdc3Xw911EUnqMkWHbHqvyPQHZaAtgDY5QkE4dE9a7ZJuPhnOLXWZldOqMY5ft4fMJeWWkMjDXosJXGhiNEh7mqI98GBWYtVXev4DrDxbYFL3F3t3TWxX4WJD3i23XaZ18L9Tkh7BsZo7i96lEX83EvvJYMMS42SqhaDfEFovS2V+CT6xOVQEFGno3n43csOVIzZ984oZG9A6/iWzx41BQ9wEuBdZw02pv88bIE0b6p0wr9V5hHFEm/OC21WC5bDb1Tsq/lWUIJ41CIhUsGLzR4WZIpvk5J3e9IY6KcyqXBp/2qSkj12BTpLe57nRdvt3fZunpqa55xdaekTXW8HZEVi8m06uUOL2myDd0TOmTtfyfgVPjZJiTbMDEsrQkgyE+BY5jyoWGU9YlYhhVv7wqgpcytgmW0fG0Nw+dVAoynaWl7XVjHjxB/qqpHI9dq0pBn/cppNWj/oZQx8iFUyP7GzdBwBnq8I9bb8zE/BgfwP1v5Z1+EWwkQvFar1ZlZGG64pw8J3qYUMUStZgI/w09gQr4ctmCkeSKcxjkViHpDB6ic+4QKAVs0m9vPLdvUbpjhWXqYQ2SXOg2qmmCtHq7Ri8QRPpaJPeXjVMT6nHH4QFJdX8jAnQPQ4HxphE9HMFheO+MzMZgeyCX9SQJfeIiMxYGkFMpfZ3eJTQjquoah56IKy1aykJGCvkd7LegoE1zGHnC3a6rGhantXG06WI4eEmgDRrGgx2YBxa64NEg5HPCdWyKootMNYB1fschTBralH72X0r2J98OkTeV68HleFYKN5KByX+oYCJPCGoqBl6CuIWdf6nAKVSS+A0YuJXbcy+QJTns+k89Z9+fjAXFDKsjWE6e07PQJU8JirXS4oNh+lZPXeXfk2J3AK8VKWgPIBvP84meD29HgYMiMfTBAYhmSbjEmH6z5QjMMZZiVebPUiXVhWb9UHR9gVSu1jkl53T1Xo/negp2cBOKnAd7pKNLlP5MLBiT6gmA+gQbVrXVuIlx3cUveMi+F7Q1HGM+7V1hOhib9MBRaZDKXzkcU9IwQC91tGN9AtKj3fP57tnKIP36qYd/ukzgal36zRNRcMLir8V1CPjp8fzLTnCMl9nHgRag69tHWVb+wzPX+kLb5frWYXlM/mSTEEsmxVlIi+/Tr+CzMqzKrhCsPvIIJV/wNjQSuRgcxf2Sv70L4ld28zN73QCYQkbkPvfA2gUos7e2+ltehCZ5xd5Y/0kIiBA8KHrrXP5tSj5mVjjmaPReHLY9DZ0FVI0rFzgRfTtIBOw7whM+L6XnZaOhh2mvpC2yXbiJ9dRww7WnkaWNTYpmUJFxnkiG+BVwSkoVhYAf7HGU+QXnpo++wuR1Hj7QFSthzxzWjX3EumZzx8PUHTTTSOkhB4FK3xG/szFF+HrmKdi4vRQwVD/dTrBb5ulmoxCrtL7+d0AVuGg58SsrY3+7nEKqCXxHpj6m8IOzUM3UbYjSIF/FYthrwF8iCU/Px+9GJ9MOGJ91s/yMfYb8Zc8lwPc+TTxPG/sNl9xCX7mdQK7+McH+J73HrSowHOag6+A2GPLCweCcBua7gSJ+sKnEOYGHWtLaCkfoj5ATkuIFZNwk/xjMw4m2hLidLFUwsRl5V5SYRqBux0Ce002L1hL2CWDu/VAGFbDvsTGGDe4/HQkSuIrhn5c0n3AJmZ5Z6dqHo3o6xU5q96jIAt/MKObUl2M/tnTGiz8Mtsd8PQkqapcDzJUDbNJKaMqIFTOTCfC3Gxt/L2+75eEm72FTBEHeCfAjzvgXg5V4uDebr4+OJkRSs9Hoor8Xjts9zFiCo4dz0at+chXnifiu2ZCiD/oE18oyArYX9oOx/UxdzXUH3yCLIquZhicvY95ik7ovCOncDQZRU2U1Yl6RoPI7qIQGvooj8o5Jmu3O+MEC/PbWv7a8Az2F0+8sRS3XurxF4eYoVBjQPkWvL07NYNXxydPhLdxO0pJNtS5a9otd+7+KRKAjbxpISgg9FjgLyxfX+6BHGx2nHzevTsMM7g1jfwmABMdipSfYXqnysyNiT+KTs9rmIyXIFHT65eK10Q07TA/Y/20L+FTrQgvS9ieUNIRpd6c4lY8VpBiGFvL5JGhMDtaPnqX1zwZU8PVpvAt0gjRSYgael7S1lbeuThtrLVA97LvDV2h/JqjDn5ALzd8WUfV5z2kKKSLmS75tw+Df30X6qF3oqraZdxzxMLrIMwqL9AS3MvOIy2lByb/7XcIfggphvGiUV8BKR7iuLuCtBLvaiAPKakSfPc8gSnNeSC5X+AXgJlrzigR4K6N7mCPA6HLM70R6vzdGtBHdwjmL2NDLWYosEjuHlyIhpC0twV+55sy29GioVk8+2fyJ2chd1qDWHD0SNqqVud7hlVzufbeoMz1tA8KRcvNEKMZ+PUmBXVW2Rt9ZAYwwwXLAPMKNRcOa7SZigJPTokxdTrlqCO4SAeuox2FYiwlXWH+sKd4xpAdV/+9CtXIh/Kf1AbKSe7QIgYP5f4bAqUltRoRZGG0UZV3bdByKU9R8m+Puu7JltKyluQDu3Ew55RVN3rSipknGbIZvXlaNVEMkhZGnXM5QhlsSDKztvKHssU8Gu82xT/zd0RXyDfCyvqg1SdE4RHVADVx9l5wzYuEGRYKxnMaGzwNMSSsPS4cryfYH1Dl780w/3jHT+2EP+D/N5mes8y5LekyEmIT9ZIzVd2Pp3yQC+Jahym+N+cDqV0qLrfx7S/C63iozNjaMdn5TMpdk0hqjG3uK9D9nqoczo8xqVnTMrOIpH8DsNi4AgNJUEuybSMilNvu7t4sHBlp22Xyr0NkYxvwWYE7I7tgnAptdbNcpJhbpHlTLmv+wAQ5I+5/ke6M+9gg9dtoclFeSbEXEWuryROkZ10G6zIv4erhwmRsoZ86CJExysq73965O+N+ngzIfc+LubIp1TrSV9jqYovhVyCShwsr9nH6Zb6xxiTAXQPnnQBW//uNzWtRKUYQyOJ1h9o3toqEIkltJMRi0d3mdFAQRiKmJZuCJK1RM1n0tTLghUNS9iHkneTA/UR0CLM3AdgdqUqN1SdK7QpaluRWA1wq5tNgGIPU4/wA5IhOf9pXOCEeEoU6OoYHRPyXRssL9pww8auuoiXUT/c/d8dm3frI3oXB4HpMvc+amzAYCKfZNEmXmPzqEaMHA4PTqYDTyooWY4CvwQO+U/7gl589TtEQNmCXvh831hBC69Tl+d+6ocaUun3zF5SNAfqh4trUmIqOI509EuVJlqAMqHuE6eW6SCMqLmmUb1PjxNeGOVscikYW3PQPX+a2AVaGeymvALSK1xlfMMVx/MVL+f5Yi8qSiYyCQbX6ia9ytaCfdUl0QbS57MNdgfXG6aiqAR64sAoESaM9k6UgIENcKoN4KQJoJ2mATJb4OtkUlfN06nCoHMiaclpfelX0TBGLS7GyEehm5WrlOgBgv/UuRM6Q+2hABHYnjhL0Aq1q/kXL4oF0mY+S+kMLpentAA0nK16yuQwCEXOudlqWJexmf743QhI45x0HjZoMrssdC0hAWxE8uSTTuCOwvJrg90ezV7uTpsOQl6LKeFwlDBTBXiqijbJdwbLI8HZWFfyP04uUZzNyRPtcxjdg6PhYbigtHtFtIXDYiOHyVZS1KXagGxoDIsBoFfuzoMVlUAvsM48hh+bjaz0KQJQmXUrAuUouPgfcsX5o1reUX3PI1BRifDuCn26P8u3Sc93IhVTix5lCJ71R3ZmnypMdaLjagwhB/CvEuQnBHRm3DdFXWPaT//DTFob6PcX8vEj9mbxQycXEQh+FvVCkJ6HTEFj+tWIzpCRaMIIMtymeaOYVWSBEUSB69TeIMz1P8ZwVTuP/G78C4a967ko4nn80VmXSJZFIy7UDE6KjKkit2oNhLjOfHWUzRWc/ju0uS8XhdI+ieMhsiOZMqC/TAdid7ePuLKPUTDjDZqYsS+berPG5AcBPDhrxZsXJH029QoHOH8zXBKKbJd7W44SgC/n1wdtYredSEaTJP/Z03bmzFpZhJH5lnFvmWfGvlqwVD/rN2E8FMhphg4N3QQBJ+RzMmBfeEPj8n2IYCbGX68Mvv9ZA5vfcwtrbpz34Oo2DQYli/pd+im8MdOz/W5kH+C9eHQZO7wHqEZRzXZZjzM23kvEpwQXNiC76Pw5BIIVB4O+FXzo6/uuyZSV+cyeAIOwVkqQ8f6g3tTqW9kEtsEWqKI8B8kfcI35Wk7yF4CWZ4z9KMSoxsMlxEQK41xyUDAsjurLqdUKZS99OYGlJ83kl7H7cJFw7QhMfLBUMmqzQ/RnEuNgnKxmILacH38I4fvHXaZNBhST7h8lPdDwMxb5j2tlndj/Y6rovxUxW4ot1h1rsCAqkiDJAL4X1yQf3BkXSrsSInai57U2blCNSK6Tjh0lw2zOoLx/97ifR13kEc7Arefz/e37BFrYR/L7Q0lCcAgr0IjavpY1GgJT0iRKL+j2f8trZUM+qU91IFIOwGnz4ebOdWkUvhsi4OaAoba7lWDmZnBEdeDHny2dSE9qJ0W83/IKw0+0XX7zYNnQl/UP8YOQQSSdz7A93HXFUcP0+HIy0WKYPsX523+7dIMqTI9G922IFDpGlJnY/HHuZGCvEvu2d5/gVs5y+lS9cIkgmHVvqiZ9gkzis5Kz/s/wMelnTa6bAorKSCpH0LZyu6nkDXUG2u7f9LRgRvotde++X8/AZ5MIQt2cu50A7wULldC9VjA+FuKQzKgDYQf090AuQLSz6U3fpcWlH0CK+Ycoiz8VMU8HSeaLZZuAe4hRB586YCGNh3j27QLGEAYSDaToSb8nqMLA9iSzC1HPiYZsHhHADWcQwy1BAwUhTKZdn3BtZhJEHQf2UD6F5F27FvYtnp9fM5hnOzojJteYtA1R1Zcdk1mUNyE3UCUGmIUOidLUXrOHDEJ3Z1X5j/NZUPKEMLZoEdDuZv6tCpfYzrInMEYezHVptPHmPyytij5vXT1+e7/nm1Jyuhp64qkTu95THxTlnmoV+qJ4GDee+GbrhEZLu5+JmAEWyjjv7GmPNF+FJh8D6C8/1pFIql1wZ5CZKjEvrQIf+PiekKQr7hjSzQqX2/5644vKWytlbi5ZaFTc+GKOqgSPgBqQ8bcjpFq0dcL71neXlwE0z4/mHutfkh7IsLeTXKqg+1iLHu3/oHXg02ZNnOAM5p95DOgU688k2bxnFHlQwOmliwyYfk/Y9kWlBaJ5TLcKvurcbPJiXIvR3kwZVQT9QCHjhbQfVGAUUJR4fHwRF9/66Nx8lnf8DWybNMivlTDbMC8IM4i/1uUgVY01uQK4/2KVk18QWHC+LmTL5QDHmfbJ89Dvm72GF8tfTtWczBRogr2jhE0xFmPRPAFWFwdf2sb0Fl1iiQw9xzdP5gv/p4g3hBQmrAABu2sxGDo4XPTOtYHcD60USDdOidA7UKsLXZyGSpNcqgnvsw4isWff+pBhX4LPx9YtIgTuiq7bsoXYQA1BjChuBwoEZTzj+17K1dO1mPq1AK9ffV3S72gUgfxTiaVZEOfqxB/bnovufqOEk/OrKh5Cq15A6Y9m1sHE8MyUGR5uyFVFP6EuQcJRqHbutqti96rt2dKw9F1+ian7WdymMGynB0RThxgWMtJH7SKqppLlshAwiKimOBABrcgK9nHF8JRHGHt+1M0uETmxZfvXGqpWIeD0NbZAfNmGDiTnr34h9E/HRmPhNjYo63TDF+do5HJG/5fANL+X1yOQIogy/9lkJ8+lKGnVgR4JtnefhQGKmxCV229Wvv0VRg3f9X9+IOAqFe0OX7sf3t2xjfcF4u6D4y6oCvYbW0zdLgTnUmIzzbWrzLPCx/cEYjKEU3jhznNwrtoBnE2V/9NomjWvPuDLvawfQ1U5S004bC34V4nrcNGFtjZlzKQEMnx5EQLG7R6Z35YfDZo34NEnqlm/DdQ1tO1E04911SMPPrc8/y7iKBej8FNLRErA4Hem2Q5t1AWoaQrviqKWZGagmluLnl2vI/3XZjwWNasuqLt0ef5B3XBeAFiUxr81G1htt8MeirKsJ7yHvs9oiB/uNYYEBjfn2xTu3U+mlo582aFLQNoRDidazoV5ZWFD+z5Nylq4aCSKYzLLSg0o5Zlf4Yte6q8+YJqAttxYMi4bBVxZkbGfLNm6uw1VRTwe8QyZoDq7vZpU9EC4wZs1FkwMqb9CvdQLGu9egjB6E8cUJzSjjj8k3uJih9Dwanb3/QTmNXE6t9Iw4m9vlUuEsafGU3269t4Gg5hKaNzOrlmecjMYuqlMnHysaDpIBboVdcbvSnvRL+cpINL53WXpWFKaL4mG++lvZmauQrzZTQajfYZTS1hPR/HieyZ0lt7KLHL+ZnJ9u3ENk3WajkmQxH+sccI23u6Ii7Bpwiwxi+Yu3mOrPL25iKIMUHM3OAEwjjg0kDGzIrgUKWbaaIBrR4eKtnKCtgTalwR6diS1JxcLIB/ElacUjIGNeyWjOGv8Cc8SWJ9B5xvPyGfUcQhlE+M+Oz2pWsq/7u9ss60IxWqgQhniXhu8W5U6yD+n0VXta56k6RgwyMD8lBsbiV1wplrN+0CwSD01hhC/t5F5ns06Ns+Fr1q2lBJif5fNNq19zVCBKXjbqQa3ny+THpV9YWb9t3MAI5/Bnp+MQvqcJc5NY5ygGuF3DdNNZ3oLgZeY6J0MdeEEdv4eKvsMhy8TBeVywDjhs0/4cjrF3Thp2kXMrjjPaMx9g8OqKm4WBo+gXQG9TwLN6rQQ/yjiA+WwFhhyBUQUcbcxSnU4DnwEpKyfFjAlIRb33VzBk/pLYNkwk/RjXmJg6r098zvWJ/5AUsNpdC9K3AnGJMQP4DiZqRjOLrhpzskG3Ez+KoI+8djZWSmAfu9n2jruIF1QMBkYAkmGTy1WGv2pj7WZRx0ycB1f3vC8FYmkkbyxCNiZxd8xMWdUAAV0FGtXwfYsjCWr3PjTzQL+U9BP9Nt913k6q3zp3ahb420vQ9wIYdcWoJWmVsiMBiAxmR3tFJag1Ymv3k80gJlnULls+KJLXs3lp29Lc98Yt4myJ3ryXLfZLxSqb4HfZnUCf4I/gPkphw2AjQXM48OpVlb0eYiZbltPvmXaMhNupFV/HXUG6bTTvQr72wr746wRS29WM6/X+MCu05Y/iwIxeXyu4Aeo79SgyWUhzQ8N57ofjA4Njp10PS3OsaE4vgr9qfeOWbGvVFUh3S0w9qjB8wpObkJ++lr9coXU/NPYY68yZrwkP/Fzrtc8bmjuQ0OMFMhfJi4y7nzahb/83xJ+2W/tP6kpazDckovYeLDh9/nwj3sI+zt+iaqOZtT3STmMECKZqiEz2PwYV/xWzKLbAQUC+veur3EIyeMB/UEQiwqV8YVgiufq/FZ6u9VQbSOKiw1AIuMsIPzNcpPRPfz+B0MAV4VI55vK6Cvmtrkt85VxcRv9HaPiBlYtR3awkr3pxNzPrTTcSlDkOzb30jfaVnBVJw8FSuSzWngi9nq2dRRvDdaieMccEau63Sm6p5w99E0h1pjhZ68DMveX6aY7uE0RELXJeseCngCZRdhCg8npLfMueMo8+tKXVKEUGL4gtOYi1l3iagFMw5M9UkbjwWigisdF/5qpO2hb5VQPqNj+waBKpY6ZyB7setI8VOCZ+/Vewk3HJvQM8p0yd5ENG/lkOPG+Irui7k79GjWQDJ/RdlNDA32SfdDcpBrg3x+XFriaeb5+rpgnQQNCfSHgXa4LBBWnFjpFkr9AnY6RjwcFL3e1+rCBLvwpqcDs9/xIz7/HAGfnrKZt7Xd90L8j0S8E0ZKz2xHXBOMJ2d0k8vp4MVmB+C7dhrjvIyJI/mn0YKImFSBYbvA+v3N/49hRsc0JlT75HZzIuE4iBNTUiMzRJoqfkFASTB8ZZJa5F27DJ7ltM8U+cqp8s7i/FFpU8UVVAr7tNzB3cZ3puviCigox2xRkdaV0lRz4dZQSGR3SXCSoQHf0Bns6QR0VBroCl7G+jEL27GMwSMVPP0PrLWX9Loks+szC99+gFytdP+CiTkkbxgYhid0Oz5yeIp1hospvWJv9n0xNRlXsG7kDk1Wnt+0vs6+kwk7r4I6SrNOzD/zVaNP/uaOF5d1tG5TLvNRI+nh58Y1cuabvXssLKFhD68J0wN+bbHXT06SQnAMAH7DDPx9kJ+/FW7fUZCpcIRWJvmWJYoKbIEuUQXs/bI30UO4kByY+wqxH5kjKbhiiv/WJdyit9Ht4exRJthN73kMNpeUGXDfIbjLaUWNqXvlVIpOst2bS+JZIMVUtbGZqZ0xEj+yN2Ft/p+Q5POnTd/0ub12PRjs8g48Xp8ksSwYcaXyneaZdgpjK65vzfo0FxcQ7gFqpToejdEi8jRM9G2JC1qN1TWewjnryzVu2xF135PRBPtiRBpxljI0u+P27GNbrmMpR7ubwNE4qsHB29jRildiT9peXIICceMTp9ipJUYQh/nHMX0mZ4IoiljbQVpV046jTQMpn0Atld27XCtd2e7/J6vSkVzoZE0s59MeUPRX/07vmHeofsc1yS48sp5oqQO7s2rbo3abf6VZcVbsellR0fa+z+ws5y74pMYoenNmLJfpfBzd5BIhUfwxuUtSFdnp5gM+njqA74CddmRt0otgMaHFbhaDTMqpDV47fcnpV8RsUgSPqMR3YOOzuaLmckpudYwWRGYKa35ZI/4UMVUN6/uB1bL9X5nhbROwWxggFJvglvNsUdubXORt0O1rwknGatMSGzCBf9yvAV56ZI2o+WbvwScmaj1xyASrY0EX/vS3AzCzCppWuRHg8mGVHbSmvR5RIF7C46CAsHEQ41rXDW9liNLwBgZFVSzjvrGWFEy5okRaUjc2guYNlA27kRJfCP8EybKfHZRoVsTMbBiQuZ/ZQVEIoCKnyjYpJL9DKgMtWm/V0iyCvXpeSOlG/vwToLlRY+VtCxF8b+a4hMM/T0csb6nA439+cxcA9Vu/ne2lZVvAAl2ZT8Wuwz3l9xCOvPQqPhZYzqVy91mKnKyO4HHJhRoZEwj2E3f1ki5rb/pHvh4de1I5iwiPDi9uinZgdEd00xHqb+zsJWZ0lK0du/qnNtolsEKY5hYZTcvt4zR0elX2yjNbcAOdvnxJ+V9av6jMCe/9Gfzp65XPrtwWAasgACqcUbxeK4PmBs/GDW4Cl9XXeUwk4gMOc3G0PHTjERWHfEotB7yJOYZj3SC4mzeI1icma38BRTRbLQTJarifrmq1+QHKYNKYC4CFGHXMjnxv6gbSbW3CCFEDi9pLFDlxL4wbhyb8QlIFha+OGwDeBU4oCUqJwYYRy/O5BtLsdhMIfM9XQz1HPhXOqohI+HeB2iYTP7bfwf6jbNOOobwV0IaQPYSP8c40LG2yitMeGW9hk12meFo+HBm0jSZlX03/L4r0mftH9qDzeYo0zu7rmTluUqKSiBPW3y3tUH9IOsPlVpQiKTfgRYxwx/1E4q2PZvjOfNRvq4nZONlKo9l/rsRXAn2V1bYBeozX/hYzzkFPfyD98+Wtx0+v9L0N2BeZLgg3yV6/7cpozQnc4zW1Hdvy60HbxO+b9GE6IG2G3hYfibsD354xYJEhPlvjylVOW0MXG2EqcpyBnmpFYo7JQlGejEP5P52v3bUDzg1vS6b2ssgGCLbpQIOn8OOFEuovAIvOl2zbXfJZHmsi6uoDLFjDjLMXX6SvCToi1cdOgkZsqVcjAI2IdSDY+YwGfPZz7Ia9ijOqDbmPURClBVecS8BsnzeazWISljghAlAo8mgtsauhYKPUv1uIgWwLM0Kd2zO+pXOFaeSriW6YhKqnVA4NTWHnY1d7qyhySWkAR1VpDv4BRP/AwDeShIROe8nc7kNSuurgCeCGcxS80xCOrqQyw77tp97LTGkpS512AxEXtSwUpUfJOTd/UF6HBSx8DfdMOAozf6YkrMGkN1oL6Ig0miIqXZ29P5AqLXx6r8lQEUzCk5RBJOq91v/2nu2HLgmdjy5OS1Kz8k5Q9wojolcf+V2rxW7Mnw9UtbGSf7Ps9PstkrbwkNp+GNuOCdRKPJEAPPpeeR2f5tiMHJ+4F5DLPGjI65tM8bfZwAi9OzGe5gy36iCYkR9p7x9jKFUdPN08TX3QZnkdoj1dVWeTFipUy7RPUDLFFPk3N88MZ7uVUphJZHYwZ3Qv4Qr7xMEk4igvOIN98qXiUQ2QMhx1dGol3SSN8rSgqNURUFa2mVVESR9Iea97fdy4fgBLQ2IlCLdmT5USa0PTUdIw9WEpSTSTYXnPnU/zLc8kre2FbnPx2ezeV2uzKgHWCTXhDIzUQBLJ4lrV7psGiu0OjCdUF/v1E5vheMDS+GGd7thwbiPGhd+XNqjn/dke5pfjbTVEIfD9qPyrhFChPbhGlaT/e7kt35YR4ztvdIyxIZrWLiQC9eytT8u58fVSOdjMKGDZjgF8qRiGgm5wrIqJEWhHQeHqnFs3/nUXyA3A6mdTgZeMyo+AYFhaZUXPz+2iQ3dDyVgpYc/W9UYHx2EnTBwAOoWmKzi0jGQKSkxIiv3DzWnq8HkJeOeNPZxjll/FRf8RSy04EmQKyZ24d+BXj0U8kP9X+7BaI+hAg8azS0OWoOjzatXqNdZ9eQxKCPJ2J0BvrA3y+uyR79sEKBksa6UOedz0djtwTQoNw0e/UWs0wBSEyy9/RnfJNnAWmKKj/i0XZXRv2MyN/oH2vVrHH5Ox0S2SgBImHHQlY8QQdhByDIcRRV/u/eubo+qtKUe88PUk2Kvt9NQQwXlmLiZrSpuvh8MHxgtO/na8qWdrFEIx1BxIIAOURDRbgDv0a5j4ppAGnDRNQsSfYWMVi90FjvWWRRO3zajeXx0fSBVQW+8JD4Rg3KFcQcH9tPQPCZa4qZEb7hDeph3IPx7JRfMcP/5ZtizMGdbwHnz/p0jHBAKil3EM01gf5jRgTvjwQXu6z8jd+3DrlRe+uTGE1URCrkKII0TSBqSCNN9nJ0g+oNGPLI9Dm6SFLXxITfm4Ql1z6Cn6mKIXi4XrVTcsERZ0EXPXI7dBWiFRsr8MtdGW8wgfQTHZiRfaPzqyd91Dlh7qckxJqWngDBBTN6HnzSbAL9b5aa8agLYzxRUyzFJ/50MNQMVSg/5sF+LNDFD5DbgJ5C1gZ2COL/hAsRZN6IT0MR/z1gvkxeMaP5yVpl3FPP4b0Z9moZLF/aubZuMgeGEp1BZGUS2QJ4kLjrX8shdKtqGmfOn5VAvPZAQHYTuryxkkUTjb1fvNT3OfHXJVRRm2tH47zsbPU2ro2i2kxm3q7DurMDPrZP5UGB690Us5L1nHii+wP6LYuwlpbt0I/9XUWNhVgDfRcBSxdxyE9gTQ2/v2zaQWxxdBV6yqdM3kbW3kZcWlWfXAaZ6rZq0muqdxpEl37OIb9hPIM7zD9xpEGC0tJEsi7mQDadQ/BwqmUo6vnPSD4zx+OnYkA7wBSBVffWWC+l0WE0lc2ekoMwpAY4XYbrl+tXTbUUd5BZPlf5kVrAqHoLUIArxqJb+o8gODS5vN8M2JLHJ5IanjW6OMfSmu3w1Y0248LJckBYtblYOFfvMgwU2o/MOEJm9Q1R0wLSW6pFFAguIkwqJHCa5BdAl/p2HvF581LDvvhHf8UTmnmQx/6Nkfpw+QMnGcVBnVIc0JzHW5kMd+579Io+h3NQHznOdDeBlXZpfjNASiBvYtw6DcPWeSeWmNxYulCaEvstyysFXIFDIpKZZfQXEpmTe+iZJPQUonqsLzx2yHBq896e3Ne8lFUO6bwTfyyHmV9d7zJ9IXUhqs0IoJcyYKyAbQ7hAt1A+L+lePk/+XrHN2Ypf5Pu3YFaWgf+kmEcGbb/TAyUU+57631QKSNVDsPL2PVtb1MXc/b8MVgmFEVHXAv4hv0NE8rRwHogVfBJTw5PyJdDHGa2xBk8i6LresLM2tmm1S0jIrItGLqxuD8SHlYoFk2+obiKZ1vcD5IEbE87mqmqRq5QoLD3aPenPQ0yEa0cex1nmDRifsGhpQj6v0cBl5eebIENI1EGRABb1mf/xSchmf6zv6Gpy0DcFjn8IhXo8zKt9uSv5z2obs1E0URtqa5p0EY8+qXI+rpgs5os5zsQJQ1wYsnxw94h60Fv8faE0ldWI6b83CbhxWhMBvB5h+epR5GJxN+XjdyKaCwxRM/fyJMwG1GJ/259rNmIIHHMY3mgbeuG3UtOZ8R6XyKqGqbxTRRoZdvdbmqoZ5bQRoEbR8DQeDKayBWk5rxKT9P6oee+h9qq9y0CLQjXOQ8/dMo1OfShHpA6fbfxFMXJ98mEk1bMmjsQEprz3+5w7nzyIkWzelOtGKZZNJ6yFDuSxBhKkgAaMHznIKl9VMHyhmo5y2YqDjOjplZ6oX4SwochDdR2/wFKMfqVeGequQwgvIwjMptPJTpzaczDgXL+65BBDvlnYX/NjyLwr0twjZtJu1/4kQX0VkMdTb7vxUqAOvVsW65PlfwATGEnRRkt/lmq1dhlC4lpdpo7fSMvK8OQt6/fBFaeFKRUWkPqWqq+YodbiNbVD0Y/PqcXc7hssNaU5Zb9aIZ51Q5HHs24CjxbrPSezHQ2HZuz9RUsMCJXVt1+Yb8E93hlytTVWeHrfYrlH8cwl3KxZoP8fqrT5ezAtP5ZjO/X9J/2hL+xgY8e8jl34YMbMPGpEh0ESWw9SG5G188yGnX4OAE4jOyfvCXIfz20crXwUah8p3r6+io7xwXoLNu2EtraytDe58SWLaJNV5qh1VGCisQnArbchWx0xxptFovDGKzQe62nOiHfU5ApqEcrmPQyU+XGx9bbDjztYewQgqaMD1RKxESU5/d2qXvstWZtyuRQom1gfM8pQq4Z62EXYSTTWDEI99expQmExKjet4w1AMXhOabPoU0fTHD5Oei62qAPOo5vR6b9veA2+5RlWEM5pFd6lVd42y3nqLSyPT6mW6HCDVUsrarkGcM1VtXSGP/8Mf7dEJG9loIfYO3jrRZ/bPVjepGjU5y+SpSKj8ECLU4ko0h8EvjUaDhpvcYLnNZjX9tTEUXS8yPRh5sUpSTPCMAiICuvOzYm/hKC4jjmbAvwFgn5KvIJDiuQB0ZZzGrBEdBBFxNigtSKAWTfrCfBsoXsjKBCY3onGKk8ZiD4/TU7s2z0qRmRhzIinUc95gFyeYX2QhmKrCylzMBqVuNK7SSpyrl/D1m3y+d9TVwZpKCNJ7QaC+zqH2uZauoXGEgGnsaVUYJyTWQRAcNzq/keNrYH/KAcrAqkhAqb0mB6iqTVNGDr/oSBLzxYuqo0vd2iXpueNdfgzvUs+qg1iVcDIt6BHcHRv3WfwfnSp+OpAXvwuaDBj0ZYW6lyAV7bWSJgeO1ZNA91kkMVQmDiib+gnPjR5njpCq5zBDn4dHqWFVk2OlqoPhjc4O3Ubz/FZ6RHMERmg3Pk7zfGVYGurGqJ6atYG3MGgrXiPqQOeiPfCDYVkpwBxeTD0eedfsTLUac99jPY00Z6KQ9iHyeI80LZAfn+zokrlvKp4VqFpEAtvo/jpGtBIVRRm2TzcabGpJ3Kkj1xAjrKUckVURfRZOf7GvqMjb7DWltQvjUF8zIR8zVzpaD7hzFQshkojwAa6W4V0MhGa5YtM/nT9r4tjLPYLSBu3BzVcoq2cocmKHCp6acc1wyQCb1pDOtKRXmLtAvRUN0gZTiUOeD3ubfNSu5gUw+Gns+5l4sdX6Y+K5A97u74Zbi6Uq2Sa2JGjtZdARPaJWEy9FKk/K9enunWQBLLqI+LY6Wgti4TtebqTOO5I+8zDrf+OY81Q6H2yKyhnjuwuCwCeB1q+FNfa8fT/21Ci0ecuNIxe3DUDCtqgRi66iWlYo+J3arMSCpTHOj09Oqh8x2fXWdCkhKPNhlF+8IFaaEYyb42U6DLFZhieVIIkvqGgJKhKZCl0uO16PguFyIOIhuvKAQUPn+Cgg/2AnhKgo3wxZfBvBj4O9g9e8DHRXfqvgZ1Jv1pZg6EMiuK51QAueqXJ77CJ+CJ9mS64vi78B3A/Rg0vc7OmEOJs551OqwkvwHnPPcFNPkgOBKMcXCbTfK7yQqnFwVJn0xAQ6/Ls/uhBih61slUjeAoMt4IlUHoNAkCZ0O2nX05F8bLtfcz+XAR97GIWNS7aoVi21Ebpx0g6sPuL9ZOWV0fNWVtebX7eQQNER+xv3EKNFDW4PzfNVTfJ0iKCjkofrKkeUxVlIlf6ma3g4Pwp48YDs5FaiRFk7ta8MMcTUBNf/h+cQtk5so8koOpI61BDkk2KCd0ihHoDwPPMFKpIFIDc1z6R2qWt8hhkNpdRTvwLPur6al0KPZWWwZwvwjHKOwvzHeWZnVw5CggCxEkwk2vq5Q3pu4iIP5oOYJa67CvXaJVgpQepapUWlkCUCiA/KsmmfmyjJv8ITnWopKpkrh66aUpbk5wnKe9NFX/MXyRYtg/1RT/u1rRNCJ5RiI7nqjUh8DXHDN+oAbJ541zoi/FyqYf8lh2WqhPMGxVULqMpnJN+nGbtMn609Kau3L9eCWiUlngj1uJk4BEDbrASt8jjFVwRmh6jr0K3X6Bo6Vu9RWRV9jSR0E96KiLmNzpQUdw0L8ab1oo5z9wxAXrXEhlXmtpxkSZ5+SOEDRdw8ORDbZwkCTyvASq1ylNJqj2ni592OeRcaFBjKaha3n2XGMzAW6ZttwdsvP5IP37PYDko2CCAvOh0/m8AZEViZIs6HQt/9R//x5+YpCJ27C4R7Lg/plScHKsmqvNajB/6E1TPT5m+OjUhCcQFDxYSILNEzXP/Dh+M4MGcjWLsttt50U0iKwGwukGhXd/YaQGljoEGlOBBuUL3MeBl+xAN59UZi/jE2YMu5Se0OMeTlcbwZ7xKQGKybSt66PhY2ynSqiDU9hiaqn+ppFJHrKWFpOjGLwL/5wEAqI5T6Uzw1xuwdeZ+AMJBl5U8BIxy6EQepqmq/O/7wNnCmHbl7qeXsfGno2SHiJVCUFFJSqVIb+FuDWiM/65KKzYhLjRFZ6WWmXS63vlMPy6mQ8Al/Ipq/UfKRyy6ODzwLxlgNEon+l3kBJug8qQDwx0PRlKNcVduHOMYGsyOmnTNlhoIoaBHmRcJDkMeIo6GJNws0mTMGH3AhslD3QHkYzo4lLA0SR0DIDOne2n/QotLF9RgRRkPpXWejiPhCwa59S9h/Y7G8Lx5gXmJGYeQP9pZsPG8izF66AwBk7hIhRj7uPsrn6idzzcyb6tNHk9WxTfaeGC6JL+pmD19mKehbFBi8bpDpFZFZGedj/0nVSI8OKE627npDZGta2cXLfX5MXFtj5HPdwoISi30ON2gJ0GQnvoUq4ExdRX7C0lmBRRtrjVki/NatB3ZUoKNad7wnIegxykIKnw8mb2vCQUr+yJOOhdoONS8wVroCcqG4PZcYfAHz2vfRR3nWGYHrAg5+YJd9HrL3xGHMg8a4udM1n/gz/GlaWU2A357n1uwh301J+ODlgUTBXti8adLbKCtFqI1yfbpBvtjc4Z5NVNSvQqn850GyZK3tJf3V1uj5VVpCRWtT0Rn0n6X8HjsE3DZ+PVIZDbcHL6CLuKMfymU/I7AxNewtal3x+CfwHhxK2MsMx6CfOhyUOdMBRWH35FhRSDXFoJeb3SEEKxT2FqBtvrtJl2rVqG/njl+zYeEpOrJZ0K9WV0PisY1YJ4yziYQVFKWGuxnJEET4v3dtUDptISR9vmuuuK8kmhrERa3qK/f+wdWFrAkhDIK07Aye4Qw8Gdy06ieoWzyra7aG/5e2VKlpBaz55fVi2AhKk2YMt5ZSG2+EVsgjAd5xySiTL4aWLgnuKAiQSmb5567EV2MAqSKUYUrgsI/sswMuV4wIjr3Mej7OqjjoPglzQdrJN4SxMPFZQh3w/cqIYqnfoJbQDzt2lwHTmcXy4F5pvqsyrmFAjoX1jA06oIWafxU4PfY1Au0k0Ga80dxrccqWF0XHjWZ9k0kpyD4FHrDr6AmB2RW2WVrB9XH1vP6kqRe2Y8HQ7NYmL7QW3bQdNzVYOUhhCHOs2+UKoKF0tpKMl4Z65CfAV9df4udUlScm1sNBfGI55TEzbr74JFQbIpgj62swGx8IsjecrUSfC3tnJeOqRyiIbMqmIvbQCtX63E9X5xNkCJ2dvkfJ/l09m99GRcHbLgKk2UDp7EvPNns5ZlLy1UTXwwmPF061rltJjtPLegl8kW6dfuL5PSm5paBceQ2Y5K+U8pnq8lIVZhaUoU2UA7v6BRv1x0F4Smn9p9S+duB1zW5ctLe7UCDWsGNmrIXugDiw4IxiNSqfH171r21Pm92mzK8vuvy/DIbFjfE2rF3bVHzmZunxIgvoqqbTzeVmG6pNHq6YrZZpTn86rXrL0rw1CxfPAiZPUgTd10QbfBxTvVD4x3VbQffkkLpn5jrkthopQTjvvwRrkm/yhfupHerdJcLahbX/kE9tkBbv3WOeb1M8bEWIN4DHVC7OrNvWkzobc6sSlk1ZiJGW4n8hdHTl9Yn4v50gcH1PT7Imk1N5ZAuqurBPoZhGP9Ri50B0sGjgUPn9/BoEx2Z78eTYoCvfOHaGxeC3Rj8+tWaTA015tGYHJb2Ip8CuybcLvLGS4OtJJa7+oQBfu84nwshj8p7G2p3q7P/wLy/rzn8xNCRikv4JEv0bX4oMs2I9PUCys/qcXsv73hpEO5FCwl8Lyg4PCIBAHi8GoqXR737u2DbcehWcN563W6cYJm70ZhX9QpDbwEndiZYwc0A9wyuOpcPotIy/HjzGkhb0aNrpSJ31N/+zZQC/W4tbK2JcvWMiNMwQ4EHkEbSImnJ7h3QQOK8K+Gzaz4ay74K1gRgROB3opbKzjKnxFagpSAxZUg3/NqHbDYlJUUfxuSrQ7foqetiCcyJX06uNW97ZDPXEK1cJKQllzw46GcTebHPr+MXpQ/L+zSi9u1yO17I4PkueVyQIUSO5Ha6W+S2xTpqLGbrdXTqpNv6hdiZS/emZIcdoYWrtnD6I/ugiu07EHun0O7NDhmo7HB9L6LRWghfbLhKDMP1YQW1PfF06wPYw9F5fCwA0FXTVs/EEvf10LjPTdZxM4OJwxOdRExYCS1DE5AzYF3VW3QtaB8neh3CZjtbVvcnLbjBq/MhpXmUhf3NAYpZAPuN6REoOfAJB4XWIs85AeQqvnOAfvyOnPZM98m3tkVizFs0bnob9KUnYo7jUlGLqYFeOxkhYisip0Ti6gKi0fzxEHeWNlbu7u/Mkyac2C5ll+gRj6HIgPobao1q5tmjMWmT/9P5zSO2mEV81oCy47olhFr6IFu+KGlcz3mclkuoCKTpfH+OaaM37gPiy7VUkWf33XCFEFUSZfhwczF7KbTfw1UAKR3UFIZAU0ovmYGl1bIM7zwB9dpK4lyyMKidAU2cNSli7cZqrpjcidgks7SejFnSbPugE50YmEm5DgrnTK1aBEKgXaA/1/Cb4hq98+jvmzXBZXyk4j6BhmOC5UVsW7Brk/GFVimk2GfrJSG5MkysmP2rUdTz9JHqocDDhiBXHoz3xrDIYezT6zv64bfIAcdLJzgv+FR+ZK6a3uLlwG8lvd/raDu7Pp5cbnGkbHA3lYL9/nO+0qFVLah9ujEHlP6wRudKnMqFFde3RxzESFEaAbOaFVd81JHHv9UAYLWW+eg8uz54Q26SetmLjvB8npb1BkhYyANaNY4mq5xYZkeyQXSRBUspwclc/H2zBaXuYeRyWm2dsoW71T6F+DvKFoHGYi5xssh+e5Cvqa4TZth+1QQGb7DoEBcJTSst3QT0I52mKKl7G/FQftg2gY9zwgfFoIEqhGO9AHt5V47fhqgQh2S3fJrq2gIu5iX/gElMDcm3vfR0VKYgC8jad14Cx6EQc1peun/p73c9xYPkcOe6VhVxL3+eSnebFf4uHULwAgTdYsoA3Fj14e4tPNSd3Ox/hZ0690si2tmrfD5MzglGorriH0OMZRBOjpO0HHfrTh4Gc7os8IU2schGSK8cmAOxfS+Ep9bKP8RdSpxeA71HlJQ0or61NyC2qaFtRM/BNdiFxiIdUXnArNEpFBWYOPJ5DpPxqcL3R0oCXyyPkknGNQHSXmeHUjJQvHKF8ibEbivp3XmYLBEt+i8+yvr2sFZ8S8qRxmYxTPsb2j+wXv++MwHXmtxLEh3Ix3OyswHSU4b+JtB+306+i2AT9ZP2cIx2CefpLLJRiFjCId5iCH5RsXfo0nSmjqhriiPY70AZvOr/4+Wk+W8XZXPXsb6sECGGLx+xv7EVL2n4spPhgCrpB4eb3OUfR2TZTi1OCy3szeCQ4U3TAEHB4SK3Ou3X7bku1szvS+qWvGEpCpHsbqZcekG/9SEV9xQgU2x88lmYZ9NvwJxD0nJaiCFky4uPlHrfWdhACTcgmK+t9lYWqNujCj1b5FrhSwzBVnqhuVikwz6jBNzMGgzaTofqcx4M5r0EH3FLsKh8eRespoVaqlF1Jz7vfwwWzH4+QEEIMlNvhJspxYrmuBOM2r5BALUGbGzuuy0Dp7s7/3zrQFto7N0h0EgtGzMwthHoWe9bDy97XkMe7kuVnI/xJo1354BLqoOUuQ7TRq8L0DYwcnEuoere2lRGGPC/ApZCY6RW0/rqqzariiZfR/B+mq7+nIiAAPIunUShp6AKLjByFY0etPes39JYndrYduMcGr1S2QLW5DM4j88V9ro8gM/5Nu2pDbdIIDMXGr3dDOZ7kWvpn7HufW6DUeER6iab9YPLHHVYLiJLF6hUaBbOENzZGbaYCyMXudeeg9Ea8/ySh+e9HIF4mRoZRlHiuy7azUQz4q5zuX4q6RNbPDcviS+0YtQ0M0fmG+IlZlvklBDIpEYZ0O4mdsKQ5b4mJLbdiZosIMEGFMwGsdGeJEfuroXO6JOeDjIFiGYwY6fcz2i1bNVVuIhDXROFtgEKU2IF/NWhwxG6K/Kwge7R+e8O9ZniY7WMnX1Vfdm3n4AO02icFEuyuw8Kfz/QMmc4rUwdQj27GSxckRHvoh/HYZw0HO5Lz6iMRbH0WHzbGgUngFidxP5Re2bQHqZCCP4SAUhwlL0JYNguRnZ65RFiD+tziikjXHXTMEB3CtdSfe+9DBnvJeiDnqWCVQo4ilEz7tOZw6Woo9uso9jY6w6K96mUMX2RZInszhWK47T1AXGB5N8YmaAQD83/Zm7Uf+aPy27EYPi/9h0Jj3SM4ZWjsYt7YtvD5Jf1FZro23bsBhbCc1JjnphoFHPALqqMe6annkEqLwo8Rgci65kJQ0Y46mj8n5/9Qsk4NT0QmuLYOV3zOPYsDT/FFB8BwtUfuAI+fIwYkXYBeUoDelwQHWBMaG7Ko2ip1RrVozLTyvI9r9qv+r5YxKzfQSIkc9JdANJXeSGZIJ7XzLXjp9s+YnDZXcz774guLUWKhEgulKUcH7zDwz01gwnkKajaTvIifau5ffnVPe/MOIJRvDX8oYztyXfHDYRcuTSsN0eR55LvH4Lswbs30rH+zpsNHOaontr5UZBjuQZ+45CzBBjsBPyJmQpeFD6vxLnAbHypFXmc7pTe6lcz1hvM3Kz3T54FYcLF2ouosxewygZnEsEzDV/Nk4qfp0eVApzd2cLo5B02PcKBnRCRAu7ayaKekSS3e+ul+oNnWtIat6eNsFviFaXIkqpRQa3nIJEJLzdIiq7vOgGg/8jC8+WNysevkhoa4BW50EoniOZ1PEKyExv7CTL7Ohfgf4bjhBqtfr2YuSj9NLOWHVKkySTeM5lCsWZYq+M4YAQykcJ8a/aHC23rhDftMJkad3Qif4GgcA+XdvRNGueUsRkwlHD5WYXLUlGVpLbXCpqbY3AEdJYRTezlN+7vBRsTc1ylP99YSqI9U6eY78nkxDCMGwSWkOrpnlJ+QYqoJ2WS1j4qxS2LkIirgjMVzUgNS33FsHxWsGcbGpEpTRuQwd2+JT6/RC+D6o+JMaeHf8zTMJBOlNkXZ+/aHJ1j4/K6tM9R0G3EHYeyUjq/irjhDTGaXQTr9BKrSL2hhe4QrCsLIJaM9z3YbtaDpQYMkBhqlYudle8eMrjYvzbaplC+m3LluDoc8+6dCfY0LZx3ZXAsCuoqXpr9PQ2JKdlnv/iYa05hLnDx29okbqq5Y3WSgLqmSCJTowb2MAnyVHy/LCQe4WBS1N71Ftkm4SQijvoiy9wtUb6X3OJhpbWNBizQ+iru2lo8h+r/lpWG06P797tXnhfqhjt+bjXwV+nDMDzNrqFxRxQh55B3y3D5ebOPeJqryf2VnoqE+6D84hJ5/hTIMxanDY8eMF0R/vOSMVNQiEx+sZm5RYy2wRI3FpCUqRLZrAB8zUjA1Vnycg6NGzEWChC0YLZjxMyam06b7V9h+H1/dRcHtBnutoJ6CwSmhs+4edpLOW3pl0ckdn6SN4yGjaNuI9sCIBnOpvZfCOqISvUcOPMnJHBjgwGPzmGRnfu0qfyMZOwvQR5RPdiE0IlaUaUalQobDczs5oFgIYsHz3rMNjV6jzVAmgZh+6JWLSjW+B+2cT4WMlcMVip4lsoAomjOx+YkBSPzvAQYLO9R0Ox4zpUPBK4FMJKOmkSzTvueBJzjEBvwz10iPSCOOREQc2L30GaAYGIspjJXSnFPXqRCpN+PqY8vqq7iequu2EI/keRqqRQAKHHkMl+mK+mwOYG9jGMAnOz4bT/CYfqxI+eayJradxmsCMifNQ70Yww5MvbHntwyM09Jjrtd393Ms7nmLc6RffnAuT5mNoAhf9dxnLtOy+JiKlzUnRydkigzFJTYm78HpYCNw9MKEoTUCejhf2P+y8QG66AbSicd4g9n6t61O+EqpNrObAfPz83A1WvjnodZVwTzeOVzfBVQYNI/eTKsD3px+3Yj8t6ONKth3Pby3ZtZDLNMj8aBiIK1Swz+pnvCwT0dcFEV3QR7A3BO7YoKvkFHP/Ax/KtNJm07uy/TDUk4I9t44/sJ2NAHDFwAmiLxtXSQ/L8RKLRbp3nu/FQNim/cLLCXMxWKZuIanF7SsNysp1Bg5jdFlL3ZG+co42tZgyUSBtI1wT31QPSrEPnGpT4VMdLjVi6rJKmF2/D5+/krS6TISAuzA0dgsrMiKFrQqpjotfMK98Gh5rZbug1/zG/2XMTM3vs4WZmgkI9PmMEbxvqjhOUjsm9DH5SGDpPW6qTIj1A0MNY7SAAsPsowTtdEjD+M05VjJrlXhBakqrWgma2oJUsBMB71Z5F5dKKIyOred9q2+4k2gU7j/Sc+wRbLZgPECh/IlyBAmrXAUVgT05PZAxVPYPS49gQwxS+KPEAcojDkmwtzO3K+c2BuI7lTqOV4DifVFqA9RcjHSXsSiV98y2fVGQIHfq1+iUpet62vg0dOP2fHeQc12PWlK0zwwEPUuilkz0V4+doQOmuU+UzFQQxz6HBIRpdGVBaWEgZHNc03CLANJ6ELwPtsh+MJgrtylntF6sONaX7ZqnuNNJuqGAXXH7v+Ck6DfpbkkjiyBQBcEYTWC7f8CQzN51xrMWmhbxgZzGZ7fKzlf2kXF3k+dOtuFyb5RNhUTI15mKitK5tgpwMVja+S6H3UtZnI1mgL4+e55wxjNX+Xk1YyXqeiE8HjPPY5weJlxD1Pmw/eTabkbw9nFRlrrdBC/kXv+mPhyP5/jRe1c5nzmtdKQVXYQbv/NljSlyx42Be3LTYkNuQKLLwR7xbxdyxYcNq0CarEo8jIpAYb1nkd7/XSSB5rTKnU4M3RuOv0omuS/qQBR8REUclu20Hqw2imAppljv5PyQFRPFJYKB85nh9JmEU5a74ghhYVJHizeueNfGJMQsvZ4KSFkciG+IdpNYNd4C0ePXxikveN1dHQDoAHVtEfUTm02+g8bGZm7Rzg8CePRykmvz8IeDGiZJVzeoPMbrwe2mJWmu/b1hGc2t2J3NxnI2z+tSJblVqzRCPVIWWKIgD1LdI0vBznlNivx5hYfHMKB2QMZaS9VaNtSe2L9dafZNWZqq0KjbrcoSH+x+8tTaxnNdg/3k2ez2but4hNQQ37Gv3s0+m06hmlCNYRr7HFGN9nSfFIYyA8fmb7LnDB1f87YUyPp3fq35S7wiFNR+1eOKMz3j8ykKeUfk5q4bzyQQhTl5uXPIbCI7YV6lQ6x9wdzdID1gyorikXBLp2UyeCKgfoQVGoTDkuRi3YqPhGcpmHHHmeV6WVPwTF+P1zK3pAZ7iHfVH5KarwU78gZ1+rBOvGXX0rrkE1g0L8YWLV4uW2PDzVkYOaZ7lGKWUfVeQvyQ8Y2PCZuR+mb9BHA2nc2VgVyE3NG3aQH/HDHoB8Ia+lfXfkHTQGP1JvayGeagqEhNDX1Z3aUDKFEBrm50fFveBeedeu3u0cq5dlTFMDlm774VDcJE337D4J/PtgaJntc336u8RgsRX5oqP2sWwRX1vkiCjAgCW8GE17zheiRanPzrTPI/UN7qqilad6zF4VadquRU/9p0V0bQIsr1aRg26T0HClEVYSbX0BRw6lFv0fR+9N6NuhjstIIRUT8QrCrz3ehx+QPUgDukSqja1tPW/ePAcfLL9CaYQ0BHhTAwGI+EraJT99j1jcmQ2WBkAOHM9oNBZ3Kr5Ogk7eatSiUDQGM7fVCCe5YhcUx3CRN2xtfrxKcJ67GJNu4T8Qx3u/aWLlKwgvummqevuKNL1qURUnYm52s50eME8P1m6Kkypu1fjDjtCsMEFWz06MyY+xBbarUc4TTdTKe8ZolatB44LefWTnXNyPG4pyn9RLJrl40+TzdBC0kNRQGG+HGAInrVFQPMqWT0235gHse5aTMt9qZX9mMFw26zmrePe1UXPNI4yemzD5RBBzvBuuPPj6lJDzlfKtJVzZtOKIYw86JgR8iI7bBvImS0qQYnM/yKObmP0sRohVImsCysNcE0C7OGBqJBH5sEtEgVhZulVFssPWnPuMWZkxD93nHp0EsOpKaNLtbszF8s0lWHvwAJpfjbm8RsMlCrCNtMB91tz78sKB17mRg7Y+QLfBymFes1jq6W5NqN81X4Zx2c42xTU5hWSBMtxWN+3F8P3NSv6wUhQHwm9VviPNxnUU85PTs8SI7GOqc2W+IyCkqdfJ2IZZ13ocODlWw5V70wB8n/s9/Ujn/YsBp2C99+OyisuXsSuaQZccWTcgFjEHmdQo4aj1GFSHFkZN8TYfPXklVAiS9uYpM373WLTbE7zVmJkCKaj0xpEcfWJObhXoME52d5jTSvgO5ixKfEsXLXD2y2sfugREvTZGVpcH0o7yJnLczWf6tLkNiSijGMtLYYXpm4rcVTaba+L9ixAe0EwmU18TNkfYLcdu/19TIzReEID6wgKhLnkeE9+iddNlAPyzI6L/cfCkHXQL1XRnWyX+1Lgvl/XSK7yMMwxoPt1+a0iK9/eH2G+kORz7uyAdSEgM2MEVCq/D5rClvTrRDFwiNPO8SCqcSEU7DVjCFUvVbu6BHsIRd2IhfDQgIENG6EysMGKACcvXTxROaV/vJsU9mr6L/9VsE8cZ2LL0zGHUxOswNsL2350wqcM0u59QDBJtQsy6EX6M0rnBePWh7lBafzrvvrwleLmLs8fS+4NWo82hPQrfCzXK/0QnQfH5h0ajz7GgWEEqcYpVa6DhgTQ+HcebBw4Rnr6YUATI3L0H/hOssT5xG7OZaazhGtgRNe6hGd325rZhPSnZHABnDB9xOBR5EPaL/NgcldvSC9lDYeNr6luy3Dgs2hGxk91/vP0Fh2U7RIPB7dYc1s5cHXZJcJdXWDo3PpmypJzw7S5iOCdbH0OW4kjQzt2d/qvZjabvDU3+zL5kFVHQFp8Q57rvzEH0iRgImzLstZNwQhjTMIf3Ygi81/W2f6poQPz02DO0bq+yd8DiSCLMIqizmss/4qSBF+1ey+GYU2GjJDBEycVBwIJxhTl0mxR1Y05Gd8fOOnNzaRiEtv1DYoh37LTjdkFaOJUIgnfW9nvKChSg9d7/N4ZPlPPid99Hyz13VdkL1dwRjp8PstB2aqGfOeubG6Axch3JP7fl1sUPHdjZjijSIvFcpsgTtqT1Nl0SYlRoOuMUUbIUPPStxmn4Q3y1aqj+VmVR2k5kjfTBU7ObAS6TuhZT5T/bIcizwxEE5yiFRiSl5fhx28GJMKW89qhVFAQeItPBo+Ka2m7fhdm02jzqhSdGjq1cTqqC6AVAYihHPs7bQvp378ZtLzQ1Yf2n272EqIIyh5J6E7IH0QcJx+aWTxhP+4h2D8EJHXzWL9LGSjJ9BYYGZD7RopnM//9r7uY+brHGtSVi1CsDHd4QIzV4RVD/xeXM4++fRR/+v1kIq7oWvbfvUumOxF1MIocuX/nxSOfYgGlkFezMreZMCS7Pc3NMORDtyoc+FE7JnN2SgQSImtxwWFpbPdAxeWJIbYmRgTjHjlf33+GhHYuASRBT87XNKRwHbyidCig5/SXePwbTXInwH5HvPwy/KAfw/W+HZAUQ/6/+QIiqrprpDDiLne1Rn3/Y0noKtAwHYYN/y+1HLyafDB1W/CWoPxkYPXDdhOVV50B/pRZvIzrJ5c1hcpvh5+skou79zpTxrY70nUgNpZ1byUNwq5RZqn2/kC2q3aeLcOiWJuQQ3Ug99IFGNlS9wwWdDXNzZuNZjduBad72jn5S/cZptnn3512FtTCSITXnu79i031Vy1UQ18Yry9oaXoe1JGRiXADd/gBXfcb79kn9StEXTYo/TFH4evbR/hlnsrHhHi3rhhiCE4HSqXyMCYOdhaBfVhIv+ddLADP8c1ru4WxjbmgAXWnQpLniGiDnPrkvWTNPTHvbUKs6sCjjVYQh+/EiDWhtRMc4ENzBp/4l0iC6BagJoHl/nVZzMNT2ac7N26+dzfwF7wk9tKd8ywk//2vuv9ArVo2O61PoMuIn1zISSNQz8BtOkHttEqhinF/FKnjSZUqiZvuwQzXEZkkIdJmepek38YEDDVV6oBLP4GT921ycB4hURv4phR1etPqFcTkLTVsFK/EeIl+WaDevamBqYrd63OIAmuxGIhTBHLLGbk27vLIYpaVRsBpOETv1isypJCAEOmfRm/MByz0yewKB9bmRexC0IRj0bL5keq/jGFdbOdqdGO8CwiemSSp1L6PYgkZsNSvlagfmRiwVPzi/jk6HJ9XWOCy/b18f9+V6xmLr9F37QUGXGvKbOrjBAGRd7EQUPS02Ia4Ssx6KNhP/6Thjxf9jPYCsOIAWgVatitsIxbQ+Csc6IDxktQZLdXA++RLYNji3+McakbtXH0VYiw+He2i2H09/6Ua4J56HHbfAcmhIl+xQ+7hdjCf57s2QGeWat8ruFStVP6v4rYNcVT07EFy3HaYKF9BqhjM+D2CxJu71/xhjQRop/E/IqNvDOEzF4Jt/OruU8kKZM4Fgvgmw8Nyp+o+ERdGRdyBd//BO0cxhA/CFjDJYPvSnTPR8TXDASIepdkEDv55qLImNGJJWj5NCKec35lC/z6bXS0VmS0HOpGZ6Pi1UHvdUd54VF1Ajxu7OkbLN+SmxRihLu77PJL0CBLttzQoxdhN+eqLtp6dXHqqdgkVOB+62F/EelBmRwyaS+Q28Aq0FtgSBXMDjTkLON12sArtTHGUNTMB1tLY9jQv8SVxb7VYXhUNX+Io0enl98w2BaU2gZ6MIgMEIyjXGPGNpdQMz0ClzIT37D+AFtdwY0XiIgmRnbLmXOdOOSBwkfoBlOXRl+oVzKzgNFHqyMsfYJAqm/lQaEQNbpL3frMPzNyhfumOtTFNP+Nr3C2VVrc6sOiMMIcXSX1zQQvfAq90XG6DUwKIiSaXLPGFL/LI6N3JZlJ5haJoPoo9WlzYx5yPXBIC0ckv0kDAcSMq7v7mmaWrMSiOoRqR1+a1kmmlUGQlZrlOxJCybTkYUWVu68Od+ruf18oDAHNAJCgg9vwcHR7H92D3MbTHQfi1OS2dlMddyuZe56PluNch4nvMvSvNCMmQu6l3IwZPwluANa5V2QeYUHq3bvCnSPoPwORrauQ683/dxKPcCk2D12ylGZ3rJ425ZJPn2lL8ifxmbM9yTCusd0KB43dSzkqbgk4gCmK6wf1YKTP5oz1170qd0WAWxulzFFl5+elLQQxBNbUVBvlmpwW/MORO2Gse/aW27y/c3Kxo5ucvTyGrj5QyrIcwFfrJU2uDu+VERiavYxC/w7tBgwYzPukDafx/ItEjh/jhQsvb76TXiaFCXBxUp3ZjHaKVKEVe8dJKyRtD1fCVRVLl38omVIrsDtFO2quXGTLK6EcJbUIcHSXJpqWj5nScV9F+JZl2TVuoOUM9sJZl5H76X7Ll2X+bYZyB70Ot1iHG1rKtevo+Gs4svuI1PkIE0hou1hzgjAx3DucVidNmTDTpgCKvZHwG/GjKaSksVs+KQKRZDk8s5arrH+nvEJd0c4NBcHh8miP/tCtkmn3mP6vvvk1XxuZLdEZJkp8PPmuePuvJecE0mWAF+7Hfa8AI6t081onB89ey1mCVXjQzEfVrikMItVsWT50SjSburl7D3OstP19Yc6lNyhtkdR5zZavo+yjdJ6SB6P3y/x7Ji2QEDETrAQ7Qm4YXlJ07be5cVA1gVCUzuZgpJ0fp3qHI7j3idqjb9uZNOPh4FLyhuIkg70gBRDJQ7GnF0XAexWU7raVUyP7hx15Dwfrl9crgPwy+6aF9xxKiXSLc6KUbsl7jB7J3/Af5rBT68ovwhOpDXauTpqmnznWl/zRRAbArrbMeNhSkMpD+FXkafip34F1qxvW2cLExLRNl3ugf7boERz0uuHvzpFa+633oMjAIR3CP9hL2dXc01B8RheNxec0WCrD7/bZPeiUDWWvIgF5RppL3I1/40fvYgzSASdcPoHCTP7L4pnuHN6YIvJaW1QrVsknaiBFc+cwzVWU8jjFlgV00kGO9Dfb04dlt1zdB3wCu88jFOb9wQXXShRnecaqPEu5wtn5Op8TNs6LHPGGlnASym2j9wLT0K8YQC1oqbf9f1uww07CsCCahnANc/QtB7ztxESFJTrdWVJLe0KPZ2x4cBaFcjZ793bKs4hFkC7OntKMXldY2o6+IgvfGWHmY2Wo8CjJPd/nzRjEFEGlbVvpUUnYj4MexzTk7nAfMtsRXvEp395HZI+8dAqEfa/ewiaKuMaSz6o30cRqxFuLXL0cOfQUwtaUDEE4SHr4PsdZXRygthtZyHLTUUQJchUQ8Ik9/frCiTZFzPWzL25CZyokJjqarvGu3iOPwLP/yVGzks64AS8UknE1Qst0oSkI1x+nxcH3X7OeT9yB7UbAPEHTCnZVoRpCllEd7cxrMtbcx4MbI34eWcpvBU+WU4ri5fja3gs70r4KPaj5ymnN+OCQsrORQSiyf20v3lGI94fPr/eOnPwMZXDsZTg9rY2EePFIHp5vrynAkIzUxIHF13F6kXwtIiHslPIdZfIMSUv/5RV66eiUZw0zMe9C6ka4DewYP+fmQ9pG8OoRZv+knILKQ4q7AuCHBaxLBwp7BLU3yVyL4akIpDu5b4qT3p4nLmZuWZM6E4RSAOi+JChIhvUjaegjqpP0bfdn9i9xEg/7EF+r87qQc72smhyRv3q5tHv90Jk8kDCEZQ701XvPtbWKQDOj9sV9vfnLgJSydW4p6U8kB5mU2TsGWsWaj2Rm4PKr9oPPuktNuTLJauvLReXZa+m1mAkxlQO1OZrC6fsTg+E0LYEa0WFFu9P7dPG/Mh/tndjQUTLMPPL/sCOZzyoSV9zKkpUmKygBUPK7wUd3bXWMOLDJFIDRkZcRzNRWcVqFQVCrkD00YUVqE/v8d3RZkHhL3wFSfngD5yyAnlfYmXqk7bOEveDYZNYCzoyO4zjlJKz0ngdI4WiVyF35tuga5DAC80yfD3vsiIhgaoNKFXrKkRNlDQPHhC1GRRq5AMRbc7HeOX6t4nWOt/0smgXVSTPxWMbXrSmP0HLLsczbqUTXkXb8L11vVgPbDOoZroH3Bnz8X11Fokq7ebIRKgwh9wpadCLhbtoZDIGot+17nerWgGmCxyXTc1kMWd42xR3AZSSMfQlIXQ613aKaYAilwlpq14E8kfZ0n9sE5LnoYsnmv+cyaWslkqObFpyHExmgiqPISjV7xiJRNiFlnxM/iC/xEzP5J084eaOHjjGDjQpTzXmzqfrmYpe3DZVWTw68PyoueCP1chwKBeDUfcBxV4fFv3v/m+F9cgSflWM+RWd0qJj84pQg9L/tGSKXm9i5Ewj8UvLYJq7aTcjzSYUHNQbYysl90345Gm12/tYnDfkc8rza+e4kRH4aP+Ugvw0dat1sallHpB8m35d3lTSQ67Ov4jRjHqNsjy1ujVufD64n+rnkBubKtZ3MYRX7m/I6HCcuMHCmWZnCAbX56+Vv7hlDZd89y2UAt6uVrEL4rZlrUVA5b5U/woAdMI91d1vjN6UaDC69biTPu8rWqFxejR5fyDJ7S2dByRNIrsCA1E4BU84XtgdiEebJ5c4KfTAk8KXfs5MEHxe9fj5ezTtgpERqkNNb421xVNSQUprNFxeDurpOaEGTYPMHHPVksvFxv7Y6/VKnP6TG835JC34yaw2i/Gx4WIm1X/Cy9KqEajAL8Rkj2gh09gqWMYA61T6rhXOsrNyO5Tn4nxnxTGuP/l8hntUN/gB/s7HBz8TeC5Uo0oyqoJHvc+GpGmkB74+L89M2FFNaKPREs3vVLdnitELyyIyclOwqEWCVru4XCn78dZus7mjpXJ9gulNp5PMINFuGfbaR8mSoc0T+vrcN27JSv13AadOBkKRptoNC/6oWyV3ALe2bkMiWlS6NvyiiRDJnps2Ofmc6k6FtQY4GiCpQPerl3RlBnUYatzSZ9Y9JAnmR0UHGdWM0WYCsOkH3BiDEreD4s4CDRkRpCazma9ruDP225VAiREJ+BS62xVCr9uI6Et7fsnTZY/5NymiJy7b8U/6R3iOsuYXWXA7Fe5Zj9nY6/lvWQ1G1OD+1FXvcOOp6TedmRPhWt2HjgYFtgejN779NMXNSUZYm7TBcJx5GUeP8jhsGBDSPElHm8s/QM+W5Ep83vPOR8kILgMhuyen5GMrT00BKo0ungDwOfGfperv8RIxMPo5XBWKfi1HBmQJlRugCxTXepbH5OeaPJcKis13XQIFRJf1Ymm35sGy1b48cyKNPxoItaqVY0v1P+WBg26BD5amS8LomCp69MOtZvVMfiSp38mU7h45369SaYad/G3yI0/TwcfohlmVVen8qnTGsqdFlXT/JKNd0JOt/1RZLQgMvhjz+9yKeeqC1SfH/pG9pSP87eIQQe3cIgb7BQfkzcrycR6RrrsUy9rN2q2/37fvnO03mm/is+VVK2woO7AtFu4j6fA8xzNFb91Bkoai8tbzGsVIQmMrp8+xsiJevJDXgOsWPpKdutW06IizzDwFOxixvcE716eYXbW8OHSwNEE+MQBryFWJjR9yYQmXFur9xsCRgEU23Awc6eBe1suofsmya2S36DtckRmo4rKIav6lbCdoWd2Q85A0vUnDYk0m7u6Xsxfb//RHAk2oLQkv1B+Pj4y2cQ0By8GwLTYiumeDDJQSqIJygyHg8MDOKIbr9wDbU3ufehp9+frZVBXCT+VlSlVKbfYgNAbynFkfEenDf3/QZqYh1x/t75aF85dmKmIHjSp4BHqJENnaN5Lyk5cUlbHsKl3cMgPLHytkW9WQnO4YP14G5ZZJV+UXcYp2zYs9ty5lzj6OHBTTYv7+iEsV8+yv/IQ5vCYhCJw7ZNfx1ucCw82ojk2tVPz93QlDsyDeHdSv4qlXzw+DpA2foCiXiyXaJMhx1D3g3iwswWh3zhoXYpxvg+EFD0dAAC21P9ZFkS6LgCBkRUZ6t4oLdPLGFhpHPSq1ZuSdIPaahXrkB9CcpX9K3Bind3UphMerqZFEDXFA+Ucf6T8Mri2YV3746shKjuHCGvQS+o8m2yPEngJRbZtsg8kGbB46AxzVZw493vGjYGJVkgPIZqoofh3BBqNsW8Kyaw+LkWGxpWaDHszYAxIWNISZ82EauG+H+4CFpHuHL1KgjI2DNVTFQye2Y6Hz49/rgsRiZI9fys0T6Q04XIZCa0uGpMmscckksySAIpkmxRsALNwnIi6WxO+uUXVQP2KYUmJg1jvyPsokzI4x85hwT6DauX60hmjbRJfdottnp+pSYjQySeWwUhpiEviSb7AZRbvLPiV12kpJUZij9iiOWaLyIfwZM6k6KK54Yr2IIKOLLSBhvougoEtCenUPlpivIZ7SjVacXNzJ/AGxuHYu5sXkDFvESwehS6QaMKZms4+/FT7aG44toXMCHbuUvgcwofE/EamqUq1iyINX7/wL7F9cTuqR5qRFJk1hfsrlPNoy6Ad4M4khD2h7AH37KNfuHdwDFdvTzHupolAg9pHCKFKT5gvujmXHkEAupZTxroIazQRLUrOygPVoZ3b4A76GMaaEb0rbLURiJTotPpiCODTctn2k6nkf4nbQsky1LuGOHiAYskQeNOXfulSN3cSpZOoOlSjuPf5sFcrET9iIM1w9lvIRd+mDrtMDB4E0RHOSG2524+nOJkirXwZwbu2NKC2tmwQGBwNw+UwAR872rSPdmeAJaWxetZcLhd9mBEDUvnxWUQMi8WYMUB+e2IznNVxYvPkiEkIwqsp4P6TD4X1c6osdJyXhD1Z+6TRX/qKJL4Riyd29HbOg23dTZm6NoAyonPC7bM11MGNa4j7HljQ6EU1UxtAOjKCEjXgHZxJxVSyWWcAAgZ+bA1yAFVUo/xy9fd10he+L1R89Yy6yXeP+CZpWnK4oub622/qg40fHQPyiyZM2tKEdQCb3L9XJ0AsOY06rzPphs4Ylhs5SZ02LUITVBpEOqDcPnpCvRBxelHISRcJRfaxkxMYJT9nB3BurA/XBXT4dlKbhUaW43UJNopSwoIrZPeaEGhhCcmcZfDFCnjQ4UiTeIY+nff5yMeKX2r+M4W3bAorxShbuxdgHQUBEH5AW9cbdfANW8Rfu5vxN/8Wi1dkd9j44lbbFAokK+N6nm9sPWctXxl19yHDsCSn07iGH4CAtkA2q2ZI9XRd4jGmY9qmUtD4Srivy/RkSUC7r1AFPKpyQyT7i9MLAKXdXQj2pplbdROFxYrmc/Ohp3rh5DixaA67Hmdo7/ylPB02OBTgIEdSStw22bM7ddHMSE01LY5fevNy6jjZvOK0SKW9yvbqQVUsFKTulF1PUSpFAZcaVm17I8erres85kDU7a96kEN+CvfXAVy45KDiRw3XSs6GWkiZxmQ5IgxOTCMkK1Yu03JQ1e5dCdBxJV2CPUDERD9+blTTCIpF9eWQ2F/KlVg4XTO6S72cz/rnk/SbuSvG0GximkKDTMt82AaKH1FY5QaBX7HNlHfQaN/2hOF6PkiXDkfcNVYRB+hvw73UFtOiB00PsmViaDb+UDndaIIoq7QjTv7o2zQG3+YTLIc5jM2W5XCGRwS4ppUeb7LbA8hJkqUM6JzKk041sOkIaA4Bdx+0L6E/Ujtu/RYmhRSmdD91A8UQHte2qajW/dc0BqjgrK7oP+z1+NcL7CctPRiDy32wDyPDrxaC5B/1cQklD/DjxR5jW8WnI07+TqPmNhbeiiytHaj0q/IZOdrYPUwEj+ZMy2EhAwMgJbVh7yX8bncT8Jo5Uv7Ldrn6BAJ3HCmtHA78zaT2fMf0q3ZBsBOZjxaC6ELRu2YfbYIardhI72H6y7JX+yAWtQTfLvBdkOUaL7Pl80mcOBQiFph5U9I6xLISR6MiqWj6It+8C9CLQgCTQrNimqQ3bWIzHS9GrmBHFSpKNssCLlogkOYmTLurYYIdSo19YpejtkQl4EYL7wvNO0bzYmjXh39LwHlMwMhoz+jKWxNhWX2+B2MWPgKLKjI4Ssldo7XfT4QOwt5MSgSqBpf+PPPpNuVnfmrsMTabVuBkiW89tNOymIXivLAD/eT8iGzk3CLggKbmsq+k9hQcJ/d1hR10cStiVgqGraCrHNXkri2XdzcoKt1mAu8vbFM7yEd+gd7jyCOZy+dWOqZSBPVa69wjVRrcQiFCT/OGm6l2gEpqHCtTYbEmzuvdvkRHrwEzFXtTcN13u/X7GI+lqewo18rBO+1D2GNBztw5/wNyovseB5d4ybkaOY9/+RWqU/IpVhUHuMMFAHrxAd9FtfFud0GyR38kORSBgsoMdKGI8gTb3U4JZw7X1npZ9o04GJrh3wd32+dbsYtvfQ6Ex/sjBv+XkHjVWRotfFLGW+pv9KGrVY6baKXMCcSfrTpt37vU8f5u3bK8PRZW+/hCUViQg/GFfzbi5pBEwcjeLI6mFXd3ODBEOphEz29ogIM/5sAJV8acyAWsTbHcoXjxcgR8LeHeYfiR+J0AxvGsanIXnIb/6rb/Vvhu0AJOW4pcjyOI3VmBAJ71j2hEheuqDwZMXkBLwvz//C+1rnV3KTcgvojCFhA1Xcj83prZZdPLWrXEG4l74jFcssKKIeJ85R6oiiTbOCzZ57w8/onA1K4XUVkwBHTZeEFs1uOkTtbslHVWdfh+IlwdimuoPNtW5cO/jsPSnRnvkhCFyHDV2Yx6vTzB4fI6Z52trCgIiBPpN1/4UZFk75k0hWRi93dg1UAZEgBzE/93Aiksepj1cvKy9rSf23v3FAm0e0CrexcDi3W8zRcBp+KwP2PllFL5XYs2j2DLRYvwFDspk/rIdrKLjGaJRuu2tgyf+Ouw80zQJb5Q2kChz2trzwIcv97cpuIASyDDePHiW/a31TZMCQ5mK85b7DqJWorEhivoEdsRQ6XaF8XuQHZRLOKWyrvQqt55JtiQJQhF0vrzXy/SvyVTP/EMQ8yg/GjT4GGFJ6DRphImalj64APAfU7Sq5bETlpKW1iFrmvHuq7J3f3Pf32kzAlHhIsSixH/pblPg7qpQ4aep3wmQNwAZen8Rc97RYacR9vQ1PJFCMaa2oGqxbu6/bjfGuGW1mgJLg6BtGWUbgwRZc4RStii1rWiJkUJscECkD4bD35D1mwLxMyZ9r/p6DlJfbdaaFCcoBWM1TbFfSFWiGTmqUmfHJL0xtcC7Qp6PlgX+kQqFdvvg3LUEmov2bBPFRJ6LM/ltp7cIR6TKorCEH9vdmeS3EsCqEmmPt+DA9vLmKYSPM2fG52iT/vQOJ1nNfeRJ3m1WX+dvEp9YoYtRNvvTBIcVP95yN9iEg/b2RWj8gaT+b8/BP7B+TDsE2Dw6RP1qFcXVAFwsnAKexgU3HuWXXkl1f1gzkfxuaMUs0iAwHVDw9XLQq/6DkH0/5zD983QJaBL0DTTYzhU5Y8OqgfweEEwIHj0cSo6ncc7kGYPBKtzgsKLwpK+scD9CRRPigvhxJwX1G5zySDZWQ2tN6DStxWSy5r+S2+Gb95A/uNdimM8Qvt1xnAkt8JNYkPzO9ARrm1NQTIbsa5yqwZP+AO2p41rzuAdpReqIzZV3DO3AM2ZumHAgYx22/D/Y9RCkpxuwsSlr4z12nfIc06k1Lqz+Znx1Z8Z4qT/AGRDfs4kBd5JmOV7girPPAwJG0EGsvaVOgVw7cCRdAgEYJ6La9au6LF651TgncbFd8LSDY+HETUSxaq1idDwozXY3aPIhagBThNPZ63FmzkyygeQeGv10u+rG4sguQl/ROobkgY+kVk7UeplmdRr+ystAnBy5YUsSE8/2XOwmer/sm4M/X805hqpyrAOik/YlaTz0UjGYfML0FPki0x7zHVfbLbGgwAkAy5ieIO8dQl+AjpmpmnhHK58g0jtZhklcZRrAXgKbJd4uS3Hh1MbkW0Nbl353gHT7RwFzgog6mdIct9jn7ej9rk89dsf3rfIlp+r4Fc+AAPxjW60BLOU9RPbIZBDVy4TgzsL1S3Jlp69lR1Vx1bJ1T8T7fnzPGZd4yvsUScLuWf+EpyI2SMnNAxdDP8MjTMOwJg9wXMEdzwiLKnUau3x4ox1OLzD/QgkLjMC34mTw7GMowhu6yb6coRr25lPHz15KactQfacHFngVUlfNXK4keVJPS+mgHCOl1GiHCmHGfqOK5+lUFxZoVTffX1h0/myhprwP6QYDwPyWI7DxbPJHe56roAdWwxJvjDsgcGxaOhva5P0OGugVX7ALyfS0BhhmiCHXjV5AliFwwxcnLFmPolv5fPbJFnSygH1YQFeahBUA2CWbFhJRFbChmmSPpbNmLUCWaD5RStGHKAaQxsSkSUOHkkRRUpmo3+z5mz2dNw4jZxRK+99V8JyE+BSI15sIRRv2k6tux7pl3rRj/kB5g0AVrgGukVtpck9IaH7I4hY85XAcJi+50fPS/bDqOffhnaYhxptgAzDX0naDXT3Lv2b/Pzox6HHIC1W4eQYrBzLWMXvuYKz+ctDYWhTdc9B+OL9/jH2NBiItqSbWwl8Hh28AyVQ+k8ChzRAtJubAGSZYEMriZSW6XskA7T6Ckexh0Bkp9iTszJz0NZI0W0Lz/B1v/i3NsTFimN7mNoovgmbqENJe8jaICVzg8oemRopAqLMYeIJgH16jHaG6qIiLreNzdKj98FeJtRX5gZ5Pd5IzLbgoWYGwJ/BQj7/4rbPDxFm7YM5Me4i1KDzDWRd2Ts/1uwgmt4VMSCaDPLykoIE6RRUfz3DlhgcibKwceuCQkmpvDh8t8tP21eBYQJ3MG5LMszlmXZzq5rkdaMhYuLheR9Gh5vOuaGCXhE9aZmrUxbOOblZGPKI8/72cB7wzMBsrzmCR3tKa/Up+u5os0AyH65jVqgHmFZPvcITVmf4UbjMCGoWoZRxgEIWkqRlHbeO9YjBaZ+y3lhvDM+ZLGcfGZ/rMTspiaj+q/GgbaB6edDsTLOcWrkHE2lkg/ifv6qwwNR3i0h23lUSv4szkGqBg4dvHmKflMtP5+/h3FvhdXkViXxH7KgHygj7HyY+fmivkt/x7NbQE5DyCpONvDammUAImQs5sh8ZXHGqi5c+YLqKL+p59GIqcSfJMSG7x2NHW3aNxaE7kQfFcxBguizEuNqv6junZ/It/3sLfq/8qAfVtiGzyzUdWo0+skE+HbSKRHn+AU2np2GY6s6DTWLAoECyaZb/heaUWVMpzJDocNe19V2AT18MpIEEtF3/s3TdmtFBx69B93Le596geuDJ2GixMO6PjZvhXJWvEVhsCqA5R7E+g4MJv/6MwFC+LMfoNmiBoF/zEzT4n9iKFjrL60oGjc8EPiV4rqpS6kc9HQDCumi7RBQTQAUys3RP9drhn35l/1fUhsn4LvIESfXpsvOY8mDx7iz+lIodUog14H9SXsHE5XplJy+MQa556+7g0dXRZOC2kJ3MCVmjBhlQ+rveVLySMMTNxHI7FhXZRd6Lej+XdiuqfqLK3Z1YxkJyFsU4l60STFY7d76EOmreiz1yhph2fb426L8VxWvq6sEz4mlzzsaUNQuuF4HhrdWphkbJBKlPI5fuuWFAtnbaJWUIkG07Q/ACgMnFa1gaYXJ8ozI7g6NA5rBgf4DpFQrb/q9eF57phPa0O7uj+EX/CnETyf8wQfGWSB2ej7jrdw26hGQqw1+QlX61djULtzTvhnQTAdTS66b1mmDNX+98QN78nKcTHetAfOiExKXEzAyzsjG4aA176wRZ9n7/f1BJVaTFyBpfc/luazARom2WELIi854xlk4X1JBGkA1EBJfkfQcQjdrqdysNHpNNt5XskGXMFzm3ZkBc+5zMoZWLeQKgAPIl/moyh1ayOcXO0mVIKqHh8bhq9SoRb+dGZuwO5bmv6J7YExuRy3f3eQBDmjJJvLfhhaivsxuXt7LuMN+sAGL/PwrAwB5UwiVMJsQ6dkAIgB/cmLkQhNG7mKwTkpKnzsAuZrmUxvUWjgpUCJEuKeqqD32c9t5A+OCp6ZP0+vdjeSRdi9VCps6XMf+sUYXve0G5q3upNFmXZsx9bww8gkxi3ph2ekv0PQR3nzXO7AznqZpSeSDMFLY5OgE5IoBa3CnlNwtGZBFRuDFjj93QyVvUueeTcc9SwFvqCIK9/IPj4QvDO5M3r5nxR8B+Yr26+XlM6u1vdeRKO5R6ls0BjLf8GzuQmuiuHyauRxqlgiPEUvFxjVmuikyzMK1E5+t6IwaXucV2eqZQdd+btswhOTffbL36laJDLuKdVi+arjfHxI6rgCJeXvyfutkvCNqE+sg+WdPDQnrYQTKJLyPbRdRSOyHbVO+hP4KpmvhFVycZQh2fciYji1aNwxoFBxLQBsN+98E4H7JgrhNq4BQolDD+3PJDXyJP05zsBjqHKGVqDYeej1rbMqdHXEmPZylZbJgisye3LYJ1oyoN6acA21QEmsXFsk8O7PoMZ4gg70Z/rWtpzO1qvdWoRuvXZTAr6pPNMVMrqjEB+Lp9uwbpFKfWtS2XADXeQthvQ0BoCHvCuHrfVJId6dPpF9do0Lc2JxXsIqxsBCt1MEXKBLhvCzVffbQi3HGWUlbl75hAzXr4fXelTn1XJYq/kovcQZEkGBReIg6H2d1zMIyMiDv7s/h2lHiNggCOIJmQ/YFcj2k60gxfbLpWlGLgV3QHgZ7aNT6aybsAT5Ee/f2FU9CjnzhfyiwKT7puLTAdHMNrPUt1gRdd4/ieMBf9hiIakNpsULE/Gz0NH1wFtFhAXYobN5AhREjeePXj0Wq5g7UUch+M+UD5loXyartUcqh84PQksueT/YKFgkVPxyJGKSvUVoJUekkkkSReR2g334DVRvQUEC+asp98HWTFuClD/t1VIP+ABvDHB4486An2N8ts7uanHFtSlDcxlkmj5xkBIlEHXBD4pImMXjK11AARUAkjdfKBSgcMp38d+P3mKELFd808hXgdbCOXzsAqb4QoogHFmTnwPrqpjak+sqyPAeKmUOdxA25fBUM7imQ6eVv97bNNK4h9DFILa7xK8OhGrUUBEUJZ3HbSTGwYml5CH2p4SU05aoyOQpTOi9N9jfuLCTI8jgb1JOWAAjdx/ml1GUnpuHuUmonFlV0SYutzyV3zmKExEV2WJTfKhCuS3JggS48rKg/TMu2ltUiL/2QvCQw1old/Hi2A3IR38aRsTiGBUrIhQ8Oxeju4/CmythlxZG5ohBTL9uuc6FG38afkXhIbdDLYTmu0J61k9UoEgFWgoovJUKGIq66pt4QwfWSU7S0OBQdSlitnRf7EnMp03t3jOS4KAXkRNhxSi6J5Qgel1iNKQByCQgPvy3g4jb0wLA1WCmDzfZbPx0u+hKZOvR4JW/3kVFEasZ8tslAbfGC08xktORMs9yZVX6bqeSrypiJYb2ETjwkfrrL9BO2jYKIw7p4itsRMmtP+jqyNsRPwYo7yj5VH89+Elv9o0vU9qGkstai1djY+t/dnD9fh/1cp0YpOsN9FlPAgvQ7HytL3cSi6hZzcQuaeMt7ejAPeXojmKddVZqI3hdu5rY2lEPl1WEgcZOBEIS2AlRsAQaDPJbnnTuzjZGZeVHq/8RsqhLjbta0y0StzRb4q5gOwp4Pct9/ysiC96jUTEiuZCNXLmB7NAKDmCjyabegWVo/di7LSOb/7vUCd90QWcNr+vpWF0nomKA9cc/tfgS/u+YzLhjby+M2mP+uLtEbrLvs9ZiJXXLVQDwXay95pBAzZ1xy3P2PP9MwuOFEI86ugP6m14l364QDfm5Jd9fs6PZA9cMAqnuOD5Pk7cf5r5+eFJ9/5Jivdau1nOiuAASi6QFhllOmnor5/bfAz/ky397m953WSA88uQwWNusgzxB/oc4UkXDL46c8ZxMDF+ZAYWNNwnoR1RElg/RCs1fME9EOMKkXtn4MSASGzckJembZftcR4my39WVGEKbqzLneA4pphyPHM6z1mU6WpFbgdRw0/Y9gDrpmK7bdzDrmTC4yEZFpqjSc+GEXoCRhm9sYv9HCo09FsEHqBVp4TB30vlPOOoa/9Rw3kfKS3FblOQcPG4jh5eUN6aU/ZVCs5NmfBsvNsqeesmhJzyetnrDqneF0SqHFy8AZ/nfg9N5LBXXozfnPfL3Xacz7XsMcn4TeRFs0LrTS3Rjo9usxPklmnrAt0Bm5GgjZXLmo/OUkaSBy30M4neGMlrqjCyxWqslA0kho5qq9XNdwtyFeKKH3k33546PImJkzPfBna9qsEPVWGeOiE7jK5sPv4FI9MXb0J1kYxG1HgcmvaWYkcufqi/3ZLN7vekz5ls4ifBzdAuyeoE044JCSwxb8UxgnW1Cap6M7vTQh0oVQ/WSk5/7JcfpsKoWWBQmGdib6fk8PrDMWjBL83JumwLdCCkCnOuoUY/7zdB/sWvKgFobMTejy7VqlXj0wPkumvWazTp21PkT993giXajPXtyaNkEJFaE/B/dMVy/PpZBmiepASg8+2sFTYTe/zUL6yKsV4JTT73m5C5ZSxTxBOXjgl1dY6IZ7PaBHd0BwHI51Hf4+Hm/XWI4sdNcsDEAGUBAIKKqC4P6DSGRURVHJNfkEVvn+8A3n+fZrlAp2PFzM6W4AACxMAelvGZxAV7kmsIPZ23C1MlpuCGgDTpTRD9rPpYYF9L5iaTgP1QPE/gTTu+QdqGz3reqA6HmOi5I5aVC8hajt5zEnJLftACEbCWbq7C+G4c09v3HMKLx3prI3b+14xHjeK/f0qy+jLKzdQPlfWlntLN4U7y+dz4VujIN+hP1L+xFGmld631yMm0gchIzWQ3y/4i87r3vHXVbbU4e2A0o1EqmSmNP+49cIwme7BjWhVRD7hBOWS8aqC7ZyZaWVTHCxR6WToY/uNtwaoBd7nPnQLpGRtNa9a44jFk69HAamOP8cSSTPRmm42YORwx/aRJBXyUBpNww32vbs8JVSGwLpeu7noBQi1K22mgbkL2Zs7+LJRqR5fOO1JR1ARBbb63/X7AIQv4fWP6FSEoQdrNYdCGcbvtZEmXdx5gkC0PccjtivrWyejvhymlbrUL/OAGZgV/7ou2Io6aB0ZZ4KexTdJQn1hSmKyzhWKCqsNmKZXYmlOEhYf+06FGPwc85oTwXPIYeojwh2UVZti5TptuZkGBE9EAW6x8ByG1rAUYu4E2ejnSNxWG7VAqFVnIAa3mQZ7CMYb0bUNHXswXixNKy64xzscOHo7Ezs2uSzjnKRu+IS0AnmdVVA1BC92Jb5rG+S/pWQ759FEEKg+sCQGE1FccZ7Qhe3mSwmuOZY7VA/bib2Ej9cp9MJCaCAd8lDiFwQV4wqLj2QQp/xg6uVOyKIBtrESvSaO/Wa5JGJLzwcOd9BivY5s4X1MkWhoHBLmi8lcKidfhBLHHWlgVZZ3Fi+dE6iHsNSDnF9dhRm0A4Bj2ayQy2ypKQs4LEfcfeyXmofdNYMa3e5c4PzhkajyKD+2wZ/JZ2ZVwQcEK6ris5JFUE33O7cShEyjlvUJaDQsMSJEnz1vBtcUQyiyKXVsHt5WLBVh2JQgvKBajVDXBP1CoYfgqloErNRX2fPYzXa6syszKNPWAFPakiGU9L9Dr+k6/yLeJiKyTg+96UDXGV0MhUV8v6b92cTW/oghJVRrQEV7LEgZ6CJ55L9pKiZp7tr25Ay9bLSgU4N5KVkrAWEYAIfM+/bhnQ7y6YoHLw9SYMxyaLS0SQnR42jQy3EgKqL3/1PUN7/ty06Nu7bWXsjPFfWNfjv0GYh7LrymeXS/ZgCneVA/QJuat3grMyJXFAV9/X1ei9w306JniTRU4/1vIPdMDMszjuYOG+cd5VEsk4xsYIx/uJuotyS5Pv0KQucyYGMubAR0uyRPUMYCCExNMYuT81Fgez8kYECwP7MXP1+HUXHkinimikElHbe3p39ReL9/7KB71K9gouOBu/eEFtWEqKyQHsGzAwA9+sVDKt1mlqWRclqzpZO0ek5iUWYQrNSTywb1j5Lsdv8T+ag3vRKM2UlqLZ6Soda9AyUBlwkSrtf/Qt32aJzsQDMrBDjwVROStYEfXz+J5H0LKhrtXTEsivsPOodWW7AwmyPqpVe+wTrEEld+ejPPI3n/hP0MCVpTQQ3l6zAeL9yixboKCRj1GYr4m52hhF0bAhp2uTDcbbNfQmksb3mINKiWdLTnhMk9xiVCUkslTKHEHkks2GjfxjEgIGJ34ikWzskfktQ//M3Vdk625rqdHSYICR6/jLV2XdHWkqw2OzHMu6q6qqwFZesUUlEEc8rTfjzZ2IoXnS4spaj5F7RixgDa17Yod441/VgaVnz6IQ/Iqo5qZP0jLP9kRbw3xfKyeM2KBz1C8mCYQk75U1NOE3MZrUxDr3J0YhxVMDFMMAriM3mupb6Ch83ZWGEA9F4RqCLUdCG3PIIrLCFdG78zK/evV2dbRqpPPVAgP3ZKGPZq2m/kAPn04xxz6BHxNOT2iY1Ir7gsZvq1oEHx1+E2oN5EIaTvDh0Mw+cKnV5LrCMoJ3SmsBkdgMjNIG50Q2HYDPz+/gCwdbdotVzMzmhURty3V46jbsRSd9vu2fv3e/Ns/s3XJsgCdtKzVYEJCfujhBKvXdkUsCJHNLYJ77aoJwsf8yENq+nDsZTYY4oDXLcpptUnvPOLi3sHf416dZujmExv4jLzP0RRfEr3793zpVCFkvKbH9W4MOIoifb3ASPyu4h60CuroIfQh7HI80zZSMYB6VDW7V8nx79MTt2LVl8ZaTgJAVDfNZF5wZFAGnIqHERkAq5txJbvL6OZAHEFJKFDIVSRCB8mDdgANvYjKJv8DVN+oBC1+Wo+y8nVBPbrZS3iu/ELAhP3diMZhB/U5iIxUtcrpvRtNHJ2LMzCiB98VktwSv0fMxg+Ni15kNuDUjrcjf4+9bTPBARlg9+67RV/m/tEyDF+1SkqgJ1Ohlb1oz8fWAb0lV6c9rDPV5XQB8uKI+cxKJT9+IhQeT4z6Xr8ZccSZy3ATKcx5mN3Y0A8e3LxLi69Z9zKc7jf5PdWEBFUcDgE/a0FCJNX1AqoepEdMKsZ+E4Shv6Lh7Tqb8EHpu3d4QlwTeDTwUmFSxCO5SKFZpp6GBYLMC3/bHmHT/srzDFZb2HGA2WWtsjf2RFkAxEtkH0lSPiWbZgHIIYAR8ZlFeydEsQ2eGX0U7u+UuARcCf9BwLnJ1kJZWQ5J+7+0/jxhYvi1BzMOhrii1Eg/RYPrPTFY9H3J3/kgB/xdUc5Y+/zKkx1yMmBee9Rrg8m1f1bmBCwUZi/qnOq6qzt5F9yM2njG3oXXWzdp6HQmfEspFpG9aMSoRbZ0LDYtGNIjB/LkzyjVYrjLPznHiXPsdlSXmCwukokNL04CT5RObbXGi9ir2xcf3Z0Tv3tHVVpe9mfqbdLP+2c9gEjp+BxawSs8Y2npu+VGBfyYbgCPIARzR4yH1tPBwED34mwH8Uzf+sF/ULl3l8PvPVgGeHi+bexLBaZBwj5DU4hW1kje3cMhiY8d5tB8lba88Khx7/FBvZcnVHGAhQfsQ2WFwrr+aneq9dnoUaLOsnLp5yIOAfhYJPD1pi4aGQ/WKr1fBq50XyBrnr9FWMKJBRJCsDtrkFXv69tVPI8gCmsmB32lAR4vouS1iZGJm25bI9+b1ah6MBeTpn6rEP6b29a/bU3+jXifR36QVz9yoeSGtQgBz1r5uM/9wPXKeApezZmLQzbscHWX63KTwN/CRKxo10IUwvqifIj1IxGcv7g6j/AbktXp6a0uaYYLvCuUW8ByA+girfPHJWsNB8LeaH+ZVJ7v9Qxvw0r0pJra/374u4QhOD5UdNu2CnIe5OOV09iMd/Kuu+h+Iefed3VNpnP3oQhuF4nI5rshJtEdksOKqqbiZUTmFXOCFCG1Gyt1EaGvhXB+myN/qwsA6Pj36pfHbGxH/FJp2l0bAuGJnIQZncr7j82Mys2xR0r2iO+kTowdcBHKaNhiXsu2GCUQrvqn1x7M6hVzWdal/i36GxBr56KBRwXtkixItLhTgNfJoNDuYjdyojGKI1PFadag9zhBV8gP8oDa8VYlFOwVhRlxWJWQkaqV/eZlzbG8OwIYwUzDlrOZc8NuhhZjem8w+KloQckC+uqBs7q1qmoNgubFIQVNGw9uyPL+opp3wB/66DiR3Ftb6AK+XCKcSqCVJEW16vX2aOtV4mty3JPfenuN29di8OjLfQWsp993ks98Tv3JiZ0ZxtiVivE8XRXHZp6OuRbmCgHdIOOsFHiRAsdrz2G+eLoWtyMNWJMKongGM+6Mpdzga7+/LuHLeJ7tC0cVgamFx+AR4uvXwHP+b8r0zbJimC0xF8RZIJ00mKeAtzfp6n5QVHOACD+BWsNZQ0gFsQQwvpQtahR2go50R0VxV6dGOLTfmZHjnbYh+giLcMCOMs1E3TsCsD3EDi1VCrunHAza4K+iaRJ7eEb5xuLRyyo41KLKrIWDZ08a38A48Tcl1gKDyPzIozCqqtabbfmz6tCzccf+rsIy4l5/qGg2bV3+sn01taLOWiV/3F/RDlYoZldjXw/yZ3Fg14XS8iRf/huKbEQ/cujttGpM+4+DzQ6ETEEJrN73LVrE3sxCbSEa+hhH4y3p2FdR9sXlh1A8e6zKzHVq11/15ZLA7vuYBIacDoBFyPHMT1zymZ/8xbM5nYDf2FHHGl/W63zfpUY2+60goQLfOBC3AkjNnz/nmtLOlpPbV6TcHEkb54ye+RnjCjC2JcAF4m+WijwHWNlvg+RAf7a4/LZxhiX8dfHM55nqYTo2UruwN1UtGYmQl+HbvS8LCD2+4lOMeQmvCL7CviQyZYzY8PNrH0+uwaFJ3fXPFs73zMLSxExx4AsYFEyg/tUgC9a8e+2hgAdaRP7ewyijgqGFotLY50fm4oOpQix15eENR96H478hOTB2wQiVPFh06O883qjVJvN2v/xGVFdXnQjDTPFG9hnUvHLxao402DvArHGSnEcGnpYNOjGG8kW4RHlq4Dn70/etkro3URpyBpetLxgQei2mv1EeFPmpAjO1yfQqmDhp8LAn4rU7qVzhKS1dxAqQMB5Rxhm3Ho2SDz4TQ2nCazlRBH2pQ4f4ltAtN2MyY6vtcEasiUaibrSJ1Sw5DCxXJI1I8nsNXJLLGh+0qonLURBG/T6JAsRDxhbKSATwI7hI08rIFwfivygl6JKybpUETrUAuZhl7YMfK1uxUTyszHxm3LhsxKU9k5qPxzWIJvVsuBB8FhoJdZsMAakNacSv4KZ24FOmNftMdzOZLgNXIty0nf0b3Ks/23NKQM+QIB40tyOoLKpN1sycCfplsB+fD05w8jhDGAKtZwffx4vZsJhymPEl05ay6/yDMFQrrbJP+AoSa9ps8gRemg7I5R2Y/bbJsOf3E73YaS99jQoxf4iAqUjqx/eqka2TQjKkHmweDh9fB4PZPdZQ2DPVpfgcgRsvikwqI28XC64n5GbzZ34sEWkQYTt+TzvhcT0AbXyAw6++OH/UKprrPqSGU9srcJu9mZgHPAnathkcVCQocTARWXFxFugZqPsyrzcjwIJbaqC8E/LckRQGMX7ztdEf51WOKxGeqcCVAjkMK1S72yDTPA9t+1nTlnJURbOS3D/Cly10YksEEJ4n2LiSHRSvgjN7jro5Lzqq4zfg5UkR4IP4d1mJoyKbHLV8zN0CenuNw8WzhWgzBW+4mSJqUD45xIFbqgCRZ2ocNk8vWnBA22Azs8XoKm1cFVZx37hpag1uU4aPBOc4jZD6O7O31315TY+sXdi7K0rCh51uTx8Kf4J99iuli5Ywe1aZN620bPS71gt4U/8YKA8LL25L6au3DitZIHYREJQGtyzHnXoLWJc2o+ZxpZF3mX36uoJnkO8k1h2l3mlv5bDNlznBHW2BH+L1P9QQlAIRaeH2cYASJO0x8LYNt+/F99+mroL7dB9n0AtVBXG9Km7OpFjAJuhE34SlemG69RPklMbqBrI2o03CpYyj4U7hxGgM1MvQExFgC/4a7DalFc2T0rF+ZJcLyDKhftBzVcH+lxi8kceyJRubqK7I5N9Sp12KeO/4WHyz7wSAso8G3a5KUkh0DkWo+R2KysxHHU8BYixwepUf49h3CnVsnM2lY3vFVuhsheEh9naM9rUM779h64J6JpI03BtdWbJKWOxF5hCT2xhneMlRVnsvrEfr91X8GX5chk+Fyo3ycBQPWe8aqRRtYuc/Ra9tyLnRPqR/FG9qi8FVTMmlUw9QfOKxGMkOPNb9COymqrCIwYzWsjRyW12rWKXoureSh49HMfjgEpuQ34tOVYq1DDoTmEcTC+YzJXwlvC7kTa+zXtPJN/oBoTMvpRWyKGwm7pLunBWZ+r0KPTapKCkgxak4SZYbwXCuUVzkIbZRZtDkWceEX/8qp5zY4zdN11dGGYGA7rWZiRXkAzHSbUnlDf0M84QYNBFWhqI7vLGzcDrpKMObe/6e1qBwcTQ29SzbkDa0FnOpB5GlOua+sRnatqPHJ/xDH9vMnvAkQ5nUhDUYciCPoqxUCOCi4dR9h8Fwqpmjj694803jk8ertKlTBjWI9RFEPErlQQZIONfcO0TWfMAnfJjWUVbC1kvBekT9ZwkfXewIHusBLTwmsc0Q7VW/13IlgpUIbJv4LUIhh77rPXMjoZ4uw/6qtIs25HveA0lQtvrE8J+BMAe7wuSM7Di6enwX234d9faaGl1xlTRMb458uaxn0ZFzwibKdVcjaktLImaK0VlPGRRvL4et2PqIK35OeOiLVzHVHcHcFQxvQrojkFogJiLa/t/be6E9K4dzuckDUOJE7VAirbFwClrkvOpUkBVhDZVjSP0qrxcg1UxEcSS5DXSs9NW/TmZ23gv6pHaFlOd3s8B3FE2TG466lfJl4jRRORQlkb+bwnjjlZeN6LwJPFro/e4AdV0u/soNz40oWtHe0diIdTwlEzr43kK8/0rBXYcNas3d93SNEaf8DmnPpBxYGcwydL9IdEaXS49N8oQalps7zr1lyNsAAyIbVvDbmbRs0LSn5rTDLZQU+GO5wQ4BuzgckzAQQCReXhUCiOAn/sg+mP0YlTBCXiLfLR2+7nVoTh+Nf536XSXt8NahEhqk21ne7JR2TY2Y9pycYm5OJ6AMsvzVDhOdpNnAL1pP8IHSMFD6nesAkBTefyhWw7Y2mQ8ugZ9jsvcbw4xBUYmmppq9rMJlhMqZC7dlq04DfeMtCScf0ozmwEDarQV8jcHY712ExqeA6KRWGptcODwRZUxKJC3qIIT2MgVT+whbtXskHfpipSDJHsQyDOXNboE8kYVNa9Y3bfXVlc+fNCt/KBQypfbMVO4k9htibgNW4AdKB/kQJOLeyAFBsyU+YAdU/o84ho1urwqdGzre8YSSYpgWBLmSyYFHgu/HXGL8psJHY072t8n/GVGQqiUnHePuRbeEBG3oSBaW5sgRRxTVFAavfo6idWiDiDLyjToFBGI02YrhVj7MGM17VgxZhp+p3dBZflr/0KYaFIZysXjvyxZMYfQ07t98hU/SDBi4VzS65JViCVmPijedh5dx0Yc8PwuMSzm5Mh+JMNJVJPOKQgyhQgyt0vt/Q05TYgwWB5Hf1lxOSOPgaUo1r+at0kP0TRYnpDyjhX+MpKqT+Qwv4feeaQm5yPQUru6923SU/WQ3mD3U2Iboma4Itkk9eo9fbrNnbbgriyPiIEgGvR1N5patkXNblLLSrQfSAwEXeIjcBQ4NZtLf075tIoLJ3uWTgMdpPaC4JQcq1hPBjH6jvDwTmVE+aEhSibIwczsOX5BprFbxNqho8GVn17dcQx2pvs+JbUc88cm3keVcHO/ANVW/UlawJxxpXgINcsPsRkIunl2ZV1eW+KyC7hxENza5AHaQM0pH61uYyzJT1ajJhf4SEU5C2c5WF8qVYWyheFwiFdcPooGXumlFjq/wIgiEx+mO6lnjZMwyMydiIBC6Uis3stSLZGKHPGv96bM8LBaEUs0xqe74rH3HORE+whc+mOtjj0xvE6L7S3ttDxiADSWfb8U88Q2itREfRE9rZ/AZ1OzyWVU8SyRfwTqxXs2JJ6nDrO329AZ0Wdbri2Umw6G1v7H7GR5LsSAhKuslwRE9D9rwxKJBc5Gk5totloeO9jHswBPld1t1PrKBeuTGL5yhw/WY5DyRGV8iUo8kIpAlS7KbAvaUMHtaNjGIMPUtkY4sZj7lqPaVoc6E6LXGcv4eUXipcm3BQkaWGht2kId99M4Qg9UrWZ9Y/E9cxa0Tb9EcncB8Zg0RiCGp36Q1gNxDoiq8kgcNU9Fm35QNoHBNL48oV/D00ygNx9jx7Zp4kzFVCcBpAQa0tyWJ3mxHR0GAh12l1ejoKyLyhN3d0isg1LdFYSPHAF6MJ2yIkI2HwGLirppFXwjDVcwYEgwii0yqYsueKCkeSVtTbH4VY6/bzX+HX12VZrudcsDO2mIx/tzKM2rXqESexK7KDiM11arSYZFqpIqpAI7y3Cq10jzOnQNGmH8ZgsZ/OSebJZH7k9AJSqhSKWekFstxWGNgIlILiM5Bpz5s2+7Yvisrb+7tooKlnikGW+L012CcQkxx5ZAAT9/XbNQp++ToJSFIRSvAE4zKFgwbT3gSsy5Mz38PGGAGvbuR1fSV2lQJlPn9S7s/LaAbV8bX5AyF/6xWkewoj0yTi7cIfDcz8EW6yLLeRv+aVPqF++h92rXLPgfDhofFEt2pSclSL87rySvSf86H6fF9iYq3OhPV90YXyL+qwA8OGK4Ki3y9S5b1DFqp42BoiEPo88xQvsoOGS3BzwKrwWowQCfA02Bd5bBd4jqqqcz3aZqe+X6s/CVeyjlK19wywMG82SwDRwhIBGsy0MeL6rB1Sdl6zHFjiCne7QOSvHPeooIo9svTTnSHE5sEBwwoNPIndKoHATjqBCOfH7u+R8cEEFf3P1sfJzxnkKDzEKZo1Mw0pSP5qoCb6ydEl52JGVTY2SOfhOGKavP3nPw5fX6RS+DO98DSlwP83VUHDltdnUAcSB8IR4g5t5D2XBZU09VjU5NgaZXiIrqyZz+F89K+6I7lAbiEJpPLy0FD9BAp62zwHWYY47QtKXPpd1PE2Y7lny6eFzJy5GoLdCUfqHI+fHju6GyxKveMuQSCA6PHp+kepTbDQZPm95JREkVv4wr30PfPKm7S0TIOxEmyKGgAJqrMFNteFhzIJxnXAEoWeEo6TctUaw1mSF0ML/byPvBS5+qi8ReWbByJuokk1byN877yYWpdHMO7VnI6e3amacHuFPEbSMk/AyDCM89wP1qfy8Ow1ZYeiW6Jk9a+RJvwTdp8KQVZytuzAUfTehHWim0QWHtY2RAHYzOcFWImBaBtzaYDUIBZ7/3NLMfV/iDf5hf9KaxeN84wnlK13bRNBIaWCHdHljQvc59nR2cLpnescfuX8p30qwoCsQdiI5ibmA6v3Z0HCAdhQITWDlk+YqNvBLQL8S3qbizhiLs1zoBYpp9JyBtievUI2XvRINHaReTIJoViICURcxJ49evJMFQDSwt2SiW/YRwy8kd9PqOtzY3U+YvUEDsSRSaRT+IejaBaOtFhQYF9HLZLLXKr8sDF1bvBn/CMPr9RzG+S97jVJMuJDqwu95nbjiG5WTPwKV8lot/dDRKW/FmH+jRFgxbiYGbNrnFWqoQih558n/y8jrDlNkq4N2Scvgej4in7rPmzwzCL2x+HO7PFShZZltPEvA4HlspKo5H+zUCuyJHsHzGTZLVMIqTWubH+7yj/8lMYtFEVLkP3b9chj7n3o+twc3TJOb9C7I0ajfzbgokM9RCzaYvINp9HhE1YeXuhn/D0XXIcXVjcdivU9fiqiQzcgx4Xl8NisBXIyVwiflyjQ+kxlq0mDBbcabLzMK2oM/FVrzyiqhHxhg7hfPDH+HsbGY6HnxPWHhIcD5riK0NKXlpsmNx5s7ldj3Rxe3mNb6UNQhMKUYn77GG8SYXpUckwWvE/8TK1QY3TsQsT3qGMj1H3ADpAs89ndc44SxHLIidopKg0TLHJCO3XACQvYQOmwHd1e1O75r+59wfBBfqZpgV1c1Pf7KQVwzu3yKgZEtWasVqCCtcVH57nuf47cShE3BBg+JkWxUyk1LtTS2qcLzE/pcBzGWPAKARaix0SiLIgTHhYbebcsu2VdOLHKLpOwoGfITCqcKYULI5dLKVOokWgxoQpfwYIL71svjn4GrPCEkon7V8ypBqyYuCflf8FJ1DqlKrPLqrA9Ac7wh0MNXxiejg2IMHs/v41BtDWmLPd88FKhDW4DLagtQFtIBGOIJyyuLWVdsoba8/ZCyLE3Szco6Svo2rL1enf+5S/kb2kclFudtJ7iaGwgQMcrYldUsZWzEjiaCSC5zA33Bs8xogxFputohSLI6EKrpmJZ1PbcN9Jnt2L8fiTBliMLdlm4tIZ7CKj34IPuRLbepfsU/3NsEfbEbik7sjSiy9FJAbNAI1Y3B5dGMDYRCfaFru6dqAzaTFj/fGVY8JbCOzT5Mq54pohwZCUY/eVaQaFlgfwWATjawup5prCrBNJqF5sccUYTa71mco2+QRHPXL2jZWF4fgFxdFZBrZRsqiLXwE1H4nyN8SzqDmtXTslZo0S7PsC/IpKy3C1wLp0xewgeYpLCzfXxkrvaQpyIyA0Prk9bgv6ocxGZ6yCzzJdwyUIr5HC9tyQBos3gBHieT5P+Fprlp/Q85M2za+4TXp261W+M23IlJiij/z/M9kcF7kyj7YUtBrlqPb3a0mDsJiN8j4eFPliRz9GcKKRO0cOd0jAu1RGP5QkLjBRwQqj+gXPU4KbuRlhy/O2fgIbVO703w3YYRbkx4O70VmG8c1NjjdSKpGNnn2bWor2yv5uVwMNWEG9YeaB73mEYcClB8k2n0FsTjCvov4AbkiQB2p9qrTNV0Mb0wMz6JeqOxg8TkZr+4fPWEGuZUtsG05QIUtmsR+UjGRV2TKddPxMdg6WYL9OZXsZx4gbucPjnx6CvVua5dgb1Xir4p3XCKqaBobgUPfRPSECdxKjoM/Ll8nSov4ZWVz5RK0t1hnX6ZSC4SknEsv0AACTSROf9nFwKTMTERut1SkLIJXZ/2oYh8vWPx8SMeAETJRpr13nKTjwr8S61EHgbqNAhY+SsgBsocO7Kqg1sC2awwjTKcGYey2PxpdjhRjFeZlw5qfhfGpQ6zKAi2GNqZO8oDqbqkQmPJl+s/mF0juMgUSAXtoIr0oZZJDoasKP9SSQPvjyFXYqI/mEMYN85uOV2ICmqo8Xq6dZk44Bf7c87cgERBMokWx3PZrQnZKkRadrhmyCNp0LUNfX2sG+NfCNSlviBH1ddvSefmy/DlrieGcNKlPi+nKNlzNB1BYt3cAWz44h53ONR6RLeCIm3hduVtRnvdxxWWXxn/Wi6KW9UGuzdH5S8MUMqda03schYqAN0RXvN4dDY0SA7+JWyLhCY2W3gkCfBzhU7N3WM8Q6hFNogatBaIlHpxLlRe5VLT+gVj4Maczv+Xy904mEq/vPXAeadutRbr+BbHRhLBvnfjO6RlAJ1RhbTBwz/F+jMA9BJvtYSGt7NUVBkEIFg90X8HxGKzwr9Bpo8L6Hf29+W3HjpTkkdt/zbZpXKS8g/ScxOQ2CiokLi3PQM/55KVryQv5X/DegV3dPAOYWfyRgUDqSLTz+JUEX3fhyTIP0u0oq29QHb0GTaKXsdnjuflMI5Tqi0Lzh1ePJ8rP4p/xCeKdTKnK34F5ssESaAI2bIQQzbY1J3rL4vYydmjbBA6d/ox4t3ZLwDZFTRwEKsDbqhY/SCJ4aTwhgx4S3yVW4bc9CyfFaLRNFBmjmHhV46Sl0Axoyn2JQfOEs19xiB4sfgl2xRtsgwBqkrC7VEZyPf8krudsHOpCvCHdMDfhkuKL32qbb3t3pKjLCnYCh+ix8JYJFwh/GRn/2n/TyDpu2tOR30idywqcsQbwqkvjAinoX+dWjduF8G0AuACp0rzwawxHlX8Y8sn+XypSChIfOPZNYFMl4T/hpH+p5tHdk3Ni4SAEd2s21GdLJMf45jnvNumtj169/Jm0sHxLiCGBb6o1vO9hFZVlyyNZRaX5AFTDcLrvMymgAyXeLJIETLtO7lLJez0ooo0M+74EZGbsBHoljn4eKHa4kZN0k97UYyzgWCpUKP2Ag/fpoNfGsOpJmYxx8vWwH11c25OMgDl8lrcH6CQZZduwkAtc2DOg0qmTNpvHgmnn5srvqg6pom0DdbRZ5FldvHUtiEiq2O1zZrbhlfZY6/zzOqA6Mf2nm9SXglAIHuvK7ndGy3KzdKKQQNRNuH3QdaBMh4sSQoL/YfHszJ64qGNKDDkMixX3cI8eEZmH5csQcnpplbYaeBNG4OG7wsT/bJq3mAyLPQhONgC7zn2vmxvqYhxS8Gnpm6AVVqRot/bSMZAfZO8pYxB9oxojFB+R2Iywg7ZwBDMs33hqe2g9OOgA2NBkhymHQq3+7DX6EKdielfdqXocn58IgjPjlzb6nYwvN3qd9grYc8eu31TiGl8RXeV2ScUy7cyEElUgr98wm/JIKL70ruJZubErCrv6XuNgPSLXXH8bb5nJ5FEPD6+9TWeS5k1iubcm5FztPr1r2D1zdFUrkPeQNe//1gVAun0VWIowBBtuRJHKBG2dBWsFPNXhJ2sVYz2+bJWLhOaBsergs0H2HcqzzESeIjadFLoiS+9H38l6saTd0b1QK6wNW/KlTOwuaFzbyCK5We/rgcG4HsqxEMnVnrUNhON3mwXYOH7QWDX68WUC12ry701nmKKtL8cWMe5RbuGEEBppk3b4449eLmygCwpAhrn/GCNslhcEUGwS06Xjydn9giYXQM9IWXqXeG9Oy1QLXb7ig/2rw6KCAAJ/JK9Ab63mKKSRj1tEVjNbl8iEIG2kJKrLOPdiFCwFYGI6wlgwf4czkoWtW42I0WmGIlul2Ac6Vsr9zIK8S5vn8ZAX91MIz0UPuIapYCPxlp654aV2KhgHco+qvjXvXSHE4McBqacWg1XAaAV82vePMwtmN/6YSOQquWSekla+0Dkxb9/b1dNrh1h5D7nvQ3XnH+STv/byEVN/MtoE1eRmTAPIiSrs4+BkqvnANHhtRXvPyGmGtz6uQu9x81mZ+MOieoiZWJNf2Miwm8+clhDmyux5HDUcd8WTPSfIhLE+SaDjcBkXbDwZzUFLpRJuVg/zFvJhfJwuX45uj0RbskXjYrcY3WIOllSWrlIHrBgeBuw2lHss7o6TwXNxUIUW+pU1pZLP0Y7DlZ/AYdtcp0xYRpfa1pyfVVqsX/sftNTz5HsVt8gIu5SfSxk7b1s262gaeV/RXcyt3VNR/B9L1yAhYVRCAgpPsU72cwlDH2k6ZTAKTeXjbGh7SUCtcIedP0d0HcWeDx2XyPQQvt0A4WD+E3i3v5ogD9b7EWI/yp/UQ/Xn+mXtOVmWraAM7diyrrhCf1pyJhj5EyIdew9lJDvsfWmNbqZjtzN4M5htlIqsGnokZgV/urr4g9qxVDKQ8pr8dqRq782gajDDXWWYiebjXniSZbRWPiiaXer7DlwsGHW6gcNzFoP/EsNMnKQ27BHrX/OJPgvSgeyPYpu2PZ4AR2uIRhuH3lYF5Y+Ut5xKOe3wW5YUD/bu3M7bIwdTaCeNusduWHth18RnfW3ofkMWDSezZ8So7kWdEQTlox1SgUgWSqMmlDTLU34wZHTuTGsjzxiECHyCTZdtU6hHGdpZVtxs8BMgYlhZAcJ2VNbc/KWVRIXureWmOhZYQhETANLpdQIqZS79LX9KPWlGbzvuQuRgjHGV15Clwr899QMJu07HosPU9+YpIoYvtxF3gQqbOwOH3llxiPCt1gUTM6J6qQMfIFi8TeK2IShPZRhCDoxqpSlDaVmQK4aEnJy9JOZjnA6NWOWiTyr2/MH3ouUJ0cGsHZqGFouswsCLu6iOFTJx8X9eXURx2JUtq01IXj3Xf8shxyDi7OYDufHRkT2LoQyimDo5y1I1VeEDF4u+Q4aXO5XG4r+Rwpik3UtWoNMxAs9fpcO+NBkc2q2Q1v6IoAZAPQOCPO8U72Gs86EiLvshathx9nxx8TtgvuisiG6So7y+Gn0TOR4p6xOI+dPUI8RPoote5wGDSILVBgepUaol44yWUUl0CKrpm48UJzlm8ik77iHyvwHS9JEbh/aUf2sNlQd3OS/UNzYyiUIbHlKmiVO8XDhCOPfPK+hT9DE4e2KwyuuXYlcGKBf1/6KwMWhbRnEdtdaLsjGDdqzxTWD2UV1X41+VAJEjxpmiUo03izUkF2cdg2jNqEAJGP4xzizHI7+Zelzc5R9wOc2F9FuNRgSWVmMSDnRm+a9wfp3b/nU7KucJZNGFirioYsl2p+YjhJzePnrDe2uWluB4Xm1WrxoCyAc+LNNv4Mm9C8zzUokP7axcZOz8cFuNnmVDwlNdUimeuOKxopibfjBkMnToMKke31T/ULMEm8LdHjvjHF75gGk6uOo6CePOQYcep9hlOuHC2P3D2nM6PiTMlwcjWol7fLUne5zE76LBog/7cnS6etraviXAZ3RB4JxVIt2qFYBprrcsu7w+hKkgKUoiJLZvM1UT1GShgveIl16mld4XbA+LAbJunlrVYQcqSX3a4EGmLdVerRggKmqttB/bX6EVW4g0F7bYKdpUJXgiDgiSV403tTtc5arPqgxZYhgngjTkz7XQPGyzW3f6p5ZREhvK1J42LVL50hrzfauUUFAg06n04U2eYC9ueRlJe0LFzDY1o0yU+tke13mhTMq5GwC3A906CB48+9CDkSY1cnlk2X1vj/wYOtqWyALhCZfA/11osbOhKqi+uYa2EnJL977Ct5RA8eaT2Mk2m9r6+aFBLUA1D6swPIPfATfaonKNpw7MgZZyxad6nP9FE8hssO1GzSQoZrBGMHGZV9lz+8Gv1bd6qU9XtBE1BuH+v/g/+X2IpGyg574qT5Ca3KfIk2NWrmnwWGcl0n9ogEYsZplpwN7BHSWnuoXiTRscKVD7yM8yFA5IdszYyXRfRSIa6HGUBkKoT6B2/5Gm1PPOs3hLAPTed1mIi3gsTEQix0fYu1KOVzuVeW2UcmdR4MtrXaSvCubVbF61Gh6FTwOpjJFlQZ82qzvRfFaiyfER4SH85ES5E0ea2f2LH2RNIdeCcvpAQQhu7LSzLjbjJfl9RhodPKn7k7WNQ8CrZFK5igldPSGLBYGYB1idl3RMNYjEyUrf/qnGCsF/e3lhmGEovmnqtJllmhrDG8Xdo/khvbcj5qpIuiDmV6fcLHNoe9uB5CUF9O6z1VCa1tYDlgOTgHhpb18O7nHaxGvFCCMZforr7ts4kYOuhYhtuun/J4BASNu7NBm4M1DlmLbc8DCeLDs8OSXU4GmZc0MfcaL7mOUs9nCn0tM0dEYuRn5C7X+R74TrQs2GgNZ0YMN0ZK6fJZ06bNMkBA0CqliAh77bU/lDDs5yM5NjFSqzzHG4/jfLhEZCGIL48UsHDGn7nA+4IpaL8N9hmlabLq9GRjBciiEi/cfRztoKxmLdBokGpajXUHWmJLKp9o1X6/kR4X4+WlCS+Z2w1jWeCqB7YgKfw7kcE8OP9d6QR2turQnZ0v5Xi0f1QMfa6FR+m5PkkiPuFtaBhX4EPRZD2gCAKwe/sK1KzK7iCdMFdoxlvaP89NtQlhOa+2rVDcT3JdE38MCMld9EcPvdEC6coKH7qA7nETxh2wsSyjSa+qnvc9ro2tRbB7Olxp8NY5Xpw0H+3LMEe9FZu0wrQr8AY0OwpSPYgzysvvsED8VrA+i9nggz5FLTvxF4nobMlGNTnjP4ZF/0F/MNb7ECQr4NSyWiisE/T0J8sGu3nTvodaoES/EP3KMcK6F3JlO6v05eTl3dSeDvHgluHReBrkAQO1wc/3CfgSjayEZxR/uePSwfiIpRPtSejLZeX9l5f1X0MS+lYV8edhfp2IJk8yNeECjl8H7DYfxgdGNVj+T6T/HqiRD5m9VHEUIdVVVOxGyhmoYIvjeMn9qXuHx7Ertez0VuYjwXK+DABgzejkm8MSRuPib5sC5gTdT3kAiYpddhxmfFY1tpbEC6bn2ZcojDhe/t9aGb9w+yZLdRQmXypXZ0iNRVlxI4yjqEWlHuB6n61R0WctIPYpE6oXb7igsbOoG2+FKjBHWVwty6QuSeNXo/+HZiAG+Lv0hYQJ2M/PE9HDbUFR+dyUJvl+3C4QHH1gCVALgoaFmNAUMkI54YALq54PFeRfmr/Ch34raMispzUdcg+4tw8NEAVm+dLOHej+cqTz/o4plLnUt72twsBuXHPXPoOec/N4Qb0jpI5u1/cS2ANYgBoMl7r3oBjgVlgo2HRgcUiHMXH2eptsi9kwhseZT9J6/BymgXztwYVz0mNmPsEg9ehkC1B8HwqhsqiqejRJcckS1Be4RzQlZgZmzWFX2qKDjMhicRHpIbjscJn6/gH4OLEslBFE8JSBBUmgVyBssZCx8tivd3cN5li0mLj8TK+scY8DsyI+1KqLk2mnc5VrrLtnFNIpXM21iRTdPE9S2omfPGWfZHm+sDAMT74uyeOC3VZbHPVb7pDlHwQZMB04peqJ2PthYnl0eSi8WkF4hAxSseVdW3fpdLNLEYUTgpFe/mkCr2cDAsyy7buS1GTcDMV4lA2Sy10hsCW4eIRTD+S7Sh4Lb1coMW+6k8gUKke498SeZDM2ZiaQ1YRJJx0n7elm92BZHF7bg0ABkZApav30C3bygbXX/n+7sTD0cIN0O2O7YALkjSgpU3RlfifgFc/1CEJxyxNnYE2AU1FUosmoPj66wha6Qerz3JelcNgAr8s9VB+yw5KOET/z/gxq6QDHnmYoT6jl158l15PrMkQhot/DhfAi9AqPq90sZv0G96LqE2OEuAc9Ql2yBZ60PwIp/qUHbLm5/r17a89XFKLdjGTVJ7Q8LK+OrbNSc62PZoS/l53YA4wT/KFtPJh2onwteNhFNbVrxb7tNEppk6e3jORhpZfcMd1gdo8mZ819w92M2qF25lcfypPyjG4chqqX8GU4IRn0gYSDo2LO9Eo+555A9gLaf6gXJh8WicYT7XM9KmGHrxJFdUsaKrjK1p+uK6/D5ARZ25JQx9hG9+PyaJxEPOqDlMxilF9HQ8RlmZ6SFz1B2vOWaOlrIRTKfOA2eH0Q36c39FBqi4RXn/ucNL5uyQ8qRUGEx+sLcx9HMzOFjW+xa86kg4wOu2tn+ZQWHEiMxkQ1sw40o4J8tTFEzzNV4moTB6SZwJJmVpR8zLC8CGBFlvSRo9ZMQuhQIlT2VeeZVDTIoSTaURD+XzTyKHY2B+85htVCej0nSIeEvLRcIZ46PwWgBSMoq5mTE0T3sHh/zFSmVVWpuR+epU+XADvDbMisXTXqiwDhCZMVDqxib77RHMRe8VzOcU7tGOV5bc7ypNmm0lWacox4Nm9m5ASbbSI3VBn+aUVoKSOEeECNhkhsBSvEeGWugQaTWKJGa+lqSf0pjkflG1IQT//boFiR1+s8EvKXEKhbOZbUSLbDlewhsWHxepPSSIcqoqyWRhSZ/AA9SOvG9st3cjor3kkIXjXvcbDiJ/PO8uGHdCqIrQQM9hxTS/kBDyBCoPBLs3xF4l05DTMUMNkZXNKREOamkk5wtYTvhEYDQpTGhLHHIQ7LggoDRtUJeZ4Vv0FENk0JDsdrjDYp3QyN+BWIZouCYGG1NqpnSVtwNPGqChgw/hmrb0s5FduLKStXX+S4kI0SjvMWTm1l2dm6NXVklAE92rjVgTBnmQbKxL1ZQ6rm8a924C9QDNgR/Z2crQeCTqyRwxeIQs/GR4wZJ9ofepPNaKfJEXu4KGm25Q8e6CJzIRBszmj7UgRnz0IuNhoLMOd7Z8AN6ctQpBi54m380IF4mkrO4eRKo0ScrHSh5azWRLIhAwdLSM8M2eyiWBkL6CvejTOEAhZNC7BA2V2x4ruCl9nsWYLeXJcdg6O7zbBiFfx6eRD3azL9eo4NN3zZ3zjrk5LyCJ6IWurqRyGE8A28WDrSW0s3CcahZLnrYo5pP7dyPr0AkMz8QfsixYudrEtZX5eJgbVc+BPdLdWHeXLufjYals3ps25N9IPPo92Kkj2m8vYGc/sjsf4yfff1z/KD1XEt/mQlRzCqCMYHsk5yKlE7sC6ct1kTuZkt3t57Q4erDGOvFULogCLsuzUMP45MbOtmmuKHp7WA39KRhGu+eLR0xy1+YHDiyQUewaTDmube84Nkby6xmwTzF0AtaoQzZUDiN7HS1HRrmpytcpVNfZ8oxdAabf2D638NnIzYMTOWk4a0dkcNf8zWy3NvrKaeW31o7FfqAsGhrkDAKgBObRVF1HpLA9mneEncWUsy2PWEJtaXvJEJIzRm6LjGtpasIwumacCLmvQmAzeX4KSmUAHb6sQ++6vGmjINYMRqTscc4i9eNHBZebW2/V/mR0uKcmXYayAUkPZYPgb2V1RmtKrDwkIIQ2LBDPu3B1qVIlmwPtNuljX77FoJzO+NF+ktyNQ3cBQbiMY6lLIQUUBojcMmXIvFCqT5wKICofD1WCq7hV4hTqmYwaGiZ0Slft5Av2NfgVAYQpXC0sdqGuX9PLFX7TlPlQ0PpRSvyH3pyiFmcjn7fqIrSFd6XP5n5YT+L2soBsBDGoVRrvnmBGLBG7PcZDYXAtPH+SsYY+8SM4cQIyog94i9Ro8tTcj1I2KapNvKklzFBoiXh6qNvrQWkOMRkUu7qmKpXL4py/2amKDb4XksWA0unLqJ+DEJ1P5PgV4X/pfzArL+ygw7S71YzXwGTOgIBpB5TJ3HXUr589tnjB/uC8+VV9eiIo8PtJiIlzLn4gUkiBwLmLZ6QIHTD3xVcu6lqCsPsdgkhxAp4rSv0Mt0FHgsL104Bz2dGDO5ZGY1f9UiYNWuyREUtX0nCv4oIOABKmL0VWKfslzyI0zggCZwF/Wc0MXwDTX9oVtPHum+abgqxghRz53B4qngt9HzPezNJuw+UENYYcUhKNiUWHuvWZsjiRrIZqN+l9YnSfYgao9ES3JtbCi5zGGk8VfL2RFOzuSQvcSLldvMN86wcMfFZzQFpnGC0uNM1iIoj7o0+e1nbbkboAG4+ZgfOy5kNuB0YksYZdlnimmsTXG+hbCtBcH3h51J7sSGFvJ3JYqbz/t5oyR45vgFRbTHb4iWsZrEtHwkgBv3KjCycOhrfFlaC8SFXintGr26hlUiDJIeDHrDG1szzEUyrKH+c0wB8zy5ZuSDmZhv+0qDS/sg98mSA+ulvMABZ4tYMR6Tmo4cmTNR+iNbDe5uXPIe3DNCkdUxG6cf/NB3YLCPlU83nzgGP6gPy0VsSqOxZHdmJT/CD2PzWIoj+kXoQQBSKNcwC9GOTDElwuGKJhJvBRBcmP6ip5OvrNzcfgiDw28isPvhu+oxqaV+eObM63H47NINAi5aOE7/5x/28Oa+dL6xIRnsz1ZROIzWoFzKHvhsjspVp+9o3rBpM5LnkNnBbIKo3n0L3hbM4DIJsPQ1Qq23fUGKdVFB0f/EazSi9nkod+7lu/XrD0K7amdgZtKNqxM250PQkD5fI6L0UCLWnJ9vvSBSBqoyc+gb8GWaMCNBW1Kzkne7BbxSvWENy02Ep45SlrI1++WNgVNUoM5nfCY3tzB5bOG6V8U4MzUMPPyq2zLjCWuKllUCuyoJnmcMpXAMqmWkyUP1cmX8OzsxT8Tp4KGtmf3GbXjqd/gYkMVPu4+yyrDqNAnAWNW/n2mewumYGigVR6L+6TfMUBY6QpZF8cI5s92I4vmYCDPB6TbWqIFpUNIku2h41CGAGHjQ8xqixtj7iU2ZzB68fiiLk1U7kcFPXJduqxU2TywYdASng9NWrGfWnXkXJGHqlZDZRPoFG9GUqzhg60TZxC64o0IY0I3QoUesfM3RtX9C+ET8JP5PR6ntANad3yz7JxkyM5hH4Bd2cygDpXgpR2oVG/qjMsAzKo+jK3twcd/qEpxW+EnBrKzDv7gRTe8jUmH352VVo/B8wTJBoeHCpVygh74FmGxOUO8BM5Uh7ZnlLj9gD4z05lrHo6f9UYLjop1Tx3YmX6F33visfg5PFgzN9qed11Fqece5H9Mlsdtsnn2G8CygRY6F/K6mPw5kThU7CS1xhCLcU/CmYdfo+xsZ3RQV+j6XCrPW1+QdYSpAtglRg697dsio7exRv69oSBGxRdcGuZOixiJL5XriYc9aGWM5Aiv3wYgPcySGBz8bo03ttVKRW1h80wZ3h6p6XrCbLB6s6LmSeD5DeEtDqNypvmHd6m/XcLy4BidVZUt8PAE//7a/1D8c0h0GFGvo5F447dJwQzzQT0giqZ2MRjfFipvzyHV3cBqG+T+uahgF3KLTH0zz4KkdXv8KIMm/LUuRdAhr/gQ4lkn9i9X6CQ4NtWI2w/v9KRaCD/MT8qq0qgfmEu5V08EIpr9NtitJv/K46091gYpwY3g2mf1oL2PzCha5+TISBncjyBw/PNojQZ535BuGgkEBC+BR8PynS1lVcGTce535G8JaBw417ogatoZHEfGr7JGCfaWtIZa4XscPAjBYhFtGsmJUai2S2IFQxo+BJDKZMyzDj8NmoAVlUMdyrsY6f3+WXDsCpPZjxZyHRy+GRIqpjYWP3r0xX9Zp+SS2Tblmee0uPKQ5xcaQx4Zg9HAGT/sBql3X6F52lwTEcIX+7BgVYuQrO5BMlZOiPkk0NGI2WW6Tq6Yenr5nZ4HFEweDBfE6cOpkyJFxKXypv4w3G612jEo0u4BfS9temFyHS4LfZT9NEPk3AyVQiryK2rZZbkxw1m+iV5c9e2+IDygxtCYRrAJM40beYfJ2qBxzsflHK8tf4CHMAbRNRDG/+tmKeW6VsU7qxi0btOJDs4iphhX0eHDv5Xa02BPPS7Ckzc7Pf9Vj+kfr9XW+xRz9Ej2q5BnECDWotbtVSLvVkIxUApWwpShRGqFkJcEvL16B3mokKdgqlP2mjRVZfK2WGYN8gy+7dNCp22AeUbQ3zM6tLVqtZuG07f6MJvOyVwR99FNf9Ar3PkPEyH5OUeFyi/93tC0G4NcPROeYslpauGXeSPJ6yQatpma6Q9uHgsZVfLGq8MCz0unUstjeV8MYtOd7jtMJkTK6F5aI7x78D2s8mWkAV328/IwIiBXHv0CZDV6f1zxhaTx+BubW0yXQZfEoFlT5mY6WH+XRpUpDyrHN9XP7CmBgG4JVHrZatgawnSBe0wjvy+Ntdts2qKomBKZjCQhLCvfbTlqNcqH1ZTv15dM7udBWCdIDl64PHH2XInCP33fqHiPsnZLaKyKGZ7OtjlvL1fq5MmirTS98DBv6g338W6a6XTfXQnxVlsLXHmPC5/pIvCjK5Yxr7pcLPIkrmCLGYKbdYYLCjd8b4rDGWXcbxH3R4My/nrx6i/zOz939JaB8/s1lh3DElXrCvmn/G+/DPBWPuNuKIyBpSBz+Qkhucl8BXpfHa+gxy+qDrw0f8BCnwwI1WXBXeucaDr0gK674wQSHEiyY1UGawMx3eqMRYwnlAjuNQfwyAN+uBKT+V19975Zkkvb3fhPxbhFrS9itDTvCo2s/mLlXZ10cuwk15bsqoGHq6/49JwwdSk6MGyEjxO6UHttww/WUOsbYA1CiC9yHPhsdMpk1MOg0VBrIE4nhq+oykRYD0Kbo8aXYKjpuVpBO95eVcuazRrwucrZoHZ8c1OvBMgQhJLzORJUYLhlWW838Yv0SPCu0DQa1pHWSRVu4t4m8PSKkXThW3ryiihFlgJcDsWpijwpHCzC9uzbBdE6aoY7h4pIE3X7wzHIcEyXomguoMMYFSUNepLJh5BaBIgFwQVwid1cX/9ql6H8W+gMeAkk2vFZpA8cBLPOmNTZ96/Et/Ti37Np0CjggwRD6hoy7CGHU5ExxfE7xL3JEMVPXLARnJKcVwArLDOTtudN+oauMd2Gj/xySmJPWVqM6GzzwPeQvMRfhndpYKGrTyc2pCLAX0H+Ph2gngYw29IHBwXPfsEy4cJ29tMql50dhU8ka/sCQC2RsaIXtezlHCdAUYhKIl7bouKJb7nxmjqMcdphbAeIX3RxpPaZ2ZnhBnB/mEQDdubBHftWTO907u4GEB+TBFFJWo71KgDLTxg35kJT93Ho5sh2E0jEq7XV3L535rjK6l15Gcr5yhx418keu7O2NjZSvi5bI87mJ7mTufUwjCa1et9jqbX4DnsMvRQ4eFhKcuEFWrFCkfsWro6f3WnyYXSyse4X7IEVQLQu+S75x+il+XxiYckgQjTfBCEHmBZ3/UCGlltVyHHcpWWPnatz9mugsw/647SuZ5iK/UpV72QvpILJq+97dZljfgPKdgCeeVm5yKazFDbQ/AhIeT6skjWO25CAZsA8UhGHce3ieVzu16QtyjCtQD2nrzjk435L8NtiJGfpug8Ylbhis1IB+618ZFcmrQUeKqtiFZqaiqLSTNxJIjnPe9ewzua1n27tJCK/bLUkx3vpeDGRGhUaYQWHbyEN7xaLUTUEK3EB/hEvKa7xZQ8S1xmMlAbr2slty8Yzz8/5amU+VSeT/RveDVrINeJyrMRrfc/1DHa3MdjaTSPBjUrCuBkBMYZIAzazxcUb6D7NbLrgeLo1lahBmFB+4AkbSi5uoyP6r13oQ3eswmg33UMRCGjoUw43Ps+v1Zov/oKFqTpZjrD8jSg+85Zyuxmo++ei88BJWrYnJ5IvGvoehoXQEfEJSzmSf9SmZdHiWN84TSIqIizLAMlofgb2oBzewiCr+1Lf654083YfaTltCLUAhbbyiTFVKxqUSgUiyvI06hg0aAU5A3lXKTQ88r/yLWDi3KU4Q4iMb2EspXsyGpq69SeJ3YPrK3GIvRoBjCPDux6jcuxEHiPmZVcDCTYcxZkdX65zHhjhbGZJrevuNEhL5+jMAfYbo9QZxz7aDdjPmPYn8VBSysQHlYLc1DnCVRqFwl3aDcXDMkxUFRE6N/hFxcjc3Tj9kAlAVLuHYPAYY8YBbnPYtwt0G2hL2v0yZcyd1lkEtI2B+jZnQlJTsVICXotoBOsTiRhwVDJS0nTMeuY5krDChQNyKxV4csBE/KEV/X7i6gtO+72QfjmctWIydkKebwmpi+Om62c1wbne1tpAE2gHezxkXAYOeE5gAFzHZcBaRE06GvUhWmabZteubybuuqvH+Lhpqwyr+lYHagLAGqoO6A+m4VStbuR2BpxZy85XSyVYGZJ+VsOM2/tmNPDJhkLBl4YDKjh8P0dQlYrzryNYFy4mgOfh/h91rqIie6MgQJJ9AgXQcoCJtOvhJKATMJp531Yrv+Uo5Y15lG5xfTlVxghHc+bpiBIgs9TdK9qMArzY46Wzw8daUGLhJeXIfbYXaDRN4cad5R7R4vkg6nl3kViUZyXfzgvGiayh0JkEbNV2YToFIaB0Mj7YVlEE3BN9O5O8Eu5A6Wcjyki0DMsUr1v3wS/3xY6fY4xnkJiRzc6jXJ6nrdh7F93OoZQxQtFdE09Gx0Yw/Yzf+acQU7GwlsXSp4xFXSBXayTxyP4iOtMsdfshttmXfRIa9t9RWsGxPimWr4R6Oe72Ys+3xYZ0sw0B3KrPKw9QTW4y68xRO7wAXNeU4VSp/W6+hTWWUSG10Zq3jTW8PxThxYgFsaMX7vh7+ckxLLlBY0A5EeZPmsTwz6mb+JXfYRVT9Di3qGjo4DWHjtZkKL0TPaLQ1VSC5U+DaiHeak/ZvTUc/leWyFs3z6Y7z2iT73yDsVg9w44AYNmrradztAYQet8HYRj/n4SNH6iUeni5ACQsga7xCPFO248gPSWUvdymwNPpyZs8oAV+jpqOjniBtZK2wX2h2LIOoegcIRuvlI2GPz4WY7rKUkSQp/lTSwLb7sijEUhJDthel5YgLYOomtAgUkCB4c28XUZRp+fweLzDTTuKFF9HThruWk3PP/qoEtXiqNADHLff2MIZRXokIBDq0+bmT8PgTglwm6HWL9E4ZSqiKww8X+45siyWwP0dVfipbLCfBd20jMBZRMvEXD0AirBtVVli/JQIlbsm7b0jWr8M8BG5xzICRfueGhwVapq8WVHPnkJIlBgnID9fXG0zGLlV9ICm+30MvvVY3aJZl3kFbvW5PGZRdS7waDAltfqcixfVYd6FoZ0WExaUyuXUf+J1iKvCgoBxDP9QSAUUwrGNnQxDjS9QrbkF4sLzLGqyHAsff+wI1Mr0/HjlvC8rAOW50t/IMloFMwJ5qvl8irFanryDecKphxpzqftNqK8TyQfmgA/TrPNQ9a9Uwa0tv1egK0t+RfQ6Xh+ysLNc95Qq+lgdWGqfflgdclncv8DwPjUR6j7nI0on0dANV9FROCRmjHEiHQOAN8F92TlJvRS39QD1i6H4ZpMie4zsEO4XpEbXMpbs4xU9Mn1WGPslpwhQUz7e46jlTol6+AYUPHXWC6Iuk1y4tn5mqysvGFGBRGERM5E6mIrai+/go8CL6kkCqYVD9cdKlquHbGZIfl+XAQ+un+tL/ttAqH44+vlQTIJ5BjOpzCQIku4RQHc3oVW2IKsC1uzc4YVi6qKXxJNQ2Cdr9L7sh9c51EuSicwdoV7maanLW+UFUEOr5Dfnh2ANYxuZU+UA7Fq8eHDmQGWVwdkiBM3ZrkEFIzG9N4ex0GGzNQD6ATQGHhEE7RWgdHJnWW6gmEIr+jo2jCM9+7CFz1dR3Kw7tvRuSVILLgkSZkMcKHX8gZt0hGE/RE+eCJrs6nE3kavx+GomdoGH6M2StLrhUdVkzqZH9K8LUXJk+WRnZs9ADH+IlJpqLVXGPsiXWx2M7HNi5ByxjvQQsczQfDeIj5Sh85PL/MaJ+zKu2Uyh++WgHHiTcUEAecE5svYxqICcY/hZzza+wLBgMZisjNlVMnvlJfng5nBagWq7F1EAyQB6Luh+xKr+8O5uxqVGeBaafLZBNp28RcrjDaMT5wEWDOLT+EQL4NDuYYTmmea8Rfv6OVNxBX31Vc9XyARU+t+xLCOzkCpFUQOhdofXMgKnzc6MOvtq0c5EM+/edW4aB53MiAnXzhw2shBXhGBJgA8QGHdgYQXaNeDLgfTd/lEUWtOJK8md3boVuNBxK+/YWvfg1Ul5uBob5xouvrtg+pKVt6EiHVW+p617SruoRocD6okdyjWfSBJJ4/LKYGvrOZAKYUAhW5Fcu98yUtXxtlboFOLhxNQdCs9tgB1/BsWN1l449WLbSzFqQOFxbXh75FqdRwZulkP8F769Grab/jcGo0rRoCfUHy/lYg5sPJSRorlxZMGL2v/b/U0xttwnyurd8wYkhP9+tiuVVztbsTDjGB5s7u5lFn3lYw9HKHwRBsVW6HjyM+Of7BcHxbviXleMEWOizsRytE+8Uhk05lhK91pikUIuA9+LTFFAU14GfnO8SH30aw5ID5Ukejco2c0g6CA1zyEgKr4JBJvn+S2X2KA1VPyJrNrT2hLwaCLKVM2k5kq7cmRQls1uzcQ+hkjMv+MtpbQju3LB19XZHOXuXQtTOU2H7/HW23mBjMAleJfE2/Ooyo2xkpMhfsxF2k4uX/PO4b1rkqTg+ypcCi9VxQe6Mm1/1pnmWMHBFDgTF/0vF2R5Mfo2kP/6irOBv/oysPLXME3YOVZScJxVOt0bV4S1qwfuCfEfI2UNmeBcT0UH1ZVAA+8B5DBvkfz+PbSAAc89vxhKwUFuIrPTJHXkacI61dTiElE3pByY78CW55V1xlreifpKzx2GV19QAlczTi8e65c7nG0TnfPMIQOrUUmjnG2BvpsHvO/kKPaOXOpR+pW5QBJ/xU/pxxbmBPE0Ihqy1ibwCzJBoGeC2Ms5mM4ry7l9M6Y4+jiGdyOVzw9ZmBRxDCT6AtZPe2ukdpU+dIfvLwpNmFmJv02e4uxi/lqSVNS+7LSVTTJrDk6+ihD4yatJlXS7i+aiJELVYtSZZfsJMkUbj+lEPn4L0b5adezODIHpI1RdwWrjKDj6SI1Qw1hXhi+c6TYyohvygDguLtSPBvlhgWZj3g1HLHxsLvobuV7+md5a3dvzjVFFV/lnF0jrysAV9UjMTJfkuEviO0ww/3VR483meVfoH5/2LTsK7nHDWWt/73Fvd1PV08Cjror3AdJtXZ2mxUU3YWGtCmYdNhK4+j2VHpDRGpLD291GqQNDICfLW1LWJ0K8WHWGFIrNBnyla1PN75Mk8o8EVCwgUdc+TpfV2hugkszDWn0IGL3fkFhUBW1QOiJnNB9p2MDOgd2komyD5/eTJ11rr4m7d1WFrdTeoFIRfZAOjh7s0bzBdahB1xfT3Z2KXRyztsBphTx7JiXIDDO1jQ5J/M8MMCNkY15badE/FmjrHpe+OfsM0ufDVR3Dmk3coD1QHbaacEcfyM7qMspIc5UO7xY69clu9zJ7neKclALIWeqZZGXIPhbsDDgkiRbk/MR4dAolZu2Dk3vk6F7CLQL8GX7gHFr9e7mQtyI6byp+O/yudZoJYverU9Ht0jPfkBoDgHfY/MzazNud0XuZuubk+pdNvV06NvtGvYiQUR987lTcz+aO9u4TdlCEA3xUqvEUrCPpyjh69H4+0oHml+Fi/b+yuBaftZtO7V3wIwky55aIZkxJwat5n6IjL8C5d8/RZ6LuRBNbPcKoznlTXNhiMv0ykW+sv6o39tltcKg9nNK8BlLWSTnS9p/yCKssZtZOK+jRtrQGkhk5ZXAICBYA9OVzPppI7tF7iH8NcNgWUoPyb9ocyjitdrqy1WB0cDJScoo0jjOvYGcx8VWTU7XSHCn0lpQJESoqVTnWcl3SlzN0gR0alrq/7kbDWFCZaRcHGcKl9CT8GZz2W7Fx3plcRWUvQaaev1/pSiIpyuKbwUgBv37AxwWirNohG4cRpj6fCqv5J/L57EcRssifVNByTJAa+LTu9mufP5gCcx6QSusTQYHnJ79BEyqqSwye9B4g9C6Brx7iUinVwMQGmjsaA49USx/eKJz7rEg+fvQDpzCc5qIvX0KEYeoTdb9TEG4rnLRET14qFzI8KFMXYtPRxKIOhVMhR6sPKD0LNc/2pz6gVWGZtM6mvZ0js2xbZz85TPjfIunHMxzdoeXnmbuJWJ+oC7dui424Mk4HjclBIrzMyF9Mm+CVJ4EczSY6SzMtibiRgek3/GfL1Y9W2LqcsL3bE7CpyeUsZLMvEC8MtjKUX3fzutTR0y6WodCe09ccQBiKPEt62oBpZKxYZPasreMvzVVgQ5e+K6548tLIQSnllT1Uk0FafnvQnJFitH93LI3EFGVgZVJFsHw443puOWoO/VW0bhwc4Wg3zITv5PLUIFu6va4R8nfUqaeYqSgXXOjlXozwgzt0w+zsTaqjCbHVE1bHU3tSMs/x1klq5aNsfA8M0kC2C8XTh3XlmCtC9BiyzCZyv7fDReEuA9iX/ltQmvOQtaY7tfsBSAgZo1gNdPflfW+Nmm/+iwuZ2HKuIVQVXToTm/j1JVIqOvUQsh6Cb1U03uHzAijEQNnfn0E3SfK/ybYnNo7tDRTLToQ8miorgC2kX5pKY4JzY2NGSWIsIb3k9/w7vgvsyqdIFSHzWmqc1esk+5QfldZVB6SxCDH2OiRo8jPq4gr1njfJgqSGH7UcfoHeurFPP3mpuUV7cwHDQF5zJtSHZel33km24oktPvx5WgzZ3GkCtTxBbxpmWYjPfSyMWpfd2qs+0XpZsHWXgl22QWgms2/X6w1eZZr86a/yV29zO2pU2S2J9YKlWWfniAuFGdBtzK04G8KVpDI7sfnPmH/+P2G4inC81Vce3vZhlFFSu3l130zB5xUgewXNR7j0AwUqrjATd5Xyo+IGr23mS1oxW+4NV9O6w19UiF+mps0q6iCO5EsjTBooMVxRynl7QREMEitBhIRtaMuB1z3KUHZL7OZ4ELECUkMTWRycOmqXg6oEvi68iiwume97FTHmKZXZDYzUNo4IfhIBKUO6ZhS4Qq/n6giHcgYXVUp7p4bCjd5Iw36oYis/4bnuPGZKJqg4TVk3Hpmtc1nRKVu2+8IOuBxH6yya0TGmqyfNmX9NBc3LQWChyfrtrwrIUyrP89XhUwbIO6grkDLisw0zdt2+v32TZ9fxeExMhDio+5RgcVBn6/hODLZkhxgayQC7yv7TGsQFM9mlsD2sXdr5YSyY2ZJt3dZGrTv9eh4VMXYMWEuCp0zhQnwk2R4hqwDdm4dYNlJgAH/PahZHckdaKahTjflKrh7GobWUcndFGaE3JWhRDdvZS34rW+J8bHUZEc9TtcgtLsf6q65+PcExxalxDuBK3Jiv465UPm93AyR5f1y76S4EP1RdHFTry/nVAi5hqAQIRMSsZkw0J0wE0aBXXOnloSLwFz1EX6sh+BCpvG5/oirsCC1mW+mRxPcIaM5zzbMFqdFuyqohaskiab+stkPdBpCmEjD8twbUDEXzEZsFm1ap73B2vo6ACArV8xHgiga3VaUrpWhGhUkudo9V8qtMFW6e8A9cDm/+l1xwwym7fOaqkpoUrYiPxRxx6tWHfHEkX28LcrrVfCwoKJxrQjJWPwijalP3lT45DMEoufv30r2d/UlBh6Gj7AcZJjuQmN3ASjOyOMBZg8FiIQOZ2KcB3Go3UKHpZt9Ut3LjS5VvHg733G1tBR7w4gXkx7poHf7FxZjEDCXNzN6a0eavC3VnyWiH0Ag/UQMRd83G3APo1iZ3NuE0Hqzh9Nq5gv5VmetGdpt7885vz6cXkBiTa6Ieb1BJH2KFxBmJjzKMRcaCwPGM7LRUqswf0oB6H1c1TFjb8QQcX+UOkeQKImzEXbHnisHHL6w+ZwqEWptb2FJBNLRloBZhOATjZvgnFIOsNGSeFJ19NK6HPxRU/r3P/ATXA8yw4OO6l+cDsoAgHeaTqRGKH9CD8BrYTSsJVcg3mS1n5yXKB/jUJkQW8W2yIliIV4TYS2OkayANEbOta5nH/I4u3gOSwIcecuD5DiJwnhY/EYq43Bprng1k2Cw9LaQwS93tmc4QRbk8fxV+/1yC8tiDsGvkTqh9gzw/l1V+Y++WxI2H9dzmbnwvjrEGWZoNBoFyTpmtNtUQaV8wWk9RQ+2QdbTCr00HUXqh02BazwwX/ulZVl2b31vY50MnNPxJD2/AToa0M4XXsETDHPCt9L9DDEiyZbSRTDC8I137y1T7objuS2O1D7JQfHArGwhuA2e3VbhzM0w2qKU9BPMW0HexGEBM+n7P0DaZ7mYlRIYQ7Bn1D4ht/iu0L/3KgyVBT+IRGK9A9/usJt9THPOEOP3M07P3WdRpyEzlGv7q0tb/QlKswXpKDrzqetrUpakOwvvRDoGyj7A3VP9yGty05zFU1deCiED3SwV8kSoa0cDtMVENG/fghDmPX3vJ1d0kbSWu0gVIZsTSh4jthgSQveY3m8opYEwDAkrmREtRIiq1rOfBC0XVP0dUus+/Aj3MwC1t1KCZfNEtaf86I5t1eUaHYln5IAhQgPK04aZl/NcOT737hpzM3wvyLwfIkoNwSZsDN95VHHfKLxDj9JECQndpHD1SrDbObQtiI6qmDPXq8ar63hiSyvuvhfJRVWNvp7QinXAdVy7cDFnyCZYmLzZZu43xgE9zL1HUwxghNKGtguyrkNb3xoHiGb9mMSYU6pAP7Da17PNC13pKhY9RVrm+vHim7GLKSDsFeQ4wlkbBiOhhNziC2BP2Ye/gpY1XSllb4hanW5dNPF/4aaEBp4vTGS9GwGzOIUMhq/jwNrPW7lmG5kSfjP0KVCsDHRRsoJP5xrCJg7buX666UWc1vitxeFMDuN8R/7YmsayY3IO7wZ6YGqv0ww9vwzZ8zwKsfQbs1KX0xre3g3tUdmrsIfzx8RU8L8YZZH+Wg0tglegkflTy+LBwZ6W8kFk5/P8Fpyx8u797xPWXhypr98vKC7oTCQQO4VMEjalKAUxSE0QXUvEYStvk2afq8OiHLL7U4rjiZZ5DaPwLJH9SiAA2ogT0Upepv6Sumo9ScdxcGA/N7SIEDNNHKDkT4ik+N9aALYhtQELsbqBoxyrDdghY8AxjbnFrfLwVBhFXilVXGBYuqoygA251DT2d2UqWqYN9PUj9YfnAQGnfMCBIWLdXHaP/0ak7JnmHWKbjmwkXru5L0B2Rr4BNWx7CSCzVtu2hEu6+0Cs3lybfRQshrpYJCFehsSRoxM/QwEWVcnZ9TuYja8GU1Us4pM1DNIVb9JwgTQ6iWQM26TGV0tX3ch6gPWGJhlzVnjp8XocJFec0X+oc8h+lxBXz43AlBQGwBQy1OF0/hwJ+0S/7Rp+FCFeEv0g+CMce/saj2qS4a5+937D5VcajNmHrlf4WEraXqoIi71k6Tgo7BjknEsWxv3RRMIMJy7p+trJ2cQtgUGimMl6IjiMsDqYxVL2327lAUKcNJag+ni29I9YTTIAyuj69kRV56oqckg7wUzBJ8yBnCyCPGb9FTbXt8l6SaWvMxoRWuu1eRM2rxbjJ8KuC5SaE5gyAfmU95j+F2P+s2knhF0GAKhlanLDNCthSpgxctTFA907JibXCtY9Oq03HthU8EbHExnXOrpu1DhlDwsfnI83VaTjYsni2B6tZ10kQHiHj0bw+k9jp3tE2iVj9ZWDa366hWV5Tp+HdJfpcBzjHYRTfQRX6c1bIWQhCOdSYWcqSrsHEeiY/8jX3Fyr9lYSFd35FOm2zfHHd9Ikv+fyp1IqPs0AdDe5UXDmfNRy4jUBuvDaviEEuAG3dyBHKkH13UW+5VqJ5mV1ypcqoV527stHg099DFg4bLrOWCTWLx9nESyFYO/EgjID6WBFn75YBMPLOTYVfzgGobVs03vrikaX5ZMpizG/fqtN/66TKoxAOcIfEoRN3g7vbFck+f9YDE7504BIlvVpgDYZhsj17vf3Dibq7gXagKJL+DH2VcXTWpnd7ikGn8TVWr9dnytu3+IP+iYrmwGK7Og6vqmSXrZJEyeFoQFQBzJ/FtoXnoQTE4MNEurSHOqmh2HrXJ9HJ+46lQ8Usf3iboLII35HzJOt+F52SHRTPgLoyAsgEQrQDoHvKc7Lb96wOVWCFkqlb7n6yqtR0fp0r06HGMG3Qq10SaDAa4V919ddlkk4hfWKZ0luP+P9sEnG8EzWyMThfXCTaBI7UrVeR+If90/zcu8Z1Bmh77+q2w3MrSOGEIZC8NVQlhWIsw/hhD3iVr6e4QBXH4t4jfynGoraeNbM3ckMHgpqpuD50e83gIEz1bLNEpeKMeLfiV0F5NIkr/WaXDHuu5/qqbMNw01OqxUVpqQTCs4r/6CbqUSUh2KZR9cKML6I6TvYppSko19ippwKF7eJu843V9GqKwsuCVnEa0iupUNbdHLz9bOmdKkAY+PgUkdPmnFlyylDtqE5apee9PjYv23oLEm5WoZ253iLUMK+5B/kYcgJRsunPBULokgRNcorNBrfP6A75Huv8wf3HI3wMiW1XPVfoxbLwUQNjWNTefJvZWldKN/VwrQK90nszVT3RtOp9kN/Jq4288tAr++DfqjuRQ0xLCh5PnVxIVzUuB00q/sTTz2QSOW6qLLkGdJNT6RQ8NCRAhP7TXwaxxF0Vg2T6L5uWVNgx4YypQfhh+hgmm2lG0csLNajldkiWwHnOOb14B/o1EJroFIV+TavDEs5W6+rh10WDbZOC9F030Usp27TaCEdQtgFXrNlfLvFirC3lRP6LFTdpoLmr9+CtPIaoKT76Zzki69nCKo7NPutUBRpmG45nGdRH2PJn8/mQ7Z5Z8b3K6lXz193trMvNFZ/IxQNrmqpyNSRF/QQPpMb28/L//6b1tZDCh/M/FJX4koQRxel7RLpet7c7rBfw/e1Xx4Zg76DQcw9dXfPyxXLn1xA3B6xMepaeZa08V+OqWFFtedp3WzvpKJojXK2fyTIDKOkKOIF05XP2y2BYv4BD8v3Jfsvrmk7GwMp8dlotDqYbV4uJMX6K+Fb30NVWdQvLun20OBccELqSFC/qFEEy08T4+RSqcRu/wLHL9VINkC14IaVu+bdDIOcP0FJnJAF+O/ejy5+GISYZhxsy2TfEzdYAc7AeI/evHA09Nu2M/TrLndYDgN5sHApHjBfk7k+Y3u1+F4X9DSvM808LdUdfvDMzIaRU3spDnIPezK3JXuCcL+Jrl0tpmSdsGztU/sA45dYaR6xrcL2cBbpn+KHZucqORSXL3sSVNqzW6y8byr8FBChaoVXQuLUwBtPU5CBj+q7Vu9+Cr6j3k1e18PQeBknPUa4Y9M02skksqSSMUKkRo6ESwtl395YK3vZqbOtgbhGDxeserhzSb3Wcu5/HDn2a9Kal8gu55XZICZRFPT2jzkzDyc+ea6yc5sbUvTPobBYtzOzJu/8D8gl+M65OmDw9PL8GjNdtO48no1/IGy/RM7Kpch8mOGJoE7oC36TEwNJu6i8k/hZG3G0Gl44UILML0nbwWDnNWCQ8M/VsJ7wGLl7N79L0M1gWyJqPERkVnG4ou51LyuYH1DSZtJJgPwbsk0dOp/JI/1sbyqOQzxJwVEcySE4pgdrKZCCPw6ASZSGAx347d/Zxt1N0Bb07PeH5wM3brNF6uoNF+Nkm3mTihbTtreIxAJotKM8kspGriKBFpmEuS/8Sb2kA0FIe67sWTZP4QoiR9N6RVqUR9YCQw7kX9FXP0BieTPa5Vrdj7VBNgw0OsqtfATfo6O6RaRbphkCOgPgVOo2h+8c43q7LuSn7pAJaGTv9XwT9Ys5NZCFtVbVggmwOyqCGlmpQOW016J6g3NutEezmHeaZA3JNfJNtnL+m0U2thJWhpsAC2EnJH3UzrhS+r6JTHw6got6TsrJeh4tJ6J7FgVwnAcqG2FczRTTt8wbhF6PWbtWhwlDWVNWKy6FKAIwZmre+52hJyUD8nd1X15gJ9kLbDV6t5VnM41n2inPEUAk7O32Q705t62uHIzm/BnmwVV6gyK3YhyvbIkDEb4GoasSOp73oXsWldfNAPkqN+YdmX8kXaORS2/tZzL64SKzzm4Kqkvs1BWpFCW/SJc4/FaJ8NdlO0OXyeU4K+xPxiN7S5LTnkxLrsu9tc12XGXRyYIduj4myBb7X+15sJD3jZRVIXpG0jpsC/g1Q3kElN3B634bXYiL/H6xLr093C90zmnLA07Uhx9XGPfiqhjtLo9XFvHmCkfEhZJwpgbfXlmkF36JRtrdMiv1Ush+rEpt5e4+9uPCG866BFZ9O9oIcphLanfU3dJmtoXUClv863kbFpDlImPnmKU479xWt/SREckC9nhqa8wrtD+SvrLeI3UdxG9H2Zwg4xqJlPtEmi1GOo27J9PV82LdmsYs7LAKtQRdn6yRUp58GXQ+qtNMyHQe6e5IKLcEhWIdu24wXCO+PNCEyA40DHLDYGfxpbLHQ7Vl3LWulgDuSvuQdBfLd6DFrxNam52mtqri0u3+0UgS40bHthS3YaBA80cE0BzU55+KlO/zM4Jj6tPIKlmiT9mTb+e70EyQQPN12SI07OUbMTZAigRj6zFhBAC0GA0y6BpNEyuYQqMTrW3Kr65/fVhh5HKqjRn6EkrqQqEm/hhaVLK+AAbrcI8hE84bht01s3GYNMr0CzO+499vGMs9tiaCDHwahvJX/txWphfOB1+y2/UTaB6KVBJvt0ZOcU0Ff6/4p0IqbnNFocSGaOcnFD8VXRgSs3sxGIxj4uDcJufNUby8xd9mjzoL/3NoRLs+FWUks9lSOf5nXKGQ5WPQf0Z44WKWE5b2/JIeMpbIEfvwme2vxXL2bg2juz5ATiWjiWKTzFlo7BBLeQC0rd206PG/M+UAwQOdws0uZlcLqsqn3ix02i5EnFmM3WNhryIqsur7k96jkHHEL5Myjd5kR0Ll5ZsRA3gNrsMhcOA/MHfvVSoxtGKZSn9KC9ZPRrCKvMlLPErM8B9YIL0qxhsQ/afZAvNKC0qJrW1VLh5C3ZmEMnudiBCK3L7JkVDGw8Fi5GzapJvThQB7ptaCj61zb5ZH01QkoN0SM90bjgjKC6kLdVtL28mrTYJ5gvkZyjkwuwM7G9lXdXWEp1x8rR7OT28cc5ndi4zHsaz6G9s8ZVaXXM9xwS9+o8dcDTq8TyewKMkJHxrg2PnyFjno52bJ7r3RZzvAzg4gx8GSA+q2YqWVC4miPyiOeQfJyJJUpQpKA5495b7I8gUVZnAkpPSe7+9Z38MVfIXM7jaauy4BBs8cQg3uqkBsWnVjo5mY80wXGYbSnizUuBEEKZoyZQ+jK134FA4o5B8Bk4r+Eht9BAmCwJ7IuUa6n5EFEFWtS+t0y23T47MGb+FMjDsTZcShzBafT5j7ozw9pOQPS08nqJDfzqS3D4WgkhYri47U8VrkZ3DsgEe4IOkuNx/tUuFY4Qrqjvl3WcBtbHgapumDDoZDbdrIOt9h8i/Cwa0nnTECwP4GmI280AID5sLc83+sCk+avSbGcr2xME0eBK/313jWQT4Z+xg1MC+YGYA5fR0PXoz9IaIfq4Jw0kZJ1g49TzemI4rjXWidrEx9dOc2U9lFeRsixrs2nNQCPC9qgkUDJKUCuDg8v4MAnGR1RZkvxd74Bndmvk79A6DuUUevXYLUW8WqMLnWVb3GufC/brrwfORYED/5AZdHdzKM/HY9T/Eib31ucShdkCGMpBzXEeuqRAXsXbECwooZI4NnSLjQTRhouLZJauBbff33gJdS8xrC+DsUF3dhs0r7+BQFmqVrX0RLnD3Fg8U90kvRUQIneLkGK44pKTgDk0XI0EjLHuWIIj+gfnj3WXqS0XhzCwXAYE4B40wgacvwVZDuSsLbdhwjxoFHczm5eZfMY0KTGCSV9Z1ZTwLrb2Aw0AZC3aTRj1cLTdSNAzvU7DskI1g8nMUvMJbU9HdYnCFtC4C8j/INTwA4FYpdMovwyDdYBbKFBK3QE9+LI4ubw/Esit0c6zHu0Apm2t4rJo8MEvr7X56pSyrnpI+oh0kRmCQQiTP2vdHeMOLHJg+OmUiBGZf3/i4RReV0M9wB6K1cKrxrOncZz6O1kGr8ASL9sSIs3HWUeoZlUlQXuixt9fN73SOODQFFF0cjGEZUtVO9sI5aQKKmvWGg2KuI+jUvZ7d5/EITWLYelq5aTxuhw5zMvnWx6rbCyjEzKTDPk4N+c/gwNvNj7sseBosKR7Q5JgjgqqLfqpap4fvGFGAsXpSlrZjWtgoeJqb8O3gZfBmK6sXyKHpwNMLKD1mRwwgtCu3HijSvZ9QuksNPug0mT2daSXATyasI2jJT+DoDtqMkVFFjGR/a1Xxjb9d1q9rYKK0sdawula2FrRartFZwBqlgSr99VA75oN8BjkZZg6DTWjAV5AUa9QnWNt/Cfx5lSmyiImG/y90I/wVD91Z86WR5GNAAUFHzKe7DZ7qtZh16FOu3UicL1/w+CDBG5YQtBoFucdxwEt7q7ARZpVDaJTwWFV/+r2uwrXhgbNX95e4/Fxa89svAW5nWaqb9SLa/zVDL044PwSLSiRwfk9K6Hx1fTkSupmiPBE0DmEU7G/edhnHZe42Xi3ydA2KrRf9nlvF8kC5oiAzaw1pn6iQSoOclCl53K4g+cKe2PyfqHdksCFma56xGLWD6rffupO0bU32GHQGO0Ealc/RFN1ImcCV7Mj3lINe+08OZtzjGsNH9n9c8fZVK9gw0ycXVn2CqWO8ywm7mkobLZQQVFlICE2e135VRsdJ0wxNLdhSsr29bPHll4f/TAWxoECmnqExGnbKarKvvrc/UFQNSocAkUOjtqZ4Rx9YSI6QJajUUOHj2S1wLizZVgq3H2qbS31PfTfNBkARh/Pc1sBAIaxt3d3xyt0HnsRMRCDDgJezFZoSy5ONjDBhxq7YoeoZV7ri4QGnMr3QyKIblCm7I4J/zD3Ek1ttrmmVMgBe9XJFwP1Ds7UWThbdnhfxRdvVPkq2NJaRg8nsCiTChfamzNeopYGMsPzyZHaaSKce+B3J+1ZMa36fT1wNXk34ZODRmKV1xnqxsjD+HJ9bSmM7FPspYQtRdwiLDnthfvx3FbG+iMETRJFN0l7JxowqOCANYHLTrVhD6sbTOykzWm8Cvz/98SRnNzG49Hh8BKCAUAtB0CkcddjZVas81vqNKt2u7kEn2YjCkTt5X6o2dBeyHyxiIZqXNpAolhvADqfR/QV+TFdetvE1KkWrkCIvuQWE+VygOvCdFIEg82h9sHd8ah5xl9S2fiptvFbZjIOSphM702nvQc3E8XRdpKD6Ad442E9VwlKmRhAzhEPo91aef4ODanhNI6Hw7u+4uVuhoKL0HUDf26DGhoJuPvZgZJ6pHAFKmlBi4R4WvKoNli7daGxsRCZKyd+/bewPuOZdnC2dJsrDsvWGggwPUmMpmhRzAnr6LyJMY2SjXuLw7ZdfFmoti7G6nEDl447wGBB5dnV4YjuT49LTymWByJRpvIYfZAmpdvRyvJ9l9zWPeyhiRPPm3VF4BrvFSfWaj1nqTbZMu71Tqjp9bT7edelY2nMwvnFkCKGIRk67l8lU9kk6RHUMeBfv9bHjJqprpf2Q+3uin9y29c1QHz+UIEZeX+lVooDO+0twnxIfAeaL8clCQJylOql7ScscFYSZRo36kC6NT3Iwpc9THgAUwTZRfJA8eavPfB8U0fVmk6Q+nbDhggBZsTLwr5dMOkcKk4DU5qMib0D2zjJw9HXGBIZweIM/RvkckgEJSF2OQH7MnrzI4sKESjQs+0gsrIuU3ZMB+/c4E0gFre1Ef+GAMKFh0IdzvtCZQpPEkyZ8hizmrc2f95TfB6TkhZMKkQmHSj7gQcgqwuW+Q4kiMDAs6hc/EFS0QirNTUbotRERDst7TdagrJN2iaNjrCLHgIN/a+M8ZR02mrvpzjeZBn09IkRkAnqsdQ4/w3kLDK+TaQdajeL4m9oozEGQYQNp+YuqZ2tg3q+Peg7lN4nroBtfbN7p+2mvgo2de3TNNJhijt7Ywnwks7rE2U4zuUpD6KBskDTEVKegbzBaPPz3kk37B6LNvQ6xSdlBaJHIIzN2tkKr/YvWVOYTr+JL6aa/uo8PlyJUITqTU+ngTLETZa2NcorFliCcfEb0/HcLzNMeR2rAntvQMw588M8ME1m8lKIPR4nkkSHlVfhACzqBb+6+mbVsittE2XbtLptGGcRDUDX0ExbWigmrA6Zqyq3IjrVWIK+Db9aPTKFV1Vah7mbLa9ETElMQk+2tx0F5BeUdoOnHP7koGLwbCiBFhCSA9BSnN3sWkS67D0CQPQx7tCev28PhTU0w+UKGkhWj5Zq9dlEAIOpAsddbpC/z+iNUuJnl9oVeFn5xE92TLaeUsXodp/P1nyZRo8f54DHqmnJT2s7YyZs5CI6hUpgRTao4wua4sluujW3ZQfcLuRwyTW7JGn3B17KMXqMlr8hU/eZRZMchbtq3kL0H3lCIZ9oLxCdqgMaoSk09UbLFxU8LPQeIke0FB9lmo/JqrpOn0neKvEtRpn8uy6zDzslxOiqhz9iR/LPxKZM7dc5FSJAhxTmDlY2VXpBFh4y0c/EQPWyldiK6mbCAyG1cae2BuAw+cyvAQoX/8xs78EZ/P9e4/wSaCjvPOn7OE+5C+SMe0OvGxu3JO31+VV2JwzCL9OPShKs1t+FhFJL3LE1UuW1AIwftx7otedpD5BSthy6KtXEh0s4eGqcbpcLeiAV2cYInyU2nIuUCfm2vBF3uYcGZsYUNpxEY9EEeRMLGL9c4hfAi0/wcJZhPRheIy7eBEqzK8IjcyX/DSyGI0/d6hVtV8fNXUtW1jW1bYvAbYTh2MdArPUTYiocG3btBaL8yUGytvJ7WZCdksCMD+AQgu6gv/+MhmyFb/HHT867bz22C+FiLufbcCgbl94guTmAaZn13Sr0a1bXV4giW4DzdFZYkIVuN9fJypohdADL7lKgo2P8PMRyQunpzfMYYNp0rVQvvrdNjnt218Vq2imZhSGU/NPVwPfj9/6xpDyv1A6gbd2epb7dfbUfviiS6WzIqvMyq5veVovSBDsGOmh34MTqg+2OIQraETv8+WN1S9FMauNZbE/IwaPohQ2hhmwAsG04FNrMYVBWkCGalxYmIAhorF5OQ1xluMR5/jUVoxUDnXoppmzlG3xjxhYgPTkVZdcCodVFnvOchATY3U5dArA05hkeEi7+myrAIi19coJ4NnJIz8TAgTHuzDeQAUZSkJmGJx3PDAyZommAvqdRTV+4EgEVrzJxI1MJ9kxI1Nu/d9Ws461Hri9vtc+vzcQBcy+tErRR/aaCQ9Km02cJ5VPFhWeSoh4YFuHDMpyfnkBiTi0jAzBSfL8BiZec8G6/dYkMr7GDmaM1f138DkDkz2Z0iAoEoFjaV8N9MBlFygM9q4Of2t576ShisvjbI2SFmEZ1XpG69vGatr8ENB7ORaBOSY9qt/+YCU11Y0lHIg+bRGVlGihWvrf0qSB+gzG20lyNqckyLmsJoKuvWRqdqhHd/iTulxZkdZ33Z1xjbLtUiRGfFt59NXp/sqHzk0lG4bFdI8A2mBlmpcD7a31Au1N4aHjp/nA52xPO6rWvaRswWDyhk/S7mx7vx50O3R1CpPCcyoH9rZFAPChgMurbVolzdPgI8kmTuED2C3WaHa+Q0UI82/Ho5GaoXGMj1harJ4whB5tXg9kZt8iHUqW5qPioZfqfm44irYXxP44mb4ahmX9ZY0ivInolK0dq94nggXZxbSRSEAhHcPR1q07YdtprbMmdIzwltefaclqHVwwbzb0+h3spww+CVtoTQ68sWmYKQV4cTgtYRixyei5VtqIz/0FphJMDZ3cyBoIRu/Ho7HYFSeJBkW5v/2r3b6NQIGtu7P2K6QlmF1ypgihKOUW/ogY0jeMuLlR2vp+NuaWnCZUhIDspM06pUsLycVLoSZyGWNOmsSUOa3MhP8p1GIplDvjSG59Pu56yD6W/ez//nCywK387RanbYhl9vCnehlGURTz6UxPuvfs5eXrknNH1cg7Ol5VEvGYbK/g8xZUiObZvEpTuNJfLuBzB4TSscbZdOlj4XBjTMZc2aw6boky4vQp8lF2jynQgdypA3CqsSIj2j/cbgV3JtFpVtnoLfk/ZZHR1pvMcm+s9OY6fUzMjuHI8HppgS8QpJvfahqckifPhTVOTivyFDyD2H3srLbsasCWTEGHjQe7jgbDolWCsmEULfMFy+dwPReronu063LAAP/XWDL4lXfuT8HmjYpFv59Zwnc7kU2HbQkqm5e/XVGrRCfDkev8Lu5Ee43ERdu3A06ZIFCXg9Yc2Jkl28orsGCqf6QEJ/yWJ02NGHeF6R/AGboweGxmZzoYq6b96pN7RLCwayyti1kDkgZpbIX7rjuboE7kM3YolSN002WAn1AR28YWrK4mZIdnOtURox/bB4bwlfGTxKcE3nDhjfVdSGDwxMPc8fuJMoyGaFsMFJqh5577x3hHYoUSOZkWs6GGVvHNaYiTXTxb3At+louqFP8yEA8mGIWqZOATK81CLwYdoWAjxyT9sRIQ+TRBYJD2HKWYw97JZIr+z740OyLcy7jY7b1zYWsjKYsY27TGV7DyQzxcRpkAZROWd4lFvN9ehjl89jFTC3VnG1TqkV+V77QiS529Ux9Ifpe/LrtXz46kSfMDbRt39217Rqp3lm/winRc140TCO7L+16Z0XAaNoicPC8W3S2VJ9SGo2C0dDseYpYdpLgkAEp81yWDhAMx3DHnau1nZak//65HiNU3cN6dSJbhAaQKnIDHcQfwQb6M2g2w4w1BMwzqUTgGb8erWcQ64eRwXdRfRryrm0wFtwVLTk8033QJPcGylNfgPgssydmnRMPlMNDm1GLHxrmCVgYjoY6TSa0N/att9mH+lA4GDMEF12baldFV1GQaxN5NkMEsrRdgfmUxALPQDdXHyKQWl3oiFN5YU4qgMmTn2XwYnqcO1sntBVaCt+ZxvLqu2ywRgJalqKo44IWatYa9sv5jBcPH6vU2YFL20KjxoWdb0PD+D13hDBpWnO016DvoVdYtH1BJeRLMT9WBSQxAgMQ6J23FHHR3oD4cbC4FnKx9VzCMHEtaRCcag7bjm+AmXWDlqsNx0yQ1A6rkFDN7Mwtg4qfBdkei+2Aa5a6hTVGub7cSBY05LeUj22WBk6H9MFcZiu1wISNFsysVc8hTNHWfpG0Kd2MKvZhMEDczsI4HLTqqfasVzwv72YxmXNRrD7IX1EaVBhRoWmMtsRT0J7iCWlx5zNC8eqefvzYzhrxvnn+hgDFuvIrX4kLYPJGdSZIoK72eJ5eB08V4D/4oRFBgi/arCdwcL0Mu5FcTEvZw9kJSOHV575csL2+RvKm7ihYhvmnK1RcRHgVzhSST4dByWEp0j7N6nIkXFx6gmsi6WXqYg3Tm1N2G4rm5W/89/TeaNOC+ufrX53rnJqRAtgA3Urp4ggc0hac0UxwxUGVaeeZRphlOZQ6rkCjOrDspme16YR+rcQijM+l5jmFQ6HhHwCWvMuTlfieQ7QrNh+g1cWLh4uIzhFVLyqLtB93abNiDuRH6Vv4Yb6HzsM5zQhAwWZudQ044ITrIGKatTrdImjZEdLTkGDiGRQEMtODr13hRfmjfy0sEr1qn8taERgD2azQFURQWOPNK5/OhqeiQBPN9i0NAl7H497+P5JEctTTDV/foPUBIFzKoA3G30Fgvm3Ww6QiQlJwV1mY5Coqm7tKBTEY8neaUr6Yih2XEy7GgbRgiY3hbFmQbeztoFNlWoXT0MW7nhwOeMh60XCb1lIWxi2DnvouBAV57W5zYRO++3ukmTL2XHUtyGL9Df3inEzo6PAR9v4qzGS7dmSfVvBV7OhLS7JXBlSZVsSbNlxPe/6PUjzlxyW82tzPHWLkPqWc4FdY4wAtgjNkLWlpBIYmgNGxbaZ5yC2DqQm9FM/q/undLUTvIp/qY4biPX+qCeCB9LUBuPXUp87VwYZYqcL/SK52F7DXnvd/0QunD/xoZhXQxdmr7+Sjq9zapfU9gRzjFT5JR4wVcy58nx2sOeQG60wasWzV5870Z/WsvnMbPOKxlWuTKL2tlIn7BfWOW/6gOxSofkHLcetkw0udKpxtymSkx6uITggceZubpLKa73MfROYJ8Xsewd844TSIsYRJXJXz2YrglIChqMpj4jEY+cSFw+iLEGc8nw/CioWQRI1cRQPoNVkS4+vhbl8JaDOZbaFRc/z2h2kci+6rD//NK2cCdr7uzf+c8rGuSO07G4wiDCI96FH3vtyw/q4+TtXaSlrY9TmoZAIhvLVL4Hqo+x9w3/xImzw1sIzEOun3XtiML4vtFMY8Q+OjsdueSiM1Wm6tpX0tZ0sg0qzVFsjn0u/IF62pwmLDzSYVbbX++i7BcRj/9yIdcsJ5E1MpaWz/hNC+v5E2S1OsECx5xmZYxR4bHLnD9ha3o9YNbF1Pg6kKfuJGuMn9Pw0lUPBvZ1pJXuJuUoZM5daGGqfNS8EfrXW4eJBrKdFTTsDy+ZmQWIOkxXxlQxlVewp8Ryhp1Qx2pQW/nOwoFUDoDuwZOmts4KSgcPAvt3h16HYBSY5WYm4ItPXmcv+z83/zigSN50e7HFpBUNa1qCD6XeWgqLRvSvj5xfzz9J1M4WYuhG9cpvVS/VSkDHwm50z8SezXMkHJEqHxANYgV2WfWDaRK78cRwg0lJbApyemzXq9E7ucpPT+C8kfv4dvVypXZjZe1XroqX6oCduLut+wCICYanckCZg9ZmVUTdgjisrrJrjQpwcSiHj2okEYCv6qQpUR4on/dkzy0Vmjz1TANQEkOGAd6bDywu9+YsObzf72dM5mQFWRC4ECgGLcXKrt5aZG9mX5IojkytROZ6E1ODvt3YcvAoMibdDjpkdVKQl9KxEygZd5T1NiDdKE9n8xLhTJEj1wDWxcdKRKaoHIdEGiaoqnL1C7swE272hReWLiNXeYYmKlI5ffvv/8GE5Ik06OTGlm3SHgAN56omTfjFy7BYHxiuuH2Lx9yuNMp70G1V/kz0LqLeHxXZQiwkkNhCT1P3wQWnL66yVbn63WYz+EAxEtRtCZBwUw4YNn2ytL7MlG+4Yizn3oyGT/qWgYW3yPXFGfdi/INhwFpQkrHlY/u2trb9ClJB/t1FvTQHV1jNBYlQrHGdFn7mzoMzoEmTO0310KzqnT8/QFSFhZLJQd2YPDNaVY2ZlFRysID7/a8IkSRrBj0SUWZoGd4ghWc7KU3zxPty8WrcxranDgeJoMVBSdLDl0VbkbrPeOU32d+fKb9fda0oHfrOn/4sxveN9PtFIEJ+x1/D3DtR6gKBgROuTOnovj7YNoWZ/sCPJeNZ5pksgdrtjQOhwN+5Sw7jZN1cjGHnOiZJfUPtWDlDN2Fbg1L2AEfhK7HVI9wCN4MIDeFyshRkrQsZ6yAfa+s0Jqh3BGA/T8DXWtWuOpR9wSQvjs03M5ClRr/ojtKIojb7wsB9pllN+3gc+5ptDJba9pfdYBX3tCDjG4n6UUsslCLz6gn9PWwkQvhmgaMjmC/lQ6zyZyDCGDPrcaFsRLHfiWL9itaqS4uU6eMI3HHU0foTcyeXUTd/wnY9bkzbfiam7XO7Uiw+BrGg1ecaPmqsI0lW3L9GPTakSQKFMARQZltPw4ZEJhpNBaU8DOQEVzUzgm2NiXS0yk6/RXBwDQrlg8pHAi4Ovzi0mAxGTB9leTrvBoh4Zsls1ltQlaNz5Ebpdu+gU5Mf6J2Qf2OOISuaQkuCb5an9Ve6aa3Lt8A5rC4S+XHv5sNVQLwDsJurBv0Idj+IqO8hKimO8m4nF8Vt3wjDcJyZAe6GlMB0+G0nZQ91oQP4gR4eiKdIpW9wCm2DkvGN1XZeh6D5EykG0MJk24NcH+E+fexqCtxytvkVsUGwjdtrnyB2Gu+kplcTty/oT/sutcP6MMi52F/J2bc3vAGrF+bnK0w37YmGdO+UBWchwi5l1rxqCPic4Lr43qRJGuEAn6E+xwKdtexQbcRu6mWLivrReOpug/cz50t+WgBvKYxjfY1AARMKGV9JHOEHtqlGnwSEtJFz7nd3CSTVeLd4oXezqGQr6ePuyuYuLcVLFKLa0uObANJ1CjrnTIv84N7XgPL0XaxJId88Ex2smTkmAopDiCPy4Q4BsUm9ci6FzcUNfKxLK8CvA5aqDS9eIZ2MFsA1grBe/lcr0TNAS1rpuf7D3siKo/Vrca7fJDAqaT9aq42zg0Z9iNgkdVbcsgFf8Tv96DiNzhLe3040UxWZXZ6Yw5HrlsiLIi/giwizUQM2syLoXbLyLL/ISc3SgGL7eqL1g2TaJ2+pkxQPwIvwHrN3mNuEzz90B5gI0cWam6GiCDFcqlzfsTSznGcVy1I5YWj3w0eZuyKYbLP7UoZiIAqz3ug34j8YXEQUFeFMk+A32B4qYvl1Kn7w+bnMjLjD/N9h/m0Kx+taI4Hybt/rcgq7o83LsUGQuYEAV2Ox1rZtUPmiSdtljbnwqFi6iMi7HRiUox2xG8Ow5Vcb088IAAMT0OsH8yGxuxZKYBrXRNRygjN2bPqKVtUn3pJgRsGyS/ulepPMGD8D5aMqSXs7h/bfH3QQ6/eQq1SQLdE7q7ZCJhAD02NzlvX2expRoFNI4P2a8/2PQWSkSwfNCAF+1IKclf9jcwctsRbDuqxjc+/eNwIWSKl2Aq8y0LbRZIS5hSbNGSX56eOSkOwjJ6RB/Gf9IyBq5OiVy1CzMloXM0z5FcvjCQRXVJn2h6i3MIeMZSVLjNRFNOZsT8FN4RAhYWwuBRxH7DCAwd7Pmy/LP1qd+7I/ftzfjttj6cTj4au6khtbfzuvypJPWRwLvIxiGnjjACypv/JyNQhGeF5FubC9KFmKGfx+aewetpQwtlN5FI2XEEqsMAnDOwHBEdGh3EM9MFEzXAnENXZ4LrXIDXvONLqOgH2FOFSehIKOAu+SHoVZkx0Hf/mXJZtiTFAhvAhbgo6TNUKYBzhg38wOx+2Adq8kB+WVj0njEd0SseEulq5npldUbl+eHP5wC7Cx6GtLdGsMntycJF9/CH6oH86daD34BZAeWmhkHOLjwanqNUc5xYsDfzX2NW4CPLCggKMiM6JbnBcHT38wwamWcCHqERnJ8I9IVlH5cjfpasCB9rRhfN07Z9EADnnmfUXC7/oCZYImRv3u++JoyFhUMGpfU1hzl6gH8uYQbqF0eEigN6rom+5QxxifXWKNgROUQ082bF5xNlgac5TRTrmqMozyyBL/UG2DgtJvlmQ4ZwPxuskMSqAvgHlJLr6ESTQZo6T5o5zqtn0oVHG1T0b5WhB598QDttfyMl6ZRnUP8zBo6fuk1mgwFvaFH+TyDSdWD07qJfSMGuNEvRnC5JRAlBIQ1Rv1kZu2NMuy+tLAgFXP7QivArudRjwHSL3CCvR9Nt07CEe5XwUUALGoJX6LCMNLSAd1rNpMn/w8hoPBD2MuMAGO3R6NjnFOeYJur4sjIK+aelB+hxrfs7XAFc9yptv4xdg40egp4wnZc+Uw2rofnULyRKBkySYlPe1q9ya3VfdIPBN2dvhsIJHGYIowG9L7bfncNeU0U4ITuWsTE9qvDUoD8PbetibD7Wlcinujaxo/jtYNCe3kF9SfsWtbueMrL49/eNh9GNLDkBEWn/jGjUgNri4ARtUUBy2fuF3LvJ880cyfEWg7KVU0H67uhIz/7a6gEFUUPpGt9SYMEMHhiZtdi9avYCZDUmTf6LM/gH40a5lavhmgxXI+S/XH1NDDaY+dErrqoqigAD55tVY+2CIMdF40pJSsb/+sGY2QsEf6CwiH1h6xXJJrYyd6yjXjk5dB5dGR4QF8d1gd88YX45FXRyjdeUuP/auCUx5PvsIWNTfR7znX7iyNn0uDkO5BTLQKOXODxkWU+9aKUqrp2wpbZErsyCgjEeljjIZ5W2/Eggoaz4YyCXZOk1Hooe01bM83YiUSK2dlnR+bduB5Ekz5jc5zvE6MVsS/VkxIIVIhAZ53IF/+5FjuHvYCPuQYhKeKsFJh7E6VwlbIFSWcSsEGbGzWO6UnmV4ICKHXI6VYIZo8j96GDBTL2JBdl7A9+GGyEsvR1oOlZGZgi+Ob9FhAJ+36t02gYylDuAtFOVSUiZEFch0kMrth7db1v21CTIeIsSZ01P8ftynEvfPRbUnERwruBPF5utNOrT9s3/AtVViEo+RaSTaTqAtu2StMcEclmInIedwkpQ70AOJU/BsbJvJ3oxRrGR+30PnnBmWgHyVOTa792iVorznQrHSR06v9fWvOT77hNP6vcPQWG42DwTiapoLPCCAmFCZxb0OX36Ff2EquocyTHysUT8JJuMIXIOQiOvfq3YSZ0AUKHvHYoKsiYb0fOW9pyvyTU5Z+R7RcERb+cIo5ie7UJm6HO+Aq4bbX5q29ioa7bma4NWzYswwbEFTVu2uZuHS7NUV0Cz/hb9E5yuIXhs0BLQJ6QIweai4+vx5xsBat2LSjncuTF1f9GwI9j423gMhPKVzkc85KDdYXgtNDffg9FNCmC1nbLdFJrNB+onWrjQIPd9vIvT6kPo/7pUwY6mq/2HSGariWYGqWKFspTamQbK/Yo0t4tTbd4DKeBsYusKX3vFFZ/11v4IeU0a0WEizvEmAOmev4zujywSIzfkB8hyTlr07KhUW78Osh6F7iYwi7RNCxk8k5EHlj5khrS59yAep4uTKKwQIBNxYTwVGaK12fRKa1qBi39VVPBCM+qfYsCxndxlvtVr3fxlLSat4MTtW7TCkZQvpDyBS7QkFt40sLtuO66Ez30GDEQlg3X3JJOdwiCkeJ5DDVjKmaYTPlBgCUt70et0gkbUFcoLy/OpReqic36x9NBnAvfqLyXvxg+Sr5tmXFGALW/CsBBiROoitUX392OdScgxx56lhfeG6EcXzEv/nl9GnVqtIispY8R8KWdZnwEgGAsxjnrEuz6kN/6Bb25DTo7GC6F2RtMSIwH5P4D3yK8kU7FENPCedn8CJdMK5y5AJcSXvD6hreShiwsNIqpIZs1EJy/I4Aq45arE/k8BkuQM0V2ZdZHzm2bgEy4SPjKEY8pGtJgbKDUeSBVIUe13A41EzZNnCUgQCEWqX366EvG9IiJ8vq43cLec9PEMHhIlWijFMoEI6ofhDWcucmV0IZifI/gOSYAkAPGtz+YyUTC4paDxidaLLF5A5luyZfILznPJ64ykn8qFr/pZAuuF+1wpNsdfE3Uz/uvxp/QqikI8PjcdAvHrp3PLeDJtWThuX1RP/d5KWlhay8orXsY3vSdoLEzGnAIquhCERvurqAO3zmfTvako1UzMrlN/dctZCkRF29rxrgo9W0/23840VLxIVIAyg6MzCxmFtVUF8JekiTlqGi4/4I3Krm0BCsvzs16ucp+n7UV2kN1n849uIjnX+xwKwfjhCoadp08HPaFm/21IYaNhVsUeyXKqdlOSwh/2JQQdeOuqYz10VRpGho02BmhXXGpTl6XIn9d/Og6/GxnAeexvu57r6QtUWw8b09NvO90VtXqeAQOxHzB+TIj1wi4fyhcV+kr6fH6I6VEy8mM4HG9N4I8Qn7lYOuiqH+QqC8XbKEr1z0TuZdIJetByMnpuy1xtuTejAQOiSL2KaqyTRBagOu0fbBPlclZNGn3JKSVdOtoE09u8+gt0tGhbWtFZrvbvS2kknjcpMe2k4mkcZzmO9SUcfR/Y/ErrbW35juS8YCYkw93c9VwoSrNM2ygKBB8mMcm/C2ioeMCPL4BFOwb0+t/N+RSOIyebF2nYmvklWr+xz1EdBGzGMd6qGT8OA0f7tK/bQInAqHSZ0v/TfeB50f4HQV+Pp7fsReqUS+d8LlomprdHEeXavt9rpfyo0vgMNfhNSrcwe5P7sjBe12kV1jXahSsmQcUB03ANY2D6Y69YqtW2jpUYQqhrd5lIFsQ7La5LM1mmAT+grMv7LaGQOEfslNZUHtIcE3sQSfJg5nmZ0ESf2FP+jiPuRfj3NRdvSrIGmRLgvLhMRbFkSDGp9dQ3bhbcq9GoSchAc5EQIr8oZfsj/TTl5170qOcUFzFQbQ+4mrUhZ3mmflCR8AUqRb5tCoNXA0pkCh1AY29uFDuMChTZeUYGENtpHexm9VPCv8IwRsmPxfJuHrfg8EasOyFZimWPBsRNGJGbQLgOAKl4V+X+wyelfGSfWwzr5LIJRYdO+iK7fTax04gqZLbbsNLH/k/JH4HrR6jMPhxgmuWuyV4y8aABQdSlj1g6uZB2NQgoQo5rvljeovEv1OMZZdSZb89NTj4miscUvA4ay4uVwx1Fg3pCUYbpNfbIaVUaCzfCzKkHuH+soqNO62yXiaFTsk+lx5Ar6LtpI5NU0ta+nlY2I9pg9w2tjeGSZ4wd+2CSRCmh/Hyi6fhGe182HmHeshZtI6Z2TdHfDxcksKeN+c+2Uo8/JfgKM0HRcjRjMBWt6UAwhusk4t1ZVdo2yXKcWyW7Te5fBFGQZ6Qxej1Psl5njIIWRlSlWjksIraE+HJkcKKyzrDLs7SPOAKFD8y8ISYhPPJ9xdpLtrdQHbqzRCzh7H2H3wZQObCHpCb0ssOIUJc6AgXflTdNU3ynU9qwFQS9cRB8VllxklTHf8El07mBF2kcszCW/B9g7SwbMx2Of3m+zoZqFpNXxgIupUTomNQln4zcA7UNvM0vrBzc+nSBzJJPxC707HK8zWYoZVQkWrAZcHs2yxIXAnJIT3FI3ZzDEhj1wdk3a1CKcO/utA7iqp6l9fYWDxV0yiwsJAtZi08FUEN68ODYNCNXyJ2qDdCd7fw1FdoyAkGhLf72i6keNQoz/nlfhFuON0GRgNyZDmifT48+Z/FIICgGHXaCCwWtVQTHFtPGkv+t9wmqq/fA3vVT5ShJlHJfeVEDQLqD+AlTogRo+CbImmGaMwIoczfWrst5syVwwXVgYaCrrItrg7I4f7kwkRTQu//3Qzq4ONjzrQQjLF9VTDOvTPHT7hymU5Dnbo4S3ZUAc0V/iKpsGRCL8E0OhPeXu5KETWV+LYHYN8EXnP68uD/hCrJLIVjBae+Q8Yg+U77zthgvazb6hkER48Nqw/stfH7YzcZy9OGRcA0/oYopfiAFKwz7L7D9m1IKcWNykHpSD9AZEmVMTW4VqjTsfXpYamcxxOquA/gEMyygSCLD+vSMT8mrwnm6CfkT05BTDAND+Llzs4CXy9+/RKOj1crzmkYW679ZHNsVzQYCuRRKhyFHh3BpjoCX7vI13sLl/VZsaThWo4OSYTXgKDD0WxpysGPCiqHxRGBeRs00wVLfFBVu44M+dN8m2C/cAct+72nmQhZScW0z8Il3ypj6KZ6nz3hxwJ2VEnzatF6SFHUSUIm2/E0Rt4OtxSdUnCY/xZ4zZ8q9pnkBBP9n6xQSWmuUt7A6m5x0XWUkY25YXgverWtae1ZS9S3aAXi1Ih6enk7eHuMViLvOUcJ5ma+YCcsz+1SoV0oQ8/h3yqHxYn06Kb4cBxHiIzkkcLD1ASF6TmwPHqTZyg5UueIbbx8J3fHEgCf5qTbgfbqNlhYXdaWg+v2Repa0tKLnllr423tcr3goswyu6SsLAaV5Ao6lPEcYSpP7Mgwm52EmWe66zPlzkq7LddCx0IRVX/hJQw1n1ElVoSAqYQOnhkrZ9dofbVMyZNlP9uAI9iLebgC8oYUq5lN+9FxDc9En7OPJzv0Fxg4RtZE67mmM241knXVLmX1/DU+J1aWq126yj6DneAywWnNR8YGmiNdw3g6giGl1A/rmZeJGGCxDljuzD2lEZO4xXz08l8dGcorG8T67tbbibEf3E8C2yjcKA/TISRD5gqLFTMULpLKHCg9JfpmyR4LhI62+XQ32M2KWsGS2NOZXR68FQTZtuDqBc4WjRdKH5eDa0fSeGJlmVHtq13JaaJ1gIR4x2Fnaau94ArPmMyRsMCGM2RrFBeNiHxm7o4RNjN5KksZO7bnksmk1ICcbY20QGjKWq4Z4rUJcyY+zl82kUq1PbZai6rCo907p/EDqs/aoQNdpuz03YnJmT3AY+wnFIaEkj+M0WBMrqxRP0nLa201iMvFlEBJ/dRx8Q7I7DFcCEZnniFqwTa08YlzCEkTSDceJCaqrmTLYRrsiUprCLlp7wJKTnDsmIjSYDGvnfAA7x6Mzh6boAMBnTOBkbsQkO2isLQWhBU9GDtxT9BOy0XsEul0OV/b5NwldBwYMapA0/IoUAyt47RRfuSqNsEMcjsE7NqxprTSZ2rkoqguZ/3Id/XmS0VMAWlXFu3wkOaLkHE31rIesMO2Vvuz+qysjZs3Lns25Ct+NDZtnKrt7uFEWA5O8na8MqvtUWiVYXOPEdfQz9ZwtzRKmtOcz67u2XzuJ7JoSGX1F6Z6eta/CksO9wSXW8JUB7rvxekfFznIJqKut+Iva5hGWXVqGSyLzO5QDP2M+Du5aQIJ5YilfxQgSHcbBpVGfQRXebbIaImz2jFQ9J4SZ1cuth4D0Sr5UN9nTuE80l+uWl+lLbNftAk4F+E3wdtpKkcR2jb7o11SLTECAsJxZINITaOwp7SxuNj3a5TfPf2NCi9GU6Oq9sY+Z8ZRynVEsWmJ5Gi8mnd8fMkQq4/QcgZ00ROn1nKE6N+fyeWM+2OPKu+nZF6+cw4WwXupMIexNWfdFhx0vmJAtvxcXtIULqQUdQ4NOHTDkiItDpvXMhkLg6IT6jcPpMXQXaIG8FnIRiKIoHrYV41WZcTt3OPZqdUab/ZNeDUAMJnveJeckrJwAUoQAzqR1+tt/UT6wSAY5FjG6obZR+ho7kUU0oJh9fZa2t4Qzd1YFP5Yj5u3x+5T4mhyZGOXxfid8Q5Nt2XxRF1TR2nOrXBROyISIl6kAAhnMyaYrJnEmj4nC6Hcuc5u7/ZhGG/sslht6M91sEm/Jwb44P9YYi9eqnVAsyUg4PYJKxOirrDedwgA2qBM3YQ4u1ygiCyfS0bgss8JuspZfKMWk46fmHOPMoTtSXK63T8pavKM91bax9jFwtLrBM0rN+znuC/TsWbxe9FKFbiuQacOkhComc42KvZGeHkuyd4AtoEi+LynWAx++xF6gtL31tXw2+ZSC5BnFnU6dWce+0YNXpNLYk4fEMykXIpGsid0zebL+k4HcHGQwsGffSpKrWgNknpz2BnEhQAiGkOptR4Z6HunuKdwbkBriFjEuC3G/wMGtgBu9OVXSnkdIvgmujIxPEMI+GnfrV8ki8D5bcg30kGuwhXKXOkQoYAJbHH3F/37o4415rmq/Xp2TWAJnj8TDJHoPXTmq0bJQcsh/XENCUjl1csb9x0dfPkAp3xXHatQ77r0U9cq25gdXeVgUZweBWmK+828732Kow7VDrpDQVRUigIlbB+jMtT3FzaTd7J0soksR5aeDg4mL8T/mEaDS6Ke0EbYNa+vTQ9mfTRl5i0loNtKrcHTqrlqKWCwLnURpYs36wS6pwAMSqr9uFW6EFW2/8vpX+WgVr4cswHr8Yc5pS+9SOhNkzeIe01Eixrx/F6RHlxMuWbG6pRTWXaVrK6MNhmrGkEptKQ4cmGk2M2TrRMy+4VojoAcdt+fhL4sCVxDNSbypM+/HghAq92KsyvZcjPCQQPI8ab7z6IxHx62lWFI5Q8n5CRV2/dgg0DoRBHxdC6gCrHBwpug4wJVAkUiplZEUzANext5gK75FX6nNJI+NZkAvMNOtx9xsNECWNpOGYr3ruTEEqsnhau9pMakPjxL286EgihGiySYQozJaP17sIyGO3oKToR3fKPmxk9XZNgdJWzJBJC0bolCX2WbxrzDnTwuzdY/3mUO18yOYDVe2O1fGyy+GqrWNJmsow4z3oszNmx0qTy/ly6Oc3Nxo4R6OW9hb0uEqI1M5KFHVTypDTlEnJQWIHCdYHv6m7nvVMhfpnSZCxbQash+Eq9+AuC4PNF8VvxT2rk3BEdU66LPpkUom2iv3KXcGOjAOx9UGNxZb2npKmvNA8xC3gEuU8jKCyjHdjs8Fz3QVvedA39u+UcjaPHqYYMA5Wl3R53ZceB6OwfuZOBOzAsxCtJbLaeZJ+A2aHzJ3i3qfHQEOXRIPnDC3fKW6f28QNH0kiGUV7hJsfax7JSknXsya6lrt5WGjEH8VXxBrwwn0e48+I3WFO3YQmdzvoX2CCAEhO9usOxq9o+29ely0jcJexHOLx1eEoXh2p707asolse5ioJDQeA3Vu376G/OtuAXZyqlGVKGdwiAP9ZoTqOSVEe6fiW6PdpchjHTRVvNZAL80+vpt+tZZK9RABCn0ytdASrJRslILLw3w1Ji/SYgfyCzey6sLlLSYFdO4FXmo04UGL53g9GpoKeNinVH/llv9iW5uhh4C9IWJ+ACckae1IiQnEVwdx4nhomM7NCWmrqE/tUiDtVoVpox/MS8LCS84u1o7Bj7bd8pMtptBh1fyT0v0o22+f3ct6X/s9UNvy39OVPtStpGWtSPiXeKwHQgeFlCQireO3Pg4hXr972yJbZRz1jw7L3guFAijA0bO10QPzYsONF3H8rpOAiSkrtfoyq8Az/O3FYJCttGB3BZd3QxtWXjWT/1V3Hbk0PZ9UIvkAjev8C+0oUF4/LvjjC2sbgedoA74wa5qJJ0kSfnxNQy5RgGAQnBGZKozzJ40bh63be6HU7EGGFHG0PW1AtXxfErz6uZB0w7r/9Kh/0VfcS556+s+EGR/I5ay43SsBR1AH3lxLGuMmUkPgVHPWWc9z+1pAoTioeemVlIUEbKnBC6xcBHFWabCc0UWXkxVEId8yKkGU0692mt0JS8DmgxVFsdGDiVLpFCeJf59FXJDFpjfsBYMmNOu+SqGcDNSLLMw01TPjrFopGh6mgWKKwrFSsMbFjHaDpOJXBmWQdxdVIBYRnmipJcXfu3W64PnAF3lMDdtFPM8L+glsNmOa3fUJN3n/8Gm1ZwPQhaR+padsGiytXfYNblCquuMOWKdS8wKi+R529Iy/z1t4TbM5kLY0qT179I02GX6MSmDPtiUXEO3+EewuHCc3EOKtwEiHMp+/jUUln3wK0hz/w6HjZ6eYTmMeg3Lso7cUWI9IMpWV2RPdf2CppYR0Z1nItpw/+k1dfIxX0dDgPKaYxSfdt54Ypqpt0lFtQ4uUlEvyvFemZKyFvUjL2oHeLFBGCmoALAkFGijHWjpQ7MtygbHz4Uxpn3oDcLAhKiLBBtxlljJECo6BtCj9hdXj/JKQlIcR331sXmq+/zgPbwRn59iduTMGdehNEV2xUmeO2q54D6gFvsKhhJtoL9bF2KCNSc5ri6UfmLh0b639z2qx16p3Uq6ljDDjbEEAI/RWnbltVk/v4REiEe1HVFrl2SdfDcv4ubKpFooBx1s0u+1vx0zAMcLWnvXxilstdNx9tsQF7dQZ5Os6v51NUQTeiFUGLxh58gv3HEiHFO3Gjm2zcD0Ay7hIGZcj4dxV3JR6zWMNcSVDm6nMkhea2CVEkO3L9ozK4BcbdARsBzhHF/FNWIZdr/bz7qQjGzkioa7BIdbfanBUBwa78iOFImQh3LHgBBYiYSdeXehfDWh/yJP0bsJWgGg+pjr/nk0wnOl8oz2a/3VnximCEUaPhmu8PLMr+GDGDWgShruaR7CtrTtbzvLDWcRYkSIc8QQ5B+NKzc2/oslBJB3axiESEHapMIW/VrWthjiAcxX6ossHMtplYyRA8WFW+aE7FlIE4vWzvtTpRNU+Z9R8njU3r2RIymoAYDpbw5k3xd0NoSQpEMIL1ubZiec/Rt7hKyjEDtof5EFGamvEQ22eukS7tRMaB2ZCOdRf/xvGIjZH4MhF9XGM/TXMXPJ0djPCIE8Jtd3mr5eBISd9vNf3q/n4WMoOL9bPs1ufUCgbp5yO30tmBrGykw1vegHxA3wM6IWVHaaXpK6S9bHnEVdZ/3QBDR6DRuiqnD3oIwRXmEf+hWMGQANIK87gIXrnvCk5oKVqJeLLkmoEPpyi+U3/+q5gDvwKmySbapNZzUpu2s4vzAyCGkb8E9eH1qwxibYd4tOVNwNP4ml1yYInhPhRFy6Zf7mKXMFLcy/SSC6yvuQdJEpmnIgfZw0dleR6I0ohXi9Tvp5IgG8SrWm0e41ls4XSgyoOAq4uKH0vstg8V8eH/6Y/xpAzbA3h2y5x/o/l1+4iZutmvv+xafcUbF47jXxG0wdBqZiyq9WBk73XHX4pwvUNIw+2h3CADcX2wY9FioSp+uw5NXYzL6l9bzA4JGFYYIWUKzXFy84OvRw2vC4hNAw/JwEfgXrHifr3d1KQSWPfV0yTS02sJVUMpU9cWBKSr6YCKFVo0GDEU9/wwBPv98X5X3zrS1Ie3zv7OTU5eRM6z5iVx7C1VwgZToxTT1nYudo6zT0dhLwPe2x8erJKdtUEIZmsKrlI9MYpXzVVJsyosQuBg4jDZI2BF8DBoQuuAygiIHqXyLOnKaiQAsO41DniquQmXQNT5XZw/qjyzWt+R85GFVemhqSHJ3S+/7yMA39KIYA29z7CfWe36uroTTlNPFdEExwS6FEk63vQJersv299+ka/7NLY7LNqm3isYHXikt55dnpLJCITFPoIuxUKuwSYLEPe337vPmV0X1K6Wfxj8YHEEgoi4ayfiz7fA9Zh7ojli4vxPu5KvcmBxvyJWaOiOGvfqUZpQSKIdic96/4/aTPckqTOeRs0Z2i0NNWZxcWXCjXBfvOsI/tUsCJGtSBBK7nVBPKcD2by1yXZpV57j2W43fAqBnrLB5jmxtgLRITkF2XjFI8VBpUYI16S/00Itg7tn2OJAbyNDfzQKiE+SbhPO92GZXacs/j9o6pISXMahfq7/Yfr/PxQ/GA2WNkYCkKUmbl8QU+sa43nxhrDHrq0ezoV0P+wGXR5fQiW92S5M1jL4jEt50bamIQd79KMrDdReuupt97907ZD59sEa0mpYr7/TNQ0OQnRROGoiHWlvj6J4nbC8vfXwDW119XhHGFW8gIE7pkNsLcUnzbnJXNlw+bjEjaCLmmMtk1S32iR5qkojwQcyNClXILwumbridfJIzCYgtT0sboLS+OLCE/kbUbrw42+Qom+JYkBcA58dE4GLcwwdA9yz8bX0tbyR3AqHF7/V1Vc9bAYSbcAJzSDzBm0PhsqFfPwYxnoLLFmC6weMHUXH4/mwBNrjuRrcXsL4WsfeKf99PTGmbXEJfPhS+VoxI/HL+qMM9Kk9xnTJ3cT67ou1frdxcUm7T3Wqca/ASrgX7YfWj1OF8Sugkmd58JlW7pt13QEx02uIPrUSzT+VG5L08rC1evrEbtPE1buh4DEUkKJxt1OVxIw6reRNQ16eYl8/USOKGSzW9ZF2tQ+UuWUFsxuyAsd3GRjOPYhlR/c8VDYAzkx+TxDR52uSHWpluFMxBgkot4Bp/LU/vI4JvD6/4g8q3cNrkBFfTYokzLeg/3sCBiqMxqyx9jtqGQ4iAgo85qfkfhu51HMl2+wfx74gs8dbSCzuLj2xbNbmBVanNAuLYIUDtAwpZetGNLL49xOE0okQ+6cmH9X2MIB0Mzu96/hgTS2LJeB1g5bOmMNbfOLhHvc9Ic35e8bAuICZfq66qtO8/7Ut94GbrwRJ9zNs9Y94a9SlE+6eSXneiyb+H+6UXKMYNXhr2BK5X4JBF6+AZI9RpwMZG7GwYFRp7z+d2A6w7Pz7EL9/fbUyszr0r7myC6d2PSUHXTIKY//wI9c4wIbmiGWk6VhpqwPckai1vAWvXBUpumaOMcRgJJHcYSynoS/I7GXV+CnVb4MSmnBWVcsT0Qj0PmAsjZOVhWqqmLjmgTimRgHM5JjYJK7Tgq5TMU53csTGr+Vn1K6NaBWxUDvNgsHnUboDye5REhbq8rAZj+iBgg2nw4cHIVCrb4UF/OFltPWfjGrnhco+xU284KD56dQu6cMAv2t+tdFBKbqCwygjai5rwXz1+KG32Wm0jwsq8QGMLmDBfCiCsblPJ1X5wojU9xe/rQxFdK062RJ4zfd1ngnngp4FAhR+B8IeBJxbWisuasRLvuHHLSjfSoFcevBu8wle48PF/cuTE2kNru9xGIYCQ1bAcupGn/aEbtutyVCIa7AcClD77nFXknnYh/Ql+CgB+/8i0U+Lgm6/QyCiBBPI2XR1WHg1GdLdDB4xNSx32oct0S4HaauijbXjAtxgrAok8cJBSeDqk8uCdpm+Fdg7S0WRoqJpe8lbqAf36O87hChHtGoWcJliBRgE3oSrGeBT73hUExExc81txA/8bDoLlFgU8d8hgLAzNeKo6vA7wH8v2w39iTlMBvFYZcw7pHUL3gIeMU82jODYMYP43pZsnNXbjS4SsFyl/NaTXx5keJuuc2v5acjK+xwuULhuNqdebY12WdZF+qIeyxeDMf9UAYY/wQzJFI03DGqaEK5jGOscFe2LwNnwPoPHWuyqNbD5DHs9sU7w3EZYEbaQam3LNX0yEQDujiBcbVzffEg6C3dyk+3iNmQoKFaNoq/JeJwnX4fX5kLRQ7+WZRQ7OtNt54hhITj8BKr4kqJEVTTKMsOaZvFHUEIDPqeLGJVMPIX4xPTaCQTvAh0Zvq9TFrk0fmdJhJVTE9mRDcFHOo/BygolahQR9o8AW23JirOfp3vJcoOLdVixllmP/FiJyM6V8gf0C72gkcZrjhbFlE2ftdoqrCBB1bHVJLrThqTSSZnC5OHB9oIigvulzHRn+bIVr30eygrI16atbsSueyvYq7yVREUROjHAuLx1nflZGAGsnO7DJCczvOMg0rJ/n6+HHjNjt+DvCQfUruzJsaZNJLhdpRxsMvak++iE3b9VihAjD8ZyHEbRlNQQVtVXLmxLuX6K6dIvrmiiCFRKDgJENVeT0ktsxNMP8czA2Y/7W+t8JGiD2jfTUXHxhLAeJhcg+DjZdYCeD/coRRHErtXKf2HWAK1dLJQuQMNQ4JIqp4N55Ptr+3P2L2FaWqxBXj/UNxTzrVQv0igtcxX3Vf2V6kiOUVGwb8XWiLkEo+fRHKo3jR3K1FWwzc+FtHDu140r37UypzEt6mNF+d03ukQ0NW/mLlZTGZKbi187dqb4jO8m3hkLEUFF5xw3NTDeL7mjEwuZZL6AyY6tJS9GmqZLJbW0oxXh9+G2X5jX+J42xiKo+sTK+MLjmMCIGhRcwA98KjXqj6vP7YZvofT3MlxbEza5JiRIGukvwvQF1iHgApFt3671SLB5us7030S9nXsSfPkGmLaXlZgDfqceX474yCpntMbX2etzrqBiJefXLWNzJZriTyYzwIR4g4XOB4vW12/wwQert2SIeSkT4JB0g0XfmOM8MtRlGmQwz8yqjn0ODe7TJLrxZ/pnqgBtK77Wg7wy4OmYhqxrr4xOHWiUqLprn9iAd7FlGjxSILcNTVp5a07lbzCpN8YDgeaZ0MfRQ/IfYgw8kgTrxSAg/o6E+Zk+lhlK3buD6zxTmIbuHfIujJ7u7xtUhN1pfdwDcDFz0wmcA+eF2TJpQCb/YVWI/G4eVh4XQI1SOtAJe744f3xqtaoGppUEbWghMP5rDGzog9Tx1bHfBDG5QcdlnFmx7SEHjE75iVitahllnt80agHVZ20pfUS4LHFTL+OBXR+/d6ne18nsLwXKInZ/ZWVMo67Uw4R66eU4ywSSefBuWzHI8WtbAFyjQdPjJ6HdK8/qRd8lBnCYzgtIHssmL/3zfeNC/J1p6+39XAHGxITA3Mdr6xphojv5SzSktHA7LA0co9Yd9oSrTDoWGKemsHIXd4cHBqxDA3aVwyx0E/ks8C3lfG2J6ydk59R/gkcz5ksyMSaX3bVtfBB2uIfZHfzlGiMjrBKFxpUe/nAbJbek9yJPvYsWNd9zmNJQaB2Fw6gu36jznvTJnpNl6LWSDXp/iPnJlLFO8i8QsKdMTpaV1j+Ba1pA5BPQUPc449BkpZ8GbYiA966ZMllC+OB7norXQBChVTugMuokv21V6N0CC/ExEybP60CKkK/WmVqX7EtbER+/CyezL2L21EazOaTcykIQTCuh+gMZd1o652X/COFCJ9QkQrJ8xfODuKu6H3NqVs6BI+5ApZo3htf3gNaaAR1lzuXY0EFVleKFVXULNC8rxrrftzG0iE9J2PGUP3wW4JTSt8lkA2XOIHYKqHZ1lJ9flw5OfO7MqX3F9mbtDAV8pJIpOrDUeq0d3vuvQa2FAvaHtOJkK62u3w7sYdAD7IwH5ZhxHtW8/mXINcHEMYt3qOCGclfAQwsIjKtL+tLoD9UA9tMCuvZ+LhrQm4H5lk+NyPSWPWHLBbCsu4GwqcYYOn1xCxFmHgigSa/blfOCm2pGiZLpcw7TNk6BwLmhnf7wPx79WacD9UQsSkr57z3EpmwC1yyjfgU9/a9akvFJXbJ54MCTG/13UF/KGTdDmhplFozt+4q1mLZ1APNUvH5FAISGfn5p5kt2CLDCugTly6e6CxbSaUfY9nMCNvhGLBX/nUdTbPOXfb2k9hskGR/GHYujs/IN8/Br2jcc8LzLMyW3CoHgjVn2maEhoyaKqhPTgnj6/237mfR61VKXKZM3Oct5ZJDbLIxZOr1V/XI2pMvhDRx4shkaNFSksYxPL55j3bzG9i6IM7kPXLZ1U7EtL1AHi3EpAXs4O4igaQOsI+if65yXUFXW4ZSvKi+sOuhMURvTurGpSE6EpUe3bTeajqEsrWI0w4cn1kSLxS+Z5u8XPnsSYkScgKtACq0Si9V1wGPh4jqoF6yPQqBQFnN5E+Wp8Ldl7wV+ls8y0EXcxEjjDB8hoTEnk6Xl1+RoRk8+uvJGJLJfCjXbYbwB1qX3EQ2kluL6saWO0DolWuYSnuqBfqinxrSZkhUOIJfOLlAo10fyTFID4iXcTnK07v7oBnXQdWMECMQ7dWrFOnyluPaTEVQe2GCff4rtfPH41WKVuHZfvRoY5t2+U8jLA9cktkDEURLYM8kGAke3mwsGX9ns3cNolIjvRdp+xDomdB55jJ7Bog5cltdAOl2PBvNgjJ9+bF5Dm45ybyGRQ2yQJWYgR8fFQxEP4dytVg7/C3pM/WKkY+c1s8s2z8j+Orwzlqtb1WQ2UoQ60Nqtq3hbvG1hShQ6Fnix2+lTaNVR7YgnUt0OFI87aYgOstqCDHG8YsygmUOoogkFKfGfzL8nVmJRpYJZk9Jb5XBOCiEZtdOxzcdccHDljH+kKr8QNNUX1mkC247lzWvRjfNC0ZlW5Ad7xIFcO+nCIPWAxqnYbEw3+PBWpth1+SVUAaSk8sY4TRl5SPQteW7myfErFyUML0qq3hnn7kZV0K+7O6As/7OpbqqLN+fMahN7mf/NZxX3LkIIQv1nz9G12v4o2nNcBnTJH1xCSlMWrDZEYtqyf9KYFlvmVgkxMdBYMWa/EjqI5RYmKpgLG54Z3eikx5hgQOVSNh6Q6kAUKp0lwy1RtMv6qz8MI4X1x2go/BnMQ/ntaYjwpvR7cuT7KWY2oQF8FEVpV3uoc6kCjtNKc/iXzf7Pvjv7WSYvCoJOcK9/rDAHro006drFyMdTkm+kkZxw5TsPrfveEdKxkmxuxV5ooi/DSgudtSgmjbks24rtn35ncwLlZT0Czjuw5Fxzwk0Hh5owxmdP7R+wwFNFT49iGrQpkvJCcDM/Dx/K2B+QzOoqtplNTDUFYxbuzQ/w4797MrUHJyV+E8MgHOKHfO1qf0UCklPvMsIapJHl8yT06bVcvUCSNnOmB8sXnWMfbOSZewzj5smi5WtmCCBvnR41onpH01KHQkhw3Zi+8JCRh9PgdSHMETDQUh5u2URaN+iH+jzmrLV1pK9ihe+kR2Dq87vpRAHdklCZGQcwMhfQI+1ijdqECWaJwRlV/jMmIdAMB4vRkciZcqrvBE7KjS7jRvAGftUcBkPQol7j2YXIjc+lATFJ/1MFdRMz/sL3uzDqzKu61ttpeIzoWdzBEGrHb5UzLfoMKWgfB43LSTAXQcUdLuaizPDAvP9+mYZQWTGqz/6O9sIDnU3r6LqiTiidkEpv0trz82wimJJF+icU+6alOJkO+dPi1bNbGg4F3eLlrOaOxU1BzOxMHPerFJ6/DbfhmVrnaiKwDvU4ukn0of8nDbxiJuGL1HdgAk4On4EykRN2H+enNly6Y7yE67WpKd3De/1peq0P/XJNuci/ARBnqk6bmQE5g5l5DWF5TQwInfb9rHDEeql8QzKElmgGAH/+TGecKeEkv4nAylwlTt/Ig7iEk6LsjzrlKvsNd8G2GGNO4evZOuuEVGrSJCP+0VkUaICstFgpybfaqdMFyl5zqucmuV/RD+3g/RQFeiExYAXZoEWn705e4r9Y2DkeFAGFAmGynZ/xAgX+xTJLA2rx4/ta1EqT47HD/43Ze/WsGNVj32Ab3KFmFle5KgXVSrd9uXskxKbW/cCWeaeSZVuVST+HDE1XEgH2usDPflaZMR6Qvk8Ur6xdbUxCDEVhEK+YbJGIOuNlMztfZiYACDXxJbP9lsz7K3hZCuPNk0XxraAxnwF5oPPjptCIRw8HaTs5cHU8GlNaD5C/iVKExH59zIjahbmbX7Oti1hOWaldfzkGzEIuBtoZqJbQbQav7x/FRTE1z43xpKhsCQ4cR6/wGyJ5McxgDH4UwzHLkZgfZY3dQ3Gl3ZO1EA4YGXVSIY6j7cH5KiO5yUYp74Db1sL+6lQuO+RSyVSVLRatYfgnfhhwuGqEyBhr6AfIVcNGP2W5uG6LoMATHDXeg9IoQboEzV2VTmTvIKQe/jfjthOdlbRW0gtkCNdVIu2urE8AxatCLVh3h2DjyXKO2caQa1kWjRDAS0Hq+F1Uzp+0HCfRgC7eOv6mA3e3oUFzcss2tCmGaBWwoexU3TWGmK2nKu3YUqGZBtRjymXkUv5vZrW+GkRfhwMqj/34DBEdcaduQOSK7UaFaGfEFTq+WqN9QrA4VLbT8ufqtyRATwyU6PQr0U6hqkhYGt0PoSXLdl+cXQVFams2d4RsBib2zHNAAULzvAXO2e534d1OFK/fu+0MzHGWNTxf5NK9iKqYwNdo9edrOrkawRdFLiyGjLU7DU+PEeVDXrXwktEcP8nqkhhIwJLwA8mjyuLbEYCk2WH6JDjXCCLs71TR696mNVtWtPiCsRHTnJ6/OGLyNKGOlJgAAIaM39NOXnT5OEQA2jHtBCSFG1GCm178ml1Yfu1yp2tlYGuefrBBtXSw/FxDOF4JK68kVnbywRLCGDmp2e1iNxvZgJSxktNjQvcgzIG7KhB7u1NRgKV2rVIAvhDE7wYACr0Fqmqkr/DNkdpQEaJoHg2ItOtWOYKZlU3PToNearSTA72NH8kEqP9+XEzcrI852vfJ+BRPVOmZJ61LqmS1g4IMvBUzZO7kGygVdu8bRMZQMaV99Yh8vt+le+I6pCS2HbvpYmQnte5TIUz+k7N6mmOVR/rXcH267Si2m/JK40tsZPqo3WRUlBY3D9B8TK/SjuWN/YycF/C+gsBGXlXvfUjvvvyWe3vFAAtK0Hj9Zx+ixsTvi+jCcBTM5Thz+Ch15m3zhYmZeYHVN0Zs2aHmwVqxeQWWzvZaHInN/4K4y+uE0GWdaksBZzi2hg9ucyAYYg7Oh3V8D1QtdLpoGPFynMY1liJ5VkOxMYIvD17nP191NxcY/DsFUQS5SldoWTzvYGrkKMP8cN6s7YYJaO6Tmh/l15JUfU7HVcSOmYhWAU1W5XnGOTgwXoxrRLvwE8bd5bR8uf8KAaGshzKZmYd8omSGWENftHZehkw6TmJUio+2QhVFkwkbNbNUS0ZcYXjb8FZ/qeMcwlusOv+Dmiu8VM5yn+cx2JhXQfweNL3Ow+5K20nYK37tI+K1CIJuZfGm/zsPHaEc3U4uhAP3vHyHoJz7Lh2Yzxw2vpcmBNjKesUfeffe7YlRncDPgaChQTsflC3rk9ed7xKJK6LH16viWkRSkFl0O8iPCeMsw6djdMkaEfSKlyVlzPjFrFYMIrMXlgCrsh2ti4R+BG/ivlSXJ8nFt4S0wD4CGd015vSVuL95f5H+/BdovlvyJa0bt02kt306habQ9HNWyX2X8Q2KHs7KaQjmS+l8e1YhQre+v/m4Zvv+w302YW4yJYR0gRDt2BytV0ZpWcdBoCAljxEnciRt9D8vIDpcs4Jx4b8/uI/Ubj7hJQeM/s/sfZbAX4zdaMZCzA3VV1fF7Hft8KT9Yad33tVq25YbaOqhDhqWYBCo2Wri2iXw71n3wIp6MqwTzOh9CC5yLmEfb+tKz/41QyzVPESc7+QNvE1AIy2ZVaKfe9InAR0LNRRfeHR5vh9sHAVVCS/IPjeE7bhKlh7KNoYrDxwUkq8n4UpP1buzuaRBGPdwztBDX0hJwSmM6ZWNfGVA+HkOiNf2YlhHUEpFkkM/rnBV1gvZNx0jqo2H2addHrXGrhem/88fjEBEUdYyabbSIZ4F0ueW4Bm+uj6PscNYzG1fx+/QrZLCyeKPyPEyj4CeTPZKhmAfAgMA/3N9BODpVVypqJoqiJhA2eYSl/KsOiiJ+v92M+y03GtVieVq1C7Ep4KyMTrl76DrTRMunXxhMg2TXB0fbmQI/NKAp7yWnlZqAhfI6BDfiKpVkch2aB/kt68gzQXjU5TvgIyfGRUDBO41bcSkNWgcYYGZvo2Au6OLxgQxO6HBxEzRe2FtJ/6PGJVOyA9ancles505qK1FiSapxrbTk2nFU1gcgiv+wJCL7MKbCIL1cpW0Crf5LuI9XtL+z+rtt6RhiJgnJZmYNv4NRw1vNKu85dkYnKd1RPbVoS+7vw9yp/H++vsQr1IfsqoxZ5QNsUKbtTnKFEBFl95SIxG8+XhUYJdUxbggGkqx4MWCOWiinHyP7tQP3aLo4jPzGXrP9cukQChUCVQPO9Bj7h35LYC4F7BV6Z/7dASmeIfDYguiVQo4ZZX/rDsIwzIV19vNi2KAY7qvKhS8kXi/uNUFiXscWELxw3hb6th3n5fT3/VKKCMi8/pg54uqTtdOm+/JW90Abce0VDqWHKutLEsNkrWV0k0QpfMfxGMBcRBgtKZBGZkDtdfkK37gDEWN4l3/lQYTEx0vIHSvPlfGwXERGyDoTHB3fMHCH4rig8xTBnoQL0ATlM4Ew+NAM31NGdjVMjRF7l/BALphUUzLNlWvTs1+ky7mc83fuLFTCcikMkakYLp3IKnEmdxI2nbJaVEprp0p2fe1tqWfrgZpbfDWzqVvUSfRRHmWKxAgIPhdG4D3Q0OXK/3FJMNBOLPicfi150S7knQ9B19+iMeclz8hTpH4cZnlDhRGvuQqwLVJiiCVb26U9A2UauRY2cSCivZdZ/KmuDJ9Lmu7SkLjMFUULQNqcNIotq3EVTsrg9ichqJ/ZV9G2SQ9xKkCygGgUskoktITpEzbXm9pMW8ZHGzCKqM6fm95ZM2uVBBZ88U0yZnOU6Dmd2tCnHCaENAc6Fj838nwC64c5+MoCvgwBUZNphkXoV4h+25D4+v/bREznVCEizwCOtw9WDHuNPCZHxJ7OAMwlu6ptduumWxK4eHUxWiXqC8o1Bdry1grG1ABXtg+Yu75CVWDjaI6YDUMRvu+/iHAgMy60E1FrVZ857l37b1IsUbEvGiRGizC0XvSbr1SVkHCHldiTQ6Sydp66+meSXfXqq84NYSxumP7HGufruT0vUSer6Bg9ZrEWytX5BUnh3OaON/HSQZqe6PzfAhLcZFV8vRKAXkE/L4IWbpFEZmTGwq+VGRCv64BFANokKX7OmavK9qoKuiVpPMHTf2DioSwBbhvMiTwePqJ1Z3m10KTsimJPqpTnJzdtZrXupK9kp1r9E6WWTI7BBAMeXXPp6DslPaGh0chRYs9BWbxGVNe4UrZlIoTRFXJNszFqDFfh/D0nvCSichetinlITqojPacCuFRqql7+wFJgDUAax+isxYFcSCd1eiCQJ95AlkTPtud08vvUzwwwA3gsxn1H7kCvWbOOJBi+Fr79Lwo39gzT3B+snf+T++i3nnfktyW9nAGA8SaTAage5NyidZX4akZThJUCvMYnPCBkpHkRA377DaASmeb6uVUKhb8vZJhm0HKbOrLbHUZeN4mzUeX8Mrd7oVPz9vLqGk+WT8O5KvqsfjtJBQS+ZmCPhI5vEiuEBz+qmJdNiZNucYN4AAtEjtbBF+Xs5wlK7xdJhlBwt+zxRSwaVYS2jf1OFtVlCXeilzJMSMYoOc/iPXJmA+ToDkVAsLz7+P4U158n1Kdlk9rMERi+ibcEKncoqyOMvQBU5MxTFxgbLMDtSdptWEFFQaTAnnnfd752XCulK5FOkTWZbs2p2nrsBBEiQyrAkKpfmDt/O0FdmPvaauLESUa9GtJ2VcSUOEEEiQo6X7Cw9wbNT1CAmhMkTSqI3XahX1MoaXdmD6hADQ7wYfdycc41ZwdnZmxx23/DrJz4ZAFbVfgNXkyj0/XCMPakPuLvlWjpaXxW1YsoS2EXkLLW/m/HKZs4DYjy//wYiLy6FxtYYC9x0tCB7xsa4fEKl2ek3zdl3vwteXm+pw2prbQs42C8jHUthhaW66EOXVXszGkWtpO+q2vUv/hHoUndvT/dY0WGKwjESTR/fpIGbopCuC8j5MfyHs0+wu6pQKz9FBIHO1jnwTTE6FSlVfKTylrcFZKZI0JUJt2JuH2MPo3yVheQINBPJOKLQFwHHAjg3yTO3SxabHy02hj9oWQ0m1uCGHV2SlxLorKRdOwlk4faBQnta4jQDiGn1r6X7IeM6OTejltyeZu7Ij0LkThmQ7Gdh/TjOPHp1mowd4jmQFRIZfd2VKn+bJw430K1jUKFhcQsfnML+ytqZ43My562tpW+B00X69dW13X/1nQH6vLMkUDZf1YewTxG9sN5VXJeczfZoibCwz+smCFmqvK+RlT7n3xR+doVm2RiMuKu+Nw6KCzcDJPUV7xCXL4nY7TAwxzmllfdMJ6nW0nTCm3WeXPMQ55Oxh2OcGcMP+ifrVZ0SezIOxXfhkKp0rh+e5Bn8HjMxRDwF1evPX6ArwF12O8ZKq0c8xl7WMmLjq83M2NEjQy5dvjLcC8EdPm+Sp+qIRmv54U771zTRO2ATXjy0twdfFs974V6aJlWOh9x551zxs4zD2S2K1jIBe6CwtUbPCFYQtlyGJ3Kk/IYUURXqhm789hwmrermfZKnCaVrmwsaRwsgc4Yf3hsA008DyCkdiO9LDfzBUOCKTf1NkuCCOT2MkII3u8Xc47NsMfhNbOJK/puQHeExdoaqtDy/j51mT22By5C3imFjvHzc1lWILUxi6YNFB39EJPQK6Yj7uO+ziaf+V0/LveTU4NSGM3Q1KdkWEBGdqy1GGZ7m9+Tg2ON3pJcBxx9izpDhWIvuTrGnvKb1CDAf96nTci5M5Ay9Jf52THjoxH2PcMDEN4P0u+kMX63qo5DfW+1z0X59cOypWQiG5s5ag7pBG8fsf3LY2+C36tw3qr1i8OIbimQj7O79cZplHmtfy1H/Ql8Jh8eL3hkvYExwOKQLSZs+8FkhN4sVGKZrDfX8BYlwW/kD7RHtB1m1TdAJ44+po+YamYn5rgBnRNKFyiulVQnRep9ejRk4NM8xSvY7tyOx1ixprKKH2bDgMaFfm9tZorr7PACHkM3QS5NYBOqMyy1C6CHSAitS5WafXeeQMxbbsele0vr4zTR7X56CM/0nhCtlgNrNsOmCFZCfGMpD35H3pGaOoEh09gseF3Ipu5iiH3XO7QX1M+uGgPSPJQoT3sPXqPwo1fT/KTYphq1Pgkkell2YfgghZz2Do4uMwxpvuXx1zXl3lesw3TqT9AP1CzVNKSCOUxoya9PejctKQpqQTPybia5Mrx3XuVAnnCJazEQ0awR6TLlxMIUgw2RnXHV7IJcJPLZg0MgvEy4lbCzztHCJnHvuTkhF+kfWQ21z0w96EpPHyt0SD2sV7u8nhnKMIKYxV6xk+C/NWjzaILQBQyqLU/+gurHdnQptbu6m0aUQ3Y3T9j8JeOe84HPcDgVnyM8o3H+nUxXIwlvzyAQFOMc6oEZG4U7eAlBEb69U75ykAoDhKKkYfpbuhio8nj/br5dEG2iyq7YeMUHrFcZHmIbkYkcaqvuLW8CH3ut7oDDXXz5Bh7Li8evuF8PyCG8cZC/wvjFETv+C+8w9BcD1EU4mC4QKq5CUMtrqHzdQZV88uamZhY2Vya2rIXnT3K1bE9CvmdpzfT6lwKXZ9ePHKN46HT2CZbMdFTezJMMoyIvFZrgsSGyXN87tRaEs+cHtNXey7n2QQa4OHPNFFHJITVJ64TGTBmDHaCYvt67QWvSFDxa7oxkWs+OEy+3nPqMPwHq9BR2/t8nXSbkfIzZunBR57ifjFLRcxS3hJllCWU7HiwxxYM9gnj/n4sfBS5pOqdnRYDPrdDEVEnxBSbuCp0zt/BjNZRWkAFaCjD9LO/c/vEhs4o544Q0EAf/qsUdbtYjEDO1Iw+caRgSMwFsrE4nzzgmc1xXxcKis+1JLmyOY+SvwfFb1rLd/3zRNxNr3squw5Nv9t5le7J829d3g5Dqj1Q99d5PVPmBYaSBM6DlfgaEzYG4xzsJw6cFicGTT1Uz4mZRZnNL9Wx9GLenQ3huFeS7s5SGfHeuyLqIJKyhyYMAScN9ycJSJkxjLppsSKVQi7edtjv+L9j1kSenL/wI3eu+cd4E9E2aXuCmlfTIZDLBzW7wHUobEa8Jy2Kvh4l3PH1bonNsWdBr4YYaoGWrpPgp9esmc/D9xmRwxpW2g/v9JVwUa5xfPuQhUiEjnQH+tOHurjEAZXOmGGsVnNOCeXb1vFUAtOkxpBRIiwfF1DQ/W8XxD1Rl5DiucOHRcJNhS+Fi4ZFKoM8R8Fjxycdk/xVPIrt4aNHUenD76Sw5tYjWxZmV37W497ewCik/jVN6RWnjhYfVJ7W5gN8fR4h+3UeIpCxPZDsc9vu+dSF/Q4/k0buIvxxruWrVejdhxwLjhB7wFXPqdDv9p4wHd+wbEhZ13DDVXIkvTI9zUzXQgudpjWry/OwA0eEpeLW2s06e8VyVmG1c/ZehMm4ldNVEijBBFPEoDeimZAzKKVqcMii7u4uL4Ar1s8n33WOQokHv3LIlI1Al6PgkV5X0Y0dcZQtOMuCZxiC3OxO1nN+gudcAGUe32ZiPaSb7FPGmbMUOKT5KMgeQ3Ok6aWXdpBH9rEM2H22QxLuen2WH5T7vw0qAzPYhYLvQoZNhgZyr1ggqR1m+t3uPBpjZ1xWJr7kLf3sNtpMBmRVIf5ug7ePECpJk5bMSKm30X5XsDUmgzedwYLwn0eRtMQVjcYOPW5yJMj6n1jwwdOTD+Dp6kEX8ZyAea7w8HjtZ4G9aAqU+0rsatSjPWY/Autu61JcphEXygHknclRXQXUcnSXhRPGphjczmAY6gNcezvCvX3ysEIR/EJAyW+g9ah6jlnYl4Ng0y7tEq38CnA9M/2h95qqUvOXVPV0FUTTLRMEgCbgFZkr2vHaqZ7IlFXWb2MWcz+Uqb6zzQGXFgifyD0wlyqqX/PlbMW6J+DZYp2DcEPAJ286soxWDb8OqNBmCahlHAA44NhcFD51rzpvqHL10JcpOoz7UI4OvXWTIEAEOwkvbAynANW79HRZTTkNI+pHT/zLFYpMG7szykOcO9d5xUkdMQlMEmgpi4FWH69pwueP221NFl7srM+BsUPzG99J3g1OsacItQpVNvLt7GrWDS5tWrDA9CY/UmWzjf032NMSPrLdAHgBusYvw3E6gtBhMJm5CgzVngYys5FvK9P2RvG/U1ZYQsNFNWVKNbP5qW1ST4P3tRNlAGaXUu83Mz9dMpEC80gKKYTXsUp3MlDPlIxCKLK/Cm1SYo8pJT985wgebCYdorm8ZwS+a9151xkY7ycE9idvB3oYswMyYWOE5sLUUn7N9/exxlRAI/XNtsfSCneX5qEsq4G0zFlBBiMdEd+Bsm1RvmmYCMZVwZo2u7Wj99JYbIeheipmY0LM0LG8KD4cwgq0ujBFhG24mcAJVB3sQXc/GCfOYQmk6MIaC3ZpY+4r9g+xClPfR14ilORiG0fVO+n2PNUQpNVMWY6cOyePOLRgak9L1xJeWEPRS27dobc5jrCK5oxw2Qp64ftCLtdM9OmXUu4r9EK0flwzegAMHocy1zyAF+5NcjYFTpTk7ZaO/RVq5eY6mLkTQLjaAyeDu0bXTEq9GIBi710YLjO1qaUfXb7csOuQMqNNaXjWZ3c7Hw/emq647+/M7UoGPJ4JDUZEbQRGDnk9De31Ctnx/gAm/HuIj1YLtXUZZYk+kaBeb9MJn+BE85u9FJ6pibWOd2iOQx+i8goKLh36UNEUiGMOpBIQwx625M0kgsmlesKL0TAkICbqCRkv1FnlzgopgPl3tYf8oZdv+aAMkh7LzsqW0NeIghAVI7nO8sULsu15+NiwhReYf/8Lgz94rbRAvjqCuRtsHLUSAYxm2si8qY7V7UZEB2HxBujDVH/D3FflpXAuEf6g6UfaVfAHl63DT6O5YA3l2Fh+vXdMTLZR7pQRDnYvfofugPMoNixkjEjuvqrJSv6lSRVIgeZczTegUSrFHcsb5dDBRzvRRSJ60yFsiEIa7I2fGPkR27CnT69o9vRK2+nmm+2QnsmL+F8ZvJOjgqfcBLLGnPor/9wYqSczWx7o8kz4nSXC2bJY36y1hQA+EkG4SZtrZYgcTysHr2xHZ51yA0LwLjOymDE0Tg6Sbk6bCzVOUTnkEAXnRd3+K1nCgcqT9phKUqZxFlmLfO37s0mhJoV2pQnxybr2lMWjhgRQp6r4NaoZ0vW37a20Eq95CYFQoqAnMX5sVVRbAqBtbn9lGhFqYD5JedDI7Vhe5NvEkULasqoSoo7QCaz11WC4mCCNZbZMK5EaSHQipFd2B0pydG/NnHOV1ktR/iOyBbUjLy+3+jfTAiQOG/gwfSWUe0d/3HpuLIWCkTMTXaRmoThnGSTlnyyMQdqVCw4UGSVihkvHE4P5JM8ROX1nt9bUSnW3BpqvG7Gq9yPD8G5QKTcZ+0WI66dYUdZMKS0iP+RIiMm42gJM6a77sc/3ttRRz1pZd67iwlUnmLn/0xhlilb4jaZR2YPGe8ZP3tQ0BuLcjn+vOrJtbDfQdgcuxdrVUFZ716DQ1CveG4fN9xLajdXVsdb8wht/GagkebNxgDWrypBOLSn4/HnMkhd3STVCU37zbSnncTq/m/K5j0+iN6biYxQOYfqyB7SQp7mNfC4JXvVbYnuOHrYrXE3sYpCzBz2jJMFHu2mfL/NVwJDaMv5dVfmSoObjhbL/lEB0Fj4QbQGrvFqQ8mEzj1YCLAH66SWec+XNPZIEs2IobITWhBAi4EHhheCiM0uN0bsMC1jT/MF9GytvXF2Pkfo5gTj3vrglvxDs5/THTjXSw8vR5kIe6l59B2XvyfpSBxQM+I1rSVLEqg0w7w5ZSUT9g2sWCaJ0es1vBs7B4IqCtMkjLdJ66Cqrtaq+eczFm7DxmTPJMDNYr1FDFbTrd6Lfme62omsgD1Q97Nc6nUZzWFhziMLP18SZMFv3ds5jNgqg1t67gtIHq3ZOegMEZii8eGVPo84uPop0SMBbjs+Gj1t8f1qkPqyszuvsLCK35c6r7Hjkd8StnPm95GzhkVy2w5DpP85BIpObK+gbl4zA2Ns4wZlSsJsAs+E3zrQEG2O3x34xb7AztT4evjzt6Cm23uz5XtjzPlO9MYQZ1EFi0C4RV4wWi84T/h4sN3VFUBxrNr4716W9sWM90K/Iw7Kut1f/0dGCE76fzlSkvqWPTFjoXSti5qM0TPaXfMhT+bZfIsfiJVxc7OIChmg108hekE6fBX3hn+dE48I6tdsDAPAvz954T47bYiCE4yVl/ah5PtxhHkdDDWPiPmgvbA4qAdWb8vNWWAXzScpRWCxNYCLyr9fs9CjtINi9l3Um5tfXyaFzghTKnLYeHhhDG0AnIfCPeaZ4aMnW2V+0qblOBdzKnCBM9gDocZeKxUuPDsg48BwSR5C1k/1fXoR8LvvRdE3Q8HAqV4XORkAh/p+5hA6c0qMZDDifQp0U3Oo4nzNZcKzvgkcA5GRyAXjD5X0iWHYBbxPhw6wzDkTq6KXolO3pwDWByfLvEQEQtNWnkB+RhF6NFLYgNCh6HA5p2hzd12K/LoMvqXVxnkseLOJrrwmJVkQe1VjamywCdDie1HopmVCe5bZXonaYQmD7cTkOEEnrvlC25LMwN/R4+2r8/O7qhpBfdrZX/aFZICeKKYC6HUa+mXOPRvulKIx6Kvvk1bYWBCfeGhkMwbZ34PZnOYlFAUuHJwm1idobccqfzmkQKXLXaB1FFe65HmY0D5PE0/ik8g7Rn5AipYa6GMgEVzWm6H76r4ud0/FlbXsDz6/psHuIFNkAnmnkoc6NZc6pRcQGBW7IabcG3DOqptxq4RvYHekDFO5cm1FCxV2MQorC+Kn920BjjJNqPwiA4hhjPu3XCY9iH4Ut62D+HI2N8fJwrIAtPvxIGEctBZ2MJHZHXvxB273+0SRuS8fFe35v70ecYXpWZAP8FlA1A5tigQY2LzSWcxmpc+cUf0PPBoRXUb0qxaRMzXEj4o3zopUwB3APCso1IsfQDj692Vk5RsvRK2qJ5kCu5TXMELo1PB7R5MZijWyQsohQJJbi1CzJFkm7K1JQIItwz3ToR9WlZ6uQZLVfFHGwld0irgLkF3YTsN46DiRi37A9CPo52kjimA+UiaaKEJu+ETYJ31sMKRJYzaVfJnaTBAQxcvVnoOkbttqxj8quODGiq16cI06Si/oRMKumqCuwcGMtlBfF7vNl8F2z/ysbIdC8abtevN4fdbc1IsQr44R3UNdj0LD5qiNRpFHAuLsHiFp+jCX38WR9swUuZBJYqPHTplqbZhQqaociewtJaAZgOVPPJ0+fAJfXiIcrGUxXYi2oXPzRvKkNSHnUryWqsmcWv8T+IdGGJ71dVvhXdOWLDGXyHkj/2lyQUhqHOUVxHoRV49rSzKtxc2pSlv0nja1L85LwbDKhtxMQ6tLVObGMGHMZzGXma6IltYF2riig+t3avmEN7+lfhmXwrXFuGWPjy6tD6qfLXWav/h70+6BlUremzNixvl1v0U/fnIxQ9pGJbygJ6AHJBciM6g5zoV8gZTfsd3fIvSHI+PJc/RNmbq87exc5ITLQTtn4lH20jJqE64JLroEYRQ6At9rRd0Jpm69Q0fCKKLGRDc7sAepVKhkdlocYRqOiRksWSd3BsJw1WRBCOKcpOZnH9efUkckEOwNFP9aTzjI5jXgxr0O+4+/7mIDM2vZdEFFIHZbr8cZ7hJamLwQpB3WMZuQnxZNyWMR0NsLUZqI9DiEyRaNfQ5dlXZYYNi0xn3Z3TwFBGPqCDhD7Cu4ikhLDc9fNV7yJmUc6ChRKRX1KIIR/jamQvtGu6Rjg8yj/2rgBnmxvLqxF4g1UujB3jXazIG0ObpxVJYHlUKuUmRLJrSrYFCdzFpfMcrc3M5DFNdeR27CPpLqD0CSHgSEejTJZVcg5PPVolmk7KMmC90N2wl64dVg7h3KPRLKVmSE6fMnjegrEDNZuUFSUsrjXW23VLCFHU1JmeKfBjBIhvI628GzAnlSyU/nbSiWwD/Y+dXHcZxTvNjIpK6OX5hLl0+eo+LGo+cvuQ10V2WxXVUfC6mnb8c/4yX0gm0UqN1nGf6LDP+0oEKwBfZJCgQzLLP9OkFU7wnDQtStv7bt1V5wz7MZzxFPJcAoyDz+7kJ7ISRoTH0aMGe5kFoHx3N9alcLIY+FRhWFdpwn+WQoo0EvE/CzdMrRxw8Ad6ZQI9zpfl8V2qDQFR/GzbITWIHCHB9tjWQZmLg1GibBl/3XtlSjSrqFOcwZe1RgQUEVlU7L1nO8zrgBBU05pEz1Xog/tV5tSs/Sj9GC73urBey0C0DbF4blGP69P/qv9bKTZDjHvxUsH+iQc8JMiG6CfK1Y9cRcPt1Ed7OM/8kBxCySDM78MsjJuHXR7uRkRuHz3zaj+bTAfTd7Sjg/XxWV2sWyKztZ+EOGcJ1hgyEmDsC1IWYRtllBqOndDCyeYmjgHXLBTWerJTXXUYKEQcWtXX9d03RRAy1SVL/84BAMSp8/KT1z2/xdpHAqv5JRz/v5PnXIO156Xfh79uC0NSG3jPwUbgZR1hjYDsYUTexaneHTF+bvcbBGXFvRaE//Ey2DhQySuso67j8lpNmeEzUxI4ViPSIi/c0t9ZH5z92bjOUQNq/vFhP1vfA0AutdthXc3eI9zaP9sayFuHKUh0H3HqSQ9XGh43JOquhGA9O2QWWIKdL1l0oSexEribgQcfWCNlxOdR06dDV2c3c0JQm0rvHVKzMREhreofIRv19IVjvKTO7hIIMGeWrfvdexgWw/4USc+/KInc+rzSZZ09nArKR5prhR2+AWjv1jWQhqzFWtV27zZyFInu+hQZs6sQBdmp6aF6m7mttMqEYZq8CwIcVn/fczcR497gu0Cv+UWzGL7jg3OYg67c92yYa1auefYvYfzPQ3ovBmOIzmyqTK57gDyZ6wjvQFg4FHmNdsI3RpKApQffhrwd4ELnUSuh+sE5tAm20CWXqUXwksb4RGq14idvudjtQM3o1JzgrQdXQzVYCLVeWuSrp+YaFLBOBy1zAEVrtfnRB/NBQoSr90kSGM5CJqcQyQnr63r/F9/3/4Piw613pFPcHN+NyfLZKRLWIAn7JDTHlSxa4HMxOK3BCCfGwN41ry73ueNshSrXr3yd8zvJj2O/2d6EszwgmJShW0r5L3BmqJZiQqFblyWVKU8S4KmrV7o/xL2mrRBTI9GkBNfbcy3B9RdEs/ncMWPG+zES6MFDPxgwnw90OtmZjb/FBjKmjzxj3NRkiEQaTp9I2u0bBacF1fDTaH218NNKzWaU8iquW7du0HdOV8OW+PXMHOR73BnghbfJRa3tSgFyP24Q6fa0OVtCjlx5gIrpXSFjYep7i+WLND3fL7ImgpqjoLCjfffMOXwfCP2Dphd+yGgefJMAksYD95/7cz3OCiWrDcvsza05oQFtU0fJoOgTkGLUNm3lYEKzkWUf9aCrlmN3b3t3YTPmN0EF7DpDtuXzUqBWUlr5I1e20E+ieAyeqQ+J6xfXTCXcMTtLKXeOrnwqbVPG3QvV3ItpuJH+k+WOsvhaMA9nL9fSEZBH7kSxycKVGO5oMku3NgXBDtJ8D9XCoewBkbYYo9ZqFK2BeDVHbr8TrDoD2GFSHFSllVzgMdHn8IHl03IEMlDfRgQToNcBcNizFF67eIO97gSQQwn41UE5zSv+U/r+1qo5MFwWyvZ/08j3a5C3BNbI0H3iijIIunZ1BIdjn7xsZNYBqwzuzvvXnjcbdvFQFQObHqrZvWzCGMaIpNuOGxHcFN6JoQLUDmSm3Ow09BWh8rq6oK7kU4TrcMSQ9mdaOU8b+6CFTIgZrvUQFTPTRyix/qVk/ZVPVw95nQRWIca/C9PDF6XXlj1I0D9FfjG/42n9pGCBbkvjkg9i34wK+mEUJQlJGC0B+XOWmldPHP+pIxsVSy3QwdonxpA10aGPzm4JHsv1Kx4ys3j7CadF1Tk1+UDGZ5APQfZRwQD0PY/BvYRIrOLHgs8+ymPxuCO5WC+b8PMtQFn44/Dbt4l4++1gQtC1ht6CZAMKPeNAZg3UWmJZay9iSP+Ylnn5kmdpv/v9OMGkizqmgPCAtADPGiQK6LeY810KPUQVUFcBgRyUBWviCZI5TF22JGgxGB0mvNqsYh2a6257+CEUy9sPvU0ABnjLbyGt27syppnWE1Hcr79oAGEp+TtvDz6hG8vmN1UFRyk8zSIZZE6DJiUDdxr82DxfNa3EVUHWJefVfrJs8OxmtZgz6Lgmjgwh+XwjCzQUo5fUbxKlNeOlLdXtaeF7B9asFCOuxrzYO/zcBOEI1fWQftCYsWkxYZ+Qyh4foBjobC7mOfyufSSG5moBjlTG7ZVFQzQkk+uqVN4Jej9Ej1lEOgJsTSkw4pMN30zu5H6bk1h9hzHaRpEAHslybGv7n5ymQvuOlWMeF6JWZWNADbPY4y+3S+rEnzm/YnIvxGM65MWgaNjQP3ixwQ4VUScXVq6o4yte0bAWnnR4PIhdn2+o6wyxsJ/xdDnEfQQK599/uvfX1A7IlK4RCw6erOWYvemcQt6PhmUpHG8JM7e8n5gqIkAi1+iWubJTVh/h06pM/9BOGOsrVgg6gkAaW2TNreiNBCoCm8/nLcHtYR90QsmVU02h2fcYEZdIzbZtqi510m7BGG83LBVcytYzoCLOfy7sF2vTPVP35pcxqywNlroqkH32vSGm9vz6A5G87qdfdaoVmJomTHLapO1QcdGuxbXEVVxBCXydUyHnpaurXlc7/uhy1lEr8tjtUxLxx1xLb+Yrlh+oSOdcQpU3ZObJBnCFCjKoN57ISY3UBXQxZ2LV1D57n1CO8mR/d32zoDKpuYUj4RYh1i9zyxdx0e0a4QdSKK7kZsnfhbRjTYZjgxHDpy3NUIrVPQThtILd20DrgbN0f/fkMNNGpWjIVp7nEE+STunBBX8DyTEKFnrTTIbpsM8yIFjTFl40udg/09RRLlRbr4YvEsALZA7GpDgZFYd4UYwEwC1lIXivxq4GDOZwa3u2ApPh/Vawzgj6n07opR21xiusfYXnGjpb6QDmd6JGtqkB6AC/DiBisTR07GGMYdrws0KxLva0vy2PHMnmtcPFnwJ2T4p8WQt4saC08ujJ/dvoqjAC+rW1lIMWYVCOMRS0df0TEOGCeNmkF4KkLwWrAxvazCqB0Sk+8xi/aRpUFzb9tZ98dfgwjWVcZGNOTgXiw18yZhjY+VVFu2+XeyfnXv+ixg6gG99EIRRrS8hcY2u8xnTNPkTBqB3/Kt772wFG50OomOX88WdZBzYxU2bfoizp1/yq0+LC7LtaVyf03FjROZsymJQFW9+mwpELTOqxjpPxGHUwp+t+Tr5su7/zo/sP/wEa0PA9p387K7bLVPThImSpGsF63FAqCNpEUwI4/6IiQhxATyS9NXgVlNwq34+51OuSI4tVAKk43QOf4GPrWRby7J05ygpI3BY7gj84NZCenxuBntczcZWWUxdgPMCyt0IX21s5JWdmrLKlRwHxvYaqbCgzC9uevKwYTAAJbsOjlQhR62dW8Lu239vYwr/HClMcs0v3oDgBYoq+Cu7CZITiNzuDKi2wYDjmDfN5KJzJYIPPOD6cdDHYTF2It8K5iFNnhm7YnnMJ6Q9FgehfW8TQEEWUvxrTiypygw3yaALBnopZW0MNCuINvoxrZBfe1kUJ+sIqc7iKqB1GB1bZDw4gB+DeO1rZQDx434JWZBsZFDz+eyApU93594Bk7BOhEbfKK0QPHB29yxlKzlbWrRN9KAeEM8P8Lzda3PzzF48oXgs/lhdRiDdIgNi9/va4R+CAsCJs9Fth+UkeRSlj8vbM42RzHyMkYVh2c/vKkgvxdPx4t2arMVnwTOZARSdx8561SUxvnpZBmtw4i8IbdrhZSl2tQzWh9qDJwigicajjHrNdIFF3ksAWUBMcsjvgZ5S8Nd/Skl9DgJbNryB/4IUUBj22m2J0SEbjmuJB+UcuTxNfk8u3tmRM00Ix0YJaPdgGKAA8xTvemcWiFw++/OoJKA2QyismhqWZF1s5aXBbnCmYLItISa404yZdkxIazkOgYWmFJWCgccNekiofHHq67AAp27Z9QzDzHl/TXD5jiIC9i0yDx/Km13MfSBMuZpcYAG+VL+SvFNnAiafX2QnoDe9MCMZXGXfyb1kmsuflMfhqydTCz0j2ABspfaceNrftQii6ZRUGCfJTmdwiiqN2CUhhtqaytvcvwtu6MPBHlcRzx4KQ4W2d+dh6aH6CaXc0TsggPsG/dRMLMu9t8ZJhYagZ+SrIwUmyFOd1oT91DW0uwiVDf/alajENHhZNH7mHeF3xy1hA5TSv83jdPy30fcJd3q5OF42Ybur7ALG0ijFztqKbYa6SOILiNVa2xYd8y8Zr0SLtHUfBqqY8eq+Th3+lE45ilRMgRtANL9izUap1DXa3wb3iUujYtJAfDdyru2oDDw+lyxZCrVqfOGevqpd9M4g8UKzR+9kB8eA0nwtITxuhDnkASH114izKNMVnKKEzL8aL0XhPfRzGhKx+qxvkNsAj6O9NXllNdrlG2j60rDNpZ8/bN2U5LlYGQq6XzxY8HkZNBIcfaW/ID9pFXkW9DUDpbWeuVKN72tqVUFSyMvZJmvi3T+MGBiqQOp1EX6zDqgHOSAzxsy4grq4fDxUTg6WLir4fozSlehO7bk8/RiCXzGW8HxRm2bUC5NX2g/Y2LAHlYYpTHCiYwq3lSfyNWorv9/okhi00Oa6co/JVV6C+Cd2Ngm15TxDJVEb3IEYu85oukh3CAbPq1IQkDrE07rIKygcoNGAt9zhb+/W22taBSciV3gT9Hlp8wuHT6I6JNGg/di5AiHbxe1jA1GwoOHiyHapMrgVbPBu0EUrG2NheJIow5LTHOkDY2+PhY3ZWM0A1a8KR/+9jHIsVO9m44psMwB7zWZ3/6a5jKB8M3b3i2MCtcTLQXaAzdQ8O23IgEnXH6La9JKuQCVs8X1Gtp9368QmCbaQjz1fKgeUsB/ddlzPD4RnWqNh8FX0tNw2yBnAT2PSXFsv/7IBEgY5NUzhCziAD8T37tuEX5LSd7hgtcfu7p3HTPGNKwb1aJes+rG7gj0r0tVIA5+MYasTeRbCwONeHzDPsolfCuVqfpO3ANajHryM2jfAVDE2WIggZ8UZlCb+JgoUcEUYjKAahGE4uay+uH7eseRsTgA9gEfOGRZxf+ct4GnYYeIw1NOawSxuxpdZPjLVBAweX2Zob4nQY33umpRXa+XrQYFbu1dGZkQWjhEKUqZswtOzwbUy+MEUu3tX8/ksEyNF1rM23VCAP0NrTl5nCOJDt7opNEqSrpkPlXjJWJAls6+Q6LzozwWYrobdKe6Doovpy5DUyylklEe2A+Y/qh4EJHzo7/QjbCzsxaZhKXJXlWhub/IF8YbN5cUeNkd/KFNM3XNXOFQ22+FhvAO0FwcC/2GvGKvtd/KzIEJkD9pnItNNeVogiRhUT+QeMRyxLOH8Txa/XUgNf6USE1eF4WkJ2rA2vXtPBU1By7gkC+KvTTqe7DfE1NU3a5KozMc0StkR6NX8AlLIO8Ukg6Ip0+zExgXE3tap9/yzPaAXxnLDMa+zYco0DtWvZoUP1R8VXOseQn2/StMs12GPXLImeITFdB4GkRgZpNJFhP9L0zB2PHbcgNAtgyIIEyAKiuB8Y0CkMNKTt6pkelINOyVcwHztxN2vo8ysqxZ2XXgqpJF0wFgTDBpgClKGDjokv0MicVFS4gM/P9YkawxCjGfq+IDkEYv3xZAhPKQtv6qV7wUByd21+AcdNfGuby8pDTb0x5KZI75VletVdUxw8Tbm/Ca6OV4sx2NMyL4oMF2X313G/WG4SrIDutRfLfBywbY6dYuiz9BQ85I/xDH8muWvll7QbWJ7e0shVMYOQrL7vF1+x6w3QjH1+wMLNSCf9UPCNPg521O1MivkZhDNf8pjX/p2a4H0wgnuIrEh5Mi1soLFyWv6KP196myVki0r0Egk9gWwBMSsEFVVOEex9r+xHwrAn6qC0Dg0P/fiwafsQMJfJIbCUx2d313FdTQAeLrNHLt/bBMiV/BiSVL7kdxaLJqPrn7Ub+umYWGl/b3LzPwhE8nXAGgARslhbegJEod91ZD8nvWh3E0L1UAkb4fjC0/HuC8xEayjORW7h5+dFE+TSaNA1sfngpb6SdwCjN9OOuZrsPvVyN/FOjP86gFo6ANkA9Xnu8g2W5ohJ4bmzA5rzQUjwN6Z+yNyWiZO+um7seHOoxzVMZL1sMJ3BMKQ5l5DuVhw+eq90Hc9OtywyUlI8GqAQaP/TCzDOWXMDR+9dDIj9uENHwgUDdF5JmiCqeC9ox+fZplrzARo25BM7bO0fKkJ33Xrb8aCSpCKYv0vy42xCkLYYCT7AYFqKlnPK6MEXoDQd13zUk0WWWLWJ98xOu2uj6kM9o+jsyY5Is+BN5vHhW9Cn3VH5fkacC7wpnfAmco++kCnU0x5vMvqRfBHQeezKrVLmcNJkmqk5+g81UpNDhc1FM7Z1x3YiH42itvlBW+eGXMdnwFSq1l/Gkg4A1aI48m4PYyy21HDDwPicrD4WZ40HpzY+YvmoRZoLVBkaxcfxE3MCSAdN6U16Mtr7ACXVvuhOan6bfZuJWeFEOkwLo9x4U5kg2mJdbcW2/3y+aU+WfaeomoXWxFNzyIbXy0VwNHQfaKnoDm9kajR4/UP495e2WUt8LrVc7U5R8XJ1iXCafzryWZo3UDlj04S8EIV0KDfk6ErY2W/2k7qr16lO88VjxnuYmkSCkmT3/jK93FwWd+66NHONzSdC9XEbyP24U6VvAG1iKt5UJW26+2EsIjkcdu2eMCZYIXpxfUP6CJhLPwn74vg4pyRU1/L9yH6vgIhESeJIqPELmIaSVm1f4fSQROv5NViu53u2DG5B0pC4F1p96i6CxUlP/ILO4qSPD0CdQGSgP7Zkvn/KMPyWNyeDdQBjDRAhaxyGnffJ3Fa9epi1aWS8OC4QgnsY5B5WV3ZXnLxnsqPRYSUM9Uh1T4dj9XJOUirc13aD9TCtjpNxZvc68zWxBZyotA7asMnZYSii8D6gMVAXaj9Do6H7+eKzlYPqFih7/+dBXeoQpI+0ZSuTg70IvReCZTYdNERJqBCwjfcy6k83OSjPGmWhhsgwW4YGc3oMta7KT2v8xPiIXG3bGBvzRJ4wODaZ8rZP1RyjxhCgMSjmE5ubBch6jPZEZr699r092yOwCN+0LG5tso/q4LsVHEFJZKu8Dh7VxwSZ+0akqBisIBAn1qtz51ELT28etvSgIoEZlL1ae+jhap7/WNqLNBVoG82U2BN4LwKyi1ly6WnJRfbv+TFzZax0HUk66C4t3C15OHFaGBVZJOSvZMvf2vqbDWkfhqxXezfosUzvWoTv/ykYZovp866iORRKP/YhixBWiXUtAe+sLHcKgHcXbdjalAlYBt2uHWfoV4yepLvTZnIKB/UvFOJcgXWajiLzICnoCmc+tCmeaqFq7OPATitxg2eBEP9O3Yb6ReV7md58Ka71ieMNPeFnC3/se3kY7QJQOn+UTjuLrBhixy92z/13wuv3dFWfQz+HluZc9/y1+V+UZuK2Y5fa4rkyzea5QFYfkVp0DXHrqJGmCnBRywbcOBBCOw//Q/pE6vG8I5g3yGuZoAxSg3ngNTM64uhYqKNHqEmniA4hJVp9nNBQOnDru5RIiY+DsK9wvB3uyX67kRsR7QFWEYLvCXAljluhcOYbwF3OsDj9E9CtLTz7IyXwml4d2KFGcxiOvTO3408s9kZUCnErhfxOT3Gn+hJf7NMDiB4+fuKDHWJWRGlUSvQ53b1EyeB/4vNKHuOfqH/Fje+ulNn6QqbuWct9HjdHuuYLGtHoypzEgk2T9StLmHOssVbkxfrUttfEKJD1hcLCZwb3l4iXh1nc03313w+hx9FXwnlRVM7VRN6bOJCuru7rVaopO/Ysm1wpvF6P3D5/z/qlPfv0dm845dAXeCMqHwSSstopwWXyhisXqFRVOvIRvHNzyYRKkrWvSxhldeLPGh/7cW5i0xOO9JR94aaYwonzDL3DTYzIOFLh1CqWbf9cJqICY1XB1cRVBbE4oA/05hE8Zm9h/cFpJjlNnNntYxLoTswP+z/m4kLuE1hU4FGxM3NHbmrRH21JdouOndGm4aFqIo7Yw2R0nAKvUGynLRCgEySVqF2gxCBWoEyb7sTUnux/giF7f/C1JIt5nZ6wr8HlqZvCHcKI9wIY5wzmKz3HIaGIbktfrqVBjgQ+ILl/gKhJuZVuzslmTpdoS2sPLZ/ZYvJbEPNZoVEiGB4F42swUGBd9AuKkXD6Vbu9SU3Cfq2hIKgjgS9XLGWCLKffDD2rsfcsajk4uAmyEzDU8pGamwBPEzbWnGXvqhmXJuShyZsdLqO1OryUqxFPJI/7B2D4v9A2S0tfpIlCBHq8pD7bbhZ1YtkVA+1Q9sEirLvFxMUu3SX5DQDG6hGh1YB0YHMQmwKh+OQNcemdVrH/TUiAZtcVV2teNUO8vfKg+q+1J+/ns8Ojmf5iJ1006h9M096pYslX6XA/LDY4rdsQJFlyU7Fy4TiIyweVBZPPHS8WMDclg2Y7ZmNM7rVdEDImmxrtigr7qIqzPrFs8l76Pqkhpg0aVqmk3D++lim9vEAq95LsAI6feHWOytzmKVyAR83HIPed2/WJhFrmdpLpxFMDOCXtfSfTDxzCPS8+EOEBbAAuR9jNrDkBHEUgWe/syUZKjoywGFP1iffvO9hXov/eJGrqTKRyuC21Z2ZtD2e747OuewGzOzmgcePD/ItE/c6pDA413eUKf5Va4Avwpsg8vG0ntvvKuXxcIuZfiK6bq9co07hw7I7QzbuOGacwYVAL09g9RUjwguQHSS7QjlgLzxgCyLEOBlwBIWoPsdoeq5hDYxKDrnFnmlvhQZtQXqcW8PIMHaFzjzp1vzqLthhpvRDeH7Tsf7autIT0hsDlqyQSr8dh6DDbfLEl6g0MNZmwXw4oOm4OiNEORuNAUYJNdav40kbkqICcD6SMFWBeDN0HU8ykGMM8Wnt74GD4FZrbgvFoAjX4Zfd3U7Q5u/Jd038Uq/47iQjS/gK+3QoOxyG5lRoP8H9+hBF2gt/cl0gJLl4uXQi0ZGjSOLWLfIne215ZgkZU9kCT5HwrAhqBJswqtNczDOZdmdBx6RXY/Rz85C7if26CXqMZq2y3zdKe7BvByqRPA4sfzEJdZzhl+Mclw874Ug8Y7FLGP75tl9fVBvaGvvs7VvGynV9suq/fGFyoeL3Ws1aL+xbA96fFLRlyVt6Xb9i5k/Zg8GuMEvEF6ZYf0h0ox7CJRa3/Dia85/9X5QaxoPXKpQ8pADqCihHwrrwysPd8YErVWGmqnI0LE1hO3Yzdgv0xuOfmp19Xr1VjcfWExmWVcpuCZVNO2n5UQ6GArse3Lt0hm76T99Xi7gCI7t+D73wX4/8vxGpCt8dbakN3Qdkc+/2abGduQz3O60IFxFgsSzUEmitmuQYKD4DWv/EZY+Vt7Fw/9AdVELrLZa3bkla6AERjX/1VdS5SggyKftPoTRdfDRncyZyNA/uirbWKKe+7g/kn/QxlyH8vY5DjZAZY9Oc3AQwpjuzUTiQGooEVercWXdaf326E6uAqoUXdP6aM4IPk+Rq/Ug6DqsSVSC2OXg+1w1wwCcujjoQBItqVDa51qfdEyqNKsg47RY+UMd9XRaGrbqHcPk8gs23sVEVKliuVG3hV/AevfxNxNhaQtEA8bNHw5BYhbxbu26mRMlmLKEBZkO/jyV0mDBUCZZrrz74UFM5KPI+uQVMfLNKSpTiiw227hPb5zQRtuMszeE7Y2p8U+rMZ7oJAGnO+dQo4mIIIedA6ab4Iog8gg0STicTdbPqSFFG4JBpF69DhY5qXJJxwS6QWxS1vxOmw5wmSxyiDakpKDlQ+lJ/NpkMD+GywXmXwOPk5mGytA43faKSk1BGwgn/jz7v+nqm0AjNfnxCGOwI4WwRihzl1yYRTD5mR3S9BBBQ/SWlD9HTeLfcGObCq+7S2HmJPweMTjyV89qVwmdigbLIdGt8BzHWeLRdaPidDJlPyVmaEUMoqLXtpe/z758k7B8xDrb6u8NbJQ2ny1udMLC1cZ6RmtA61yK8dwy2f+i7EuPLg5R16v8o1Ew0Vv+SbpEA59bgUqanDCQmDKzIZiDSeGsyuw6f8lMC2UiPQD95ful7/QlChAzIlvwS2COmmUfPeUC78h+BHK79UxbqTmCntCuxxSP6nhxJqIT4/miVottbRzk8k+KQdYpuOR9SDRkSCnc0wX9Z8N34NVhC6IwT2pEJ/IInA7u35U2+ouOpGzITkj8piCKgVmhUjfjxrb1VoO7bW0kZbSQTmgpofEu/sR3bruL1DQBFyHiBtqzZ0HgZh8Mx9l9ayfn72rC+6zoAURcs/ng96ei9l3bCRElvM0VrHDGyVVKpbx0tFOWiZQ/8EXqnTMFEleGICuUb/JQCHxGbjLeF263cpyinx7SDyE8YDkqb2KbxYOTtn00Uy17aEjHNH3cCKpwd8psit+tSJG3JaAspZNuBSxKUlFYJ+Y5q69s5/RhdkS6f+OrE3pL1fTlxZsObb9qUakJgEFUoaiz/EinG/hQh4VCMtyhpRNwsycs7LeWB9liNEhCGsmKlyyi7/+wZ/fdbK38x+ZYXtEaCO4Tgh8h+zyA3hlp/cRA5lZaMGj3+2PLoPm728MmjnSyJAwrCuGeYocpPfEHmBycVoWjgIUpClCJv0ne1p/WRWLyQ83oND1Do0JvpFMKqFx/m6BQrBz8Oqf3JEVVB1tmPb5ksLDwyhA7nYFU6oc8XEJvKMa9mwDfyPbFG4FKajCl8U1jyfVF01EeAQGCMT+DjdDGsbXsf1By9qZMR5EMpmU4XZzkdEZen/qPLBvVNObQrmXtg0S8vX5Ag3u8ZiKb9nz+d01dFcfE0S/qKV8y94JDWpmF8ToS44xVlR4+WOmplKpe0YYsKgK3J3L1yZ0lC+WwGUvs6jrkYJddRdD9wW4/GR0zR8z2p8Osd3F91ZDi7V2gC7gs8A9aUAnEuD0orRo13B/Q8ovoh+aYqApfBslC2OofyE1NS7mvwAo3VCifJHXj/PMox2GhH+f9fnOmT+3QioyHex35C0ECudRToFcvHTsciPt4I8O0THpdwNFmMirvDmMj/e/ZPNn07jBBC3Y1VmmXlIk2BrDZ1ydPX/9ZPkFXtCe3EPcAtpjKg33Z0FICQtJDwd5XLB9/m7jSBf1lEkNYmJEcSbZHjWjI+KvelRNdGJKUusrMus7yAA3SEZZhS1SZwgXTcyJ/it4lM7I3nf6GU4ozfiXmLadVB2sX8Uw8qWxD2oVcwOBtF1RhR8MijoXQsC6EEcLxrIec1kAZ3u2X/zQSipqKt/e6u8/zBVuavuxTPg64LX9bPWnz8T9vEFc+wAPKEwKx0v37+kdIKBDh47kgEvYcYrKvTIpmoJc3xJNeUIWhBVKJRIvNZIgMBTJ4u5vb7qgFVU4e3baEae9PZhzw+EHs47LJgF5LZsYN/xzgwgBJZmafNRmQZtYl1BqbU8u4CDd35GtuFbaiexfZ8OczOYIFawIQV3ykGjjTN1SAJ6WiFrWVYdTCxiHEjlwaf5u1x6trblArlBit/e+zzCFF1MqbuxVuUzTtfPF9lr9mrtfd7pKFHv00g4gleXR3Iv+SkBM5ztFd7jAazMcFnHKR2K99IsWL+5b9INpV9DWfn/pAbe74EurRa7T2Kfgb2iddIOHlPKomoihiUgYgay8Bl0jkLXL05oIOHrfSPBg1DkyfYk0M7g2Y4lCL27oNvc5rYxqJO6cTUXXNIn6Rr5dFBMrqxd8BmRHi3bjVRRth9Ma9Wxpq0rDrjOWfuUXqHGc4i9VsPtNXx9vpazr6bXqBnOdcOFNyslP57V/neCtuiz6MLlD7spf9okA2tKAdmc1CEVuvFjP/iL69cePhioTl1VYfnLnEv3Dq4etvnHyO418rgmadMPn9cuyVvtZejt1NxRJBxYTdDdDy7fQjv1aCIl70gSGLp3LyJUhNGVn9cMfZB2sbdA7EhbeIxlRu9q/QA+Cd18N4VXJSS2c2P/Ab8S/7TNKmr3i/iXQvWVN8Ve+5Uwwc2Owgufyj+HPe86oRhbwk8wM7H0bpsOSw+3fLMgE84NW9rmopF7IT4ETF3mTmRDIUPSAxcB4wvZ95UIZvc5KqkkB2Xek3f69twRAJTJsKRvDJqggZl+aJq4X3bB5hvvD4z3B99xuMywao82dSJowGwZd0gs1HC75lzclAQ0kcOjFJaFOnTF3bHX6Fzs6Seio0ywRvnf/AIo1vzgB95ktsw9QH6rrIvUqzOEtUf5FoavrM7GuNy1mF2t/ys0RiKWe7JrOB4uYup11/hiSDVb6QJ1E7hiH6EiSWdaG8DwyepFGBPY+b+R3KGpdY8pPaJaATLWrZk7LDEZVFkknkPD08sxOZaoxvZaAt+BDHUh+8Q5NajpQuLmz0kxcVDPC4eRyL0zcRdiEgZ8faMeafvt1MY0roM1ClogUaLogj7RrnD5jCRLYBxumG0+d4nF/V8ORFcbISLdqI+sFhN+ym8zO27F4wL4z44I7p91a5yp2alHMxJygNjB56k9ePSWrs+6bGyjZtVey+0i6HEU8h5S88kw3gYeyHzDYBBdRJwtBZvmNk2xRdT7pAcmbUhqRz5Za+Jq+Vhg50nDSVeVNryc9YPLEZHLghDPbFv+7C0mxK8aZbB5kN0LFOpeUGr9tTOi7vurIE9E9I+qgJCzVrdZzcr4KdEygEnl1kj5W1oX7gUSkGtQCdDAanMlKwKKLFsQxTBHqLKw9QdPl8VwXHfmyYmBhKWGq7cyp5d3jDx5k/ypyCgGPHzbQESk61+aIxSZx/VucC6DDOXrED/8tkb71s0A4DceKo+cFiD+9MJ19B2BbCSWnv81ZqbNTTbZUFiVjnIPY8Wk6uNXqz+DSUtUl9f1yG+eGOV9zuJRoUAqKuQ/egJAwqrh7Ur9VNgkaWf345c5hz6jq5mQrJ9OZlnwBjtHt9zSp8BtRO2XGqcWo165K4y2Lr8JxU5VidV3OGJkrfPXsZx9qYfJ3YyaCHUvozf1t0Eyf9tkNReZXYQ0iMjyc6turMAZqupzhrKpEgw+j8wI2DwhPEjZf4syembjCJmlJVUXW3Ep2yBngpYFyrqAEafhNAoXzk/NQ+grP35shsYL7FqELlSMelhrkLTYmJ0lJ/mxHRc2unIYHwqtNkXooiksYFXEiQa36FtR/65cabUIfNDkwb8sni3g53d1raU5BZXp5EXp7qvv3ZiVG938SdYtD5WHaA61ptuZlFhMxSsme3F5uckkaLEl3OF3sqBxIJVrT0eeNu9DXjM0E5N8+pQn4reErE/5xa8n7BfY9vxTYcltLjQcaJAf/j6g8tW4nwACKbB6grRP4jv2kf+lSxkm13I6Fv/KtSBsNobpGrcaEDbRNW9wDATn95ckE1Nn68PRoTUWtgwVS/KjnaTXhOp9h3PRyznwXnfV3nFkjI5mADdjaWN1lpyx34gJHHqoOVp0CSxVLEG5PFntUwQpezNxgFHvSrKEFLTCo+amgMssU0YPKXKLpEapEWLqBqJttO27AAMlMzWtazIl/ba1sFA7Jtcfsk8quhlk8oLQDwErRWYeeA/iGy+Z/dcViilH+oqnhpB2/V9JwVEeGlH2kVCw+YcAea7KyFdBEjudzdPLgl0GnOapOfc1XdxteI71qpToBO/paOCphPQDGFlYXW3WRzIMRYzur2NHqYf/PbDSh5NOE5YvYMVUBXJEW+k1qyOY4VLrVZqv+AVp1+eCKh3H6c/ZqlEFY0Q1csUo6MiQ+r7Qhdf30fXUDg207AIeeYxVghi498fSf7WYG4MfHr92n23qUN6mLhCZD3jwjTNh56yBUoeGshF7QHRP2IQ66HMr2ZpHXL16vyIq0qJpHJ0zCI2MMfuZWaDKJQU1ObCnzi2w3hAsGUz1eXmggjRvPGycIBRK3i9os5J3VJhXDorD6mxB+5hiszlHrr2Gg/n+A6i/iYPWo6up6+Xggbno5cfvKTEe3JqZ6kD/fgyQCKTsimYT97rrLGDzlEtKzQluqp5r+03CxCnsqqftJouHpkFEGhTDFgwX7TxrmH7gWjwrQ7r44j8zENOSZuS6pXAWP6k3eUwPKHT8Nqh/1q0srZ9svCa9iu/PZOE/4qA4+YjrrL7+B0tibKLzczHeJTVb8gmLxgAJ61m/qtVy6/f1JcJ9epjIXkT4uqO2u77tODRz9IhT377kgK2cPBaoh+Vv5nwiGOGwVhXTQ2zjpGASsh1SV0S8t41tOAaWu3WzJP/kM7ZKDub1GMBBeCLgzmXnrXso3oVZ7PJkvKc6gJYVba4UJkbos3pQHz+87AxS3V1nw1FI6UwqFtPMlozhEE0TiMGMQBHk7n0Dy6mFzXq0lqpRZvma/QhXpQnjMfucRHMF9DkvcNtws3j1HfpN4U70rMxudTbLWbJgsis6JqOY12Wg2qPfH4/1cXDoATAM7I58c86u9JbWpl6c5Ttuxu+Ql0XLZ9sctoEXHHq9WrX+gTduO9ICjTWBfNMJ5w216mZst+CwPOB+W/hZKhMFtSrfNxdqXJM4mNqH/9puSwUQgMEpi1qixl0H7TpNcJ47jhhXmCdiy745/ra5CJxxTS6Ns0SeioRhZNYiDmizDi7GPia3ia2MEeLgMiYrc4NlEdezOyFAYoFurF2qSRUf3V6p8FlxMaBYjQtVknw/3lZOdHxXB315eyVizGKl+7HiKjk5xDHFe9R3qH2ZWTNV6TCct4PtkpnPyNhdKmfrSIWEnG2cfrSNqxB9J1oJIbxDV4WXct/k5pI71E9qK6Ksfv6In/u6v23Wz31R+O9wd3111Ax6FFgHlywXFPHrrujoE03KJRJNF/yU7G9s994dIURuBgrlOKJc84XRPlvb1ygB12XYooUrHxy90/SD4+GTQaiL69cnAbwdelmSViJAUtp/r7FeZ/E0cvw05tWMgX2RrpqBU9Wnqso5wd+vfnCD/UQof+24w0y7zf81Wvfslgcfl+SGefIRfaDHX2nYOyCSocio9JzkwcXkhvvtKpsiM92PauM/oCX62l09c6n8XYNnxiUagZ9TNs83J423XEljRr0ldGHBFGrtbR1SPgLoEyT1VmHN+l1uIjClGfwnylRcuggsIhTTFKc2kXH+yiTqLF0kopiBi4vbHHzbC/kPE+85Aq9oDWb3No+DKiuvvjFvsTOuLv2Udfip3Lo4v6iu6pwz2yOzBrrnaZMX+exWCk737rcb506E5isWOnt4gFAtk3Tg0CXG5brVG2Pfdf18f+TMcMvmfWjOwFD06AKx04wSTUdqSxNHXb1nwO4XlrbtxMGs1S88oMnbuH3lnKwr5JR6R6tdoRr6PT5fDuGgo4egYviG9TENIDyeyDI38B0LB5rTtkq7/PA96Ss+WSkHOXfjB4O8dTC/EyZpYMtCVIj1gHd8Z6tZ4D69hcEXfPVKg/7vAt14lSAktRlCr8lyvMFQ+6poqSi6U0W75lEGfXwNsJ7qw8b2P+1SWVaG9xf/3OBWtVCwDD0do8tMcmjKjQ8B6G6Y+z/or/v8QF389JLs6P+0hQos8gJGJXRCjI1w3zC965A3I6VDevZE5Rf8JjDtzXkGRVTuozN1S1UDlOCFtWiyj+MqYPtO1SII9aKgTR9W4w2kmYzdlOUPTWS9/h3ICTFZelXbhtlVJztUJj0xcQH5yRf/qqohxJzfl3w2c4AtIc6HZ9erMiOpdhbTzHgnjMFxmArX2bjRNhsM/wgJaAW4eFeD98zX3wr+2pYXpp4I0TWZ8oRznv/qMEpqSK8Wm2cA0pIcPKUoB5/FAoBqkccEwGLOcIKeYcdanvf3Sb3O2HYvh2wrubc/4Wbbv67KesZUUbUZ/FgAo2RJGrK2BZebEMIrfOqstC11IWTk6Kr3uS1EqV99zF3x0AUkDJzji7JYb3IBc19zWf0Ee+Vcw84s2GLC9JL9se4C3S7SVqFOlyvbN6zspNOMsK+z64zt+gmfmNvphyeCnRorUQhV933e6ADTumvb1CtD13kZX1iNQxTikxgDFxt5QB4cRBVKYMNo1Y416suLKpCsdSHGRESWcrZHtyQyRTJCoaoJp/6/KHt1pboO3EjlkG2ztQv3MPtCmRUWRDWc7jV0FA7P43iYwZG2xd8bS9K8+HFAZkJyssvwERf/Al9NlsHO7SNCkpRSOA8Neyeio3LZ0+o4FSK7+bEZ5hgcoSCblTadxf6rcy71EzziSDH2LU86C+DM7g0m38mvRJ0lr0PtpgFgNPHPu+eWN6s6rXRqYeVa+Pqp3pXsRxkei5OcPyq1wXpEETgokMSBbJejiHS6mghg8FYwBOOsjd9kVYuTJneEDXUky2Tg7qiRop4leNTGMVBgq403gWCtLhvE7ps1iM966F0UERGcStQcLSugyne1RoDglI9YrlJC28HNm5LwXj7xKJylTI/87DI2+6hQgGDMZCh9528ZvNpC5DQgmon1PIA+2+8yXingkQZE6p6omC7aqGtM9kGgvVkKzFsfUlsEzd0m8ttSUNQGk0iTdsM6zPU7wMv24XKcz2zXRl4QajQMX2X7a01Em0s0ZnoT+MnP3Pk9pbo54FAIfMcf2ELvUCszNwGdfAagpkDiW8695/fAyrepqXrkFRD6hpUeCK9B915iE0gN36YLPf4zMNIbhanDTBcxGFB0pwn/V1llLQaTG0V5e0zqih/BKq0A1VHbIITLOmHo90x5ujVJH83xab/10nxxunIoUaCd/7IDBPwGwtf1GmzZVK7LHe88JOdQSXhqhx96Am3v8eiqZOgvdKN4cM6qEhWTE7l/u5EAQxa9hTKoMSMaXa001jcx290cEaWPcj3oklw9XguqZHyM2OgyajgWTNKuEUXh+9F3hIiWciQYmMLFg/Iu/i2/+zhjxYD2F0WAGZQxBWqAThbUFp6JlTG0/NTyF3dkBJqJFrh7/cqiZRUhy2Lu5BKzoYG1u4lf+NezBFNjsWbddM0PNytDaLXLGCTB1XnzcqTzPeMLdVxFUbcfUUitw11rqTbn6Xh+HIYX7yOu0u/RWTl7yHW2RSd6rPEuHBVGh9lYmc5XReOYtbqILZfzHjtcPbHQ7CU6KKVrtm1bdshOFr97hrlw0IRO1mNzDQWJ3AKgHfjMBkfWCefH8wVtcmyCPt6H9JZt+VSUVFwDurH8w1L+YKvEKxbOqrELrSHkl3hGjxLaYveWciyIV03AUSzR4RdtR3t48Kag1+R9t3QgErvgqT2lI/JKO/+u5BA08Ge3sQEQ3AR8xKk1+14s6TMHqxDKPbHnf+0O4t5NmjFP/ppeGND7CcwsFx8oZhe95ruSH58w2oEIFkOiBzGTXMu1FVm7nuwhVttwArEGxKf0kg3cejMG17o3FSSWnjYyJBYEhT+N9P/QKySVo4K4vu43a+0aP2ddsEMnRnSjH8WPoeaS+lAYbNyzUDV9POaKqg4kr58Zdyk1ZHTHaGOzptTvkdFmqOAU/SzG6s6C5mtSKtWwUPtfzGRxQsIo4O7vZyTMCVVPP8wt++FonsKKZTzFWIuDRuMaRiENCACJCSjgB61/iNrm7LBSTYkjCH3Gy2W1fD7IFwX+DLPU5ZMyslDW5yGagh11ZtHANLI1THQCTa0aDMmPFjjgF1eBxXmvzd2/b3s7LKBWtnXcwAg+paSzg2RS+rehaqS1pmDs5V2XNcJ9BzVS0zqY570oOJQQMQ/dIDN4buzd/OO9eg9nmC9VOHyWP+t3wxFAYFPUI+MXbTb7JaNQGO+gjMDJPa6v/1mNCGmL49ar9oUm4L9jkwbvcyFwVUukaw9KI09tM3Caf+zuXZ0uJx+G8UkW/3O/CszC4yWt+mATQ5bH4h0ea2s5IEg7LU6Sm8ktpkuV2Jk2b9UIN9a2a00ryxs5HMxI54SIPSe3xtoUd5IU0RiTgYjqhhw5DNtC09S0tJZSNCrcoQ3Ro22Ha8m9xQJRHDLupDJkw50WZZd6KcO7HdP1xXYEMvta99izdl0hXCBdNZkwWdBagWgNJRQzMHEJ9z0ZX627sbQpTLJbpna2nWlUNz5KBkQqQf1vqBSwuP0rVz22Z7s3alu76JYJRW+VMUMC46rAmogQMTXjJTxChIjF2BIEAhgiUcAn8+Gt7p7t71YGVsl04tmk8mbSpiSR0alsGfWbAaO19SinghfoSJuAowAJ/oF/Hf2B0l5MsFEHuqZeKPqWJGQ4Bk7awynRb5LO7YVhJG7ZPf5kxl9iu4CIF31iga9tvyoS655WXF4Toc6BPIPa0zD/VnsgbB9dWxh9BSzdk68yET+Ar4fmyQtlbbm8LTMyC1G2UqsaWRuJZBzpnNS0W0EnEVw25OHqD3OLpIGK1DK748o7H/FlrX1Mivvc1x/SsJZhQ13YStPVi1GdtHWqwYHUSfJbi7QwQdmmJCl18khnyrvO1UwI41BJiM1iFwQ7fU2zwVQi8tqyTWAc82s/IANklqZjmdxuBXvDgPkdXI5Rl8Du+aN0aub2y4wWfLk4FGDYGjQnY6VdWfAG32tYTbdbyGLRFzQRbB9CZ3Ia/ASq86k8ZUH5g6A9gfC2k82ZPy8CoTonmX1AAtJcet3ZfQbqvCg7T3Hg+EqR/2yy9pPYn48MEG5YLhsKSINRqsIqRKi0AENGUguOgO/babHQWtwFhtljjCvueQObI0CzYhiRYGlEHV9UD4V6Vwi31wvseZpSKFHkVPwm4n9Q0a1n7oI+lPXIAkR1JhnxWCSzAACFfFmf8rNYMkmH4OcAVPhzW4q8i8itYJlikMu4ErvPSjqKl7/XWfOMKYjGUvD8e/qcl2H8jZrF+y6vi60avmC+Cgk3S3G1BpoAsQ6aO46sK9D9ptSX0w4UOgu9/mCX/WWQLY169bSh+5kGCoYoB2hRbM6keXMAYcCsuw4qZKNRYuAHB18xoe0yRCPK/QiAV0WnWhbUV9By9ubuL3GdDP4b6XvhSyjSqlacvxst2iGjz4d/pXcqI+JmELjOgMMLsZ/hcdszron0BnwtIDSHKdRToaAkqFS0eMtFBTWKVYepLkFbwKNTVBomSnuumN7RBGod7xIad9LUVPSUupAzpX0Q1DnZQreLkDXxizIGr8NN3+ByzEr2GtJZng4hM643KAfpLqXY6kTCxQT543nkko2HpJ7APpPIe88IANImSXM201xneNPzGi0VhBctNPab0Qo2OjE9thkIHkkHpifEbLqb0SsyUVyD2izbLyRzO+pO2+CXfP8bIus1PJKyWVMmuFYV/EccgodyKRSUm6DvzAnnaKyOomoVEjMsQrSbZ5NSSc5uu6ocBYum0aYr9CIigZnbbSRsbP6nxp2TS19v2tgo+DaQ+kRih7/z9+26deyArd31AsaarIZobP6waWn1FwTaigxjCQBLGg+3Jxqbh8wh+z5sXq5IM/r838vYVmcgqOZp5+5bOAi0BF3Z++b2K986VfEQFt+nd4v0oduUUz9zaOu9tZK+CxLFqPuEoYOQHL7hh7SV+qZXf0RAQOJaVEHyGFqfQCc2JoxJK21kU9+tgL0ypRVNwOx2jC8cF95hAK1rSSujpZeb6TpRopE2AJVYg9x5v5mQWswD9oxAEHJ/zQHmOsLjjjwFTwAt0qrFQz4JOQV597fn9wC5j2ykW0AMAFc+cYONfA3s8PrciKScc9lqKHmJBWA79FKI9uinYt45+09tWTCOcYwIrV51Sp7ttF4ir6v1pnLkJ7SM0TGk9bZotg/p//20BJolF9K/uZybiTZHRqcIKOyjREbTBEzoM4ED/77Tp1/8AJbuLAczwOj9t0Z1CYXJju20jxjYrcBICi9sSXRTjjpj5womxcI+RjiNlZto9TCImyTvIuKWB88govD+GHy5Evmnqb1ceGjVknjiBADYp5sY3isMYdAc1lXBJoliJQFhSO82fp/76s3ZUlN8qpzYlvPm53dXVm8SHSQbR0nLjFaztekGlbqOorgF7rZvfAw0a8h1KFnakOAoExTJwkldLbUM7JrnL+RssF8w9mXri7Tg7hFLJR0NHFuSx8YQYISWVs82+9xEI0IVkmSQtd+4LMxjLTufgl/knJ62GPiGq81isu0ToWJHWL6acxgEzOoZGqK4cjjoDXVijFbwMErn/tI/ZX1VNr4/DjaPA/rAXmV/b6lMQYu2GOF6nAiftGtSfYPA8KgbIuur2rAcf9mhkHoYCYALRO5UoIyPWbB5Pq8J7tLP8yAVe7l6+Sxj6hcHKUG2VnBG8/ZMYrjatWmtlnurWLkBGMNaohcyH8DmXsPto5ygem4qLcU4rR9Mwz5aYDwkMJElpV1JqlJz6pzSE1iSkIEkVzf7DhmPgUP8N0wqaWrmnTbSoPvktxwdeoFXkwjGPCfJ4Y87P9y1vyKo4GcZ/3UwJkpSp/5zcBU0CvsNc3pPW0/DB10z2qD5H6W0gqljCjvhrq4RSVEpOgtTQa2pcYH2dWXFK9rg2PrtXOG77Nr6asF2emXMbAJjRj8DttCTlXAeuMx5fBTnae9ppUnZmC4YrGbJ2wKAYuoxBP+YUGfkijX7wl76CIWiRWhF3hH181SuMg/qoSP5vz2HK4gSSJOjstzF3WPGTNwchPk/ecZNxvFyrrCxqyCFhHaiBfoUbzmZZr6VzTgS1iCS/WgygqOza5CkWSn1uxd61aG9nWmrnHUNiLQ5RJDMuM4FRE/lCnceem8Fg4Znmfoee8QN4AqrWM1BPFFGRxUguMIXhHAwZ/jCJGG7jo43TGvIzL/xM3qYf/UMA9K1uz1u/VTYKad+qF2u4lH3dKsYFddseEnVemGwX+XPqBYGMfFMxQznJpmYSPVfJa8564mi49IfDZHjsbpmJRhr6l1yjqYZV8qv/Iln+4raI/y9odvLa4KJ4jPrIB4uKyBFfG9chmU3P3iE20PTieJeZGueBBmhpf84uok3ZE4JTPnasvldygxMyTXsmALcAbgoykbNo0SRFCq31YkLcVvT1gHjsZiz5us+wB571OZnMCC+LM4pxTDwRbn2FXWRY0F7mmHg9AYGXHatD7ZedxwkpI1/adwAke9Gp+QfbKBHnOgJXHzEf0ZQdchLg9SnC8cZoy//UfErd59fmStrM5em/kcEWgqVJ1i9zF7gW0XLN2Am+SnHTKA9zVGofpR2STwXKVuGmVTOH2VqCxlWGRcJiwvGBiLWe49TIiwodltfpj1nATVLTPDMW5EOX1XCs/4wyZUhPDBvTxOkPFvzQGeTlE0x8uncCTjfqgTCokktDBT1IgHIHWwo4K1FIFOw8yX1EP2gXb+Oh/qlY95EijXzOGBGBsW2RjvYIfHLLpVsVINJzTfK4ph51QUlCck2O/5QMamNPoYOTDMnre2SYkDvFM7ia0X82hVaj3i1mCIpGJIjNediuIpaqvfmiMZ5kBxSHORkoBSzGrKyvT4qU7DARaZ/9dMTXtZ+xmMXuYp81URa8L6bUpyUsymkDfQkNCEt93TIsiz0DijKbdkDZO6TRnkoaPV4a5LkUFo4dPZ1lN+k93M8o9wCb46vWUhqeCqQRSVfhJ1JP+6Ta5M9GrrKuFLTI6Aob/yo7KT8anLlCs0Z6G5pfhu3nqcWvhsh8Us6WIVUWs5nvrjshmeuGv9KqZ+FbEX9HKL0vpIN7ClUOxTQED3KDa4YEjqpn29x7Rytfs9bHgwqm8Se8imPvgHP80txRgeiH8xwdyf0cP63r1E7L3w46uK3GY6u6X3VlnVrNlvTRZnaMz6A4wFTgzDrOh5IFn4tj+H+ZUFZWSDGFx2IHfJlu2R6riR/InGsY0IAPYQ5Y/xrNtQikiiSkQDXmwsyxAz/CNZgC1+/4/XhtD40sMkjy7Kwqs6VrSr7Ja5eyFNDwjv3oWg7yxlLa2QHiA97TfeC2lT4l2FRXwiRijC/kzzB1+83ozTqLOLtKqvAkZHbA1kXbopNDbEDP80aGKemaQaMK+JuCrMW84tM12OT/v1/SODfrP4f049hYQBQX/93tuhPGAH/RozsR5QVJu+zkpil8CU1PYrYzUb30IgseSU66jgjMAoDzg8QhV2R+E//5H5zUJnqcxs884oGsA2PKnaOUndlrzsV9AHfXQaqKe5r+pCgWoNJ0rTA7DUxYkIw2DdPXWyMjmui8aGg++bMc0s5VvGkyDx/hW3dYeyevfu6BX+nTdHNhMHTX2jKbgxh6IHuC4Gz57GElZpOTOBMhlJRm/byMs2jHJopM5+MyUweL0RjSErDypfrv8tqzbglTtQ8xNQEMwWxILJ7wnlraA8p5HW3ZtbCQWlzRe3JKW1K0pHTWwut/CcDuXyWzBa/onI1zbvBcMeDxL3E6uCKVnJvy/k2w6UOmI2tM5EUWil5m++ktKD1kaY3ymxIM40sszi7rqeEyCS8yyZ+LbHTHBRo97ZSfMzofaTFCS+MKHhasiB22cdIj5gML1ZhO9+w1H9LtpXTbYYvqK8VRj5VGI84muxSrUm9zYxgq4Glb+2DTUqOSyGdAcJRcPsfqKIdFfYRpSCj9EPeMdDCvpSjS/+2hijlVo67OIBI7u8iL1BQWYYNWXikVB2ScE1aGSX/U+fXbZbsTAi5OBxekjCOmV92PAS3rV2t0uJfyaon8Gad9IurLfHwtmgs4pFk482MdlZUrwYS2q6D9/cxXtSVWWx1V86g0hOANziRmQGMtSXOykhvkL/dYAy+NdJpkIm5S31/4jcApLWGY+gc9KzOT2yo9lqh7LZlXqTDiys8KUpsecwWp+hFUGCxHx3nSLm+ThiSqNvWH6c1GRgbNeHAxLgU93wXaYABS1x1vpWDMNisIf+gZKAyh7Rq4EHg3DKgePEeYVKa59xAt28ajpE5UFvXBG91XzWWOyHBk/TQhX5i/DO6OMZ2ugkXCBeFrPBLokUPL344ClWwkaGrQAZFfMdycFHRPma0OY+QQFVwraG/5rsZKB1SXcIX3csJaztJ6c6rwBq/u+Gl4NqabrJAKW3jQUREB3+gyviKQ8H7oQHNoMZpaISiI+unSZKJ3VGAt8RuHO3+/gKEY1kAfOs+nc+GdrUQGAXs9Vp1N1LIvbP4Ag1cil1XtQB+t4cdHucvxfnM+j//zm9uMcHtqDeYexu9bHr/bSUmvUycpXDLPaZM21s4YIu7L9gwty3cugsCbyCy9oqRP88jIlXA7yqspZHZB3b/Vn1iuytB3sA0v9NszCJPiCZjwb8nvNGqXL+3YL/8+KZzU1mhvbvl6LxyPUSp7fWJkSxDGHeDmMVz99lRi48p6F7a/zoAsKSg0tjSkfdmk3M8MJ6yL7nr7A2JCPcorZf/I4ZkszEmbbMc9lSBW15il/yTd3a9thqojt1sFvi9qwQBBqeRUs262ePCbt4sbvTak6Szj2RC6m1Qi5LvtZJjKkHoBjHu9EWlBiM6tv8Y0yDRWA3YQxVbkB2Bs+1UlrbJ0Lis8sb9EjSDewC30mBUyA3FAxFVWkPbplvdjOy5kusdulnOUPm5D6OeeTacwVczwRqKIVrqyBbJpYHj1x4/Oc6oPvHGXnf/zJR1dKFEjltiezEYiSy76p2YQJxtCewCii4mAacTAg/xLJCLeiJNJ3cOt1FVAVBGbKX7r6UVlOnSWQjiOGizBjy6s2/X8waHmTL0g0d0h8/KMlZ9AoCrWuipMTixgTYBtLOE62eg7DydaI8DRd9ZpBTfIdFVnT36d4cA/riaJ/1m9ZIHw3rkGeJ4Ba2PFh7po6umycvGSToYAM5Xc9zJ2PRNFOqcE04Njt/Qh0v05ux94p6czoH+nsU23JndR9E5xBAE//wyHbsuoqb4Pec08dutEBKRWtKEAhno/sy1dp9PGTTLNqjxSOIQ7Jqx/5uIYDQ+k1Fp6n9rSYr7DqSWgm+eVHFVsWWgo6t8N3W4Yorfoz86Q9bVovpWM2oxktqhskkIMLE5OegUp0f1A4oaajDpt2WNsVRgQ9seomqEaqyiUAgvth2x+htKaqqutsdxQbbDwq/lLZNBnfrYJIeN5tGBRO7tXdqH7gfwUh4lPDktBELQQ17ZIn+9nMfX/ZyXveBtM5kur9Jnuune1n1kHGZJhMRHFmNi+hgxFzZhtL2rLjerucR3+YHFZ/5uz0HhtiCF/ro6YmqYXNc0x56kKMecjtZUBFuRr0cBltz95+wJEUcNFUPb4KP9eQ3wW0WclSdLfpGpTR/WLG/9IZ92QteO/kb9fDCU6bQhxtApYfUWBo7m1c/dJL3XPRNTlfDSqveIwGGLUXdsHW0hXqI7eZJmXyOlGCYyT1zeOfHb2LKNn+u1ZjgzhjgYCEmtsGXiLjjA1eFcTDT7Jr4zKv6nwz4bddho+x9AC/YALr/Vb0J8rBCU5K21eVU4DaLoaZ4IMxFiV70eZMKIsCaeYlVZcnLGMNS7ozQDCx8giPZb4CIExCPWM3vH0w2d5lYyb+BamMvOiKLBbc5qCsH22wLS5zV7Dc/JvsEMCGlHzw82tWNq9lY8zSSct+sjnw0fYxQ0isG1m0nDyhKiSPCT6y3LojzVQshHNihcqDSJDK/UHihCCmF1AAIY2hYeqkdMEpyn5YFXM/XnSVFROCcZlteX+pmN1NaX9SyTK3pcpaA718XwytKKKSromqfwf8yurW/InPCrk/Z/wiCD4c1E6aXro6lnfCNrIu7mtHoLgJ2Su7FKOQc/C8ZMsO6sLH1yoN6LACLrqhy/3Nj6S3wjcJtoUq0AqhqmqGA33GN+IzOqk2adoBsaWcxcVIc54PNPXd4s7bGj50G/HyRxTeL7sRwl7h4C9W+jrp13vSy8yuhJE59/6ROXXJF9ycDLdgTvtH/SO+BNmtMml2L6wkp1iOnwIyQ21taBye+8bahfh59rLHUsZ37ey5EMmquYMXS3u/SPtoEb4IT44UzsXL4if+pjNjWwYm1ms//5sQPl44JZj4q8O0ofd9cf77oJr/D/+NWv/YkV9Q57nlz0/4AW6Ymt9aPqtZ9ac6WvXHXA1ukrmZRi7GNtMgJ52aHeo7lkUL/aNnYFp2jtyMzDJYb8AY6A+PXiTekGnTsGFrQbU5PgPaoLx1MoN778iizDhVmkqt7ZVKOVj18hGz/cttzo+TuV4cmUSE57N2RB9QtQwiKjC76b2GP0EUYHimw3KKbqmR6xsa83rQrU0UMJ2jKMfNX2UGPNmln6AV3tr8QdslGbRga7nkWmVD9OhWGeqylr/OCT1z+glPyqoYXOlghEfuc0d3DSvjs4nXyXRQDYTHUtyuj4uzYctA3Lp9InGDS61W2lK+xpBP5h9+LH/xOLCBli0EtXaxKEwMUIe70N67aGXT1etMbCtNbsUK3KPXOCzGYUXGjAGm/7Il8kCbpVI24BwI4zAu7UdP74GsatMziO1RLGs8A+2eXh0vbQQrp09T78iXsa+14FiLfq5RN5h0VKxGQozHsn1fejwDgEA3qeGLE5KwAawDUMWn4ZfdmeYBBBrYbEOeZcAmmuN+3IctM0ZcY7bAhY0xpMBjLyvXsK9f4jVlpUx3lmHhNE2ZxoN+MRIJHyJ+Qc3ttl/AUC0Q4URwLtZ0WdxI7dWmrHo395pzR3l14m4FUuz4k8jF9Q4q4udLW/Qz0BUdQg1s1foEDK1gxNV3+altV3KofIah26Ayvj9YOXnluYIzYI50548tB1Kp8gluLhIXA4eL88c1MvbckjJNjEtioypK+d/DhsGYAe7V7ZoD3CiYjAQQLgDOl9X7HXBUx3qBtZuYZtwqVxcki015XjpiGVUcxtrbd7s0Ptqc+ML3CyK4upp6OujyirSz5qEoLYr0taXpl8So0AY1AyN8gb7UdJliq/WDkhwZGIgmkSQlXQZ/7U5mpprfSWjRFK4TDDi+lxUC1MGuAYEN7JXUBPiCTnrGGPqSAQVJHpA/ogvOQDHT7p0KfV1IPpTLjOxHjTdylUbaMhKPGYvwjHy5KOiWeS08Vt2I/vYZWu8wb3phtcNveM9/18+UM7sUHqZDC90xlonND29nkljCVLFd7/Y95L+fUauA0iHO84MeFryeJz5+175U2VZpLPY1m5n7dOSafWM+QNTakK3JQDe5T8ck/2oI7z8fQhjBNIketcnBOG6FLKoBaBa/yc2uFhI5yHvU9ogf6HKzyI9GMLMUTchGsZW2O3dKE3QhL3LqDis9znOcQesSNTPNzMTZ6kTYnSs8qdiMsZhG5RPIzzEyegePo5goFJrrxnGCzgCvYZl0WT+1tNaolf6Kti5/RBQtdkrdALzFfSkt1pIYYhAYvBJ8cMquFwyKnnE++QAA6Ii2OGr8fWntt6dOrWBEcVoNof71fB+prmtBjBw3eVSpyDNPxCx+7/S94qngqrPN4PfXPtdAcM/JFsRVLFXrbjNX1SUuZknZ8QiZaE8szd3xwXb94x0zsq5CuE69/0swsfnavUDne4Zk8NbnFSoVR4L5++3bmot4Cjn9vHk1nFfBQ91V16zCk5KOCtL7jl4q4ivSHxkMCayHckV14iMAyHhu/GrrExo0ecdy0bLp3jquUAf23K0PM2vJQZrTgpOjU+CSTnqUwAyK4AKLumTMkrJAoYLhX+mda5YMFfB0MM6G1UHbJc0dz4MRhvdpKquc6hASmuijh0x2KBnszPxso9ANLUDCXgk85IJOFX1BxTC8o+bA9OOFjcFbEr/0bnPfA5IZbHVTlETBbaf7FTArPoS6mriTIiE0oXPVWi7VL3sok9CobB6z0EgnHVKYfoABErhLQjRZ+32JTjfEpyFKXfSMjpb7JyhQJMQMJV6zFyHJILHTDQU8+jW1kmfkfwzOpWbQUV/QNsrCECcr8KpbLMumnSGeork+3pu+A/+97b03tpdtnaz6iSywe9s9GdimPC/uZoAb+UAJIeIA5WPr/7heuM47jKP/HglAraYwpHQ8HDP07Guaz2C/PvRfPO2sxA2yzPr3vuZkfbQphMYpvuaShfWFAgasUhBUynGT0x/UjRDAqCSUCcvlEFSAgR9pObhgdfLuMI6L0LJRYlSkhHcbyqwKL78hg7EfAsAO6mTWmGklCf6x8ZYHUyX3xv2JJ+easywgncbrKDiNOhOesudafLL7+eYbvBneeTpuUDEwvXh8Nvv4IsRKgpMkNWyrXS+mZAqWTkJvcUnV+y0BC3gev+8PhcWpstdfuzwI5wi3zGxVPbw1SSBz5Mwm61doJElDk5ACRy1wVyNi3Pz9QyHZhBXJnqc0RvcQQTrUPG5hE65O5/1Um6cB7SXI7zMOLWlQzT7VbMWAI3dfb7eHRKVhvDIdoHYAUEMCYGUlTyIYDI2Br848YL5C8IVMjtUETaKPsxFZ1EV6jv0h/3XKH4AuAYhUTYUca12X9cRKoMEzmZcqxJXUniZ4mPcC6OSF+Trizov7bk/3LjMa1j2VR4yzo66wW32H52Yg+1DbcqZh6JNIg9RM4saf9CDJzrLZMYhFpwgOn7XBL1O8LezmfE1GMi1AHQDgYKMd4V5mJfp2/yunbc25kN5FgrdMfHYjwXvdfgNkrrgj1LFlWet9OST37qjHHmVYl1ymINULsCJZg++NGejCL+nry1BHYZJxysE+veGNsoX5KMBX6r4jlkLl+HseoabWEFSERishWKOBiOWe8oECqbDiHmMWJoUTHaz9JSlJqR+/WCxPQiX025njI07QzLucRmbgHsjZHssZ5PM5Hy3GfIZT14GKRpF6H7b3PNbFcePirdq4DfOKMkGC8yEFZRCTJwbreub7DezHAjS6FlZ2NaFdKfuwBr0uUt6c2FSx+V36qJJMHA8tlPcY49y1+BI+u7Sdu8+X+bIG6SIHofOaNK5VFk7ft66WzbbwL6r+WirBYMbcfkKL6jlc8LIN+VuPe44jhYb4OuOjCouyOIVmcaPViBWtcTnxiHNRWO70XFGDr7fI0B6fZQFB0dhD1kxtFEZPiJe0M3ngSSgDzNLNl1FoQn49FJH/R6F9JGO+JBIXMuqxPMESld7xT7LshDtS1a5B6LfSadJwwnjSLe/dEL2iYnhdt4UzMYIZYAkjDuUrnw06wnR/9l2FgIX5YrQ9XDbRC16px28dj5ineg/CDqNebj5Uea7JJaW+Tw5kN790aArK3zvDYlM3ghgNYNHtAubf86aRdwRCBO4RKKDQbeiRVw2LKshxqRg3iTRD7UBRYJ0HqJlfpDSz6iqjX2+xh0/FTm6jXJmgek/b/9ktWYajzuUb/Qe1hXLg3UNt28/BOzsMl9nmiEwnDJUWks9e15G4UoeksY6jbhYO8E4WYj8zQRwYDiOUaTm4uWhjpzaeVBwJh9ntZyI8ErLzeD5ZhQQj9paZIvn1kwRXFJVS7HuFozyfhRHY5ctdDGdXpBnGVKNZKmAW9+iZQcNLU9xtVr6mPux33XHYayee4SJ0XRfFxvRVjxaMcXdSRgEvnDiiLxlkILIw7UCFhFU5AYT8XkYVt8WwWubKu5ZCLcZSitIjvZ7Z52eoaEobd1Y+7ML0G/IuTRq4ykJpzT5wtci85++5JBLIhJaVdjr2OTA9K+RJI8jGGGnRsrD2Q/0IRbd+haDZzPrfkkXLAkxwexOjmZiOitKIjNKXgZF/NYwdXmKk7jZuG+xXu0FQLb5en0176WZtAluQyXIRKzzalhfv/ApwqM/tycAlhGolEYoefS6G6PlJnqGRB4HywEVJknmkVQA5M8FKDlOAzjEVzpgKxNWXW+L/2VQ9nPBtXvFcVKz5iH8jWqr43vOpRqIjlLIAmE5EvX4o1x6OoaLrJA6XKoZPNcpprio+HW8Ys37U/tmXPkWDCeyRv6bU3sXW16fEtPS5Z7wEMdewrFjYTg4Kg4y0jRuvyUQorJNHO8UMnq87ZRKbl9WxICUtI8C4/rsX5UoqANDb7/vLhZNhfLTzlW8G9wj+ZoI4Lfxjs/eQht/BPGvYMuh5pCjZZXafViune+YgsrexUOkUNZDq70ySy1z8n8WSHPAfeRq2KxSnbe38HZjgPXcPvS8BIY+BqhzoQK+zuJLIhTv+unl6SmLkGmU9O2ro8E80YgNjpWeD39ZnwgKKHgCDqZZekVGbqh17Lw4I+dN+umRIQ6pmJ0n9zAWV3Bke7LB8Hk3jzdzobpNyPV1piGr+WEE/KSiJVzrmGXcL9B/ZRj0Wzb319Brag3qLZGNL7lyg52NWFIE7U4pzu8VTX3+uzXwMdoxdYpyOgRthL96jogpam4QFWPcMxMUQ91oCR1dr5croPurPu5GbCXXkQcQED9iiji3HBZOI42I3fq4ExT+bE2RwVkX/hS1+B2t/6ufHJeFAVtB6oBtG5e5U/mlIMUu9qsO50PrfB5pWxJo+/PGFsu02XaLP19+JYFD+jD7zUgSWnqPpGXwkUjhe+q2KTVZ3qe05Xz+arlWeSy4essLy1sakj/PlOJcnsKdvCToiGmSU5+/49VtFMpTQeezuqAf4dUMihkV/eCwjF6HlzB3kLvCz4/GtFhbExbBgQxcdkDV9YYapAHMGwWTJiN5uYofEdzPQLzIZlYOOyQcOCMqOSPerbqQ/mQv7LRON4GYTE+3RTli0xxJzWXj1fbl59kr0ETKGBKoIlrYVnqnpykV9PSS4VUx5TvTYPpHyN8ImbVZF0mSPwOB3R5f+Curt2+vyswJpZ6zKwOtyZ+cvgdAsolOMtcONYXWkRlYBVD90rPVaKNaP+l2VSCkhbqrZpZIOAPrGMSU2LFxrV6f3iNtSdaUSrfkDwK2u1aBU0ZwHrTZRsloF/TW3kejbeahLzmsVi15MkzK+H5J3u9SKzVeRLlyYozg/19ptK0tkTjbKfGjBwOdUs3N9VDRH0va45KreKh1QN9bcgAwbgSuOvW0SAJxNnKJi6Hoq2F1YADYsAbv0kFeJ33FstzcebhLXEC0b/7P64wJq3vRoajfWTSNu8hxzIHS5NAIsb54eD8rUagS/nNRS+vHpzRDklehfzoV+Ucr7/OGRQ2+uZjtVI1TZLNjaqFxU1F1p+1oFYMhZOsG/nyWUg6xtn2bg8ULAOBq2Obdn2RxDm5D26ItCjDPgWsQ9q+v9kSvGfyVthNhBJDoEePjeSXoJaDoZNgHSXe47LZ0Zc6odCv2RUTYWEbAnr7Zl7+Wci3kVJvrbQh8SxNvevZDxpnf8HNqTuX/XnPS5Shbwaoa2pIGE1YxwXxJN3rVnVq8q//4uYqScDxLUug6qAwS5xDOCjCTEyXjAAvQ0O97w7bV8jcJ/foKcJcyRsprqbDvhjsVv+z3X7D5NyzkPWFdYvK8Zpq732w5l5fyMK0c6x5iTItRaLktJ5ShOyCiiVcZKBy1r1USG9QhblnVoQLk9UTT8/Pp13AmZvzBhRGrxDrJZ8mrmAHy8orEox5EBEf9gzxe66mv7v87oN28deFjSioPZPjq4qdxYVu61UhhD12cd2tHxVPmuEDfEZUIvYqFBvMRPRx8GLU7LKO7B6Qbyl9THOuA9EIm/zmg41bBibKbrMslfPuwUgS/OPgYays1JFxNitQ4pHmc8T8QRNr2aTSjRz6VePuxCYLJTNHpM95VIx5ROEJjnrxIE++nEERD5rJ0bXvyjsBttJQw45k/ck0Up4xpDAVjplhkbB75RctD/Et9s7yhryV5erDiiOlL8kCZonZMOCAUvYg39RSb7F9VhOYAnlaL6f6RVxioduQTDUKvkYaabeiVL3eNDZSwatmAVrj+rc6qIOfHi//3ik7ryHNwfdIOUSC39SC3bfOoyuXrnu7NnbCUYKER6L260oT0sC133Ch61/VMJV5EwTyNz+EPPWG5mT7w2XFUR4icQXRo8sJfPCL1C2wReg4EGkWaZm8kP7Qso+oqxE05qoaR2htPRM4wpsEAFYxbzfAjd86IeKgFKGe0jyJmlortPY1hVvXy4ZA6mUV5GfqxAvQnqTGrbbIdZU/rtTBodLO9BH45fc6y7a8eXjxqwhSpWSppQHYq8QyO358rG8jDTilDv+uBer2zEW616LeaYNUEWrLHK9NqcAfHA1UsLNzDvRMo9Bto95FswIEj2mk/bJVmoSOMTaTEal2D9R8LaY7K8PmgBWQjVeUhrurve2jlSWp7krNp1Qu7AdhjVPbbtRzKXPQhGzGou8vj1xc8scsmTeum4ab0TgwWhIIMaq087LlgdlBLDZDH+HprV3t3cai7XGcRabCWCZeIUnu+5L/+kTpWZgJmS8FfsouCR+seEPA+WkgQP4/FInj2EToVvhQJg253vwnWgSQj55Gy4rLUoz23501Jhs+is2OMkhUOTcb1Md+ZqYNzTQCWG3bmO3vh46FXJzBURSgHVwME0tVlKvssV9KHvpiuHOCCtcpyeZNWb5Mn/gV9D0IWjE20qr+wsU7TzHqECnYJouctd1LkFiyYylAUMa8v3WMI4/aVFmCmgdWbUKdASE6D3tYl8k/b8RbpUNOX0R+M5yjigUxjPOT25x9JIX9Qw9gxbwzoJCcV6GZrD8fWkWdA67dv9eh6m8Qnl/SlRuNbqFuC2hysfsI0Lbc5D2fx9f6e8NyxnS77r16fhjTQ5FS0/yzNsc6W7o1oBm1K1UtIn94rRztLa44kElGxNa71C5XkcFFgqXfkHZ0kyuGHjRNknpXb/rQc0yIO8TXlChEQsaByhH6gJl2pM6mUEU5w0Ag2BGn5RBIhzLmst3juJXExTJTzx4Sr6LYmcs30TmGEWknmbDs1YsnBA05baJYlwvrESZMw+p+bLz7TbmHP5pGkEtoRFz2t96P+KYVTqA6cHKbFD64GufCEyORK7zCS733DUPt1OQ+LfzqLmU7Tk/KHAGMEjMn0GV2lzod6hCvbJH3L4IQM0MVwaeErwXqqdfjT1Rt2W6QfvaXnD6PJKJ5WzhTA97VJv5hetSN83GgbqPjbSy7mqH9kkvnnBW4ZGGV8VIOw8CFhySDisqOyKzguvfRwUUK/FUu0drm7eyC7ktp9PoNtSUJsGUd5YdJVz9TQP5gp/1uLNCPd2HnPQapENG8yOZ9PUeYXiOl8UQmePh7Ef0vzOuppR7is0YwyVRFelJRMcCudsxjpZjhVP6hRuzUIJqTHaxUw5thf39XONLTxqhli9xEfiHYBS3fsqfWOHH3cbiT0W6DElU7xYMjP78iqXyAVL6lswZSnff90ux354pPY/3wiSSS9IwNVG3tiC7+sWo9gbQ5q0f6ejIjEza3jpylavE3tIh2BBzkEaMHUVbwTLraJYty2DQ/sVyAjx0AM3IygLelB1+WOmtVs2xe2CmgpB3g/kSmTX8Ao5G3B8qHUUJluWVfN2GdudeqqkLrHqZ7v10qCIAxl4cRI4CRCdad0XUoF8iH/CcSWTzhQR5EhpHKgm2PZ2rz17bt10OUMcG+tbLYlAU2wLrRGBTDqJ5i/GW/n151/2DyDVqv0S5NrXsKmrFD5sWPwXClkf9BkJbe5cgWJ3yaR1TWUOqvxKqiHy8g5gZEH0Crinafo8pKPCaU8Tfdz6DAd+8z1G78g0Doum1O3JFAHJJOFaekf7joRl/ouVtxrtclrCPM0E6MrnOfZyDC4C9ICgfUPn/P+IdiltEYqEA76PY+HHB9cGnjxocPHA2E7RieVW+nuKcwLS+7WXXrZ8BQlovSkxiQb6S7BjOrcyadU3oAWqLKVGxPyUSFEiU9zxtdtDzBL/O0WPEAuTXM0Nuge6F0MXC9GzkG2VyPPMAYMWqufJpxd6lOtUsV0a8VwtUbcHTZ0XYy89xXElyjCafPECy7OjlvhJr8X7MfIWSoT81z0g+cr8Mcrk7Uq+m4FeSmgJa2a8pDcqr9BRJiSydPdCDcTtOc/bjGkDCOiNbw+c7S2/BGZ2Rf/4pRA5OQXFOoArbIL3a2iSzO7oySAw6/ds4DcdT0EQfV1ivHXSzkDEJvlYEnJIfYscXnOR/30RdW16LsyRcyhmgRV6zdoqwaGZvd5RAGK6lAylDb6ZbSPTFivS+nCG0QXTfh9sfK9ijhqLwjnPOoSCV0jABJU5aNTQLuUnv0sEB2c7QbF7hCcos6iBsKl0o7E9GmJD2onJVVODTFIUwVJfYcIstQ/m28AGxSWA0qgKD50FE83itFKQ0sSQeYzIYguIUNaILRx7BZ/M4zRG+Vr5x0i4Xl4Wq+24DndP2vR5L5Cg4q1wPFl5/03Mbgx5lNAp2cQb0GbGs5ppI992QNWzO42LQYsgJcLgucqNm42qWZVQ3fqgRSZfjx8fN4NqntoOKSRmJ+vDpXeloZjNSIZcRJ6UJxecCEDyNV5Z/Cj4ts6ceaojW05cieB2Kmt2GoAQ9iKIDdAIjAMDfiV+pxZLxpRtwsrB9yB0tE3zzPEusCFO4i0rLRT59nbDKkOepTM+vWBEEiYNuBxuq9CMyXdO+ssVhJFSbqHhmocvC32nrQULhoZ+i4pWD7SY6QihSYAdqIfXJTwWL66wS8PuseLLNz8WUXb016YYmy95fihgj/ViO+gSrQyNJrSe39rp08/LolU4aTc0Bupldh+GeyYloh/9TcCyiDQob9H/OuLlhj24gf0SLPrrf4cWQhIEfai10bAtgJc7j8af6AqddIyPTd64dEavJmWOJbSUw9QxI1tB2vqS1KbBGFySOxrFFgxiWzPj+h3S3YixFFW95+Ic6Wb0VucYTRzbsyIcUQfKz1CtS0aYjnS4zA1DbPYtQ/P4ZYJpG2EV+RT8cozCPTMmigiIo2C/rkdaEep2//OcdPF1fxNkLX60x4uxdLLnD2ONBI6+KamnPlY+Z4VUy/pqDY37cTlGr2xlZx+zWX//+EX0jw0v2YE5jb2ummvLzBAGvjqeXuiJMeb8pPk7K6dZQmF/INnooM55x6GAk2FcVN+THFTQKHXIB7Y1AuBD2h3e85aCPZDFQ8t1A/hz80HvLoZbRgfSPkL8cmGJ7LsD4dWArL5QcNpjvbB/NvxWjLUQUfBr9OoxRN5anGQb1TM4Ho5zPSisHFkp8eVFj0rx68pYVRXT+anaGtZJs9RR59vCagcUbT5+u6A/6WDE7BoSMUHfWZ5601mQeNZNW07A3aouEdhwBJtiR9S/YWka7P1tfDv4cO4i2tObKiR/NmnrFJzIyAfdwFiOAOsC1b35OC6+oum0wveWrPQmIFrNj+y962mXdRlgdvWqWr5kw3QNut8aRbOUgmc4nabFKxQRza7yTWdOmjFSSVSluoUUnJf3PAfUSTJdLRFEXaqCIuCn2hSCFm3iwFx8yday2MskiSbW4EsjeCVrEcVCg7ISC8bDa1yJ1JbsUXKqOxUG5KGVlHtNEMluPR2GCfHpdPkZo90JXpJrlkZYN8LGvcx5RXWe9PAT0gTpFqEz/Ui+kQJAFV8tJRiWStW6h5XF5vYGgXRisoBkBMQhqD5PN327bUIqGT5jkhVXlwicBcuGL8uZyTJXF8OgO/U9boI7Xc134wz/QtmwYypn9Fw9ZdUQ5JcN+sBeDVsEEROOydQjjL9HCBgrr8Avfx6gjMTXHEc6h9VIYCZda5LeOAa9z/NK4Cg1T6zEDGLFnRfeHhzDLLDe9Y73wD5QfMJa5aOiGgyRGTXXxFnWvnH3P0lJYUHNAZMhIPaw5Luxg4AAXmJ38QjItFmKj+nnuRkp01ZlHN6drHMyFKnLQsdyUico4DDRJpOVYCem1UZvkMe58tAi6aO7NLb5jgV5A0bno6xedin+uyuoq153iEa5wbafFxyOjXIU8kW/nb6ao3w/EQFGpuZFZa4HOWD1gGr7qlPSCvQRVKlKfmFLDOuK3KyEU4uoGtmXuubbLnRP1geA3to0VO0R4fph0vmWhbBOtZiqNnZWzhY23uESPSjbxROiHFg3SpxRM+qXnheXd8dIRbHAWzbAzridmoSGEDe/cS9Uov/FK6leqHu/+H0xwuegecTQmfpvqQMynMDtt77iqxT1tEsQUfSAce6nN+JlngXVaJouMcIujwPoFPQI59ViJBTsM2bTYz0k6t1GIsZvIs+8myG5KIKDa4jriD1Mt5P/0vHjZervhwk7+Vi6MyRd0eEEa8gmb2Bw5ZvZanrcFScCv2y0wWrCkc1E7V/RmBcoIWxjJWBF7gl/+qkNWBg/+QOHbpPbytrOinPt68FrFOSqSsy3WSEi+rn02KFP0i8nGacG3zXD0x8HsUwc3/PDHO594pf1D1JRZ5YZ5p2pmKJ5fJM8Y5UsULf65iCMMJt9BDNU5i9t/k8+mQCL8HBXUEXjW7SFh+rgLIGHntuUwltq0Vo2rIigHxTMNIYscDnMZ93RyEph9Hhyj1DVzp4WG2HxUUS/PFe9S01favaz1LI3sgCQX86gs8ppbqUIua16F5V3AyX5XLZoh0+5WeZxqwTelf/LDVugLywg4aO7qO3j1qMp1l9fBBrbjCtf2klanWsoGzThnP6hZFsQkkjyt9F0O4HudXyOnJVhJhBJHrsW1dTFqJW/q8Qtb0zwIQy4LlM3UTniu2yGWQwrvEl/hQFrngm69hj6YZ+Ku/6dOPIT0JZXCz9X4XTsyieMMTAhUi8lvY9Lc8FEb3ge8ykY5hlNVVYqdlSYZQIJ4sXhunXm1oMEy4hSYZ6optZZCnrjV11qw5xg8MbOkFcNJbimCsj398qL36aXNfEr7trjVi7Mq7gZW6/2Wi5rd7ww4KPc74NNBHg27oBCCDTS1FX8MmBLOhaJMwxWdV4C/WuJvEjXOctVVDIZR0hrxoTTJM7X2kwfRKUWIIQfF4RJuJSzXlPeB/KOwWAGlqeZ+eipmeXmb6usSA+F5vgc9uI3I94Q3KN00Xw6uTpNWKKrHOZbMRmfYf3prxBxFMWNYqXhjSqPGzhUzzB4QU2QXbcp48mMRHKvCh0nnPlhzSbVZxNacDsUQRPtDfBM2ltpEO4abKM/HE/4q0B4yFaLJ0+ewvfn1oSxRmzx+tCb568jLA9ATxYhY9J1h5LblFwt8zAckXpmZY25bsLV1pjo7ofDQvTXe0PjsVLf1GAIVauNUXKTdLvqCfmDWFHEgq3qBIMelix82QOAjdRM08rmuyceHNATGzaMVEw4bR6CiLKw61YZV+kYk01AwwW7PCEw169Ts8DqKWoTO0H/NdWaZ+oYIrIfzYs9KfJxK6gJxpw81UGuswY4y0UEX7Eov9VPAV2A+CF8Mfg4iVsvLHzvUdqpfyqis0er8+cb+ih7Po3pFNN/xDOBi9O4u18bC5HZ9DyEp1FqV676gWyOu/QTwWI1hi1924ReO1QchqzbVAWjy0o2EjgvlY8HCCeuo7cbWR0vSFZtRNKMLV03yqsHEFwaY53K/Vn6EncUBpLKP7ioIpcDd1pC4+s+6UzvoeYVs/aOTb3AxNX2Ag7H5xss1UEtgRXtetghZEq+L4OENobcOwlyjymxApZ+xIDgBny2CwGK8p42Zd+HSQUMcIxjKWfYlMQAQSRn/5St1WoWkSZ5GtB2jBwBpQXhQm5j2ekJsOXZ4j6tyJXdof4r4JoWyAW8aPVR4HH38FkCX8qBrMpGIoc/wcwswOHxfSYi9+/th0oUEXMuwtfxgr2oHdm8anrr2PXiwtKTXJ3jBe7gC5wap4wpdXfkzRHO4h/GkgcR8eMjr/+d0I6js44WgfOWc1vE1WjtEefujxV18L38evHnLkedzHrdM8wdFmE3YCVOtvT2/uT5+4ShLlgKUQDhejDj+i0J72PWzGkD6O3QU/PxNrtPRXzvSLwSnElcFF+csGaT5Oyl8wMIzGMWYnWLCotE7UCl9tDGu//ogofoRk0HM/qhth+6DSP8hnUZozKwSSws+wNBgXyfeQorQpYdbkzxpunG9rtYvoxw2abVWWMQ0fBGBY8l+R63eY0ZdhjjPqXLN/y/9vj5kZjL4Qn6xBCT8h5dEf5JejsZRlyjMaLaAA+opH2XH7/rUHj9g1fPD/b5bLxzXEdDGBHuFR7IOBBSnImUKnM/DAawWdrhzCPoKYEE4A2mZPKv2l+PZSzBBaxYhqiAi6e3liFRFn+A3mwTYzEQ8yxhmeF1dH9gpyW4ZFDiCqiVdePF+PhFbM9BoaRNdHGj5LlCUwrN9AuDmEKTvf1nZqQmE3LrqW5X1o/vqxOUOJw6lEsYt7OFOnIwK353jniUwJ+Sn/87hnyU0+Jc8KcN1/RR2VS3jGTX2jwKoWvmewL5JPtymVLTqi6gcmvH0RaP/KmwObFtKS+tUFyUWSurDALhCfGyUdC59nrWvGSgZTlSZlmPYAGf8xM+/F/qk9pctqMhrZLBYdMUioEJ/pRU1dNGGwnDi7Jj1jwg9lIl1cq9jW6oTyyeyqmdWgEogaFaoJ6G6ZZ6abRk1nJ7cXdQjtYx3Gx96U02pZlD4+xDxs7xkhSZN/PPBTyT6OKKDeYBB7A86Wb426Ho0c3G/59bpCGsTAJeSPvNV0M5L4PopE5T3mKzwtxAQoOeZMOUi1E8WQ/e756IVCfbbAXft1023i0rOLnopm+GwM4IF8g2Ulpr7+Pdj8LPkUtojnEN7ZkZoWBX3lJtG62NoV85Dha3GHSOgwRXY4BC+t9lLhgUTq3Dms8W+zat3jvdxv6MbtU5kWnn77CJUneAVsHduEM9bLCmPhJizF0gI30N3PJrhhrEkKrnuBbReeVwqh+KsbIW2NEaGv/yUMSyORU6G6netOp/rY7aZX1hDm1k2USJ6KKf1UaeJf8QZ8Mw/sJCofztz4c27RUR8xFJarHh8oGoAOdClZJ9sv+RX8R2N95MNLAM7jsVLyYEAx4h2TEgHsoeYpzfgfBKlPN5gpY3dUTuu9Q/yuVNMzLVW6qQQrfUbyRY6tMT+N4QV/LaNYgnMh4OWgVA9xG5kvMfHhsubE7078alPB0R8KbJkp7Vmhxs3ecOM7MA+og5umgQE6PwT/fcQnxlAMplsG9jvc16Hj3B5Akw+b9TOs5d+V0AhlKauw1kDsPG6NTLtY8nbX768JGtWJp7NSdw76PsR3Qvuel0G53dsfjSFc+8vzd8Ao4UhxU2wOCzgXkdFPSF+KrvjJfPYSidJOc0KvCd9qsnJ0FyECnZXtyur2nBDu9sCsBbHK9XfyPUkUUnE97YBgkzV6zCiNxzozAL5QOhyl42xDRNyYTumysVJbAgAwiCDgtgK3BKyBcUxfKkbmosFWTt/k0GIGKDBGwWUhHdHkzjulYbOSBosz75xL1uCw6JZrHjFAcHwxfhpLjWRXgVfT0/zQ/Ti8jKsvM69aWKdO7yQyZmXmI0YaymFUgWf+AvPacGbrSVQj96kaiCppX2B1RRL34FI7k+J45bpCC5n0zWJH0FzmFuHO/qOx6Sr/UgdH5nnUa+xM25UYeVHjRNJi4yqLmjBN5gdvP+vcpvME21aLzld04giM+SN6LeIlPYkxBu18+Gx1ZEbHTo+yk4Hwt6pjjpWnzw/40m+CkiNlPHA344HkaJZD5s6LvPdEnEUJ66M86Lm2WHUNHjmlAIpD74Cppl/VSn/ulwB3X1UUVnf2o9AMEjfL9J5T8CG6BG3InB9Hn7NxeQKFHg2y9+anqv3to4oaeQPZl1JDhPzbLnGz33psDaLook0YMSbZCki0P2n9TBppls/Nh+Viwiby+nqTLMcuy6Y1qm5/qd/MJPRoM0qJGYv8MLKrbD0KcJNTtflG+nA7jA9c8PzuJiczg5Ldbm8x9UXvQJqnijtoV5twjTk/dDpv2gPgGtmFDjvolecRjzTGBFGKGjKpHrDc1j5J9wRC3X08+S5XY6owR5X7yModNj6i+9xmsjwdj/I+6eGqkdZoSch6xoDlW82GndyDTkU4VBMHo5AUPqUF3KvSoRp+x8BPsTUx81si4pQZMepA7dRq1ozA/ndmziZIySozbMrvzrNv9JQ7FTHUk5Yw9SFo1R6dxlk1234rUjJ1ho1bswcOfu35zlqdmJ7WoR0D6GOMGcBi/lsrr5+7aI8QtrxgWWoefpmRbdMGr8HZ+YkxT9C6avqtDCWHOm96ChplMUv3DFvDeAjsn2oq5ymIshLWJSfl5wrtRxG3frHla0eKlhBj17QSM4O4dXaRMiU5aTZtvrvrbNS69E5iWTBqlL8bQK3NWl46xJ8fQvYTAiI+O3Aniw8oaIeXVurj1Ho1YGbspZMY3MgtbGaQVNJ4vq5qfoI7iLqaXaDsjVFIlNi7j6XgSsuq+lvT63RrpaNC5EDnkU9/7BPj8gmqSm2aB4Gxh1/F9kejxGY+UmJ2hxpv3u9PV4qW5CGa6wHKqkU6wytq6tmxZCqTLZgvpLDOFUmVfK0uWfh9D0HaQNphR2g53BiYDFd44hLW+8u5fh6nBiSmn82EByJmmK4kAyJvVflvswoDNLusl6NKkwjs6WZaZlc5VwA8r9l5GkVg6shnXc0XyUBB4QxVexCHjm5HrZ1FdGQ9DB1w2eBF5BbIFOzlTOOHh2FRgyjyr1ohfxxzrSoQgTeA/BA7dF3P66PAfzStV5WrzZ9cx9b6s8AJeD3DlPn6PlUSiRe9P0UGlRspnXZgHN9t7qQWdtBj4BwFdWYmeF6W8g9SRa7zOTI4lKzto8G3ElN0Bpskt0bDJCd7FyFZt2WakxqtjhGIcsJbe86mWT0qAevfQgtQwSPEk0NZc0S+ID6Ib8m8F/uXplNpy+uc8gYbFKRVvh+ftvi7efASsvmciS838Re95lSyElPRNnqiXgmAu6jkAkh+YGhLH0Q1taM3dpAmxSTNkTplTFtcnjCOvqo0UoN9XJO2tpVtfwG8QIdqNWw1sNl/y8lxYLHLMAlpj922KArBimG61Xprk5/PmihNAxs0w5tPd9lfFLxSd9nKwVtdPr8YkjwnlMNkWX0UMtQ4qpJLYFEdee2MTgr4Ub6g1tRKw6LzC0bn4PdKV0VMKZh9OE1FUcEZe25ctQQyjZV5zAGf1ABYm+3vDw7McUyC63l8uxOBQvqOItsURg0rlqu7zygyRjdFDh9UxtFpYvaT19V8sfY8YN6DzG+RIdKbf2OnJeBugIMJCrJwLRadDp55gmmSBDEjBri1b7o3G/f0uvGuZ4SIexk7ZUFYXAMsCtqb9aZIeBbgTQmlQ8cHut+ZkTXwumbcvvZQyuv2CvUsOFG+cd+/sI1LmgT1vxQ/LvV9EPvyHHAJBN29rF6UbMCyVN2luwxk8gp0ckUMXxHp4L08NxwYamb7r6GxsxxeZxRSns8Hp3xItFlcYQwxabuAdMqqSTwgtHp5mmAle3Zt9Vu0d+ST2D44x7+ouLJ/6x0swFabUz7fdhwnGYW5EPew3UNiIP+b/HTPhEYgMo6U9rd/3lsu8VTsd3LZhfIqxoObzRkWOSSAuAhJ2x1xoop6w2Uy7kwWrxixayc2GPyXEUBPcobi3Hc0Odw/yG6IHX3bvmJ/YkQerrNSh+EI23nCpJeo7+NGwtCjMSxtS1wMbJvv++Cw456naf1+dsx5fu5Ffpscc7vzMziceD4r09hS/fbTDD+TuchU8xn45VUegyQtRrR2lDe9ppOFtn+yvHG4RegOETp3Zbb6k6Wk7oUpz44vZajXEsudsOOrxbv4JaFoM+1YAvOKNc/GShnYE2fNO6ZriN+bj5h2LasmKrLtsWfYWHNgZuDMQd6+Sv/a19gHhoDmGXAejkrUOhmX97hpOfYD90aAazkaRWXHaiRZCrPmBWkp1nAS7DtvPGw74qQRsqyiM+M4AYTddY/igiiXL7tAx01CS7xAsbsg5jfTDIgfgn1LGBwkHOZxJfvwtciJSDtX8D+dbsizvsSNTTFFey7hSQlVGgZZHBc/HtCR1iUHn2m+jg8ZZmanILmmz9oqrZOeJlobnQAaRnpNa3mH8LQx6VME51wrP607MIq//vt0Phr8AroIVGhm3YFydDXYnaFqhiU7jkhoBNdsm0qe0LOQS68Nmvm9Hl6KhyD0csye5xh3BWcYhnMkyQix1e+YuimtIeCfv3uwNHAgfwKspU+/ecjTjgIvN3oqGMNgpfcbKBdO4u7n7Z/W5XhCM98838XZx36+ikIAlz7YfCgzZDPWWHSzlalqbYTPYsNOillq2L4wndcfRvCfx/KJex+AlxCrTfOacoNuviVN9fGbI1xMMLao8FgzkVGAiRX1EJEnYyTl8a56AaKs7Cd2gHnugn/Xt35CQAiQY7vJWGHGQeOk5mL13h+db1OWFXYeQaoJi8ITqwvkwI3UL9CX6Y6DRKsNZ9IG4dGrH5eMfdyaChJ0N7Z9GPX1V6F46Bohgbo7hDgoxotDyhRKjmS/9wX1hd81ySdqPmor6kPIB93kfQGft2c8033+v9B+ZXdihUlqBcoxf9AT4VXBSlHM4XvUtLLWg/4mdtR/jeGGxhiIBX8Wmj9MyWCB2fO7JtIb+IMsVLWnvxdOTZdIfXmDCX8yOXJQF4Ki6IZzSmrL/Xm6RxN0eA2sDlBQonqysCYdU5gKZB14zPq9GMMRQedXJG7C+KotNbykC30mGVxcwIebZD8CM6ZMZyq56D0uh/nAmUfbTra7KtGyFYxdaZM+gFc4mFJ21GNG7Le8TPBnuVTF7WyEfJmG2SVH2YGBIq+74gZbVewAh2tKhCLRqF+/Moq7wzEcZfTzW4DczHAYNQ/KnoJLU+zBs3JRClWbGfeNg3Bcr+fgk9HFgh93JsEluGYyL72a128Ghalep3jGWJinG7p7ssoC3S7KFX4+IId5QLxGSB4WsCFUUW7zAEs7rRIIxVnSr7tiZv4DQ0si7LaN8DrOgS9UyNUcbOiWL/0Zy4XZ64bWoGWONKU+lDjd/FWdFSUf4DCiLGfWUZdP0rof7AY0f7NWda2O5EgfcLsNFf6QcOUuqh5Q9h/VfwjF+3dMLKk6KxypXcHklFyLhmuCMJpQl0JFK3Ik9cdgSBuhZaBaBymmjNKIbuyWW+iFlbokBSOaf4MENH80PAYzP8jQLoOVOP2/1xDo8LUzGFVy4NsrsHjnVdxOkufDrx1k00AUCZljzDNLu8zKiJRCMhkc4pcFxYd1MFtTZ8rsNtqNb0IXUcSecaPac/v/n6vrhgMf1LmzH5/JsQjrmKSJwEEjvKOyUYwyi8uV4L2HJxt8QX9/KM3tW8ioTyg/mPCWrGVuC80QNDxUpYke3TxcqEB0DcxUli2afR1HljV60CjAUfwT/ZGUqpb7/BMAXCMgIfXLqozxCosZ2dD7mFgYV1cdv0TsNNkXtcOMdORxTq/YdqgqQZdeL3dgbY/lAVP3t3zrhinptGzjK/e8WAVZC5YnXEQ1a8OdVZgHk0bnRI+Qt3gNYokXL+2A/zZpSe6SQaj25w20sNTYoupDCFfGxw7uuNMG+KqxEJek43vWvMtaeD0TPghCRasFIYB0Q43abgpm1gMmEjlhJynr2c/TE7Vv1OGVmdJ1gpBkMtNGlcbuV/1BFT3Cr1vWpcMUY3IhYueFMaiWS57CVKcJoptmXMQ0rcubc9bRigaRh6DS8HsWoy8Sd5OvRQd3yCLdLG4sgzQ/C901aHggydo4RaZhXx35xmtijFjq0ZY83N7wVJ+oQx94Wc76OuPLOCUOMSrxMhCoHRJtcEsSzKsz085OjnS5XV1GW/fhoKzXWcQ7ydCxO7Rwh5clSmD6U5mCpVdZ9Biv4whtt4freX6Z1xeo+ewiTNWn2WxoMv/HFLoh2PL2A5+m699htWGwvE+RBydkpEeqbPpMp4QovR5lOBGgrV18GkCJVQEuWhvOQnMtpG87L6IbUUzCM2WtlhxGakuSIDij+8dJf7pUXHUvvalpJBSfY0gzm3FzxoWQ3EREHy0rfySoR50NIFnW2ZeDuhkeJOjConJV2wDciSzy7XSXUVI4tUQLu86GQx2axWWvM5xj3Q+ljLxlmXZC+zqlwqMsFea4/ENTkmgdWk3OF65hDK/+mJktxeJHdvJoa7WyvFoJqW8vJ7vT3FtOe1sAf/XmFCVsj8jugWnNB4KXesqNPMERhh+Srk3CMCFdBACuwBvnZt9Y52x1Lr0BpZKzpWUji47hNdi62CbAck3uHYvpsixs+ZOcDUWK9fzu3OU9X7GVNKEiO7AYBH1Vh2qW8tbyi1PQlG7b2GQvo/Zef5fDI6LtGNyD4EKtVfszQYDeumOW7IioKKt4GQBox1UterJZXRYvkRMehaculyQ3EsNGovkdV3FXRCwE6fS30FvnQiF7ydldnzmJmQSmgiselw/p6XtvNwNMICMZ5kgS8/cKAn+rzOTUJ9xDuBTjPsG2NOfhf2dsJudfRe7LUcCF5fJTcelzotROSfs4RgA/ZqTmmY6dRDp41szXKJjOHa+DP78Ec//h9Ms4H5Wx9xFKhhk2fGD0H8JTdUkfsX4zPjVd+2fyoh0PViQIQtfN+ERs48rOu4ogAYpEvAmjx3n2nFF96GplZvSXsBC4DavezA6FH8ai7CLjQGTQLRnjyO+D5IYFwq/GH3SxuTF2Btqpf5+MMMfsrMoCzlpkopeO0qzE6kI8GaZsOyLtBLZlm5nAO2XSOdDsAB2TJ1P9HZbYL9vaEh6djf3pDAJmd0hksOUJq2LNja22hj6yPGfmgeKFdWxaYo/gneSjy+i+vzqP8j3Qixk5pOOkJp5xEMTtCG173RsSGcuqlHHuhySJLfr1tLOr93QIs+szHV9RqcQBQepWeraIXrLvRRatbkjPv2hpF0crtEPUZwGdgcoJVuK2nC1fO8P4xO3kVMVT/nfFn/mdUBaM5Ch6jvguGR+UeKLZsoPnjPPXFeMirYfIauOsW3SAba3kiUKDQSypL1T39mFupn46jFc1fUiyeM8GQvBX0Tw7N4FVA9R77SOhNiVNjcYNNdzt09PEIXSIi7vVcPDrP17LUQLDWq2S6MtgBUW7VsW6iKFq2gmHtTWm/jm3AjVknbyB51lAGUVr8Eqs9wleMrJVRSOMfdODlX3ZgRZGQGnSx030ogPBjufeinEbqSGWYaFQj06LYWvbssEH/xTtycQFVjGN2YqRYUbYRxpAdZZDx6IZkLCde8tOPw/kC5B5wDr0m2HuzsmOgcOKq/T2YRVnsqeglhS7aP7ky4n46TKTMQD5na90ropwPIPobd/WnrZ4ScgZ+wjSbCNkfn9yZXaD9AWNZzlV+ESQKx2XNp9BVM2RWI7qcta4sl3Fp682Yvvd4uUzLuZLlQZmqu3JgmvlLNP8wP8rX1bHxdFnZbjJc0nHsw6mZsZ3ogitd5CgNSzEjpLiOXmBVp5Ws1eyiUglYULt5OceoHHvey1lH/TnFmriNs5iUiXRBM/aSj2o6e0rogROlMLp0mdDIzcgWktNfFHaWuWkOVa3BJudpEhjeFcQ2CrzPTXbPzeEDsmT3BGo0H8q/zYTzGnHSJP7DamGM9doY5Ky4k1Uv52f9ojyBohUn6LLl87IQ6m82lbaNsJwUKoMYX2jdrNSsukdOK/YnPHRJ86xtIinsfcLGeNt5qTF9xt9vGIDxxOontoDKZYZuzIOelnEGq6M9sWIpbgee29ff9oiRcIyjOdexDVOHg4F+CmiW4X3eey2zNjw9CJwqxoKYOiEVq8jbUfZg8BfAN2QUOmirRc7DVNC1DaYbfGrSAUKjOEJmevQzL7zIpKRUl1JyrS3R2sv90Rev/nqVrYsQOlBErcn3YLzJoBvbuzuqu1+tjBFIV5+fUqlCQyW3RIZD/O7Ti3CYTzLbDEtHOHjNxZ7p5ac+effTXFK8rXfdebzubHycuhfGlIZnE812dFn0/rffFnVtjJO2hHCEzayUN0XDTI93rIRXmuTkiLO3npoVvwfLclRTq44IP6zXQA0aiLRyXVjSL3eL9iTFICxf5D3U6h4Dg9KIPsW+EbCxclZ7FSJBBOsM5yUgKTtRUWsHUvUiVT0buvZpIMlycGidnfIFJaiYvNyhDYyBSyxPSyafrLRkaum4tRpuv/YuvUBKLAvXC73IGYyh3qC/nbQG/kIYr1bXdHw+nIRiTAfjrk5JtOGA+0Drb4hb74CD/ln2Qn5qXlN4/cCX9RH7Bb5q6qKbAvI46FQTwu4E04Aepocn4phJui9EaVBLIvfazjFkmdDxLsJmLOxvafqSWD8VMJLPb/KSDhqQg3bh0MYQnjcAP2OrsQq40d+VGw/5Pb/XyhjFLR+Y+QKqT9zOGUNxZDVH0+zSH8qiVDs76mIk3NjZ96Qku5A5/yMXwJ/5jscHgDTn9bz9g5zjVVuzamH/3QCVxJiXAxvi+Yo60BSSSkmnNIZJJhJT3Qoro0Ypqo2PhpLJ1ECIakVqGZbCEHQHPalNyWgOxij7/wua1zueppXEcSuVfpkN0AufqFHfhui8rPBznxtOtdMkdwEb3Tx4I3y4txd3CsbSgadZjeH0edLPAHZAL3kQxSx6s1JK2GB86hI9sUJlbk7Mip2hcTz+kqooM0s1brsJY/C27KmNwUQjverrxG33myBc3SOqkB87zshC0h9ubiyt/NXOAKrPfimy54QmANDqXyHappV2gfdeTZV0kl31y8HsXATifLEa0kJOjszmK05hKRPDZyOLKJKxxoCl+Eix4iq72VZ/WzHhXzHAk8Ioc1YPS8vGM2bO34vlGpXKX6miGn6p0DGzVFnt72LdrrZjgmhod1Yg12+Ys19IoUUPGGAaX/yY+k6V8iexetTAjOo5DuuB4Nwgd1vd601yIrCZpE9R8m5I+zMtCfS2POOp/LrGqUvTg/Fckw/471MTQC5At4FkCQCwBynCB2no9FMcYhnYnW8+6oiYFaP8WXc8oEt2tB239fosP1kIUbPwtQdYdxIP97oMC6iYVcmlmyu2+PsyomBNVqahvX1rYmJj0c9ZxZIaJ3ad031RmdxCdS2uu+bGWFY6Kw/CSADPBLkXLs074MWrxmdsnTVHTfzo/PFrKm4p5CGNZTAuumgZ73WSj5QpHYBinskbLQekPxcbGdrON/7yrdBz7a00X3s0/94FXysuKgmHyxu7FVYl8Xln1IzZKPgRjbkkdh5lAuetR9pZtwfieFsUFg0tGX4Pr6RP9yM/iP2DKUe4mi+UA6Y7gSi+k0xNX5ZSfkjSmzzK9fHwRk7pAFtKsyjcOG5f7WK+1LClg6dJiRauEvBEKpxLucf5gbO0U3rOczwkioY5fp35dfUf3TMWf0+thezn73EVV+d7PR2krQZ1Ji3gN3+qQPnmOl59Lwb3GcXoctOCWCMvnv6scFG5IF/a6B2f2mhaFJYF1XSvsYEc2Pb5byyysbIip1WoPT74EQigg+7FjiCx4u0NUMlhRNZilF72YDETj39oLoPgamqMfw5d3tmhji26ga+Uwsm7gxIq1g1y2gxVvH2Dodyf5MtgPtE8zE3Mq4tKwxWwkiUWELbS8qNBLVRLw///HcEfpXkYUP3wQiwwBc6dckwXQzNe+KFwCqmUQruuOUVm5/stIMJ2oEUV9wU2vkeR6F7n2/lq30x5SiI2h1S4n9OsgJc8gWflC07XnFW80hASTdbK0+p3M8qReaAlV8GStR5CRavHfCS1rFKKeyFaxNzNgSu9cjgB+FrGWviI9OGboX88gVJoEvHp252K6GhKnnQPJehC2Qlr8BLowVZuUq+o+Z+UVrA5bCjXumc90bF7f2yeRl0q2CoN8z/qgC6sdBll889hagiOhl2bqjRAZNMhbEbFUit+ohIe6BAag3oJkFuTB/fbV9VTawofy++L9Iv/MsuCFM9R9S38AO8tCLQ/wO0BIdBlKD9ZHprvnDYAJm9z0YfjvQIXF3JT3hITvnSZD4a55ShlWNmg/8n03tvJD1oJKrnj0Le1Rr0yy/SaJQHgBMsFpBweLrGA977K1xFgVT9kMeXL4uWbAY7NjU7TnrfGuW2nXaR0JWeZFEwY1T1Sgpo1yH5Vaf+ByMGNonCfKQ1s1SkZLjz8fH9Y6TBtF5+0wdmDRUH2x0MWnw0UEMgwg9o4V6RVMnQ12BbyQCLIswF4XCTB4LTvhaSMgv8ok7xde3lSRfhzLu8KAxN2tyMPHY4/eDktNMPD9CXjcu6s3nEBeeFr+l4ymxB1kowA+9kzbfyB+P8Tcb5AVJsf0GpViYkCL532pCQIW7tc25SChKdwF2i+BsIbvUuoVbBBiBfQxeLSml1EaabsoqgrVS+NUKR/pLvGmtF9KS5ebnSG5LOI0fNzAj7ahjgrfvgZ+1Qn03XZIwbec1/LPOm9vU/GW7tlV3W9jZOC99NcVLjwpyVfvVYglcGcvNdVVTS+VX3OORBSrw56GkQQqLfBEPIKBqgLl12BHMIpnketChBy0YrWfnPA2CMZYSf5Dpu3ME6E8np39hFK+lKuuEc2a/2qb/nkTCMfwY7ZTvlTm6X5cIUhkp0k9nv2f0Wd9SYK4v/llUmRaYhc8zlv1pxDTEENyGAzWkErRP6R5PWqLaPCdu3EPidaAwf3J7SXTW/hP5yuZT5rUuXwVYaNjj8itM7yofZK6/Xde1P7TvJCD01IOdRbUlSxWsOUAgjmGP9cAKXmLlepyxqTfvAHKe+OM8FA16HUeILP63kVu5qyFEbbsbnY9IhUIcAKmdHyVH7TKS1M9Z2hPm574CNusqS9U17cIkFcMua7P/8CnqwCr0iH2E8yFTgTW2VK6WoxIP5uRtKkQahbT1q2toWhQG/+076FJZcv3LxFiECWU9axrcwKVaVkIhpYk20bXEoD0VT6x8Ck1j9Ziz1oDaH48TntKkGFr6n9iBa8vhJ3d47YByz2zVdojzPRUmzOqVDJIkXgZaXC0ne4rXhnAcGbx+dic8jK5vkhgdteGNyaTeI2Q+9h37AkAzJM9iul8Qjt7RTfE5MGEVb/xDMyz/DVkKEAsIDNY3VLmoi5MrX+2ZrrgnaiTZtidYDGUGnNwAiriaKCHVwaGD4Le3JGLoxo4a8860ui99VNyYJQziwAUnZCmkWMkfM9w9I64WXGTez8cmIQmR14zSURY1OpKZQp1BAEutrka0Em0M5x8o1AGcFzhFKOfSr3F9Uk5zN8Plr3uI0GHsGiXwaBM0deHcPkhs5ipTTQ4FCrknUzMlZj6xWXmLB25JisKZMiRK1Rr0oloSGzRg5geq0b44aXwnk8xYNMHJlRFsvyxHzNEyYN3r3zGxH4IDZcZF+hhXjQZR86T7hSYLn2RNFhfziWVyHoqUqZz18gp5h76GLcyd4kkuKSWmW4u56+4P3LBqgdAl0gF88IvtvwMblevwIhqpEyqiPzEDt1kXFIBO6Qi+/45ug/TOWzp08WcxXx9+KJ2JvhfIV3O/OQkrRjEJ9pP9lz/OwhP7nrAnkFVC+SMH30vkH07JO6GDONjnQqHYltg8roAf7bK1Rqtth/bXUNTqz/OwCByv2ZQPb2JiCWCnSEr/4umSfop1yeOBxP60lsCJCFJzfIOm0UaGoEFURFzV7+UOQ8b3XRWRFhvmHntjBUBFWiRo0epDsxrjq954UoheVNcDW9fprp2GaLpDAEpcEiTzDW+iNMGmmEbzc7Q6Riw4mbpAiWjVe9KBnRpVqXVSBZKZ5c5uulJSLBt2vw950e+ZFUUri2UF3tf+zgr3aAVrlWHZRprTlovLgdkSqPUOD+xuCCtcyZRquDyzYKjNg/QfvUlnF0TrXt8aJAt9QuyIPQceMRnTW/G3PwvfbkwJUzuBEWeOctnXyN4sA6lj0sNpvKPjQWXhBW3yMO1Vo2hbkh35zQ0ESE6q7gxlbPXYy3NivKUgztsQ8iGsh6PLjfhoxbmOMBYFRQyUEQO113JVR/yKv+wLAFIDfdK8CcHYMLF6Ngejdf+nplwj1RlNscmYmGhOR93QXJQF8Efb+WklerTIUQusmSdSuAQbJaG7RyLDEeKhhLY1IrQ6YfgbnUOOm9ZlXgRFh4B0UUbmUz3G4qLwNnvgmSF0vk/3MvIlaB+WfMwqfmg27qFSwZ0cFLtYTxMqF6wBA5LOV8JwapZyUxv/hE51xHex+zpqWvrevPXcblvEJwLjzSj/ztTxR22NFE3bDuIqq4LINmkNJqvPkMwo5icsMRb2ToyBD/oNm1pPcveSFTsPIh0LdiMvMEZqeuo/nY5G921en4efoSkAn2uG3Qir5lCSC0os+w80figYC6yiV0Y1DG2xTK0bgBMjGbmm3KTXdJJpDGFNtxOOBHBUCvNUDv5HIzGgVsnPZvkAGlegKCDOSFkXs9Y+XNA78Gicaf4SzT0TKqImmLRkXT2pPeHiApsxgRRXvonM1XCilv0Pp1VdrZ32a16AIVHIBtzj4fC91W0ZX1ushNjhGhIEG/yJBVHPU7OeHOtNKEpzpwo2fi0JqA85C+xVfMZVwrqaVZjbFEcCIb4oI8FncFJYOydFZi+VBxjTrNmknQxhPJRpoLh37x9r6d2vy7iU020s2K5sOv+3IuVkomxcoZCErEEmV4ju5Fucv4gfmu4cBWxcwnP/zm+NeWWnrg0hTsNrVQmlblLEK4hGNCQ1699NyzX4Kjm8kCPIVU2h+tUWs8zuu36Yl16Sl2DFNTtjA6FlRRPrJJSlgX5TUwx0p6EakQ6h8ApTEqppknMZh3RH/rx9NgiMRxgOnZAd/BFEYkwyvB0e8/m3Zev0y8AloIEYKVh9pf6JrXeOmGf7peQsNbbHecnTqEAG0uVfYidZA04OHD89aFu7ScSi4vPumWTm8wvmk8Htu3J4rUC3+cf7EniFGj7ZMZDznoLt7H1Au09tkZ+ssRDMYW2xxY/kPXuyUyM5rzofW9UqRS/I/kUGQZEemZ9a3A38ehRD2yTol1W1RgbmHG2uweGbQ3Nhqic87VbRQwmz8SRn1JgkkC6ludb1Io3u2p0KEwZJxdvBaoD6G2j3b+6pZawSHMFi0Sio3DW7garmkM44iIcL1TKBIX+DmP2qGkT/fI7XF6FxgOkLP76eiHCWagfMnwikOVTOcnajuYN7iLmjw3mBabeqKjPkIYZVt/uUuKbNBCMDAygPCkr9GJJjEctHcTTIckOrRi/H00HxvJVB/mgZWqmaY/6/8s3q0P7/RGlprfETq4M4R/Ao3TZqziTrjDaojqAgTTYPo1NJSJxI9o+UGaAhyLPvIRpF3Q9/gx0NQJrwzVK0EWXTFl3rhFwjTFyl53deadBIofMDBqwChL9DiZkp3YRUy0lDV7DC+f/VN2xjTQltvvNT10wC38K7nts6toEDIKIw3riBEm+ZZ0CJbiwLcqtJnY5dPCuDqpInrAuc+9GP7uJ+iMo7AGO9ZQXbOWzkQvM9Vlda8dmv3+BDCc+tPRMDZSVFoB2rmAeRAfGicN1HTvGuhom7xeUT2SRUQIvkISEfGfIeuaTd6X0z26KBl1bfOXYCNilWeA2SuqkOjmfCZT41PLzR8KQlAiPTrbWJnqcTAhttn7JpeIYqPvbZbgREt+2aUs3WIuTtBc5jJ8mQkhqihNzG3BYSpAM7KHLEh0n3zXhZAI1nx0D8KhV3nCQcYiFDn5FBOMHZwgJ0vjWYfuOvH8QklJPbPO63Ct01VYPls+O+JPO112WYJ3aaV+9jAzAORalxYXn8kpFoJkor9hDJYGp0g8C5f1ITW6LwYycCdM3kjeTOVLlRylnVmMG7iRmUGJG88pKKYDcMnY+1TQK+iw7juqBBtFgxVIEOtXdRbsSBetzcIAZXoAOWozyHYHiMDJZU6J/hVLCvUSjp5SFkCG3br2pqGfurRHKU1tgFsUOSYKzJBrr0G/4Xk0yRVsGf+S6m+ZkOf0WXzyHwVcxz9I18bQoulbDmJbzS0SSEA3gqdanTwqWmlPtpbb+CwpMGgB8EWOTPSuWCW3LXDyM1Zl+Z2FwQ8FUOPJ65/t+q7FcyYiw+M7QGWTv4a+exUQPRcap/tvXiyMye541Xt5gL4CgKp88GfUzoKyHIMFQu67CdM58a8s1SfUPIcPQi8jLGhExYOfweo9331sH268ivdlT3xDlokUKfegrmqEzQZZgyLbehVYJakm2Sm/xYHTnkTA63RvwlT65Fgg+fIJTJFoFmjlgi/2ycva4SP1BEjnc/PtSCAuyxfsrcrbdbyoqqEaW7PJ98gkmj/WZ3O66szHXBzpom3Lm/e8fbMf1V/VaK8qnD1ALKeYE1y0FskQqbDgiFfd5PTVmhTCr4Kfsq7FiAd64gimQNfvyz67V/Kkc1NnE2W9JRyJOh9ezaVG4zX24PkaPkmnDDj0AWLqWA8P9Hl3f+hJOPQQMsceIcKQ3N4pu2xCZI+7SZ7DK3+NjttYWlBXeDD8DeLP2q+OAjZx15BJ02vk48/0XXpfQR1Ck/i7qiqiKfjofDBB3KTPUQ7BDofSNbCFVDSw8XRTJaTKhK8c/+HnHWyQ96wUPCUqTB9z7zyS+8X3NQigCGgGBbKAfu4xt0iSjXzAkMhFfMJ9WOfpmpKuuYIxuIUH7/cugYvzaM0/YSpKMoURQ9c1H9bXo8eLv3mRZhfJA1pwi24m2Gvyf7oXV9XTfLODMUbfxZaR78Gkrmqb8x8arTyhbl4zetRAeZiYrB6xVqO/NLmimpW+vIk+Yf/uWB8703TVLtzqQruMICfzRhTk98fCF63ZWEs1w2s1LsqhEr/5W6DqaoqowsBgangxbOuMQWWSe3VEWg/thNdTX4GoacmK1biHYTH18t0EPmY6pKzuGiYg9iC8qa1sZAWYC/+/E1vskIs4D4ND//alVxyg7hxYdFDB4TIy/zWIhuavjwisQJjqTNokGUjmzoCZBBs4XUG+1CcpV2adEdReXENAa1Mv0e2FfULz58WkrCEzXGyQPQShydNDJqFzMqNvDPBOZajGWKhYdqAuHH+AobbxHlkn1q+5HD0OHkc/ynjKQxLHPZciDSAXQ8PLvXZR+vwDZiMZy6fwpXyVwkOEKZzGhXIloAgCtYtNZGZ8L/2PgDJmHZHkNR31ZoTuLDa1VEc8u3XkYp13pRdQZtSTISx05YFAFzj6WD1JTAdQzTqLW34XaQbq/ISfNKQcR5xYJaIsHr3HVoz5B20Cyl8rlDQaj5N6eOSVqzaywSq+BZ1tiBU/SW8OEDSC0GK+QHJ1XnCWnFrqqVJop3stGXZhzR6HhuSjhm9gGM658fWjz1seZy75t6bWv9oPpoMbY36OBZxGJ4gYIMTS5r4S63U9xF0vZfHW0aEO6a/0rs4eGpc69cezPtXZFgT1+2h8HkbwQ4G5APmAdRR1aSPjbhL3yI9I0i7i1eintMVTBNC3i3+arFPCYbU1z1yVsO55b+AyuZogVJiqGmyJdf1chvQh0x9SKNiHMheayiRd6kOROfSqaZmJmPcfPwCWOlPLhcRyyEnRvs0Qd1KIwDF2F5BCL4bA0Dl+CJ1oXxFjaH0RfjGmi6kTyrnBQc1TbVM8bNmC85ZRji+a7/bAAyBloOTscK4Q3WNrSCIsvA+hNK4mUIdKYU5d5BqzvxmP3LsZdA2e7fRfHdWq0ErEPh5gKJ/d0lWI/1uP8WUi2rYr4BmnQ3dJPsUMa5IQ073ongVfUTA6XnwkKYQK8EYSdWlhWOUwxej26cLAF7G9qGRAR0fm23+xQAqAIHVXbD67SOuVfWgJGpsvrxvsVMbfQVswDQbCCHRfwgbpc86DYh5lsHrGt/lZUzxNZsZM000/YcCCayjMmAL4zMQEuyrGlaGj/QqO7q1YoQycn2f0SZ3aZpKGzSs/Lu5FlvKie+5DuFjq2bHFZa2losrIxInrqn0RpDdB0GFX41KOSOMWDOIB/PBR0YWqbeL4MgwZEQGjtJON4SN+XqBKfy40GrOl5QOjX3IHV24fTGbphyiHP6odhp7JQ+rdK0lFxsWpTu4+mUekjlPlAxEOdpC7Fr/f/EIP4ZZc/D/oQ2i9i90AepECzV79eerhtkYMMMUtqs9CyKOehtda7as1K0lNmKv1KPOj3n/10eWKIDuKZksu7c2e7mKWjSP42FNI5ATx07gHVwktFnIkR5yG+JClOWOm8YeTH3kcOCeLMweMGfMUTt/9+WkEYGcOfcrNnUGoJEXeOFghsHhOUuNoLjZKgNlf/5rXW7E1RBCpNH/8ec0TY0ToQ9kiOsc3S9hlhL51PbvKVgcHowDxZWfZr9sTERRmoly+YmNpKMOR0vNC4GX7poAUh0qrMhh8oA1bAx754dDjJRtnNwlYj6dBnZKujZTX2IfdrmDBQdCiGTiuV+6vlMwNem+m/VWJrOSlMtuVezbqJlT0JxBAeZsB9kwGDOQxFydKvA3yYdHP3FDVhMVKwiOzT3lHmYGcaNp45P5pEaga7BrPmaCyGMbzEYkwvI8xAcnCglLOL5DjQ+gUatBFT9r5lCBIobgGdqpoMNXiFFMcohJ9dM3fK28ebVkxYalTG3YW7MoCUC93kHt6Cps2iI7Jlqy6uF3b5SYZN+d479jQ3R9NKVLHw7uMuakKUgX7jTRG5bgnE/eLctiHjJ/gTCSfISopLhUYdKTiOFuXO/dDfWJCDqXbGtyy8SvfGCDQCmY1IXXevdIuhE5WlMwexQ4sk2BcF72ZMXbY8NOgk51IbTzjLHOvUeeWsUw3A/SFg+My5rOk4YP28k+OrWUWhbNMVx/6qKQIlbC2d2ry5OZ5eGi6KsEojd9fUGJDLyLQqHafF94NupqANGQPywu9+84gBO0QUUKlF1Q9R6y6MzXE7eyzr74jGBu80C1tVsCLl14VwdkUk7dthGtNcjCpapTawwl/PW4uDApzyQaHr2ka7nIci/luVWZGFi8XXbiOJzNgceccpEid96ASdhEaf9HTeGSIRp1dAp1fi6LvUq3H8eGOgcZxFyWrp9HRELsMKAYAFQ+clEOUtKHkjAePF8ink8HeZxabrHrSSRj7dILYEEeWYR72ZVcZrPrNTshJPubHHwid2h/K9NsGkXBb5onin2GGoWuA/x4g5rpVx43rGawKAp2SJIs2TKUZuAOotfOrvlxrEQXVOSdmYuvDEmGWfr8pqrAFmKy7/+LAC7MNEtI5tSTF7SVeWvv8JOzHRX78OLQK9OibuY1QxE+9NSM9krbnXYJcIZMZJdu81m0rAbS3ZcWO1pgrMP6FLEyvWZgOiqKhAsdOYEskTXsTyMHsVsqbZ67Io8XGaoOR2m6zWexQ+L3hLLGxHFU8yObbsS4RXlkbG95iNMygdtSioxBhv82ZWe02CGhdWqrgUWaNk+chxWigXKZNP2EcHoanTDOAKirxZv+B+33qwhrlemxMakhEUgTe/WFty2CxZnXV517XhVO3IrBJ7hH1Q3b7GrZQT4E6miYJ8iGELdIrzT47ywfCCA9ps8UiS9WzQ5WQXh3rk+dY0J1kzgVjOOOmOpatbyP6u/WLT95/9dRc3w5UIkRztC3Szsh0UqzvHg+kdMtbiIV+8kQhx6NfgRMuk9Gekb7N8hEedLqnYWc3Cc8mn37/q1FnDH1+7BlK2+T1EXVUiXwKqi9HOuJoDRCmKuRwRt33uF8VzvnGX0XBa7vC6FkpnM8mChwZBIf0PL8wofhanhnKY+anE/ZjvY8jaQyr+PwT74+ULDyQtAAyE85TOnq3UvdTjhJmOrTOw8SXj6pYafGPqirr4+0w3iGMHViB9Ko+kAS2+jDS7/q0sN2GEXeU45nRuQtGQdVl++H2E0mvE133VtRSEtFr4XpVisMxmRRPzHNmlvTcHZnan62wfMXaQQPBcbtR1z0Gv3UmBdll+jATe3noUcb1OxRYxncTfFVjXee81A1kfWJnU3VcAwOEjWImG9JLXisJWAaoiKDTiBN0MelAaRzGvbMvAhGFWQ4EE/uGR95hbH5IQdOO8U5OQ2fYEdGk1eVhN/SxNKBbz4RKI8BkeV4h30V09/YvVX4TTeIUzan7NQAZeveU/lRLYxpAwuAft7HSshLHo9YPqNT2s2fWp7HTVJR7kavMBpCi4vntxr5QMjgTSiOg87Xa7OAbggfC5DHbZqg8v2IG6nIB0n4HkqM9ArtH9L/0lA/rqzQ8ZQISwXeK7a1ZGSqdnoCVNCx29o+soW1PRpC2kwaicspOSLPRL+ZYgx5JyPX+a80TyQEqdZ/bRFB3wojVHGonNTBLwnP1sWKdgEKaiutu4viqrA7NLtbEGF3mhvfRdp3ZYjHbV5JciKDoPFamD3yt1yLD/mMC8vWiI96vlN2z0Gu35H2aliSS7Kv96bRKgomvxOHokxyBzc2r5V66pOOYSHBOYs3l6Czn2Z5uq8iNZk3vZgPGPpFKEjgmh6wxrs/dbEOYj1fS6wwJ3Um8scVAC4MNWnHFp3Kz2yscYKeROzYvJnKRzUF/Ts3LXHflP2go63ydIRQw14CalB2PQhW9FNdup3LIMPSjhZgwU3ljRzh7V8D5kyBho0wGQnDy984vRpylOfCC6J8o3AX/23JEG033T7EZ+JvkETDpdNBZp8m9QQnFOycSVm17ErwZ6IDbYFK2UVS+WQvY/rWBxxdbGk5CTxrCWqVOjCz4hOZTr2fQ94+AH5gUqPGnjH/jSuCasnUASDLa3ag2M81ul0RGUpsrruYz17lsb2k9fVqo9jD6MqeFxKyWQDpOeL6ZuFeOKEV0Ef1hbjrN1wiWfIVKGASQ+lBpcRhggHJpIBT0aVFJAmS5zuqTXIRigww1NfOyn08deIc16rXV79JXRyF0+z7e2NsFox8t/bOOwZuNHWRfwmifX/ydYMhfVBpescDjOmtjD1OXbkA/tEw/RGE9VRiz2lwHVJUdQDRPIiaysgrYYIptpVSjXXh4QMSpNWxBuF4YxK/XAws2XGHzRlvLsoCrWPvofA7lSbd5IKbZCfx8ebnoz+nfPEARgMxHeset+F/ZlXQnXjB1JwQuvnV2K+FtQ4KYgfgyOsccvfVg/GrzFBjvo3HDlT4A7bUHQE+MvZUXe8ZKDIMe16OB2YHhBjQeXS13Dufo/hlApNN8xRLt1kqOo5mdnZ4XozKb9jxDXpAOAssNlH6jT8YbkUQ/lnC0sQg9C6+tKLuDeSkRfS7bQHDORfKIBEezy+Z7rhSRq7lGjbqjlZSMRsODw3/oaL48N5n+HcYdC6T/IvSBHv2Wt5aSfB4jA/OQXqsNUT7Rhluoi6xPQcD8Qyzb+2FSFjkTuCJe54ghaJtKR/XhOG65R2zUAyQY4n+tru4c4UTbZczL9inUqC104JuxKma+lgCQ7A59vuZm2tJ2s+vrThahO5/3AP8LhlHp0iKsOesPwEE7bAib/h9EXUjOE1Cr6VKS5EesLm1Rqyn83Lf3aRrAALfIALf0zuQnkAay8BksWMz4yqaeo034p28Pw3oo+qoVlOIBy/x8HCbrpVyAIoWUW6L30E2dUVa7E/zxFE0KjndHM7fmrHWE7g9YMgzxk95uucaUwpkCgUDcjRCWkIJ+WmjlFBalQeefQLDTyY/qUUg/mRwqj0KO9pC1h6ldec3yim7QBlcZwnTa5okmeJ/t67X3CMbf6/SobghjVKepGzfJk9Blhb3cc1GGqbWkiM3Gnf49jSPQ+H8tgaVG9stXIk6loI49BeAHB47TUevlNpXxwfxZ1ugK5luS7QV4ghA30RMthsLr2OzEy9CbMqLSWoTubvfGmWBNAufwX+0hJAbgx2yapETD25IlPEWehGI4MW+pFhNh+EB+EuhoDqMSmB1+JcCDFt+6Sk0uFinPUckeTuS4ImrhCxY/zVfeJYRPISimgH22SOqTJ1HolfE6NkIfzHHFsUWvpJueTzgmyN+AuK1EofdR/tTeTRIJ3/UMOEsdxBl9Nrnj+WeMStN3ZtmnSfLC86SJELfkNMZR2rgFlU2sBHs+AnOn+G3fIWVFikI819pA6wRL8YwLGCAoz2QXkb7giLvU8Ir/zFN2lMg5QvHiyPzQ3Vc2KLHUiQv6eXD7y4KT+XNZ0hJDrjjzrcm0x6UKsb5EWt1cbeH1rEPPg0q0/BGeS/89tJudeVi1eBqwTEHn/VSyDdzxp97Gjus5OdeSn2DT1ey9hvl0qzYlJRLKgKg18FY+vssnZS5zSgCOBD3Fjpx2Wz5LBXrZ6LZUIJtIUUmPh19Vrr2Tzlf3cLDZglXny93CA5Y3iih6iHPq4Nm5NZzah0prejfsxqpf6Q1TQelC8CZmSXPq/YiPsmfBt8p7Kd8edvvRYLU5Pz6I8WyTmTLBt6Go+K0i9BXvjgUzQSwTeyz2TRbxH0khvzrrA4n+zz+SQE10E6+7LZjtNNpOFfwO9/hIijEEtUTKVi81rHqS/fAXNe14PU1IyE4EAR3J8pkt7/U3xdtB7En/uNSKmh+zFrj5ADU3DtqewvdY3UJdCLYq6zRcAt1jIlL/M/BQOWnQkiLVFYuEtC5L+4w8gckJgn0w9wygmfSG59bJ/4vQ+dNLt1O4yNu1N8Tqqlo9TWQJouIYAE0e0tAK2CzaDWJHawzekpeXGTDhj4/CWcH1eUuWXumQRDxQ9gBXeCW0D4IXCd53YTb/DOn7J8A8CnP8pyrdAskHHZ6e4XTQQjFBhgERB1pla27/jHp2+CFWzLEXtlvsRpZECOLgrry3wM+oGiha1auR79xiZlXKGcuzUvUrNDum4RnAJqZsdL0j5Vyre/J27dSxEKrWoPIoPuusF0zl+32z1y2T48t9lXR/3nStFgLVutVGK5Q6OFcnGlu79kYoGRubJ46LizAkNifoHAj9x6EDEaoxOn5Aa3t8afVdjzYnbA8hQWXEpbt/mimhxC4weJIIjOMVYJGb/bzUc0neNoRte9tpjHoTZWdEsWcad9yul8DYQdATnUka3v7FQBwep/Z4Q2QM7q1k8gnuyyudZXgwgZubYVF5VWoy7wrF7G17hr2ap0Tq5OCh7zbtOjt0r0hRVSpW6UzCi+zg1i2r/onY4t6GO/4+0MtKejPm0UDVQWQAECJaL+MjSADGbXqRoyRZ57Cz6oiPG75d5g4WHWvkMa/KaFLIwBE6+lCs7AZScOnorSmOG19AjLfGEAP/0vvv46OUuDZfZufKwODyvWRkzDaMYv1qb5icCgn8jBEmrOuf3h2pnGAfaQoGnXu0iSmB+YJCK2BoU+8WdNdk2joMjRcGreWy0tpbwQ8rNUz1baUkDK1xPRAqA8PINdzkZBuY75Sa8qa+nbvONxIJG2ncMpf5x9CqoUocAasovEfIbjO8MbwC+v28dhh930y+00RXs5oC0RduGTddDD2Bz60AD9ELQ7Q635/sa/BZJkCWxY/X4m/yAUphw9xP6kU367GQ2vJOZVI3beydaC0j1jqn3faba36CrLnvP1OxoC6N59lR8urh2hddFoxg1ZbSpplUH+mPZJhQLIasKNB58xySqOQLav3OEglxzlzSX+tAKlkPH2Jgi4ORBAD/Q8YzVDrZgglxO43E+xRWFM2QDyefWn1OAWDZaU6YhkAjXksVgiogemy0pE/oG8Fbp8uwTAWU8xB7in+iXKZNjn0f6gi3ArZZHb1Z3mHE+vPediQS8qTh9K45gA5sjNBxeE3kc3vFqP1n9ojODDcr+YyyJt/RbUQqVZKWVyCpLPfo/dGGa9fCiNoWyaZD1o5VvjjkMVvKb09TSDebHnohyxdp2s1TUe+3I01tglkMnr5RLO/EjsP+bBcSYtZ5EGiiAHKMS0xoHWcer7Hcw5k5xNptpBvnSKuxEZq6FOrUENc1TxyNBJ/uUvd3Ab9sxmjyzcpeijVFTQi9uu9JlDcvqTDsS4nnUChSPdbx0F0NRM3FFrpME/mn8D4/2As3Cni2yWhf8OB2AQ1RgMB9iVaOHXjhupT3lXyt0MCWpueqchBhCaHp/jyUoUnFKMIZQFYoi3r/ic9UzcXJ8XGQmmgQazCFqdEwNz85CCzObN3X/Cdm4e2X0ViQDLzoXDselXyovcZo2e9bmhYkBzprwG16WvplzqfCzzyJOw0JdesXME7ivEnKadX8QdKRKkXynx8BTDeODmfdXFceK7fXl+VWNJLLre23Rkr+MjwaCE2E2Shyjv2KZ68AT52opnhDGo2PyPD+3lWMITmNSgoMy9A9ztv4Vq4ZsxxK6PTUj9kWAGsLFslLgCNyvG6kyvsUvAsg8spjAsqJLKDrezuIfpDYFFpUoh+7bXmTP6dO2rbgzJ4D3gn8EHDTrE82+LAkJxJ9y8JSVSRtKuBAURicatCFcST2cUXW2P1QaaaukqOe0SXxPlllE+Z2EiCquaSIscvo382stKEbOQcOCCsk7DAFzVpasLTcUgTs7oKp6mWHJqrMQ/dQFP1YLSaCkwc7biH0wfW+mPf8njXrjA+72t4y+gb1F/GEhgZmPQW5SjVsh566yF6LVr8qHbSmTW/aQAt8xecQOMbNQiTTIsENAk642ezuNMbOh7EFPT0JanTvLggDmYaPDbp6xQBiOz63BwJzvoDuTO/oq5FUxciPLPk/E/lzU2TA+Ep6p37OSFoJjVuB/fO43zjINNd+z/RbmWYw5vkG6p5AWEnK6I6RYwny877Ad1+qUNTJXImrC1/oJS9Ql1BtESJQAtUGVfk5MzCxqFIrwqpjvwuEPql9r/m4jIHxN/NHMui4pFDPWQoX3ZOx9UgmvosGM02zbj3y9vTr6pt4CbnAlc15PQGfFm/NQPDt9IVBbYePOJn/KIPoJ4zHscFayagLa2T7GfmXfUYzqsq5/YyCVQFpDlEkBARZ5LCPlb+L+7y5FJCVbkd5tYrNAHmgUt/x18qcafpaTFlccr2IA3hNU1OYPMev5/2ln0nqSXVAHCcb+EOY4SD2wKgdNMML4fnRyN3r+a8dvBBKl+vlg1blyhpteKlFTDvkaavgSzsw8etag1Wtcm50ns3lxfkxZ/uO+mfRSfSNMNqgNnARXNMdnaXgNsPPLtAoXyKQWFaYGfKJPiNIYKnEcHnFZfor+gRTOa0Q+3UX++RaAciVGKbSaUHxjlU/kVh3aa3iyJo8jJo8qCoshkhx9MaIJI261M+60Ox4Uv0MOQv8NWEMRJGngQEE3K2A5C5mDe7XDBGkqVD3A2AIqToqvi4jMIULZxK6sC66ne9YEdN+B+FLz9ZUOetqNtqeGGHKYuUvWqRly794hw/74YyYdMnh7yQzKxUmBarp9X74GPg0cRaBqtfjMSNbh7XV5cLUL0BSm8cAbjhpzHErp7GbhnxjQGEXAQhFeYV+cytmIVS0qqnLAe3VqL7uvBDB+dG6s3YAuEioctcAmR8Myswv46fj5HfaGzcrI3luiufP7+aImrKKYCi7WlugAC4J4GrXIMoJb8C5ljj3ly/QqRdZb+/HxZfy8IySGS9oogsyXpj47ZCA0shcqd4pCpMCbMmSJKMUxlx5YN2ebH3yedM/JKYiqLN70EpCpOxDu8q+kR65vsqpfP4iJhsZHXWogdWpWOdNuBuelTS6hkrpuef4hOYvhZFMGOGEFydgK2JeJpyk+kgwIgQBvUt2QoWy6Ls9MV4pyxDWJF9qJ2t3ny1WVWwtUJyRHwYmqt6nhZuaW0TyvZCNyMzfXTxQdplFJrv/54NPANJmYYsIslOdOOGnDsFUOkfw/NBs2XoLaVVA9Erb23KGBnkXorsuaVf8/n1afodwFyAoi3MNyNvEg24SYHbNRyqFjiBSq1a8S0aWbxJegSlc5KfCOoFY0ecmr+cOXJB2hsuUyH1tVYb5P+IuInaTP13Ize2crAjiqerdRRupZmcn11i0Is9tn40IdD0EmOhc1JE4qs4IJv7SOC5ld/hmtUOOqVzweX2gYShOq2PaTF+o8R6yXcahJRPcr4hSSg1EaRZxxxyGY0iw5huf8feQY5DanjLuKRpQ80vTAQo42kkyyz5Yc3ztHoNrlcYXuxv0tNqbwjscy9W6GasNXXHaKc0g4mmP174Cz13O1RdTvKcdjf5/w/6cUjtfMdS5wFBoTXxeq5jDF60JTtzPo9lq7EBhnwOwJhzA6uYtheQFu86jHjiaX9xzLiN7or49967xURVaXNDc6ihbk83HWJUwN+vmeIiduTqW6ThSnI2pu7WzU2zgcxlPSXHfd2EWYSR36v0BEUj3os2JKCIc9+nu9dlO4HRQNSHnxj1nVq245SvDMdjf5+PiVdfmigDgmnANTgRaWWdOeJoRoncdSHy0P5AXTPNOp6fqSZBSl3AJcA42DKgvlafAQe2tYoHvMVJfuFEqI82MY1M4IkMhwG/FmB8r+JsvXdzdE34jk+jL+hg47v62SKBGuHke1uZjW3aE2Aev5T1wPI6m51Rw7HR04D7hvZdD7zdkoWxVMgBj3o0Jsr9BuNtpw0ukzS250BBsxsdFFiJNo112yi7iE72I3pD3K7JUBj07USzjFHNPCrYiwFhujkGO4f9ks+TyStkqz9bn/DcA2l3u7Gv2aCb6AN2AhX3J+fPulnL3yxEaHR1MZlGSic21YWsIHHM5/h0fPIkGU107imzRUla5Oy7Hi/JQAEmjzLqxGt4rIAtaeYIiD5OWKzWDMHCeEyKaeLjevGCEVAB6ZoK14NcstHqXg1/bZUn0liwFQWxW57gxdR6NfWCTwXD/1XWeMQtVg7z3j0UQPTkC6Ih4ME6xeFwOVTF/1dujZGgl0y5oGmv/AVInPXMTfnOK6TP5keteBmq1Ro5FstilQciSBXzsN82sczTUUltLEd9v0sYeqmi00O1iCCvi0+MpYnvJi75KpMgG1pR/zuRFvDj2tKCmfpBeNNGmnd+R0UrN0OZrKsJjveJzdOq+IrmctgWX5UzDrg0iYvqhsrxZnhDIMCcVXGhLNUTz6EfY95TfTd9SAiE1h3EP/Bi29VcfhXKsFcHJcL7bPYPf2tGKHp/WfikSjIaP8bbKH+WBTmUyVokXLQFhlrYaT8Gl9XYdv9j8nqx/dAZx3eJ9lyOZvW2ia79oJyBzkUEvXPvZNlB0dH3X2mTimGczqq29WI0hCgsdrCdyC3C8H883b405xyH5yBWR3xfPV7KAp3SSnCJ9B3Be2Vhv5Fr+UFz7mn8ThVDmRpZhd0PZH3t6g7ySG/Q/xFmiEJ6BAn0lGkHvCZ/37OkteN1t2rpKaL30vK1d4/3RKjPBdcdbEeo5Vdo8sY6Dc3cLbSaCCN6bJUZzboAtAGctXxXG6Q9CoFWxo8+H9Yrxtflu1CYDS4sEAjnkA2h993pgSNXCfhU693AOQQsqQCapVMAP0zfi2V/MfPJMpUhNjjYFfcnYix3eUaOf6tWlsHhq4vFI5XNk4fUJd1XXST7oTiyksHwYcgREGpZNmxX/e0Ij8qtcnSW28rUH1ZQ7LNcTHW+ETvdBhZBYFcCmNNVffN5LO2KlOIxU7a0aeiKp4lrTMWPGERDcmcfCHMh6dPdcY6KUDg5RmpSn/kyz3Iy5l2SSRC2vzk+jAgAq+LVLDz1LlNkN1G95CZH6tc3M8sO5X3RItc/kZwjieLw3IlXQuCY/sHE5v8dZMzMHM2FyPiyEXKJJi9FgjU5cz/Geus3kmwwiYFG7lqa71REg48np0Y11biS7tZcvWFPI1tTN2E7Po3DPs/2aG2hU6GK+7z8h+8Noz8MWyyVPHHPRsissOE8L0SZlMy4FCHxLpJEcj3fa7xG9SdAGEOUzsWGZl3cjyh0RYfOX+/oinH+3LEX3bMGtOO6wjzVYIbFGZcoSTICtdgWxA5tBQjI1nrX7gHhE/MqEn59L/qX7u8gaNkE5aXw8oAluVMBCbOg6cs5KDpGeM8BRO9rPuBDXDALv76Yk6Hc2FxAMMY5XmiYJwfTvjpfvcwS+5IJYHFtugVZkAbHUZKepE8EW+GL7gDDfffv7l3qIPvZR3cWpUzt3B6vn3Jp/LFAIEPnn1b6mD3EocJGzYtzdjc8LtD0QqwzJBkLYfjI2kiVb3CP5ikqTv/e8HC/dLma+NZc6PFgnPooEQw5/w9EudNSn3N4QeMofXYEEF0mJ4iaeUnXkkYugcoNW83tDPnXm1za+tvxnB8CiZNOKt1U/I1F4CrrBS6/EDGAbbGD8Vp6LRlxwB3xnvKdrTpB0v115t8cAnpZBDkx3E6gUVZqMHGXQ7h6+ueZ6uiP+RTjVEXNlHlX9xifWf4uTjjDqGOzCEKpcuG6Wrp6k0gVPWkRoOFrCgb3aGZTU2O6Z2M1IWBxIGVL5U5GvcN4vBjWUtmD0YFwXzhL4n5wT5dEKmwD/1ht+3s4tN1pClcpyQPKkTH9gKUBgqpG78bsW+1C4JmmrkNP/zXXn7Wf/jjdSQtkr29Rf+jVswGeRfvGg2fp+UJOJjvmcGZoS1QXW5oBmwXEKyjTkeFf3DPacsdajLXJVzg8hy0PA0huOBUKFX4Ftuu/BOPIHI9MCBUD/XGnyUvYzegfOMXz0F2BgXhpGBicuHjZ1feh4zF2T1qMX8Vgxus2JVv26TE42gq5SCZAJLT7PrJp/RRnrnfWNZDvI8tMRaB9CwZ+nbDeoR5u/yrp5kF8kieMQFE0WzF5EfEywmLtBL37ziSs5i9d2g4GonHbSN4XLS7fmDbhMrQMHT6PD3adZ7VJf6bjIu1wI8cEK9LtQpNX92p8fEAq8Pc1zM5C/Z3BiLF9fT0PYypsWbt5Yjgi6/4pp13idAhw7RTp9ULMb3i5hMB1CiUYzLXrl2sOinOh8RzyEpRiJ/EubrXBfDiAqu7MnIUz1DCgFADtgClKFDoTRrdxoSiHzvRP0XBV07AddI6w2dlMnhAkSrTN1DEIQ4NOVGFwCyOgIOM6bSQs4RQUP628Gt4mrexegsNB0DwQZVWBp+n+1mcMwYdVivZgUIUQ1q9g4q+xISgutu/9lwzFuibT5UjTZsbNBcu6DF+qQ6C2+AT5eNZxPeIQu78uvC7fiRgVopwdi0YqmVjbJjTqjR6vfxTJklVdyxLSYftzAbQFYyaotRnliKnmi5C83zc2teOpB6oy5I8+b2hKciGtRigBrfRvLMHgASap3ULfEd70YBVNea9S+R6wf/FB6SSzQ6FQUHK7eyXynRVyJk1qcOjYFFO7gtXKdnsVaDtVuOgyAPbQRcn62kXB4y1OCOsgUHd2xPu7sUXcIwqqBpleTjPFq8Lw8XD34gazPBj5XY8JSIkdn1Fjd9iLIEa7/fiAqY9upkP5TyxlRI5dfMAAhFubnG7modeZJHJaby4yv9TQuSL8GQANA3G+xmyGfgqOX9V+QDhbP6Lyun1uivYYyVA5q0zn9EkfMeguxXA7FwnTtcHSTkC2l/9gQLlegOB5OzvubFsrbjbuf/Toagymab3V2hfdGmnGRKKrjis4FgqqgIx1o+bSrp9+8+carZAcr3znwhg1RPMUogZz0Mrx5Aq8SP90VkOO4PznjzeILsAyUBS6V0sUr0lxOLbNl8o0beu/Q3LdXv9NkQIiCe6CzAjTbMwa0oDibD30EvY4bQmL+/UOp5195aVvbtQD2Lj3Nb7qgX5a3AWR5OxukCvfdpPf0/HxU5BjTSKi0zvTiQhOrqMIj1X+NTziY4P+gqVPVk7WMh+nDwQtFwshAivqEJexVsRnKhMtVB2EZnsxrl7Nsyby8sSn4U4+cGFnnsBl9SfdmERdzPMtv7PtAnZpl7pJq2B8B/Na22InouSkM7Fwz4PNXcmp2+cll1Lsa8lIIfC7ZbtnmvgTDUuav9JByUwotUI6nCP3qgYZ41v4n5OphTSV5KnsvPcdjbnvHvfaiAWowqwadPuVVOS0Lo5g3CHHoTjxAbaBKQlFE1kMT1LsQulw2lJOPExQ/svEgf4qp/4h2WVOQ0xEGQYqPmogOMPndwjxJD9pVhwbw28wbJS0qgd4NK9tKjtXWAHQvEho6y+ciYu/WYneOTnE5j9Iop4k2Qx042peIchEpapKFJCTMTq/iSav/NdXNIp7JrmJ5O07EaBU+mRJZn/u2NArdGVHOf+s92LWMxQ+8LKFUBrTPuLRR+rJGD6Na2qFHpeOsftKuZhIKMAdiuU7DHnSrXM9juyXOidTa4pJT7jTagqJs0Y4hrvStpaAC48Un8bFDB4MmHlT96KXx2x2C0VBy/Hj86jnUQfMRzFbN7LBkePHIFSF0XTELW3kxkHjw1jys0fkWO+rqHQ37CJk8Kfh3+2wniW8HQ7CevImk/Cz1xjh66D4zNl3ol2NB4GnXs5V+1L4UZFYlvpHsMfBIfl4BKNdScsShpA1ImpOvqIEOCuEvCmxlPD89D5dFkcs+Ix6D/T9iO3BbAPMmoX4W0maELxr2GUltOoHPWGOFIjXbdTax4XA91D+HZIXXGXkAeZukqGEGGTdcJXS5U87h0IAQTGagVAnr2Kpd9WggNEo7vSgx+8vjT7OAPifI3EhfTxZ/zGZQVoSo2ajMQ1vTZt357AyZuiFKuIpVxNaLFyCkCOfZOBdub7BALpZDHzvCk7CobF4zTQj85cM5E5gpAGQRVYEcZ5l1/osrZM0/UDTGdCWtr8TqH14JGbavytW2MxamjklMCIrN0ZLC0ewFqgtt18gmn28qdMyRdsMnFzvJZ3VhLrm22OjTW/h0N7J8zZROYrWxtHyq+KygPtdj8QfTwPtufJzyrQ2U4CYN/obHa+HAYza6XURDw/DiwfVrsuqKTi10QxrLK4u18Ttjjz7C4FXIk7BE7xpanqdy87PZyTANKkyN1T9HpGMkXpx1CPGU5tKo8hv2sR9syIDynJLSoMJWWrBobuMEZ36m3Sp6q4Kv1s5lKvwxBnbNsWmiIF/aWRVw07ksdI/zFeE1xDfBucUDSnr5co58rvexcZRHlVAFsS5pkh3GOCeh2pXRW+efFUQYbflkFgXdeNLhi8qfzfGhai6LHh3pKJMmyZgusxOY2y4rCJDvaHPYmpL4ObgazTVaeUC74aJOmQ4Sl2BAF+N8U6PZ/Is16y+LzwhZf061eK0lP01qn07wLn+if6YU0Ut2ZifDFDkJm83AOptMBnI/yuBfrCkOYrD63EUXMol1faTdcp/xrcICS8VkApcKmtHpUw5VIxSPn2reg96hinZwVzwOR5/Ysaa0tzRsfg2Tmj+lwdy5UjCS6KOdI//W/661MP35tAR5oO0oL4NFE6KRz3P/ySTQXjY6kGJuvRA/GKnlSncvMhanr4Q6gEMD6lKDwZPXc+vIqPjJvN8IaN1oYvdRGkPMwNAugmcMtCqMnpYo4Sm0s8xQY6WgmLAfB21pJz2IaZqNU1RYBhfXehMze+QsRSqkigA/mFByHrBwEzNYqsr4Xjkts3XNJj4EJRTJGfxkk2mfP3C00bNRJDqtS3v4jxjqa7NDcSX2CCJsWHwtf/x1XMA4sQ2BYNEzYvh1Ab9PyEvdiafeF0l0HReKeXUe/LRHkZg/0BJ1mriYIDFjQT/k2VIJYgz+YjfuhP6/mvEkaA1wzXOmvyWyCxyRfgH6LpKpr8N49sENAVrMB1c/knHYnKCBrOTRieTf6onec2G1EWFc9p4hEOEQn5PQWWFoEJTUGb68RwDC8a6luTLGPNPCf14VAbgTgtVMBJVHdaiC4sH/ApddF/PG17mm8nsWspkm+X5b2EdS9pL1OOCFPYvkfQyF+rtYnA3fFgG5EsLqu2SbbILV+pJ6yD41auKtEF4V2qKrZOvebC553xviUSVtMkLtMwOUpz0+YJkiRsDKyYc83hAH5to11zKjyaw4V02G+gOOBKJ9+lYdqKVl+lw2fiV1i2/SQjdQorZMQuZFYUkqK7hDGbkTijOx4hANNxulcuF6OEvVYaiZ1caDrt0lKPS92J8b/9No+FapdKDCUYtc5KREGxACk6ZAwzDEk9voZePzb/jz9xGx4rAfqm5QbtsLsJwrv/LBl2PtHFDixfYNgDTxLfENIiOzySGg8ZTt1MfarztXcN3eA0x5o200fet3lAhdQluaHWvrw+sFrvr0HcqL0IwrBlTADeyOBgFihXVZnl+Bz35LfyPk9KW1ybGi1bzpJHQ6YcAX9pb2057E2ebAamq7a9ldnEbRVAT8QNGnDdf0n8GA7pO5IfS1U83LVudKGuqrz+xWGKUi0iIQVFB2ga1KjkkkxqUhMkKzSbJRnSZrNM5RPJi7bZ6LxqczS17wOR/rYVexSa9azGorweQeNt7CgW5xc139Q0GHQkdbPfNSKd2mP4joFBW1ntqqLrbKj4SqO0kEkZO5cQo3Dsb+NRwxMv7Jzl6b9Kkrn/Qg4YvdMCBK/HrkDCBLMEjNXTs+FLnqsBOLLIxcqXa3h2GItlBVu/TponH/QAPFGhibfUeqTmwy3lBV/Friw1wrrHm1MNOndk4XvemmfEaxaUw4A4gHqOKMDPpOUKZSoz9FlXaje56gLtH/Y9v7RXe7+1WHxbKHrgO03tnEiP4ZsTMi/IeZ0zEQc01NcMEsliYzs+E121tnOYsqf3Vkz51N4+8UH08ssG/JUL1/NHldpMOMAyYTrp7584zxHJtLUTn6hCsRp8Qo0lsJWAvbO+HMp4n0xXbFanKKfwjhLPfyFTmXg4eUb8bXFqOlz++A0mu4D305aJ4Y2iY1qKw3hpF4e2NyZNgBPncZ8L+53gGR5E5UKJRDFUpIW526Q1UqzWCAd70j/3j2ZyimQiAvDVF1N9C08L2mf22ZPgk6rjKC1Bp6GCkwhgX+S/YUvBwlhbjTh9gBwDoDRV+RI/cUmntqvZqfyqFXAmPlNQD5IOGvoeFEcQXJ1KCheChmP9kZ8mwP3Qoq+ws2GUq+uFLStMWEnPzS5Ac5dRuUB2g4ARSvtEl+BLYGDNJ1TloQsazT07ZC5PNuwqzNk0tKJ6+z4L0iKuRTAurRJ/oTQd/uAbAlBjLNFNx6TnTt4gFtZzs5dqUhTv4ESPHZvuGzFsmgoRa4MurDJnkvLPZC16jCLTsxyrZoraiocQR4QE8lTTMxWy5o/iV3ENIXKgjuBnOr9Tu9OWgmmGwfTNRe7+t1IS4+zckO4J2jMXDPYRChT4BT9MfV6zu+rjAV0nMqoUfWE6vmhXWmP/meOXDJb3Q8XIksMKE9vwZtzdD3vs9ENHFdEsGuzIv7JkgqyevQFTmaKtkeVh3opjWTYVEz5LjGgQ5MjI04K/jUag17BMDCL9Tder/ldQqBTnyk75Sn6hunqYK5aE8g6BwW0swb/Nx87Yoh6AblYz6zKaFYI8VyRvQKe274BMF+NrAmStdXuQnMgt0kQVaCaUqgVrT0beFCUFAoxgqKi1FsNI3Y8uBs7r4ojETYZP7Dnr0BLZSO37Vwo57Gdu+yvlo4aPaOjLzEoMKcIIgVNOqZjwLtcsTgPSXLfZJSfluymXMPnq1nK6NeEaJC0/YhnIAGh3w5nUZhbkZZV3gc3z4FbFX9S1cI7knUAiL2v58GDILK3uOwLhIPMr/3eum0/SFmtcI8/OMjNcdP2nStqCBisNdn0S9yyOudPGGIwHfZEQjsfwYkLQ3eRB1XTyjWbncy/siPgLZkG0ShK6Zxug5AJQ06ZGA0K7oMLBXiE4ae35rEFTO5DUogTg9Z38mV++00NszHzWpeTXcXff2enExRG+tfRdZ9LlR15GgU7nr601DA1m9+xn0tU/3808utN6wa3QbRJ2Qv/stLgoxr9fhdTZdZjUCqu2ekMPl9eHiP7Ldtlzdyr6+1Qxki9Jn2QXTcVLehjIqZHMG5iIyxpGTolb5WCBE/4pPp2r6UoKOKes7GC+W06Bb2ddYgLEvClIJ8tmbDstjCMGlBdl+FZdgr0zoiGLH5lyaZgdppDt7b6h/JUp2a3/6aG+/9SomD8NJa2GKGkC2Ecfd6ucmeL37pNOvUr6STTJOn234NV8ahw7tga8NWy6qeUov3NiB41O9Q+TCLyoWi02pLu3fCY9pS5lOdgVpcNNiY0L8fRc3NWoCeZkVpzcRWnVe4zFsTMr4bz7XJezX8zZT93yZbkpyuBHUhbLrxhzxMBJscMgJ9Z5c0KNe9Q1bXVpoJKYSxcDZkaRxmlSeeWWcyCuhHrgDFNlFWdvDP8uuwTDDQKT/xIm5WXQxRtPHWLiXRgNqJyGXuUt8TdJH6KpfvqOqzgldkaQXTHqq3HyMGZVSf3WRWeNHB5I3Ai2G3pjIFioVrcz022vLOFVklR9M1bYt0KxlP/QYXYOSDqg9UFHxtHkbci2Z31iJqfdKoqntrzwu4PEo0dsgb1gcezaQvr1m0rlfqSF6Gsr+Qqbz75u0kl+36P4ROW4xGiRLh4wSU+5L3sY0i3Kf0o8+qq1D4ElAexUwhsZ6gwlb2KL8hPHv0c3Hf44BTynnW4VjCJg6cE4C8F+D7BLttxVTS21zAIcVJ6zfAYNCpRB7u07ThfPcRTEIEkkd60uh3O1URDINS3QBIpHB9Bmz1nIlItKRTpblGiQ/w//dfFBIg5h+n22O4KMsXRDpB9AuVsUlIkM9TYsMUUbmt+jU845Vps/63ctNkazky0LP5IxjN+gded+FDvScD9Kh9XU+rNEca3OjOHQIZfDurWQdbiHE7bfvpJcznbP1o/zZE1T3najgWkS+/8F+pKSs9mvFUV93/6ou1vaikNN/hDQJBSCWyZbgBF1SjDxIfH2YF804/b0GaJ10vmZCKjzV7/uyK+l4sZ+EnZSJXYfQPUMNaQbRkDarLjm09dahPOyv4doPa+estEr4NuAmLKFm0ZGC52zlAxxBLW6L9dBtzTwyIF3fzFLW0+2kLMQrxzsrLP0A4+q7GhHtPI7ShsaE4CWhbi8gusQrc6FvwTMS1u6QpnAYFey5ZNitCrbAB3+BaHAp91mCCRINLPiRr8pPyc1VTtjdqcjCnep6+5/4NSzbWMYRDZTXVEBSaE/vGphw1wF8wsMNBKwyTVc+KvmNnyluL2ZvlDXGxLEUt+a6DvOYVhE4skRkD7R2TngTcttqzogY0Dc/y2PS91K06waNOz60hmMgKBk3X00bPajDDJEMdHvMd+o6zqbLnAEUY6NtDoKb377nvgQfTzsZHanvFtbNAOlQOUL535E48KKyKWQaKneT49ulFGp6eF5fw4kN/KmDL4zto2mjWfgyil65xrvN6DnkmbAMoLoB7ZCqeRYvMo4EPPIhmB5h/OQlDVnRr2tqbgIoyJ7x+7fAJB0/gAKTW7yxPVIudON0/t7JPnqp65p2Tg5IthLtzctaZxLlKCPJ+NfgyinrbCO1EYBy68nTvTY0HGTlE+GfprQm4yQfThk1BK/Sg6WkMGCpJ7GHDliKBjyI72sc2cmEBRYF120JP2K+/fP/dzc+AmOxOL2AvobKdlJ+fjmDe6e3ngthlnvCfBLqOz4xXbySB7E1inOrBlltQzYGxWQJhnmUSe1urtXy1POitCtXKAcoD3jI3MhT2ZKQn3y4NZTVin7GeE/Hq5h+VnF+t6MXh0faFxQAASrz3mwuZBWp7/eCTN2J1xOT8x108eAO7s1nN+zAcSzr5CdV4wLNQAelyg++XR8mn3bXdj6dLcs6MBXa6tkEj5vIN0FtiWvR16/uqqIeW6lvaN66fSGv4y+L4LSDXKgH1aYI5r5s61k1q14UbLFsx3nEu+yc+PDYYy/LasOPkzRbO6aOCAk6Iq4P1OGqIjBuIjBjHlKPS3JZJMGnpCeAZMz3qYcAHFoN4n9JFk4pXIxVg61sn7+3nXWyaZuF6k6Ezmrj8fw/+z/MY3ZJKm8tsZhzKGMk3Wx5ZzL3HwaGDchjDJ9/syLxTNOu3D+va7ddM+gkbqSA96aQyYUVNht1ru+8k+cCKrEB7qSSvYLRH5ICzJMDJqkaUNPMq0Xg9esXCpKpWziZN5AAFGvMBjbXaIBxDVbEmzd8712+cMf72jqk5j2FUkA7qfX4weq0gun72WagMr925HeB51fGCVoo2nKIPg6ry4E32cxeybDoH4X7qBsBinvaw4I0I/FM+itVyJg9FS674GljjBlFdWO29gN5WgoOWfzO5v+Zam8p8d+MyPlOhczFNal1Zbo3/OCYCEgzK9lkEPyGY0CDd1AKkm58C3gutQ/kJa3TKRkvHN6P5oavchmanmSVfFAUA3/NMUF+pY5IJz4Cyd6b3x7LDSya/TJWPCjiBLcADqmCr5qrLZ/AyLQB82ZTD2eq4GTURkfZWr8Ylu13+3mnI2CWAzSzqlw3Ry76bSFYGzXl03e5fStqZkgMob5RopouAK4bMQ05Rn/w+OPm/bx+qo8+PfQ5c+Tse5DjXdHZEEIdsoUDU7hrf8HwQWEXj517EzeTAfetEoDQUYKfRGunINULy/APGEl3NcIZx2RMaW7rsyfhq5r13TtOCx/ytA8Rr33edwZo51WJcGWkbiaRhAE+dU+aHxpRu/7fCm/nzN/aI0PruDFsOhmSBITc6XDQr2IOzxwIJEgDM3EI/9x8jbiIWV9OCr5flCY97KTzFxikLwOPKuYcxoq233n1v7CdJth0w61kQswz4AwfatSVUmvVGW25K3dI9xEwSMYzO0Pzk4gTRT7Jcn/rYS3WIwD+IkQ3y5z95bnckq+ht0mcBkVX70GBoFLEHQ9bFsC6hdfZQvOOO01MJ6KrkxTp+sYeRWUbtKc5GAzDJNMQ+a9l7EhV6fiHHlAyxSXI7HoVdlCbdP3qGGs4F6uxBoGFiEv596rTQzVRLznap2cBU6+ECoEvsGcSuHznsNWOo0EX2keNh+ZLqtvAi69vopHcgyZW7/4lWHkmdTzFbyqJ9SpRNAf/0ZpHrDM8p4/ldzRy51OHbIgAY4Oz5bstN/8GhfBwQQPRsU9h9PlFqXNSV1B4lZkPk+GJhWb792sFP0seGeXxsk1ZiNvH+ZSSKCVnnhj98ZJkxVU27HAdRzrsIu//oVBVdgOjqyeipZf2mDhC2YPkQqgjxvoULeQZphd3UR5AzuOksLwpLWHBnuF0n2T5BJ1dDmn70PvnhmDWSk0K3huzir4KXAaZvY6TFWexJtJIkLAG6Fyznzbr0lnYDAnFCPUCMWDYmkMh+2zv11mL21vmgEl/KAbUAn61XmI145IPQg42uMTy7CReu+g6tq4FG3zjqVVH0kr3F9x7xB36L5W6k+y3NelIkDNkqruU+ZrJ+X4BjvU0AId8Vp/QoxaMcMQNQY5tvrlcKbzw80V/rbPtFNYdnNRlV5v2PnG/zlpmi5k+5vhTqXwccwbu1/xastDLgkXuYNUukxsdnD4br9hW6TvAqCj8Qvt5kyfF++5SgOxtoSeCgtmoamWRA7sBaxI7YcaMrvX6OSgqeeFvWRF1rLrxqh8mM/8KUfyAZZE5Ay6Hc0NCqf6XSTyJQQLRoJejItKVPW+cdR/Fwuc78BMCsWBQdOCBgBLC3Bui8+x2iX4k3qAfyi5/BoljFM/ryZJ7mxaktK/DXNu17rjLdttEsrQEd/SgmFWyl8kYKDopSN8CrjKSoupRTtqVPp0igsuTttGFOQhNZsMZ4LEoh0hDaCsVwLoSNJsfcU6BxbkhLe9dh7bUL/8qEDk85E+mWAayLChEColndYCjd+fTg/On2vQRb+MImpfflhgaIkhxA9RUjmiHCurRPI3ntv4EA/Pq2B2cE96P/uChWUWF/9VlEL4HE7jQlpWfEPc268pSYL3Inl1R+3LZyUxZV7mu1RMxaPnofzqb/PSyx1+9pyBAyDN+GAcniqI7KmGXNE45yg7nVX1j+pAo1Q52NCF7fnDLCWsOdFXHXMrHC1YzGPPips6+E6QDatC/TIzZvlhZn1zQ5qveFg2Aju5tHYqwWnC29nE4It7lGRVBxgcQ9DpHMnFy3b1Shtfe4IDqYXe6xjj4WWmgnb+Sb8Bvg7OSBJnz/HUewzB4DmEppWlIkbzUorapHyaqAKXy/HS/aJnn8RDgRlIb4Sb4kQMgR9Pek2rEj5l1Qx3VHvn5BLHo82T1O1oZhSqMy1+DKjw6ArOTlpOclpnhYstucLUxWW4WAVP9lkMRwyrgvtH9EjCioJWVwIlWOYYK4/KRvGrCj/yTfgrGIONAu3kLL/3EkoJQ7xiiTL8N0reXAuo4whItVfmVGsSXxk3gdiS4NLyZ10ObxsZKb25EypSECei+bkzSPrp2yTfKziFJi/kZiJPgeNFdVyaGWQs1Q5Bb45k24N6C+BIFoYBw6ACeFsJCbv9C/OSgl5z81djywk8aUzNy8el0KvahGn+pW/+F2udisGGFMGGWEPFtdDz0/Ac8A1+Kj+WdBMudNSuJ+LOFYlXiLZH3gRfb3EWqj/t69kDuy96sT2ku3TDKwBwut7d7llWeSCjthsGASN6V1kAp7AqnkZqhEaN2Banps6XEU6/xHJi2gYXgxyQsn8ida2U72ysuWmuQOqG373fSejkzXwNwJf+6+wG3DtMRUbYqgNssgh+exA8BpVaKi7JvJBHw7kyWAdGafYWl8NhfgqEtqzV7msmMuHI4pmFMIDe11WgpmNByn0vvK0J4hy3wq7+Zlow3XkxEvBJ6b21j+BajkuIDB0kR/tGbCO8oRgdL6uwOLCCIa52ZyaOAiJhEJPdLkhAEEJuOeQZGXKWK054SDVFgi1oziODa8p2PtX/xncyKw5DywXgkuJtBdZPLxEl7fK3tciGmrFum9SJFWW5obhoPtv1T8HSIlLCjkq3RttTldJXW0rQ3DY9ByYLh7FLs54IF/hR8HxRnJ7DlIOwry+bm3ymmQlTI1jqnbFtZCZWCQWZ+8GVq4BhBoUaYFamgwZPqJAh5/VKMR9W2nR2KNgipZ+JByyfne/vo6xHIr61l27qduSRsU4G0y68/mA9xAgRVNLD6BkXYtIyS48s3fOngjlIfnA254RNgYawMR7xqHepaBA5/RWuCeBr3zntm1hZpNIzfMMIO2Kdd6Muyw3sDqWm3/h826KzQe3PtKibxU8Zq465if4cWiT2SFBd0cnjCakvTOPCfXRUdaMNx+z5uDzV6r1JjZunjBrVn5Qkek9tT6ZP9s1PwwswNmlgEDKuO5Hnzjk1qYezhH5NPpOGP3+ZrABbT+MO6sY9CQzpPg5P4cDDBXgyQ3e1aOQrPt3gZbgmA9qtl7JP/ddFVrQnc6YIMkvnnZ9AZLVBxdixSIne3GIew8rKd1rPCuI1d0OZKjfP0RBfDnafNE015itMt7GUOpiiTfXGFoC96u56mXL8tkQQXj4X6AJemF2lZd03PvrPxhyYo4Fpqz/KraBg73sHAnRhYXEmnbEPeiJe8xt5dYALKLMw7PWChZE3WrnOqshJ8sFsJUB48QBiPKxY1Wuuqbho0c6bNQeHiy17btgKhNcMcDoJ8E9VEVIqG9j/MGfXvQCmeIHwq9Cs+GUo5KmO9fqDmvEBxm1QxhDMgPWuDNToJIs/5WgBhVMuHEKytPcoS5u1PHFUb0xgVw3S5GdPI96Cj3vz4ooWIgPpWlLYcWiiv4YbHYSMPJea7l++vHwsoUb65hkcTpAxQc0v5lrlvUxoWjBz//TDXjoYHjQ3wVG9WRbLLZE5/wfCYIlSdLGO8nAIPbt7vtxQVTvjcop+Tom2T2b8Q+zSajSNqqGI94XR5KVF/8CCzylhyvnzr9JHPSqFWth1wrKUrzjD5St0HBVkIOrqZe/RIEYC6qsEU0L8dAjU9LgltvaJ/5EV9FkaWwpMSs2eUXIZLUQA9ebiCWCuwiHC36BKrJ6pf8Zh8fmLC+o5Y4WNc1EhDoiUkGnpAE3UBvDvNDy0zbIenaMZ0wWI1+CZ6VW41aTP19xPRXYQhZNfOTuIISb1IVjs6R7jOZ2hk17p9TwpVx1x8118d2CfjZXIZtxgYNe3N80oVMB8LrAnWrW+7DH6BP4+zjR0nRCHnyDejFFLXJmDd2QQ4Y9a987+IY+afrGjb6T7MpMExEXyd8m9eHdsDVWMxlzx6O7xWAE77Txl+sJzHvKTBJULySu5I9/7T+qIfJURH5rv5W/JrVI4IZfNnrPBDNR05XQ5jsq9Iu9ufjH+FXH9T7zxIGbbqSbGn+TmfPHbuNUp+p2fFo0ZLOG5/Y54+NBfUxAnGpH/mOoVR25dPEb4OP8eZUTrp0GGz84HjgX9dfgOmnWTY9vFlIbQEEUe5WhwoegEfPTI2RbWA5THzvN4zWCf0DtGAYQ2BoOBS/DYjT8+cQMmRIRniaUOm9biIeoTaOy00GiR75wxa1Gtf6b/SPpLGF0VurHww7IszeFNf3r444yOI+Mcotb5ARMff0ldnpDS0mildUgrCN+pFVmRx4PG4YQvBQssf1QwdYvHbqp/HbsKhQz//N/DmoyMBSwC2K9Bt+IPfRD325lP7ermr/4a7roL7qttWTBBEeIgPUCRexfo7R9S5CTXPRLr1E2WeRY2+u4AK8h68Y4VFof4lTwn7FApFDQuSAsRsdZ+qAUFR50Wj7EWxjh3TJOw00pznStbMiImyIIbONBOuJk+ao5NXGkW1l1DMM3/P0uxQg9sDnQNeA+TszMPteRu2OsNXDfC9+1npqAUN6u+XQASqWwfW73mb3hdwRUqYZ2j3+i6o0eBtVL9nlsSxDQxZSM7Q2LjfyE5sO82lkg1WFLVqWV9V20+m56IrvQv/kLE44SQ9V1dlcleo8PLq03yfLVi+xKYKyOqHtXDxWhlGWkwXSzbGcnz3iu2M6OxYHVN+z03doa5d3qe5gGYyj33211HncR0SUEWao5Clu1Iprnl5SZaAgWwx0STboX0ze9hhjFsW7G1aXsK5ARw+GpgVvEqY2k4gMDqzAg9Mnn54fXIYo+gytdiER2QDXMcshYljy2a3ZMXgxHyMbXiLCxAhlrbSZd2k+KpdjnGeLpxUawZGANa0odcDS2270i7mHxHQhQktmLibQaSP9SpssgA6e/gFm12tfXGC7GGctAO3I7zJDd9Lg2WVEEfWFXelRjuoHPz6PrHhkbhag7mvnD4SrXdER3XH9b4tfBqVICKLk7O7ydOZ9RTtmhVSIcEOR7Fq0K7FsSKfmmld1Pm0vEV4FcWYpNBT4ZhiIHVkQt7fHaAxTdOc61Bx+b9OABnN5Gwsr+CbJaFdX3VpEr3c8Fi7Jt1zPqwT8xrIw2g3Ah2oyLUQuCbTEup4qeLd7N3jd85fgToG/QUAwpRV1pqGCM/K/LrzXGU51ykgRp1rOnEXAXC3+pZoAJBNeN2zc0MCwRsUajAEfF/Bt3BlJMAQK9iDWSrmM81ZJFlcHDMxdJo/PEFTbhEmSbtDSUAv4180+1eiIthdrz+ZxPaNrMf1E44VF8b5TO7FQ+eocjSZJjcBA0SNvfX2t3faKToseRMkwHH20A8l0FRtXW9hQN6p0yUc9g6PZgTF2ebEhfm8K95c5JcQz9WzABfpBY18YbU7CniWyJDOvznIynOHOII3sEmZhRfpHUvR3NANUP8cQ+im9uINtg99HnTOtWzZS4dYhLApfoLhH+39FMJdPtsc2HBUyiLgd94bOSjvt3Gn2JYWlf8rOKjui2gpL/+k/HpjwTwp4x5igh35pfDLx0DAFmbykH5yAzPmVJbYSnoOciT1TP/fKulsJUylhHcabIzb82HNbQM/gCl9nRavKCYw/5J4R1BMc1dNv/QyeqzjCgGoT9Pf29hMyLOsYoh8e6t6JVE9AwPDFu5tfemUJbhLmW4Ur/2ofK1LytQ135WedZBNOHKRS2Y/hCND9s7a0f+ideBnl0wfLpbf+Ye5jPfFDomT0LMzVW9/z5Y4zIl2qNQyl2jJRykCLDgpesDMMf7gCMuI4IJjx9UYSGyM7KT/9o21BZdcqqXXIfK8aK1fIgzrQsWqsYkJQDV87m7GDX9+PH4l3MXkEiSsZmUJMRku1g5QhLLndrWAC0hKZhU9Blv3ylfWd7OMejF42GBS70LYXcvKMbseWBhGONfJMz92c+ZJ+YKlDOqTVrQYA1w/slMEkfLjxFg7zh9lTgoUDtCuim4PNHtsyLMCEHeyKev8uADD+8cV3yJcK3KJ1hedTP15oXoQWbdfDjGIEwimRcPhE7KQOQZDoHLZfiTCjNL+sZpllK2BTnHT/e3O98KCHm+NjRWSttAVvufUgxrgMXrLh0tUxDJPMgrY6yZ8Or+LKONSKTS5/SGTk345ueusGkeAu2cR2zOiqZIUwOoZBMxAmZ8D/X4v620yxeZyN/wQzhOhb0Z0/fDJt296/rT4T4GBY1PVOquSqQf8h4O7XoR0S9I9zvptmRQ8RoeWqe6taq8Nri9OVuoeuHcPSYJDKQjnqL1WgnHC6GcaCKbvtWVJY3msCwpkN36iH/zfinPX1xnFYS4UWqvqFtMZuzW6uGoYhrBpi+lZvheCv5HzXvhkk0HBh05CCVz4Soiy9HD2p1JimZEWoaICwkln2s0yCQLJ4CESjrkhCnz9tUTEmnfaxexwp/4ciOCjppO1NJzVpMKBlVvl7VlvxctdQwbOd2TjRf0kJg20wH2FwA0TvpG1oJYiLjyiCFUYOz86VkTR1ghpo5ffcaxJbkEMXYziF9J0OtZ1s7MqQ980q9OsEBoB7f9RS1d1gf6SDQPf6AYTU4nipszq3+QqkNxJMt5N8e30TYErxink6z+N5QPY67ecX8wSiMI5MiifsAR2pMc6cgu1KOyQbs1X7SCAOYlp4nWPK2GP8ihi+s43LkEs+vqXKg1GuEas3CQCDXK5PLLU2ISLbKce3HHoXtHpwKRKuab+0XQZdc9PPwICV5D7xLRMIbvaRA3UU3cEyzZDYRIbJD2VJ6GPf/2l0qZ0I750QCQXvtiK0b46nuL1xjnxBN121z19GMr/Le2AOrXjZIaBso93XoRYQOY2wOA+bhaV3TJp1xFdx8KpQQZD0ubXCkxgheEn4GS3mXUXwIFneNHoymZE3xLO3ilGndrSI+Ni21l80xDqgz9EnxRhBTJePI3s0xzACiuYYMHKM3NR4iItVQOouagmfNXcfEskpB27Zc8y5pie12GLXKFXElD+E52B6Dq0YST0OccvXL+8259akBvP6HXHgKVbll53y/8RiiCgETjaGw00VWDrdHRZgxT+A3WGXMZuONSV6kB96MH/aewfCmGBw0Jg+Nwx/0veD6mPxVRbn3xW2J7aCxauu6HLEqhjlgfGKojnwRloqB008Jz9I3zaWjlBKr3h6KOgC4d/uCAksBYnQsxFhUBbsFzfS5w0UFjSAgqqDz4aagw4f0f+kpGtkxnNsPnNSqwLRk7w+hWi9wAyL+aFxPm6iPWQT8+gpK0925dt366VHhODOZ//RSg89HMax2YNl0/Q8e0fZlhD1oqS1XZfhjczCoU1hiEDZfnC9yUM9KKoM6N/PWvl5FzOZVezbvNZhCEY1DLnzbNHeReY5kJ8FZzBJj+k1MLcWkqpUjH23tYGtdS8aYlt40DqIG69FIIPsRx9SWNVQFFaZynhlafbRRXcxnOlUDWWbiuQMP/6JQVWdJY1yEGNWV4DdJCOZQCT0q8iIE5pGgOxk3dX7yD80xbM+nRqUVsGtFywLCfsKHIrVT9ao9pv3xI9zDYVSUbBJHwb1LKzRln5HY832rMvuUHwXL1trA2KN6kPNV3UdENVjTZbu+MTVgQjJN9ldZpnWITjttjUMx3Tb6fA9NOpiTUQfK/bSU029XKFVmQv4vZBPlhkU2Zal2oUxpKTpRnfzAS1ioq0AnUnJ+AVX6JJnsVwpcR9haxjlRvD3mdtKarTcXKMMz+F7YKNZkjnqY0pNJdAmKhQJ/O7G6qJ9S5WZkjx7aHW9Epe1WVmn5xx99sm0fdUWEazjhuPZiWTI+v5ZpmtQaQiGLWAenX2xy4Wk4VKWrSefk3oPYn3BGk8f1d7PhZcCwDaALZAk0GhPlZJDS5ZHSLJajI7q1z/u0X9ECoLZw3BS5Y3eoA/kxQMEgSG7eSUc+M88ft98m1rXKQ6l8PWBFhl7wx6rn7VzrOrR/XJuS2sh5/iad81IjGi2o3QTX2DILhZg957r8Emjany0J1L2VWvi9cyXbdsu5MU0rFY3ds1RrgJZA5z1gB9nLO80/jskMceM+s2/JeoYdUFykuW7hUcVWOhrdXs2vrgOGbMNju9/u/sX7M0I3TKRPXLheP6Xi4GQMxfFMNDbEUaOyMQKl9J9GeHkpgsPF/rETlIvoBX7scObtGxCz/oldkOCfa9MU544zQK3gSHxyQeeBfJ7xnzel5RoKgdNZ/C0NF0hCPt66IwOYSM5jBKbR1jC+okoolYJ8Jz/rYEaBCOALfG6KIAqujY/CWr31VvlpMfU9PQXQXoMEwFUCNkGJQdacXeESnP+Nw3pydGhI84pPBhzMS05hJiOK7AFAe66H8dmdxkyt6vpzfj7AeGX92Wjr4JipLxKmOb7JzjEDzu2IyXulk8kxDAI9+h5CG1UIgJLnyh7qm+kLb+QMZ40eEw9Q0xm/OJPJ4M/4nC59GXg4qAAZML2+9dhW6kwM0/xRfegVY7FFJv4vrqVpeRG/JdMnVZZb9jJX5Syq4wtImrQD5D9luVcwzSdoBrnCRq6h90V77JAF8uCB3CnhLHD4letHSUL6uqvLNyO6Ckfjjpc+mxeXuCFk+Rcr5DC6ZGJ++8qhjyDRH68gNaRTLEG9bq1gjD5m7FLujpOk3e+g+kV4WqkeLd5W2Cyf7zykh0aw7gt05jDf80FxujDALlSEyc2TZ57dB1VMf8VNDYcqiSsdshvgY8kMBWThGI6UUAFMSqNnQBzPmuYj1I/ecddAfbqWRSGorr7knAkCDvWvECxXLwga6wCIPyQT+68B7OFIfCTZurP6C9/E+3dc84uvXfJ6CbldYDeDzp5PD4mgk1+q9RTO6vMpNA5E/hmCKmh4O0Tb1KyUiY3KU31e+6Xo+FDO6VI/SLiFWffwGjapATksBmdaDLfE0JjWpP+lV56t1I5w1ty23ef1DjExKCjb9HopHnbU1BdkGSOP9M1lNGqPryVqJquu6Q4NCHtuqno7MtHs3rurbpBc1QAuUFBe/JBnL7drADEpeT0so6A6tSmDJro28cvadlWTH0jtAtJvoa2qUb5CZoWXCUwsralCybed9ZR0xzH+/Uq/nDPZ3N8uSlha0+HdO7eTlVhOoJHcdmxPOB4tq/Bnz7XtlXQdcEAPnypat0W2xV8JhLtV6HcL0AY/BczHBDZXImTA48JVvlO23x2pReSAHoahL5k8FxQ/uxHu3aKprOXPIg2r538PREBRKP4zEWLRx7bHa0Plxhkf1jaHr7h2EnArDOCkjTEkrtKHaK8bRnbmHbPOiX6rvtaMkyfV0/SrJ89JvBUNQLu0VLgBDmwq7QtcH32ymRgcVPjktmFvW3NcRiIx5avhDme4fWgxSe3PCJeceB+GcUTN4HxN9apCSWYKsmoQUOkuLq6tZVIWZZ4+KpykzATtX4jqeV23GMoaEQuSugB24sDznxy8euWtVkjWaBAcCpjOtrn24jR9013mw2RHG/hRtPa6AmM2ngvYkznm1svfJis1SHLRv7vfOjBf6rfd/wFhc2KqZdb6/PHMdEgyj5IUaGMeAzQ53oGwCSZqQJrsmw0Qi8WfaW/wPxqcyyU71SOJJHh3l705mMrgyjnaxL0Jib2/RidnEQu5K7cuIyNa2OeKDrylFDasFc/39w6P1DysgEic86x7uaRnWhMLc16m054uuVzp/CdnhgtHCFtH33cQwfDz96O5CjYSVc0jQLo1L+aRTGFHhhz5HcQUts5Ks/RcT+k6JIH7y69ySHhqTyUDIEQwCSuQNZs+htU5DHmMUZ9/saK+DPpTa5+G49QXanT1LtjCRuuz8rG+4QCy1Nt7xnlDgM15QF1hE0yknVeQDQKQ2P63DQU9F1cCgIGBLEwk1WZAzLqg8MB8HodbtP9JVTeyxEh3SrEPoArelPZgLbKeQn84F3F+qnPKs5MpZ+v5cjHKo5FC3wsRKjqvzAIhWJRDg41Hwa63KST3fI9w6NCVS7zwqgEAyXv45fg5s2HgDp2aWkQbNKWR9xYm3QESasgPFOiGK1cGzIRC+79DQGKoMJsANY/J7tN1/iEZ2Fx8c8UkOija+MszkcXjO7+q/DRwuwhXK+0Sjj713sK6UXFbuYzmKqpgAUATmUsNpvYTPqiYQiu5NKulbev5JsR1XcvCVaJQrFnfGQgdMkmiRLiCYhWpaMggtBxxEOQps8bJNzNk2dGif9tEy6Ly6OP94PgAhOQL42CmssLvb3+4IPhqoSLAHtbrJzusq9fErK0A76ocvgeZqKEXWFtwkdmPCgGcbwa8FLqTyKxMnVmQNuKRUahjkt/Ki5sEMBdq6J44rQNCbpLU0t/FO/jSU58q5jrl4mp3vhvy6rDgh0ridD/ZQOL/mfpiwWDHPvU6cmElCVV2z94PnwUjZaq7RpFatHRuSL5Uh2L23nS1YG0JKdVALLR7KluMwQzWEkj1WyhQDRirsrFoPtA8wji0NFjtY+igZStR04Zux8Mu5Upv65qsW4ymmiBW4DY/KbcA0wOTEY5N2NpTUs7y0fYjtPw3tYpeCSsQ5KJEt0KEANKqlp98+DwzHqEXaNg8dfH0Jlr0uaKX1HYC8sLztJmTBjZBLTQHaaxg2xFJCPtt9feJvZEVNaUvvyzPvPGoa627570zWh6Zy+OQZz6AojQGjpd+t/6xFK9ogbrBut7ATg/ZaKFNPon26bJjMA9uUirP06OdByF+0e9xNOSQ1iRvktnRFvBdLSn+Brkc7E1F9cUli2JldyqK/Cvet+BErjYsHaz4X9jaJ+ryS8exbzapNmuOaGKAKz97skdQe27E7iv0+ao8OZGAST9iXMOb4Q7jZp6KLUbf0A1N0zF6YdcE35cOIfjUhXOmg7wcm1j2RIiEfmXLMnzbrEh/KbhkFbrp8jB6dLLp6rAESVYt/Px/vZr6F0lv7AFGNIU93jDb3JW1dlUKHnTDrZKczNzbvW42UABlsLBmTaftZS0Lr9gj6sNod/Ysk2H5TpdPBRo7tmoJHHK56oK4S5b14gSpb2UlgrZC2LfWvIy6OFjXfcQaUBNh6IB7zX/TzAjL1wgB+WiwemWSpGdardnbltKy09AXsy7AfFtrguRl5N4vPMxI254Ul5fW5oUPgNlx7kzyIwbX+eNM0a+pLwSJMCPmSal88yy553cYAvnzeWRzZcyWsAWuoMtTg1HkKraIQtbLO/SQUyYtcyAI7BNpIJKfxl9rgj5tqfHXbqwAUpM2ZUd2JuHxvdbgdL96peiAH5Y8oQkcmnGo7reyhHIWInVxUoqD1Lkcqo2KM0tMU9DJG6aDhkgGCIw0v7dJqYDtsgsrynKPYAuKEzu1O6L/zIY5hxsA2RBZVkS6iWbwGIU2drVOJ9qHpijezgJ62WC5jSKeJfIuuNdR6A/qbh9jworme+ePbuTsvDrOnK/vEk7JLkpwBeJ9d2jUtv/pW+u5qgCCfUuMrgPtqmHB97q4ea9D82ye/jgxgNasLs2Gq9lCMGQJ+MJZaexouRwS20tTMf/4KBVHt9fbIqeRw4Wye7665JSVpsMOkFgnADJwb/kmnK2BUmTQH/lEFGqEMsSIPJTkdyWwC5icLBmDIzc+bT/FaIjEooMuo7ZlMIfZF+8sKw4B1FXnYMxoGUwlvE4W2hyu0bSoWAqcIclpsCxbJmB8xvTK+HUNnQqwb0GJmRK/+r10g6yGMl3mfIODQkCt+wSKqy3i1hbPhC8hUnxCts5jhBua/DCmwgRhKvkMySsMeWdu+K0IXQCFcT01jCG3eX10Majaf33dR7HCosf2jAJ/eRNaWJFBNL9jHTyPHojWo5z4n67MRlP+7GwoAG2ug/Tjb2/apfHGSMMZlkXwPUbNK+ULVwwaDJskdtN4eLPN4gLlktpdzeJomYXSC4IfW5mnRNdXcnH37JKuMlnSr0R2xm2b3XxMC/NpWA20ZwkaK2ePaX2f84HPoCSv6JQTrLjadr9/N/5WOJuJRWtVuM8f0Ja+dttBd4V+hq0miBCU69g62JquPKUjVL4gydduMdQ1/v76QSURKjZhTtjodzqZ1PXqtzQgxlrEY/TOGPN23FalwojUDawPoB8Dk1R2HphvlOlX1qOcK8eLa1tYxUETr3I+tVRSTbQ2ui1MvD93uBSiWaSCbwAIVsiiIDxUrmx65a8EeOz14NXzbVEcMrbVGdYMdsQVK08VucBz8eSbxpEI+t3wql3uEQv/1PicPJ+ZUb27pCLbfUShZG4ZOPGGFsF1Cnx9mXJP7wacMMY39gx93R+YYaxBRw6dzihFw3XvnbOftmcE5/HCI5TK9jGmEfRYWjbVkF2AT3emmTZR/UOXGh8OZ1Tsg81tVmoJ1mDrhcdbFMEE6LDPmhSC3sgprvfzz5wrCgvpMiNH4sALjwlo1oGpkslnjzjoQlOcbS4ADXqpeaF1xlUwYyz5SjrwpwSEvSbR0pbI93bqBbEwZDPBU/MVlR+psS+y2mJ/+pkQ31ZGwUXy9MwCSqioOOcCfbh61GfU9KrSGi4iqkfaX+nWSS/OkcLn58KB/chm5Csd9AUsG4GKxpCbK7ZxZRwq56jjRUsI0V0XsrWgE8qVJo+iGAAIQAVHI1DHIBFPuaytDoDn5u//vVOieTLDoNmlmtVhBpjIs+kdctzIWLVN4QqGAd/jYj0Wblz1ajp76+sKgVzMOmrRmhTYcA49tfG+uMQ3qi5w65ArYwEc22zn5HY/F85mRg8s9ZW0sfp9aI63UY/pVrJvhODchJZmfcNd5cne5/NZbae9eIpPzJHVEW04uKBGTS7/hzye8/Lm4RpmQUVWKRq14tjLoH81buIEBLXn1GVJGBo7uK1yhE4nxPN6vhmYAqDO7fstCBp6OxJCnbHNMRL3BY32k8gAzm1fv1tlDhpMyUDq9Jc9XnuAShdz+nU4boiVRtDCPSlNnuCmTt8Wqjiy23Q9+mOUpPlP+vnEbHgwK8VDkHB8Dyy83HY5bWTGjQdCe4c5JCo7P3orN7DCnlPwB3Xi31cuzhUE9GVdHSJ7bgCwwTKKBc0HS8fxZ3LShsFDjnNl0v2YA6f6T//68pxSEVfWasP+3D23CvtEGYrq1WdUvLyZx7BA4eqVMp5PBJtuPc685H2g/3WfmGVW9OjflQ4EtIWBxLLEzQtCYl0ODwhwajisEfcunmwdXNkelWKnxLRWGjFfpAZbh+5vSrkHYC2+SOpDxtNSwEkXKCQOBMX4PoNFd12R2U/y5tbpwum79k2szW/LS8/I7oEXqrk2gDrd3yATNfxar1tt5Utcon8YV7+9OigLij//A0kJxvQYfYHyCUzVBE4HwadxCWP6WX3LWJj7tS+sFOAI3ejoevQ9DRsScnjIcnm6Nex1aF6ylHvsnaCPT076aPRVEfh94VkaAY8PjZASY/NKV41W1Oq829+s1e6QWKtMMgnuaJy2uJwgvCDvoCtYtMF+Dlwij5cL4MD3ybE3Uvs3zs/vDFaFj3kLejzpqzROhetMW3AHztaxGLDqjD//V6er4hxk6s8E5gIXwQZUgOT/1yLt3voAuZ/8NxpQuj7kMgc3fDbHLT8mh3uEFJu2uv7K/+4RMWhnwV4t49tMEzkMeBurcGbQmebxTPao8aK/HbPowDGkFMwNEbSMm+Ylt10Wix5rZEfXHikz/lHSmyr7KmDBVkZUmbKQvOQAnsnIuH4J/cRr6JlqELd9eplnz876JRaOQPPP+qeDva+O4e5n0P0CrQKPanPxTnJnWX6Gkuu5nviqwve3K1G+8bCNuxJcSrWZn1OABgayv2JxB3U+gnPKimwIsGmhcdAmaBpJX5c2AcA9VsagOXo3zJhyIVr2Y/2igw49OdrupvrN10aNutYZNQ/AWyhS3bX91jXFBFsUh/My+ZAExvKwceFHCHdZTkejytNPxQFF05hiVDyafxIV9eq4GvAA2rhuIJMxbisz3sX+K/PxfvQ5iwBBqyajknS4rqxpJ30lcb4eN1iYiaEOdknR3AhbBK5Y/KmN8ROf7nhGC92YRHAULn1P3ce5j+/oO3l00OSX5VWhfMJPWc4nLuQSximUzcwdqCYatqNemHIF6KPZs/MSeYxHwV4piWlRNyxWs6m9S86TX0EoTNVQlzV1RXYTx+YN32WKm1GpGyI718qzSpnBx78dK75AGjPS2tOBXXvNgZ4mHUhOqiIDL3cVHplBclJQqhQqHXQuwKL3wbMsEIvvSqOy3TB0zfR1C+B8TftWzSzH4xzQpiRoao4cUgZ86qgKv7Q8Mr6ZlC3eaDnsiWssr2VDFi8phQG4xgYqeJs7wlygZiCM7m9PJOKlNLJv4OxuKlvcoerFhMknh25WGQ4L9A3C12hJg1q7t4C0Ir8EKAD94obeTodcC0wkPABgl/r/WynriuV+dgmoA7gvrrE7ZZXQJzTHyOVYx6XgOiHxnXoBPGCML373fWLxpVzpDy1cEqjoDzZjVfZ+f0cPnYtyJHsQP2XVzBls/2tAdDuqTGP9Bmz7hDcX6Fku2Nj3I5bTiVdR8OqcWJHiolfBq/A5ugPmWyu6AyskWIXgEMvnrFrnxHl6NRKTP1RkjdwfgosII3Y4cnEPsNB+rJZFN3f27hhqTzpYjqLdYmfrzJZ0OFpkW1lMiMAT5gOGooTrOEAzupGSs4LRV0ckAg1ZcmBYgGyJ9UmbFZO1SuZryPJToSrfXDZpJxbBBKTsffagiFbTaaKikV55m892VxRTFoit+ITmcOkZ1i8uy7buzF5WiAWhdG13EvkWaql7Z+O/L5Tah7mviEn7f+YmPGWWCLQEwDZBzCs3Cgg1eXnoOLr4NDitGAV/gtm3t5R7rWFrhOiE2KFZgRE5fgm+WeuenU8NR6grPKjNheEPjgN0tSuThPViXT3Tx6uT/5zalHYVIK16bvcmDMX5lRzN31o00who0mrgnwT/XxPpEU2v/8k25hssiHk4lPRxQfBUBVB4FhAltNPnNmDW8Krep1DCSFihZgqpNZUlL3zkQx7xal8SC7Hxy5mrkITox2oTAo0ra0DyCjZPOrIGHgqMY6BfjuxBtcORtn7QUIUyUM3Nyv9rVNghtjf1zEkCBZrGJ8rLfC6PDvP07DY0KPos2UkH/uqOxggB0ERi6v/GetvPbPHJQpYNr+YYUhlKw5mvU8D/EpqRkTeHYtnSbK0GG1tzRcn1RpYZj6/S5ntKYhlw2GZuz6kcGz8J21k5Xzy9+1IFOAYnz7vOo9mobofT6UKbQkiH2Zw7FJ+gJiTj7viKUngQFxW0R2/L0/taX3c51i5mBSFdZ49bT/Jhldk03Coz2cr6eIDNsepTeFrz8PaIsNgqJNKfHeJ76opqtef5rg9kWMEXVxOFI6TuIXeze6d89SuBoJu4mNqFImsbbDdEEZz7Ae2iKTSrJ+CtlNMd5MmL2yEj/dYv7ry493PWu6BKFxzUuJ0iDiMhTpBSYvn4AU5yXqz/HfF7vd7VGLxHSXyqf3joni0dMRVqxFDOELUa3mT4rRe7PRvTyZeyz1vyXCjtM0K56ENXEGcU59FVOlPocvjBDGfoh4VClOn6FVKDRvYMLmEIXsKQ+GUMz6cMcXGToDdHA9Q03t5Qd9UwgRiJQCA97JpQJqjzjIstaIrUNSn7XlXKOcJ0pH0D9W+GCPLHngD6EUggrA/Mwp04pQckqg/vRBvGqBI56op1HKXyrJ2m2k3wnODuV7IfvOHZN+PWSimDwAoWlWnE2grX6oCvLUyo3fwhCgJYH7ix1Jk1SOCZF8icIt70JArX3e5WIfp7QBVR+nqpXfHzIcHPTAuECn1AwhbOoNu64+qzdwwmKTax+cIIO8USo4e4KNPVSIAHdpMZ9YcGbig/uda4bVan0g7l2oPXnpiXfKr8+DHtr/1wlx8HenxqYe2oUN2sC61xNZj6h0ikXEkQXyyOSwuRmpVduZEWABPjtDPJ+R+O7CaelYW8Qg8eAcmHwJ4hqDplHyJOPxmertPdGQy5+FSFwzbiWysiQqBhXnGMdeXWx8Yxu/J6wIbAE3xgVMVenR7CAymP/ksVLF+ui8Npgn50Vl9CIlz4BpmQqZYDM7XvxmyZVchbeEv1Ab8P/h8ldkqZrx2A5XHn8DhHAATBiPnVBJQ67zIJTx7J0jtkD+LSGd//hadDQeuhRX/3+Eq4vSRwAN2824G06FAOJ/GG++YoduOSxpGxWStS3eLzv9gRGc961K+qPrym6GgX45IugDVD2g5t5+jsHTUlja8LCorAaP1sNiLc2Xox5mvZUGaxslv97RiMyuhcCo90FG524FwiBaUI+veYg6juOzemCU9/sTBN2ucrozp+PLX9fXdjd4MiONIcBf5QiI5DAnOlkat+HA3OCu8oe36OPcFdXGcJhwMnqDBU+EgHQexluh3Mh7xGtPxXxaHUp30+7mUyk6iC4Zp9ZryywD3ai2f8U32HU/i2F7PssF7TMtIswBRS3/nUKYMezP/EpxPsctOLdNa9XomsKKZyVxqSXuxVgLnk0h7ku/ETfTbHf47kTuqA7RqHF/ZzzHS9dCEdXGVl6ig3pkAWn2vWTBqxB3bdvdL9kosyZFRU6P3xlei4DMYWbKd5ubzzEXLpFpBY6yjJDpEVfxwenjDiqOcTK5ZZpKVjZRROLT3FvxSclP8TsjchiH2nC+5gM/0sdjnEosDRQO2pGlVhz4NTSDZHF57J6t3EhmdOkBPrHazRbDbQBaTocoTWZh1rhAi0cqnf+gPZni/esk6qkivqLy9n9GcE7A/pAhIFZQJs+nkoQS4WUuNUfv9DZhGXH4txP3Ja3vgUdOm3Bo5pyiyMuC4X2s/0D1xk0wzENzB3Yne3250zwfDzhcgDJDTyS3LPfGtnsBeU/1jryB99/eoFm7QSG/L0FSrrbs/XjFSyhLJnNQMa1i1Ss8ACOyBYocDieJlUz5vCn21M8bsl0NKEVN89VEJYvnSECCIFEyySIhGxjhsBX3Xr3Mj7+YL0M3H8thvDPlRALT1iefJyxdcuoWn3YaJ7TJPQWgiMLOFZI49f5hfSoCt56CEL7F4ZCZBX3c61AnC/6veg09vBCmutgpiK+xnrXEJZyigNVlLAOT98hjzE0QT/iHHXMgw+yJER4+tx1t9NgcwDnSh9iLBvOJ0+Z7ot99sHq80FBK4QKjdY/4Mzn0sFpbG8+L4FLRjZIOEr7DH+mD7ZGlmfEFERc2lc8kIoSHoPMAuF6VHAgJvhpsKno6c4Ytclv1bKPK/wBg7W1uJTEVPC9n9pPJKr97wVZkRX2soDlr6TS+T8Hxh5z4mqPb5ByWaidbkKwpf5vAC4yYW25KNrq2qwmcexO9jGf1b3doNngTutSz/pJyXRbpl/8pF+0M5E9yt5tQzyaK6yH19p3gArrbyojmUa4TkB8clBU83wkI0domLvXM8lQOZ1DE08mHITf5yii8rjVy9J5WIWZ404eIy585lOvEnhqXYnvz38hGNQTC2oK6wwH2/wbxM/1QEr4bHro0ThvrO1XIGfcex/hrQhOcmXsr5nahiNcISY3tKu4x2kYdmj/9KpGHzeObqxC6MMC0JQygNAzhQr2mtXXkmcdJIVSdxYBpqYleYTIqDyt8KQL7vjGiGT7lKcTfBHtphTdvYQQe4Yr+O9tdXzYWFfvEbXAtjXqJjyeKouK75wNRQTJB+mMZ7CJndiw2qA4UXTSKjLEIbOHEOBv7nVVmnmGYEUwrtopwtpkfjA/XCG2MApm+VT1HChNGfVYAqoOdJp5SKZkTwgFPVzKSq8b5CatUbept4hkLBgyAg3l7Doe8GFX+XdFNUNb1HMu9LW56mUey4nEsgeBKXKRKgfbYKTTDutnFBEK/xiw7fdYKp5MehiZsN/NSdntIBe4MKJ/FAth4JOBuA1lXDZqDz8jyQwJC4asBdunzXt8hkEpFkDbJa4fMmJVA/MjdFG7ao7ZN6FXW3R2sMnr2ap9F8a2e2ZLLDYbyRsJmuhmpZL5uZrryfsZ5INnW0LRlM0KtihWrOLs4S/WWpbIGVvOoxmmCYUJ9yvqJyyxiWz9myTpaGDJJNHyJ8WNII0GB8Knp/gy8UZa3JhD12dNChCG140TtfjGa8cvmPpOfLst5kYXkFwXl3GiQtWuvhWL0ekASU4A3NcMs67XkTYvvuG8pXWgRAqYhqtIJEhgdsr/AgcfIpuaobKo/5fT6k0Xzk3t1kztVXCkalbj+ZsPMjHudqOwwXSwpeCpOGjFxRWKoWR4lBP16rCVHuzylJ44TTB7jLfhqRp1qe/s/f0t0jMlz2Tn3PmvKZ4oW6m/tLQtZGRKNbisyKSkjPzjR3TpAc0qFRnvaRjD47WTD0ZKTc3x10C1265Cy7CCtsjykeLmDQyIFSy6Q4YaHFx9W8kJ/oyrI8rVcoI49pFyAvWTWm20Sdk/4JXmq/zovkQXXqd5K+heEbkyarmKLS/cnMq1myF1aw2VQCFozhySbnYuUWjnqwunPjkLNg4tmP4l9n7N0Gfs4HVUjy/HCY6eWGjLVeafJqzmI8F0OglNLogSMPrbydrKxaSvB1dj6bM6QbmwSOUEkPWcuJ43QAoCoxUZdoMXPkBXmeUPC+n7CubZ3oeDdGE7sRPaxXzLEnEAkrJW3hokjIcHOvbO9mvBQkFolrmoPn/T1ZSMJ61ik5cACQuqQGAAEhO1+51vCffyGBZjnP+FSil/9WUnCBTelTiYaK+E6aql790F2PLeNAA152PIWhOyCPm3ctkNumCWEElFN1ZMBIVhX2lTLtL6LAvuDLlV77iStbH0nNAJK6kIo1w0VTworpit/j7/szqu9hnSFJ+aRPQh9J8om9Y+k2z8iZUVyc/WCrsPE5MlIVXFPX8r3R/BwliZK7HQZQywZC4QouIx5HR9u12oeoqn/Tjc1sVdDOe5Urq76GHAoNsB/LGevAPQQxwlnwZDm8sZCKnxrIK5EmsIQw/k7K0M6KNlUH3yM7U9sxj+/oior1lV9zvhm3OdVD5VF/esWtbM6Im5ecKhNvJiKl9q2vkZ4F8mJH9o4NnTykxpPaA15fHgsJ+npzaO0eXwykaadv4e60RFHqn3NAudjvgotOGeteYtJ0AdHvixokGyPCpRl1TSy9M3aokfsy0zOdTgxRLrUmSXcJIaDPWI9tVuFeLAGfg2h2XfG14HVzQnie4lQv8z0Rz4IW4GNrG/l0Poqpw6khed43P5x49uJvwXyzzL8av8Ia7+1LGqTOiAKXW85kIODQv+36jPLW9avBbAD3LDkkJzodq6b/66lSS8ld1t4qwyJrtw1udurYXjgVOhn27MKt29pB3tcFlbYtUBJ45NMN08he8r8Wy7osT7CEH4earY8DzfzNjbT8SBxwF5sO9xfKDL0q4DetxTInenkR7lJFXWXLNaHLP+h9H0hd4mMd3rEqJflI7xAmC2e7vH85QEb2HhYA6tdP9S63h7A1/JRjHB+mK50ztzJ9jedL55zRKuf2oXOhZo/UphXdwU5xhdnI2dOr/JGIL5Ps7C+yjHlAIan/OqF0aKCpPjgoRMCluaBEK9ppmVvB5KElNxH/kdsNJi6bVHzBHv0z2lSywBImLG25LACxFJkOJzhzwFZUaL+pCbXWIttGo2QOAqcsiwP44QKUFVlxhx/mgBX6luL2VzkRIzTjbl4jQSjcOeLkgwe8vWWE9VJFhbc4E/ZVdSvnA3YgRKKmB9J41Gg9GfhSEaMt/CfuWR7Usnz19Jv6biTsdCDNaCD39TRDa4H+xienc3kdhvTm+/P5gleW8N4gwkXZCLX4BbZGBOJn/5cjOAPsWT54Rm8YBeT6I6XxAGmijEWPTG2k8gCktT+gcIf1fvztihq/o4Pe1T4WbgMoL+VTl8CVh4DAtiVYCbIXIp5AhId3PNx1Ck7qs+6THWNfYYXuBTgf2CvDnwBRtKI7nAKlgtz28sr7a8Uz9zcFZXTD29dp6LKG48MnUGViaQOoY6aWUdkbdbVpydC1TN5lAWFmsLkNL3yFE5LFehZviTlrt9Qv7cN9kYjq2AqiFgYh3pj/7Jfo6aGqmrZIeM9X/BtV6VFIHwpPpP6xx5bzbDfNHCM1VDGbo8ZjEGTfvGgyFkUHzYcBnE371GZm5EknYlzE2FGqWZnS23TY0zBO9xPEQReX+VS9Oi43Qi/0w+oKgcD8IQnCy7+m9AuLDZawAB3Ef1JndXEoCtaFQX2Rtm/4GkdmYzGqtnneuhYJY6BDBwgCamByGVpZ+Zb0JcPjvieYO6BcQborkgSZx+p4F3zxKI3IJQUO3G+yQe18bqcMXWjEoRjmxTzQzT5Q/tvf9UFFvrIT5m/wWsEBHUM+VoFA0hM/oHbkWCvua16IItjYFyWye09H3JjGzHvIDHlI+5QVRc/xmbRhZze4PXg3ytPqYFZGQTCqzBjXVLcZJnhJyBWBd2euoSh63Bgw5DH1dnNjMWKnC2p6gKEiq6DaZLoFkx3WetieisYk4/eEsmdeDWMO16YFFUrfy3t1u2oR+UnpPhF1aVBgmbmlMQNuNUzpROh1kzXu+ffstzOl2VsZGibSeTgXom5kCPNLLZdw9nCa9B+zSpMn4hCVJAY9U6NKFIGK+3ZlpsPY1d4Dq27c5dZ+V6l15lcuWsWXcbBcVcSrjNir5fJiIOBMy2rZjQfxk8KI2w3/44RM90/6xN25HmvLOm4vLika5ArOkbkamqc/tRznzMLFWsBiGlb2d16kg7razzVQ/pUiTN18wdcnrDAzvzeXb5aVhJA3ZbtJyDUPYbkwPzJ7BP9qLz80oEts7ERQ3FXwPVJ8ZCAzuXGw3L3U6BPOCLcljgY6boTb5YzSmUw+in2gdQJKimNttK8bMSi7HY7OygaHTpddp37eaUkZmEqoibmGvOsTWj51izVe1Uqbq61vRBk+mrqMAZKiH4Plh8wV5b3qZS/3BHlCjyqVDsnXbZuQiywc6Pz/VFcuAayV9tx+hueXPmo7Tbc4GxuSw+VdfmGU6Uq+BNq1l3p5g6Om0McZuoBw0ZAF4RuiAAJrPrvgEEGJDithLtz0JQB40NCuKWTcA65OC4CkrPqmdhOX+OXma8P6TdXDj0DuZ1K6Mpj6+bqGQUJHYWjgaFoaLUaJQI9wVGbE9ZuMWBWaRrcP8L9aQkJCgyHngzEzcdNrnQYoBXOgCELPCUfnaZIN82xgYr6f4WaXYOxzAL1kwsueSCckF4VgoRRTq2Oqc+/aMDWqbGzZ+QaoEGco/0ZjAfmYoIqScUnz6UU4HQUKahqMyV64bSF+cxtxQDriLI1zl0yJW/FZaveopW3rc15aOFvHEs5SPC9ytL/I5XypPvEZNEwvCJO/+rc1XHJf8U04vunesPijltVJlVCqC6yAmIxMQTv4sRlUWxqonpM9flB1Jg/AKVqb8lFrl6WZu9EzxOtoQt/MayZXAl/IYVp0oC1bPaGVu+vUfcRYtcHiuVCYHi1c0DGRB9sCyhAy3Jz7g/ZElgVJDT+Vcply2RiLZPkQkwREBuzKkD5rutIbzwWYDJEx2jGByPq7vq7b+f0B5K5qFRktYI29U5vXzbkxLSrF8vBkDQutixzlHjG52fYK+kke9OYUyho7SPXW3r3239kQ67m7PGPWn4XAKNT3K9Jvp96isJ/D8fIrvThFg/EmPvq44LBoW9MfhZHvp4TtCrV1EePYvVhfkIHBiYHz4I0786XA+HKLGnIOnbtoSxLJgGUZo2Y+vvsxPvN5C4QNcPYsOyR8tjXZpE6W2Dfk5zqX/nGydjdn7rvdRrgy3IHajqkndcTZbh++m4lZK9AXmCxpi2IHkEzUbMZC+sDu2gq3wSsKR7T37f8ksJ3HjWTrG0pM10xDnk3TLBoAUWf1Wb7U82VPPcEmzX4EyUH6yV+ZDes/wiHLH+kBhjXT3h0EzrUb5znbnRBELrTuJgE94Z7aNjlT+gxyyz82TB9p4RC/FJF7S075E1tEekqmLEvE5GljBVxi8eY0DVgFYbd6P8g73+GaMY5wd14C6xwAEXKk3T7OpkKwbG9QqB3vrkeALB9hYWK/FXzfnljYdQCg3zfyuk6KGzBSfFgDywhJFDhYc24Cph6Af+3FiyE5gwGnEVVez5b/XhVXTMEzbgcx1CKk6aRZ4ImCvedznBzyV5FXu+LjivIxF5Ly0mGQepf2Az8MooJI8jV9gwENnCpN5Ppj3w0cYHGXQV9lJzNU7qbrPAII0ViGjyHlD9lIyR4D3DUQxQrJrp6JCboU6MYY+MFKB/wsCmIE+KkNVPVXJUltN69RyyhZa/5xYMl8x2+unN9QKVEOpXaWzPo2Lh0rTA8djEsatcosx20TTNOla9A5QucWr0EE8pTeJCltxdpNZ+98UciQb2usJ3fH369Ekjaor8LkA5qPeFzLXT8RwyKuuwhUxPfKzVFBYhrYp19Bepvk6COmig5Fyh8ETsdAuXWWlPGkRgH569Okm+zF0sxrBqYZtwdlebpal6ZK06hB/ktssG6hR2muBguMwIjaTwRoXRZoL/KtpZuw4+KeDnup8h/4C74V0r6DoXI+uSaigrIxYWMO/DuPvl8dC5bh6OtQu8w7TB9jqKLNPLmbFBKDobQRB1ePSDeXj9zEUhSJp+9AoZ6Ln4d4DoASZI5QZxTrpewpkqyx6aheFDQxLaYjioIG+iSloj1j59aXqsh3Yr3jLbORegJul5QTUP6LjrjcVlhnWxbOdXkuauUJy5UzXJAliufhyKir+0n1jUcHIu3j2hd4Hu7NodTtTro56/VGNLf9cHsUiOcsAqC4tHgXZqk037gW4QRckk0f+4MPddr9zDwzrrp+Go8g2Z1clVjIK8BZgcXW/3F8Yc3k6Xx+S9gYHYA8z2qexqi/CD6jgrO60cbepT/BYUtD5sCeiMQgqFkqGZjVc+34+5dTSZndttLtsXd35OGFe3Qpx78SaT2b7vSrtWf+iAM0UYIE86CQO94jpriGlnHZ9DsnZdn7iKVrMIksGpHZ6iNvxDY3kjlU5devE1ncwWTf05F5tmzhBikDTX/46qtnpqHANEQZLU9bmUffg2/nCmvTzBLsyv5QTPXRASCIXNxkTLcsGWCAkyDNdGq4ya0JNb4i3A815uITltNlTxZpmAonK0lOTOqtANA8Lb8llbWcwZ5mWikNS3XoqHYEj3BKQ3kPz94cPVZMGo7Q2ZIc9JPj/s+QIeiktlBk1b4+TFpHcxWEPGmbn6DZFQ87jPmUcDGP0YTBH6LfEJs2CuFmmZjw+RBrYk+Ivqb02RXOk5sRCM4pRd6nnGl9CPRrWbr6vHS3GOUY27jEJLHaCNlHGxY7d1dnnOPD8mJk5OHEOgvwaGI8vbHh/NsVz2w36H66nPdWfZQdnXlGEhnrFQKm3xYJ748zNVQ+Hn4fcD2FmHAaFJZEA/GKS1ayIup4ehCapVOQIqSn76zPAhgYRApGGd63yFXCroLV0m7p9pevC/zkMxirm2QQWNnLY3NSer7zEEQbzJydkKRHbBskCXFUX17gZuHem+EsF377008xf+CXCReRVLfP91IgDdp6T0BEPzM1kxoZfAEF7mTVNGQzL5qbQmWiiAsVO3vTyzQnVJJV+R2x7JXZkqyYcS98lhP7U/eLBVL+2ZhWzdT/97ZD3rNQ5OPkCt9ozrU1Od3Z+9ChBMtqYkpd+XiIQVwl4wr74VcFe+q2rSax1RkIu/Ul3BAojDYRyIMXuQSQqIBn1s+TUUYMgKhYXJJ0AOUOJvlufkR0YwmdAYhmLpqRXwBl+otdZJitxz8FwuvfE0MnglLvBK8nYlLZGT8INakgUTIzNZCF4IEtOYF15saM+BBrj8lF+rJZoE2Naw3SSmu7qcTMlZHEjpdNOV0/AzQR091e3/eHn1VWwb8M3//xo/IoHq83YzYZvh3dqX76ft1TXPDR9lfN7wYyAsNFC/xB+UeMAhFyyn1KbKJ6PpiWtDnBwZh8kt4oi7OnKZZEBIvZ+EfLoZYGQWoffJlo3oAjzMJqg4t645l060PRW88e8EX+mVFTZGJk0sjHDwVIk5lDItjf4Ab/ca0MwA/wpVZmt8bYkAw7m0GJOorAtpCbSiHRvlnq4GurTJx7XuYBxKrKPwEdJ6fNL5GLuadZC+4r+Sa3KLTZgEmLdUEufCyqOkAa9iG5ZbkI6qyxmyTLOPqJcNhlX+uDxVZRuHsIf11T39TmtlpqBJrGDzxqct++qrJ8r1d86FhmtoEnEoqZ8TXbwHbZUQ+FjGK3VjFHfMep+JyMbz9SCrUXB99b2prej9N+ad/lRRByZL7OMD49vF7846o6VWQNugrxk/9y+pfupIbvr3dJwmnnbvaG7wIpsXzTbCPKdGZebJ5qeAR8NOZmmLAAy7QvE46O92Fv6jjvNzV2KfmVl+OAjHQtJn2xbYo5YyPI995sR5qbuTz9Bt4a65htuhHLBuP49K0Y+11m7Szh0j8vAx/EPzNtAJfnBwN73CUeCK81WQXCT8shvFp5UkrcLZ3mwfcJN/MPVVTjLrsUupQHMLMZ8au+SVIk1mMQ6GfZPsUsNPd/lwMB/YGjV/oOKAVvEL3SmU9I5b0jSlqgM1eUL/EHVtZhQx827tjiz3hVvn4jDUSpIcpPETLWzt+DQdtFlTIYnmBRmhOYkQkJXDtGNUNMwyFspx32QQEaD8lq52VcHq02zryDjtTabVFtfAYb8yKziBkH+u4wtxW40n2/kRR7unO0vAG5wnjNby7xap/DJ68o8Q3X4ZNKguBCr6HOQfwWz/67C3pm7LJeqXg3cV45983Oz0Jn+VbHyFurlE8NpVSbD88fKEOH+/xI8JRU8k/9deRsjuUMRjazPZuIYjlIYIRwasYSHyUl2/ITFBI+vzRseOGPJQidVg4bTG121q32FVRXgo2QpAbUK5FOJcaU134bfSHaYnavMtq5/lL83frcxNLwHjRBJoIBJ/jkZhU2w9irY88XtJFsgp7Q1Hf/cOLDlxSt6yYOQGmW7WFmmQ4RZlDsMUDOul/TL/W0jnoyy2pjYdIkZiAkCGzy2VKaC2QTtKysRVjN6C4Fcc1vOl1jure/Cgvd7mEUYTyrNUl5dcX1+WzBsCAF0Lwp6CYzIYIt/mWd3IeZbyJdzNhklN+DXlu+HKXZxe5tcgcz0fIkMdtCm+eULbGSho3b23neO/nDE7WJt5hfzg6C2zmrD2wBjOPWhT/vrU3wzb3vuu2/+ce/ERtpuVVlAdde81YvgEHrQhVkbsUFJRqtRFtXktSV44HmnN5mxWyo419JdETkMQakcLx33emeua6bMe6Bnqcgw7XtBWrjAHO56u1bjRU1m7CY4cLkbQ2n1B3mtbpYU4MnjAvFaQ2tCA4lD8dtyCWwY3f5BUcZpigZqjmKyroDmdfgWe3RmTmzQJnS5RExmmpEY6m9X+wA6VYiw4FelbJoIQu2DQ/aI1xhAY1Ul8i43ruJskoBg0Wtfjo8owW0O6T5YeQV27dTIId25NWKL2nTwjp4lQnQk7stL0rOEMek97P+ZgWeq9NTURXu9wUK3h+tHyKyCTXcL3I0qN2mTSeRV17t/qlo+0H9hkVr7n99/0euVD+n3M93cKWv6evLkt5wOt5TRq/NLTnYFsJq88vrEQnRCySUfGJg5n4cKzMxOCXGdbIKYvTV4YTeqkuWh5Od5COwn8i2M054Bv5aAHjojMlUp6Xa2i9AqycDq0ecOsPT/V6JVuq/jDvnotvSAjqyzZ9aNn3/bVzdC0xcJoIbwns98r1VEfKnose8ZXGeE1dB+4/BxxzN+snwG6d7wLIG9xj7iUU8Zo1yANYxgg5YeVG6zg8k+JVqM24ufolRTFmMdsIgjqX6EoPkwoli2cnoeb9CjhHrzrPVEShWmWP0L4qBnoBAgY4lKzR4pSB0QqCaBy4oTOvHIBFvWR6+XbKGVgSVqbrW2AK5z+dsCyTztRFovZtEcF9I1GgnbDRawCHfF6Zn2slbgslQtFbOqbeLfQO5hH72Sd3coK7iE2RaUdyFtwUUMEkZYr7SucUSduLdrhmiDEVFyLpqXLhRq6yntfgScMZFFHj4qmTQYVyqdn7Rro//uRNFSgqM66IB+KXFVJlX7KbI1QJBWDRMXej79VNYyguKn0uDTm6XuLWMsXc8+kKtLgf1GYXJcOV3swF+iAi5ENNsA9S/ii7VtWoxyNY6rJbX7f5a+6/JeTKqWpz88rReA9O1KENW8YVNIk625lm4fEWIkCwG1F3B/CWx5QUaGC2o4v64qPnJVW37Xgph/qxz4yqgas+kcRe+khlvjKO3kqK0xRj/lFAEV2ZOohGAptxeRa13BZFeVe1OwsBRdBJbX6eVIu47kwfPsTUZ43fZ9TcgAmHtIAqZ/bFN2xGwr6eLmFyXaUlJ/R5/ZGkxVHyxaEZGxN6ohnR89tqf/1IZTmBO1J5PA2/j5ia5SYMcyWbMxZ1MECegZTVLWfySmll59zpKgjNkt8aUwZnfW3NkAcrQZXuXDbFksHKKz4caNFWcziOkCUUJXge0323NjO+7Tr5aS25ER1jSN6mbaJwJcbQjeM9wQx0Ysu8zs2uF9Ifd4wT+R8BPDeU/kgkxIJWMjwcZ4/YWE2rryZORwioY8ITRHIP3shxcZoScG7oneSno3KBXNwmnN2BwIg98+wT1DYATpX9dC4wJSubTvrW1EIrEAjwF/NwgisXsl+tgPTjaf0/pkBPTKX5iqbQodBA1YnIvxX7DUPe7+GjOJZk0GDz7sbg9y8ETfU65jpQJtXjjDyS1t+6yu0z2lEKKsddB28LKmu/l1Cp3urHKqjALzXc21ynEb2SLTzwuZBZ08KWLuIb94SLjbtVJ6iIb5f2gjWgC7zASJUg0Q6Nzx6MCJy03BXFKdWjpL8YjTnR9OoqwhW6rVtOf9lN8ZfMeMGN3cMl8jfqZmdteDGrH83aKVlz7rz1sjm1gw23sEH8h1Q+eaIzSr0s4099rJ6lnWYvrJozE/+oWo9oU9Wyn/G6pM7M9cA2OF2NZ1DzqVCCx7Si+elkPEk+IIuABjOeWMnk81LvlGCWCA2aKWcySqazEc25jiu3mgyszG+XD/UtGU3PjMGoldc/K+2g6MYsF60PcZdY+l201d8eMuGSrz5wYTjKFuN/GLHRXIUJT2fFUVsOTBYnax5mN1DHDXQqDez8cTgFQHMR00YYrOJTiCJXarKihq5oPD+3MBcuQKevhprQFs8gjC0yeO4ke9Q7WESDFAfNPluZ0AjswBHMV3BrsJWOxRjdQkrgsINIdtTAuaSmq3mPmz6/JtyQd+VJVH93zP8X438gyUUfgX8SN7H8+MDDk8CDNvpFkwkfU/bmr3eLMnQnNjTxUzVHpp9N70fVsVlwM4ZeqtJrz2ffenD1tw4rEWk7GYwssACz6q0wMSYgrxykbmyHkVbf52eyCFSJpCquqYPfIiFkUXuNKgezXctKmB4xJeGg5mne0Zy+kP94GGF8NUFCaEpDdsYkQ/R/xiQyGpBjsf/JLA3r3TMmU14o+dEm5cLia5O3qMO7uXDlk/7eYpVPQn1rPOTdhxfV5k/OrTb1jvLqNmLoqs2r+cdU4hGzBVlbTVFKzlmCuyKsZ1M4f4/RGupfhYFN+TJVYHMx3BpPcsxjpBeAWzt2zVU1P2mkb6iTUZBrmI/QnXAE9mG5MRnBjHufv9ioXBcn7tjmTghaSBmRsne4jC4Y178DtKey4gwkBXy+uqcp9cAj/YwhitEYlx6HiXxHZva2FhQ5RblCYE8PGDPcuiZZqu+vZs20u4jgbMMc8EE1oqvoyr7uDeu5/yvFZxezqaINQ4Ft/VesvFXsR4AqV3R69mDv9bj75ZVT/xa0GEjVK8WUhxr3Ofcnv2atO9HyJi3fWmchpIgDh6vnTAtj4SVL05jzwRe4wmpKOudE0Zg1g7T6mu9eCDn8Ojk1R3dObFB1vhHu3IdCEZV0O4x0Dm1IzWgxWDCnmmKvwexQ3nJ8cGcLhlMvineKz5/xtD2V70t303r+nODBDBlqcsvyGZZaQ6yjUTW1uQxvNfoOeGnLhlscXgVDd1TZDXV2wcwOL/T7iztjOjTOYw1uCBJRUFTy/W4VEJxVJV5uixSSkmbUwfWCuALr93scUn+4Gi3W/NSVgjPwdCZ2wUnXZlFLnUePY2yUHWvb5DkBsg4BnsFq42k/iLJBabJ9AF+DjiB6koqFrPy/tdKS7RNrAnwL949CiR+ElVKjMreRV3v0ctLGfIDVxkhYI8gxl16AiCv6WGvsI19SSN93n5NSp4T6j0/L3fLSchW1hwpRAfOSP2oQlPt+KSTH/i0BQPt+18WhSjW7gqv7gxecoK7LFkN/BKaJP7oYeaJy1csA7G3rm29gWsZwqVHyOqn6ZvI7KdZWECPyAxIf9G9i5SZoaOp6mbikx10tdjJqnZ1g58VjQuVXPcjWvZk/2WY2a056Xdasq3CtlgzTkUwD6ADFgyoqsnK2ai0AYLOlL05iUJowmH8dYE2SrEkwo2BYdyz61GawgqY09i8efOjtZxypGqsGN25qzRwUfTSUxLiw42+E+2/qJun7kRTQqNvCr7V/Rug5H/fT0nHbhyQOfhT/3621/bAgvcwKFGfkpi8CfCr3b+Ns+sqTimjAQPBRkWz2XjKwOwpiTSA7b7SeEGZzhvemqURhRae5bjOygpD5caBH7RtBYN3eEKbCccbWp+VUmcDMZIEID9jtfnfZ/8bwiCLufxKejHKwaj7GeMadxmDYgRADybR8/ppXrehRZzz8zFBiGzTJxHoQc5gByn69a6Z30v2n68fjVccLsL2oerkkFLVAtb58TQNQ60VadoeeYvWnIsHoPueigxloH2xdQ9kEWzKIJSmaX1xhxvSy33HPhFq9xInC6L02hv/rds4GQeOuP+9uPMVYSXDT3QizaO02NeM0wMDJJ7gAN4l26CjJKibDK8GKjWSHaPEwJuLiAyz8DRrXfnHCNaz7dP4xy9A1rm4/X5KeHvuNUFEUD/Q6lyV/zzONqwwLbWq5pb816krtEoIYQD7E9kScCANUGeefeEY/PGdLzdWQ/tkWTcFbV1Ienwv0jqc6FD7Rmazmn56vojO0IvbYSEq0/YUfEbWl9nwEKbBn7Van0qlXyT/kuhP5+NJx2+xK6BFc9myMIJpiOK3WFTbphdZyK0O3Gym9YxLj7buUzb63HafTfoIYlAgVpGVMyYTT/xi1H0RAUlh/j0ftbtZolqgqkM8wApcZgxp51WeCYPTSpc7qwKI4kkkkSuABuqBVS0+rH034PAI2LaZFqgxPkNVsesCq5wqXWxlBH1JVoF9CAM0PBPsAdzmTACYVUgYXWrfVBFyNuixkN25HtbWt9jZoGafF8yD052XgsYB5E3T1oCTKh+NDty3K9ujl8SmdHwtDM+nhOsM3hVYNNVFewDWoA2RgxV80NpCkS7Gw/8sd2quUVFLugEvVuCoP0bRrYGW/ovwYZ99k5lDPY22I+wjEP08e0FTOfsyUISOwumSSayV/Ay58Ipa78G75zAWn6DJmJp8ddNxRR5UueQ42M+WxS/pEZfd67+VzAdRsJoJjI+7wfmrMJwpabHb/6/CrSmjCpm9BKbTF3c0xsqOLkJqZxiCx5/jdsskI7JbaVFQ9HejyXCrt0UnGsPE714Wqnv2crwqnTwhQ+GxOW2c89mSswGqYhcuir3Wy2Gy1B//7IKsXFlWnr7SLCeQTvYrE+Fp2bcOVY9xKuDPcrPT6S2Ikh61ha1e30YJIqQBTQGiSGBZDrLyMZIxUq6DVT5D00TFZAFxRjDjbOxpGtKb6YozJz5Dd09/mDv6MlEqUwD2gPjT3FjT66WZrSBVVc9QC0dvfTXF1YtgNGlaVXOezshNcMicB+Pewn+fux5bIQq5d2dmbF9oBd+K+9PUKXMmKxSW85MNOwd59y6rAaUqwYveKxTJpgCO2UNnBdp8hAGTsrtp3VzppShk/VdU58IhMHoGGKdm74s+CcHEp8mkR0Ag16hebI7k/xZ6l4iCZjGgX8wybDi6fCW/tTKXKhbfCU4JqWTEmRSjVHuhjJ4GvsTaNA9MfTkUHkZkTLPhsWYtbNEIAtTKEQ6toB5h5nPC+fzawVqcIjH901HdyBxKkQtXVUrGsLdYd3DHEaVuuO4uvksFXVsf0GY/BnnqR8+fWGkYpzgMNlXoGix3ehPsysWf8pFLWc+mXbDGpI2KfNS8CxB/HWpWOz3PmkTaiU4AD39TtdYtCLGz35bV/kxm4dWBnTHMbNwNs/f9qRmlmfg/IaFK+wO5azIfciVJxbmFlbyQTlojt/zvjddddYm/kjvqLMdvXXvkgE+JvB/oxY4mbL3FtFb1SEl4mmrI0DMEOPkv2pAXYW7EhBEqgc4k6mD8c96hbWioJha7ojvd322sGCWsuZ4fQjhPDtVKanlJdgm/W6pA3w4Sw9h0umzvPJNNWcd6uFME1SmnxF3adc4zq6CbNrNlNglwkFBT5ZrKohH+8Qj6Xd6nFDVPq9TFSXbSG+HOryWqrWoKunEqUsqTM22lfNd3JXhU8LaZq+punafoj4KtEspGK63aO2BXQg5mrYtt82EjuSC2Q9qPEee/9wXGn/NhoSs0AWAJcTKwwmE1a/1lEFC3krYwp3g5yH3wXxOoQd6qOXoUDsOytlwaM5XanQQC2Fi3zRMWMFIC0/FB37HVn4G3CwtNw5cSJXgw+sSA7TGZymOdrBrWw/S5FssHxII85dStiftuNjIbc0O+MWSkYbaL9ycoQBgpPRBE7fEbIO+l3eba7e2YXUarL2XJw9+SHN5QG5bmzSYKH9Mvg4gTb/DTWH9iO9Xel8ZcJtNeU14ovovrP3vRYZY0RzjfAvrsKWRfpqDDUTmxdfMVbXjxIeWEXugz8C97Mj3xWsZCSANVR21m4BQ9d6np1WR4gBT61wLQN4tPPVYSu9LrkRO0Dkq+JualacP2g9uxNgyIPgnduoA3VPlGz281p61Nt1xDi/7x7mkgX0WwtHfcuyeb1Jz7juaMElBd1DVaPr82lg1YGESFulFZ8KvcCUfpGDLlc+fWIblh/6e75bWisd8z5rup7GN12J2fiQhmDTCxNski1OfzB8HXCqUjJ2N1KS9zn9+sY0wcBLoN+qRLCltvhJ2Ibm/PptzcOQVcdC9XAmkX7yziy0679GwXSDtCiyeUfHDqcwgntYGkgu4OVwlqwZMYHgF+XZ/PJrGhtx2CJ/ZwBRq/kGIvUFfzb6fkgT0rtkkMMtsmL69U7oobuuIy+dlmsmltf6YOcrHjbte+CDIc6Mgai5sDhAP5DfO3x0R/q3hu11LBrPjxB6i8qNmqp/FuY8ROMzJRNj7PikpMXOTEgfRwXU9ABrlyj/w6MnyIWsD9kNdY0fSIhmKjEBMxzC0Efi8OHoNkBFN6gX0s2H991rAJGElAL8oX1kRUmWs6+r30+cyQB2o3stdncWXPdDd+nrUU1d+3MtVx7JuBYYHzSzlQcIjPEMSnlJmh0F1pHzEEIBni+59c98vBC1RrkPqW2X/SWsa/CRArCWyVR834hUFMHVLubmKrEHfd6aNkhf6vVtiCQjv4KJO2iwwKyoRbXSzQ9Le51rrVDhEEBV4R6+3y3TgVamPZ9awsQ37I3WdyJ0jHF4cmuZ2BH8T5DXz3JRQrU+MZ9aUNwjZppz20+XA+U4Lhg6OsW1xcKh+Q2Y8CoYErWM+2lxsjouh85qHZdL7sB+V0b90BA/ktPJOC+Ur1VgOAWw12WxosA+DjsV6+Zy+EtWWWcjtau2M5r1fj/UVGlCmwWLrgZrvmrH/jjdAl+arI/i66v9vfDNLaExU34gIdJUyCchqu7jBJDcc3yi2mYIhj6qICAUXK3u0x51BjbnHzvWgu3UjMNtkQOlf57yf61t6gUyj68DEgHKE5s4kzJ36nsWx4KKghEzsZDnA9IdFe2+Z8RX8P4GAkROZzwNRu/mz5F3MBQyj/yBfC57MciWZZ56y0axbzJnTF9iKmx3khAitzp2rY/P6lDRmWB7AqO7z1q2JVXx9dbTmacfPpgcDbkrilFT/0+B39FsEGKhbxcZtPs1rSKHr5Ds6q/oabtDWOiQPbKFxG/dm9GqXiUenCIqsaXo+/tiZxlYSt2/2Yt3uV4hGQ9Q3Z3NBylxAbz2EPiHhyA2bIHC3YO9bOC6JPHXZ/AAlvliD3gbkwXH6doOX+qyRdkBTSCI8Hj81xha0pMSFymyreYk0JSD0dPWQno+dlb/mEKcbHlgCwlKAJCEQXGAmb2JNcpWPrBkmmn2je9eAglAZOkF+0hN3aMQnYR5GnMWqxzNiuV0eSF7a9roWJpX9bdLysnb+SFgKAAuYEvDmx3Blva939v0pzETw0AT9bdxdlvGjh1vxfpAs6K6dZRQ0FxAGiqzcOdNF1NNJdNWaCGXWCBtz0gjqLvBagn8InQV6rwEtNw6GBONgSUQ36a2lRmuuKZMZuit8Fk588GRxX7iQ2o/X1M+u/4FYe6gR4PNTBQujd/sYhaoapWwFV+a7RMiZicE829xowC6fpxeVT6UmTxGOZhxvGeCsTRTZYzzzDzWcP5bkq2zLX5sLCZkK7F+lcZOV+b2OWZt1it4BL+rSEmNZVVknvog4ollTF7IcWk+6Ordr3uSgc+QeISsPa34s/7vK9esIv/AS01pOzOjji94msMrmKr+jXicQQNylJ23W730ruuHNrglBC4QssVz6zwPv5vxejy+UK5G+9i+zt1flRL9/YNT6h8sCkG0uXoGc0GDVPucIP5IBYmCAzyOgiCxIjkRJHZhZF6I9DBMW3WQBoSib1Y3ldjeNCfatlfJC8n+mGj+bG6CslkXjrmAZf9mskAi8glFk9wG+16SKTIFNkz1ksQsG2H81Ln+ZzFVL3fihTUOajulTi30Xe9ynEu+kC5tIlpJBo0iMh/f1j+nKnL9FKT2I8Yn3vqhhppXqDdWW2gLbGBNMtdm0/pgXJhfZvhnW2mYWQ7OlL3X/x6UanXVVpfn48BWsul4tK2xq0ENP15/4wQ1/auHva/IlYAgarEXBUspzp48Of3t7pzaQodXbyQxrokn2JBvP46X/5aRI+JO5YFNmoXIQ/1JikfrhJHNkZJobHafoIQ/XcekBNHeumnpf9uh852+qXnGHX3Scj0FDLHfuaQa+n2Ui+E1RmjkqvF/j9cYRqVnaMNV14ffiS2N3Ws+RZS1DTXLYCx2Om97cwigO975fsTJ9Ql8IAKLlDP4xj6L+JmFR69EMIB9BavrFSayuNJMwVT24AujkjjGnX4yGrXuYR/AjpNl9CQy8YWiWyCF6CQq2qYJo5H11Ma7XFCW5pg1hKI+s61oMXO9o0lKwzl3lUhTTJqQegmm0ywu2fEbAkQ0tJHWk/CuiVHatBw/TCq4L3g+JbJKccshCpmxjmY2Um+5R6EPIa7QOkkF+Sp4K2EQiIjAh0cgdAcA5cc+WKQQ956e0X07lE/zOg3q/ZmxhNzZp1tfgs88ciqEG8Dmb4pyihsmEJQSYh1wdBJVLu+bdAu7AlD/U2da1lqFEz+yloiYhCOxwyEY/kyRPahFNA4EbwGBo2qcs9Szup1st78mUr6pBt7w1EMqdoP4xqVuNLBCQxhfetbyTpZKnxSsQPSxh76AFuM2+aCOnYEicElhPenNIPE5JAjvoCIr0QFeaxOs2u3uAyy9SPwf17fqO5PbPZetk2raOGYg51wVBDr8Wj0HPacWEDq7e6xHOn8evoDWUbZutkA2eLXmiqmSe4sZ098FJDwSqj4/0NTe9ZoqPX/R3E7ufixj9RanY2pyG83pQGq6iWwF2qyj/5Ofl+TyXbvzQ5182s/1550bT5jNI25KxIJlgxkr+UQFtJYD6TceNGrO4oXt9QCUr2lOmoqy1+aWon7dpZNWkiACi1CK8BOMEnvn6CDxbqlq7PiBPXAuPpEV8L0Wlswk6NI8W8u/wV29TNTSe7I6HPemRHwRHxnT/k/3IDQutc788T9pvDk0c8NGFSGgW5xXFY44wlQtJHE3QVgCCr1NpqboYQ3hDizpvy072KvHrSDdeag7bB0ju9bg2h7A1+ZGe81y+XJvoT5IMEhuCfPZK3cjgyL8jg1wB7P26ykcsA5w0ukXkIsVvPKXAoBot5w2kK2ZDxef6kjcCofsc57JsHiMVJ5u/0IIjR/tp0tanbbO+fWv4GgVIDbCoAFGI+SeoqQtSQGASLC9Xn4SHs7lOsYzF8G0XeJ+88xlC2bxRqmHBEACVW4rXVeTYN4OK+YcD/4e0pdjo8DhSt5L9Z9lWnXkXj/16P/kbiamlu98betUl+pFdW322Lkamq0eK7WUnkpihL42FWp8rlisyP0/xiVsVm+lbRlGxW/eOkd5FfSY5a0BhtnO3EQHJJwb+hKjHUc33Zmi/LgUmVTbPuyZ39tA1Ig4lbD8J2ukzXIzDbNzBulU/O5LXVCuArwiSNE3pTAlbPUZoOMMZHmsEi0SI0LSZ7ugiOKac/4B7GSvZXC7GpjkB/aTX0ZSlXlraV437479NwJqovj281QM5kkMxuX7JuN6zMAGmpjpgurL93rRnK0o8rwu+iYvU/9DZrvjvHDOyG2c9inua7bI3yBra9nEsjeDqHK/9AsSAskBK+vk9H635MmTsKvo4HynD4yfV1VQtMi08ESwKH4g6yEOCUUpUzeZhqautmIBLzwYlnFv6qRimeg+2Ef17up7115FMjbk+BA6k1i05sD1e6zfNwzNdY+MiL2GmpIA31scJ3wqMiyGgAJHfBJ3012WX1g+MaU/MrjQsedV726yVgnDBocA016iv42ixmUyTdH0ovlAT8pAlFDTPIjeW1bqnH/uhGybscuaZw/3nqY06XWgDIW+ESs2DTlozFjtz0hadZkt1Bodn9JjkRlTQdI4JWZQbo3eqX6xcSJ30lNN4brG+4qyQWt+YPjTFjhRCYeoj0TcL8ptr54mJvAPdcauRoikERBsCaAzAcSKvJiGGbwnnI1ysF3p+1D0zRZfkuLxinUi0FBMCquBGQkbNesX12dkWMDRt3+E4ZyYRzKwnSlLmDtcsTr7j69n92fOM5zD7fX+bs9BLDDj6JDMCrRgkgLhzU7IEWsE0ZYTYoif0KnpbdM3SNPzwp0Rc5EkEEjMmDK4y2qORl//68WsKF57C4K9rlNJmwtJDblwCQ3myduaFnp16osr+uv9RcCCtXMPuHeZKGlmXh9dmj5XcnYNmKgB+pTErnIybhSBM/v8N01pIyLuwul8zDzt9UwHHsKFcsqszuis7wWf0zbSbdtu142O0QE/fyi1F4eK68Px7o4U2LxHcYyLyEjXKpjnn6xg5XCmicb+ifh5UGn+NkLAdsv/8kXq4wAEoQcQVf4uQXf5eVm5TkYh9Qp/VljPO4yI8czqYw2GEJpSpTWp/9jBapcrGMKhKCFHaiQ7fgL/cjK0jHnxeNkT1oQ72YW+Zi1mqC/A1pSOt7EWU4LwVO1LDcyaMFaI115tsumAx3YEmeiRJ2XYvgjRnBvE2WuHQTvNNX7esbK9sVBqi828mE/0evM/yFkitigVn0/QgoLr5tppyhOHAAN1LgHwKlTGB+ZYMKI8KvDlQf0Ybun7opEdDoo8+tEcGWnVeq+ABc9as7KtbHB/4O4NdX3FP3GKQGW9gRcMZI92wHlGG3BIK3XsNbRvJawm97aVUq+F6fPqOQOQKhqqbIUAFiZRmigKdcCGfI0D2RDPpPyPtpo/nYEFRkOHvmW+jqbugCrfY6cOR2n7GmItBBFJpUTfvOd5E4BlWmvyYt+6WCqFLpiO7KyL0d1IFnWECRl1goraZp7pF7ln4NwKtnNDPSSwF+VZT6I8EzVknrsoI63G6asuIXKZaG8LQw8pbxL9OUg9DYTYEacOPYFXw4N9p1fcp0lPevY0PQg1wifEu2d22h3ZCwvxhQNw6OfA6KYnyEm28lul+2XMdirOlsUjskZTIl5lMSaQvM9TJMGtv2WlmuGln4BvjqsdN0SS5yrhfjP1goNmYjXqs9NsPOKr8zwNrOWTlzcl04Dc9FeW2wdj8W4zV4aydYda2TUC34bc72YH0rvs9jVezRcSA/WRJJ09KgVvsRyzA0YhQwcyM1GicvXALI7/qr18Z9xzTCHDIVZY56iAWADoqT2i1El9kvPG0yZ4W6h43Gy8oCfqqDvtSRV8G05ZkeBYO8nZpGSAguaI6TX2llUOvXGTgeNGQa5Kds98Fw9nslYnwfIajVHcNmsu9cKYNuXRk5kYSrkIH8U0x0emrjI3SncOFTfDPflwIo+wO+jqhtkTx7I7YvQ7F0K9vrFi34Wcvf261fJFcd8KyoYln5EHFhBSttAazCh4xNR+S4b3I2L0Ot7uB5ePakOThjkSNe78xgfE+JsomWZilW93zxOeGyNSuthULMeSM+p+O1dxA+FpE4x78/zGa2Dw9E0KVm1I5ZO86eJ8PSrAqDWw6iofCplI/UYqp3k3D3gDs0HSXkHr2UYAyX2284SSZvvMAQHoww1/lLmw6Ylf3AHpEh/afpaVru2tlGi7E1s75nwDD0GYeynCbH4XZVgpgb3hsotKY5Ltf2v7mP5z0AxWYOpFqVWrydc+szKRiRG1PUEDMFfVBSgMqVdwI0dlrGux+HgZNiynCj1flqaLKVylg61Bqm6mqg1ploB78ocYjmp8+a+AI6F754N1H/wAYlgqfUew+MHvN1u9uTwzYkepqO6p88IgcuTFrD+By5Oxos9l6UUcl1+R9POEQH/fOlN49Vve18D1LfTYDxGRfYRiQKGAxzYW0V1TXRddn3sSKhy+y28xq167N2k3e6NbkgnBR95IHh9BXXu9y65m7kxKdAQK1YPnCBPa+jWFrVSaCC+BhvBKQxqFZ3nW19IuJGqyRv+eywRlFhS94IBu0XSGeTCiGbcMB6lW7G1UTPAp2C7QuXmac5CWOWbkjCcKzmIHmgcyBNE2vJqemeWC7zdzBoWfCf729zZ53VOmFgKtN1nGUtIo9y/T52XA1BpYeAFcqdumO/GKc5NjYBdGJ2QEqIxYlnza8sHl5V3NKZ4BLxgr+BWj9nGgZHRCpt8MCzWaGEjONT8lKb1fA8kxD2qatToAK/uBfeLgYxgGtiP7+Em6xaouibb3j287MX0OkjTAtsJcjhbAAgk9hMMm4IFv37POnfpjbspBNqbknvXkIOFcUzeKSzw6q7Giopb4IENLIkj/O+1fOje677DCl9DFaOjbxYZ6ZvFO4vQX2MXWLp8QNsf88uKwhmHgIUyM9bfssnxNbXZ0clplVq5M2MxNQk7n8yhtrGCGgMrnobnuYwjijS8OnZhm74y4d0TSA99cRjYNRFbWhgFOz8NbCagZLIQ2Gbnc6xdSzqquszcCkwG97M83JzYif2jRgJS1+B1ZqaKNjwM/6XXPjIFw9FZDGa1JN11kcxPDqq9pKrwKJuR2QYNGSKpv5/3vewXqDUWmLO1GE45v0Djuq31JgSM9vV0XNkStk2oLzH+l8RPaxYnMQLQ2RcRl939FwIf056d+0Cf+KnRGIXSQbv9MEBpBQ3KX8GszcPMUoUR9HppkCT6pgoQ3emdplylk0XHUwZj4raWptQyJ3MWe7u+NEu+jhvYfanCrvg1ejF0JXE4vpI9I07SqQt+/Jzh8dw3NqT5vCt2SpBWTa+JfQQEHKaYt7CF/maqy1UYTqogYSbGIjiG8DVEZgvppBkYuHRATEpietkTvntE626HebHzQlB9lkPtLIJYFwZb/fZBQuHD5U7YAWcFYVU10wO/6LrM5748Fpn503LbpJESPoF/gRGPGeNgFc/b+IhptA4sMcDqaaTVNcnNpmP2NTA/Rk4BCk7TggljFupSUW0BMYyDZ2CJFFF4fMO9lWt+4ES2BgcjYuuIQg00XZQ79jpA6uzFfPORO52El8zWS7gnCwBtrE4AnNtW/9AF6CRuRVZN9osWG49UxU4qxkg3Sue8Ni0MEdtUkPqV/OU4K3q5bnEJiQCWzFCnWpFv/Dj7oBhx2PHYvd+y+NVmJyVoUJarFdszcTwPpm9W+Wwn0CQFXV0YCfNcFb1KaQ75CsI+sH8RsDYxKsQ9zpZKebus1FxePe2DgztdC0bbH+CSntKU5F/X4xf0G8Tu9lsaWifKRwJM9lPdgBU9wLZWJ2sTc3XOYw8rhmo3EeazzP/HnVBqgltolwzhmQylgByvpfqJcAtM+DQeouvxghsI/6p7LAlXa73WvzJIJLdRYqkikW0n4kUtTaCcgYZsqt0vOSog3CeYZPoxAOT3MuzZw4oh6L0CxgtVztmsHy1UwhKiwmiBC0irlDihQgga0SNHC3/sXpM6MXl+3sz9jy6Alw4wT6TjxkbM9iI9okeootqzVq8JTM4GPFXjuuA4B0T5UvVunFU/rtAwByXpe5Sr3CO3Q1Uymlg3eUWT8dlzn/uGZU4jTMWdXd1R/HXnnGYEjSri5CrePoH+6DGZTOhAIZ+sOB8UC+iOICoOeATFh2co7NOFEL8YHSYc3Zjj8IYyUXH3t3IksdH7Kj74Z+0xAl7XZJikEwdPWUDYFtDZqoDpUjTPypA2dGDQqXt/yd3XEMM26aBfgErOSki7x8ptqv2gLlXGorailZW5vbEa4u9JKHjNiWM89HCWm1Wqu9jzjKiOodvEx4IcTPjjexw7/MPuOvIhtQ+mCiggkoAHcioxdfzM9KKnA9As8FuVYYRwZcXBR2gfRNvTAWQNjhm2UYKkuZkDIGcKUkAItg0WYQtu6WOKbRwVQldxpk4VSiK6pOj4ekUtPX4DFSlaO2nIC8LtVPFYQGSY1uaD4FtO9RD2VTGE0/pjHlUhZs+eTaeNokaZfrvyVBYfV5K4CF2kkTZLVBq6vc7AthJO7mvEGGV7Yf/CWu2kDFsP5yXMmfVfzqVbfPqhTLbc4LGXPyqggI8VSbv/IOJKi7ByQIiZOHocwvQmJOoKM8gJZVbbseHiJaMkv0pf0AQ7/3l/4TxFt80AaRKJYJX5CpPPi0FWKeiDDmx7KI8JQq21m8LCSiDowgxZ4igXrGEyWoV2Cmv5GJtn6/y6iv4YZBmCldMKpBAI+s0COQpU659ftAw4fp62L5pApEQ4FLKE9jJFSoPXHqMqaQKdkT6+DhPykXOGBXZ03fwL1UNYHTMTGINCMXXN6EDCFomBdb/XZ3cG+IHXcXPDK3uUq1varQv8LQ7/4EuJRLk9b/trrBGLpFdluhqEM/Zq4CNnhTNOviM2BeX/VrtrA/uhZAtBbYwoatSWvLTVYSsRiYsTTWk4URN5qubxBwqNCOBQ42LxCWz2UzCrlcxqNLAeYr0A0KVXQC0347PbDJXVI9EVcTizbZzz5z5n4j859+FyAh5eVeRZQK6CwIxJhYtuUaAHd+6eSsP2ZeUTU9M68D6GTzsJt+xmp1xURFJLA4qONNBpCGQ3mgVnj2hbHH4qL8M+vjkMm0guZ4dngPkm7VyrnPDmdy44eH51qZn/hXjyEoux11z566q22jfzZfmMYP5MIsdoRGJpnWJiAsXeAvAER7sBmHk8W0OHIQB63Q/OVRYxqPUexlIudoVhY7O7TEjI6rL/CDBLTGmCCE7k5PF4ltfV1q+kOt/kttGFuv5xiZTqTPY6ZuzQ5vk+mw+IpW/e5xtQOdt6UiXTnTh4QR3AEMFzRqRG/yCPqnui8k+pTsMkdt4Srh76RGEi5aodC9Oq85TUXkID+UmFXhl/w002CETUWv+8AHzwRTN3C+WkdgJH04WvX04Eqf01+ey5DyYYexDI76GsRNtxYeCpSQMZI73E7+C+xBXMqJ0FeRhT5fPHYuI9+HYUlTTJEaj0QNYf9R35nLRYuEFc4XSi1LpgrhJXC8faVd5z4b0pv23nwordPa9hWZfCWBZAoNX8mafz8hnh0US0aKVjrq16FOM3/TbGN90mFjpy10MnjlpCVvmI37Dw7IoY8KMRnyT2ROCHq/C9aXQ0X+oz6G99C0E8j5nRq+RtH/uJA79DAsrB85wQPJ6Z+wohWYMvnhwHCOWqObdH9jqj6z4vtOPI/hmwgZH8VgjVaDBw6pPBY3alA685ObqnNhDho1y/jezEIrTytwHglg9inxhy5ZA2EkwIv07zsaqWXdyCBmSHkL4TNfO5dH0+BYdYriWleovTj3RFgFpVoDXX/t1ZsEpDcibgYnrqNJhACST+iNCN5tsCf58R8PZmnVeJ5JZqs6pc6YALliJTaz/FaUPJpyhImbKis97oU2f2fs8QW+dV7zweGsLnCyjs+Xc39B2Rf3dZKTTQQOkBggxJGYpthjxIWI4WsWsHC6AakLqOzEm9OT5x1TDPW6ca1WFMGM/X1rxfAUJ8mCag6b0GFZJKoLvDkaEySgcBeVSuHAeDQ0vGyc5V/GPHIz5tvENQgxCd6H1mNJcPQd9lZ5+vvZyAwYvdW7CzAjTbPtmlKvtmxuT5H26n84XkxH8I9qCXv9J3JxiYJLGwKVVxM5r+2hjB3cdXQUz+ftyOG0oUFkw9i3iU9n8Zy4ONsqPuX4tdQFqLi1Z6wvtkjT3Rlf1q8JNjy2BDvu+XAotxtEuQ8lYc8tMnxpR9dtaLdTINyHqykwnv4cVKB1hOPD82NfY14wLk1yq39ZwKHz1o66o02vbuiB8f6lbB64hiJCEDJ6Y06BRAoEyCUJUw1OZobqTS4rGkLDI2rTHYurCuwIbomniIPRwNrDr3oKi81lgts8MS4oM+LrpbBQ3ODNICu7h+sPxtRtf5DX0ZyfjEgE5PCNrkv1MGmn87VkkMHTAt3iS8Iya+NTgKD1P+2PtSMDlX/N8rxHvsudIt6fpUBU/Qpu9oBOmuNM+wSkx0GgafORdazFdxqxjnx047VjsWEDgQirx6vaU6l8jim1UJczv4JGbwO0EvsFnpLWcosLq8cK48MO61dL0TnWPhME5vuQ5TQEEvgfJDiEynvuD4WT79/jXblSxf50Lk3pTUejmNCWcWAG7hu0qfFXyi/3luLY9GIG4KsATf+tiYdDl2Xw39VuanOP7j5EH/KdWtSlubmyvivL8CLxRxFVPhSKnEZoc48JhgMUd/lZhBdd+IL40YumrNjV8N+C+u2bpH8/ZpgE9BULbdhAFCHriMBBDFuVKxNWJg9X+GeIAhvDF8g6KJgbcJyQxWQzFt20qvrTXyAmiy06LvrDF94M2anP8HY0dERSKm8nEdjxqqg51nK/d8eXoRicMMyezM3eod2Y/kMzDKrC73aUU0W0PD4vE4zPRG0ZopomZseDFgqqu9a1L9kOdW//qdShLa5yvC3N+sElcT3q3X8/4Et5VUGrq+o8XdWyHVS6yaeXyu1pSeMBLikNCRx+W1h5ARUwBaCRLyqHTj3KXs/fMw76Syf1C+G+ZzpDuM4hwOSwDY/TB9PxtdHPSiF0KVWUlRf86LrlBF44NfZ6NSABFVmmaDtLGLSohRrrJwPhGm4YpFjxF2TpN+DfSToSTVqM7uJ/ASYsl24vfUPGO4754xRiniRI4Q6qfMRmPiZ64hR4xLOrE930ZcnUFsPPkUBXRzDy0je4JIm/W0zaLGB65cwl96zfwsa+T5t7YtfbHOePZ9PTbt8MzzjiUVc0lo6blyo+vP42vHAoTeFIYJRUzHZUqMVlMw9UmxGtmZ/PLtB8FYr2bZXHpAsKFSPmseV2MA0O2WPKr9/07672qyOFK1OlCdVH8C9vGiFZL92ZS5/pO4USMjVWehqCG9xQcSnui8Whhp5gx93fx35zK5M5kb4TDsk5GCtHBQudMX54iVLg3Acp7aIjjwFu/Jb00J16iWnB01shtIIGkGsx3sKQX1FMSQOe7/st2fk8EICyYiRtl6F0GByhKRtrxbChmXCmzgcJAFHCI7aqhexo3p9flhuaLhuf95MkAegLsdu820QCNGGMEWtiux/QdGs0yHO8dLCRmkDnTW+211NwyPWVGz2Zs21x2yA8Up46Y2GR1+pSZ2NhT9pE/akpOwdPgyamkN67hCkaD8upPmaHyI3xTOskdnhkWA59HqLA7ziGBA5XrOS5SzDSVPiXHuqmawBSjLjYoDxQX9bo4MLzuPaIgbrkdVm2AnJugusv1c0dFwjYfN1H2xy4vlAB6e6t1YW8CzN2o9vcRB2nf/UHfarnDfYX6u0QzRSLQUnLLiVhpaiSmBDI2nWOh2GgQsriB+kJhjdegytszpu9aZC1qUgBsBARTfopoJY+QPUsm1qam6fF+oMWjqQsL1TVXROhSeUTJpJCGV3zPBn4YkYwLvxvfA8qbM2DOSWdPiJaI3esnQnltxf0uyigyJYQ2TE3/TZGoh4Kzqjmys+7YS2KnFnXlKlcXJHxAYAvudThOXDuQIHWYu+359SiQ5hRxCdrtQNb1g/X1ADTw0OcG5kiy/WYnI90JRNoGbKDCRVQSvd5qVRkcEGA0qJhyVB2U/fbElwIPjiK1J18B5/KzbN6BsTYUaZ4EOHKBXMEtv0d6PeI6J8uXVraMjuFmgTm9NSVTS5dbj2qzwwqFLD5C1IxZLcYXdxowLdqKz0ZWj5ToAjb8xG/f9X+mqP/jbD4ePC5Ss8LbeLds6CbPwtsqvT1ayrbxg5GxO65Sq4LwNr9twCZnuFzXVQblVPBhVuyz4qdkNyPKWBAJ/JfI93Z2HKV8vrSovv03w5AR1BsPP/Skg9CWjRwUX9/TrY3yeq7OBBX+8YWroP9hsVTuyGkNlDkyHFm0YWXbgf5P96rgoE0fOiNAfLvrWiNBxzm2T43QXtSabbGd8FxF6F9l9H1ZqQdSE0h9lFMlVkt00zC7h5k+F4SqbCvz3O/WeS9DF2s601QEX+ENK0YYO0ZqiUTX3xtZiPSxroLX7TrpfqJmMXuxEPfPRuU2rLqbsEe7WDhSLmY0625ON71jKCCesbZbl19NRkvJ+4NgWlpHwddttEHXC/wjjhRtOKwZIv1p7dPiBFkJFIJj+kqk7K6P/gNtqe4JK793wqdbdrVk94d5ozC5UgC2T+guziKR31bwG9RzqCpVJwk2jarZdBuA+VJ6MP3kwlYFOCE/0csWORWnMK473qAGI3KuT1iJ1Eaw4P9zm74jpJNUWt3T9Up7qQHeXeTLkGDqGOyKSjvKgcG5GimBnjAKxKfA/w44abQOM/X7X0vXmqi9b2pWE2L+L4guWHiGgyfS/U6C3Bfh3wEAyHZ7GgLTVTRtwyfFBYQmnnskStPHEz7LjeZH4jxOKd+lFg6LdGorcS8W+ZV/z7WY4Pp2rxe9C47Ig3tSeZVqiVrYpUpDfCEdzA1g7oFYgaEPrCiJI67ZKyC4/KLQ8c7+th2EEe7Lom6d9/Isa93PKhLybw/bYHBgM07JagI7GsI1u1Ovqr2kmquok22NHa4Pp0iO94NQHWaYo5poGP5M1jWJv0WHid07KPIWFWk56uArpWMQDJ6Srwq9dyzOWVTA7TGDV0xf9icD+JlMiI0gh3vmYOTZNhGbOX0UEMam0vi8YRhHSizCmuZDPqntTam3QbQJWpupC9rYgIBJw7BH+G4TwN6uwD/Oung3N6lLSSvmCchZnTcmajxWoljDlsCztVwZcvWDkkJzqhgDVPrZ3rs/XYyZEVb/TOTNFr3pLC3hMZ+T2oFGPgQypRQygv4/D44ZFVsvEqcePT7mzQTGRFUnJG4Ic5JzbdeAWg3ywo4G77zagwe88ZT6qQId1lQFDfQjWBZ+wFAiFofvhQlVYNTdwewNrQQdfTbOxsP33dS1FTY3I8bl1sogKQP0A+2JolqH1qIDDjjOnWT04tRu/KbsPJnl0sW2fL/sVQQuvIPSf7yhz0fu6suFnmP2mosY1cQOTvPhJ2Dmmi5U9n1zEhzTSDeVmQURVp4dZQVkaTYEO4QBg51+UogasHYekiFxtom8trYkZkFEVXYYpfhq2lzdzLWahn8IBw8OrLGgx7QickTiHrWnvaY7S83QkCQl9W+9mxaZIm8QLYath5OuzLcWrGUF+WWN2PmEw3+5HwNWrnlIa2iHiMCEdMWL7qilidQRq6jWesZI4dv0yEo1n0zmRi8GgRPTaBFfnZIsMwCCdtS4nzUmU8Or1emYHuKQdce/E/Q++pYmxo8Ft0Uj0gJs5WzP1AOnRwcYP2qiXYNZr3dSgCwU/Ai96y89DnMDmnGN/h0hP1kztHuiMQw48U3hyowUVwiJiWFnLs6tVO34ZjiUMU+smD4UWgf4svy9wSCAGPC34FidcedQOOwZhJmj1NPjgu0NUwOqTM48h0uyaHLc+0OpH7tyT4ew8dKs+fVkxcu3RNvnL64LvzHjIhlImEOPKLx7dYEi0cUQzHY3gWkA5L6e961YvXgYkEPfIavSd3pnAQBic8sHgZ+GRTzC4+MO4RXMFEfMKQ0qJ+awWHs8R22FBwKYbClDAIMO1T31MpBOaqsXWE0dSCH54ji1ipCCNUXCQqYeyT7j1we+LuzVo5hCE8ML+scxXBGui5dFACrCqTSToamh05o/HPTFdRig/9Q3umWQmufpLUYOlTO2UpWEVMz4HDmiLrQ5o9eUFzXREAjIGQCI4E/pMMMGlqlN1aL4Rq1s+qPowBM+DAViqWGaZiAqt0Qj3gc49defxMqD6u/eNPMqA6czMdyjs7fdR6ZnE9vwO4CdeMGolIauWFYQWT8BtocivpNjDcYyzeHfxkHwTNvXJsYv0BCPZarUlo566dr6H1J4Bcw+AdGmHZe7OzPL3rMG8oo02dKUXF4a62HG4K4zabRQIdr92Pkt0cKeMYMpsvlHCKMBDeRxUoxYflt736FZlD7et9EuDZcA1FNFv+N0addXjaR7tAGlAvz7Ccp8kQDFxiJxrrv2NJwHhjKB7BZRFGDuHqi5onGyJmwSCYMtLDYXLp6gbe5cqwgMOgB1qDedlI2crV7cCsf6zJx4YYNkKW42h1jkGur2K7BvnhfeuCkhz/bmMEh9XEJW5q0bpKDU5kiaXnj4jbtmuRuDHDkTgDY5ZEKduWHP6bCLq+t+A+8IcbwSS9bnGsMHyO8I/y2S/jOYzI9BooBrRRFfoJPZrYzMFgZMzWQecQMX5SHXNfmJPzJBK6U4/qZiWx0kZkj9HgDD5L2eCz1/ULWPnx1oNqKmGluQRqrYW0H0zilflDJOpD9llmzbwV6RIrZ4q+ZtZRK87OGjqzpYkiKqgS5K0/QUyEsDC+S7N7fboLofbtksg0gxLqz9hG5hY37iTD3fHKQu765axrGUs6RKPPJnRaguO5P5S/PQ+j2GkZhqxhNZxn50+6OosyQBZ2aiDWePzlLsthbTG706quORBDo1MAYFoYUcfNEEpS9uRLZTl/4Bm9CQOrZYw3X0Lr0s0B+5ASXFRE0oA4WDOhYGFjkMVqLS5yS3ig98EPTvmGATYYxnSVCGVuMSA7fCDBO9PtO09zIM2QWUMDLP62UDIzixdjCs/cG6gOiI1x+TYEh4/96sz4oKdk1Yjqg1NthiBxknsgZi4JD/gwGCLOazLWM7ax0zTAnJ+UsyEXr5+VKXgKmAGVHmrlXNT95zH/HWNOr3GleE7gngdO+ZtfSw/nhJmuCrSB+mV6mM481t5S4pfhEatlKHUUF5jeXYrduwhX1iUbIsnQmvmXSJjL6Mn5zVhfCi5SNNcoszD3k2/uOjlkLfHhAMLNcVr0G0P+evdZuQ7t85SEV7mqWbdl8TulrI8mhiOdF9hmn539wMNLQatkxd4L4QcXwRvMA47Z3pYALmRK3SHu6pq1Rr1dhY+FWL5ShUB7mtP17OYP34hi5Ro2cwDoKeFCcuqWKgk6qVl3pBPlu5bugTDyqgvMDBS6dc/DDY+gqsmIOUaHhUp3obGdFDa9FZFS6XRL+IAod1kw3GFp+9/1gVrju4fMaLktvWyeS8IZqC/nMRjK5L3MH99ss3ht1AvuxbNWHP09mbnp/1wk+Hwh1AEXSjDKiOHmfg2/9Mlxs4xABabUTxTcx0s1JRZIixHPF2MFs08L5Vn78+GLbKkqAMGSy13GIAdkapYgjFbjWHZtqJzLhf/ZGc70t6DUGcp15Y4ja+n4sbJHdNka+fHwkfPlhLBB2BDOeyToE2wMcqc7SQYWfNNircD82tS+D73rForOAvT8GyVfQ8h0oyWHw+IQ57ULIDFFbph3jfwpQvmg68z7KVAL6LjzqT2AohRhRc3ZzoutSGnopi9euDdEnoe4sIRvX52Mt/Ku+Oglq9SKj8MH1hfyWBEOqd8znWFRAEtR6fqNbhw0G4tQm0jvLC/mlX+B7NX1gxs65T8bVMAhKq6Bc3VX/lfxJYrQ7yiUDRfJJLQPA9KoBE+ZtQJ5HVGMgoGrVFv18YS+FEtFgnNxVjRc+2Px3CsBRF7NMF0mwyVwVeNLRpbvkPCgK6743sczInWBf+p1Nh7ezaS2aJPAcK/Kjf319V7Dth+LhHmh6KWrxMqp9v+/SOASh8uuZftOrHLoxP12V/RLNPpTpOQLeLq0r4JM8tX31H0sCRZtP3njEwzBzwwwA9uuTaeClyWsU1lA067szkduIdmZEeUB9XcEIUAq8LlQlFf6MlL1+HcoTggcPpjk0pjtY5VqcM9DN2tyTftwR4gqM5oO7fzrMXcBHUmq1lHPu3wcDXlK+GiLtoMIkYMfSY23qTeeCbtFhcAT999VuyWSjIhgc88GY/Nr3TmuwJIEEInccvL2frkv6BgByv01Gke1KacIADw1CTHKNF4Qwb3k7USq3KluycJ7bYs7xpU/dACMrS3owtcJdhnGVu3iIGN2RFLUacr3uyfIKI7EFEj7+rlprGCSL8j3QtW8YuLr22zUW8U01pA6llPCScGrCBqXJwQDs1O3KEU/aZw+BjyTkO6UEsGlhXxorNAMmzSke54WD4fKPjDJ8TZNo/2ca2DpqafvUUjcdAuXT0O3SRLaQgR1zXW6CTCOsut1luDZIb+IxhFucoNogr5eESAFENw8ccm6SaeIcm4PTu3WFJJI1TdjwJtbZIt93C/y2Yzl70TRaow3CpKtvTqMka6sgTMnmfN3omlcIQT00nwVl99GDY4ZZ9vQwjtEOlj8HoRRU+THlSUxjVh/bti+dVfvN/2SEeBBUaRjFvoWXnQBHqnMqgmDAnDMzZnIuluKz6clLm05L7BM8X52I/n7Of9TcRYxVjq3YULwM7nCgsW4Z3EDCfB3o8c6MFhzq/xXGbOxgqhaGhJDuImMBjOHD1IsgyPPkU54NLqMdORWPbgVL0x76r/MrPsB8qX4Ke4wCDleiijURYa6n4Tjw1TZudr27TT6G7upAVWoZqpKgvRvLAqYP4lM+mOAObbB6CWUn73IPgM0+7ll7xExS+kCwP8o9xQqgKX1UoXd0Tcyl6PD6vm0145uJgTOk90Qotu2+a/6ydQtduiu7fqBfjVMpoZwYxisH0h42PnIvbF+yXZFyNYcH2IrlpM7I7CYFuKg7tX983hZ/aJOR5HPsSem/W+fOAHcVt6vXhfcVHrRe9ZX9Clj1ZCWg74e5NlBwcrN9F3Gma3ZpuQXQIvo/5pyUYxddF7ATtS/BysFN/jH3Ko/keuGGHEQEqultirM34O7eK0DPTgv97awqWL+Mhrvuv/Z20NN/Zg/njFeJHLIszBXkuJ9bK13smeMqMkgCp9bjay88i2QUFAxpm8VowwcmfFXSUqRyYsRFqRbRfsEtRm0/6NU+2aiEnf8Np7wWZpTJfRbcm2FGxKSKrOm40zQzmRqETbfnnwrXx8+a8FRAaKoxAfgCSpMEnQojjoi64ffVi8HBJWwh1X9Jv4kDuI/MjWFByYWxdy1T3NvPaCQ4rCwQjK0RoGiGD5U/rMjx9qxKI1UoDlBfhnkg9diquO3Oxe9kMjmJqxpHQsMr0978F08ynzoQ6Oh2zJXSTQjkruqtFeTV0BPKhE7dN9lfQG4g2IbYMXVahkOjpuw9oeWN9GiWxBBHBJVq2j3M6TSyOg8PWmu9DmXUbupfR7iWbp9XJahQaP53vHcMJ6BkKsNyMf/aKi851g7jOhkr0Wz9EAb6QzWQjosk1F0UW59s1pb5Os4ILb94TVBsySSHhqkbyWZcLXljVIPVZFZpDe5vr20BapD7eaiBbThHXvzL/zkXQZ0eqUbNvu8+efWBcpQah7y2LaizVuDavLtvKf42jr8pzOrKuedNrT6wPy/ip/sJJguoadnqZCz9fSsyIocrLEpjP+NyHQ5RR8TkQKMcR7LjlX4QBpCJrQrUe9bUVqpZKhbGeu5gxenSLszbOml2VdtArDEXijEXJ2nVD3DjKBzPoeYmK5Hdk4gR+9JfZL0MPvLTtCCwji86IKolTxwToHIiKLswpSjWwLgNnuW4yUmeit0+h0okzOeNuVjfUVWS+/IxahYYmZwh7PoV0UCAjAdPb7H+5ipwDXoknYd2m2vi9EO5Bov9I4aAUozFwSYdvq6NtyPdMAnV8YrzqHRYeCwKi7ZtgoyrFyvQYH0o7cWMbrqYtCuIutiHWu/GqYXUeQnI5Mtpo6eSRljKRtPP9Fyog7jXYzGvgT+KwH/rfQsP2bF6CvZCE52HuyKVmU+fm8lYJlKXhT6yYYIkHjMKjTA2QY00ZvE5Ai3BQ7Rh6e2dmCxiEauH3UWSoHJ7XnlYT9YSp4X7QQj3j7H3GhUWOlB7y3kWVRBqYntjl64+FvLUauuV0EhBv7J0vHRg/qykPynsu9d2HrnYDDzPart9us99tKtfHrbA1rvneWOrvAtb6geLEsMZrza0vxR6LC7a8BRCvqee0mE2hFC96QvKZ0NDdbu0umI5XvhSvb1nxyOVTAPFk94ppp28sQimBWSN3OZ1FAxJa4lCYdohVXb7YlZo2cIfWf+Ct59yKFHLrdkE5M7WPR5Iz3H/hkSc36GTiYhj1RH7dyGa/lXyL3vUu1LqmBzZc3K/Nk5CTcSoJzZG7fYGH99dXL9Cbf/mtgmFRQseCIBD7ONO5L8zpw7KqbM7FN0CrGSq6YqkH1usOmLmRxKKqx1UXjtvSLK76sheqtaNYvDtl/j8b/rZut+wFAnMyRcvCit+ybXhLoi8TBq9nj/Hp8vVVZ6dNFz1pZ3U3OAuo2mu05mxZ3ZKOC6KxQI6w1cQjmS4ad/H5eTytjTcwMFhqs7XTg1tPSr1ghq+HnvrpLWObiBROz2W4TaDcCfKow4YNUgTKiHtbXjoQbKmd478OD8rdkOScj3K1HIGLEvxDXph/TePaCqLQvrZixOIN7bSLkQphs9CcNVlmPot6gRhRYYW+ZimqX6+A0mUDs7pX1xvrQ0Lb7XvllK3KMbXWN7o0GVvYOBjvtqsA23D8oIajT0gJHsJL/CGRzbeDqcbuiqfobOaOn/EMaibU6C3DkhkkTRWhlRMpT+PmEPcxsA2ua5IMuppxdN+iji9SDibSziov+19/iqZ8P9LG8cswL2cOaHpYE0aog/cqYOQrgwgnDvcQI8mS07VgyOiTk2+/o0nKtrG1qTITWch0DjESuBVHlOJVuYDr5FYnqjBi38UbviOectJdaBtpq1OR2OyD887FDepA5WQh0Ye2NrVoWB75FkGs/529I/N0E2UfEmnSFG44Ji4qcTgVzzLVfop1XYuXKbJrzfuP2MTMKwQx90vBdwm6Xhf3FE0d8ZwvNuzWEdk/GsK0rMOBMA+G9aGAljKXlNbqiV/KKqchwV9IsmYFf6d03Aw1dNbGht/rBzNo+cAElknwN0+jGs09ZkatPDLODEropfMeX4KR1HAxvQ72uhcFdMZmda+eIj3eaAH4b/Ik2gJ35DjEA8dOZ81vy482hEFTMKy7vsGbzofXeEw+rlcw3VKKup6ZbEDs1OcXt+9XJuZc3JkOi5wB06DyIgGKQNJ+I2LlboaZ/R2ChmQ6i+kIqKjRAMtHxAcDyyVYEcJ7qabLhHDcxgJ60a/1Jkoloa9+TgWtKG4J9aorsUNw5N4rtJCaGmFcpmXSrOMRL/6mOp5FPDoIg+7Im0MB6T5pC3KIqcmvQaB7T5/yORBYrvDbsfY5zDJJLGxbGt7UG1Rcrx/UkAAy1XlZ5fihwo0riBD6nha8qfP1NlYANR++Y/XUIQR29HpYgRxZbfoRevJNm6QQR4XZ8yPO4QJgcIJ0wT04ZXr0VHlV3K4sMYL6xxEdsL2F0CSdZbD4gXqW1H6zx9T8409JFjmLLngj3NJ77BkVshFCU1eWxavUQpcdzoSt84MtPP0B1940FBnIjllITAVUJE16Xs3gY1B4tkzxkujl3LNGc/hchCHZrvz805uXPXBW4GE03/IdUiNDZ5cjrHK/dX+fa1AQz389wDhCV4z0SeBWZs1mNsWzl/pbIwpiPkV9QrwX56SGr+AXOgNyyc7RHPjiyMypelo8Jhcbvo+rSy+NoPyi9rW6OAhhTY0JXBsE8Ye1ObIfrG32IrMlZWmBEqNFzcaMrCgoWs2ZnWQSJPlMV53QIf2WhCYftDrReaZ4oYln/CrDii1TMZA+ziZDpoeq+txlF33pXQZacXuo0zmytacWP4NDd9GrmI5KOR+FzCNtfZ2lgqn5Pjwv/6URHsyXBeeyd/UjDGrn0O+/WhbrJs4LsGGsss1z153K8xcSrWpo6n+Yk4XXoEep92B9TSStc631rinhls6mtgW6Kw+PiResbOxq9u9fL3zmMLhw7nIM4MyPJgZKCAGKftRWniw+BZVJ+1ksnY7qfGqYgCqU008ACxCpp8kqf4oOMomwvWnMSnxilDORk7DcTbotBSUdZXbza+qxkGETo0x5sMbz+U664M1vhr9pTa5zRsXJU3b0q28IZaiLi7tNXDrad9fYifqyI7Y3NSQmPAS6O7ZQT3XH9FFsi3V2gcofC0OXA2jBswGAEM7Jh+iCwCyIfNih17sJcxfeRHCq7Cifk+f7rkuS30DXZCukPPVfeBpmQc3UFlfVPtbcXag7QtrAEEt0y5IB//VNd301AiCtATc1Oykx91C55oBaRy4MkbaPcSLsICXlKJA9KVps8R6C2SYAsM4huzOvG1gsroC1Q1YHidXClikjHuFSRalikicvH2BRV5bohPKlRmBe1jQrg08YBuUG5ZUmeSqhDqnStTlGa6bCe8LI9tq3qeuMd+aLGd1r9dCWJuhNEJ9qeL2iez+h7VEtJniHO8je1D9cCWxVtiHJ7RrpBS0WSC+GeQ4XkR0q/s+TfWlVqV2FAP/8cBklbhrJHh68PdZl0yDKWDSulB9XeFVdTsyh789/bsTUP+S5rxjF2k2y+hsa0bWGGQtqs+Y8tyU8O9Tz13c1WCP5jHt5uQ7kOM21BXEcztM1/r6PjiBnYdCSnuIyX25Dh+xOQiGA/6D/vNhhQud1/8AHugM/8IX3u8ncABlUJ7KPUiJIjVXU9RZQ/85yp2ZyN7dHngCRVwFKnr4SojQUDREC1pwJBMQulEG5LTN0Yxj7CzlsytAFd5WZ0H85+2rMtPCgIm0afaH0J/Mi+k+RbGU13mnWmfbgRac7dSVtZZaQ6TeVXzAVX0cV9oYLiIWMFq37LA+fS3yCXKe1jCUT6ow2/ylpfyAFhXUPs6BN8rot3qGkgWZEgNorxXskpBwzKysQnZvevZxCPyHS8v+AMZzJ6yaCtIGquTND+te03QSqXWIlXIIzVO5PYDnREmmkyAqa9EWz++Iji1eu3zdCiKyOIDBs/o+9vk9L/FvqtP6CcN1+4MAxniYcboXNNqRwIXS/ThORV4m1Vp99uuodCU+vxFqI7VpWWJEnfHZX7zQN1pr+JlqPLY5LYckZ7ALUtlmS2B2i3NJg/0mXDgM6rWO0/XRukA7a/dEBmtJS2Y4h1jQ5lxmiYgeByL1jwroI6c18mWcZncCv/bf3BHNIhzlHsCkAnd0vLp4M+2Rmn8CBlbqZaBmkTwdX1GowcVMjz/wKUgCywOKcsJqsY34oNbYycrlyCcLJv2Dc1yXjV6x/gPdmK54wItyoKyGYwAFA32tV+GJC4gdLWiLKuO4R6sn4/QSQ+tLTLrX5fbSgF0zSdPapVaeRy+Qp8J5vxiM29B3YFrDoM6TmE1GRRZkbkzc5HOwOEz6yD40N5xB1XvGONtkm77a2iNLRgUqrBKiCo+UbLvBnzHAubCDZWHAw3elQxWlJnU+DJk1IIl3SVJ8dcz01SwAvCJtYS7/gcQ9cQNjXyF61xZHH7xvf2g2wiXba/NAJm9UbQkQMKa9WG2Eg1vSfRPhFzgrn3m3d28weGG58U5oYv22ypgVbQENJI+XwmkO5LS1btDQfXScfcbcEfRq2Ox/tNz8uzKlv1DvW7GZCdFpZdWNWrVX178AsgZR30zYOZSA4rxeJkjDRdZKeh1oMv0mSN0Y2LjXhZ8MYYO7jo+VXtwQBASbPti95f3UD0bk0pPoKRZHTmAMbw41x1JaapfW8OLHrN+Mt9s3cQo1GO/aDw9PYyU6kTos5cIWsydgpjXZN7jMUdvhnEpbXeNAj6jtnGd4N99QpnL6pwtsV73dDQ7LEolGC5j6I7PZgiY4gH65FL+6N6oIslBzG5sjZOeP8fl0GwHzUHe/LrHRwQ08VNlmjeReZvoz8AC00B+NGH3yCR/eTY1ge3b2apI3gmhjaPaCSTQXBumlR30ImhQvdw+cPrIqzhxrIfJJ04g5cSSS3F9igkjXjhSotqYAE2/NWupwoa68eaQjy3Ve1nk7XYmKR4oDdanKklSTgC9LdlxF3NK+RrbSoY693hG8uZ5k9Zd/r90dDFQe9QTF/FTn42hcDvxCCCzR44L6CFqLLDWbccugLZF8ADXrlndq/XkkektZ9LdL3UFF9owkwD2k0ipUPVz+cF/0bMRAfXuu+bVVe6TF/rQORh+66nWmKbkPLkdCNSCL1NWr7vo/Wazyc4AgdaOANcmhyg7eeSi6h/quOa1Ao96ISoAvmonPx4ZfH92DjYhBQcUg+fTn9vtHU9whfLlpdj++7KOjrFRQXmH36k36ZypSKe/R4hiosvlrlwM5LMyID7IkgnX1Tqd4HPo0G10WS6sYBSfCb5y/TIsarAVYZFX1ykFxLtiYHfQyNTGFE+/r+4kCGLdHHI9u1B7xSQ/8ZtybOTbGuKPCxNbxvbIEV+yt7gP99hXpBp7cEJHKNFeYjXwuqQUWd2+rPB3GDLIfSSjnvA4c5sGJZOgvYD+LecGuNzF+1BAIFrIJf3qpZUu+RzT8Xk1vIjJm9THynd8osnZ3WFG7arDF7VMyA2oBqFgRbw8ob67TSIbSO0uQHzT5XksJp6Oqe2Po9V0EnvkwjLFyegWLMrHte8tN/SJXEPJgsOylvCdLpkZDo7Qyn4S3RRKKr/ZBjBb8E2h2mhWnT2Nmo3EI3/7OCb2sw7W05HdmLFMr12ecRJPbQ0AOyFbKqLDzGpYcFAzYtB1MWmezUp7XeTQ8vbLkzJpvgIWJg9D+MO3jBCFuk5TRp1S9lQsAAO6fb5UtVE/jiRlGDNMbOIfSgDA/pjBZwDKvesRvf2I9ycHJktL6eOawDu4IOk2Gc/Pq7VqviTyQeLUeCpjatmSa0vv0wBreoV2brYVn1QmkUQBkKCs0YgOGwLwKEe8NqDyvbk85zQq2h1+j9wjC4TV5PHIeDw2NpHVOjafJzQxTcC+FrItnRoH/dIK6JJE9H8z9zpo8Up1ZTqTfDI/aRLwBrVNkF4sX4jkcSZrCFyObKTFSSGaU/7bLa4jH4S5so1IKoOMg9LLrCu82izh7pgWT6TDH2tRvBbucaGMyhXoJtAd7sObLYGCXzitVPAfATccUSN1/4dLRkw7YwzHmll/pMDWS+FghZiSanvTAlVLeC8dfGxISZUiDYUoaEc9nWiQegVg0471Y6N1T8VdacMMYWOVzGAkVyf0RwqUQetqmSAnR6x9XwWJb5bC4a4H+SqlotfPAtdOeUA07tWkcispeKtYIYm51sMzQKvRhCMQvDImNR60Ro+1Z+fh14h04cQJCiDqEHxp+pdA7qUjbI8C1xA8K9GQnUndB+ZuGz62NOye/6Q2kkaX/jkggfrP0v41i2RQHptJShsJUxAJr1LylFmiCUJ1q2hnURElu36l/F8iz1OLeM/bnoSUF2GCL2OFs9hvF1OTf3Jwr48PbYyQXreBYLPunNeO44wxS8Qmfst4s1iS9HiqjPWT167dsBLV8GOeBkU4dHJgv9GmC5mRaCFi+Fo0jzAagwMtJf7kXjmVaanxOQWT/ZHna9gXjPMKjVCAGn1PSRrVIFZt3eiY21Yjr/CmRRaAarlXLll5GD/sFLeiSByZJDTqmMc20r+FteUfU2YTvJq2+2xihuhA97kYQ0GPZRuzgajnbHyIJNlLFmOl09hqXBOKt2l8AiEttnF89tqEsYbAPokwZMfsJrBIPEp1yCcS0T98sPLinLgEOk3loZnLc2WvDr/+XPvHfVZPw/yzntNZC+Xl6lJHDBXmXoRLIUTz9QhoIDHcNwakKMo/V2LqwHl0W6Az7mzj610QP96fQLz7ofF196vohI3uECAgF/DMHI7c010EH4KINIMF9qykbUHrBkXkk9E//sltZrB7UEAJGckT1DubhkHBbw55iWsXMrdis/gVkx5RLIUOd8Auh3Yr6HDAa85NPqe372/dwqiAFaH3M0D+sUqeYcgKGEm3FYZXeINRS+6KMqSflRWWl9XLPsqZsS6Y8BKvJdFFb/eCt5ict6PDU6hXODtK09kRGduM4EoBdynbqD8SRcwNz94Py9hMNG5acRv3G5pOreXxKbfAl4G7hYMezC9o8d2dlfjFO6C+C0KWjf3Yk6N1HJArOFdg+Hhp8LwRrQ1B12v0XFkNb8hE9Tqb5lZO1KnZMNLjhQY01D8u9tgvucHLuYFi2lSd4SwdJ+I/3NQmsTtA0YQLvdgZRjxana7UVgFn8kTmLEpfztJ5Dx4+Z2ByUrMVTLb9cH37P087qEcPr9ArXuF/fAQXLgYgXAjkrNqx1WLLHM0b/KZ661XtSet1/vcKbJoKcrkSI7mKsWwsG9GWYDhjkXqsZpruhZlpzQaig3xG/Cdj6e1vVSjBaBzLBqcGrap6FrqYJr2Am04tnhy2c+kgv7XPqGTPUECfRKsaSqfqV+jqDw7Ak15A/qiIVnUNTUP/QFNBfUZRErVrhpd6UoTTsh6djXqYO/9pghpF8FnqawP2iYle+TKfWOqFjOSDr9HS7pJ81FThDYuekQ8OzM2eJwEODmu/ezMF0SWNsX5OssKVCIe6JWTiXqfB+ilDHPkcmDfpXVYvKTLC+1ou4OE4dE4G+0ZH9Zxt5Nf9xsMDCrc0YXgG+6zYl18xvIk+ZOAGFhXIFEUmyipKt9ts27gwtd2wofE/J4+BvUqksqcC8JBj/bWkTNq3jhlVgRSxhodIpV+2BKnqzhts7bzpBaFAfJmNJiPXoZD91NNHQ0Sysd8bHsSSlmexzBoLHnAdv8oRm6+su3ROQnljjmMyF+3KNTdHtrANPpvAicfoV0ifYFVxSBGMqF4gjTtFoZ/amh/73wuAFbow8b8DBoJbgyYecEuYaJsV/KiwEdlR160v0dJGebXLBNZqqr7kxjIcLpoMfZI7ssKBryvtxTvtjv/6gr/tdpHGq8r2ZfQjEMo9TYfo0c5zLhpKQvH86EdUij8GaLbDTYsxCdsmxIMR/+1DYPLkIZK+30QDSVHe7DvFn/9lCeGuN3ZQnjEzFHDoCL67Y0UDaShxP5qUWNPyKRD35mYoenmyTOQvxFK9eocBW2jHJIOrzTqoY7u1+Jb3LuOIqYQSHyRNHX+1+rVMSlrh7emME/1KXI/w3Y6GyGIjdZ2i+znF18qK3Icl+WxdtFWMqTdteUcnK0UVUdITfavdN/NXl53+TbtloSjbFn4NsSVoUBralqzXrCKS/x30ffmVW+uNi5HaAJO2JSPKCeVvvj9iLHwNI7AkAojwWh83TdWO0wFR09bIhx4YKlL/YddDBZh438u9MU+C4Pen0Yss3ZjAE08mlcJrw89vfx4oOvUWmGbZZoe1CYo/iIRPeSu3MqHwerh/hC5JlWp8pdcASn8sUtxcxqaiPtpIUYuUvef5shgZZXL8xhi9GSypMSoacqqK6dDOXV7pbk62T5nQ5JhwzXs2T4Bw2ftJ0dGgrc9dRdc9FQmYKtBrLNyPTDkovlHfl+uGGKt5K0qftxoTzeqmrdCogGLaUB2QhnM24+DKlWlcz1ognFxZISayDzH64fd6eZxO2RUMd0YoNeCPd2Tg9TvavZB5ZjgZXbVZ7pz11l1A7QelOtYB2BYPqGcYad8tSkRqdDRDB8Q5m5yyLsbrAxQ0Mg9AXJrkqpwFmfwRWTkmovT1P91RcfiSqz1IzCg2qKR76gv8bIPpWHuJy97l067RVkdcrfQmhuAJ/hApmE7HuGESQ4MI/fxxa87JncVldQprjldtnVveVgViCV/mpZzv34ukh0CBZtb5etBjkz3OABubL+h7BooqOWgvMcWN/pxItmFmwRGK5lxCRsjjjp4dSUsk4OL9fgpkCllZ7+/OSdoUlQvoJsnN2nRqOl9A5AQZSOfI5wEAAyGzmoydTY3MItSBhW6lkivUkd4dtmIY17mVEhIqPXtSRBJshyndYCHUfWruRZqV1o3gbAvsalpfD2boVLCvUfbjNMnT+aV6jAzVt+1NCX7WTkBr/3KGDsc9ZRE10bp6WKupNrwEsvHzqFXS5IWkU/ovkCC4DWfONGkqfkz8rJapdOYufZrsJ/nSBe6/zXpQfKRxJ/pbb2KEpsG9CtKlIb6pBoIBCh+z62nq7Cgh5d+Jz2R+Vb9PRLRukEouNnapothosJa12yrY/nEEVjCCQ4ofp5yts0BPz3QkJj3tXuqTnYnXk3zXHwT47QnCeMXv5jft3vy3KjJhYVwySCmg61bbvGV7gynrLyYuwXGThSauCPSYmUK2Rkg8d5dlvccB4ttQbiCYEVWlfULqBq5NHPOxcUPVrl9Z8Lgn61wFyow5qbXuYroI/+65Lg/EaOgJhIBnsHMxc29YfFPVIBSezMmVJy/goLV8hiw20yhZdQjnGMiCly06jQMcrflZlg5AsttV6ItjHYeDbfjNeNHJ/37TcjZxMQbwOZv5+YsfLv+078c4if5GIR4DVQqfX1KMS1BmhzsAoruZ93hBkKg5wi4vie6UU8jC/b2TJbNd3eD/mxQmdGRBSA/zgjJmNFfFCit/Kzn94AE5A9yfoftJroaFauuRzTzqgBRq2THX7Br4C0pJSzwhW299ySGsUzaH8sxQpJdn0t5ceq0ERCIRt+0ryyyVPXmAVN2XA9P0Nx2jgKsfaFsratDslI8uRCnqPC+2m8yky+NWMQZtCMdYR8dGss5FFBK8flu7tgh3QhiLCwWSTd5382WZUKy27IR9b/E5VfUWXRGrRuMDhYWysU/NOzRS7XcbWxSAo9oJT3TfrZQ3PcI4SfpNm4QHukbGKSEM1HxWoTbqs2JanDXgT0ZjpOvUAdyv4PmQHROH8D8pe8pIy+8TwnH6gSVZGZ5LZnE6PCqdLiCyBZZIfoclkLISBnuszbYsW3Ki3SbN6J+26Vq4sdr8K/EE7LHMgj2yr93XmY3WUWmUAeWhhOQbAfnAnRuU2YRozd8kWBAwI2CjwQGc3zUSPH1hoaC+yk15G8yxrFINlMhCOepVhsUjUR4eNyGb8gC7ak1CRVSQfT7cpUXGApPj7B5Ru4LQHgIoK39rBsALczxiihFw2OVVBNf+AAPr3EiccDV//4K9eZjCbtnVHy4W1gmZ13D0sGJ4713ovqAUtzeJkudAhNv9YEpy8fe9c3VUR32tqwOqe5Mtmu/Ol6uIQyAJG2oQkcPFiDufocIMVI9npUD7xfI9ItYuhuQXT6DUJsoSUWTghyodppTiUnxwI1Cr3jLnQuOaKCmzM+DdaOIShB7Qzg4mD+tdfLPuuETbzsNDZpuALv9Cve1UA/dsXAH5CZ6yxFhgUP+9ucjJxkC8CHVxsb0jJ4XjA/Ez50WUqax/9TioHYBM63CbuY1+0YQiViNuBOVD6WLcsEUzb2bgrgteYJmxF+tqqBw97ZcE4WG26anf47eK6M0flvpUpXpcXJg5VQj2p0YfnceAE5UjCM66vwXrtHk8inru86DMxjUiz6a9BK0kRkCz2lSoirWZXhRaaZoJ+CqCjFwEOEiAkT1CtLy9gp7BpnQHdHsraC1viqI85nWRshI5DuMaOnbI7MmoWjZAlqWFpxaqLGaKO6lBLZSC4VDQnbV+GDK45UBoDDuxzzCHiIDHemd6alzW4UfoFlOtA2EXOdpCCfaED9qg+BX3cjvE7WqPi+J9DohmjQXBedvPqyROqC23iA/1ZIgikcBus6th/TDUC2mWo+WL3uYjBMROU0PELduzKxvcCPz5rxCCrzgHCyrU1pM4R9T4YokLX5p+6bJYqaFuOTy5iAggnGrWwU6emQ7hGwlBISB9QWdPn5FZAO+QgqsHfOZI4IKo+suu9AJR5EjzFWtiHZLimrAGTv7fyXyrR4TG8M4GNg9sHQYIQtmp+7ok7CKJB+IJrdcZHexurh3N0dzv//4i9Gfays61wzs4Jkg9KQN0SV/7v8pTBTe+9UlaUuliCWotxBqkA32neBDDQS2qYv53O8nRDuPxvUa0UtWVmQP2eRMZ1B6p/1QXQWdfbsETa/24h7Sa1Aw1L5xDFq0tCWC9oViPH4kpyrYp4Xe+0/QN4FzSRJOqUguJC/lVKyw5Ynx8HtvLca6k1/B9inTEroI5jdjZIhzJ7lzgi7G1++URjAkRRYxwl55fC7Wm6QK834lPY+3eb/ah6/LiPUru8qpzHZPc1e8E+XJxplnbJdFHAYp5mvqmyMkSU9Do/Efb2GKKL9BbWQNLToEf0JkACW+iLLI1Ak0PMdhvA7yJU43RP+PjJLePirm9bv5q9hldq3qDSXuDCg7Bpk8/qCmzZNnXWfX54gpJNFzhD9V8kRv8O4pnGPSDoxLANT5OYrlNSCiUOMIUM7S4lPovAoWVUUQPA8RccBjCo/H7+Fw5Alut7U1HaWu7VT/WOKmugL6d7m6V5rUF2nd54ZqE+ktFBu5rVMizSFnJr1dLH5ijKt2hL978uhc/Vnc7NqnwRRXVqJF3tqzPN8h4JUI80LTHKl5W742virRcisM38GveeXDsHFpDQqiZFuyK1KEtVDDN0I3FflaN/vr0pFT5A7hKPxVzG8Svk4BsmeUEfMVKNhrNGaehDVNwsXFwazxMsTocWjUDGw5upAAiDJnP3meU9+tL33Wp2ziYFJ+qgJ24Om0ACc8Jv62wA62TPRA6O4M92Hu5341fzEj57S0PkzXJwpSpiZHtB4oDgka+vFk6JA/Mm+0eRiGepbv0LopbbHQaTHaV8lSfX0PsYfehWzpnQUGgJL3O1DgHxJXfL5sV4wchlHTtDakrF+hJjMnJHx8cHotBxrPGZ3T6Xd9HHj3oE5wGflt9lXyh4KkZMFPCc4fw73uoUEvA6UP1V/vRmedqLJMAB3xl0DhQlXzDOZg4LEoKvJHSyK/KleZmyEhijzysNcQ4RwZC1cLZ9JT8d+YyAlSxIRmvyz/9FIkhu2yIpEf9R8ZlnOM8+XRqc7l/Fr07eJOHoWcu0HGkzszBnBEllK7jsiz6aoQlArm1F31zpfLBoRWSTDXTaPcRt4q+jJzJVTo3zNWxj8ZUZNYJRdMFuzdC2GwAaSFwN+SNv657qH0NeRVb8chWOg4Fufek2ow4lsK0ZYvtrG7laXbVQ5otb5LMrZOk+OG91ZPC9SzyHDVx6jpRTRovkyd+fPHLx7IlJw5u2p1oT9i/ZkZS9kfWXwMcRdJ6h6rSwek2Kz3F0kmii4zyfczIJ2quqYPir0b9YdaBJYbedHc35Gr5AM1t0uTwUMWSdQEwhGhWSbYty2XpZAkqjuzd/i4lhkr5Z3w98Sag993g9MchxfhNEknXckrVhbFUsm8byRQ1kYutPToVrr0XtGMzzw40s6CQdTjoNjIWXJdmHe1em/O77IPVKcAkKz+U+hulNMluLndw1z85x/TiHgrwpckO/2GY7zMiyRcOc14tQKdKc2GI7RntPxkE08ix+1+1f6FRURew22Ctwy5Nd7+Mo8oTyPMgp6bKRW1p7o3SuGslZpu7/1+4z0WU6xXedZ1RFBhB3vhBCrUYxPdpZDu+N2kd6RyQEdzI862xFmWadWhK3r7+JgJkU7Kze7XUxkyilj4cmW+fZK/F4mp+RN/7979ldwnNKYI5i/l+C5J96S0BE54PFMVPVLv6npZ31hOSy8xdNDGwJQdikPMAWyH8m9HIQVAgYXTp/n8hc7isRn5cdg9pxiUKFEF5wU8Rb70GZhcz9NgymK+Cs+p5466MaqE/6R/0uYyrj5/8FjObBusHBhkIqdC/hL0eZHQr7UoHOT70ZCsqT40xuGDHojmSMR/r5eLAsTmTCXlwNmbpAhJ1GX2ggLbmGGBsFu9r0TZ0rKHBB3v6+tWEhxNzJYFtDDgI7BOx9V4KmuIZX8NC8gCN4bnPzO48A8li6n6x6CgNrl+4stdNvXHfsNtu1HtIelyEuuKtLspFoU0QXrnQdwhfkmXStKB/ev6WJEXG32JhTgGM4/ktA9a/I02cdbVRGmcTluIyYrmcexObKnkgykavSKasWuhtyK0jm8lRcQs7qWgBwQibjOFYkIGKAqj27DfwsM7tZb/OFQVb99H5CGWVaYOGPp0cacfQ/g+0jOPVC2hHPDScFv2DJi3SuJVibFZMrsQbawUrzF4OmmDrSeXbgo5ooTj+cqqxRZopwuNg/NXRkffPLlEQVCwUYDmsJZ8LH/5Gr+HIBt1zqJ39VACVJ6E8QUJShLaBUrvd/Zd0YjDFxg9avuFtNc1R9gNaKTawfJd3svvauqWOddKi413nCmkYbdCTDOS0Ym4Qbvs4Kp6qqNMqR0vBza3JnGd99gTrdF6P/A7uMdJVnP/dcSoQ3y9MnoYl8o8yQpvvM3RteriXk5C1AyP0BDyYrkEUtGjfkW5fWVpwWzkB7nRM+mOqk06AqkGc1bronKiZSAmvt+LpSCDx7YMlhtEDqYED16h5Key/FK2OMC71A4LbXpuxt+9grWV3Dbf0hArLp6MUJJtRRRgysDzQbHvwAN/CPApkwCQLIXm0WmaSt/W81soDrpquTbIzcp1mvg77/SM3Olek8UIdWpuXR+EDO6ISIgx7n+t6USgos2BcOM38Y5eZNAGJoLEuPnVoOAJUGU4miuDYhfwT/6ZGwRkdrsmwUvVSEfiVgYehPRY/dQhGrJGGQ+Kx81/DSnmIiA18o4aYmMEJnd9PTzHezm90RFs3Nv/N/XqySsz/0ww6Qti/+H0JT73pFsyvQ7lg5bvk34wpTN71jheMCRpUjdr1G8FDIuF+LL564Z7RerMJPRsxgbcRbFPnvZi6lceVEx+sO3WhCu9rU9aX2T6OrcHp+M/uPR9kOIk8itiPIp54Wdzq/sn2w/UJfFUUy70B1JRvfNX2xW3LVs3YTHntLfQqe9v76u6B8aboXFt4bpaIL00Of3a+PzY1B+MKYfi9lfH3fcjtbcQMXKYMQRAu4yoMeOqz81dMYuMZQryutA6H/0jOCWBFqp0ojaPmyFI1ISP9UYAFoEhinPHv7zCOmHBRQbpOvi5aZX2wKx9BZWJw2JsZDkRj5657XOGGG/fo6GzYWQR26impyxq7CazF45HJUPHuIcb/oNjT+7ppYf6qk9es1uLpD36otHcv0y+2Xjdno0So1Ta0RLHvee+loQcNP9Tf0DLpJLctI5NoHmkzOH1KCPnWZtffEWNzRiiB+W+Kv8YBVTfdxLhn4ZGaJ+pnLMkhfMd2Q8pnl/u2e4VGo3vwh001kG6Q0bBLGkcDnvgiRfrQAs/emOTlPYQlxLI2zs/XGZtB20F9nYpAgKpwNS9eDfyzeD+vjP7EW1xY1+nVm/6Kf2Z3s9Swi0z+SQNTMPlcqn1thlV22uDnv09EziY4IWRA8II6P9oQJKzpA3MbyjR+raAoo113Ddc7nCigGxiHwzQ9qisb8ZOtSf6gUcg5NgrYwPjPuBc4Q1zwjJxf5zVPWa1ibUe4URuOEMCR34MUFlU3s9KpzdwU03RHFidBUQMnGcGemAjeIOQE7ae2Ol77dJAEeWZgJi3QXPfzNASqXe2Sv4PjwoEUoZFk/Hv1f0rWLmM/Y7+x4Yp8x4UKrqexv+TmbKb1PI/OKqKN+8e79q6T6v0YXID8lB6bJfU6S9IleUdE+q9a0bPY0hZwfayFRKXL8P2crQGcppK4J1T8EO4MwM9AzQ8HlHgfEub9YZKjYXh1cpljoIwFYUg6AKJe3+6r/NWKi9H1GN99CwqXQ4tM/jE2BYN0aWto16Lq+cmgZDSSGEyADSFbOFE88RebX4Y/ekOwekOQUY5TB+P+ZG39pcIhVltGn3KLm/KqVeaQW+BJDjJaF3vu65XPk/WxW6zSA7HzAG58DhVZVPBA8SDlXbeF/t+7tkdz91l2kxFkC3oCOPdFozMJuLzvc9Lv5xIZ4eCuZj3JUvPyQJuvJfFDgc1sxn7ZxnA5U0F74Bpc2dPjqOEpjsai9iQpSSjwdtQdr0tlpRIDg+BmjaKKje+zCYWOBdmHysUi5X7MvH8jbcUR00FImdMb16ici75EfymUJP1CxdIXvidxzat0p+dak80GhmNve/nerxO2fqMHHSFaH61vJUxnyK+VdNdUlw98Lcd1fAuS63obuSJLnesGlYYblJso+r6SKS7x8F5niJFiTk0b/HD94gC7ZgUTDy4yYog4syaaxWVPl0sygsgE4Srrb7WPpHSMQWYJCGoos9a6DGBF7+USq4s1e0L37bj7a5NCbdPhpuu5rwFQXmeqQpi59knpWxlZ824Rj8rkPlWimEtL4R8vvRKF1ZcQu6SQ0B5fG6EAOYm4OSN24S+FZErIhLQKwZ73yr4nZrer7WZ5U3gb30b0Bgm22JKCt4gWnJN6+G51cCdL8LK2he3nJG8wKaTThLpFJ0G6adMq1uXsK+37ovX1tNTpkTb6IUiPJbDQx3ESygR+QVzXY1IwOHFhoNl7/uTP64K6tfXdWjykNEa2Ij20qYrotQlN1WMaSE0KmJh/MXMnXqWdg66leMyyT0EmUjCsJ9jiBAVWbLpyvEuX7C54J5zaoA5bBqJqpb91PjPgXVMq+0p0Jazmeb5F82JVci1d7L3RgCn+GDKNpwd2ZKXnmDAlxDXcTSe2sNIrB2Y46P5BnmoQRkFFfyhAxhZc8K/n0mT/L5adR+vsWQQOhLjU5dptScXEybrCiTCSxJdrs1uUd6XDC9sM1n0j3jhtFlqo/9qiSwde/5om84LnT4C4yNpVrQ4R/pxOB3jvV4XULI7WRjnT7nN2R/rVzPvJ1so68G1vZ77qZmJMiZdR/zpqFgNk48tZNvS73Be+6EhSQFiIpzmSAbHMGxnr7NjWH3t2lpqwxOFBY+LRBle9eiZ0vdkU63YblEOnloX93fbkIJ5RSn4rur0V6/1VbDVSk1uh33toG/VGp3JvCY+r/zeR5Jz0E57WjJ8L6mErlrEGYvWbbNdUUG4zei+HD8kSR569PetoBVcNeagmARnyJxMxghNFOHuEPKsRnht3N3u9WfPT6v32wTlfh23lhyC3m7ECJM4aDRDThGDD2lvgHxD6OdrDUvQeGpE3PjX58xLYA3c4ehZazBtwbJPoniJJPTWmBaFx2DkIqXyVUuzoQuZt9vw71niYJi2fkuYVsY6jIPK+zoTogR+j8wJvzknHhBZdvFQEu01GQsP0FgZ0mJSrwHct/0Bimjq4p4JYPpLElKZmC04cEwaPq9D+XqELukagNdZ8nDdlXqQWbqYgjCAqQoaELkxGF0+tJ6HO9Ve5e3qawpnw6kvMR84awdB4hHPSEacOLceIK7H//dI4LJ+6RrO11SCzEmn7e9YSbDOijcCwmd+mz8S/IcdKpD3eWIJal9fjDLXioOkqRpmQlUjeDaGM+OFKf1cF8SaHHlAe2UYdC2SF10LrOqWba+2ww/WKB3VMkVnb6iX86qNKD610R1xLoFlrTQYao+uKFqeCByQ5ZnLTVpDONuT+n2KR4JW1a+wa7IsLqz2VdQx9E0/UqJ7ZHtvHvvSeKUkKpbpH2e0IDKzRXK7oJb36bENmDPqFVIf729DJnWzSGCnnU9LVH8PC8wqfz4Kq8ylh0Vx4/2GV73cCaxBmgDZEhjr2t3H42rugp3m/PfvlM2TikKfFSuw5TvvC2bQgzUfK5OOdvURRO1qAngfsG9ftQwzvdYMe2r6/JP6r1cSpB5Zc0mzjnvj5JCpUPG7eSUTctcN4duKf1GWQ5k5zJ3mXIAUyrJfKPihEgxIDXvVM6ZAPuoBraZEWF05+rHCZMdmNv4wovSYl/bu5YPQ1jilMjlvS8RcaYwkTlV+OcHGY02vdeZM0Wtvfol5fuh26lt6x7yIB0Yz0vO3clMHQ1H6K10yKGJPCG88DUkbaPwwlB2KtKQ4GqI/2idROIMJlrqV0XPHfhuk5c8P//Hj9SdxajQj+3tMi/NK/q/nUeTTi1b/WV3kZY+cmrovqQoQzSTx1MdKaM4m4ZY5I6nkQYzq7cUf9+0y3Ash4CN6HrvOdlhyvsKgIovi446ekYnpQuaqyudBH2BdGJh+jDsgGFZqJ8ZolQe6hGxOXv8X/c64jhZEmQBsFfbUvWvkr7gKDDWVixPOg7H0nXB2TuF8zRyixKQnI+4KMYt7QzpblUUAuJSph4to44u6fUbHHKbvi4T9qE2AicuV3M9AGbL2fCnXVQdzRJcMB9WgRc6SyDJvBfuUIIVpUiOtQ7kfNIrqlZ49AyzUvY0+jrDwSasU4PE4FVvoHQKANZLjMti/PDkJ4JLG3GewS3wiTm6l7/SPzXbbWJckJNTxLC1WkCUkP+3xV17g2/yob7ZVBDpBj4Ij66ck/w+1ytzjRR/U05Tuw1Z/tU0LLscYEgC4YHelN324JzLcHwSri0iPXvQYTVChdXJSwYcRmNdTJbT8PrWfhHooYItT+zDW1cAj3X24pwLS8kdRvprbVrX9HFlcl0igLpdTrsQfxPonjsWoyNEn0n0jA0PvZ+58GopAhIvtNWl1xhWKzJH708tXtk6Jn914M//iC5qAIHOcOVIit8Tg1yXE+u1UH8PoE3RIY43fzNNPQwlPIAsMmfyppJ4INZwrZxM0yFLIpvo5pqa/TJWetyuM8yv2iDCA34EcNA+fwgnfyBB5Ywf9T5p4pLVyJ92AjM1sJmx5Qm/oxbZDQAWXNj9rge/gYnHd+qpkAHpgsDXmpfSYgzq3uV8obSu5KbE/Hgn2vS+Tdww5O5BVJNTxs75+YmzVlFfF7NdnfBkfEAs4PRCE0OM2+6OT30AHnNwG2wOQZyqz1D5ysqypoPtaJcg3rdUHfQyoxIT3dVVPS8cRonwEGM01RVfbWlQWcUDQbTfRZVRfk0NTrQJqCoV4rW6Otp8GZSFi2qZ86orku99By171n3bwFpx6f/cJk51jWpC7JubGuPCL7iE/lilLTrbiGoua4fpXfNL4uyCCNEy9+l/XFSXOxZjM1Tbv0QJiXKimU6G4wB52AZiYTBbxn1LhjkbLV9AzQAsQO82ycYhw2rVkIkaXoD8om3FBKZevovy4mzR3ZgQ6+gxAayEw7LV5MrcGjDdpXXu8Tdo5Qqm4kcuoDBeBBi4GKdz6747biCVMBkGYY5tkf28QSF1G7J4EiA5Q4F9F8qd/07uTckau+cSBZkRKY/Oos6RGXPAUz4jZwOwPIJBal/ztHgYlHc5TUEW2I4V2lrjLgVivsvs+98wnQ/ONEVU+H4fjpiRZJLfjWxf62gTdaFOguvp2tMGlbqFVnH/zEGl3AIab/j8+fktbw38LyEUiifWY3XY+7inPt+opZqzySXp9G1/WfxzLpD6SlFdf5QuRpiScMQQ3nUcrSSJhpYke1uABp3NC3aWGHaLEHyn2nLpPNsZSA5fuuGlVXoJPLm//BKj7OTthuW3K54zfAbWRvJOPSCxNTeDcwji+DWEKt0+CrdLZVgkz0AcpRheysYassgIv4ukpcVk1HnmXAnNV5r/VcZG36A3e/XGyRtPnxY6Ikp8vvjZuZc5AgCJYnDQSvkxou8oWXxhIDUO826qDL2kZDsiVtsp8fNQEWz5WiJs8ou3/xmoEToh8qfhwD/xYzZ493e8S6ZYZzLA9OWPfZFtH8jMQ/8LR2Dr3yEmf6R/io0yuIgOqPW2yocOcQX0KgaIHz0dezL/gZuTiyAFY1p51H5AhUtEXpLnKY4M7xuF8Q/rjW1m+uJgYJrjJ0Yei33qRskQFLeNpEqBThIkRLX3VpsfuROL5mRfulssqJrZ6d8KVACyV2zv3ffxJfDri2NHTeFe+rLoJP1hDeW2C+tikWXow8VTRpZpwHHX/7goGj2GnBSB3BiIvoQuu6SW/NwVeqh33ncT2uJf8qetX1/QVi4diu7Ry3pORHLvPNsOStsJSuQ52B7hUZWYpa1b4YzMxBsTEpJzJHRAfO7Jzad8lqkNKNWIuMH+QV2pRpZ+STViw3kbRR3lSqHr5LSmyb4mGQc6ZYddZ4dfGi+1pQt0D9V/Iak2Ly0Mb2wAlY26QXhDVelMpd1PtrwRi1bcaN4gsIeDR2mDk1Q4g+GaNwEO3F3GcRdAyocgJ9mrjhIkvA5W6GHRXDk0xSIDVFm9NpDrggTSZUlzaOZVQQjvE9b+tCwjJ/XIJBl8tmHH37k9vANN0Pv91DuD/RwZ7eJSxUHzQ3J5eQ8bjcL2+qY5yjCKPwmvm5MCjcT7ZGwC9M+BxBMi3rw0Iwv3Yn0Gy8QesLVeqYTP87omNi1ld1aDiFxT3OxFF7xoEIyF3nUCl5BsAY4n0WL7sB+eOQqlIbtiCKy2J5mQeFyMx88hnFutRoIERe3nNzToGfOCWDzAFl08wTPpF62vggolLACKe8S0h2XlJAGrfIp3boJia5zuxRIhSfEL8x5jJ1pqmIF+YaJS6KYt8/VUSzFSZmkACCqyHC8/ORqUcYiO6OD37N50QndBPkQp+8VgrLpC980iA/5GwFPaA/BBRMItHinaO32bu4FFLIWpIhy4DWQi9kBAmX3h1ZNxth++uPl+wwYSKeQKtHBxMB0No1yYdGpaUaRA9UMueu39ZGHq+kem3c2Bp5VKero9dhuSmIqLQ2rxFcN1gyjnXA+Yyu5LkiMQwNOhwjQ60nC/uSEXUbJq7sJkosC8g10Gj8qGNXusTw7Sw3q9xqQ2nmM+8oj9UkJyHbsD2sFBhJJ8hFApc25xKRZ65iD18omaNrHXRL3XnAyp9w9P9tXQYw07wqp2lFF9tZDZgP17Ycch7tXH2cQpTOXjt5gzTJexy/4vKCRZcB+QjGgGlbG4ewLT0qA9wXanQBjEl5wJdP5PpsqZbJPUQaKlUO3vY/jXSkyDTRGFwNBafzMSkVc7/Tz541WkZ1+DOLV6X+Z8lf9pLXyIngmu6thF/agKuXuUSOqXyHEVtVzA5SgzPRREvhx2Of+XDNDL42Rovcl6wjjaoY3fR5Lt2IAuLmnz8IGwjgWwFY1HaGumWaTHoy1vCUeakljA/XTxxXkvz1h/6MBNUykcEV1hvVMpfzSqt0Ii4XOB5Y5CuCd6g0oL6egWYP65/CxJ6RDlDMdtPEB8RyHSAm+JpCfvhJAV5OMZkNXi8JVCk0Plik8iaL7uiFBN6a78ojHdOQdpr04wdf8Y9Hc/wniYQQrNUySTkpQm9WE5xNWIWQiSdhbRG16pfcyc3Nomf3PrM4aucvZYFmb3B4ZwrSKazrqkXmcuq45Pas5azh1fVhmBCkfSybaPzC+KGIHvQcgmE1awLP9ry8aZTblsLRs4LGnx4vKguhlQ2Hw5oc94YXctGz5zf7OzUX4q5SbD/P0c1SpHYM5ATHrW4X7z/YYg6TsHyUEAVG9PhV95D49a3AGBjfXJTtYAIMb6/ARZRk+U3gmHjYjT3QWZhBoCvT3k2g7d40bXsWUhVKuJHJvKweyWSeDLTfsXQ46y5/74vR9ybMOGznRls7xPJdaGkJgv6BsDdheRRyL8enQU0hUWNZlrKWk7OXprF379YIhtuPnN518hYPjKmGM5x4G0laybCiZROfAag0f9+98jC9GhII471GJf8K+zMc5Zj3W+Zhp6BkqRccA3kxKUjnFDTPeukRJMeJSVjFKTsKcXAq4P4i5QQwC7cjV5ZpbLfOeDHYjEC/oaHkuQOY0uOsNq6VayRGRpJmPGRw+5G07YmqXbz1KqEGf3ovZIbKJ7HBOLRFAOL6U9JF/j2cIEuya5M3HPbpoYsjw3h9TIJuIxm7Lg+5iddeRgGENmxGJFcHk2fg5Q1DHWFPCN6A2g51GtpzAdvb5ka0siWhMw7QBHEi1UsDge6GQOoF3UhhAecD1aq33xe8v2EBV5R0wh/wH6a/43zSTp86l0iRMBaj20iCiZpDOPzSRZbdwBIAPqk6GrUaMhkk+hy1+Edpyo0QMr4m9as/hRptQR1v0ILP0gkahNFwtNboR+NpUuim+0fRdtOYaQCCe+WjOC2YiUgiuKAhkKzk2BKN1O0N4BCUFkiG5Lu+ZlmKVrM6DWCnkisprbvsVqHq98PVWya9PBrsB9nk/9RBTDMk4oUKFuH2C7tYAju3rZU2jcUeHvxqEulEGN88FtlD+rBNd/uHhrO/px7ejZIE1iywccib92LafX0nrenKvHE6ifY/6ENtqcbs+IwbJUjPpefutHyDvr5bjZIyEX0hukxv0Z2Pt0+S9fSZ3KkD2XmtE6ZAiI5h+9kbQoUrDHk7q9myZ8OFTh6/+17Q8hsVfoHME7kaQZiAAZ8uT/wPhAPF76T9P9inqQMhm6ZpwyRXRqZFukLPH/aBjqTwH5ciX10n5Rbw2DGpM73u5sC7oBTnWpkcWYV/3eM0p6yqAcceZF+i0t+dHMkntS2tZw3RlAqgaG5MrpC3yAXk/KissJ8dRxfd77VpWsBD1t7UaQIV/3omlP6luU9oABKg/TA3eVRPy54D0ok5Aiqbhiod1Uqu3Hi0Uat/0P4spfmcQHAWicF3jSHr+jdp0SfIdGqnDO2Pd3LRjw9L4z++NV+XLbrESeli692w/qnb70Oxb69n9stdbNn5LjRvcB5uGc4QVwYii8as8v9tbeYfWXThkIPM1kL/GrM7yVfje1bq7V75ABo99NROGVLsOenNkZVgaYPxyMF93PLpOIpjBMYWUyGo/lMaMzZRjSTLd0JSYnR5EgwUaRLvHmj3w/Yi0F3vzWxwiE2gXl1YwM8edzUstGqNm3vS/lYMWFU0rRuu4weGlSg1fl0sIXqyD+rK1Y5cE9O6rGURy21bzfubbyDXmpimd51UVutpYrLjmolLA9cuMuccWYGzKV3OTpbzQw+LO+3j81Mr5+fGUBo64ATrXl2fofkkOEWANYvOvkzISvmeTq+Ryis474d+hjaoYYW31BZ9RuSChdY1UsrDBXhK5FlC8csoTKljQZ6xcUDYaVwfU3i4N7zAoWpvkvU6o8zWuDbT/UUtgGJ1Kc1vMdrUnk2bMOPNEYSiVZX6t4FP02yVE8v2HyxqHHqX1g7BJIU1k3i1YauBI44x1utcDV8JqX3cRJr8qaqjJne83DODrppPVX/abgB2AFuAecgbU8Zngswx+6JYdBnU5EWUquJAPH6Qm+ZfEtTHXWcs+E0MGO6g5a46Ndcff29vIjxN3bJ94X2UZ+eigzkH6fMCsRnK8D5EyO5PVTT7FwsCBGFwZdxUVBZXjU+q55gGhETKX+Tseac9jGO9HUGSZSp8oqH0slvnDxrfpckC9xiyeA806k/EH0r4HCQu4ghg5a3WK2gFGyo/ONUhrJjCeUttm95VvRnc7RB3ZLX5CEU2SjU6LzWWtJA/aclqzEjIMatSl5X7Lgbn0iNN711SmNja1qUBA8iEkNJc0RDrlx6uipsuGXmVaABXCMi8N8bU2TgWtR98ptv4MhpO3ckgkNsViPVCS6wv41H8lG/vo3cTI211jfEhKq7Ck+rIBKoV5BmfrsVMX66k+WbmxZvInCzhyp5iLGhf7leQVLfP2PQPmeWIzlEXUMakPu46F85ondfaH8hvsUmRQST7CGr0VGvhLNLNvzCj5jGCaBwIWuqb1o/X4oVGltjTB1hAWsnTN3zn34F5Q65iW684ZEANo/CmLq5eYBw8QgDHwSgJNxVI9jhMHM+DqrDUkcYnddgsCFxqBA7G6O9DoE6fG1viMUcbu3+c7n3qndom8K5Lc8XSw0xTxB7htx9wXFBlyyA5Uw/5JhbP9c1uNb+khLzn3FPBci/o1DUSK08uHj7Xwp2/wec/hwYbRY9Q0cgxrkhXxwukULJLMxs3jSENQM5O3OMoiYRqUW2Lfxj5XFhH7sJT0ahs5V8GWVDy76VDNLCUEm9JuPAfJpVuQ3/Hth5tUUl3XUapWYJmmiPCc20hvy8P+yw62FruNisR2JPWa6WDd0iV9qy659pILv/1kgiJ61oUhXyh0pJpcPAuNFm2yk8xDbM6BlDpQD6CBDMARdWdMMRsQLtEZkF8wiov7kdcOY2JMfklBgS480iOImsYd0ynGSgHrOEsyI+O44abYDaM2FbTJQ3IXZf8K94wnrCtSfjRtdLW2uTPDo7BpuAfDXg+Rg7M4kyA3a40P4adFDuLGRFvOOgj1VrOUrT8n8cR6h6fv1K3ui1KJUXtbmjjaLjwZGkHyBSGEOp1SigCBr26WaarIryE4vzx4tlIDId+brsRlt7SHGWGQiXliYSEVW8vYobtqsWWhRg/ZLYTAhslBzlSYJkFdffbD1+pnQ6VC3tZuCINcs7FudLj7qetfGiEaKBMMnURU4w8nCPdrG2fDiIx9+abzjJt8EgSyWEvC66o0LXg57W4/QhK5HRClmAFuHWxjAgoQt2VvlZ4QavUn2lV8frN1Lqokg5KpAOi7ygIRf7UVF+Vp3jDauZ7LrvgErr+OqKRX9f+7ZBSVflwsASZzAT2Clt5ZHJqN3xs+nfdTTEwmU+HCG6ZS3/qsv0nrn5n6GFgIbQJNjrASmDULp9GBX4r8ca1HXme0WoEST4+dkSI/IwlQKmHyzlSiRlehioxIVUbZGNWULQ/hcDI7bGb/sj7KUJqDw6IEHPXJYegnxhDMaXTuMAXb77+LEKXluNkB1U5C0TVj++XEjhd1KqXUV+sBt1EnjG0Rtn/4yj4RhPqicerc2czQuZOyN0IY8taqr4VZ0vWU2A4yHxZPDvcbaWpiGVUl8BaOEuHCXKoOalQ0vmlQ9RRNoSmkDvrzb9dP50ipFZ2hHaChsjxXcc/lLMGPYOIsbPLQhP6h4d86z/GaCaYgClFPs3jKUyi9J8TF7FE7FSE+IUm6NWC6HyZvIblOQfREPeJDFBkkEecSEy0BI6G4ZkZTXeGxB9aYJNOjTlsRjm2ocJwUnecKvNySgihms49bDEaOCtzt0/XWsvQR/ZsxuYPa8+oGhoY0Pcjb+hqLpVof/KWr/fpxXMvxh6EZwI2BOkOIl71T9AE7vRXAiTqi4hOea3ivskDjV142Ou8KmJOtYJshiX494Ee++I+HaHhHdz+1XiZcPrqnXjatO1Yy0ZKmHLj7MEiJ4gbLAoUNC1GncarzWgfWVenIiXxzMzluOG4yCVpU2g+wL3WuQXLWfiUmP+2a6FUIq6VqpNBNedzHfG62Oc6EKjfvi9RoL7c8FffY/Yj8P3IJzR6AYFbnA80pYeFY4H5hnLzrwrdVhf4Hd9+VgbUFhLP2Ue7DVsYUHRA7i4ws5Rl2J15empTvcbVdbzZcoFBdsBAQ6y8Zqb/Bpztp8i30Id8kzYg89ZN7hPOHY1mTWdunuPmLNttUeve4meq89r25N79Pmx62Tz+MjiDcpD9vzgry+s7Im1zyxFyz4MolMpAcm274aQHd9ELQyeFtDu7kUr7ChjbnfH+3zQSfsOUdUZxlh0khVkFK5aAuowFx4osFJEHSc+KEUIgNMxjCEx8DtqYa2f5sT4ejwAdQJeAbz7JittTQ6RQ3XO3TKfMw3bKwACJVEyNuEoadxdMhl1wZ3fzjoLSAyqCPdPA8D2PklzG0ZjwJZOrsNS48YBE6B4f/K3N/yJuEFdkBCT3EAZPR2RMrlg0Ci0JqH0DvxDhWZyrQBS7f1OAJQ5+eXYaDUKmV++TgirmLqg5RR6m+XdTrIp47WTllwEWit8gvXNQZDQtCJwDFSGLPFvbrhpu6WSPKdMYKuooRBBdqYUkJHGlIrjitv9XBZTzQUfibdVJG9b7h8nMYYHiiPMSnNKfH4fGatbRIbfnynZU3lIdew999PGZUW4Hl3NVu2kGDq6UA5V/NC062FwMln5kwyWmdBR64wt5JM5yxYpYyd8MelPfsgUVzNLYUvC5otz+AIaa1o/DThy0O9A9yPyc5MYs8JXP0j6GSPLL3h878hSe7ZZaMqbN8HAAtlJo75EDKpi7Od1DRzwTAqQaib9Gx/kyScOdT7gsTX1emgA+9Rkf2M00oq5tctcN0P6CJhjZjpWzYUEnWu5KLv/S9AFIdNHtBASj/K88jGBxOA1s/oaH44TSCDo0wSYRWfqFfXVPrGt4B7X95/39EovQF1aHubbCdZ+hd0vxLy7LNGo14y4t9jG7H/fHh+0NkLfv7EZa5JE85LouBVxDDuPBWQa4O+LlYIBH8a24vqNfYuzZCuPU4+H/CjxaPbIaVSUPQkMgGFXzD0Avpjt/4ULPtoBWhHzrIK0iqW3gZ/mTjaRKLwS+/41DPAkIAQpq8JB39Y2NlmTU2JI9VuIhBZqJSqTdFnn3bLdA4ot+LQV8X4ULjtbUsCnFTmtcoVnEtx172WJdKZJirqe8FR2wfM5cCmHHpIGxjqA+zo5S9hpLq7O0lonmiQ5X130uhedkOpNp4ur7k78Gzv/bahqKpb2PGwU2tudTv0xhZl1IUL4/EUwjynxuJDsYeniIkp1fndLDqx+LRFnH1kNA/Di0ISfQ3v5SUHTtDZ+dhosiHa9aSg0KTJ+6Fq0mu+7dgIwVCG/2HpErQiJZmLjxFshuJXQMxlaSznizGdfdslpnUpE0XyedvlQV4GogEt7Vqp4mgi5ecQq5J8KFPNXiMlpncU2hc7THo41/+wp4OlWhi8QoifTA7NXSDNG+g02+nDk/qofuUS7hLvwNLrlwza0q8B6ssST+H7DpFN0OXto4yVEqD4eDAifH1wv3DrsI9ELZdoY4i91P8EST96xNk8FG2IdCyNkNiz8CpFj9OXZe+IBoAyMVs+5LFQIXJVdfcyoZnLy5+UvYJt/fU0jYct+H1nrovPlhqq0SDhibYdmG/SpkPBN3Zi78OJ72rZx7gXkeXtBqEiSopsb2jDHeGT27lfoANoCgIFQTLG/HJ2CKXA2xPpD0bwd4u5l2VQXXgvfGmUQ2LPeNFAeFOnRmzpTiE+aYvUILkEoUsgefGFQiN0Zkhkq9DlC8nJHhOZ4s4F9/M1BQEp2DppV74P+QWnjexKBOpSOwuPNVAundJcXZaZxWZRjOOlT2aAQfXb8sS1ni2HkvCzPNS6+OPz4X00yoTlHGTtweSwNYnQRPXGUE9bXEXAu7bfh6I3KOjkJhjdpYC96VjBhaaMFw8//axlVzFiHKsPKcyXqcwabwUZGiuZ9caZyV13Qc3NWqxMhp5EYq8yPKG/MZscBymyVcAq6u4rQ9vP8yt6kS8jM08NfGiSrDrN0m3cE8F7RSkMgakf28A3/2Uz3SotCtuFGicqHBgk9yNTJIeabxdfkQxXBxBAGrcDIpiCcWEkmiO+z6lqHIfCRPP96ZCWPt+mn51sJj1obp01I9x/JhdXXdLpZ/YZIx0zrpR6k0gJixU7UqKHazTDJsqSU+Zj/lKEoKIyWW7UtPmcc2T5RFh9ZEkquPeupV6UUaAhjx1Pj+bvoZM7YTSrDFnGQvSCeHw4K8v96L3ROEQ3qnK2HfOx6rcxDLzlCWT7TMH3vAq2MEa9uqh+W1+zA5uv7q4tleGvsPwlZgzpO4wpEX+5cwVtU/+nSvVpF2mhyd4ovyFJSG0YVDHgzf/xoVHpUErSqBZvmJyiHfdiXzF7Z/8r8xO3c9vPLdipgA0RHhTxitUc3makDIZ5eIz18PCRxUpbax+67TLavhQqpwNkvInFiio2yHJVTccdRO9yBnTj7F4nKBxouGCCrTU0gIwaGX/O3C0c5p1LnF0PMLxvTs8unKL+jKHwnZInmaUnp9hZijoYgWLqGzo86r3RjSD0qu7e0Hpk/PdbjQ9f2Njy52K5kv7taUXtgEGmnDdWhcWwTFGMMMjoXugECo2S/upQUO45Q9ox8JAY0MK06rZdVLUg9N1GScD3Ccv3ihAvw+SOP7rdyp8Wv0jrak9nitEG63GAmd8fyh4RyPjtNUCItV9LH5lgQJXGNA1e3ASvh4FqfR+4nYG/n2maEC/qyR27eeQRIfQlVjF/c/l4Psw8Z7FarIprqQLsalAkpLtIYUI5Ofbco6gR307ehK+zwsoaMVKEpJcwaTLKY/unvOr6f6rHxKf+DBMczvuSs4QwW3nDYLw/aR93sGZjeRHasc7wQnyaVUEvI/N7DhogOMfM5Or2oRQbxgDVenKBGu45q7fL+OXfpZPHFUIucaZ4O8yNJp5d00ISHOuU+Rx3x5dyVMBc1FJxEAdqQ7t8zpPluFKRy5SL1xo7zLIPZSl2bp27ChYOFY+2+Wqx+rL8Acn9kHD1gH+p63ldbP5e5iW03UjZ50Ln+sZXZwUg/qQ4/1hV53JDgbJcNgoYp0ej5tNrVOoVtp1o8s0z6y8bNUe/56IEoUPvqnLU5P8aiQHhQil7/ffzsPivFC1HxfG63Uzapr98Q3ZNT5dyArAeUkADHnJ42eiwWGs8gA7JXiDOKa5xW5ByrhB7khqmsLuvix2GDNkg2Zgnsmmq64SqjV3NbGMVHrg7QgbK10gTNhYajOksAzsCf6kqiuxvOGpV9+6nW+RA8ZcKc8sJUHDgU6fVAYPa/ZRzoWjQZWq5xDb8CigO0QIdb2gf1pDlT+R/Tlx3zX1DE18lsEFep6o2UrAaYGDb+KmiXfoNuxTgockdsykJGmxrN4FuBaWQzCw2ycxbemqWkriNHCuFwVW2dktqR+TJJB3wnQTQBi1I0R4JbxbGTKNqU85+QH0IWZokC4aMBd+zr6JIeCs7xh/VsUZxkTP1YLd/T52hx6G9y06mDHwcc2kIR8/ciqzicD9+BpukoYQ5v5TMdSPTVp6bKoa8TKS47dgVKoQEUXuk9/5CauwPytxa+wbU7/zzWHN/UzDRE1YuVSqqD7E9y4mlz6opFGbSCktD3f6f5PM0HeMCS6rMy1A5PyW9V9mawxdEQ6IgjkUaJ+UxUY0mNrKjTRZojBi2F17egKd0+LUIcLert1zQGTTrKvBWFCIz4+FKQVWhAPxmVu/2KrJ4mG0i9RX2qCfbJDUoJ0zwLw3H9surRuR3upzUmcZrKp3nUOs2ke8INsgO4NyA160TMEzE+xCFt69V/snSXsVc/aFXds7m259OdTX4cTy9rNVqPlOLsw3PKUtqbi7R4QRboVDNpXVeam8s2OL0cQ5gCPz1JGdDewI1TXswSw7/Fyg6aT8OL2/OEajUOmpY/xuNNGJFYHzXPbruNqQy9VxzSA630PgVb/Xq21llh/Z15wLlvXrk5FxUbOaRBwB5O3Da4c1dvZlTQJ9GLGMSpZJ+uwzYFm05HUWIdtt2P4zZpW/NriTmoPgpK2Ww+lAig1moO8XMageHF0YB+DFLtarS6/LdCJ6kCmG3++FOgPSEGMvfynKGGzvLHF0A2+N02Dx5oyT3o/ydjouwB0/zi/Ufo1vJtFGdMtix7vutUOGFyS0J5csV+ld6aefYbNRIoCSjwYi/NrFpn+Q44DZAEUai2DM9OOdqIX5++WAJoiQBrDdbUvxswN6THaDzTwM5aKwjMbK/i30B96es7kdbrpPwZT/IDjG/95Ain+78Qe3myYXH09cEJZf/GugQeFAFMe/558XhkbSpel7pnwUnAaacdb1dAhzdJ7Q4vF5ZbUe0m8MkOjFLNzSEJ9Krj8nvw7j8uK7pBxRYz5NOsyNwFwSbJScNRorqEkdmn0FxDFVgMpM+ugTjMeNTbiEmmal1Y/gYpkMAweuZpalY3Ut2aeX0po/LfSQLkBBx27ZSR8g7dh47J5W2g1rrD9Ai31xnLX9G8DBtAOfDDgE+koGUYPSNPKaDMxCWvlH3NXi3azkK7C/yykDWIuki87aQu/HFB2aLXa7LfS47+j5McNT3vVld7DqgIhHkhzsTTf4mao9frzDL+kMI097vYdSqOD72OUmBSPhhK0YAxdNW20fTTazft9a8ZPRAZIJ0h1jvk7pmuRhnnnFH8Cx//GYqCBJpaPWvQ/eRZLMgLwbwYZ82gtRqzm41VSeIXVyz0bZ9rXPjvLZoGh0LejrX89a0dVm63JfgpLIJEwkYAfunAk0IgpyuDV0ddHuk9xq/H+ZpE9pFyv4XV83KtDj7X4wn1tP3gIA1BG0S5R3jiq19QoNE5ml9TY6XEpC0UjioCVggUCPAyZPvr8hYIwjXgiIL+VkyJNBXEQF5NqSdZx7vsdUvGnagSN2HKOW5uXsgi3pyiN7dbzZodFHa0IgGyRKGE8+pQCnXRm304bA2hpcfzb0RNLvHuBHXBqKTQoJsN8hRaFCncnNewqR9cwNsFwy9P1N8ut6bSzu6JK0naduvXkkq74fJh25cMMibRVBLMs151QkFkMjH4c8nJ5yhUvAOFbx8pTb6oIzo/Z4u+fJDjctDyaG1PooVCA2P1Nvb+xCUNzg9HURvR4u/wpdPwY/ctQeobCrPH9tlXCuAiwbQ92j89cG6O70KjpFSomTSGrwOEvtYkdwxkW03wLFETVFR/1f01u1wht4+KirJpBkSMbdfXpoQDgHnUTQzquHsKw1mFzpXrYpYt25WOMSKZ3TQJyDlUJJszlRtbyHi3YF4S7m5VhjTCyMoRyGLK3INJgpIsJFxtNXHijJXtkVD6KX2Z+r9PJeL2X/p8B9oJ9pt716m6G/5a5fs+ItvX6J0GkyIc3B4XxQNFhTXf3TuXlN+qUVKOXC2+pr7MCjEX/JHRljjA4dyrYrfdsQCTbV4286h4l0SMik7nU10ePriGeM4r1Nt1e/DCpUwo9Pq1/M1kiFqvWO2rs/dmxKHnisA/wuLTbnekoOTeRU+oA/OuAThFgo0M+ua4OhYQXc3Id8iomI7XC1TzOMGu5YpVBvfU4qtCEpxa3g4fBg6t1jjdgHNuzyDHHThIAWQgmI8P9GAGm4r091Mv5s+RuouZ3h6gJqCFbIM53+CAPUFeAMKGVGnbd/oYBEpE69CaAfkWRTpKsdgqQO4CI0IMFzPH5DRQ6LwZYIelNiPEi3rVhwttfJLjcD6d/lAAlKEgiUWFAg60qB8py4S2r/2bhVIzOTJ528s2F1I4l5iKm2VBmc0u7ctgxDJOo7ZlPwS4k/gD5NMX63GVtciNR8wxkM61sYMw+CEiwR6dUzFJQO8G4KFt572T3tT/oUh3t2HbQiuIULincB4PThghqPBSjOY60o8oBnQeia27FP/CKxIkZxIOlouQIkQt0Hnduql1YbR2wnkJzDbWKCX08VFK3qJ7d6cnFlp7xJ+Q1ZI2MlSkIXqdhZn7SweJmYLWJjVx8iDVinZSNUGh2G+NNblxZ32E+2GSHedUIz1YfkclmEgIKe4pa0UEefK7LNu6+Bs7QiNzniqan2lnV2nWdnqkQgFrVEWTXuw/w2isJFY6VXxHzxPNpfEn3k7uAoUelY+IOh/QFuWzmXEonc329HnsHBTOmoEp5eibJPbzN5I6nnsMWTmgBTC/RBXCSbMwk8rXBqqe0r38qOG8honqcp9ysrkbjG1Mxm6faRPrX+URJhUXmrdg0Jhd4jA45Nhr+muotFIMVpq7v+V86H5n4Ess0F2Trcl7Eu2iAJ8i8MjQUIoKBqhXIsMPwvlsjYjNUdT7pKU6THTjXXotTGwfM7zt3TxU8cek2qS39PAorcGqQRfQwP2wXEz660Qcy10VVDbpGIbLPDDr3GOxcho1unGaJqvlcN1D0ejpi80xv+QFf4rSWbQ7+DkTlbpjaemqWbMRrRBI5JheLe45EKkzOJ101zupzStV2CI67sJbvDfYXq6eBOST3lcRvGBWzN0zyFSWWb3YP76TWPRoWxk7Evfl5LsBAwbneP++0lP8dJlaNAk3QSViQMDL5rDUCprNLhWapHLC+K5yC2rWnlh1jQjpV8uAqcnQWDBBJVST9faD+wFcZMlhwMHHDezs/6rmTg9fWix9cssefjRBqKfgj/vjRkmrSvQ+zgXzQoawJln8To/85iFOqgsF8gb8iPVgMMsUybx+eakLx0YwUhyc+2MJ+/TYKR6j7bnrVVb16JueXfg5hSk0JyIW9vpFYzubQpW9ovKE5PO/wD/sRWcv9C/L5Pfw3MeciAIFQCJMHEWdloj8lFJAfMSA0ftAqnzJx9E8Q9j2fg1OCvAdRim6qAgPiFBXDcM37eltgGzpRuDvNA+k3RSJI0JSguFNbKq6sYPqZOB/f9mJjnTnQFAlk8TPJ6ovo1AAGVcJHyvKrPMpQKtay6cZrD9ed+v2T6HLDm+7mBt4wDNnOIu5rnzLW38QaTHh8IxKVivPrXC68v7tIAAlnAxt+PRJFQuYxrloaP9DTBEWI0ie/+Ip5PVXp3o0t62DW7kc11G4HPc709xFh9yPi+28LJv25J67OF7u3QEG27YhP8S+Wqn/BnAyWiWduUWdeyoyBYVQwrzlXQpL0nZ45SSwLD903MofVr9XyosbJy+RYTQ6aavbEtSbl3d7uMXY6iO8FJIkNVIDX6XkR2If0zJTY6xzB2K7LPRlkflv4kYOFwhqfnSpWUYHs9GyIGFK/D7+N6LB93HY8Ej6SdtuvTyhZT9neV1Xj6vaxxyhpNUymbG8+GNhy3FSPZGu4BnEdE1Mqq/e2aehc53E750GYDy7sDUe8s2EF8RQqzhv1H4/lsiQ4SpCbAumjpaEu3EyEmkKqDVjI9iaofQHHcgqzViJ4dRpW9bLpVMkCUyt32nYnghCsd4claGpNnt9DKWwO+20i6qeZzOzY2AU3dUZiR//rj/Zcms7vQxS+GPXp8OIlzSq4AM65IqQUHGCrbB6BQj6lQMqhCiQ0rQ0KcPfUVj4qc/VsftXKfMPoYpn91oK+qLtXwrU2csuTMLyuLH1+nB8AsksdMEg+jKprJXSezydk5jarZjJXWBYSngT6lh5bHGCfRu8n08pXvIoPmlXpJ+P/TwhwBeM8qpEsyAnkryowch6bM1CUjQoOvBtXLc3P5tmEUp0yRsINssaixghnVySARK2PEqHekJXyxXhytrjHT2jQvSCuN1Z+QWtLUOYnq6BRTBo0lj5T6FKh7XueEwcROOxvKW1ITTOUzKXJQwZ3X7EVTzHHBaj355jzpJcLgQNhapeLQ4wl14AEwAT0pQQiUsf216mSDkLMUaOqhs8b3kaCLCwrEMxWupaj7ThsTgufT7aYJ7ISPyPNWMmugreafOap9L64FVgveO4QRMx385NLIMi3i3POelLgPI+LpMVkELO468/smXM7KRPI5k0SLpE558IOlEMCVRwAkxwvssCZnJfOnyiu/zOHEtcTIBpws8VR3ZSK3a+ogRJyfAsQQ8OJnvmkUUdnrA3XLDO3hVVBSIGPLL1iuXKSH4+xoLDVlhqBewDB85tiVCx0R2pK9RHoVPIZE/2pA8T59fSOC7BaqndaBTZEQ2fcWdjyx/McZqZAAXmTHz1Q2QazqhoUzKfR1/ghbM07zbxVQhLl/9Hiwy8RcbbYPbDlIJsqCuMcqaCi3/hrC92bKLUqyrIu83adNRy/TqtJ0Si0uZ7Hti436FJ4aWeHwzlhwIrmM0cwH/0Lp0M6uZD2QE+vTMEcn79QwKfuxCy92YlNnLfqy97c0iTwrBZ/w6AkRLRgRw+M+hfcJRdMAE8vdhR0UWPmRsItgDbY5x3JtmyEj2LgQ4L4a4c/HEw70j4pGSPuBAnKq5cnq8ZPYUkqQ7IEm4QZfpT6smBqWTwb3El1h2aFA78EHH3gie1QEabsn9WGauKBL42DOuJBwq4WSKD7HsDl2CmweFYshm8TqcnyVl51sr1CMnHaPMJJ+3FyrnHTzTQIu/vzT/42I6Z76FTGXATnWkZTLDhH9qB3CWiYn+QbwizK0aKImyKyuHJFko5plpdN7TZmtfZ6ZELeCVvBlczbdiySresubCbQpAQgFF8cIfXQ7nurt7J71Tsk2tR2RJis9j6Iki6EoFz9DnEgWH402D5DizHll7ZrsCBQX5fO+k8WbH9oiNKzu70wiyq4oeYH4TM2frgoRC4FJ4GGJFpzh9/k9dNdMZ3+V2pfhj/rzmPq34Q6/v6D5e1KRCJ+mAN4K3mSII8b2UgfMH9CNL8V6mmCw1B9E8plKvRDFAY8xvA2QlfIG4xh5frmi9g4jR1BXjxOYdocfTLf5IoXQoPWypwEz/6kd64Rf5lwVJxal09R2S+5vS4OAirpa5hhf4ev4RpWkou8h0JMgayouDHHVYZvsinYJnqawgt6SKMg7pewPqkqtWrc2CS2Q3D7LUTEs6kVEeGnL5GmN4pkxh+Sg8VoDaFDhT460pJkltHOYbxOAJuLC5LnAGdbG4U0Rn81suTLPx4Rdxf1rvJWYbJnClJhfXzjsZGA5lKhK3jSa8Qvg5fI7YaMREGHMQR2QUCG0s3BW0F8DtqX68M90FRJhQXecPrBblUYabmnTgvkWpouiUiigwI4qVGEFHQ7wkoshuO/OrjylQo4QByw+SQmaneI2jWsWCEjl7Ne98p0aE7Cxv20CtkvaXsV/kRLJ4nUZKboHrPuZ/ENa1t7ncw6U68LaXelNFG/wuukBx56Dt157dotAais6Xcdbewr8jGrpyQm9xgVps9lDArrydqtlVjU7sA5/7yAXZxMyPKDb7AGJlaECYyFwM62BC+PLdmFVKtf+WBli6rUei8jXXNMJXw7jFtQwSBH0XuBL1Xm6m08hT6/+MZaGTbOxJWamrxhJQmU/1wrL+Q39jlmj89tAYkUdo/1Gqcxt9oUBGT7zCRdK33ahvRXsi8XdlH4ryuWwOIRgRIHJy+ixuAfdNs06vctl0Gtan2Ft6XDfyyKtsCEF5u67cWRGoQXVOd5gTEUch3G8qjoOQv/1Zl1BsDkw2FphIQda5I++mrfmjx5HDbX0IarVxG6E8L9ezK/FWziwG5lC/gqTQdvuSMDnXqO2GsUfhukC3VkQi4t4CZ2VpNjGXyK7Cu+u2NynFJ6P5OhZhCFK+LpPKVes064JdsriiuVTlxjOZdwe+j1QkdSHV7QjsWcQLNvIXljVrEPrLK/yqDAcKqCUscwPxbwqfqQdG1mTffdtPMBkd7Djelpz9cCBNznPo3LNsGQiR4Xy9sAe8YJ6D0Bxm4q++4PlL5MFvZowhsktjfdGQgDFZc5Bbo7wzQGudac6272V1nwyrxhMOra6paZpcgPg1tPecNE2hTXDiZkjFBlwAzRhh2NSDrkIxJYrXYkOGFR8HWCdpAtlxpAKGMGgypADnUqQtuQSrsH/SVXvabNgz6Yt+yPOpihNDfAXn3JEalj+ZPryRb1hIb+28LhE29eImtmpvlarkqehUgQqEbJg/D555bk4zV7Hsp5ZmWQrSoVMfscEi2TGOhI8r3BVBRycwRUYpJM0qJcgJJmhMeepq9EPoCmTsAdDRgFrTxDYA0sfB3lzuUIN+Uzjddajz5F5DfF1yx6fP0DloEtfRvCUOCQQEgE3IOcC4zM9huEcJx32GmA6Vn1bnofLDhETXZk/WHtDEWNaIV8MLn7SZcLct74k8/2da4f+H2rW+hMNXJnwY/z/QqgZuLqoxkQWSCSphLZPnezSShj47hdPcl1vy60Z+pz15RutXUPPGpc7/ghtEAaMjd5HIsPmVV8TzHNeEafLnddQ9AH9UU+YYEDjkMPZuYye9sbYxvIszOBDCEFBHJ706hgWV+ODUxfQ8zRaL4mxQeW1611a+xnjPy4pGEyQqyydHjjpHNl7qMqOr2vjLvq6wFtXjYjziXLlS9/RLvujMSOIu9oXPOYjq1Eoq1j3oY7MFodAE6+eGT5lABM/Gy1q8SZcRIC9HwNg7BDpZwfPpPi7rZMJ8GorS4RUKedSlM8fVxzApyLr8e5TJ8xJPrg2NAY3/pZzOf8KpuMROV40/orwuXa3uvEYSPenYhsyEENqCaMtazEUlWPV77zi+nEHtYoka1HkoLme/FU3PDBko+rbNjo/lLXYgm87ak0u8ha8D+L9DCtA/1v2a//9pPqXII99gM8OsS/VoryXGjWufiyja4y+m8KEYgcroFdzqQb/ykkwwqRNIpH8jKMJBukHIplwIOQh2oPbxvb4gFLX1cxr2HqD8qwCv1egGw6K/4kDYCGk5SM0ZrnHCxgid1hCpyZNG9lQQ93xAaKHbaOuEptlc6tisAlsrQo6kzaq0R7tEcpInV1VQCne+WYqsL7s8QvIW761ltgXkA67nUOthI6rPE6uBYmlEshQiHBpUJxhtrNwPaYgDviYkK8lQWtByNQb5GyoIwy3nWGAiFqASJaIU5c2kyTL9SuaVoimhpdlrS1Qxcbj0RjIY374j4Ehy0VIeEnKgcVxrgC/1JBpEsOOC10mPacdbYJPqZL++YmbDqBrJFd92uatJQhX02WfHAAgI7jsEBQirOyNtoxnedUZ1ph1OyowEvLIH5S1HVQ7eEGNwHJ/SCXEUFGrBMkG8r8I0VX5ANy30+Yh1fxqFquPZwEeHbzPEydth77aPHhFO62V+wIKRSiCe/18zCL/nSgySZ0rGVB98mvPEp2AeaeBJCH1xHbYQfEi4JZsgbxwNj2MPQ2Rdi1LFhG2Gv79mMSjbIa3RKUOLwVrWScWFTEqdHW0/CMMHMcOVfMsjYsnCPaTBmIBu67lnOhSqjCtmLp4uMBZt/vHPJ20ri4LgJzy3G+jgUkAm/9vImvfaKsd2ckvtV61NSr6hxBdeUZEG20U/sX9K2mA3kI7vaA2h1P9piZgpsSlVuTghuZByyRU5MN3ALYtm/gAjm0npB3+VN8X5IPxT3W+hnuQio0+/ZmDAM4vLNkZSnLF7GQr0HOQVSePODNotmmTi2ujnoU6bcxjCDiZfjyvGRmz7xbU8xBr/SD5nF+3iIyxd/s3FHpOfZSzvgFw/hZqVjaKPA7mvIqqPNbLUu5zKw5FFnYda1phI5g13G2XOo0axXRem8zwHuN8zE3hGQbVb9/21J/xE1I+T+9Pex27oqUu0tTnxhDzPrIjUeCYGwBpA1lwF89P77kVeMl3ZkkhAtA5BL9dWhjxWpyDznuaVaGlmnrOOZVJR3xLx8+13UmCZ2AgCNKJrm8P559Q+XQXJSO56KCqA1Mg5T298xSZERBKlXCciJu9JGU4lxhQ8PzJn6+ou1LVLjZO/7IyenKiHsCsxPkM1+v+GghrhW/EsTyivDDHfPaiEir60fQYIlloLmebFZeuHwaDKYTDDuY2T9jUIP/aafLjb52gTHilG2uNV4ijyw7T81ar5Qi+Gq1cw62xK6v1IYpFL10IEpN8wt4Wixdy7IXlVAK2+fATypiXBMMYnGgSTmkpXdntSqQfwD+sPVXn22VfGDi3CSILxVpRESIehXD6eemtUamUqd1qTqGBhpFh1FVIMhQcJCVei/r4BVZSPG+3WOtxMvR19qszXvzFQXlBWNPD6IPAPaeDI9PzSgccrPiyH+Aj0am8hOVPplC4tl+KgMUuSXvSJcmYGR4BifHiv/+QhByP5lSeeNavP+jbBJYGLvrgjrAV0YgGhrYstkmkZOBT7B3DPGkd6Ll5Ojw4xC1OxpCQecPbPFutRw8S1LzTXb1tIkGAmfz6XIzpJABdsgRcL60PA24gfPXyBJMU3NWVITeFSBeXv+pI2jbHqls2ywLkfw4yP/JLaeg1s+8CUnvfnKFTNXVoQQ7dl8fitYCs1q7VvlLdcdAWPb/p1ngJvdbjn0RoCpKRYqd82LoxJ2XwzLYlWtu5w54Cc79tS80HYhaqqDtZMRkmkVPkb8GVNGgPGtqJomX9JVahbbgdutSlurCLQHni4SKxx5aiQpjixTROm2Pbtt3kP4WOKBM+zACqzRbtl+7BgYYkKzqGbrLkwX0Xb1ZeB463k0+jLXy/J1zBj6DVdZM8uWr2giDF7RzpX6Rad0mLgUJETYh2uylf/JWBFmGxNv3uPt/leU3ae209n223RDeAEwbaCRs5mBylmk63Ac89WXWVfdo+7oo+cW7bBoHhVBCNOm3knXhlVBzeZgyWVxH7GBcBqoG8BnP3Py1h0NUyBY4HnYORHisZ0mF3jhspylvofTI7/1bRC7A/CIfINNzPhTFDyIuUMWfBWQAP5vPpAEm2E42tR5GnOg9B+bCRgdSkkZagDhHZNUx5VgXWGsWXmsTk2DMpP8JF3EoQwZyqObwdMkQNXGtRRd1bIsL+1QSKu1XFLIsvEI2P4e5ImCQbH2UA99DOXyc+vnQ7tclgQq1fLfUbbM3fh+f0PrmEyMv/eRRkSzVhZTyEH1bgACmnZ7y6AYxLg5SNy6WXM2zTnVWQ6ezYazBOh3+tlX33+djUbi2g1zFHAvywYhWyjNhpOaRG4iQ2aVwTiEjRczYDzBTz483eaSfCdcmlvDfWfIsYgqDziasHd0PsJJ9qSSIUDaA12Etong6QNQXbfAj2rcG+p2w5o0T3KJytzS/Wre3japHBOfdUyvhCLXJmf8+BXbdDccxoRIt1p/RPfoAIf3fFjkzHgxAadf1pfGSNvCzsumOSMcoCpGaMmmZdj+wyBqKyHhxVXFehPgoVxg0Rf7QquDSnE7MV4eCAayBfaxkP9EbxAVqTpaQj23jBxG41JWEoTExOp+/cO4m3d/TuHb4tOLQ+NpEj5hpzOSbjC22n2Jv1RBZ2F8TVP7cejGgXj6RUOz+TWUh50P6EtUyYlHlH0mNd2YXOIyZwf2ixtVaUgmDizlRZt/nDkXNEQ9C6xL+wY4U4MM10jt4QGrD892cgFmIfYa/piHQSRJS4Fb2PafbnkpaqJBK2cZqCAKQ29wwM1V5lGNNUhXnTptNkIc901xzOOVusvubdF1CM+BykoqjsX9gTXRqteu4rmDILs2iX5zBb2gBlb/6QZ7RsYBs9fntDKX5ENZaHYjZj7Zn464mbCEPEklbbvdGVmDaxi/i9Ct8dT3LR5IPCA95iqVA7r9eKmy8sKC5FPYY+aiYD8RO8mGWrkcMDKc2H/3jgd7kYrhwh8Eq1xjklvQvawjzBx8Sv9L/2sl1/J0NsqSi9z62deImKE5JdIsz0tNezzOMB0xmWEqOasf0G6I5z6UYPMeWBDSQQWvstsCuiERwZvJNorQ95VFtNUZGnh6Alc1HCH54jQ9CSkkxt7x5TO65lU6L2PbG1JjJ2iCoouVzDLidVN1scJTquRsuzJgIy7cS6VdANlLA+Mr8cnhDDr0Z3/rypqNmV7MBrYfYFp4seNSBs4yT4Q26wFDFt5+zx7RGIJHbklSnBGsHNT3NTv7TPVCGGUIOsUius/wrbw18R29kw8DZd5BI/u/2I/GaUjloCp7rgg4KU7SAeFja6WLVhANF91RqHKMbpOaRrw57K8Jlnl8U0r9vDnU3Rm4wY3X1iKCNyC9Rzw2FqK2ifqZewgNNy5LcOVfPqNOYX7eIhn69WGI+FUGd2zS98YC5T7VD3W8CbLGtJXHLKZytDJ+1RYorFsBiIrRDzELlbDirpu+DXFma+bUN0WhGRAltJyQL8pb9cpMi0DTfPVCWMSYH/YFN3dQnKZ4WPsMHZM8GYgU74EuC7px5z8/vl+ZeEJd0416k0SgYFAriHNIRmhzKM1EdQHHbwXxBDiMLbAfE5y+LRQ811dve+hvRUIugPEcZqt2myh/WQHvchfzuN2SMTL+FrCIPdyd0O2cGS4p2psTwQli/e6etrqKa1M0OCJRkcnDD1Ygyk8RqoMqpILmA2dSzN7x3Ec0luZ496wC23vjschtXSTW3R35zAnnxiP0b0wQsoVfpFPtApUKTpwrfniGi7OVVsMHfc6uA7gRP3z22TMvmKHIQBf9u55pUIZoqZ34LpD17YYYDoXa957q1VG+Cj3RfE1WN4kizIDE8BXDNXLKFl9UYobwJSkv0FlQpGP8oy3hGWmeVFH0PHbzFApdjuH0DnTBW8Bu9SydRD84hUxhErXKZUbFENDL1GYu4/viPFE0LylD83tYZoa3QSUjwVLAIKTUGgwpE875RzDEoge/9hhujYypr/aphLuwyXmZjPp5StYbiNyo/tz+4zdI2GftHx5gwE747rbNxKCAEUQofoCUKZyMgJhU7CrO4ppMp6TkUdhXdqSOM+t4mRBINxudeRWR6sM77dpglb1NxS571rIIFgn+bBwqwigwOXHwoUNq6BBL1z3P5upZpuTi0fTDvLekMyHE/7mm1nfEDREoIxFaHPlbAqhPYyplcpFhTqV39g9eOTIlZsMq19TeByp5AAlt4xuoUrCbRuae/tayrs9vnYW3up9De+DMAX35/2UVpG9EQR+AE7DFzqNP9FAx1z3c60ShfUQJAcqy+4Yks0z3ynQ8H6i4AMZ5Rts5AW9+nhAqco8F1PXX5Cy1OQDTsecTJvE8ZHYCDPR0R/QOupxTVeMtzzHa6iAgP+RZ7NGXlh3H8PDjOV389muMPMthYCNE3BwT1a963UVbEP2qzyiGQBKRmfT4LOvKzmtNXJbzwk7eXlI7Pm7BKW9EsRMy7tHndY/3YFSqfvYu88Nwe1GXoQe/bt4McDYdKakyKevxUoRnIr6ITSDYRPx9VU0glPreO65sUDbm2SA4QCj3piblXUDEKmHgYobu00aZqnU2GzhT5dwYR66LjF689jxV2NbXmDLZ7RXlPaBUzI6v2WnguuRlU+nuMYEJteMwQ4ZdApvPnweOIqzG3UeDaKEOkXkehqKbxhXm/+fC5J0PSEzyc0gReXt/P6G9fvaPfUNdUM9Ueuy9NEDf7cBQcDvhoEdgplvBARENxYgyvcD3QiA3G/JfAOBm5/coLjWJ+cR5anKEFjQYKypd7tUCadKib3teqNOQDhai28HQJa2V5VkHg80xUP3InJysMoi9ze9f8c5+ZmnnlRxMBozvREhoUCQAfyVsSCYAnKgebo2EWJPQqdpLDwP2muipfWpaOTSI9c75k3xKDsjX/8kuwWDVqH1nvYDP1ax2TaygFhTqNj/NsG57hMH8P6xcrOI1AfGGOzz6bP04sGrBH6rVmcM50viJz5rX4hYc55l6JlfPgHebx/lRBE4GGLoPePzg9Z6IKO7Amss/Pw4vJeeial17dUFLRdGzTXZgyaVC8aBSNJYt6w18ljNbpi2FpTWhnQ5Bd1xD8dmdnjcgO/E+btVfSBaBGXy1qUOVCzc6ed3pzYrtWX+3saKE66zlEsrII+Um6L1GT+r+Woh8ntahnM1NURcnxB+aepYsQGI7PLLNoK9H+4cKl7MPCZup90JGPH82mqp4JmXda32Ox0NVk8tHRKC+CfyhSAhLsxRToxXSN56wr2sbb3gcWYBGkoWFmykf4iR+st+NFkVUbFYvVHULdaUPXqV3XjdMTL9jWkCW++14JRDZJY6hMrXGTEqm2CBJSO7XdKJdhGT8iuktqWS0XV9cm2V51P2yrgsfN0T6GfbaT0E6UQ8ci1cbXJ80jM9W/wMw336sbLOCUg6+4q1HVG872p4XQQJGECFKGs1shFersvEq+djw4P4k8HUFw65ljJYnihB0pkIImev6WLhSj/FtiPsiySj82rNWaqNxjzqIpuU91vCDv/NFlSsAWOuOu3eIeM6ZQWVEOtSVv9rp+ZQSmM62R5FDV/kT8QWnd4nQW3K1DaIpBAC4WP7gFmcpuZMLedI53qbE3OPlKm2ZXGFq10AIqs9bJ4NdQ4Sn6ayblL8dqe78fZVwjs6PngFpghyxEkut5BN8DnGp+mQ02zO+DsDfeJNsAUAdox4J5uni1FXao1yJtocx31iNAYB5rSgCG38s2x3tdHhZMXai2g2P4RSu5TZD3nruhe4xZJ3g2e1srsMgaHRaqV7lyialqef36mXSTYvF6TVyJQ0Na8grlos3v0n5rJrPEMPUIIxJMqAWRdKPGXSdYhiI2Nt7O3OSN39uaArA6QnLLZ7EXkJXU3oknrxOJpoMZVr1tfcSVD7q/zVKSvTHgbwjvdzCxV4S2tEHUUuqsEYojpFqryuErfpkKz1cD110pdu5pGy4DPUBlJj/zti6xFEu2M9TSI3GocDiekcG7JmJh/M4VbRjBvgDlfbUquEmvfceLvO12dTAZTJy2cJMBkW6kyo4jpX4gtiIQ/d3FkldXaFvB/WN6Fy/3atjqgza1tlBagwv8u17+PqatKO5fsKcFAUCtm+eShqhml2EaFixkERTgH+sj0vN3bjfyBdkzZVqQgOvLxF8d2Zm2VIXjsUKhbMZDNQDNksN1mNelqIe0g1zDUsum6QuedhebxYCWH6wXYS3g54wUCkQGXFmxqIQ3mFSZmjr7HrNys/LQW6Rk+efHa6+VjsUtwF8w2s9M2ZlEJxLH9j1LJLS7dgteYY3vinBPrpNK1UYWLZ9hW4zORN1/GEKYpedb9oJVPfTWEZITkq82wEDk68XFiZRBp4PaG4RNMyeDVD52YzjXsJTGApt2rlIfUQU2hCM4XA/8pJH+rFbAIGWet2tVKMNs4MisIS7Nkaf6ASqJEpc5wU4IuxiwWfC6rnDGEALlSfoKhOo+cmHvBMPVj2kJMkKher2Z3aJghehUmsPYWst2PhdZLu9EWCl08ZCqr5dmuzr8I7tBFGlxkeerzHaOnyYbmIeo/7YUdcKlOmlxME0UpMiMm4RtNB9uH8WI/GwYQ0HxGMnlblIrlhRDq+b4ZMqsZefhf8Xf5Q+UxicKHfDzV6yz6Oh5wzYc9YLVEe2gG97WeEHaKBV8q0fh+ga9ESmbqtIIYdqBvJv8FUyu2T3r2q7KuXENzwWRcZcifai/2k9rarZ0PXWk7G15wmxz7KA2AE3qliuRp1vVBLzO9/056vnqa1WAfzutbMLkom8z85ep//2fmPgbNni1uxI2d2e6ropuEa/BccW2dFPh2e0DS+GkTWk1djnpbNo5GFS589vBUXoudbQ6nv9UB/7N7PsIFz1Dw5oiJ/AZWOyU5OknCUacIjb+sbvgTX1QPj6g58xyXkwGq7hWQ+PpyxjLlQcmCx3hvPZ8tLP4ax1r4RF2g7HrvRsQkyp8fsIzrY6eyZPVj2Zz4HmwoEinrUcqR3ZGtVc9WhIdggxHf6ZK3LXBpIL7Mjkf/wYAMTZbFBjEoZQrsWrLVBKqZikSZ3qW6Xg+VtkmHV7Lk4cOKSSG+DONq656EZnawhrX1XYBy/VOEurzPQ8EG9yK1axd9Fp4WulFcIWI7Uy6kXoyjxiS/lt2jBnJe4m9TJSA4np37kcPOd9O+e7PpVRzFQZuvgUS33vl+BCB7wgzCu5TjTTVwuQVB7faaxcSAOHyk0k92ayuOY3Bd8F/xzq8Qs+jCnAvOzVur7qklrudd3JzMwuQT5K7d+zoGxPIE/iOERZXGtImpXHqRYpXMTLGf+xs8GzleQ+cl04qmTzabpFp396EXBSFzeTppqrNvxzxKWyN99pPHf2Y8soj84DBPKqHqbAmqVx2xQF4JN4umZhWEnid1uQpmcs/i7M4VEEFtZMkKW7P29t1xdKKl8MdWBNBJsm4tfzm/KQZm+WuK9J1SuymFhBGJbfbQ0eSTFkD9Ps+6K8f/0dX814DLjqYM2DPG5ZR/EHiNyuCKmYSVswqKGdO04ua+N2YgcFIxCBC4lbmpWhJPyCWha2k8VdhCyScKbmDSQ4hzoBvDKunPLPZs8nyBC5KTHv0+9ZSq1TOogdUzPttoRUaZEPXVwUpsnmZxjeb+2qJ/rnJYA6wqZycBTwcR8VVDhgfqw36FlB0zONOvq1u+yvaY2irn8nd/MK4I31mjHt+WmiSUIetioDZavG5OW68M3wzxde4r69ZTIuSfjxc2jr+c7guwuS0D1MazYWe0stlI54ao7b4pCEhK1ciG5OrrwrMKvewLWyIX+LispOEEAakb4ANU3jEt1W5mNWsYKtuwP1S8ltnz+xPJQn/Da/f8qSDKmMtT6BJTIcfgeZYfPKtyroH2PG9h+m1HIqOE5c7W2pCFBCDu0Cwhir1FHOLk5ZhYMwSxE51Ocdf0kB/Wf9lRM/PPI7H5g1Ml5rZBo4wtPwyD2grkHPlm0Nb1El/h5zteUo81JwqCo8fFiUpQ1Q8BHPC85gUu74qEMJMFvCdB8MPHzEq4AL1o4d90yUYH6pjUY38fm2wXhb36VdZqbGjsd4ab+i2K20Rvlh5BkCF1bwhQA2FvcwNX4nSdJDMOmKn977S0evVivzmZ3HbBQ8UxAV+043vbiIBSTV1bpvn7eAtmyXl+fmliDUR66O9urogHQBzVuNRd23AEzKkn0q7EFZ/UYBnDmX7o1AXh1mUL7brLBCXo8PVMjLi+bRitCMuvSmYeZOLgJ3ajSzvSII4fI65qL8Rnl0eSOo3SNyRTJlzeJSCqdtd35JtRomEx+lqSBjqVaLm2qQAvPtPYfVolBT8kYVdKsBeUZgltGGqUyAbdDffB+4dwuzdA2HycssvxEMI0fMwR9+YxHH0DaUS1BHtpPh/bMISaS0020zBQoSp00138mLjo2+vSXKPQyMzNNXJRIsUIlHEmy3zNxRWPcDL8RuS02tycwzA2ULpKyo29YlBBu+/RJUYFBORdRvBDb0l8wvl60qR7MHkZsCD15BKdguYq/1oNte454HH1SUQpCg6qAHfzHCxH6FdmLjtc+RUpmdIAHN/QcE0WOEMJV5tWKLcx7jddr3J9gaszh/N6d0oaeGzyWdpGi+QqeqnAqwTLM+Z2gVXgR3iF99+5lP+6+ctL8xSyRxkmsa85j2tsBuxG+zdBKHGG0u6P43vU0FQXAj4VRAE9X9KApoSe1MgG6AVuIw9PZyvPtfr27LYb5zo16W6W/WKiupl+SZqnCmX1bqVUASbmNgzQ6nftdumHvjiyYY4OaDyuNX9JQXljHfA9WkImWh0hHnx6quwjAsLseThZYaQkiXCabeqNy8puLMt/3qpioxQdoc9DTcErM2x+T42xSDlZ4GDvciAmk1N21BLlI+n3QZqCgVN89XqUdocSVKxDnsslEihW5QgNq92dldYQlTJK88kfyR5Hy6l3lAfyaQ5n30zwFS9AMeVi+Lu9BJHkrPG1bebFt3SXLt/2L1Nn0BPg6/SB91Ei9GVFB1XkwyobYvJ4yD4/xqoSezIP4/M9FkgkNAZXDJKo9lmZoRex4BLAz7GSEKP0xOZzmr1BZ+bBp7m4v4BccXH4NoO9CPhC7Z3nbuMVhV0y61Wyp9LjGmINlS3l16jYXspF6rdnYK7PfWDmwmXaSmqJpgOacL4OYXV5wtwH9K+ib9eje9NwUXO+o3Bp6IcvDockfZKjLJvcAOKV2duMKyddc/qTvi9eMdgyVjQiQljXZkaJGOxezNW98/IO8yl92F+UhkxXmj8iboxvhSijfo7Qhb6LoPZVe45C8O2NfZ/fpNdutBGgbQCasCwT2/sS1hKPaK/1VeFwifVG9xNpR8hTIsDzExlEc61eYyuc9ikeUxiS9mdqUla2bgsYmJsXiNxzKv/+/aCFTF+TpiCLsM5c7A/vYbYjghpnrCH/HQeZ1FpO0xFzzWX+glpBM8uH91t6rVyMs02CzuGF9q/55PGDNGOHcYrKQIekWM2AKFN1X/K3sfY5Gm9gSaWq6wH0b/QV9FfCW3uufM/o8QWojshO6VnBRT6JhR01XOtHxVM4flZqmlqe7QbRd+mYif+2C0EFpnmZCaAMxYMQEE2zjvmwopXwRayzEiPWmcIwgl/PdnJHX6wRbF+3rgykOT+DzSt0USw7cIn54W/Vd60cwHZ7c/puVIOs6o/QLkY52kglfXHR6m/JX3e4mgVj9OQNZ5NBGVU1mhiUV7xKBy3wDuqjZddI/VM87clsFzmnUucOurv/9T96Ffkbs9yBq6t9FLYj2Jxk1YGs6NDB6+8xDt3Kemt+vYFJZBbPvyXequvw+SkvnT753fr77oqtGNTiKqy412RpbXLep6JfWkDWzrRole/HFHWDgjyjG9qXgF8PtNAx1yHVJcumk1sjND0kn8rKMdZqSj58AAH2lbNWB+Q/9Ib64hOhy8P3DB/qLZea8u+Co9BfzZZFK/o2kzCCj48TaZ+Msa4GfoPbiEnhnAkZUkstt6ghMdNoKD0tMit7BBFkpsZmrhBhQuyLFaps1vZJqis2ZMWK79F4wCAWq0hQILsFh1qenehM2X46AlEfEDLkXNr+HuwffVYkpNFt9ZDD9bj+DyxZGAMYlym6k38taV/ssNhQRkivc+cXsdU86+xqFU4zqOqznpeQ5zXB0GoCFLnqi+EqrD3UlPcKeR/8GN56EUtZkpq9SLGPhLWSvDA+CPHfoqeVH6u4gNnMqF/sPuddnfK9lT2KKLIdLzdDP23oYAb45Z2Z3JjO1u6cutO63zXECCR08ByfQJlguJtFE9lce/u0u8DV5Klg2cNR/nN7IMlCl0fbTFGPVTo1uQc/vPCxqCVYGIBMkrHbjztJpaQD3tV2w/YvjRgM1EGKGc0Ys4N1QvoeSD8USRGJSYjxWPxs6N+EiU6M9mVCZubqxjPXdfhzlwjGc9YOhU7D71fOThvWNbJl76unftr3yesVSlh05yL4usSWgFsaLD3aOkR40M9XKgeoSmD0iVy5azTJxZhtWyHOy0hkZevQkXFuY50QdKTmBSIEnbJsitH5RkN+iwWY5e6bLX8lLfyFIjZRnYA7jISrrZV4y+o0++0AxJpeWZmLHwCNSPR0vGU4fZ130+TygVMOcD9krKYLAyYW2gn7G4aKJ3Cy9eZCuo6gZseGdUAOm5J9t6/BnLYjJYagEB4g8jig2mmmn3+YgRJyYveo9EPpFsi+AY2Ja7PINXiVZSrYd/sp8J0eaezqFKkV7tqbRMe5d20tutBDLk70n3LXPtVEG4WKcqy4KCAQS9LyIHW4JSu9D3/vMDZVFTmA9ka09TBEexTIKXM+JvOuAgWvmZz8fm6E3ZF1ck59Jd8AWcRp3Uw8tzRAqAndn9PtxGnBHi4NvX/Mm/dbWSW9lh9Dlf3xKVTFMjh9utmlbO6uj2yp01UO676XJHgwzbmeHX+086YhL9eeClXP7ioHqO0iCGhJS7jyZNgfYymvVDe22XPGv+JjCRr2VrCe03n9dFngTsBurjhYRTrrIFN3POHsfuRI6z9luDTynQ3YHSk6ruQrpqIG+j8dOXe2b0O4pQdJL3vjwZGX+zbViGmbp80yPTCy5lZV3H93Uejxq/g54hDjBIypIYNcm2nP6I9VSBxcaeX6qrlP+3OiWWUlAbnlQXtdrl3ycsGLyDNybkpF5syI0N4auUn2nBcYRWh38mG76EKziZV8aWQp2f8oLwaplxRjae64VG51faEo2FjgLuYAUYi1zeNBiKaNDaEHUVjRo9fv87dwuUEcNqrVHpYco65l3HUFnV6uWnqr3W4HddlD4u6EfjjNClxSu6KChCH1SDf6Kl7KXsvHI/8Er8JswEXqEr5YRLs17Ea5z5GOU7DzhVYm/0kpBZOSr6x+zqpV9iHSnMiUBzzkXb1UiwvVRjsmffdoBDZqNjTowDEZ0Ev1pjqPOINJvhv8dZ0MQbNmik+FqP0ijxcxYOrc0hkxnjiy1B/6fgvIZntk0H6SN7nXQaYe6fRzhzSVTjkAz01hNhPBnXW3WOV3S66vQnLIqSvd119Br6wq62NFU4YXOhvF3+Zsf2v/HENxBiWF5syFj13LOa38/WyIar0m95sPAJheKPdMnPGS+5XXM4GskOL1AUtW4BcKQ3JJyZBobPG5Pp2vuDnGpsnIQ8Flfy3tPaHaZ4nKJ6h9Fau3Isa6EQi/U7WEsiMV4ocxm1k9xrYoVizAPYh8dF9Nvi0RWmuYbqhHnai/lbc7RkQe8f/VeJADc5ChaNYEyfK4CYrp3voFPutzuR2EE88v/9Nf+KjqIJwrFXehyFR05jPhkyub8GdVOGWjek9Rn0afbG8V5ghJIpUWFMufeAPQTf/JLjD7W6cfwE0c2jOon9FqF+I1agsxfzZPdTaDncYvvZj65DiS20zNiUDA3/hgmL77HVxbKpdYb4A+9NN0xa1kYpGURLWGSewkKlwDJP4EoxjHZH/4Nd5Ls8n+nRv+XRheZyiXaDCdNoCUpITvi0rUrcfTi2eQ3NWz3gNrB6Cy48aRJHMBq3wHnptyKMmV6x4CsVDOsRIt93/7Hyhbi/XNNmSYe35BFC4EE+m657ZnXPXy2dKjRFxJqIye/lbu8sJqSIELsT+CxcRbEP15v4nVRrkcpn/dCAiw4x1E7hLNzdELkVCDY3+bW/lBzV0srgf6tzITCtlVZHJdOzanvFn5jGKwRq9NkExTZtvpUNEUcevhOVsxDZC+R3xKOZ7WHi/xXBN+IgnCyqjWRLnj7Mvd2r90QYCucdSqTsqKPTFrS9vDsUyegWZ3QaK7kDBVpd+TsabnaytnlP3NrLSjw+OR/BLgNB3Z4C3ZVYfoteehieuoAnpBNy9tgxFOdnhbBHvUl/rlPe0xwSi+cW4rDzxQcEocHyqr/WiMisbfxRC1zxpBKZWoTWrYALfJ2bpE/H8TAzPe5CW2Vg9yn/ZEZgB1qAPB/117npUaktEMzrv+zrI+aevml0eQ1xxJotz563ZD75rm2tl8GdMIsCjgjAEqknZ7dW2+3fJqzZ1edgx0hry4MIdCTONAjz70bIqD1R9kcfEQFQPrQfNWCK8vKD/3A2cwQJxjQ1By8TM7yRS9Xw3Ad/fY2Pu8v8ILaNF5iOGDpGYE8YfZsVG1IGPeRaideH8NvCRk2ycTwgCkqGLrDnUPOp/jYvBsXntPz3N0vuuoORmBOI0oVXUrgCD55y1i8amxzK6IUauNcaVpBLsrk2+KCbArrJM/3RU6ufMSoJQg5Fu4KKf8jix6p5SKYhf68/Ts63awvOqb1bFPISJ/TeeJo8EwuZZ8GHZd1PpZvH8c+RB7mg69oJ3YPqJzc1UNQl8Rd7bC6SOw0z/L/Y4o7u2Pci/a9CNdH36qi2UB6xJfILth0eCfe7necCmWlulBvkbszTMgZZN1ZdSouWh+OcqkUYawtsHPQaGMGT218vVDUapL4rck2AkQYEjRl926S8GEuiS+vun60wIfU0uhMqowVbLohGU6SxDHjFxCnrhIpPA8VKjzmtFC9SFVYdtwBg4N2ijkm9tQ2LRSrwg8vwvBg9pQ/As9DyQ/g9Wdrsa68A3JD47d4m9PzMHJGDoAlxKgv+b5KfPDGZEIifRdmQk7+YaBr/vacY8Srcy4rYaGBI09TM/zKN0X1l+dbEI2Pa9Eo22bbT3KNPtUEAKc951RoaLV5pvQnjdnMKtLACToptvOjpnMAz9uvpALRnwBFv/I2CQKKub1xfreJ0A8ET82Lp2JhrHNQt3IlFeK3LV1ZWOjdiMPMfuPFkWOAfjvvUmq28dQvuWIpeQDFJr0LiTWmvrmf/f2ooPv/tfTQ+QJA6Mf49gVHN6NkAgu4CU07h1vEToGy3EaQ0IQZmAw/5/ZPN8+6RP8CnpL+qIfjVNU3erVkXkP2jO5qGe8G7nUVwVSTzsKypJnENLSi99Dlm60tGCT42uVLUXy3qmtRa+mdWISEqYE64wYBvDEB2UJTlM6rbsvWY8LdT+MXRXGii7KevMyEW8UPHnnScUmoQEhLVo7IexswKF3pEbEvVNCEda1xc5fuFsHwFmbfxCJ6f2BiP21JRzCmI7YZs1PznK9hsArNQT3W0wrt+8Ic7dQmhjSVAVpZrTDu36hGPcUue1MSnL8x9r6jYqL+B9OYuyJJ4MlS1UN+FGF+NuQcWDB/f635V442l37OwM3HLCcYZ8UUPi6DsHoqpPcuYizcluGl84vQdWnmK3yVNK90nOynVtd4a7o0l+4RCaFYWQv+3mgvTWrm21vsZau38rnE/avsTTFl2i3uz5pIGeYCp4B/+BxSeTG3OpZQT0BLQuEUODzzXKQqWItLnDDH+akl413M93LSV8bfiV3PZSbSspx/ad8uAA6mdDahWID+Pki+dW0bzyoz99QdYA7oZlv/f6k9UGuIjjBWXj1uCODbVHm/cDU0WOMMv5/cpHkNQELb9BqzcKPZEejiV8Q4GeInQ9IHgOgf+ZgM/gxUvuhoZtZ7F/HBDoBpQa8X6i7jUypeuIAMooen10c6LCyzp4pyEyOB5C9nudKwqbob9qJlFEDUSnzgvmNJA39PoY7yfb1PvoqVoXZvMyxiYNTC+0EXAyLURY6AUHwRrLSApxzgwFp2iUl4FJRwY16a2I2jmgCaxr7iSDw3uDtCVYctuXJIre0L99GOKV0thX9Pl30h9xYkRF6SzesqPHzAEhwR4e6D9s8PryEj7SlX3iG8zZfj3OwLkLldQIw7CKeqp0K8xouMo/jLpcw5wxxEFy9eeMxIMK2XxGuXGqwloZDOkvVUcMo1KMYywhDH3qd2uxdyM/iCRRD4GgNWvP97iSQstjm7eX6avkoVCRz4VoVPoLXQS9SiOPK2vTXROwooDifHgMCiYK6iBv5h+j4l0fHS5+nV2dCZqaYORbGnssuCCOlWkGBZpK0chpvH4KG59+SNYBHOU3XhASdDhVYgQGUcLkrgQQudyQS1SnVcE3IaX8Mag4TqNysUrc7GFcdtfQKZehpX6P4qxHX2/WTUWxJb0w7+vh/4kdLRuVYXaFtmHJfAAViXO0rxgSilOG/Fi5XiHef6UBLnkVDJqhULVz/D92YVPLuhd7WpM9hKjB2ARdiG/+1fG0j/86qToo2VTF2km+h4rzAK9Q+tGutnVAhbl1QfuilIY/NxX5fBsV5bfLhQ66J4hAkj5H4sv/k6DxcJ6tgFdVHo34TPsBQ9hzw5v8M4rYi1aekjJSmLoxacarQ8XYWGMjwTKHoWtaWIAF0o6DURbhvi5vLJoYqHICiihzSe4AFKDb163qxLlCNFWp7owp0AyhNsCewBmKhS6ZszObL/hAhlI+8XAKRX1p2kIdPtMobGmYu1GfVGR5wsVAFOf//I2j69lmPJTc0uJxx5uu9INY5kkiui3KK6MjqzL7G7YPqWnplNXR6NfI6YSauKoSWdvH7YFkYDwwVpeqFtGa7zfwy/6HBIQ82rPKPyedfCbZMm1wFGxU1r2erGoAi/lXgVw3lX3MhrI3VtG7IAqDRs4VZK+p9sROenOzgG8S+5Nl7dulOAkn5uoIjNiHn29KX0uSacrN8vsCEE1zgBgJFRbtovj5Bez+xbE8ddIM2Q0/BMwLzeR6cYHGOG593K+l1dotmL6jtHzTBAe3bBqrgkmdjvUMcwL60SI6T6TofnxNhSGVtFGYgcEQMFt6qg4MvqH60HR8NXZZctq4hK+QWf+DKiEo54lTdBYWGgIY9aq7zlKA3PLJVbi2y7SpAySXE4q5/5HyQzUuBal45uW68lxzsz6OyPsoQlhGgLmJ9OPa8ujz3Qt91eQrdGWvePx59OuevGElYg/VbnLo6eN4dCPtBhv0uWm/NkaLm69gh1gkpEoODGL6Ivv2VKcUXimijJj+EffQe1fZSlqnYkpDR5/Rp0DCaQd6ZZwjusbsBYvKmv0PsSXFtPX7sRwR2OkRwmM2C8Dg67n6nd//Yg/+SnoBhwt3e3m48h4TVfG8pKAzPfDasvXfNtG1N6261gMwmrpzt44op3jZ2sgPjtFKMvED3+IXeC9Orw9BzJJp2BYXo8MC/a2oDFBIWscV3ZBWjPj3iGx6kot4Nwk4eEizKWvslQc7WRNRxcSr9DoAj7g0Z8FEGbSDA7ZqH+uqgmSEKp3YZNxXx0ZDhiAqxkkxZEKjxOmGB4ff0VWqdAZfhj9iCVxqBQZGvdqYEdJ7XY+GxxU6DELJHRcUHogSF4ohjHqUPrYyxI8pEC831XRFEltzFrfcQEk+qo8C8gKtzuDxLFExnhhYCi9Z/IDAOqNFDA+8KKi4n7+9Tzzbi9wwCK/qtUM5nMqnUEqBidHfhRXAvbmWzsxSS+Y+UaSUPfg9Z9nNiA1FQq7f47lSlylRPvwjwAspDFtwgeoP+TlVgvB6htySyCfU6HE2BO+9S8whzobOZA8cs3NY6d7/TqFglSjaeJeRhqfuDAUO+Jwt8gf6RS+hslY05eQsFDFliJ+I1jmdH2J88uY9MVQdL6mHEHDtFwVi641NYUBWBfK2d49A7S60UkJw3WQOm1kmhBS3t1TeE7/xxMxXOD+bBvFaynqR6mmVwBeldnFxPIpHYqfv7hWSmG2IOVzvMpAA1esn3d7wWU4ZRVQZAJsxJ8O/we6EyFo5l1K+EqMR7pFQ2BG5qysQ9FxaLF3bwSVuMuTpCUFn7jTV6gSP1konqhJDffQbhRvKYj3jZSptSuFIrW2Y27ARMLkkQS4+NcNvr5GDoQ6cm+LGllld74ZSRwLneiCVbJU3ujySr2lSxEagXUKpWechP8nbUmzlZS5HAauOV4pGD3OzrVc9F6hCmhm6RGQTeWxkzJ1HNW6EU9NsDpRU+UezOYdtacIttOvGCjNEWt8pZBmch3/HUdH3L6blV5K9tUVEKYkYyBvk+C3gnNQ3fA3aMHqsPI/2Pj++oJkAsZ1CzBHfn/Y4E84n4nNsxQsjjgN+F+wkhGBRdy1qWfwctiUqPr+eRdNlFjsMxJrGpYTcCJHjVcC9ZQIyJwFxQmOgX6NT5DnipijwufGi7tlmHc3DbJw0NubOVA9aeUHm1yIWEuuTHGGa064/ClCJb1sj9k47RNXPfzV562PUl/V0HJZwGwextoO2jW100M99VQRX59rNHb/VY0UE6LfakUbr86Kvm1YUqmq7QjlGw59qF5ARGegTpkoyJcLS7o7wmVK0tfTZUgoAwKwqudluo5bAb3YTsy3jAr8Ltyj39u/J11tz+JWdcZxdkc6uRd8znhWWfBWx8ngycente9R1+FNy3GGQgEbpxxkzlwOzUxD5EbDw9eb9bFH5GdVS778o/3DraWpbNabaB0rLrGCEuvhC0fSwVuluytNbKbbR4WCQpAgZGqJOGcW9xHKcxK4KmfHIv8Z6iP9V+zcTjp2yw0JGAZ4fdeKSbKtJQaw5dC3V+oTHYpgvfhUVJw4H5X2njoRZ4jZsR8eFu/6fCrZeuVQPb5YK8qR/ByqPNkiie7pngzlTvPf1eCm+WN4x18LlE2IHUf/K2oeEQKKbGLQbcy0DAQ8alj+RvnXyo45saDFEeX3l0rIjeYjLzWaA9bwgzZDyRbxmB11lxKSoZyFiRd0HlhBcHpSKic1qBbVdfGpWhIwpAiDSJjiDMZ27kXQQv+O+sWbUAQkMUKOqI+kBLup13o9la2e+qvOedzZXwiV7Ov9hsfQ++gU7+hqhr6Km9wiPifStbrvgNF4GYwgkBXWovGQ6R8pbzMjltNx7wkgEk31jjJaZPMP+9WtICyzqB6eAni+U/iiAiKPEE9obrFLghsdNRylBGkuL32aaJBBnzdCMvDBHNhMPWaeo3ol349q3ZKoNCYZwgLX5l6K6Q0YwEMnmxvs41qc3KyFbIngcmVbDi/KCxXdolVt7Buhg0LK2hoGie8ChqqsMpf7cwH289s79f2PkBAXpDWNCN8azQNnOLonuqnxyY674STZRcUtxbOkhZR68U8bX/FJ1KcKx2lI0QBTS6VtF2ffY/YkRiThtexsXSiSnZezWFQjE6ccDB/rAxTVqj5soA/gh/YH5l1PiDNfiTXinGgvig+MST/A62q0gJlj9H28TU5oqYgbOtrEmaNTiQMOOqYa/nUS6+Xc/MlqUeOB3f7B6V7jU7rcyBJFhwn2mcVnmbzQbfkVBTJQHrN9NDaHwA639oBfynYI5lKP3UwdxhGE/M9/KskBTQNDMfhtNjeDzZsohEMZUyydcsqhBm0gW8yq1MQT9egG4PmK2n1pyD3y3bn/dXii+fYsKj3Hue9CNGGH9hmkI7vHNUsyMZzycKZCjM6J+Lp8xvWv1/5iSaKh/VNtb66QF3VYRfS7Qgx3o6VNsrFpqnRzwajPlZpRuFSVRFZQNobAmECz3jc64WDdAdgK7aE5wvDMBSb6wbEz158IShefz8ZXczASCmGWcB3q03WkMEe/Fj4pApSFVMU827aesVpL+eYgOEKoMGCOcUAd+CIhuQrEYvZc09TwkXxQrKrOPEyCWD0hMe8bSl4H8Xp51OZ43m3KcHOPdRSSuLMoKWOVeJs8Bf/zOU5b6GWMj2oDBey+NexqFAd9ZJRCxlhCzF+rnptCJ9/C84qyEia5u+732AgE1mqKWrGixjX/6AzW3g+BsRM9MDv3kH9kb9GEGXtlIcdltWldy5nYCiYauPpONteEyYKAkasd6Yc9lS2IHp5sXClo4QC9op1cod7jw9VOzG6qnIGprUjKvaCME3dnH9zYcZc55o6LAoxUHRwEnUjrkb7POyhOcVy/k4GXGe4+dcylPtUV/w+jSVDQSrAfqehqjZhZCXRCKl2d6FyNaCMAR+UHdgsydoO/6BijyqwF3KWrh43uApPLPd/GNOsyeC+m2mSCxwWs+gtbWZOS8SgzG5B3TEFLlTN5cdqOH2KDXLOc1ryzFzIfoZmlUMUf6V7rBaJvbJJP7PtzIFyrvnr3W50BhlABk8QDHXxDn0eA/VKj+oie5H1W1F6ATIubLAvAvbaJlZyTVfiavBakzQeE2vf+etbKrBdiO6un2CFalPW8WTW4ClQLxNcF9caZwhZRyPF3k6o9OWHKwU/wQ/Fx5NVr7/0+TKshxEYuRlN0NIa8mNVEfxYCZV/HMQHp+8kUhfqjugIiMRo5MR7L3Jo+AiRasu+4FCT4Smgr2oJ9andn67SKSwp7FgCZjXd/wVGembGySib4Q2LFa0J7qlW+Ec/5jXGi+BeUqqqVCwaIQ1/IJJoqQIkH8uNPjZ3WxRBgx1IxqXljSE+R/aE1bAYcFHlBfV+f0KGQkFHvsPRTpB+D5pdIPBN4E6uf9Gv2F+tSRCEUSGSUnr1NXQSV/6nEG+rMuLAfgLDPXOdnj5Jq/ARqBDd5+m3BdneBIMrEj9MyJ0K3TCkhtklT840IGLieDq5fSYsuybBJ4FQl4oT8+bRX5HUQLAshjbhE3J3nfkRqwWhsa6onk0+GgTljOu0hwbCS4d4rjpvMBtzCNgaxeiwJaEMURD9LPGVvet/yu5iJlrGwlyvVUdwmdyuMlpoDZYMWUCf9DrM3mXQPf2RAt6+YspTF7bGtrQ3BxPrpyv9Zb2+C7jIH8gvmqX4hcBO9/F/OlfdzJGLKJmvgJnWfYg4T77l8n9uR9n8h3rPW/DnBtecwAsKNOPuV26ssuedXWthxaMha/BJz7VxsbYKJke88c6PHxlKWORMz98iTCZ5tadXDw+583UGr3pT21WhrScKVEdqRTt8Fd1OX6QsCkcXnXF1S9R8tqMejitccSavEESRBg+/4cgC0YfgN001gvNB7RvecZargvFOIaP03rq9J9O4X0RhxBzsVk03X7Nm3qCF9oITwhJNjOdVrYEmvPVS5Jg4ODy+h8guvTIqhIOSqekjTzYl9kvgK9gAvGb24kkNY4XOzEsO77fGuHZ7Pb6J9+oqdwCgPVyF1PKurB3ccvPrQUJo4qPsExSdm6Uf4IQSjFe81QQFJ9yfLm5ZD8UpPXtYpfNrNLiR+oNrqhweaOtfSRvpDKaCAswLwABgpoLbcdAd3uh115NEe17Q10DZQMQKfvuxwHhQyoxiZ90rbBbAV5iew29r6UXsWJL7TThZOEws3h7G+y4ba6rYelhW856vjw0v8Qm8VgnksA8V85cP5BfdyYseuCuqbQDrVXBeiFOx5KFMfXSCe/4CPwrH6QHFCS+rqgwHogl9Ak6tCf6aN7MQArdqUWjpZ/Tx1k+HRR2ln1O9/jY1QnsMWrqBHVMT3wBUcTUgQsw+UYSboyPTn9vld2zC9U9hYmB73+0w5wd3MDIn9Ld7jX3wUiV6DGBvWW+bPb8s7p1gbGFLaBVUIDYG+8C0HxNl2Rm4gZjZfolzdVtATWKQtSwqEvZrrlyQNhIC5Mk1z3hOAd/AufgsnSJPuW8AlE44ZMzF3k8nssQz3Tn0JlyD6DB/TfgVTq5MbJFxdQ7ayvrJt83zYPXWd0kGiaeQOcLD6H25uiuBEd4Ao1jCjBeB4Qqy3llgZmvmeKQccYQN0LUDIfszAs5OmmFZOwcyfNK5Lh/GpWyvhh+bgxKFLRo+2AQ4hDedC/l0ztLLGfkrCni9zpkp6qMoGxupRqUz9tqZDnFXH9zaBySGLAaUR8hT3ml146TmZvFQH5FSiUcO2Ugr35nPCrU/6rcpX06wPQA9oDv+Bk6CjLkYicsTYlNbZPB98JQ4mYosyOfqsui5YoISjGRM9R2Y3fj3w+CuZVIwdOR6A8DJWDSYaJ8cHrUyRmAmp/RHd9WYhUiLAbuQOAVgZqMLfarx3VA3vtxts/cCLE/+k1kUNHoEwSaOkaywYcVL5ID2v7XXocURy6WVNFCCmem2HHu5DYrcRpJ5Pdv2+WhUeJ7aSPi1+AvabF2gppZhH+2b4jKcpN4Ob2FTo7YflrSwTBDS94G+OOOWs32qwzU7b1+45nWnXGo+6ew6Erc0St6H8+TDVrvXJF1GMhM/bLO/ENXihpagYlNfVx59na0EhVCzgt49Dp1KT6CDZ2a7y/zsfue+l5tQOKPTgHp+MarpefWRPHejR0pQvWoYq5+70ladnCWiOiY212pHZYHs8UOjlcqWqXfe4hVvE2ln+OBxEM6we53OQfA91/NGqSVonIaCxijDm7qgP4tw8HBeExwJEhyis8WdYaB3x+0BEid1/QhsOy8Z4hJ26S33Z5JLHevKU6SGsSoKC9QuEzLpBmhMiJBf6sejsWNUaTyFumqg9gNnWnq+R6wNWP7ImA6ycBZtzmZzFLzyiW07Tgd3V1z0jcqto/AIIU888kYLow1n3cCUp2Sfg4AoqZysUo+ZWU1GCXr6V11MnoxZrfGBNiWMEUuAQ3KJmpEG9dUcgXXoUQAtQ+nElnw2gAGuvburFNMMG+Kz2gRAIsTIPzzewsFbUfuCvufqaRfsq2yGcbiV3ahRoDX19om4opk0LI1LJztHuIVRy2TdWEyre2sMp7G4I5NI8hIUd8sNUCjA9OEXEVapfjU7Id+3lm2/5mOSEKdLfXWC5ekTpVZtMaTNDlm5nQ/NToyC3UfCvPt8j6KaA4ivl5BIed37iSBBWTZxi4DUitulv9D+lUnEbh+jYzZ6evgj7JJfPMjwZmR1idjiGE2K2/irgTM/fWDYZTKbC7yuvRx4pitvG0Hrm5JQBucwO7IsvCC9eYLFS8RnVqqNpCiFQfksdHTBE2YDWe3TlQOxfCBHXOZx4uumHD41wQ9f8EVSAtE+f9U0kQfZ4rQwMnS+aaa+Ywril5mSszA6JJVo/YotL7ObiCjwNG6VH7mcnjx9oytUqg7NvV6SyWiEEIyBnkp4JYzMf83T/AolGaby1xX92oDdWRdhrXMRewqFV8MuTE6RY/PQkq4UMmQIi4AOLzoFeYM5f20UxHc+KX6rDvZZX7zbylH2OfZy1EMWbk0giEh/2hcv53zVyVfMFUH3BCOgpJfd3FgAXiR6VRcWvmE2cpke1AlMUPp8pn4pBdSAaZL9kw9XyyxZEWaLO3Tpn0fZH+Woxf59sprX2QkdPB7CwN0YYuiNMNfywB2fTBSLtsZvg7iIx8V/OmGdIMnbn30tw2azE2wtmNmTehH98tgGXeuI49jKQJBmkod4PlO0CbnkT6mEuuqcCFlv+TqsTMVYAv1hbW4MzZwOqGt1McpiZxpo4ZzvFBBdV40WAC0Kd/oB5Q0E+8LFd74IVE/GN3LJXBaFrzNE5gHs/JS2lqmwf1nVrPVHODFo2xDRvKL8CqLpAp77IYCwpqfPhCnWUs8yhuJj9vJEbq3m1K7oDiHzgVRh/FfhcYnh0+Jf4oO+Rjx4c73Pi3p0X10yJ+h6ZzVFfJeQj3dPPMPsX+7QC2VSvQ3ycuMgMV8UczQZq7r8zxMV81YGDYxJ6JEZjzvurQ5jQm1nMSvesiw4r+Lb6hsFRuKc4OW4MJJWdUAeur2nZ2w+vkivgYwpdHG3/RvAS3FuOSsVbhLNpBPup4LRsiQIBy/Q8s3gt1VRI+4MqhEf1MoL8T94PzEgqTweSOkvgT3NK8s20o474zUD+kLkpvuPfBkTESu2Iu796Idwfu+LyfvTVw361uPQvt1T+jsgtiixW7r5koNmpRW/XZlqTthDat/6fMYcpkWVN7WfhIkF8S+js7mvF38moBmF4sKSrYMskQbHU+RLfoNJeySB6X0FHrNGZRI5a0gs+7tpWOkHHLbACgSltjyn/TKV7rPWhSKcAkrAwr52jtsuCPXzN9Gtphpd9RJ54FDjmd3No4jfrviORHBE85MlLpESX/Z8b/Pf1mOGV1F8DtY+ZuiDZJg1LYOpXe1C9wGHtbh4htEDWsJDlReOhnQgTOAeXO9eXVKOf9ULrtyr/S0SW9i7hc41OqZCEbm6tMbAwjLc5Q/+koF7g6PMtQpu2XFdnRIx9HZpY/BKxc1RjPGh5WB9vrntQibNwU0PY47pMqrR8mK/xM6yAc1l8vnLoArQJOoMALFjcKQEZYP8ZJhzKvxnuZvbbQtP/jYFqfj/SJRH3o/jeSgp9SQPnExTRA/8uToLr1RGwmDFCuaZDd0Hzg3mu8TWDsp4RvSstqvU+QzTJO+IG+25E2uEgjRmuF93ZF/GW57pmgAWrJTRpTi0TJaasBdIxE7SgspO5NbqzCQWK5eMg/akpDIIzGlYjPo/W1/xyPuDfQ11TfuGfQLK2JDmxOqiVpIaWj3IxyCCjzmNl8OikgqiYREs1Fw1D6wttwBub6c0pAj+7k5D/Z/U92UK99RlS6f/f+qr3TtBTVlUbsqZi0+BtqLqvbCX2KN9uoKR/Cp1WpF3cHR4mMt0oZ7l6zNATTjxdiN0VgLl5O0d4tjIldmMdE0ucCWxi/JRaXFKvR0/A+s26VVuDfGBkXC9fYTkTqHHQioq7lsmxPtihgRISQSv+G866Hcu2K7iwIWtKdzIRE0NVRqcyVUASpFCWJdzk7XSCI2mMdj3y7oJXpufi//D3uDA9ZhruIRJpP0VFHNgZDsoGTHqmXfBjjEo0c8+ZKiBm29azoVjr+OMIVpiFX4VFuJeTyknE1wxteFc+scHa0uRZXomH1Jd06+eBtmgIp3pnc9Qh2jdKobTyo/SIJ9Bhq3qbZIHQ7qpaIPCotbF622go6VVMtqp6/UalmuD5n8/7seR2QaZ/BWVVn5nAzYpOhLEl1wlilPoIq9bWLPesgECGGg/AliROkq3MyEbC34SIEMnYkNJWnvASuYIc3pc/g5i7oSZHpVxsQsky3spoaYmH9NbdAaipXj747skl5fcqEO5tG8mJyEH/E+nAFn13toqhY/nVweLq89SXdoNLx++4OiI0+sYKHrzeuumo5E/IWtHw5sGHHATeCF+0n1FoGNKyo1HWbt8laD7bo4SloYoHmVkLuCwc5lr9KsJlZvTpBxShls45HEgtMHrYR/d/70qOtv9EWf8S2aoHU4bDhxIJsABAWLsf0CgIOULA+am2JqeJYCpP8OnnRfM8iq9BWYkQKILYtkW0haJlsF4gLHZLo40Qa1mXcendsZG3R3SdGV/eVZBpIMDyMmNdgrdzIR8Fbq/FjI8gGLFiSjJt7SrAFkGZ53oEkmr2sP0e4khfwF9xaRzgemla6niY56KNnK+IOYXpqviU7qlgTbEXpy+cG7ddBvL/IBZcAc2vZSa8GzTI7o+W14B6OokralKkcje1TaCHpqLOt8s7XjqdXVRHRzQBSHCgw0vN35YlM0Oifed9ZTKfneP4IyVfavi/h5rATWy/RB0ODCMrTiBGdwkCthTCCo2mqJKxjOcIRw4b7fVbX+5v+HUT3Hhkm3Yh5gg1Hx9uRA/J/FfzmMpgVtdawI9OJSZQY3UGm2GDGSOe//RAnc55VyzrL6BjG7wVO41g+7zztUoBRel6Z2amplTwhqedyJRybOV6FkaaGy6YEgUOBx4b0BIKpmhj94DV1c2qIm43P7ke8vhmrgRbgJBv93THjAacNBuGDyMwJXUGYHdussZ/rwp5qPF8gIa8LfUy1Z7b6PZBUnpZvKKpeLuc00tpiiJTlaMc2uZuz7oDgpMZlXl2+pXKHHPGhO7deTSM1uplEUxuVMpJj2c9dv8YwWQwOFDGxhgRMdALMEHRIOKi1Y8lFnaipDj90bK7dBqd6X/rIyh9k+qbIbw7E/G0ZO3URsGXrdqjTUTQx/FPuP5mQpLxo7KZyUV+5G4knABl1w9Vpk1AOV7ViHsTPGhXPOeZygJvmlVtHp9Mwm1EGauv2mMdFkhe+KKvecNO2Ago3PURkCUocB3ULbBApg6q7fB39wZE9keGQHCFqtpkAcVIeEXwNQeB7kT2zOsx0o/IBPSfR/A0/QGib9l34vCWczk/ICEpoZZQ7x7wAZOYqrzT3N2GQ+iAJUzWIUxp4+RYMN7ncutpVYYc4QciLEPq41a/nRongAmGfn5RUQd18hoDm67/qSJ7SlrlZMK3HgxZSHltdjR1RPtkH+kKsogIrLX5uXlov2QqR9ZbF9wfGyCbdEUfaYjUb+toILgdDdL/DVRMdrCMOjaJCFFS5B6nU3yeR6ZYSN1MiTti+LoYiqUWmZgZaVfBHZ+kitafXhFGCrlYCQ5Xgy4TJmsYdkcUNNP4Njh59IxmJtRUEAs/duZMz0W6DNoVbHrgi84WCv4gTpeofwvn+ouKo4t2Yfhz/K/ghNAkgsdkNkXHp4AYhlXkq9hcXsedu+FsA0+MxLZN4dkN0KvznV/vr3+3RFiKsezo4sR+NhSnVci3GqGhLL6yzYnsiEE6AItJFeaZhCVEbyoxZVJK9wPP/9smcOtG1kJzQT+TBaFmbPmw5Q7y76bsXVwd2FIcjVwi8kxbJypDmGJA/uuPpZg7ysENxi0K1CXvjGW2cv50NRQqCQ9UTbwxc0aEkT7gOt245qcx8HRnYlQwa/1VIQAkSI5vfAdVutKq9GVDZuGfAFqQc03NjlfJLGKYWWLZTDH+6gUoQvpVxALa6L90byiVUcqzwpHe+3BcpO5RJ86vDiqjbTtvVmsPv7LsNTKecWfSneVgzgMQu1qFo8tm1LsoEYfvfEIja46w/bKHULdvNyKNAetSy9odTRYw2qZJcxqHYj1zZ5NzDrRIulKQmYzn1YXRVShjr9pjxvf+IIbnka56FV5h1aztNOCxtiw8+Zf7BW6IsEzY0iEjFBLctqwHqcuvC2N/HfWKau6gfao8tPPjJA+YTddL/4KjPB5rfPbYWy+HaLyiTK7rI+H5bxHhxgFikLm0OdiGT19G8FMBwZm865Vw0W9H4gbveVx/lZU7lAHoX82rfOQu8KhhuPlzZJRgq5xIEvIzqY4h0tzJTSuQxMjms9TpwMhEEDV3+iC4WAEzsm68f9zVao/AeZazI1IQPI14r6PBW5GnmqXPmQslihuvzVKY2n4ARsTE6FelmpuvXrnee9XZPFZ3aGVD3BVHYKeUF8l+jj2mX8sA14eHwaAhlC2o74BTIaXqZ2bwDBta1es7PRqME9gRc2TReDSBUhhaIDW2U4/eZan8e/Oh/3qZ7DS4YROE2iZ6ihkw+DjTI8v6VCw42BdzlD63wIg8PiPo1h97dsQ1XFcBG5QZqSA6DXsiPbPH1tK6dGTHki/gv8ctltA8Lxj31LZfSqHwrtAn1+bqInAvhWJHUGTMUQeJMqo9kMF13VqgR4ia9srO1tU3u7Wfj9cyBLvfZwt8m3Tu1psdIc+NktWTTyqC9bYVeie9fcJsxuU9KZQ7tkSIsF1pYCI7KQmBTejmzeJrzhk4xLI7o9gyWwMM6YaGxdAS7GEuA4NiAiHFrByNrGdgbBP6xanbLKoXpL4jm5irBCSZZzdg53UHDKbbdlxrTGJr623Ko3wk1bVOWwf3l6onEDRyhZj1jwdBBe1HYNDtEnlqgRNEgstVldtDHS2rZ0z7dk8f9qJLEq/rhoCjDQMWj16d9iKtPBHxBh22tOLztnUSHUijfiAsm+VeJRtNq2e0rfxFfcj2XukEfwEGhW1vEltxTuVIgsd6jmmOADWpHzqFiyXE6mVGrpATWvd5h8rt5wCWkfCO/6wz17EjZt0BHB5k7wQINZOMCWSJsm4HOKrePBn58qgTK+2MNRRuyLoVYWjyH/S7jtpFbWVhpSaO5TmR2g/eRkwSTE8EBLqgPWiTjv5tEAXhRwoxF7KW9CVcWYAHMoyFUuGAoOwQpytQhMup/iL2IGQfdwI8vu4Wac6XVbeVKmlxNAW1YyNuT8D5JowuoYTo0pmGMU0FVrmqUvh9Uk9MVDmacvKguotDfO066c9L37y73RebilxcWuYcgBwPVARhLMsYTRmXHSHE8mqbOIjxE99Gft0zlj8O7icd8nTbmAo50kfsimi9V+5EVGMP0mgvGeYpSDYXzcn4e5j7jFr8NF+RIcUnWX9V5CXJtzsAe73gXA6YPvZB9cBf8hxYzZbo71wiivbAKQb4V+TMj7qg+KnsMqVoNYjYT9xzg6t18lxCDF7a9AliXN+K25ancUqQME67fXMewsGrjtgTKfPxVn61h0JNs4FBTVAG2BTJD1oXU0m+GINgAkaGsqjnzLxzp135QPAZYgrkDmiL8byZOPiJnV+7fKq1s26sG3tSnWdN9sZFiOAiWG4VyqJgfMNhz/w7hafy8JIlJmlOYhHezTeaYLPT6b48/yORmZK0lwuP1inW5B+ZciErKoC1y/ohQnCNzjKFJD1EJgI8RhnGgV+WfKEROVU7KIOH6AsL9ZVe0HqkJmAy1iTAmFuBkf8kgqzxgTnB8r4m9FRDbo8tk+Z0GsPyW9CcuTE9L3vZyGpDzSOdojFnTEyuC3k3CgGMrJtRYq2iH+9GvEID68re8IiUe+wIQqiDuHn8nK0ZiWA08Y6eOTSMvMklZ3fxKjKoj7UYecvtc/1vhGj0O9fZ/Q1NRXOcZndUrCZo3KOHk16kNd14GIKbw82UtCx2xiO29RR8ayKXvmUtNLCU34lA/U6zKW+TtWNs5cXJsCLt4+rBIs3emyCoHIO8hcW1QzWhi5IN5hjswVhDU6yNbvSQhByrkFxcRurKwdZyzlbnnNgrJFDVc27NVPiTsNkinsWcaH8fFTU7GKx0iNKN2CH1A3pOvO6XOqFabOMax0/niAvoTfqyNRUSMTUgzOJgu6OQSboRmxGEavox/3SFfoUyJw/oRNPShn4u+kA0PYa3W84aD/5H5Z+Sv5tpSeEOtUatLsHmI/xtRJNHKSJFCw9nZ/AjbcDr9hxcEHLtLVqUI4/GvcHeAvs2+iQBwS5Jb5Gy6EYjunxgDHI6hGwRBoCi9+yr8G9+tDRNp+QFlORS9nDFQgF1a2l6SM56P0gTTd0UPSkUUAm3uMr1NwBQA1G6HQRZH0mSvOzPqbqR7Kmbuj+zOADrGknSYOC4P/b6tW2tdiJbNBFCuZ02rzuoU1wKcLIRy+BZ2sbHYPNyK+aRufYKQaznsvhs8U7mSd2izul+SNteT7lak7TpOAGnTCGqBjxc6aN/AKdhM3lFu2uI8IOXjGleLrxCrGsRFTHsG40VEpVgPwBgWvClUsrs8gY/vu4mHYJ39Fl4e3l2HOVJbDctCMzSH6WIhdund8/3NrO3Vyubrjaz7vap8mSFX9bT1TbKosMA3Y4rfTVun/dTNSvoPq2SO61kHIJZBRewzMbZZAysoA+d8ngjKNgDVLfPWAIS0Zp+rj54jDxQhWe6CP0Mzr0vOcHXj7nikDF3qy2aQQQ/LaU3GSNnf9auDtKNEF05HVBzcTurmSt/+JoqT8EYhXtnG91cACAs268xzxL6fOU7IhVcoO9pc6pLI1JREBHnxQdwZ11x1MpK9CnHaeIyxpbj798qSm7wgLdE8wOA2tdKt24TMBStXfDAtYxX+CeRz4hyiatzk98QAzp0yjGIQz57W2YjQqCYXizLHCuENataDWtA3U7tPe6heM8sQqQdaNEAZJmG6ylFqWA76JDQ2jnS/2JY6GkuBV8rZo9Mh4QPNgzID5jcemuVSwj2dthDXyDnJqd22D2GqGtZd4iwmJ3MrIRu0t1bNtHl4czSUwh0vKVYHaa8esNG2fa4nlBVlnYARQx+IsbyVM18vU0yJsdsmoypcYdhX8Vv10AqxRjFbw97YJOvAtlUbl0yesXFdMIMNvsreYKZlYiWZ0kSImFOr5pjhGX32dWJPhmS0ofLm5QvrsrWI9zF5KW9Ii1a1+83Lcr+BZlvPVVu4natmBqZwR6NHCo00dVmUXP6Vme3QCANKCbmSdW5owTn+xfxPQRClBYgNKECv4bMcG0KaSoMjQoutUBgns7hkyga534nxjpIKwj9C5TBwh4vIyfgw/xYtwtq1G59Ja7SgAE9m2R2OEVMLUu+F50s/VJEMAg+Mq+l5fNlNWI6oN6M4G0sd4s/6/eRu7DAJfc+DrHF5cJtDpokhhayZiDEOpOJ6gR5E+3u2b/k611qBmQaUa7Lg1agu1TW+OF/O07n2JNW5mS4bq4gbgEhVuXyqsodpnIq26ICcG8Ufn2NH4yYVG0XdvtddS85QlWNXaiEZt74YLJJ34lc3ioQICMydd+E3YxiXxcTkWzddVR0SzYXBwP2zUnXvP4xZbC3OV+2wMB+SmH91W65hALCcBA+ryuAEHL1chDoHUSqZ+M1ma8msJHcRXlWdkqI8txYk8siPqjWogIkLwvXeAMtoGXOMIsV2Phe04UcrWFGo4cnO8VQnnBGBAGN4eiR3UB8/GihXBeHNPhDslMkjmv2Bs7JuszurhlmavLMfy45ARK3JVDw3SnZzZwVcbW5Zsm4aYAK0i5umnSYjqhAFN1XF6LbMNDfYA2VlkEkMVbx7scHC0AYHtOirok5OunB5qqDjXZcxX9bQyaeSaEEeMWKqjnjjWWEJ42xheUIEa2n8Vwki+Juh1WOw2UhUINnt3YOwQpZ7y+LPbj5lF36XM4I2ra2tTBj/mHcl4vmXgPQboPSApIX2HAePpy8p0Bth0pbZ3JpqZSmu/iKKn9ropQGH4/WZXV/0YRFhl/B7vZqWQJO4Me5Oka820zDkUgDftk9gALVkjXfHVE3DY8K/vDJdB94DtU+hQdmPSAgxntUgLXrF8Be6JXgFYTFrxEoVxyAug0bwZbMmSJ+shNUqrUzKgkUPs1hnvgYfxlcNh3qPRUb0oQ53iY2VIdy2yMaAkXeeyLYxfrA8KTyuUX4awwCBeuvREubS/T9xJPbBKE1j52VcGKgjBBT9CSChtm+1cLT48Ke86cI3eFnlNvsZ7JQal5depEgauiVLnAY10UGuGXrmGJ7pDvPt9+auRQE7zjEJ5Llln4dKWDPfSla0xIHhIDpy22d7JfhAW4+ZdJHfbOkb6rktORQ5IP1xa8gizPZ2BFypWMcvS384zmZCR03zEl/ixu+E4GQWS3FVyiORiAjEys7zMeYQ+HPXbAwMbnKEadinc6ePWXmmFIZd/5VHRYTdkH8Kk1+OlmjvyLhmPocynAwZZP3dE1e3ZxOiIgZ9Qyd5btcxyHx7LXl36CWOwP30LHTpfa50CRbIE3PG+s3Rdd7KuNlwQFxYmGhHZfk0IqRSPOvaV2QfOwvFq0r4t68z1NQoIKVCNjEUqvGXpuqvSvpfe1kUOI3/kM1mwIlBcJFM6UCXVH9vLqO+eFusRTMdxDkqsatZ+lw/+woqbvL0eVh0dqzL3uNXLtAHTH4t8N6gQ6x3Zn5VSnkNLvNX7zyrEe4NdF2HJRdD5H4G182dtPJvFaLudxKHAj/o88HMDjOAz2InX3gtIF7SkDQ8wtk6y25oPjmXE7cSiWXS3e2OLV1nQvh1ntBisROTSTaYz6kX6h6RnFtCSfsqgkjOtJRBloSzF4SCBHeHXMyBubtAsZdB0Yqjqz3GriaR+zqZ1+FrXFFAVVH4B2LkhiQ1xmU4cr+5NyaQPPwlSubmHmPLQ5B6cSl3uiWVrZ4XrMvk5g+ZtpRYPmTft9nyC4GQ7m5tEt1oDHUWtGk94q9e1cZuHLaxIpaMdLt5jsS2JLUMhZQ2HdLBAldhMrHFy7Z+c58Bj5BgloBd1vLl0VxLATmzG4A4cR2gLeyrDycqwtpcWCjFTR1X8kI7FXJT32FdixR3bibsfXgUpy809ZROJZK+kCmGF8ONa4g2z75tMCK0vg/8MiACjQ4jpcnB0Jbp8IRbflW1uSQipJTdwnh7j7iMukPzRe8bBrgj30rwXY37MkSeL1UG9THfPHzc8ewxJbXQQFqNmxScVxHQCOhAQaC28ij+V1WmKdv09UrPQ/UaTAlMha7wKn8WFzVJwTzmGXaTcohRDvepiAVK0afmt0/pxAAJ4KNkN0buGotKboQIDPAvJLM6A8ErFczvfU8fEVsmvu4G9yvFDkk44x+b3DQSdcjOdmh1FEPxLbY/aEGnpgras6p6YEraxqElWvLapSR7czcWoX1eICzDTRHu0gBZ6sbdUOvYHRCU33HAH7Y68w2bYoBE9GIeNVC0E9LU8TzPeHxQk97hcuv13t1dQim5JP3qT+u3RVO6IxVhW7EN0iu3Li3b+H6fKia8Cfb1vmSyMBV3EIghXHykrrdXNo1LUWfqgIpt56A5Mb6hZMpLj/KdJf/jktt0K+SOZn34ZAeAil26+AwFhjBmDpmn7YACHexklw9Up9OFtQOYKmk9Va9v+RpRBjh2XCogC19FInwPL1ccSvS2Z0C+JEGijGNlRy469ACIwg8AEUFF7t2sGkb3qGTCTPAKLAP+CrDcE2W1MckoTGNKWGQJ6WHcBbYOIIRsbtlwAHxhTMh4Dn2kOjWmEfY1glqFketG9X8wt3Wlz3lgCTsNDabY21qye0Es3vqnapk5zQNejilm4a5MMMcMv9KAPG2WzaM9WP8heeBc2grT1vIRIZZAJL54MzqQ5D5Fyc+m6NVqrEDqTEnHdh2zwW9UkHSFX3sih8DzcIj1psALcjnvjHBDwHO4YinI2EtjnOH4Sh7xYvdM4oNPr47TMoLLLrutrJXFVpxNDHRF11ONGFeTLl6BcfO/GipVbqDZHvvvKK2xUDYvnlzMAJro1brtWTSEmz6iYRUoT1eWXGZ4ESkhPm7w4RHzUy1Hed8FmmZkm2ENMeWKPCt2diziHWR72jwY7YQk1JiLAXWDxPzeDk+TW+VoY6l8uRfT7hKiPnsWnAYuOuesr/b9xyVZHKTdPdDt7Yqm3f0ZXPj69s0Vyio9nzekSvm6gqMYsNAMk/uoJJdLOOF7KPibsjFm/lheH2earMPHIjj6wo2taP0W1DFq7MislEvhJlifS2m0tiCxdSE82isgDSVlbSSyiS2pg5Xhq8O69ClGKJ5i4TPCaCtHypZ8TskLMCIis2GJHm6dMnlUxSg/Pshl8zyMQboBV0z0uMtbTGc0H2/XENDIz64qbZrowfAThAbJK7+UT3mJfMGP6YQFUwrW33pJqYLXh3/cZ4Dmp2UobcmVxKhCif7lrLUG4c6BlqgryOOwUboiy5jZVdPAYucwoIkizhI6DFtmczsAheKgvOjmHPTs9XEL+2fzdaxPHAMsdYn0VkNPQYEVwbe9X/5Dm4JQOmz+xFGSqldkoqAgdja+t0cHB2eET7mtvOgSb+37+c+DgidSGTQVeNWsyYP6Dv4qgmlm8VWySUQL1FhoQc/xWivB00WltU5/SdWmG1FJgbfNJOckJDWYC256lTFjpw6yVzSLz9jS4ycMbHWpzm1eyu/c5MpiGngzpZ+wz82IgcS8ZVt/RlqMsHix+l14yGR/L18mrSQeSglu3bbR54do+8MrXEjjJQM0sxXD0GaBcho2n9m/TUHIgC/1IVzKJHxAIUuyfjMuw/KHtAermbv4CCUWiHJOd+IP7PCVzVJHAbXjSjFexkrNeoeDnEHrL06qlip/1ln+TUkaEI+GnTVlDhNDFP4XCzXlKy0x7zhQegTNhAdeKehK5uzH2i3sAz3VAP0PiN/NfznSqngoQP6NM3ig4/DMLDizCspUboJLqvvvja865boqK8GZH2sYn6Bg7Crb4PQx/zQxFdST3TruHLz+IbpqLrqksZDmGVj3Eal3mL811VHgjqlgv6QvH30RhGooJaSjUi394D4Xw9jGLiEiOoupzeXXZY0M3drQMjJHkthl4an/7uIK3NvB1wXJz5SPJFBEWWxfvU9+Ff8J7n9fSOttBlZ3P+lQm6eRZFfwWmDvk4XJFOIGWc6zwPH8f3t9xIoQwOkXmucJ8jHLM4fpFzbxP3aKgKn0JXRjFJaz+bVKRbgNnZyE+eMpLQXBnQ2pHYYe67n9Qx65dbLVRr2hrh5zpRVOPy3QniN+jv0/ZJka/2cbaNs+YBVCLQCGqVugqXAqS8oxq4lhN6qm2B2N4wgKdeM5sl4apvqoRsO0YeO90ZZe5uawFtQ8W94Z1EBBhJ0iDmLQU5GaOeAm/lt++1ULlTrA/pfh3lG2LW2z5lDqF2naqMrfOJVcL4qXDGgCp/VgoSTc8+1tHM3tud4jB82lLquBIzEjY/KuJiPDs94PsaFGf/FKVMNejeIyRx11BIqE6qRkZsRa/PKe9V/afHh+VG6lTSzX39BzLGicKJx3jiJUMRHtQTal2aU3Wry68Vx4Y6hTMQyfL41C1cCAzjmm0Qe9sDOcwaS/1CWAlZlkHCvFITswxPIgJmmSKDhJxO3zeXGruJ0ijI9A3aiaDujAse9h5MPwi5qyvnXlX+DKQaE4ubRBcKWNiQv9eQjp+Vh8Wr/v8d5i+arLdnY2srgPKDa+ipqNYvIE2YAOWqj3KbfgPwyXMF30dW/3eExfZowU8384+vp+JL1YLZGjAR4SHAgB1Ayd2JEWsf7zcXxnStW0gFNnkTN//f+V6Ode4vb1JEj2+pIOfeSRE+3QKu9gKtFjVrfdT0j/FCLBeZVPyQsVvULpM8YP/Y76u9p2VH+wfdY6bGWcBMbZVKs/RQjdAgvhCFTV4Hw+MN9J/7xU5lqvndOiYPTUXdBgzXMAvilOu+HMj+FLVZ5/pH2snnm9ROjTdV8Fi3IomJY0vO4liujXAAieIbIdeKz14isCaaxA3kb8t78593TheL3PTEF4+A4g/KbFb5TYk18KOsgj5WM+j/FO8a078cZ6uIJbZnN82RG/SzAl/QEjLIjXI+wGM3T9e3TIy8S6qDBoaIWf0sEWVlc01p8JAhmNNQv3Sz6K6HDx4LBroogVFBEfZs51cX2XIcGgAKlhr1XR7mOMcL0jZP5zs9r/LCSRkhjyuWyl657SxpFJIjv35EB5DO4ZnvfCJsQFHQGBjkV7XKfR6v5XEyJSjqKJDk89643mUTlBKnpBFjcCLtGniGQXe4a3+IhLL6NiyHfHOcT9p+uitK/PDmzYSlzwM2LCRXhgV4BXh4HdLekUagWFS7Vs6p0klXnhq89XDPNJw2TOPZbDfh7uCSjnXHrOVlBkXrcCH7Yqyezajdd5f4SFj8YnJvuMFrzyJQc5beMvrCL5M535vsCO3RvEE68CwWlBaFbqr6QgSEn9zvQrMWSBpHriM+LL3uDanDDAltzE4VjWxAYw8KTFCX8bleSUEvZOlJ0Y8AUPFCbppeq3lE+9qZe/1j8U8svmBmOj4qcWsv4D23+uNURj6Ow3EuOGXTDymfF2MOH34pMsMxmCwJ0CSaUjEV8k4V2FEMSrN0YeLBYjvBjKNJehBkKAieE1/IkW3r1yd5TxGps0jRHGicXrdWcuXMUagdRZAw0y893EthYsf27zU3p6eebGaHdLHl/Y6Gvn2jeWuH3wY0HIIZ/qTjz9OYhp1nMqQeqeqy7RgVY09ZtJR+pUtjlHgwvhEsScBvkxk1e6y7ljWBQ/q/HaNWa0tcyqLNmoz2Tyan3RHWy/To8O/aD1qlb8cJbhjiS56h6MlyqxjeBkhCyIVFW/V559SO02SV/omyQCsHO+EWt0PJeeoxnmD17/IB9zn9wxZg4Ggz2+OZo7+jOIE25toM0dOzgNmu7i19iR2JRihYTJshv+YeUmn7rzYVNDRaAHx+aCbpFfe01PB2rjWMJtyvnyLhQbKgMhvGnSz8TrprvqEJeaG26XegS42NafdI21cax5FXAqFOUAp5Ek1d0lD+Kqa89AKfv5w4xOPaIJIho7GxbM70432aWjrU6LmsYcps/WBoQY9u5wL4xzaBJgBOuOPX1+iswwEvSijDfwCeTXG2XmZiKjOGBUydPx1eCJ1/JQGee5NlOHBQDM9ct+f4fhL22iP2R1Qk8C7m7KhGIqu0Woq3ZaV9kg3eV7ADIGtojLWUOQAllM599a2Ww9RqGoZKMRrZDjJWYtq0qKdOIr9lsbZW6KdKYZxME0A4uZpbGT7GudvvIpamUi93qUeiz7yTbpH39KHjVw5Ppg1hEoGlnUgnmzVh7Pd5nuF8B2vblwHFsMfppsiGwyM+wWtdq3c67vhpElT8giP3toaggUfUPyjxjYzj6GCunyuyd8pYP3QeC0kW9Lyvukbh/7/UkLeiGaSyhvgsPLTiwfluD1hSEshefOKxIxE8VkAaX5pVgLzlOZD24yLg4J87tGoYUHcToinJKL/LzPXN9l9qZYHZDHsNyiVKw8OP96xMg5iFIBFER3ItoPojMY3J0FjXe5erlr/piLZOcxVYBEVjdqmtPC0G+uLW48Rhp3x7vCBBYMXdYiEY3GcDJfRVcg1xNXUEFAWxJuN2I1jf/Bov4DolaFVcSrhdhFZTGcv83+7nlL7y2EL4g84wus9TxUfZHq4EVCYq82PJqYl2p6pWuFS8tjRIQNx5O7LrOlMyuLFRY+NY2sZOKRQ6nuz4vy6En1ZxC+8zv73M8VJ7QJ023/+0MtrehXK3nBYhgokxyy4KpexDj6sc1i6DjdZkqQTcah7bXUpxNIs9tCSofEs6/waH2wZ8W3opc3cGFTgToYllDI8wyna0TlJL9TzarQjESpMZ1dYGGA6zs9iK010VBmFB7hj3b+KEvmoIzDsLXNuBV+m+7YL6wxvGXA1jovEwDglET3+eE/v2Io6vETxz0wAfNIQGkSfuij3L8fq7Wtzsd+QFullFkzdlnZoHK+wQBoUAW1d6JjfhDUxr6Oe/UMqp6TVohWsRT4jVBOxkyUhy4psGGHR/7jiVjaJZQhicG+FLOkHrny8zwGQonma0wRgMZsXlevAJ5lJrta48y6+90ZFBNHXlLGQZlvImcZbj2m3o9P7GMNFT7QBmxSPoDExVRdezaYY6gSLonS+UHi07eiS2TBldznThpYry0FbDHIfMsdS6LzeqTpAkwlr6fNJsOqNakndmGvw7BvEUne8a17Rs3L8iFbiNOf/jKJqgPQS/W1ZSjC/cSygz/ssnyTgvSqD01i5eN8AHdNs/gao16wM42jMJFrGEAE5n1KLRekk7f7RBzAYxG8h2fLO2K8zqYMYOT2GubmOZb5OAFvzpx6BAyZv1bE9lUMMQXpFTtvCwqNwgyi0l0HwEeK5jJhdwiR6ZQcI9Mg2+lrWHEaEqWsMYXQoErfFIWtcdBW8f8gZVhyicD0Adv9yE1SFjOk5fHFbCWlVTHBLow8mxW8hwzVeNS113yqwIH091AXKlKMY74vfcUGp7PFh0mJ6txe4b970AbM1B9ntHfSyMMkVQtSOijkojFmnGko5bPJ9/xvU3Dk1m0LH/gdwqCzndvKcq9y1n/d41//UFgmd1T9a+4ZJyGZSmHqacDJJHdBTnxvdiueh50han14vme4qb7DRhH3x82da6hQIyVGRLm2Kk1GWeuzn6RFVC5UhorINgGLqwY5Sa7K/N6h1fQ3c3CspLaSXSxq1/KvLip1hT83MOx31+WGp7/V5LkjvvbqIKlWQNORSKiYFx4VcZsrvQsGMhS2qp4Ouy1fGX5xJ9C1GAGEdSZzwcaiO1ij50teJGVjFaFefAUF8qpD7PBQK9CXF7lqwZwCJUEY2y5bR2V9vCRBulaJI0bRkHascT154YPUsu5VIBhLA+IVw8wQ9WulsHDGAA7fiPTLCLCfy90J/ct9sqogA8xUtjhPOkCP2X9nqid567z1QfvnhJ/jrQtrPOlHXxwm5+Ob46EktG3oQePlPxNeytqeI+nE/LyQ5u15Y0MRIYoGPG4kWKo1sxQVqwe+oLr3F3VihoUGTOgw0qCZZuZ9lGb60x6a8nEaRAPYq96MBu1phE3pkuzN/NP5OxWggSZ8s/jUFF7TbqFS3FjkxZh+vdqhs1LBFLNrge4IHkE5BxgiRSuNuUDftPjS+bv/ELceaurKSUwq9nu7MOq2o8Bmpwvxo8YwLDx84bVCZQ5Q8G3KtwwtuKfoLKTgcXPTa6z54ONnr31sdY/pNENaPc4acnn2/1KF8k1bXg9c7H5AyEvkTcYSQUo/lzpdWf/6YlcyGLvdpLeyPv8EoPItAVOGkHXl2zmiYArYgYVELXe7KNCzLyYG4W05DV6DEQ6KyVYPq5ci6IcA+/Fjz3ID+53ibSNHc1qetlz7f+H8bmvQr1g+OuDzUe3zZze+mB+DtZ6ELe5AMXSAHLPcanEeLcmmfLu86+rMpNhSR5ameyx38IPbLtxezS2yXHd00TNo6puK/sYostVIl3dN66KqPUiDLX/4hj3Dr+xlU18Waq22tH5jA/mKbrH9+4aBXJDNzmalVSE5uAqIIMyzSvxzYrCXFUuq6XPSSZdNB5E/IyTv/YEWBqYDpJnFmntUWEWFnW0eLd/A1k0ZTrA9EtMQJA50RRmX7BnHLoeks9qCTKHf2UkIM6i+V81ZStS0vj3CUGk6p5uAo+8N0JUl75BBQMwWA+9qabRBN5msOqaT8/s8cgZ0MmXzR5uv7obnCnJ9SqSFnVeGxh4Ab906JMaZfs7MEcJ9uJTv5V5XelZpcXdW0C7QYd/K/wmjesDRp7wXZSU+6YuFJ8HcJNwL473CScXILhWkr48bEhiFpitoFN8SY4I9k4bLVwHDzPk4eLPwoJDP7Fsl+VY9yymDfngwlrAkCGVEcz5MUCp36DUABDYXevqBv/XIGx0GX34U54wv8ixRCZ1i91SuqU1rjA4whR11hh6oCn4DzRzxbXb7a7+/MOXJ8z1vpeDBh5ug2SsjIihoAJqLFPMseV4cdgUYSzDIx8knstVtC3f4X2PBlHcyLFCQ8cl9IL56Zu6t6DQsZ1V/nYPECOJnlDfy2nn3pf27m8LqhUM/mAP+MbD9eeknzd5owd6wHvF34gBRzdPacpHkxFoWovluOh0LuQtyo3/RIE3sbBOsK6uWWZkfPyqxA4MxlphACb8DhiNdMn4X2TnRKd4EREj10gewGBlgfjYSSLy32F2rtoj2qYrvsaFJbN/5wFNuu1OYS3zSZ2dyJBDbLS/tayMEL0nGpkjtBYrEHc0C5TU+9mcmj+CX1iKodnwdSw7kCWBxHUFdDbWKI+7U7Bm63h+xd3HnSnthEFFXCIrx/Av31xFC245gfkjcjh7+RZiaOuJQ/zclW9PBldUXsiQ2e5fUEZv4oiWB1th1g7hduq9xi+Bp9cCwSeLsYuaRiqUiSd2xfziUFOL2QCOvEmoeJQlqSOVyaM+MUFxnOht1cTTRG6uDFK/wu8QOyYkGkN/DYKPk3if/Lb5BzIqzBC5vSMaQibfURFcucJcRKdJShVqivXDJzM4vSpI0ntWJZ45IO2KAAEH8KguPH2QZT9EqCIjM0TZaTKdIVUDM8MTfyb1lRg7HcaWsC9hYP7cG3xetJlhqoSMvI5SI/AOOXu9xbknpiQ79EdoUkKkXYt6eTEwe7wxBT4XdRdVjjeWvYh9OgErSvol64LEQtwWi5a7Of5eyUcg1jStOUTbQ+IUVYrVMWyFockbaecmyaJGYtSMvdX3pz2mKq0fpz1VEDGhaEjDXi1OKIEwZFHTSp5xM4/GYfBxmHI4bQdyZfcPgYYkEZSY5iV8owQNzejIfTqKqA5ww29TjUNXZYcTbXghUdekvWuYurS5IMYN3Wisd0qYeD7qjKHwpckLDkg69g0Ki8yfNDIDM+EOfe36NUvy+ZxWM9UI+Ic10+DwzCEJkA4UnIrn0Hts6mo0jAw70tR8rnPvK6JOuhqphJ+wcvQKIenpUdv49rXjDqWkiE6MximkIHlDxWrTINlhnncoFoHeLlgpIIwCh7Wi9z+0vrwZat7iAVunhYPb8DRdmT/+EcP8FJUpL9swJ53m2CZDN3SGMG+Ie1SNIUaRr2T7hf635JBMQDi2wERCE4e4tzAYspgdP6UYyFRzAFoq8HZQfE7MesmBRgh+smDyE+E93pta9EyKnYm9wUNnT1FoNQ+uqZSAkRXl/zHHIYkgGoyjz3lbIOosK2J3TsGF/Jqxt/kfGCW0HJxVS2W03kvSEgeHAUcpH3vTnQYTEEJU4A+GRXwQ3BQFB2+Ihdtz5mD5O4815uv3WL/ulv/wj3mQ9GbVBh+y8p4aCPcU8W/+QJwAowdLY8H8aWdK2vZgbuS+WqBvp07ZmOEDYEBI4j2q06nhxO84Uw8c4q3maXbmRWh7k7uX9a/VLjfY0Mo6eW+p8iEgpytRUDnhwTczo6miqNA4rKrF+LGBmnacQ3wK0v40AQMp5B+ywIOaL9G5TbjNAX9vUeGhi2Jn3FYhbxBW5m3l4B28whcmptdYp1wBojnzEFgZrehsfkt9rcsh5zF8IMHGFRam+DMG4wuctFEsRN20+Kc6kALLpcrMc1sFfMkE47HA47tnBPC0CUKYkg9DwNvP5o4yXs4zm0GDtHgeOvEEx+wijIWos/VdWXaXHj919CyyCLbP3r1OuDdwe0tI+2RXfs7hepkELmC02KsDoNMgYG07pl+ifZUSY+ybRVtWiEk8RbnwHAqyB7CASyZmOrCgSEhpYIi/ewOsCn4nWNWlNnq+q8U8AtB9kIxa7Ef/1YVugvlmnfgocEsbkB1f/Y5j6FdNf01FQbQRPIPHuwJLQrU7i1Bz6BXgi8rBhgW5AKxSyvIs6tIVHk9ZradIZMi5feVPyx4mO3LMp1eDVFcnMx5A5j3f1o3AGgV+28ndGBuMXdq5adY9UCAzv8j0RsSfrqyKN+SqOvtU/VyMnFKAfUi0gr4s8kEMnh5xXyOqw/vZqOQDPCqhURgtpR+BGIBK91EWBROD8P5xgWuETm2WNg1IBPMVzSr2g2Ij+DSs4tTqhPlOAyaFPeGSdJbwb5vybcjkAre/3sol1z6Wbeb63zS4R/MwrIZCzRZV0kcQ6IHtQtovxYEJiQXqtgv/jAjinC5t5/83jMTl4hExDjnUPa/K9SM9ECjiI9wre5M3Xn/MY9ykoCKQevmSZpI3q7dtYGuFZ6JsVLFGSUvaeWsaiI+0g0bMlaWtbLL0oEExq0t/IZryR3UMS3vLMMuVXmMy0xHTxL5i7FHmfX2OUvN3apjIlcYeeI6XEZkM76E338OE1uKJJfaAjTVcV4s0wS+oLH8+Mzo0MIj8dgRQhLt1EHAiCFASf0Vml4nBbpqFw3amJLIOdl8hqc0IBGivwijTmXR1iskmq4lZzyhRhjDRPmaBxYfsWoF1e2vQ0/VecfORPqu3xAFvFMp+flfFo2VxhuSxpPLtIml8pT56RC58tuwR0evRD5T4k6vZT+wsoIzfkGv00draxPskx4m6DSG6OA90nV6AlVE313WoaEwRT+0qRvXbgB6DrYlv69QmWzxzoXTAXnk41yz/0H8Dd1oKyli9gaIsnZ8q6ZtWzcP5uyQr/B9fSU8ODAK0/+1qFHQFvVkczMQ46J1LOuZ/NdC72zFfkFJFsJr3HaCM/pjCSV6YtSGuLR1Kh+LaaWXx9WpN5rhm6Mq6nRn2zTnk7yn/nLlBOIqwpHs+VDsZ8C4yT0I7XkJDJWgaBTKUop4xwkeelSu20hPaWvDV0ZNn3UYfaAStPF5/hETM5lzmte/lYms1KozalFOaUtvfpPFmEPIbttOWHysY5fkSSPDiUmfahO1XSw/EiS7bVyp3ppc3cfA1GS8UU3WumbGpRmoeIyWsLJ6ExYAETomDYjZ3bA6lrCd2PerMiK7pRqkb1kAZaCilmbZ2G83g0DyFaw+OfdSeyreNES3cZuQZXEalPKaL6RZdt0IiVf+GnFsz0KY5BlcC/iTg+v/HBm5JIFnZz0tJzD0nqodaKch8gTNzbW6soLgIOGE/rY5REuULl0Zla/bAkVE2yt4XTru7OnxyaeIFAC9LlzrgwIrHz4N1CDG+7k8NjgPq5WdzjheispAfxfJxf2J0k9rG1qssvVzw/6AYUZgpZd+419c6ASoUlsHw84qFAwNG0cRu4Qlj4n/F8GegpKAoW0UR9VuorVmpryVKNoBorqsfFAOm24RZRGOpVpJuEfoDQkCh+/czTmCizED9ma2cbBdjbfX+io8HqxEj5rBcNksimPP0WhYbhs2/NlSVxB7LL6fo/ptF47o5KeDA6uRGEOXAwgb2Wx+FRqwkkI3FyIfsx4DFI0d1uABck2JVzqsBqUIfiXLseyrvoy3OdgXqpW1zd/m+13FrBakWWXGAGq0+FlDlCsUsrFeuRz7rNR2JqdGN/94w6PW+X8OGvDrNM5Ms5HTtVzwI9foEDzgDDWRbsUdnJmQVXXDETpgXmWSdtlM7AKJYo/4lk/3PuJr6maq7gwoSPPdmPygN4GutSmJV95uuITbLgQ2OmCQ2e2TdaE+mhYybpDbNlaU1syJln8WxKysIzI+qn1Mv5aA2iDxBNplF+MGnW/yulUXYqt1bsj7s3vxs/t/aTcSDyFB6c6YXHtxAx4cYuHCNrTMEkkeqknL/biFugFS7Dapykt3W40zaSUIq9ml3bxkiFnf9fbeIFdpy+6XfBV1T7JAfvPCr2Ltu5Q2W/kpluRgTRzcKKBFfSGaHaZOEwsTtM+2Wfgx/ALm6bu2P5QfU/XtXMXPrdxHkQiCirBnukVPCrSg76S2cVlgyIx6THkQJitohYH9D9l1TMh72UE0e6DwJ0B5D2Shg/aQPeLgdc4u97zYTrvSwUMoB0QUe+UYozeMyas2hTDBf14kgE0op+g3LeHHT0tkwuzeMzQ/SHIrXGVhgPIq4gytJsEMnQW9bW2sOABkjuiUGNw0faJjWFP5sBHkPmucELBkpf1wsAID1NHbZg0KqZAK1fKhfDFqx+wxwlWA3088O+KjCdkEnU418lRJPnCbfdt0Dc/+PBzIQ+Fwil4U0yI+zLxDDNh94J1MrircmCaKwuer5U5u+CKbbH+ncVo88OB1JKuoGHCK29oPGyypqyPfoXBuDU8f0LTIeJanbMjBxy+tGDZgoAgHnAmYiB/z0fDRNYr5e+FNsiHNQJQ1cLunnVQ65lDY73kvH9pSjkbAZyBV8HFysBT3KR/e3LoJXYl/wzPSFzBacvP1wU7Wof2JtWrj1T+3etcS4IrP/ns6Cr9Sjb+2q5rVdBjiCK5AHgqFHg+SIjuLwUFyAH78dH972K4yFUMSPMj58pigtuWB9PpO9HkwM8/4EVFv5gFW5O5ZbCpD0+9Pyfl+LKcak46qm4ZmNt1XISEPhMbEhwkiXJv5nDNEDza3tOuhhaNKCfiFjwOrapqA0Cl2IA8K6c8sre49TN2eKLAnI6klBHyqfCEmLbsWqC10UXXbA/CtV9yVI4JD1IAiiApiFUF+fwtmJXB2uE5mDGV/EZ4rX7UmbHQpCIzXmhLpcPLaU87tRx6EEojGNPs0SqIBYBIPjrCm06FAhm/0VMtBT4yT5iBdf1UisgflJQVbVybQEpRKrtQqzbmkrInpJGhXVoZp/b3FbeLgTxHqYDQInT9sYFUb2A81aWHYyfD2GgQC22xGPt3fr1dQ0++K9ZjES37rcBGpFWM6unU7FXDHn+vOU+VGVbcEx6lY33D6+3wBH2qXwnfGyD8HpXXSopoolc1fQPoCmXovvmMn3DI4Bmx6Qj3zMoY1m0uE8+0vQnLGx6+3vqguFkuxiZo/pHCggeQDwX5ZouJcwTyR+5D1cgpKUmaVkV2pPrfb7y99ttv9TdtF0Nv8oOEd5o2Q1E2jAgMB1GPRu6Zs/vLY2OptEL4W0rzqTeuPc6PmkxRFtSqnPGqZXteM4HxqWUfdMa03RooImhgjkYnlHSrUAt1YPvNBZJMXbnhWUy1dYJDcX+7Lj05jzmq8MPaWQlgTwmIRbl1FPR3FddDXNfGvcNAc5ipmjXV3GTW3jZ/JwZyhbi4AA9/vEFni72WMlMGR3QrvkD67/5MTVVdxw7ewSQqzpTPcERIgm0+40NdIOs8baXGmBbLnGYgpEkyF9UM0Alna8hg0O1SouRVs8NB1gHuI1ZVwQdo0apRO8oNSnfS2NqWIt24TAslLgSZYgDXyaMQFuBsUt5UB9mt3MTvDcHLHhSjhtkkSUoLM3C48EfTaTilXQRhzthPuh8hMo0EimJd0aj6jnuHJL421M0ROZ5iY2ROeox6x8zZ6ghkt2sqsIl0Han7Fdjxz/duA1ONpUVObiOm7PjvI524anEWiCGtj9WEV2F+cyaqO1bI+S/R90otjf5Jqh40sPBBJ5Qvo4Fxc13G+X3reO1SBGH4LbL22X8zZ7mEeClPhoDXzefLgcUwe0oCRv913YBc8Bpfi9QXCPoD8GSHgn+iCZbcwLK6k4gJf3LRKzKpEog9S59BtFslKQnepwfziiZxh2NcHcKV0vC2XlrjY5xHeUwZYCZOlnMxO3d/mA+1MvWNvabjANfQK+FIt36bUTUxQCmQXyO85VfNUFES2tX+9XnNqHnvN9hVHkVZcI3M6G02JT1WNQBC2JbD4YutaDsoE6NDruTEm5qPbwCqDCbqokZNowHaOiMWwzxPU1XQheyYuHuUqWZjmMcnSyd3+WjzQAKYe2eNGhBVkHb4x8TcotWirt7YF2E8mwtxktVjUXtxMWGCN44uKwZylu5LbXLExNFZ+dEW0HBtQSMsGlcgzmEcNcRDjvpy5DQGaxroGMSvSWfB8DFf4leErt6eNIkijRRt5nGe4zyi09tdkCHXgh2ODRKUqs/GC7gUyJmxEs70J3zmT4kZ+3ei5CKnagMqJ/T2ld9X6OdDdXhnSDf9aKuS+J5k+9lw1/8oQQtUqZ0mScDqboajlnBfOZleabuAW1oJEAva/5Vq4cJjPkFUgqL3ENH+IXplU7OkZHSqodmFsO3TuhsNKV8/B8LLRxx/Fu+jbCM5X1OKOPEZcRTZ1ChkuigdBgQK6cbKFfazawPY5L5aTKAJcKHEKH+w5TcVN+5I/Fli0h+5yEyRFNyIOISszg5VR/WYH83xYHsTL64pHBkwZv6CXLGQVF6uya8wdldo0D8L9tG18Trb1ivat/gOQN0F/DjKKnwPJeVK3nEsqeH4lEwGqF+xLzT8YVI7D/Vvt6bcm+wXpdba0wMzoUnp7yzQUbgJd+38LKn5JfHFcXsCxyA4AQLZeiCjXEwIiBbaVumi3beUff+y4K2shCv7XgPpWe0FtK7NMQkwetaotYA7T9rRHvM31tRGDQsj72jQR4uOB2Hz2z7DJzGjlKhqKLYPA1rulNzwbqGbvFM5KfNVVwCMdgSV4+UE/pCvGTlZ6ZwtoRQTBw9bM6HaNHvU4Mh7gN3d3a8xj2f5ejH1Qu802deUSeobheVLxDFtkK5Wxih24amZ7grY57CnCwmQRc9nwqV37eI1nfM/Xw2amnEIExWdedG3DDAqN8mq1U7SNZb/UuohaflPpUCttFagQ0RkSU5Le+qIfiiLiasY3maFQInlMkCObZV9z+cQTwGPjpcHHKwXU8Zh7YfDQOGQFDf7RAARPAnxwAF3G9skeP7irR4eBemdxurMrr63/LpHqx9rRKq4KnIsTdIHuEDoKt/RancsWV4rTihIiCW+M7iOS8ERPF7MRPzT6ViDaiRvJO5bZQGdtzaICKkwYv1ibutrQ4xklqIdjY0hDOaXChjEF1V7dai9A5l6s9F44ZMfaleGPky8/crkm1PqAdE30M8oTIzTNjk4bkn8fYxDjYdL3vEFZsjUJnHthes0X2hdmxDBtHSJ5CGMHQkp5Vy1KbHUacjTKLzfPQR5Sl1RaKJbcQsts88TExqnMEZNW3YVsdavcuAOdkAmFiKY2atgUDcQJTuiIZvn3XJzKXecsAL0F+DqkcuszkGmMDbJ6QC+cvy7AqOFpVUpeRMVRq0pDsXGPNWjLsGFPYUYxk5SZNerZXv35S+dWGxhv3Nls0zbS/XpsMbmZGM7j9oM2X7XmCr/n2GyxYVISg1qhwg3/8mjqISw5GTWvP9NdZvHcHdGQRb1TmjU1WVX7szHiHKCA6iu1P1+lKoXjoMiO1APNq9uLl7rUo7TKOVv/kyRspaqJcrUWwb8atSbokMrspZRlSL376dvu3UydAQNtPe0qJNz0Y/EZEiMq2GayBVVUVpbU4TozmPOE2OHdQZ9cguyG1ov+KCa9c784I9JcQKby7faM4UqthpWBEMpRNlNkvsv6py0mzkG6VzrU2qpQHhRvCaB/QNaX6rLEf5Bn/leNjBjrUgKLqOIrwcZK7SRuhfEFVRD2TiBXhasJ5CmM5Ob5bKzfyFm0oJ7y9aX7GMSZCtjgN4IB3/7mR1WFzGElq8S/+ZEKeIdzR9kjqxvsG1tRZ0iDTkS8jw/leq9SZV9W3dUvC+e5gBTXlP32rt09NB4ZXySze6o99/swf7dnJlVuRCcMMPd82/391my7r1lv5Gt4f8za6LL/PGQUZryPQBXebytjAO5RHDuPsDGGV3qoNSAV8IsNKhnJ4vSAwXJDL9VzJNHiG3iO+joTFqpa2/x0QPHK92YKkRHUJoaJha7WdfI1W8gzKW6TFRQ5E0dnFc2ZTbJQEKG65T0CQHmSp0qFP1ocLelQsGAfMGBgmofEwJWXq/To4VKvUm91xFhurLfRb0gGvnHirj7hiA8zbHyd1DZN4DOi4dDk/TNWMGqZazyfHUjL+Ry3ZGwNuAkW5MHeUrYvIUiiCR2BF2LNKbqgXZFWivjMIrmV0vMkSi2aOETL7jHSQZSkvlCYqShPOC2wBYkHnuRo3whpV3Q2E7oXSVeTqZ9Wy6U3Zt5dWe/2H8Gd45znNwuvYKQyrrIvc4Bcrw88F4bHvyEpUD2t193w45mFODIy7aIRt5WJSYXyT2d5XQri4l2hS/vOkA58UCNv+1KgArB+a0a+MsT3UQkmzDqnP9CUt+z7O50Crnm7r1Ncog6sotq3BIWtLhdAHRKpjRNS432QBqxsSuC1kTSYxwWQus2tPSeaYHmUrl0FaPmf2rGYcHQ8gHgDoR5bn2jXZCLM6kUyNQl6dLO+Q9lMrJZQYUsYeQVLBEXAg9hED2EvVawC8COM6oK8rbBdLSNXqp0rpdzFKYIHUn+Q1HW12zDoW7uULK0EZpn0F7i0bA97XjeA1U9Gj/bF7Fhtn0A7NHZcKN9a2LCrexaTwSkIyN3fZWMJ7VLMyI1LsmAhL2xJqmDPd7S54buhRP/Dv1edT5GJwoEeLHYpjqSQVegee0ySgSHUAMFP5Qew/XqO7X4MOnOJ3o0yCAesQ0Og3dk4Q6dBCJxlIKDVyV8o5DyHqEljJCJ+tZOoGuXPftkpyxxGZ8Pdcq5uCHDOaoolTTWkRsVTiGo+IX3Pfs6HQXQuAgISgUOh3iBUe5CtD/Az93fwCZ0JNYKysphPe5LVblnhYc/BybAcSY468DBjHVdgtR7MunSAamjgN3jfclSXlh2hTv1IVS6RmOUA57DGyB+fkggaOMEBXwBNLocGsuqBSWoS1xfcVL0PciYAQHBkE9gqxsjaSxqCve5TY9HbY09eU94aR8AthkgdrOdJbh9WmWgBECvyvKV0ErLylvWCD6hexewHx5r63Sga8kzdYEtJ/FcyuDYtWTmvGQbzsfGYOyY1JnOXf+Kdfbyj6Z6wO4ucXvVPOpoYixEpJQDdAlZfmFz93uZBgCTceZdU/G2NGYFHwIUL798mfIW9TGKzQe0pB4tCHr8t9DgpRLO7yQohxkP5Lh4lRTIthyXFRNQTfmCAhiTQ1fudOIJ3ff6NJ8MmTCcUs2AUGWtkU8dUGIw6U30oGadu/q+pUHhZnKTov3CFSe4XNSaQXDIpq5lUyV0aavHGVysLgTKIEwMYie3qYF5JE1n++oC62hpicau7Cc3siMyQ6UUff92hDULVjJTV51aCXTlVv5DBCsI/tAoMS5HregDwvoyRc03YoSSdLGLpeXcqBXsu41aav0BHoQqAyO3ijQxAot0RrzJfP9bxX9Tvonq9pfCGoVu6jeOIWoMi+IF5H0RmqHWVLuYvt+WdkBLOge9jWK5zkTEpSRLACcwhHcbr+1xNA3cb+JRBKUV55oys1IXVViiQaSzGnhYTfuGG6EEcBCJgGPBiWtU1rFCnKW61pDucbpxEWBaYLlluaPfWboWUegNXj42/A8e4vM4mUedlngYnemm9SzTHWxGdEeqnjK2AG/EUdhUA2Xn6e4H9yldTCCSCtqdIBe3fht23+2AmJFYD1C2yzuTdEaWIDmAwcn8UMj222RyLpGMJXkL5lmluNchfTOp6UFV1vdVFB/vjCbq4wO0wdRM/XHf7WeSSqQUQA9ZILsYXpW7hOAHyxbaUexnxTOmHpMYV1Gd+drUMv1bEV/8sHAPtbluym/9vC10ivaccaJnyQdnIwaLOiDtA87Pa4Xuw5IL6iWGOjrMn/SMc+KmIby3eOYYzNbHjtdrKKyqmKlW/x01CGUq2RbzruojQfa9C2TLGoy9rW11zUnvM7oK38byN07pE9LYKPkJMKAS5JnFE2wxsAVnOBDUCu6YyHwm43YcaXmVbkBGGdHGCbjF0Xt0FHTJiZKIVeGeegKiOan1dCAdpIbXbz6Yo8RIPWuWVA2DBFEo+ot18n0nb2M8E53XFYheTgNgnEM66e4SVpComscrLHoSqgC6ieRkUTV8863Lyc6DnONM96I+Hk2GRFbQpHHxNNP3b7rFOyaAH4iINqXSaoSWUdYeZDHfvuWVwDSoUhKWsdPjwnhjisqB270hEM+OWcWxuTXTBPE4qwvcVmZz3Dg6iUb+pMy8ugsrI0XXnPQyfmBnDKQFkDhkvWkUFAbJiIIeAQbu/3ecoaRSAhZWGluBBPdRo8Kh9dkF3J6XjQE3g/EsBhEYpLMPWOMNCRmAQgR4/kqbY99lGbq9cGb0OvZP+eWZHYyCkk48QTGjSfMtZiA4BLjabU0J6ZY+0dXB8v3Elfc+Ko6/lwiITtLq570d+miV3AGjqyeJtbNspTN7IjuF6hbRCRpkptR4SPqYmQEASiRIu9CCGlz0WttaMA7yRv9hioL0MyNzkhMgfJZyi0UFYuyY0kh9Q9U2bzVOmjOCBQ8DLZ/NTX5qUlxjuiT1Uif7Uxz7wl19TK4FNA2WDXQu8s7TFC2MtD+k9HosOKZmLRO+Br0PRcF68bp2mMjjadu/WzGO2SABmHKu+XNEnzKLtTzbOTte6ds6mLvrej5sKO6WBR44Vn0dZRN0Xk+sgiW34qVDbGipK5PrXYZ1p0AjD7gFknYOT07zJAjJM0wKIxeFjIzgFK1Zs80P9NHo3WZtZnXGWao5KJsNAo9GbetwFJw60AVL0oTWaS4xG5k9CX3c6O+pYViK5pldlvidnEPKfrPQo6UtWz2ESn/e9o2IUQaB/iO+8Z3JhHNoKlW0p+Tqu+IKgWDmkq4F3Ch25yEKg7cE15aCcqjDlfUVgqmYskKKNXfn/ZdQhmjyON4sv+WhMWA9dzuuKao7vz3YSeYKU1CyafSdJScePIPpWLKSe/NOc+LIhD39OvUO8xU4V0daVanav8r1RVpbo0ux/9vSHKK4usZoBGGPCT8ZZHF/zJPWrWJl6e/GxlFE7Yk2TwjST7f4pgzXmdqFQVwZ1Ib81TRakHkBST1+cB5q3zrIv9D+ndC7ycoeSusex1EmBZQOaBvN9JmrFvKfoslgASFpW+46oqrCe4pzt/gFBJlbktqqyh1pVintXRLn3XkedIQVYquus3jwxxXJrza5gEjbaQ7zu+TvrW+HbZgyL0kOuWmW+92ZaO8OGr2QFIHvF6DCpoSNI+OJUBH4JqNnjgQz11gPo1Ns4sFTq7HPCe/imhHzVRb4+N4wJly714eTUrVf0m8Xbe053OQG9Edj9zGAtL0aF5zzVveULJCdfYCiS04zTmb/GO6YQHS1OemQlSnUfttTyDXxM4ZvTQao/Djmp5bwu51oBL1BuNL2MwadvlyUiJg8VdItXRVLUOreE9UtcXLNbXMe2mTRaGoY6EXMqHI8EqKVeIVhyoJwf+B1vBv5S0URxnDJXDeu3M0sw7bYfhGBvRHRBLxJQDt9bBwbxm1+mGoykd63PCN+pwoS7c5yHLcKRluimDcsaNsnnZLsyuOf7B2YncxFVxkk6LxE4CJV0JLY4K0SV3kW2nTe0C0Mr8JohdETgyHnNQ9Iz4IbfCHUHsMtH7ySV0xbd2pH6ya/O9TofLlEhZqPuxIOgYbb1TI34BMzKEFNnSafjpO+ql7Qcy4ucVPVuIiT1yB4fbOgIEBkzqpi3qz13elbupzyUMEfBHXDj8r/V0QFqixkgQ5SuaLQYdPPPJiuWD2oJzcPR5zWT8qc3AlZ1wd/0yn9d7F09LXizvz3flonCB1bqv8a8NCl5fIp18fTvafpvDBa2Ybnfumw+isbwz5C84fDi/ckAy6Ir7DPTyiGLt+RSrmuKOm87ZAkPe1EsrGSF0b6MMGVcpaZBBK+lEfPgpHe/kBDsyqMSF0wt22edJIs5pFPP9KRzSIenVE1HniJWXcG+V03JZ+/+P27cZ4R9F6saa6MaBkNRVIIDiz2FqblI2Kw+ya3qaGV2j4bDwNydXG0u42MeLc2a2vwJG6Hts8Awv4zfq88NcdwCX7Z57bTQvLYIKcAhUAmBtj1cCnsfW2RU/rD0gwo90ap23kogy0ftJ37xTPyHxdsVIdYLiuVboDzaclVc6T+2D1XttEhgXZX4nGi2C6cmMC5q2ndf2+p3gf3QafuxKB/yxIF09D9HaSmvg+biAeUEqHYSXfxY2ccog2hojDixziDB6S8O7rmClr/7TpOCOHDj0hlNvsL4mPvzkcJVh/Zz/lePEZlUT4FLsIuTDOBk06jUr+LaUV/h2sKCFO74Wyr7D8wrMbqAoc/leIPlgtsYjRq0mIAFHhSM28Wv1z+bY1eXnVonb4QHuwL9fIKkdR01GXTvzYpN3nswvwqWtgEYVqpof1KBf9cKoYNg+A7X5IKyLiWjoc+9POyDO60R9ri9jpymz8G6dOtiuveEH2zHNPxhWqclq8iBINdP/IqVcJ4W14lC4OTLvwHpK828ahl9GSmBHnFKTbf1TRcKCjP4IFXaUphpNDxvq1Hh5p9hBDkRBVxOxglRmEgVkjk3Xbxn/MwVlJt9v+IlSnKn+NovWubHcu5S8uA5z64tj76sEkFRidTD21rkq/WTcUkgjh523XeN07WHniwk6nmUvh/ka1sqjmmgPGGWJHO78O/VMIIaq2HU6cfl7LDKF7CmmJWD0MyCo12IRYf/BkZryGXZQ2JLcseQXeV7d4O3fH0YrLMOgNGr0tcT5AsHPph+HmWpZ1xQbjvGJY87CMiYJumD4lSq70m/Qk51oKKQS8TSr71Sh6frvk1uNKTiXOfJP95cWpjGZRBajdtywoPHx0BqtECTEdQIZMM0Z1spl38LCd2jqpyl47QGmx0QvsnLTqimU1dz5svxSXHkDRhtSO1KKCWf2t6WlNu8Srs0j0PQaFZPxE/aghf8VO3c+4Kn84ZAW5NS9cCDYtT7Um+9eR5zOpftjUcq5IvVxTcSA303lDbjI5r6oF1BCvhlMBVvg5rSVu9LFuHQVvYiZOlIWwAi+Il05QKcNFGS3qOkMD58DrbtyAtPDaUwGKTgBBeSVsFGfBYi/bUq75u3GSnlPLfzKEbFgXWiAPpyNuNDQgM6EFeNRk/EGgGlclQsDwjPcgerFa8XnoNOXjlUNr0w4ScMZxgXjR3DXPGjh5+tL6eO4O5CPaHSae9lXWCs5waC/WqkySEaVGS88xIZRhyXMJqdaqDxtm7S/A+ho/9z/2C4X6F2u+voWBuZk8CwjE/sXk6i12/S4dB+GtvXzFkzpYtRTOgMm3Z6k6A4S/5wdJjRxA8S5l10+GZpIGY2I8BLW1FUaBMTye0gf4x6eBbBLkZ2tHmw56nfrKVuf8AFXL9Uf6UNfwZdRjFy0np5+n8iHiIDZ3n9DIo2DDRZ/2ugzrde1Wbhkny6qC8yLnZLjOupWGb6WShHJJ1DTDlBK7sZjMlFt3SMnOI988BNkzbvihoXZIjokMdDWOZQp6vDN+SVhBXyqXE4lPMgif1rmL09+IBdZVcF6/UcN7vY41hoEiPNaGIdTlRpR+TFQJGosjW7738O7pmqVcNuRcB/k1pQfMjFRJDe8hpLnN9qHLgsNx1I69k6osoSwzpKsu6XNZk2DfOrFdhip6ZXMZn7hOp/zCNTVgHFReKuVuu+Ps0FEXtePbb/4n9kQbWSF0xkPQFPZRqhB72u37XG02SlAqR+izGfsCWlHnvotJIsC+ejSk8l5qWQ8DMc7Rl4nSIhUYi9CjPD03QCxJi7bbfa5bMN/vSY5V2aXc2qyTxYoQaAM9nlBsjPOjllFzhuCWwlSsUu0Zs80SPTneQK69RpWrRe2fzLbGkocWAj/BYKFFtd+KTRVk8YMe9kQ0xIBb1rEfDwp9NyDDrhaYRePmQXcGqS5T7AkQLJe/LoSzxlT2NkbEzei0O3Wel0js9BTACyze1MRK2vmypMgJQmxCNZtzCS/JDUGZ6LOnMcBChdpeYjfhdXrLZauESqjCxs0SDmIhoUhCd9qsl3+Wko5Fp3lXnASzKiUGQSSNht+oejzAAfiT0C31pKtBy9BROLn2vNgl58M8OjiZKWMpkPKOZ8eJtRt5L/i2Sqv5tC8pAzV58zTc3LhGPKzn4BoKLcok4ELCWaq3Pqt49MJA9Zh+Z4EbqDj5qfSR4MB+tibSfqt54dqJCMVJ8WFkuK0+sS20cBUFt2BTDcY1ZLOlpsvsnz940zMKZCc/o00J/3HO4dwFIsZlP3hyFokDcP9KYKnnxAYV4GsSysfnV0eu5klsYz7h6obrw4WckS/h7E6ev7+WaRQMfUFTymqxpi2QRlTtttSF4F38bhMeE71zvMBV0SN2Cx0b5yiUlx9Pjn5FUnmLfZXkfP1JFfbQWWRzvhZwN621Sv2y+/iUfYbJpxYFkmJjBzeBXTFEg29VwrdiUXEWVx2fiZ2Yft5xWsep8keu4MUTXnOAAOCCF1mZVwBcQMNXeOgkbKmtjXHkuJ9m4rLavTmK1aFLzRa9D7f/ngsttJQkVIF+i9dscpjZMePLYkVilYNRvrM6kE68Mm2ZTey4+oe9nh5I/K9RmuYTaW3dh7zHbjQhQV+xoSzIeEtxdIG+uQngbcG/l2K4Dno8hizbURD9PQIL9jVwpHpkmYVPxh8kgWimlzZfnho4rR5Y8Mls7mBBH5wBqjdki06LSb8HsyI7OP13Xf9Y2pl052UcY7uDzEGdqBFLC20mjiXnOhPJ5cAfl3SH5xi56OUQL3SFnX9QPXzN/ZPaepKsROfPPOmMqBpshZKbTEY2d5M8ZAK1e0o/FG3j+1+iL+TuPkCTxEwZAEBsJGz7YQA6vxWyHOdoBof0eeIccnAPKQ4cu9t78+kGFb+fkhPJzoYjz/cqJVN4Y+culTYqdozQBP4p1oA+R91Y6LM6P/lZDhbajbYh5RKJe/ezyfhMDBKYr1ZbR2ndqGsOP1X/ICJ8J8GrOoVZEoBgmUBUs7B2pilMV6ulHgnwnoeqCAY5FTcXsZBBVo/4dK7PkvI9gisY5Fu0IrTa9MC938r1/cnRpqVaQ62QF2xVMQcdNJhiefJxZctA3LJpIQgMoDeIdJSeebCVxCw/2uM4R5JVS5E4tlJ7rMnCn/KruTdG6JPPsW0kh5pYBsFpOvyKIbzT+SFNd08qkN8q+20FhL9JfLNnlLirAT58nNCfrfNsiKg2jHX32pUv8pBXWac5ykgNdc/sLGMhT0PSgGs8YElsrlCp0GijYFLXRgcoOpg9xaJFrXhDHKxyEUI+OudB80nGsRnewm29/0wWS/IYL6R6XlZS+b+8EyBsC1Rp3zwkxKYhBHMWvZIvWbDRrorM/iKXa3VVFiwqV66y7jgktHO/N8y9aytPpv5osGiafd6NHld9v00xCnox9qOH7OXKvPacFWpSd8nqL4bXUhjFpzWA7pNkgYNTm1VTqvBtrys0zSazZrzSE/Ot66HYN5FxP9Qxubtj8DvfbtDElpVJeGB43EsPmsN6u+AHlXb+mdrX2AOBbRh8AsnBSKRnt0kmti4zIU+CXKoYh9pFI5DfkjxR6oAaTCuaTMQXmod43AkxAzEpvQ+h1SQp/iVnLIDETHxt69BvZv/GAIb2tVjRQfN4BQt2yL/jkWnJEStugiE1bXWgD5FOnM4S/AE/gEhUh1eCM1nVM27EKHodikOoi3IbWfZLiBDle+6lZxTXOeq6gRUmepbsmU1Fis4YebSEzLgT72ibLgTfmvArpriVvV9gXg943cDnetmRdh9XdB83yK8x9kfGUvkhAiEYFZWRAYEPc7/1/XT0mzy6TBWn8D+e5k1A5IPcUnM4MkGZw1EP9iQvaYzJu/ad2cODCFB+CiucrNsUM59awmMLOoNzyLlHvVR/B1yycknOKq0aQiwStnOUzxUloEfUm6p1DBjb0TJKys+8bhcblczXzP27/vIqFhzGxPW4nMdANUuZj/jkNx0MRNnrAKoLEkPl0KfxwrXXTsTVEdPaoVmlDb0keb4q2gL68dc6sQ/TyjAoqr7IAGyrgNsgb5MrAGO5qXClPPcX6jKGxZVmDEWasNRUQt3JK58vScCtJodRv1rowBILypIuZQPTPuP3bnEsF9To3Ee0fT7PobMnqDXPnMvPhZGNRrt/QCN2DwALui9I/t0l+RdrrENlkcbCTvhmu23oj4FB/n8gBq12vs9XtTpa8pJPI/k79fU9YMlsX1FyFZQaXXJFjhC5POxQhn2q/ThAdVi7PJnen1cElDMrEkp1kDPLxuLruCfTwwBdHietEe829qgpqemrsDn0wmazJwzPMy3GKtVHg54NQZGAKC8zjXNWCqp+inPqHR58C2Wp21BENdyIhdunL2OLpYkvMJUAJq0W6BC5oEy5BF6jNI639zHOVPM5hCYWoOZLLYE360zqHuQxr+C8foeRTsxgAEfdVX0U7U/YpvwsyAGz5U3lCkXBW/SWoIoz0Y5FOXpmJiSgS3frMgE2PJeSyj5FlkRS2GtcC7cQYe2X4H5t0gwV5j+bBTNIYfcQJoc28Hyix68R8NaqSXkhKmrhIztP/855VLtB470sACfnWN2oIMIvPxloX7MoMfvdUrkRsxcFA1mxvP+ko3E9Sjz/KJbDxkjQfFHz9FmCbxiO19HrXv++xqbgU0bzMWqOEgSFgW9nCSAxMQsAw2dGCqC8TbWhSXqOJZqqUBunSToAUcQZx/lbUz6VJPVT/SEU9a4PdmGxwDFsLRjGIb/iJoFc3yG+p9L8xhRfUnm1oKI6DHb2jJf07UVzrFYts7bFEGNJwpGtddPrI/+nywo//6UFARU3TifuNOhUYdGncSznLf96gC/K8LFH744kHSIzBT1sUfSXK1ROfa3cIrEx1PAjBUs0KCN/lzVRdVL0NEVrMZwZGPqOHyIlPOvWQO+pPVvWdi7fjISeQcxl0qInOu2EwUeCzEUabQjqvU1iRczR0jhZi8RkvIOQqWggbZacQEyCSTWScy6yLPehpNYH3sMvBqeCiopgLuaeuHsLfsVBugMxSFzNNVhlrSAdQP/X8tldjnon8tjC5BPBVVRANAnK+bseG+lZqF2SNuT73+UJtB9LLHzTviJEJyvEMMwHPV+Td2twRoWl5uWJZkRIkXCKPR4gYg1F5HL+1odHkDFK0BRYXGvMnm/8u6BfbQeafUWOS2L2NHci95Jy0sW1UJ/vx8fT+i+Ur8fV2DNPOrZSpvYlILKpU91I48EESh1d6onBL9PtcYhctuztCbWfv+v2iOzVbCoDgt4fdZMqXqJmH1T0gcB7ISs+MkBwOJUqSB23wDWS1S9Yc48VEFFRG5A16qrSRsgAMLk6sI3yiVBUf4DRszRIoS5yWoCAHCE4itaDvMctSYrxbE0NdCF0fNMgxPJJAk+ectuxxq/Km64FPfXikNEDAsuIciWIDIHpIeJStXKzHFPcsu6V5/2S+qMqdPVOH/TtIkZEdgVAC92ZSOHI2gjzTHLXrr1TLHSm2CjapdJSjpngUyu54tmav5lX4EohTUadXXQiQ+87eKMmmeyrYCaKEUmv4BjJwsFeianqEHiC33U3lmKW10Q45/r5NYJVrEHBXq4WqPBQWM5tepsjeEhYeONIlKfrgtSZoT5VSJDPJHup87eFMNFKs2K9dOMQVHfvzdxHgC5DEzkEUa81RrPnjpU403zwheM1J76Z0u4WXPahMO3HBRc2UH6eTBvJ6kWKfOKWZZ3FOBY34hD4GDrAfw+7P3Vvgzwruafu45S4EaxeDysWrIV8Hqfn5t9tCsJmuLt+V8k8YvXpyoX6hRut0CVpcobV7iDX7vfGmwTq2njlEVLmiMpWi1P61a5OI1U6AXBAeaG+U/Pr0XgRPN+JrQNA3ejCgCQErGtBVou3uDII0uZqyhOFogkSm/d6wRwGujFD6sUTqHxe2U2ooCqRAct9ssdCNCsjX6s66rCEQR0DkzGOvzYLrepeJgWo5Pq/ZQSfegTX6DCQvSm/X/X5tOiDnxoiOib38jTDZzC8jPfR9Tok8hKNG7jSGOvPUMhqoI6ZrUkd7xVvcc3eAh0vix0ZdoZFFgCDv3MUMTj9Pp9oNj+ak1UdJHqYyLMF4T4yhmYySHlrjs2QZpiObGY/FWNzpPTpPPuLM0SNrHTiyr3tQzmzIqmdlKs6IfLHtLxpNoUKDBaZiLX1BfWvdMWgHIUqaigALxZttOOFrzevS25NLuS++7/+IRMAAd6CpkkGmW6DrHh5lU4lefu+M/eyBE7gPW3xKe7LI4cs25zvTfeLPzjVYwEne3uOhbjHBDT+Hn6ZHKw8A6FUkIwt5WUezVfrtPVO2n60usHxVXIh9f/XQLlfVJFmVC8a9Lu9+udA/88wrNqxuliqypT9QU9DuRw5+ca5kU4gFLDRTns2UqUV35Gh1KKE77qwzsYNJ5Y1UEDxArs0WykhPMtBAsGnQAdkwcSmPdubxlHqx4XGJ5NAyMQqRDtL5ud0NnMwNKNFO9+lr36I+dsRD4Y79AdHhFQ9s7jmZAV3fk4dGJpakMx8xUPG07XEQdwl/47ZZfj0lucNi9PxDPsWakKszr+f/BN8S4H5TktMvYy6jR59eQdHTPDHYtXOQoNTT9jaJMJj0+jUJWMCSSxZM1xA3WMHWeWoRFydOPrDNkAWigo2hazW4AeKWpi0mnmi7zbZzbDbZALvg1Yq8moYO0P0TadKvX96Qti1Y4H2osGs1hhiJ4458431UIv5FwvkheDLyGamYy8ugoby0sTCARzpVauyhQUx019U6PmDlOBBB5UOY0ij+L8VdniRY7CFkWThtJwLVxi/cRjZyRn+BE3K0IBx61C1Ux/fChic/WMGnxRG9P2d/dhJqLkpWmL5+/xUTmNESAbxbmxGFHyETdtEyyvEiEpDbtntbxwqf4ffwhcD27maV1EWFAu8rcOeiBpC5PN8I1yRMgw8RKlpQch6yA3RN1D/LLEBer1mFLSM42KL/jDvetBAee5Z7cJb2Azts++Jxlp0mjHPHRkVf69Hfi6zQrVxMrRRabHPStUeBWstWZm0h+AbnOFfjt5l9TV8QEiZqUGRkBgnp1JmTYSt0y77/XcIjbLmd4PL8KrqwOFGzj8swXVm9iSc5PjtLYky6dYkRDeKHuSTny00gxHfSSbWNgYZUA8qVSZY0u2g3p/Gzs+2Aqa2yNQP3tDnB2OaWqFfNRn46h75324EClDnoH8nKSOvFAXmiKiiZn62ipLIbKVNAC0U+ZGfJ+SW861JUjHp71oI8L3wde366bKctpEhoYffl6+TkrziCbG0sPdN/QGss+VCWe2MmnZEOblWW1JDU8yod6AZmjzp+ZCcP27jmv144UptS8xRoKnlF41pElr6b6kXB+F21gBjkaeR6XkUQB7yc054lSLQWLB1E4HQ/AwYlucGnxei5AOPcSY/adVVDPLL+TWdFhVX/fOLUB7hFnpA//ggWFjV99JQ6dexp71eqFGQihWk0skTEe71lo1Q0cmdixTEzvUTCJk697ghvmjKSlxz+qn37GGceb5X818DeYuNrAnGSTl24dayD+oFEJ9SdtvLSud0PswoQ+CmkQ8Ysy0V9rVzQJ0jmMpKbit4LxNEPTkFKDXCRIxOeMbI61bI5DvKycQNS+P9xmz3AEnWySJ40WZmnNdC3U2+7DMZUtj7W8vJygZUhv/UZ1ksGPllADzOVz61Xg3OlVJ85SNLqgZBAZO7rkGefWMHpSwygE2LCp8M/8xEulYmWCLNFv/+U0SGYGD+kwG5BvYyveLC6iQUHfgFXX9UGyAZNqVF3km+BuuMCSID76BQYPKnvB0FcI9j0kssJdQIbCQGcvd92C7Vc4giHCp/6qvT4IPswN64Bw+mhc3BK4sWFrnbIinuZXIeIGuTIrRx1qkhaRQl6kHY9OX2iYpBhQ6Od9CbvcCRD8ngcYTLxEIXMfjkJsY4mTdOxuYf1l23q4oNvCEDxiCmvYGXfhaCNu1U4pUakWvc3HRHrj8kCnrNbY5oWL7PjjrDAVzMMGLXU/H4/xG5UgMBKDppdWxtin0XajWPusro2D0hi2ZIxk8SQtRctgXL60QKA7RV8XsHJjkpFDTLdonZxvoiApBYM+MqDSdgjGvuCQsaM6FQTGmTdDoDtZ4CykihgJ/3oq7lxX9wkYeIBWmKRvLS+zWpMUVGae/MgBAjNsA0LlqkuoTum9NMrKSbTPuYK6jGAXadAeqOcwqowoCsjh0D3I7KTF3TCM3H65+pYb8OCRYG2ctHlfSknnPWnsH0fxYuQelB0Yft41y5LIkKV1EHs+c56hULSpBypnfJApQFy8jDqBFDBMAT7ZclaB6Ax+hUXSUE9FjT2poR8Igblys/TnSQSjryvuAU+9DKMnL2Snv0AHZwEuQrO0Lx+DizzAtt08/Pi5CI3YpQ2t+aTDyLEfrt/N3WfwdofwLBDjvuePAtyGmlnAbTW5TB8XIuvZEPI/U5EZ9MY473uAMEz7Y1J5L9/6SbIW23mo1a6zixPNa0PeOIoPeZ/QUZN2OVkQ46u713wIb2orc+w1nbYUS7dYNTIX1+ld27D8NyG4mDWiA2hpphihgaOJ4rLrCuiPbYyvPfpsRa73TSwjf0HjWDC9SbeXFiPLM6d3iMDK2fOjKbDVnHB+qs674g06h6e5wF3mtTQdiAxGt01UUlDiO8mRaf9JhAEiK0LQx4Y9ITgv12sP+Y2R5d/dORMHOWhaJC/wCbplIKNwPE4VaHymXV8YOIgJULb2cVaoicf9xVDn+On6StbZYvBOf/ouboEUo2aNZ4dFR30OMtv8YmaVxN3DA1Rw3RyJYVtst+Z6C1ByVT5/+/r5iJMc1Ad1IKU1F+OxtZdNMRAUcDpwdE3KTXpSNYun39rCPFgBBBc45GhqR4udOR8Ak7aeQY/8QlpCZpOBkBtniV4HAuq/VAialwhXlBap+rXQjx97YC3GiO0AXyeXn+/RLyQ6h73lF3ObThsdBsBgz8a154aXpYeivkGLQnpnmK44peBjgYBVJ+Cg2YoKOqzvwHB7nfIB+CZ1Lk7tkStaFaHQzxK4B6zQAHjrSVspBTX1Hh2IACQbjb/c5NgGHfsEgkexYgs06sgvWOKUAw3mtzMI9Jm0u8fuqzjMFzRg3ndIKRhWdbOikdCeUzZlCTZdhdKEyRAUn2v3lqVRWjZ4VmZVoqnrMwIMshRstIrGtjXGb1d1PAUgo06ZjXGrt2gOVS5zE7J5ZXZPKfEt61ACt2wOrDJL5K0cbCZJXP9qwu2yxJmg8mzYPWNCkllk+Rlv3Blq7v5DbzY171+b4Cngal1zxTRmmrwm7IgQvW9EIGbciOI+QZBKNt37qS9rBaW55O2fNTqOczdFNGZSb3UO5o4DqzfMdetRP+4CSQoyy9t3yDKKZBYFGuCs1mH9XB+TXY6POUZMERUzbVvGAh1FMbeoHMNCuhrrcQdXgUTBLlj+o8Lkp19Umowq5Am0y51VGYji1qmhTeKIEaovhWmRXmRpV3KYfPaFqfX+AA1kk+DJUJYZvCrl+8I6R52rzXJcC04an01JaaeNSRbR+lvwsshxj1qirZ0OwS4cBqwfOU9Ujw6txXMQSciYLnZd4T1Ki5AhZOLUKzyaSphfeCHlAjvQCTW5jKKKSxjcXFtxXTqWNEtGdMto8Ngbgx/PU72uaXT7MqgX5d2IObJCTZQpFUVeBLlVVpq63dzUib/MyrbGmtM2OJ7cHpr3ELoMFXs/4cviHscv4xwCxfI26Igj3NAshyCh+hSitQAveHmaT+puFxH6baMT8Hq+ZQ2pQRa2TjaKLrcwkbaT5dxKtMVmUbGgG0jIg3v91IprpXObgWQxGRaBJDcbjv/ohRCi4QnuzZ8mhh/SdZaKSmWILLvLmQIkyiUqF3859DHhWS69WIjwLFKxMrj7SOY53je7A4YrftmR39YYHsVAGp6lFfJYgctCcMEr7ttLpwCKNEBvynxl6OY20+px6z2FGS9K5r3AauR8ITPyhpC4+kP+Tid4AT1UI4ixLxbZ0y1sdZtRNHpSZVC6rHmVgbbF6ULV7GuKdsnxnBJaG9RQ8mnG9m4pH1L0MrJ4v/B3XeSgroqV/9niyzRN1XY99QZl1muygi4Y65qfH/BGx0/sofW2P05w+Z8q1Jxo6xj7lUjeE54Mi7q9ha41HoSzadhsbOrveLr9c7Gg76Kg6KSlO/r0EI4VtOZh+51mCVZKPXlz4ktbq1C71fS7Z/yA3+W1ms9vovseHaX0Yn+0yaT98rUvi+3Gh5Fmhyb5FXg/IuFhgbdF+CYiBiv0Mr9FRPEp4Uqcso9loxstChit1WpZ0v1nqDkoYFcCFsK6tTUp8yvcd7E2TVXW8FrqSYLVSjJqAbNLa/xPm6lfzUJ4/9aJCeUycS/cyXtkTKEQrDLzLIpLGgOvz8URHIqECG6mS27w1zH01UmikYymifpbmkPnx6Gr5WOV1iA5PX39QJkjCR2qoOGACwiDckUyvKv2zNp9fX+MNkQvPT/0ONKAd8ONzg7zRRGripb9zj7MlosBE+Rgg4bWGu5FsBGlw+Nukl9Q6Q5lFzfHAXwphVFYFok4CfKHD+ep9LelU6xQOrn/78vN+awpL5oz+VlvOB3ROHLE2jT6SqTSCe9gAQbTdEYp6/nQdpz/OLz5FC+CLz6qviOtRuW+6feAi5biKAmWKucA5/e0atoRlIakWCRhypgU9xx33PoBzSLcTrojhEXdVPZnoFki3cXPVZHW1eNQyDt6eENHg7Y3h4hjEwL8oMsNKd/haAZzk5qNqn15/5ETOG+X4cpiqVjCs+/sSISYtUTfAKRlnHlY2OFaZowsAgtc+tSCGypHtNSBQ9OxLwzS66XePhCJLmt+MpHFlTqKMCyK3QQ5i3KoVzUE/r2F6bnhGebTPcVIOGd1MK/va1hFoRgHILG7hUmQP01GfFFM9v7XRd+3rfsA/dgSTw+R/1qdmK5P+89fYoWiAEY7xB6ObZ0yu6SPI++tAqVFzlv5f06OW7Px/rfnHCyQSVyiQa5TABSmaBTZU0RB3sYLcYsjnQ4ws55/qN0qX2nsDcHIFyfTsHWMAYTwzB6Rbvtt2SyNnTK2aDTPHMAWTdcKCoyYpV5ULSkgxjBjjyG6o/u0qXssb6GzuoVV9EkT4aqeGxXRGA5/nYv16tuCy+jL8l0ccS45x66L9QPxIODtiJ25eHyCPwKbqfLm21P4SgdHIJE4F9BAUXM7T3bLGBmhDoeIb4mBwEdhdBuybL6j5z/crGgNT3Oji3t7rYBSL4HdVIGHK8ul0gnZHDjFYFtY61wZdY+K66m/uEFs38vlpXzfegJKjAjXk4v/L/c6oaE3ps11EXUa4rPPvHaTsaOfNCbmJw2DRd+pk+Mkq2FVD8elbklota6mdEUFXn83k76ybxR5SNhAKiPKZKYX87/TT9EH9cc/FNGhCSpfh62ft96oAp9YfO/bWD/nSHi6wB7cEv7fSsdVFK4VN2s54MfX0BEO30V11VNioIotmK5tVY6IlE59iGRnjFNRlb2TcjpM8PTEaxqN6VCU2ZqeYObLb/m0rv3ydu5bFgMh3dlw8iGQE2wbWx3/Q3iyDOGPAzhgDGHLSqBWw95hzHy6mAXPFeUZQuuMCOLofwmCae4jTq1Ed63Lhzk7XaOfFiDgdr0yQ93UbmMmetsBIVWJt103yUtPV4zOtMm0de8wLrPdkdGLEgiwqe4WRAsRaIPE0G+segoifP1W3tBTl/J638Q8YUNUA3RicHHOo2BDyp9imO8UuhgCrA+SunJnVgEtJIJ5mSLxIgxZtjRMIRJ/rHbjJUQLWdH+0IywMpDKiQN38VtSc3OA//Zy2BIoxKOXTRjIjjgRuxjY3wn+XdjL8Bj5JjGEgv44eaedwWvdxMI+0BhF2LV1RUoJ1AWAhg+ovAR8uRdcELXabKfAZ+7BKbEmrbMXXEK30le4opEFXiMgFmbf2e9YnX2nTHVCvDGkftyVLN28306AVNu6V3LUMCwNHDV4U5EoLFqYS1PL6F1tiAQh9YPsdpif330TY9hSHPLXI1Bow6+QTLpGQpPuio04wvaXgRB1OIA+QSIMmZh80YD0DWePBmfleOI66haLVlzCpj3qQxFknsGI7CR3zgyqohX+BZ3dXU5zCz5zP9zUMIx0fYAI5Ia3wzKcK0PrE9h8YAGxqlbw7cSTxDP8ViFTpRMB7L+JgLeDIuekky98e/VwbqEpt92/8zMpeobrUUp6enJhWot3Lg9e7csqZetegvdvd5nwpJo7IqnUYhlQjhT4mkNPJ9fCi6EuunzILn2e8s2YbcYBK2zeq9rH5d/KXVmmpp7kBf4UwOggbrw7KpgIUf22oxg4YMzgbQmE0BkZTRoZA6a4Y2KClkpm7qG7GWQRqfg4DWH0NJDmlpTMkfB8lttmgVPvaXtXeeJVIBykuGsFSshwoC5vxF3+VxywkyQIpeRxhZT3/CaetK19A5tGnFzowusFQ8XiFOL8eQrjd79Q5EE0tW9NwbG+GHlu78ssX02/Z97OQf2aRJoIG5qkof9uJV7siy5ikqE0froIgwRRx/HVqGJv0l9UaRSoqFmPGMDoAF+8DdReEOR+6JuTg9HzM82W+twtJ6sVzRP13WXCuDEyit69DVIT/SfwEjtqDPV+x4Jdv3rGKqkoiPYFFzGhwcwo+H1HB8lTHBIg69/ynXfPd47sUlksCw8fqdVnBqSijA3FsrSh81zcT994sgc6jlZ3ZVqw4mpBzFPWxRfnBFA2DSUvMtubG2jV0IN5t5ATrjaBa3ZN1/aHNuek3DiNpSCD8/SiBZVN65sH8Y52XKA0OS3sSbiyVK+ZxUiI1MYdSePi9u9hjJaO6evBVWtTSG9E7JLuBhhTZw9/5sS1dj2ueNxSCOnuCvn8mE59bBjNdcS8gGmXnDRVb1mgT2idb8ozoRVLCaU2ycNRvJPTFd+2AgwjujNBk/J1oYlq2vDecMBanxMSjKc8bgEv/uPTHvHDNOu8YiE2tHVhFleEYGHB4rlwgZ/21Zun9RH6zxUq42U9MmsAC/22oeuDGI0bm/bbhsIUCypIPkFoxXmGDPe0XTG5yBjNiCmocHFdISfRrbPGXCVvN+UNAcZSXa0cP4M3Ss1sRF1zru0KkJDQlzoeREYCuTnmYtFUwL6Z7GzaF6BKhLqCp2jNy0z4Ozr91/+gUx8CGSrp0feGTI1q8xkVFCRMOuTLecIDVIpY3zQxyGNMwGK32DN1+tPMGzjRuv37VmwrtJfW1clnX4vLVIGw+taD7Qu15R5c1K2waama9wU852woQzH90vadiitaT5iU+XhPC8xBmIP3793xu+U9vFkXa2rmNwXP0y3xyFigdobI+J31R/1XsbgPdsoGC2zQqXTL2HhwIZMwuTV4iBQHQVsR6uKaDi4KO+zD9zncIGvjhq9VZOKCMxYmodKkHjlqzlBV26Xcve0lM8uvk9lxj3DdRnnuvUwAyocs8MngHkUARmG76eNhQDOjGttTyoHv8Zri/8zukQc0EC7jypvb8z9/Z4dY6IMmhIwmap2XpGyc4ofwe95ayzyTB+GWnY4kej4CZ5nNEWeT1Idkg3n47BlWqAPIqUZ7NUomjJ8TcDiwMW9Swhm5NZSRGAs2B0RbF5cid2iFvgTHbDqsL3pVAioBn2wH8atGwvcNacz0SH4Y/X4eMVw3zpDFSEUO+BwfJtEy8skizUs9JQaPUcLedVoQA7kFdo9ITsYzrN4pI/7K5tigg4ZECT5oHJF0qL/48vHSSf5JIKCAtXMPFn9imMmizMF2V7HfU6gL+mhT1138kgxsnUOmqYxQlDcBxBbLShEVSN9fNHB/NCItAw1fT7BroP4VE8r1MlAx4NNRGyTP3rN0kHjIAxxL4bhLK3bsyHTXAzsvmkhbmmDeM9Mv3AV0xlN2BXZXCV1hoAOS20M0TOPc6C25qS8qcRvsrKG/tSYaza5K0JHl0CaHCxrJ6H3MAvy2Kvz/v/tbXIWzIWPELtXvus1kEyiBTndRCJ/8NCr3o741jkvnWknSrMnTBTMm2/PllEzyXtdFzYmnfVcK4SrNNaAvcQ7BxTylzJ4gIAnxNryAo7iz0nJbvsh7Qujbj7I5bVDmPqNefy0LvSrxMYscjSlM64jRgBsmAuQFjEAb+hDFWzPp7Glu8yMvTfuZ9IuTa4NVFBDjBwKJCSrSiDfupVbnQVwZybquxpBdYohdLywmSbnAUupfY87RQVTWGeRWntSGbVO02UAr1QPNmT6RT8eHH1giGOpjPQ/iPNdZDeV3rU3H0JDknJnVdEqpm7ahjpFoV12FNUh+3G53ytzkmscPRGgqBC983Gf8pHsKrB2vAsG8TV4Fr0n/w7rYba+k3UkgzqTOfWDX2PHdIVg/Aw4QTJSHnnMyxOeECReHMNpsXIcS+IcLklZxy/7qToTnLjbfviWtCNwxhhcpBZkSgceM4FjJZESzGsdK2RNQ9syOYAtmXXvHK7gl5wV6Xu1gbhSzYJkzTp5WgNaT1KkAnJPEBOX+nIFw0KSmJ04mU5Z5haOQCAEP3lCz0PDUiLFuzUBXRRVcA+cW/2tHZ2CWLx9e/Q0D0ioRpaTVEoZ6ID0HYSKhQI82jyYl25amXp3HyATX5E3VQQjvtef3nqRmrB2/jG1tJx5UQCUmpt57tlmcInwlDxqo8JJAprXceZkCNs+hrqBfkAuVqfMUUQ4XZ/wGMewznbRQo1YedEU1e2vEWV6FtkkcReDj/xL4GTbhGqNkAPJkfs8yer79r03t35O1dPrLpyaTG0wZx5sXLx6X46KK/a6V44iOF2v3SWEHWlWepf2M4o+3ywcDmnKWWH7VcyS/VFCGbL+zT//GmoYfc0h8U2QC+6IRAuWc0YOuytp5kvDMjskGHXhvCrqs58/azePGQa6k99r11EgaPvK1USN+X5+0sTesL1jI/H2hsGGDRljidp19xg0vrh52N2+yTTbm+lhGo7v7SjjjD0dWktduO0Uoy/PbcUgJ2Wu8wXfcPf4vXP2tDNDUEE7uaU/SoMdnXoc57JMztZiv4AyUm0a2XUSo4ykRmOyREbLX5zNOvfG3z9X1O5M74/pH/ehbJWYDkFDocHZi8IYxyGVxVsRc4s4uY8is2oEBNKK6UKmQ112FGaJymtiTxrB4O2eFscieVmVIaLfUWyoEZ5Sf/yqAStrpp7xzN96dKTEqR9gFHQCUihVSkrTmxa01XjdC+amDSY5iVStuyE2eVb9xEGRmznhsnXorzeIRQdNX8Z/YviS4tCK5RiCeQrTmagbDJozaCQYEAGpX8TAfNRyaXea9skBLERdkjIhNBcszErzd6bLvFrYutvMnFgjCjMiPsGsT0FLdF6OuaZJD6mecma0pioKdrKtHWYoTUFKUIHj0LoPtSknDKI0nhtKQ8+Nrra+lZXDQdxRilxv9BekEXhxjm2QzO/ElIHCn0ekKd8Ykub1LQd6DSQzC8GGuJlJDZ6gvXYJAAf7Macm3rcx/R2vgMDfCVecTVd0RBNKmGEUCQG5dKqW930RU1aMLxGVactfkdoM3iLQKIp4B+ehLH0HWIwRQmTMKq8ZQvrGEz6TIQNisr/kBgstCjIh2Hn7nlsMHu05xnDlMMOrcmfL+iX/hewgQDN5elgZIRdhjigQPly0OUI5tWArNOKhSdfG5Ny031EH4SlHkwgLjwG2G9N3/FNMbbobJUCBTgBRPykIVbN23lwgJHnHIuhW17VpIxzZbkovPtEJ8T1nZZGYKozkNT+wsfJ4oKMXkMEpGQ2VkYG3ytgXYs/VYxZ0sz8v9oE60Y7iDVbO0WzwrMYbC9E3RcikraBF4ZnE4Z464nskGYztdSRAcNp/Etf5yxL9P6lLK0dxN+KU5ijtUqLlrSWbFl30tgE1Vmqw5HvFUKnnJjxY5l46YxTY63b82fsIwgw1QI6iTydbioVs1y5KoA7hySYlL/gJzn1fe0xiyzPfCs3qn9n1s7dcwN3AVumlfYmzTxGqoVmk/FbzIR21+MedpmWwQ4uKk5lpeWXGPgX20msK/5kYdHu9LzUNecyzp8FlyG6ESR9/jB8LNucDxGiMHfz6XkYfluLuy2KA0xJpN9GGAM5bmmzB5sI7OJFxDScPFfP1A3DQLeOezc5IululHZjJVQ4PSvRcT3y/HsjCINHmlNKEq8hhju+2fJ0rw+ImSraoeQyspXAcL6/ekGW0agBG6c9bzzumGuo6FZ0M4NyOeYSCfSu1lWD6iLFDbOOoqkP4X9pZVvTL1k6jUlfzROS6zHnLRrYJ5XkdQ5LSYZXO8VzidR4t31xqHizjBkqMJEKf23PycTmxFVOYU3P2z7MuqsSlH951OtHKIZrKgFsTWDmSaticnffRSxNoBohYxSdt3yPOk60BpqOS+qF+gvSxn6JOZncnK8yXZ/tSYAl5Cfxy0l+GnQNPt2bG0KS9ia16O84VCIvA+zLvjjduokLGbEWgqeFjMRNvv7g2sWZ0Te2VdIJsw4tqfL+ChE/XclaHGJ5O+8l9U4AZG/gpqziSC/Y+kZX0VN8plxo9Q4Q52WZ+cDgUCGw1UbWGwYtRtev6J3m7r0DGgPLbzaXe6dFd2dxcGoqNm0SrOuT5pFP4PEXpXdunBeK/HOu2HkzaSCT2vI/J+mRZOwIx37+hagtreT7jhDuQNzWjU5JiRBcAbtF7zMq5wDaUg/aV7VOjVPMyh3xcI6vltuKCg/MCuvaYZho8n+2UU0yeCJqt0ij9wBL36jLrrhlLKSqgXho+F21MCAbW+eLDTOCkWd3RTlsjZhGWTU9EW6yi3qfunYS+9/06EZV1KH5OWqV+yoqlmWUinpda2YeILkuqIAZO1v34+8SIT7sH+YNatGvUygzvN0j4OazeVta7MpGHj5HeE2erZQSLrwkhw5YgDDDLVcvE1dURsg7BnTkv7NlYevQWjqvDN6AqB6CUu2L5tUjKXxtwgQrvsa/km2JTM1tn8aTNTDFSvS9B14+ylTQLQI28VLnhDxR2eJV7Zzo6c4UsNFwEfHwurq5J6ZPvOLWnpW8Eqs4XRziN+bf1D+v+LJrOoQiYqtlO1lse5wK11mKvSft0rHaW4/MQbi2OpXJmyGoxnLeLEyIhMFTxjwkRKiPxPKmeclmhwGx7Azxl/B+o9A7dacZx7PseC7NWM2zhi/GYNVZl6U5l5gP75kfTywI4ylcMiZ/b/DDvES/m8Uka2XkS+q2oWzQChOLP/JtTq6pmfey/PPoJaNW5cWyyurp1gvpf+KbdEubwkeh6x7b11fzxPGqhci1wNYEZK+JQVNvtzCeWgZrBWA/aC2v9PkDWatoCUTmDHYPGXWqMyAS4ghkeFHR+B5IxzgOFBD9SE4MtBXHf8FZfhnsTc+hKzAs/wHjnUlFZtC+EOsxWPLacyzeoGyqkcXVtWHKrNG3buX6QdqSutRBaJcUwUSBrgtQxErxmLP6ivPVOiWsCg7pSU7sykzZnsZKY4iJZRF0w+G0KSlt1h/d00Gbgtc9aOI3BvBq7qUAHMUfGqTzRfOq9jp181v9ZYF0vE8tqN4yRDjAPxWVhjSHxoifAfarc3uc0w0yExIN/WH4WOKdxj19b8Q4SYyj8+X5JYQwF/XlcsgOUpLK1GannL3ieOQ09npWXqwT6iyNAnQPApzhQVZwdI+GRsJzglI2f7A63zwcEL6+HRBQNolnHvQxYcM8Vs0j7pB/XIh16nMugWN+g6rTVNd/MGWIH/6Bcr63H/j7e44u1Yb8UU38wpPmyyCbTSVqJAYHricNidebiWfm46jtCnWmoQFgzjZlZ1yKpSO0c6xFAGyMVqkAknkJRQkB3hS2cCsNbmb/erh79oXVGkrw25QhcJbvua8lpZ0Nyd4xgolDNIRGT7n0bOTwVcaS9MHHfgxCuJ1Aju1FfPMOymWvKRGJt37kKNgUElR5MuSMfOfrzD0i7HZ0FCdoXlQ4tFeU8EqO2d3fWYwiIRWyhyQiuyoWU9GAHIp8qvAHC+IUb5yjGBXBGEUkLy2lvS6RGNjhEdOBk4L/QMNgpIGV9Fh05R7iwNN2sQMcbvD2FmCkZkL9Hqfa0KCsG/NYGIxNF2IrUYzlPRwtK4iS5tgZL+Gt6f6S16x73owDPb/ma7TDL63HisyQ5R95SSEqHhfSQk6jnJVX7sZpvlqTTHNWJ7OIszlCfwPP6Im6NTEHQQCZMlbS/facvBnmp2VWPHbNA7cugkM/sIddfvXsTRJZqL5+azNczcOV23RZDcY8dakZ4dGh3q+kguKIY9k23Rzr/ApknBR8nbPzU1NhNMZ9s5qhvkJPuonBo4RiulPBRqQcZHULLlg/iaHng+yOb17pp+4h4rQJppBM6c+XhOL/J33XDOg1RT/g+HF4xOKY15RE2QYo78Q474rUgr1rRcbINsQtZFlHkv/59BCiBktQ+KcFWPQz8KM4pNHcMKHd/vtWPReC5QL10yNIclByocqDMIFQaXjr9kiqxHUI4zSs91vRowRgr0JbfYqQ7qMrgTGmm21/QoIkAxM1azgfSpMFKRK+xHIlkpWQnhqpYzVqjcwNFY99jaLBKSvjPtahjWCrixhshqoQbPZz/2fMvEu0IdDd0HuhMFAnV0/e7981YDCNkuraWvSkr/IgRcd7guZ+8UQ8Hj5wusTqMphiMoFKoNhVRoooY7ToSyUqSP2MzqUK9xf8VMb3vSeRQrugu91T86FLjEj8XnXb3U5AS8BIcj80B+Xsb+Xzoxi5I7F2qWXOzZhxwXrHLSXuJW5Gh1hcmZlEADFH3WoDvualOZlDSJr5ah16RqhP3ySWrXAmOki7GBM64ynFAm9oCdamC2Lo0b0h1ywYskoel1QQlF0wJeeT2SORWxX5LRFY0vFC7dHDmjTL7JVImGCfZXF8ZySVA/ZXIfRa3d5iCO9FVTbb6V4pCTj4iHQ/VDxqOb+C2/NGTOvL/tZu55EgdCu7XbKKgJXSt+9xhVJLuHIK6E5rqrX0klMrstEQ4bzSBVXLVcYRt9fH8gg7ROIhFeg91WlCNhuPq/M/A/RFNtWx6g71W+4LDzsLMYawyhnDi9HMBwHURKztR2f/Pqaw6jkU7QJf8wfAQ0j+/Fn9mfxo/km1Z3iTAovAF/+qseGupwomDvuFD39OuBq5XduZv+IEHhkocwtVI7EJ2B+jWCa60PxNhlBZI3oJtiQgqPbJx9ZkSUJ9Wkb1NLVW7+GHpApUVAe7zutFaPlU7h6Sjtmn8OcWk67hFlkbNwjUCJbpN5bwOnMALOWRr2cnQ92fOEzLVun1gzyqIjEgKncKEphYmXqKP1kt+zJpQe4MXBBQrUvtNrVCearv6Zetd7EJjlDPFK4tubJYwDIQ6hJtmI7RPJusJVwz/KoUAJWZVZ1htKgTioc0+sn57XOuVYLv34/KXf4pbBz0n296zrfTLaJlRgd7rVq0IqcY7bT40iYaZw+y3306zvy5Wq7yakSn9PJhzSiyAH9ebAVpKMTYFxTPOaud09msXB599SKLWWvU9BWwd5uDy5iK17rKW4AAKjk1Vkm+oMcdDBZyMZwQy3HVBLANeODIHEqH2gJmmKxdIqUiqsrNIs5tetVvur2AK8RvMvK20uVDfqDiTV50iTNJK0/GQOh0lDXFy4qL/fizCWw5pXEG0IQQLmWKPAdg/5LMWR15nmFXcg6CzKplN6HKbj+bEXdT+fLm9fYfd27VXJBBFshkmhOkqiwGgGqn52vTXkWJ2BTdXidYAyjLoaHuhyOip4aQQonoeREVquJpdXNvjmbguXsQ5m/nN5VQ4D0ao+YcmJybkr2C8uWou+mquWYbHkt27P2YauwwcIX+vTvDFB7ivg996U6CECO56OH3sDrJ6E0oAOW/+c+pnCVkdD0X0QlyVid5ub8smJ0WomZjHZ9jXTGAVXjO4NB1EDWVo8FhiMSM94yohekHHvPiZ5eqGYDPXN21zA49WJc9OBcQMLum0iSSOZ+Lm2q5PHgcbv7rkhnPUPJyZLRAvluOpfUQcT4imH147d7R+Wwdu0UlMJ0XYBZXKs7U5QBsBpw+j+i50oOtaq5a4w3h8tTsv0Nuc77qnDyBle9CMYEBoMW7b15zWuYnjbcZjoB40bPfghKBLrBBq6wBKDhvahu6kx48iCc3kBGR5le6pde/a/FOxxcxuLCEGeUsYUEHdfxpspvlRjiQKKzWQ9irIuS2IgBOLU0PDZ4W7sLK/7SGkm1TCD3fV75/29bmw5oGPt3JSXsR4VbiYFuGOlLAyexgXY1bsPfyM1FVtCroT9YZ3dJjlGLwEbuuzbcmmcf+Ob6PJFKZl0fYu02fIUlrkeuhf/fgy0gIcjfIzFtdYddq4tX4dxHT9AmC8NMFE9zi0F8FOsGWM+sK/Cg0flrfbenI0cqaz2GuoXzC33kyW2R62Tcj/FLW7rCacgn4cW1tSVzw6Hreh0l+AA3Dbuw16de+c9TEeV/KvKcYELdIS44lgYdlRzSFP222GZTBt3oVflxjZ/qGwxcXUjC6qp29WXrOOxMl4LJnFKvUqsOAHIePcKfDHqYEfKakwB9F5AsQ953b860fohqT2K3dZF5WfQ3endluVsXObsay+3KgAcVcb3Chn2FCNhxd2GkSBQ5/0dLEB1kP4sn/4zLJUE/9mdpStM5lIL2/lc2VGoIsuzM3GRgvCSoH+yv/+6InI8MkSlLV3pYkm0PFQG8lv6FqdEkZh8ecqP4KsQmGa3Y7aewY1Pj1ZXRztBC9b1GQupVKc4rWRibmRajsGX2kJ1zUuNNjK05n7T9J2qE8VRXZDzYn30DWiZ9b5kp2ozjNMsH7oaHcINswQZnNI5ljvufR83Je3DaoC6GGVp3RHQFa12JnUOkAi6dB9X7WyBr1dCvk4LTE+LCg6yEBlI0kuVfBFqpaeEhkzDpNxvouOrN41P5OrZorqQ2ELdxC20U7onqviPtbdytJFlZwMPqMa/6MBeuOKryQXoEMhUykE15gRTRA/laCW0XIdWF07jPqrD+q80tR0bFt6UHjc4dQMXhoXQ35DPaAR69XNyPwtUGrH6wjf2K5/6IcOoJwrJxpHTV5McRZ/s0bJfpuQQNZl1pJTEVXdJNuvKA/cCAyvxzQ72YjDVdxZGyFXv+UpJUfyNa/iO2kngNKp9Y7DfXZFbnrkWmHZYEo0ouAgRglKwfxhCq6ttBZBWEQ1iWUICXGIlfhkhE1erB+B5knIMg/C6zAsxykATxyPrTly8YNLmQ88UV3kkLsLfnNvGXArAwNE9JUPlt2dTy0xSo8s2z1SxiMXyJ+gRSDO2XeoPYY0t06QBXoRMUftCY7HTbtD1jBT+rek7O+Qlf5vnZo2Am1pNxuvgk4KPlwgVA9VkWXw7dXUWRr/T6WDMtRMjPIOPiXaGw/NBs2acO5n45KOi7lDo+4LMzAAnk5RAbhSrTINVpV+Gg6CdE3q1/UwukjFbG4gCIWfNlCpYTZB5hrjtLxV1BspTZAfXsyJ9EEzJdj285BJYMfFdCypXYr4+35GgPpWvAm4C5xUimsow0lfuq8vLb4ahJbauisdcnX0PS1taMdfQL5ywiMAdKOCZ/c68FMkAcsLz9GVrekUpI7FGL0OC0kG9elVM0McQCAEjnHLItF34Ef/z67oiY20SFH/5/VulkgQRnFoM1hUcSM4mc9Wmq+0kcf5ElHZvnnc4ow90XlHOJ7VpY+AKe1amlFbroxMSiGPIvAxkEaRycLa2hZKOsNt5kR8NUF9i3+8W3ds1Bz2jU15uiefKPE+AdLZaLdqL3L7Lx2aid5n9eeLubuM/K1lX6k8yo7dee+bLzaMP+Sm/4msii0Pq7rAhvFnnkgAItsu39fPF8NessGMOwISCC4N2ClRJ/NnL6cGGljqksgXaiil08ORBCrB7g2G/OJOCu/pU8iLdZ1vqIleqodo6j8jErJ+RT1jZv6yTtKkMFwCs7Vy9REYQuTkUbs0/becF0CUwa96skE7VqTOBG4cfVsd++K97R6cWl4YazI65YAT5iDoKzrThlYI89zAKvk5R8dTkfE2z4pJ19cNxqj6ef0SoUjsSp6H1/bLIyZIcaqDgc6A4INKa+NghFY8bcmLLsdBsVF3jq7vDD0ppw1y2/ksupTGWZ9RBlge52lpwxJhrbyI/BPBPk9R7bqxrNRyfDte34xZV2VAmZcO2Y4tqV5H/qveiqLZjGo7+BWSuOG8lMtTj+qjkR0DGWJkeDmI6oJ7I8BFMY8lfqNdfsQLqABTpcJrTbyFGyudrUXIwkmVQHYZ2DaqyOh8LRgLCBQEVc6hMQSi4s4ZVhT8Dx+vNlTnEoSRXmniBDPQypCaGvNiGRgx3gloOmX9EQSUVOkcJogX46oX71C7HhHYg1lyc9pxab6QWJq5XnYRnEYe9haprqNpTlNP9jfWF1bfGwOSXpBjt5udgAR3DAprchnrnhzGsvQVOrWEaf7K9wmOl6nrzsQ5bt64qLrvHU8vE9pBWzVqMZBhgk4/AnEZgUevMeY0FtKJkqIVrJLcXBrGNFs36FtylqGAnLj8R9+/kp61yqhVVNxe3fLc00uQmiOv9vDahBSRx84iMWqeiWKb/RA2CQtK+lpt8/yqgAjsPmwXOWyVPRKoJdFkNOgnK0AK50HI7wla4jqdzboxkGZr+vzU0ByYywyWRC5Mm9c8FTO/14MdgfpKkwQLmynp9sQVoD19GTdU75CK5QXckdU0PYcZRKPeFaVX483XhdBcqylCZqf53zNq/jkZdkGRj5KhLbFMhFhWvsEg9ojW87NjYlfxxKNxqSd/wtoQ5rI1baIcAw5LATa8X68mFHOhtFxiDcPNo8oX8HYcbmjnbZLhBCg2tidVB17nuI4WTU1cW5IQX1b60LCvxW190kAKjAw2TfitdJBBTTvkMFd0Mr5htqh28JTFfWUmXcFY8J/oLRdOIgOBoA65mx3V685Vr1+Vv45nksxOyJqJbax6GDsVbWSiNX662nREzEr9qnKhYLKJhrtbm+cGmJ/aRqg4F4xVTPTQvMSpaSF7qjiohlX1ev0EV5Uga5i0GK4NfAhCllnPy7DS61QvSCGlanm5paepeYaj8v7F7dPhc3Y4onCme4+se8ws0C5Yu6a29FKgj+XSkDLgXUxe3ybL6D5Psgh6WxNNIbdAOQC2zvB5ens6X2Lh2Jyxp+gWAEQR4CnoG+qOZaTFJdKxV1QmKsU23jVB4iv7buJH1g2YXBB7h5NjLHKHdDOgWMLZH/mNiAMyWoHGfQHCcdUJ/Ou8J2qFsk/RL0r46cEHIXfzzbHP9379RkHHIqygwfzJ+Om2+HEm3Djm+IMQ+M+o1Dx0V8b2GGNVtnrMW191GRCpuc0tRvjx0nkQagwQ+adRDOCgiEORPG+XR9m6y8mUDAJXk9pOb/uE1sQhjFCaUjPKu4CyCLWK7I84yNeQAHNcFP9RTqoYhuAK+HwUqV1yb7CJ3bsQksRv3fhjDgW/lo+BxznPhExYJFCgmurmTgh2RErWWlXf6x8iVKHeJSbHQ1bKzV3zuv8+P3k+qeFPrQJHrVV0+52aWImxaYEUVW/YsEaTWXuBnBJFGtL2jQu8dURjFrkueRC/QMoebXufsj9sKPpeEBUd175Cf/gOVphuTwRbuLsI2DAw+ax8nSoMiuk6uoH1HeGInTJlntwTDWH+5KUPew49jsSJ/wNZtrUCF1OxZrXre2No4T397yOlJnx1cwH8RXlZMorllWRErChh0/0Qubr4lIaMiH4VrPzZ7/Pz1gaixR8NDYbMBV0/jRhpWRpS5uWCRRg4POEeD1bfD5ghfGNkOkjF+RkfE5uFUJqgXy3qxLJUZMPBFdUVtZqjplUSIfruPFAC9wDgTlEgA2ejuGLlVy5evNKnWKMPWM6F9OSlLoR0mAq7ulwN9tphRNPcHj4/TuCFg/zKRdSfMu1XWuUOZcip8uk8jRX59yMmSqgsUVFc+cnIiLyqkjp+qkHZH3MHV2B5zgN3nbbm/UiYQStRXBZB1A4gxCqXhXdAKUYZcD1O0JELUTLUoFBVKxy59BXIrgeikAdwn0efZH9E2cgzH3H3HTXShZjcAc/LcNk838H5WBWFXS42wd1HpCXpyuoVg9kdqPckQWia8wL8nM/46g+kK03TasaYfnZkeDUNnyYoW2/lY5lMQ0KcyjG9WddPhQjpvQp1WZnOsRSCylqUXME+M9X+Vktmi0HR43DEzOXUp5dfVcsjeg5y2cBo+oNM0rtpBMhqamU/hfwCNXuTe7mOgvbPbxsNx3tQiRT43SsmjWCeqDaAhx8Zo03Yleb57wun6ciobfLvzJF+Oosu7TInbm5YVEj/RoUP5czOTot6pZz58oHYPQaBwPeXxpQiuByEo8Yg8Opai6Z1KTiBkFCbzJ/PLSLKYsmkXgO6EmMqdjfvxBmCyH6cuUWK4w/Rq9cBHVkWDL2lYbHLbCxGy/gzhgDiziGZo2T7zgGVhMpdn/3B3TbVTiOdtipvqDSakoyWH0Z8meXTLDDjwZezU8AJp2YTEqscAogSNjkeBQAOoCR7dRRu5J2xHV75uqbdfpUzXZ7pN3qi9WLZBQDg9OIj6tUxv7nkUiETbz7I9PeFXbwA1WnAjT+dWrSuVFqfZxgkkyMJtYKXrXT2oRhl+ogYbhWDQlLugCkfWq4pORHpTWu1gUMcFqsenKjUAUZrFJPGwPfcG2SkYhNMThLocgcIcICviRCCHgqpmipqLIJ3scoONqt9V8vQx0Zkcfg6VJ8dPHZG9SomY2Yfi0iyDE1M9W3UnRg8u9JFSsgZ5ytNJpr7nMJJDy/+seirsVAiUKLn5MQc+FVnwYddf/0H90pIGDJDGvroO+dSW+6/YArPKjrkZ7eGSPFPOrk57ZTg71tnq9bXtHmSkqMQdNTXFNyclJfqPfWAeVNZbk1+087fFghXcgGKTp6SsTS0TvJU7zv4gyUd61d8NTimgq1t0lzZfIPbtNgX3ZT+jTqP9KWI7rnwZ2OUSen6cEhKREQmv7iArE3dFtjGL+MDt0GV1aJYwZFD61k8NHVV2xQj70K6H2hYjjEEo4nEr30sIhi+82LnEWWjSGz/l4YFzTSfqKLl6Zqhj7/AHxQ2Qfxl7/q9Gt6JQrBY7/Omz1CTGqyLYzoPpJ+4DxYLpsw1Hq+1dxL9WNYr8MFvlneLUwpZhXLi5MAj6ZiInLjW1kzPz/O1PSuCkF4Y5SpW1toYuzb2u1PGSwOrYI6bLWtzKHXN+nB8QgalkvhJO+Dqa2Ve9Rgkd3ikc4XWnaQvCzbFV1WNMEEjfwTSATgPLdWdvQNoejWOEe9nbCv8G6QYk1k2WQYHarxXCgKJRE5SwfoEBw+q5+/nPn5k7i1YBADQxdqujBCQ7T4xO3mKmJ0bbOBUalk0MFd6KyqeL9zog9kuLfEqz9Qs/XFIwPayphdSMazSuSbQWE3+SoZiT/q+RvVyONW60ylSKRVdZLuhINXx0csOG1P116HtEjcvYU2Uv2VxwPSyow/NwdxPz+6/CRpUSBQJLqB4SugoEDkCf212U5NiQKW/oB108V7C3J6k22qJBBmGQ2vCEbEOdx+YZSTFVTwd9RPVRJvPCOBQpZQ8D/Dc2p1viGPh9VI4vRFToX11vhBzYTeGfk1PHziryP2uBhbqkJlitnG/+i3qdawIz+mF6Q40li43F0NZMUi9U2jmOHFbPQ3d3MsLumqGlhYKDumfrO5y9eB1YPp90ekhMizvp5wzAJltwbSEkFohfqzawmiw5Np6sxKpAHkTqgE73mqN7LN3EtLetkqs19eFh82B7mkbahxl9Q+OetqtS2gkwaERsV3ViLrtS/J9486VSZu5gVp7PFsjf15uBv4ID2eVUK+IMYL5sq+cvOpfdqWMTvVhd7HZNrllhVVsZ6Revyz2PQrvb/kOGyZnHk4gy6hYTKeFm+FrboSNuXN9G3WjdS+ui+T74hVxYDf2V/vh4FQhM1YNt5t5cm5U+EYFEUW+uXJmkWHcFvhZBL4FXuHcNH11WfBf5xfIXFIQSaMIpbC7bHRe8c+Xqh5tTE3H9tiIcEq8UmsefR17i5YFj4oA4vPGTv2L/48Ao+En4T3xL4Vk1jNcT2cZ1G3DUjsJAAdUEgN2l0/jF7/yMhtwWLs4I/1MRwAtoNFcII1somylv4ZFzROkT8t42pqurr9fCw7C2KZusbqU8axlItnQBxm834sXfnLUCYsSAyKPZZMsUfzejAdaw1aMApnsvPJCqif40zkkOpadeMuVdGeB8ljqRiB0G7nKQhQPkIY61hpBGxVhFRPO80Xq9HsFa7cPe85an6YkUGTrQizIVgYd19RpW+z23KOMzfFUQSFEvw7hZHMGqwWZdvJNvKaZNyBbM+AHNh5RjkX9RvV6mA/5pozQ4NyevvC7GO8YhZ8YXxdGT19UAhkgLJqiB6ev+2sGexoaaUalkpKIBx4Tu6Lt7ldeZqY4V0WpDCHvpKLVrwgfh803rBJ3TOqGmPBE7w3A2Bjv7YaRmgGJwY8QlMLzZF/x97GvKkz9Xa23qSIYPGWaOvGixwaG7HG3u8h37Lo+TrYd3KUgJBMoYlhzijmsax6BbZ0h5odaySgihFJnuau+njX8W61JF+aRLgR67Y9HxD8RinoqYYOaPEs+MeNg85D1n23Z4x2CMCTzTNemoRikKhj8yc0GNrXIWa7ykphXT9qjo5NHJ/lyVinTRECOOmjrLRDw9FoourS2T4P08AFNKhIXkT7atPE+4m9dIOkrM1e3bfzE/c99ssK+3fup7ea7sYgiYLEsPy8ICj7ycEaDbFy7E24XgdZbElm9P07KfMuPce0feMs9mG+VeMQjUyZ0X60Y+0iP+qi1Pb97kh/xyetXkHM+9xLjeSaH/80apAv0fl7lidUDZPG+yEMGageNmt3JcD8p8hRCvIdNcEygr8cJODYjczouwfhWbwEDm1sb42BHz5VUKIGXwocMW273pxI2LJ8jvZI7jeMPaTIdRl23npK2PJ8eIp5MOJdkBoxkxrkBEXtagxEDOgFT9LRVGLhnVBSX/Cj9nMgG9OVvYzDw1txM3MFOjb5kgQVlnoMxs21ZLXkywF4bIX3paQUdVLf2qqGoPjyqz8MXXTsRsWYZJJIzzQkMxeMqSofws7pGyVhHzcVIZdkW3LXFQ83pWFdv6Laiypng+u9H0yQUQBcHQvBu1PDqAuYToniQwvoDajuXL2qAceBLLHCJiWox6Qpu5srqY6yo/ZmqWfU4eKmkGFEXO8fQ4X3Ntc1eOPDDgpRa8qfQCdjEi28ob6jVJEL5n71lRVXV0m/QmGVs0kxURyUWjUiBfIxd+B7ykxD8Bj6ipxafRRz3MjqLWQ3kyLPkRT/rG0uFiN273QFor3PLS1FRYrhJimZBEmNSDsgBM8zJvlQ6Q7ZxlgI62HNxclpG0RArEHDj23zccQPavzKPRs0f0vtmR6uJaDySuer5UE5jfbiysvXkQlhiSJPBi3aKaUiR6BsUULt/9hB3h9CGZJcrzmkgYMtKXZsuTRl3aHaxgRCMY7k0RlT+mDQG0PCx774SGmCEAitNqUdfKf10SCYiCJvhzA8Mu4TovaF//QXpv8ZqWroqZ1XkNbTBeqtMraQErptHSMAGu8Wi7HwXSRfDOSvOaTwPSDUbpN3yEwlSUyjf0akodnBAfk2ti3aFyT7wuc+KGkYgu7s3TyFwd2PiC8kO2erCju+QwcIxOvv2tPSHNeozB1Krmwd1Nk2Qj56m8SaL3C+ZggRNtzm0eh0c6VXubX4aCy9PTPw3O7jJSA+f8Pge+qRw2dZ23VNu4tZc5f//1b8TSW8Z1BFCDxJfze+/vsuZ9K470snkLG53Mme7+8kVi3oMckRGQp6R9bAWpYrUAOOc3dOto2H7PRI4nz0K9e9OxKoybZf+JVFFrHAgMGTdu4hlTRXa50TaA9cBgNODBWhRAIAaO1hA72QDs7XiV7wHXPnooVz9DLCsd7RuV8vH9aorep7eFSIGBKqxw9hOuS1e4VhDyR2LbFHs6NYFQ1KS9foqujtLmJfoYTg7cRFxJQsS2Ycqx10jcq4bZJCRlmc+hZPGRrlGyAI/t2vr2FMDQYVNOcvYFqmZvei5djmbscCjX/xORhR3w6LZXCp/k3kzjko36rYbVQdQ/CyAOpuOvppnaPDBoUd6CNrX41E/a1oe/SA+FlI7NdP9v/qsYNC4soHU80S/DM7/N0w1/Z0o37ItrdgMw4eSgBYXN1JG/qObOr818WPIdMw+2foqZMD1387af3e3TOsYA8f4VRtKx0AG3i7a5YQs2txQuQMMx/K0AxyJwRD2af1dLU9qi+WNAonGsie24GijTHZK8z0hsNKutae3iGnQWotx38r5IBHWeZp0Y7P2oGF4jJEmyWp5gGL9zC2Xm8KgMlqKAhlOAM4/9s15tBpMDAqCKAMj+pwtUVYhy1a8gfwDD1j/bqktkRjYjAICCmPS/l9QU/qyB/nu3hZFAuLE0t5Cb9oqWlPWAHJts1F85zEUBM75iVMtvnSoSq5bH06d0mRgdmyLqcIM/qbPv9g3Zms9zUqoEvqKeTcr1ZOLVBllQzjhJSY7NCB+goElDfnT8tMP4oBlrr/PFl9Lf6vuTkkF4l+BkQZNZMi+OcOrVrVtHXsdEwPTc5v+m2SYCTApgplj3qug7wBQNFWMkmGwha8qY+fQYH/VkJQOrWSDUijNct73ojY0HTm4bzuqh7X/DKF2Sde51W866JVKRDqgte5MBb9pZYKelq6MbTVWV8co+7ifaJFZgAAKCVe9xy2BGiRtEa5RZ0QaiNDjo4ZHGXn74PcXp18+B3IKaJWIfjlgwZ6th4hlxIR+43ZaqcM0YyuK2ZdHTB/mOvS20fg7gJ7FhgWu+MjOAK5Ux28R5qDTAHg0TXPSE/YabOOO/9HVTNZvn1KSYBQR2OXOMyhDi4bAJPOlaxDl9WosoqPqUvcDhAWKrbWmV/RfRglbv160jA+2LtA+N3qL/2oJ779HSY2Sqksnb2wH3NArmqWzYJdaZDhfLUmJfLhG7IBbB6x1ENTm//FNpowh6rQUsJGRuyeIIH/PfuqMmhKPrgADQ0k1SM4dyfS1hHvhh5UiAeoZGsazLck353bxGBgRJ6AghT/0HIHtPbi3oMCW+6Bt/WNUNNi9aNM7b/eIqUNDF5/MvgQ/qMqiUYhLsjSbYgvrhb0JIspuGqMfYXC82oisDxdi8OfSmza4YExxg11VKl7cD6Az8XpYgGX/Ibwhn4kU6tb3qJSSiXYrNe88/fjPUGkRP8DkJKPpic9bfyVOY2b6ZljigL2F4d6OXQj/cT5su/khsRzYi3u/mDI8R+T77kFmkYnq4XybdhybCpG+w4iGOVxr10gVUFHL4ueloPVogVPl44sH94PtfMxJKmkjFqDQQ1adTZcL2KOBgqZC0ziwI5zTVf39mAQfT/a7OcCn4M+zywjxQvaxFg5oXfcoliP3C0DYD9bEFjxdIqQJvIpDeSdKnYN5DqancIy7lMA5pcan80caIke6ekvEDGWbX9cVhCK5QTJdrArF6vvqNNKp2bUgs+zU9wx3U1yC2mKi2AAa2Iom4tBZI0Bsn9adKTQ4VR/qfTJNaSu+mQ/LPH0WfJvTzQDm+IFIUGVhAFCb30w03QGS75r/GShcL43Rq4ovXKtCKRplg6UlkLuCHlK9cdVaTe6M5HOvcUmZlm1OvkfsDXH08wSqSthBS8jDy55xWsrds4HS8RZ+pfJPj0i6I9JYCwTehbqG/ncWLlHxYPVHgt+xxIRJWOJyNwq9wUGbTm0nvtPE9XN6okND8CgNatKuM/v3szaqrSQtL1cl4QASExr/33guJN150fejcqFc/W6KZioYN/68vlpHSXszkHKMexb50gjgozVdaMDUp2ip0WrHk06rnjH9qupYpjGOJlS41vqMwIOT/EKG7gW/IuJ6rdAPd4c0yrlELHgFnSjQi2LieVaCfKL+j68s0QTOvZw8qUxJdeLTW+k6LLxjejtP2ufelZWcJBDgw91xk+PuNOx7GzDd+nSVBe1HGblKyLgVc8W1ZA4ijDpGQKuE5ZQVmsVnOnMvxmn72KW9YovKpNKRO9i6IUyE1kCCLeDE+fPxRkI9JpwiBDtzk7uYa5L7vyKa6bjakuOSLiEx13TtqSQ6+OfB0GhApTtcLBSNdxfU3FoYt0L2o0dDPZG8gxHtPH2TdbzkX/TmY88IoGpCxAw8zE6BhfemAf4j35cPur8C2f8dmBQ44bTJn027Z1POrpa4c0bx6VCaUaLogMRP+65LL3cxfovCRFGCMKwbJNNFxB9DyoXWwi0iQEwt1GYONFlw4v479fEfhaWXiCrZbXUVNf8jPProqO1iN+OS/FjFpI5pBC4owYTkGTvaKT9vFHaOuqSiS7tHVKK6z3sF2K9UiZBABnBB48fAMYPYsIXwT2jqeUGu0RiAYOMwcWaj04eiNebQI+aL448WZgYE73emRJ8j0pGUuaScPx98/EYZBL/OWEJf7VBIhxDGbf1COUUIzDDaO67YpepnWa4Lnn19n3IyusWvTTgAf1Ali69oFDzsioHVm4Ha5IA7iWZN5HzpwupDiUEJy7UmZM1CKGMy9mQt5zxakDGYbVN3CZwt73q/qQk6hQ3T3ZLBfMhS+iZaztktGiF53OFwKzm1am+1jakjgql9F/ZZxFK7rgKv7zyv5pszgbm9Uzz+4RSYlFrrPnd87tQ5MESBgZEfVsXvhfJZducBQBb+AhDJdCl2vB2VMLyC2jzEe+JnpSLPxeq0/OyAnf3BdjQpC9k313WdO/w+vIgu75FVTbdglCmcJWenTqETempL7wf/slb0RaSB/NekuE1CiCnHR5AYP4H9XAtFyjI/HPlzewfNS+PMxosE0RPkihM1fRp9w5ZdYWsnjIKJNQd7Jc8KvqRsuXDwYkDnL7okUrotH9dU6wQYd9yxUx0huDUg9KuNbGWLH8KWLWB/Q+db8/C4LtWqVT9c/pUIYXnXYYGM1dd2wYue2tOeAmIYpIUihH9RDVNRtC5s/NF7Cb5tDEvOjl5UP9+bjsMpZrWnpvwTBJUymmv3viWsOkHaIFKR8PcCibyOraozJKHpryf/xPqTBZ1qgxsv+vZ0MEEpdTmrjzIfbcQcS9wekcpWB1QKrPXpIm00w/H8r8d9PU7tKRiMl6ZdzY4WoCoxp0JKpzZfy0ch9uUyOov5YlI7Xl8GrW2j03OvOpz6fw3kUkF7ZUK7Qc4zDGK2bv4Se1ymjJVk1Fad70Zc1d02cj63JnMKdFHsQjnVXpdji3rjScTwG/OI/MNGLRFw2mdH0duC9G6l248D/RV1boszfa5MrXKv6h7RLuh+dD3jpu3lhAvorxoAqA7I6qORlFxAuz7C9W4lK7DlBgvOusOocUVqzZ0fzjtJ91JSbZJnAhrzi20IE+ZkjVcbDG28P+C4W0AesZLY6hqSZhoJgdV9IAqBkA1Rhwlz73YB3P80Ey00zrgjTKluegNGExOzBNpJoZdvdATy9MMPFzBT+ZS5N7RxAttOrvj5Lk2vgzi9JH23oj0dOEn3p0Mrsrdw0mlw89FzJnoNrVHm0Hua7dvjHopguSNE5zq6dH7/f/RJoWs3180Z7ANQ7A6z44FTorlDR7l+NLhNPpEQf2zOR7dPMSwdC1dO0RZWCwuSXLyTERfmmAeSIOiu13y+B/JzJ5avipLPzXS1kwA5WTq8yVxTMhHz94JhchGTU7OZa7V1SjCaDyHt5Pi0hWgMsBfm/92bxOyvJqyVcqlgi35m2Z79A6562aFLvbCt4k1xRXdrqIFXJduBOO2Rf9yYUD5sWkUS6DfRY6wrN5yBEGNY3SWOgvxgE2Wq0NJxDHkUJ2Qgtv8wkwocje2d1zi5bwzjAQiKuD6qD1fc0b7VqeUG7IwiMPchyBvZTLh5YNV33sCY1mqJc1aX28+1jR1eFBaMXkmoR7kuf5agLypTLbXh4SHUGdW+gjsFJ/3tFrzua1l+HVsT3GWeMdcXwxK2GNCmPZ4z/0L1mA4xVxIP36ZyCtXU6UCQ50s8/ENLiViQ9udEX2iHMZMiRUyr4y3sJRXpNzbxSE4bAtpiQbzxMRUrUgROPcILyP2eED2GKhp0QbTNG1nTpSCoz3vrvKgT1RY9fQF0auRZlfGiddwpBhFaw82Aq758+V8xAhVIguLi61nt7U03ukbr0KD87Q5SnrHmsnxCr1w8c9FvwS/Lv1IGH7u71PJuNG0voydUw+/PJmiF0ODI4CTRro4SsLT2V2xjsl5XLu4/Wn44gDatu+lFgDlSE275K9sHkOdS6oyP+juQJJqx8BirgzHFSfRlBXJcWQ2HzHxCM+8DcN93Tp0KfYUW1R1/FqmZfQPOyHOq0ZniGIOkL5MlW6BaBDvlBzVZAsUKVXel/GMx+NiMOJvafbiY44/fwqnSrYcaAUxJgYNctqiiZg5Ju5f3TSaeGVRcgFWxALSJuhALbKl2ANWMLgRsgWR+wZnKT2Wl7ZlfLkBKupC0dYpNGfWgr9NK8RbkT4sRXOjSo7TfwSgStZjwXum6uOC5NLDmBUw4ewTA1QxUIw6XBUvXvXmVXjmDx2OElvelpqLnXIJDcvfTk+9b7Gy6edB41oYC8N3XHdAkNhqTFG6PCPU4ML0CITdCg8N8Uy9avZS47Twh/OvND09NI/O6PaWIdlic90JmmlGapXT8ovtW9Vcnr/3KSgkJhAbah67ItGjgro1rBQPc1q2qC94k8mSiYglhIYAxHEejoiOhhJoPAhmN7DhSYkIaw9ZK/D/LZo8ybZ2ScKaCMaB8vLyUhwjybSRzBbcDzHkViq3jhA8FY944CeHzIf9Tk8seM4UH645dro/8SGxYa7R5KsAiDXZUS6wiIemvaSxjvfw7Z5vd+7OuiFdyICUruNN973BLh4FHUvOZ+cwGenWdb8thCqSaB2udf7uB+Tm2NX/C8Tu61oPHCFiHQXM1x3P+rlGbOnAMq7Z/M+WnQYBEuI93RjYlB6xg3/BMYpBzsJlyuAYm+4mxPUVL2j01J3zjuhCRUwkPcCfR07YSeHZxCdtoDfRJUEdtdY5QeFuSM8R+CcFzmGXCLZ7pqdxEaDTOLsypjE7+V3VcYZUudzzKxyNeQzm5C/QV8MVQXc12WprmgUwQA+CC0GwfLJWb8Jz6vMaDUSlarY5I2Wi0fuRGnD70nO2WhcW+DpxXanOiZs+ThUO7achKjgnnVwGLXMB6Pv/W6+S2jn84ZbDti/EAhMvddcUxwd21Vvk2JLH9OPKAEdOGtA7EFIH/TXCgtXdbcmQYoTyCAlY9TQZA9tK2gzURM2sCxC1d9DdsdyLhhl9EIF7igrzAcU3U3uL2Yy3JRVegm/ekdBxDfRwBN4lGFAUgLAeqszlJWfxnCYzoijW051bm2TFx+chPe3Y65NXjkcqgMCQdvf7OiopXt/eCw/UHPn55+XtErYbltRrxO6Wk+vhON+7ph5cKVK4r784Vr1Uk47qdfKW2K/CWOQS49edHgs+4EerIZmO0NYT0dv3ABRmplFwo1P9rYIWEVFjCmh7ItgiTkS+Yei/IH5r+YlWh2JQ+aCaFlXLCMiXl8GoROFflnVXsSfDfM0sM2WPj4kji5DUB0MqYexT789Ye/wNx7ih4ux0uoDaJ/imo1bAtBwPyWP8elGiVRAADlSJTaNbCSjKrmoQqgOwCDTq+s4Mav8AIyBXmAVsVb9O9ZDa4vENUSif5jBVxmEtFg7mHNFc2rBB6qvsA3920d9C1E/o0MSaC5jNfpZEvrbibAiGYi6NlsNE7+aZObuRj75MrGmaV9aabIQdy8DvwAR7DJXBu58+MT5ZnRq6Iqj89cMFyqgcKLsBL4APTS2WfFsyzNy1RuA97lPgdmq9+P4hXI6Ztu63kxVZdwfgzca5+8uJk+nhGnWelCsSS2lZvl9b1t3U+VWHtOMRF1tGFkdH9m7G+ObqztOk0n8h2ccFiEBWr19c1tydooUHzuHds156NBF6fX7EN947Kv+aIX/CieO7d/aXL5/0mG1nZ2pnZtiNwCqCLVFjE5tdR08yF1yh/u/l2y20OWwjcIN8KUixOMaLos8XbtyzX/T4vJNQTgnaEp/saE84A5lsZh24rYSKG2zjxzTASCjWJInejAjiTtnjslXvzAdvlnaNkuYMYyK1j0wxl7kb6K7xXyvGKpaEqI0kXB5I99YZ8dutZmmV039PVJQ6muiqAhQSG///2LGf0NZWeCl+ZRFOGRFN794IbVmtjErgMkV4/etuKryA4Udp+PXiSCzGqWoTh6FDr1vZOmedveU5mz5yqJx5I6HcVjdKxuIRB1RD9ERmP/BJg5g3Pd2Pn2EsfK7BwTEoeg3rTUl5cNu3j9Z78AWBYEiaC72By2QH5SScl064oUCrH9WVochZSAcDSN5K6H8LLdY2bhFnXw7cqlTS89bJwaz3o29GeojZLl1l0ybDkJzRQA1s/gWZNXwJVU97zJXyKIO4ZXObkya4mstvabVFVHbp3MMHy3S7qXFbP7d8qkaP1sJ06D1xTjujGcLEsDwUb8p/HQVo1OLT+nPSPwsLI63bsEued2lTE2AsdyEmDhyuEVzS+BMJ9itbSkRb+r5MADJYZ2TP7Ymhe/F+MmSnU9/84xhgPpW91x/XtAJUK/04PQwwXo1swnSuQnUR5YHLxTq4xPAqDdpIYvO2lbSLF9V3WTI5TB+7HH68Enu+wTp3Cs4wPKxjxCzogYnL0522H8/FhaWHQGrr4HAdro50XrNhuv/2anNtXkI4gvoHJxEsbRj2ZBR+b1ob4DfselUJd7PoMxJA4sOOZDGfmTOF4u8V5i9RrutBKwKhrixuYLGfTd97RbNw6r0jCrv7hBMgRNtZ6RlYFWascN0bPkX2oCEUC3d7PsqzQL7HyQzTurWkc/9oJdkI9pkHHDongHC1XhKJa/7PvNGBLg27ECqJLUGGHVgkNZxjJ5UJVfDeBbw9VENRvNojlj21gqhZ5PExk2rIguCaLHEV9rALTnO0QnK83KLlwGmp/W4chONnHeBwfhPTPWT2+LlD0l9tJqM0TfX46a6SvLCOcdJXJTVN4iQrMNlcX9rZ5tKM6dU1qDRghD3VJMi3KeHcgfpk4vqV3jY5xaMtM15lkMjJtJWqmrJztdd15q20R/nQElkS5ZkW7d2WXUCz/aw8cyPWvCwkbxbBl6SV4qRZd60vMCmRO2wip/GkazgXu73/01I0ZlllQ9ZpOSZJCfmcFGu74vaLPaWyDRzNhyMC2gU5eudaDLAu1aioKk2Py+5TxTAqQk9opK4vWbQtLyZqLMumYWLYm81xi6U8YMQjzvFcqIt/a5oBbC+c2V3v3pGi+PeOaEXvDQtysbZeeqmtxUCX4utY6jgX+D7y7cJvOOUfhtygE2uYJ8xxhukKdq95iZY8eE+u0VmrQz0hUld84JBCt2qn7S8w/icsgE9mr4yZu7Zci1G3vGMAtKWnNiSB+OgegGRfDk8wD4uRXvRpOP7FJv32EaVE28UMQAEQAWvXDsR46Kw74mR8rbhtvlXmd/DLaQErxJwg/f9YvDX84K2f075YenP3Q5+Hlxeisw8RIRimWdwUY07CxNu+6Sx1wL2GnbylxjPU2iTFkF3L/zetMvd5d30tXWqvhcUmhTZ3LzszSVGHvtOlUUoGZT3ev2YILpLN0ZfOoRB1r1ZWt/eq0rIXjEnJ3veEZ5b7T02lpYRcuQpE8qPIPjRcLCCTvjNnBv0/TgmLC/zEdBwEnyH2NZA72yeiri1wmgDty3/lGf+ZBG8LBcyvqZsItiGmNrSI1/nU1NMPbWqgdjlkKah5xn6Td7aon16vcq0L9ZshxfvqsWuLgH3HHezcIgKwOqm7uImlKnLFk6m4zcZdeLLQieo8ssV0PGwmCOFKKZe99+YzGAhy4wo9VXqTLskTy4m+e21cLZ94trUlAGsSAeD+c8uFhTc1EPWC7P0IctLuziGvBaPv6E1j2jhE5Ed+F1AdqKV7YA72efhdj7NiZFrtPtEOVWAKdNRA3tcTYJennpHxUvRzI0FS+TGiheKSDBfXFIaP1T2T4O9CQYN4fgenHyDLgyNHN/+bUxZwt4R2MCEf9sPZ7Py1Mp3eltWMQbI24JZsA7ynNA6dVHoQjIQsbs0p0LonLtkNWcotD/LVjxmMWbHvIvGKJIYa5oroS3mIKhgc0WwsiJR1wmmvN1WQy4Ko6E1cLIcyfEiWDCCE1yk4KhaXBarbsKvajrRzM4xR05vJ0mbkBkE3Vu6vYghcJFj86QL6NAHHg5h9f9gnUaq6bM6RHJ56gU5BXEpfN5iPCdjixti6mCxki9L3CbeO4PzYIPykedjfSqu3TK85gC0i1pYCscNW0sshorUGaYGfX3b1nVQvd8AwbXIjG/vRIdgA+DLzGim14vjBvkjVGTQFfauSZbbvpInPdc2GI3/ZzTHnbFmUQ3kS8tYMmXABwL2gasJevPLALlbZReyI6dAHQmBZ4g7Zr21ilsf5Dbjv/vPtW1VwCHxds7P0afbyYqc37qUc632hMXHnrY5K5Khlh0CZA6fH6+ACFc1Es8Al6faVKPt9181e5AzzlC8krcCKFe+oCeQO4II330XAm4zSk/10XPY1v+QjUyHQNm4BANtfOmYzaUhGuHqkbmoRWXaWOaLPeFhVtTEgNM5g/9oR8EbkT6PdkXowJMV1DuIyPt/fh1F90Lfw45XttWzxR7+cyjaEOWLIjw3NEyCtxpLxPk0WJmvyh/zDTLzybZJLjby0EN4YcySNiF4kpORdalN52C+ZdCxbES4KkGf+WiMGWg/76EDpE8yshdfq5xhDldyYfLsrvntfPmlL6JQoXWMXtKBvgzjR5V/Qhv8Y1VdxUZ/pxgprNFYVwYotmkSLRvJpHywKRvHcFdRfF7jKF2r9hU+hxkl4BOWT1/HVeiGDkah7JPm2rR9MpMgAcrZf4gSO5OUCxZBevOpsfbeWlWSririIDHcPahpuvUUhLGR0PKl2J7C7iTB6KEH2bkg/Duni2XsGfXAn2BsWs+iHPVDJT4SAwSoFJWQ6ZXLmUWqXAT4MwgghuXQ8ws1cB37W57hBTZzuGicU9SYfWF3K9ZH/TWDr/5yWL2o1W/RwMIHM0yKoqeIMnZxnUclOMOwXFAS7fQhKH9R3uvvxVlFfmUTfHagPxnO/RqjKDS/y7AI7AAZeVgUNdxninAgB0kTwKuufhVgLiv/cGUkwU4cawPVQuNDPSGAaNSum23/cug8DWegGg/xg7f3BlcgLCFQd9sxvkiui4dqLJsK2Q4WOzNgc96TXb6LeEi/N6AuJrj5Uiv1j1DQeOGtw2iXkYMsgz6x9SX7ABg8p2o79mPAVdyISEtN/307Gia5Q5W99HM01MIp+pbdEgWC5G+PZ3MgTGnjqmKPDjZ8zCmcB3ER8Ubh+9VCYqPrO9NrYk39mFVauESSPbUMgRPPa1cysQw+aMmM0rgJGf5uT73oQaPAAySpA6tagX421Yjkgy8HI1lDKJfmVbTscuRL7uKW2+9NXmbBZCQV64qDfUbkRcujsUCKh4TKe4+eakfP6BPhP5qt1XbSi53dI1svdR2McRUzjWstTvcMomkYRMEdtkdPF946+E+BqXw+eJs6dwQPQ7FpaRVxKlbXJkIOBTm6glfk1Bb137rdqQRmsotG4UosaXbtDH/yLkWM8W8qUxZtDwzh3wkCSg/YGOkTr/nP0eaN8sVBjjArh8yqlqOM2pcPyKpr3jkL64Ovs87dBJiokBN2RbUkcUtS8jureSfAWtnljnW/PPvNw0NVyItTKioo5+SzymTajrMJkeVd650YcFL2UbT4DKK6wQFzU99oeoPncGdKIPx/GZgTrg/1BXMEbPQ+SGtJszUhwB2ffJG6fkmNA2d8AB9UYSCUq++lDBcXRbCFGdoVbHbHO2QaBNwtMh8hliLaIF5U8S0XHh2IkPMTDucDstPVdiHCoAYUXRqKFy6bxt8mUFOxs8NmQhlJzQ7sG9Wg9S7awZdz8P6+L58MtAUjPxgp1w37hWLGKMa+YU7ZtCLfyzVCNdWAALSGR+kHdcgjpHvmc/tMcmw5xs4hqJIbMD581Wg8RjHVX1B+lpI8izQyKn0ekPsBTXUkkRyNju+Hae2ODgFeZOqTnoiw9yKpGvYFAH9EYIgN3qfnG+wWi9JLgmKrcsvd1mcjyDQVqac31kOXkhqW28afGlIGK5eSCQOWj0IsoaNlXdQtUz/i2k63THrCWThsh2t/tw11K04F4G+hxcVsihLaz2NcHFP5svJoS8EcR+uetC2Xi58PqTkdKWm3INcrjvr+4zhD6foZ9elGCyDUtqrj3mp/bYUKZ7wKmR/EHBmDnFVedW7FjzmgSyEwyho2xVQMp9sIpMfRUSSHc/NaeeCCXltds8kalqbUsn/rwID1/eyxyMS6dy86Wt+ZzRo9RmjAODDHFArW/ShgR20ntO/AsqpzJxLJVzRd0gvjLfsA1ogUUdpMKhm7g4F3qsF5hpe2+bjPbe5lK+pPWbD1ifM+ODc6SGpczGjZ1HnO38oOXNk5fWD+TGGGUsaV7gqJAgxuutINLARJ/K4la+OftAow6i9jMrOi219foY4BjY9HXYEVERYeghavy/xAq9l1Miy2YgDF/Nhqks+X4C+ReKvy3FhzKtzT4TGVEQBxf+B3ZrKtRSsmQnQDNpYD7a98CxUQyxHJasQtJhYFWp9mrGvCRCOIoP+Br0BG4TkmsnnJvLaM2MJ47r/lsFfDchesvZTgD2tEyfx9H0TXphEeGOaOhoUvilJc/e/XjKGBTNuZH0ITWA2D530MIHP1F5GRNimZeo9iWt1gIsfYrbMIROjYw6R4eyXF86hrUUQ/L0x1DmHoWLn2YOoGv3oyox8ERj1+ZraTSyBIQ/xU5KpUXi91Pu2Ikg7TJK7JF6BW4pZf7t0tM0rM3IVLSYkoEbxHdzjo1eG5xpETAoCDypdTGn1vKm5/sMFSnd6szdl4kVWxhO4FZa8RcdnHee3qvF4oRr4L2gf8LIN2WJEoPAynHZ4TJAICDXHckJ19eZPDqV3YvFz4J6FB67RU8YLMTn/JSmbkm/XBJQzCIePK75kxRT8vjZc7y4Ybr1BUF3CJMOuYrlxietaQx4pCZtgvmOobwwVUPUTR5A+/D/XlWCsx8yxau61cUisemN6JqgcYdPavUlHd8tJ9jZDSesduw21+jZdaKiaWhDzTy9lj0b/qcBDMPrdNHQ/STjMypsICpce6e02dFAtm9CvahCNs/iwFNRZMjqKe4YQh0DW9qJOaYW7Yb4yTAv9yjfORHEEMqGiPk5vGmECQsJDpg99M8PXJyugJMo0B14WB84Y2aybAnLiljkRC0llEZlFAHCp77tXr3CjBRv3RVcEVZ8DnsTmqNc1KHY9XedR7sT5Jab/tmeihGGTR25+R4HAdFeD/m6yI3DjGVdVGetJ+djc72pamP242ccUQxTOYTwMIZvN9P2cRkFbV+sDeedWs5xDJKB1JY5Z8Jm5erpDMIGCWGi3uQy7hkRiQKHc1E1z55pw3ixclRAbAyHzIijjdpkIWPRagFrmOdkIky+nAonlw0y+OK9RywRP6PRS3303rZSHAiv0ZefR6LTDcDkgeyBXOr/fnAcg8FBtQRPBsCkol6iBfYBQDzHBzGOZXhwk5cyYiBlav9sMzC5ddyQV88X3GJlgmbQaH5sL1lypR0UQIr347YD1QRd/xZlUx/ZkIqDK9KSUhZKACrRhSA2Fd2pqLgb4/1fFMLFNc59kD45bf4BFVNA0j0MRfqm5e/lEmOaeOqwvsOrZLxOk/tRQUGzRXt2KlmDnTspy4K5+f8BwXKgcOait1r0Q0DnkfzCxW3wyT81nuwPWPOAbhx/oDEWljZ6ga+8vLBPRc9TF+3FXB6cKbGUsOK5w0dWe1cMPjRCGQZbrKpP6dU9j4PtJrK1DjcuKDEf2rdJKY3KAcOxet22ERjNUSbAcBaoqHTAM/aCeHLnNIX8AfMM+hp0v2TWsKNZ7rVYRwKkHbNO/ymnc4+xdgbLtns1laBkQz181zmwi6mG7QCQZQytxi8SP6oKG5DqmaM6gVqf8JgmXyK//Bj+FkEv+OAWw1GnhHqtbbF9VeUCxChUCrZMYEr+QJy38zGaY7/svnfiKZIe6oYHFPEwYbkJaDk9Vf0tdjEhxJm5n7DB1VDe9CKXhTp5DrGIJ3pNz/qBOivQvZLdkehFrAlmY4/6jGH+nKZSxm/m8QfonjkYzO/37iQv0wWb98jE0F1q5iUW4K3zO/737IOza0uaCwRv3F1zsJ0IX+RknjchHLNQB38Yd+6smfeeIi9wWN50dDqZkNN0NAo088Ag4FHFuKHQKK7R+iuK/iZAgJI/eAx28UXaiqxt5Ltz7UXFE48rIC3NdiSMsKLwuJAelAsVYaXyH/fb+bs79iT29qEngtTbRd+5ojudwWb4E+YX2qlNZ9a5HNUTaQKApiaDMED2erlr2upd3VSXtTWi8c2DUiXUZBVtdwwcYEjbg9gGqfjrwE3zrO6ifLUPJUM6bPTzSD9LomR8LG7VRo+SyQFOBmpQiuk15RgjwFTXSxRC448zibKQJjRxtvtcS8qRWyZAoYdqdRx3/U5bwnSpV9YVOjWeKdFhoCnBZxo59xt1V/ChRchMWsrcs1sDAaQZQ/wl5vw60Bi6lvlS2N8KKGReZp95lQhs85n7WPOt6tdPuDOyrLU+fp/ofiIFHKQAWPdmLCbJCtL5FHl11IaC+2uUp9N5RZzLgUZ6wnL9cmEkHVsckwrsOcbnkcLpQ+RLdtW6ktYedLRPgEXdIBlHzO/AkmF4xReUG1QQ7f+CI1n1otxWHRmlPTZW3TTaQjXpJo/aLEBxhBpWIFbdWI97eFiHIvmO6Rw4VirpDB/rUnEqlgFS0pCYKx2o78eGxNzJ0yBt/XP+QpT62r+BLq///lnjjftZihYPzegXxBq//l7Z8YiQl+nTvnfJ1nxyr6lSNSAM5W0mvgJWlrx2ph148v2lcVFHoorvf0t4FfmiLGX+lgeJZyrMMGMsntx8TBVBJW/amK1NMUm4o0qHyEOWGJT9L78cEFxXQanWmLgM3lIs3M5PbSkzP2OiQmBYgJ85FFBT6wQXP6ZRx8m2r29Q8OxpwZ1OaDLe7pevYfq+fC6kICwmSs6LVboqcPLMIzKFEJfDzmQpUX6/IUqfJueBWodjbodjttju4vTocHrcB8TYu7SsbMH8yLsLRKdWdkyifwH485nKi0zU4zoUbYVa3PmuyVnVvZ44luGdzFUN8siR+w9MEv8EQcIwKgVJrepyRhd9TdCu6xbHXOgl1C03pV3FIZ2DwrmQL5GIThXVE2ZPgEdaWOp/XFq8jPD3hahiExQTXOuLOI7etNLmMZp49tl7up/DgkCwxpxNkrG8PacI7s+3lbrLbHXRJGOrbpNHRNN86FFO8F4Qgt2+3EuA5oyrW/h8RIbmW+0U/JRuuoql5gosDD+/Gmfmf/p0OXyMhSO173GOpyDvONXeHUe1Kjzd7jmE4kfeDlebnPa31YIErRXaHioZZeuWcPwD7mOHsemCS3rojhhCSSguCM4qOj7fuW7S2YsZRDU6Jy5ABpjQKpKia6Y0pJJ2qZxtxGhg4ARcUrS1TrnVKiCaRhtQkYlHSxY1ac2qB4mUrr6fzJdzH2C7CVILmphS8ll3ipkaekbeBmiRVIR06B7bTc58vP/vAfim3nBEsaG/kBzXMpgv1GIWIRsFUR80YBuOCUwJR9B+aNnD2pK8ByNYVE3GNJ+L7Nld1YPDETXl/gRynVeU3U3zmS1WmuvgWLuNEyWL15SKUA+w1iTaERqNyjrqGL8J5R5vUoj9AH7jxJs100OErduuObQGGtGFw86pjLMiA3XEtztyOtI3iI+yLppUPhzrx8Mn9Lr6v3iYFmwiAg7BU2WTnJEkAZ+x2IIry7trxfH/dd8CnUhfUkuBkJWjjE9cQqYTFNvChnhWS+qYR0nAL0dEVwGM9CBlgP3fpeo6e6O3OZCzt/QEEGqB92pkP9p7XfknQUCZNMZEhOOtEKYDhdV95mEH4ExPde4vCaC4G6eoul2K7ylJOpBOQfI5xWLEoGkm2kllnHbNpQTomhiGAH8DttYK3Wovgcz2Wp6wxaKmQYMFSoW7WaVEBw2VIOdehhu/QfKL+ZfnlqFDflDGCwUE3O6fa1vfiFUFdTPS2FqdUokRutxl//EL8UqxdCYiV8REtOa8miYUkL7Keur5D1r5yREFauCX1Bj6zLP0gmb4wGRKG1q6WcBDOsytHzR2EFSpZzPAOoZRA4ai+pMbrp7ji0+TYuA0ZErfqABFkaXoZzDVv7vfxA2q0A/1tLNiTQNqdDbsQrIOXXp/+SSjNV0jix65y3fj/bSUBeE4eNo8l8NXZdvS06Fvh3F1blzVt3d3l5YbJXoRUqQsfuqIhmjFYSW8ybg7cvKAFsNRIUeYghpGAqRDouz1NqJ8iHv0p7FY5+Kjy6xxWZvemJeMc0Mry3rBb1GIT9e3L8mp7l/QfBQDUe5YNqducYWlR2toI2i7obdoWowiuOjQ7nn4fmvZeeaDp/k/d9UHdREWhAMNPNSYoujxboUC8a079JYfo5jTuqD37JEpxgYg1szR/GiWb0pdi4lH/4AyKFlv69fzhHJjLFFusAVN7XUOrJaftTe0A9ul2eOKgSakNVcVmLH01afITeJa/kx40MCor+jt8NKS1u7DsKiZMF11e+/nbiCOdnzgzSSKeXfBCvlbL9i+05Ko78NiLy+kKZpMuPhFX3ngo2WcSS9LK8xtJLjMUoEMgSbd3HCogl8CULNhIlmmMQh9fGsyrf4veHWxPre5Wfq3cV24I7wYTEt0nNbOwSOko9eANeX/xHN7xlFiLKAghPiLDELoYIHGDc4hRBjlFRWYX9ssOJse0R9ZQ7pfjfiB+3alsT+NQEsQ2OJ32pfDr2IQKkpzs/lPFemngqBi/b8Eo3Y+Lqzw1BCU1le63/oQqzsSCcBbBPti5M5rk4VsSwS/NNwN9TjSfy/GjcqAVRYoRTx+O34foEeuOuqeqoXsrF2DcP6V1QKpq+AK3kO2aWAPtYlkdqdTTmsa52FdNiOXQhoDePdbMF5UfSdSnMKf023GwkceSfvBXc/D/BqqhTbCu0TFkEdYpE/fv9YyTBpC1l4XYRWhwlPmDy1N/Or2kgIPiEQbYR1ukALVHAaeOnzVZFCy3W/s3VZ5SueVEumOS60ECOPmY/HoHQC5XR6CONw9PMVqtkUO4IzXCA3atJV63jgFGBiByJxZKPuKgKacWGf+fSd2az47HPOMAWMTFQ8iIMJeCmQKe1ub7trEN9ihFXpMQTAseMR906WJDwOV8NUlneLnwVsAyABSbOymPbbZMCzjKuwr7XADlwC9279eBogHcrXuQTTmvHHv7p3H9hc3dLujyv20CEhbTHRa+CSxPPPBkFE6lSfHKAzckCORMBeuCH9V/KvRzgQkZT4ojAdXH8uCZTrZ9EmaMXamJNk2vUaxaWl/IH/Hu5+AiEPExrok51pt886laOueuiMkoaMs52oTdMNjunQ5zGe58TkqvCjyaosnHE/zqbRjs1RuSzcHtAzbJQyW4mebBazF9xRSfwTK46aaYnE9mWcMTr/8WMSAXCgEuN9N7XN35WbAgAfspeYqIoFq9ktwId77mkfY05Qpegi4rrjKg+wKUUuno2DeDA0eHnHmbbs3WFClO0rTfJGzlKTss9+xCUCZ2j+YFfWITqvlN098Lw/j2V7/nv4VUmMTExymqCEDzi0DKX1eSjfxm1rIYa7rdDY3SuaMuAOZ4oLu32E4UdSFsXXj/eq+BWHZBwlE6M0pWAZhHC1Sv6Qnj2lL/eAlYwV89n7dmdNe2a8TssNfGmecfhzMiYo9UI93gtUBz4UmdtauG7WR2/fCZ5x2kjh1TsnHUZeOT0pHI9tnBwc1LLNF0oagVdn5nk9cH5N0tDTPskT7YIDpc0yfbSvGUFWFryy+Q/DUT+Jq8K626jZtsVAY6+/F7zZMWbLKvKG7mzr+9eHnLydSPAQpQhXs+pYMwvuuZJ2LXmONmheVByFGMpwLX5SoLB2YdHHvrTUqHDmVeVpD+iLS8i7TPpimFTIN4ALd0lXWv6UWorCEwbBbPiNikjl5o7xVMZeXtDDTpn2frqfycs4TEYVjr4bT7gCT9TfRxK8PHlcN+MIu0TNrh7PdLC/t+AVRoAkEkWBpwSvOWLyCW7azgnGishAVE9G919hO8XNZLwysJ4FHcfkLzJC6S1eUGD1OzJG7zUQlHQMkvzAw8oXO/kew5R+3W1lBZXM9R8xTPxVJwdN27PrW5/hvvKx+oybeeww1Uerez9FKYxvtOJcwG3hBSLwIr4wSEqBrV0QPqWMtbOvnMJ0Xdu02l2A1P7g1Ms4t/qs3DVwhwABKHtfphsxcp5u4U9TYwlYrkajUmfQssP+pKOTy1Wm9KUEjwm7SUdpK8Vl4tv9Fo3WVo1MaF5emYdeDYkIg5XNJFZXlNGZQmZdsE9LD8e4HJeqo2Vw8+Z7/GFh5oOLRdKlPGvxl+6TSYOMy8RzZ8B9C/fFLMyEt8ZMEMHpZK0aRPS5DqNMfPOv1AtbBmf8hh8eCzIJaj1etOSB9oKlcIPzfQqSY83JzenUSpgWe5SfOcVBNSQmEHgeS5eyDLCcbmUhNG1rWNez72bx6MsLJ+jO7/lDaedSpdNoala8cV5UyqBZnp369C/Hx+Zeis9QpCFL8zL+nzjlNufFTELDpCeQNbD3bSiUId4E6AjBirb4zi8V6rdS3QU2PY2KI2E5A85I5Fj3hes3zLDzwv1RK+vGJ/hJszMp+gpKsixCPD3q/NlY6WMeytfKRdpe5JU+2Gx7buzDZhK4HOc2Fz7cBZXVIA04jdGCnJfSL0+shCJmny9F8r0WKCPLn2Y8uxWERoUtPlrMHrADPms7D1ESqc9lceUGAQCc6RdADfTiutEr/mmijwpCo0xYGt/QyzX0rEh3zbPoqf3FBaldWLn4R+dcDzqo5IGoyPcgxxa24ud+0IFkClG0D43Q0VYKCqbRa+VBgmd0A0FelHpfKFgQ9c5qJ2RBzwPD5GkSiEY02b3VOBL1KMuTYkQ3K/wLnv+aL2Q+w9wtrvuxFLvmh0LMLhud7Tjpu9hGAgaeYcG79j9D09TdK9rY/cWhMrfZF/9SYS31rxJC0bO56mN+XmGSj2rGoaGcE2ZQuxPKALF6GZwnQs9oLOiIuk6QfjeTct9NNBUD2bYmkwXmyEBOny0kGMlTk8kOhOYHaETIcv/ddNkMqexiYYIWBjctfYHFI67HB+N3W5l2lCOrPNzgTcEHCu3gf5hTjwvaRxZp4HtpJheZZYEL/qEPXourPLapuwV96TEZIMDIocVpn3GD0XJ0hUX6aGeE2fpQLrX+W7uAqk7NcPGbekH6g/GGCpwtc2ZP/uQ85Zw319JclxJdBR3+F5TXtmDfBuwqkjxgwxksyuNbNvWqoPJY47Ab4ETIaMnCDwZIH2Pg54muQJGuAb9XNepmJQFAY5go8q3jWl+wt62bWvDwAvzLlWq4mv5WePajwdYLgo8oXx+6srrVay9xgW7TR+AABmlpneIh4U6OzMm9mRxkSsoMvbRpPu3zsrk1eqnPMP0PVbnMoTMqKIFUrGaYhg3PsOVY0SzJGlGv63/FhxmlAVtSQCTdStxkjMqezn4NZgsCmLv0aru/Gzvq8XvdtT+x5KVuIxmnp/PI8T2A/jYZDT1pwuIUGsvVKPPg9FMVshBsNKGK5UP98k7DomLH33GaO0kVbwwZeYsrb8i3ZiuSJmpOf3lubw+VGn8euEOAbNUUy0gsITv6Hb+AkdzOn4RDIB2fcShZuUPyeJ2dypJIVjstaBCgDfVaNOFLp6kFFP4i/HYdzRYa3mfbO/9d0+b1csMIzG7xgjVy/Y94EhUWCSqaW+FvWMJhl4AtRIbsD6YaZzb6HSg4sCN5cysJT5vjsKufKMUTlXOPXWo3fq7ms1jcwFeE5MvEcOw+Qyuqhm/HfbDvyZ34Or62j3MRzTV2BQGDeUm/+7mQGelQ9Rk0Hz4Ny9tRslF5am4Pi1dQfEqm0grD37ChQN9733dV/qN9AbuDBePkPRvP/jXVq/6OQRh/0RSNVaAF8pRaJTdgpS5f6auqgvgPjPqe5u/PeWV/rJuKcfZ20u0cjyKnn7RFYLBmA5petg0osIL92WnGIjrQuIPoG83qGaYc1gLE0bovVbWfuZ/Cm1iQsmoHQhYYYXhxmtCarUTtyR7g5uC1zX97TKQzLamJyNUD0OOQjSoUqTQilipypzS6dMlBgr3bFeVPmEED2fAXqlRAA1pTWHxwFb0Kyu2sjeuQ9kldz0aemoPAUfGCTFQr2Rlq5NhClB50BuRIct7yXYWOQWi0tbEf1nFuGQTQZS32zA2bUKRz/hIaHmUgUSXPPm5zdKimG2EgcdW4RV4EcK/XdxMKwKupjWQgPFPdlp8xMOCzM/2OnVHq6R+nIEDTjxqGMswB48MretNnp+BPkBvx9PSko/tff8q3KpAt3Z6WQk2aBmMDSmznR5HhfrvEepXhDdlLuHkLfK5Uog1shoqNGlCiY2Q/XFeJ1tn1yKiy3a9n9bLUKIhWl9XWOZwbEEr1PigJ4ltT5+cEL1Nu+ESxyrIR9uuJhBV1ZeJB1vsRqTtc3dEA4OhEnDfKS/g6Y0Z2qo5Y/SPS7Wqfv/AQ6CwGD6ek/62mkJk8UeeNbCD7Z0keKyZZ87hToQfc5V7cnPMTFpIAd0w5XyrOZF/gfo3m+S3UrV8eOTis5d5D8abGKqhzC3wyd4LyP0KSDmLxU8JfBTATV7DjNC+i19ZEUPs/NjkW/1+EQqZ8uGkHDVKDQKJp+VciBYgQBAFRI7xrpGQYYa8l3lT8oeiuMdqCWZhgLoFkVKYAaCUCbzsQIUcwbG0Nvnh8CJmL8+zKBF0be7UXm0Rq9zuFbXng1eMCbVUj6ylGaHNfeVRq0LlTYa1bUHdDPgpWP0azOQP/oFNrr+UKe7/M5UrXb3+Etj4mflJccmY/VCVZjYGuZ8UT6DRfOoKyCEkjvlPxhkfnDf20qeI+V6cb+FkFRKlko24/sAIbUr9Lp+Y++63SfkiSvndc10k7i13Sa4t3d9W5PAJA+B8vrYHEq+sABY7iWvoYrBLlBL6mT1WNz6Rqm0WWFdk8iFzJ0hi8MHYuKJLHgducBeW1ihYFHkeD+swOUywMmZojXDwfyWKvcoHrhd/JfPkSuTBtIuhP5anm5apmUkpKQkiZEXJf6MojY4oq2Q6gS4F2iJarKM8o1jLEwY+aObZ9xyyPGF9e5A3Kb52TtogCrMAP10tYn82zKQECR3BVRYMLl4kAqmvcxpmT47dM2QyODra9yWDMk86hzPEAwPlpnJJj7srJcpfsImUxsqDCB1rirS08myAjK69twf1aehf8cV7YIVWwh50NlSmRNqStlBfRTlSMvVvWLgzwrowIEVMA7DIVuA/EgQH2ooFO50CHPZ+SzqvL9ImlRUfjnI1NlIxfVONVKH3I10OkrV39neHeBUl7mswMKtDPrGlgN8lw1TQIIYUoiCJBfQ4J+Xlrk4xpqHxKi84n/sUa2y5sTEufG9mLdQu0e34aW2ut/UolMpzJqV9BBQeXOJd7eOWfDUUHYaRqPi01LpbXsoc0B4z0ptYl8goetX2xFcXVHQrkaLvSWU3RIaCmxJNlgDT32RlLCnlD5CPU6gYkDKnX7RKYQkZfwB7b70a1hBRNpCkyVlpNaq/gHl1GxAfS1nRsx3UCsqG/ag9qIijcwwKkd0MnA/x7INhjsLVaaygEP+kVpn+iNDwSTKg3M+7xLmsgZZsacm0GfvNrwlklSOLQk7mrEJMpcGCdRsazG24yOh/tGK0X8BSxytiLaUjDFxlOgGeH+t2heZn1tblK/BIi8sffFtaI05hrmS2VW83kU6YGs9vw6FrRxLtJJ+zPcAxCOBluWwJ1ymdDIj0mOaotyExLTzzouyLwrzKQ6a7J0ylFT2dlAl9hytKZOlIAyLqdo19vEsaKrm/KKQtokVR2n+2RFz8DvKcwdZ8EvMtPgiii4mXra8avgoZZCO2V+SQ0L9i4t+T1yC0gt8u77MKP/5wfSb8xmT+Xo6ScbbLr3iuVOl4jgEfnPrBZYiaHAGok/B/EM0hoYPLe89JnXwJLwKfuvT82RR9klxnC3Q8WeiHRzdWGvaS37pI73a+KFREQb5kS4CBico4OoFpllkQG7Jywopm4+BIsLq+L+JVCjEfiCmgnfDvoQEhOSwhqoCHoFPHx6oMY2IJQ+QJCALNUQLMJJolOvz9Iwx0baUQb3zznBDCvB32o7nPzqJVAGl51Z3pg6LEnxKuVAYKOjGVRC8UcsLNabgAXh/yVJ5vUDvuwiP/xO6oKkDfLgCslotRV1NyQ/DXmASW0KKu5Al/m3XSG1NTt9J06+SLV5iEZ4r2zfJdIrl0mcPqgfky16txKwWZHnc8FIExNJGXY2zx6STNPXraddWm419Ckr+yGwMwXVTtoRp/Cwov/FHMzOui8vN38AtryH0fyfCS9g0dEUUY5sKvR+fLyxjQgg0JvGWQJuiZxTyb6fT/B8EfFd2R8QR6oid9gSnlmvS9IlekdCHLlOArqsBCbp+L2Bg7Z5PlsTbvidyXtLBopAAiaUb6e89EOaKsZE1lxKePlbEi/Cl6293GIHLfBiwwEeV7jaHImHSnXW06+piEfUIJfBISB2XPeGiMwqCfNzR1W44Hu+/hAF2Wg4Nl5TxS2zDbkefgxT6gVhauN+XW4yKvFaKHjk6UbAdQgGdaeEX8WcOCUPsRNhtQ6n2EzNn8uM0dWECYhQEy4PH5Nb5/ZPTRlpeSEPqd1VgDVcMLiNQVZB7o/Gn77Qh7AAfyVWkNBaGpUKsXIwGjrdgAjK8kB6Nur1V3tj/zW1aBvr6NiBIPhkmrvGDboQZhPEWPa/kehN8kC7/cS2oGyrErFtS8FicUod00OFD+Jupjfbl0AwhtenA87QHR9SjCrHV2u375gx+hiueZMW9vPij7I1ByhcYYkHJxcB6NAHphUqpEg6SrE8CVPu3xmuz/zLYGLJiYiPnTUrWGpQ14EKqxFcgj3IpJoFANLbttPO/2Eva/jUc/0NKrVeL8rSJ6H4Q5ySGtVlFL89ujTZXB6TTnWFFNAC1avaaLo2VhfGvlZlHosxwI0g3G2noALi9/yEvEqHT+Vvp9Iuy/aGMthWWqtFfgU4WH7eHGcngpwNCpcqbJmoThK2nuZH1JDjBnnFF78G0AiDcG6f/IIBISrDwzeBuc0veu9Bj48tjYI8EeJF6TzGCDzs/zh9HDJtiCimiZ8xXzeFyg1QVN+lCYNuwl44Y/9kOQdiUKvXgv3dsoGj9J+gq2SfdqjzVBIKTqcUV1s+FHa38Q4PdmMu6BoqIknZ+w4Ut150/AJ78OY+mc+soTN7m6Pv3lPLjTIn+JT6fe/opEel64FQeXXnWE/tfXjghUBoLjUJCrGls4/omRzLR0UieqJEM79XLRQHiazTTqQr6Vej6RWceQgads+eXMoLSYKQ4Yx1SVBrlgKrwIses2dX5TX2ENnDIEHLcRjeSnqQ/hwUGI8HQFouNfvpY0KOefrYPzhjgM4DEP46t+r4W925EcdfU4rKzGkePjoTc8rSSjklsgaAgOk3nslgICB2kPb2GTyy5tZ935wH1JqIhI6iOxaaFdArN45uT/RjjsGopYkowGHB6F+cSGB+pa5yNUmf7o1HyixQ2IsXHlG3NKKuvLJuH0JEFyuypMG3hmRegkKZh7Z0SFaNGUrDB0DpFq12W+5nzWf1ZXjAw+DSbZg1sbTHCI7hcSPnrhXaaybGOmcQyFtEnR8JfIKbWr3q+naut5LTIk/LEAxZ59RBQHnakReC1LLgB3XmAacrAQOsTL6bNmPT1zTXDlOeY+u96fAkWlDZUapyjhQqjYTAJYSd0kqfLUVehdrYZC9868jL3m9+4SALj3TjBiPiRSaCx4ntr+tb9Qbt50OKxvNjdM9sw/BKrwTCXLF0T/ODS11FxsCuaesDKdrljhj/h4H0jWuS9HzzQx9pAlpbHflQPGla52NWriwZJFCjcPv9VtSPG7QAhqoWa3eM1HbEKxFWLQ9+GJS8AxFF5BjT0oizbAZHUkfvJR/NAmKltmECNBfcqCTAJFWYZes5VyGiyJJ2B95o6yGR3AIeod4JJ/JSVxBZC4QxzrMlRFPWXYrJ5fl+WYAcXjsV4xfBqxOSiLFcFOAV6wti5DF8EFsOgrlpLYYJXe9KCsiSo6K4QUFH/VYY39imFNhqViNYBuL71CqIwP9ID9qTMh/TljOcPfVobUdw0wkaRQF6b1T7vkzywdyx5PtPIV5bXCCKsNsbEzGiBEzNmwG16Up4vwILpos/DHqA2INSOoAlq26UME9q0Sx8Tz+RtzQc1VARDNJFJN0bW7RBcpWd/yJsndHZF7ueXtsqOWfyzpieETfsed3BJw7B27awo1XLhnNM0BQR36MWBvEdXnDE9tTIevP/khpCcfsBJRXAf9LMqH6HcEHq7m1cp7nEoXqMiaZBUw9iKUaeMy2rfOIkT+GnqWPVXvDvKe3GdkvKUBHzNurlRa/pKN51CZHNu84F75dAMH7sYdqWDgkYmV36tCMBaXD8fuhxnYQqTEQnQZHocuTKmm9ochoneymSrnizJV4lb4en0LP+/w01i6YAoJS3TNnJlZLsFJsntrsItxF7FBSDMrkkE3HBTY0BpqQJfLnYJbZkNFRpTtl21AQP0z2+C+Z7exmA8r1VnlCsXp6ZDXaLnnKFjLUwfvHdifRa0ST5e3DW9vhSot7k/Fd/aJ3Sa4yffhmN41tq8nmGdaS71koWuZ50EiNtSIOWk4QkYX9Xq71NVtK7081Wz7FBlyvi7l8mO5MezFvCsbMz737FI99nulayk1deZJHTcgeG3JVsJzOnKmlO+d3oHjswqRJM1jKJcpJx/MgnDRpKRFEptSyy48P59B8/9Za3a22BLEqpabaRqcAZO4FZ+8tYNveQV/KhJb8hnAWCrrt264bujBIKl0UCgmbkKmGXkpcjDUWJuP2iIrlFUlrOpcH+zZjSa8XgyUI2Ebz0F5baREU/LvqFXLHDAci3Bsp3dC9oJIA1UYEj3jViBy3Z1x0s0kvl8JJULLW3fgshTsiscXDcASdUUjVXgVl/QhcIRTHPuFFau5kqRP+nllWwP3vNfSz6C0jQMzzu9s8+W5E30ek0gcPXtbLlSRucbeHwEXGCJMQegqJNwDLPocsbbhNym1GFIjq7aVkg9qgqYM1VlYk/h0z3G6geJ2d67rk0HQ9eOG2ZMX0JKnDJY45KLZR8+O7uiiMh4Z+X1YT6tSVJ97f5UQKLaMFFvb++P0iMrkQTTcDRk7CPT76VFQdWdpt2ZyGpOFeG+nmWMdlSylLf1Gcd2Inz40B+YV0kqJFQ3b3EWXwNY+VqEu/nZJRtoGBKp105ylRWl8M8wYQfX0Z4pe4hOyv2EoYNjRPi1ZzKuZEJoNn3mkDoxdFWwi7Xu4xkiBjnDpqJtd1S+jDwf+jdA7gVsZQqkL4lLkqVxfCLrgjmczbeLzAfOoo9r5CNeX/1Xnhru0775yF9z8+wb63Dz/2Xv+woNzclLtsV0jFO8poJPzm1RikZph53rHyAXZcakLJJj0+YD7OrctfMcjdv8cpYeOrBn1v+Zs3HiK65NWlWMtanGk0uMjx7k0sw8vD4RLv865nB9zA5Y6wQI76PbzuHaG+8HuOSlrUXQKjQv8iquIGGWmHFSJ9E6g1AOGBjYFu2nilpwa3lYXNXSjE0Pk2UDknijvOEEjqEheg3ZGI2FzOnbzt8LOgNMgmx5CaVCCdEkOcxog/nCHiEgIY3dmNOwDdp6fmioLewMS9AXK3Df7vQ8amV47BxpQIWhTzHt80Nw1BxsuYooWuEZh0fx2DHYGv0zStv7qGwHPyZmNy3CPTCCmA+obuDq43hD7pfUNpAX3pDY1tL0Jp/bgrpdXQt0HpQoAPl1925UT4gaPSXF/OevX0V+iQwH2n/01I8XgqFYr2Gud4xAV+MHxXBEA+7XwhMcoWrzkEvw/2Yv75n6rCe11AHgv891Y6sqccP+FbiKybSAhPSEhuPG5VWlwFt9A5UHpocZReSNrDbygJC2RBF4B3VziTbUQws9p5q27ukrf3ZSKobPRoZz7HNFCNaEA3fauukLDp2OdtESNdBSLAfYe340P/p8alHAEL/ZxR8J8iMV3GgPOr21TwRZ4lA5ng0MTx0hXgYLEy5WRC/eGQebh3lwDrTHi/VuxHEJVKI2lhHPgvtREek6XvB8EVngcC6BlE9UseFgVFub2lUCg/+snVsN3CFkBMxixpNql7VKt1e8/oQbnNhCR++n2rZdLRB8yvqV/8X2MY3W8rHYz3XjtexSrrYNPzfC3gk/DOkqq+TR4POwC84FEJ/Z/Q1epNGazke/zIRKHuhhxfgllT1w+B4nGmVpYM0lFqFvG0Sc1l4K2eG46DBe8ePp8Wn5/6LlJoP+1JYFODVPzlGuVA8GJmI84lYq8avCAxlXWjfAohSBqG1Bkw2rYn3Jsb6kf1GMLHXA1LUbMmOLz9k8tPsgBsGESRP3WjBZwSnWlPY5QH1FUEV+K2aIxbFky58GIxwSoGeAKqVGnjOhkqCGrdp9PBB5hBAStp/ivWExw2RBCl+bYYKFPlK+wL7rUe6QVw++qfIyUF+0JemlJpY9zpZVZLRhkd7r5IIkR4HLiOdfHXHjVLhF24sRzETUY7bh7BiRR3z6a1YQFaMENNK6ITQ3RDPv03kcq3LbY++kq+t4MGQ9OkU5MtKSXEjUochoq0yVm6WITcJGMAJ5T01l2zHfViGMU+xCR/aVblg1wHF8s6FgwuT0ILMV+2QDuBf5yIXDrjB0ID8KEmH/oePP7tWUI6ViMm/K5sapJn/JMTN5CesrHQ6qR3xvG+VAASTDySHzZNidnZjnMW4glB+xEDbnbDgApa7Vqk6E1KGNJFgjQIU7BeoPXzlYI4SLGNcHjaqytbK57rExxLoAdIESitheFTa/O3QEaL6qiwnYhOq081rmn7JbLbNmmuSg1dAEdyiXxx9cWkLMJh8C2QY7g3zaqBlHDA3l/4WJnuFmuvHaoGFjUeJXyIGc3+yy07sqPcqUbS1Wn04CUWXXJzhyFE6O0ZPJOLEm12kDWTdK5GfRTaNNC/jroWi4VVVbn1lwtLNa4SPu6T02wrl/Ln9KOfx5mab3r6yB9dzXdlGlA2fd85O5Wn82N1sf+VJNodhOdX3WhgmfkBozPgJaZfH4FyAphbanBSOS+aqqIry6qPaLcsUkNbnMOewwTs1i1GEZJLlHT16561lkPfUUwupqJPZDGLy7XIGjk8GJZXrwUjgEVpaygjctaCfd2Bet+1seO9GPVMwPj4RZNqbfeGX6AZK/YZD+PJMyO5recoGWjqSc2Xwn/DqgakAdobZ5sqd6iMkjwRR8GshohPtuu//PB1RHUSZRV5gMlcdl3LPw3E3LM0JWQrqVYqmranCsJ81hoAdPGCl+8G2/NP935XQu1So5Y9miHVUU3UGGw85hshymgR9nD+8t3KvRHIW5TvisMrT1VY9AaV/WDwlaY8GeDLZLe43Ze0KAhdu21VoXwVWgFqYaLa2qspkBmqE0qcEc4KzwUjLIjJxRAVdYEtkWYcJ1O32gvhEwFdQ3bkudV7dJQBFSNg0GxklC85jTZE/JA9ZohdtvtpyVBcg80DWxwZMbTUuPgNIUWl34dBO61PukaNNfRVtD16rDoV2E+gS8vFm3axy13BFCc8l8gVAR72XFFWoz8mKBh08fq34g0WBBVuRUz62rqIUg84md+IJUufJntuLiaq1bwUngcMAlR2m/l8sK4CUK1THwqSTF4NnY09AWKLPJDXBu4gGkFtdICkrp86W2GpFUW7iMi7+sIs4zh7iY08fmIU70pwBPTkqH0N9YAzyWsJYuEfdiVTpJWkA3768Wy+EexHwQgxF7efGpV5Z3WmzHi4xXI0X3ZOdyo6bomh80zrM3D6H8a/Aezlxa6lHQRor9ybk54B+yzlpn762Z3zHlU8xlgd2dhJhFyGPdUa9KWhmNqKFs0mJ7+I1jnuiVrIrsdoI7idnrO8e4T1Ew7YvD4jGCLH5+v7eA4YXAlhlIv0GURSqwZToz+eLRHTAmq7B5sdNXFp8gCgEtf6mVGZwy/u80ZLJLmcBCOXeSOJJmWacNKSaE7EMmH/xJWbDE8ZnFixvHTnYzfnUeRkKnuxYuSvm1Qjy370UCJ3UDX50kuinRmggVOaXVhR/4ovr/mKE41gYaS983B4BZF9v19hJwz/TSFN3YzPkvOuyVuvVvyTQHxSMv4v95Tn6oY0UhKbYoVvwheGBpS88B5zMT1m7I08Ouk59BxQBV41C3+DbcTLHFnIkT6B+n3Vi+RMMofDwTrsHmY0OwphyHvJ5Z3yWEwEmgh9PXQAEeoyNoOB6BrYNz6nd5Mhnoxc50Tj3+oXYBN0daWyR5LTR7CeQP278d4mQRq+pxxcsoOGmrbxZWbOqAaZWjWfmovb3DsxwwXnnp7PjKkQGzE7FU49SL4DtKtiqlony6iOPd6onbFj2AvQyldWlHgG8QolyfgiAtYpuU+MI5UFNeJJsAhvypHISTdrlI/uurpxh5FeHRBprImBGIK/YUpGUEKjQH5z8TTQ1xUIEWenXzdddvaIDLtZ8Pt1fzwPNnf+iiI3cSunPRcg+UC4Mb5zv0Id76LwgKVS99RJPnqnNmK8PcbTfHknoZ6RzrKdJ/duy4oPOA9GQOy+uXCYzzh/RXyYfGP2TKm2if0nwvH9IfyJXcsT0zjYY1Lu4IxE5lfO3tJT1GOD6VIVizwP0jE72/PeKaXYVgM2b6Y6k7xTbGbu3W858uqXvWKOSvOGvk4UOKqlEpHVSMX5seOjIErnBfX3QaEmsaeMVn8+jw8xu452fMzNhn79iWOL4bBSSKuZ9uOGgTpcDkHYovtBs2dHkMXuNhuIlxgLIwXAKz5RP1YF32xz1sxfx8a1H2tBzXQp/WEycD9MnqVGC1+698Q5IwgkyfKP/klDm3Vdft4LVJGFRr1Z0rZryAT+r+J+B6mLkIQWKiOMA9ytPQ0aWgizHttT2k6vLRL6ztozrRzrL0EaUffncopSBLPcBhHW6TIyHwFTvS8/aXYNXbs/8EM4RiJHnpgd7sJujyv/SSqESDIRXxmYWMTRKBlU5wPJH6y1IhHHShJcl+7yDadLv3zH7vtLVoX61dsmDd3jywueYufSyMpZxALnd1/qsXwGDj07zFP7i+nJfhMWUFNA9Rf7sa9VapYAxfKdajZPmYOmmQkwdCc44FFWdYt/TqFZO/tAqemz77dw9xPjBXm8m2W2HwKm7XPkvyy6M3c4FlaWDVuurWmx53bf1NgNU08a5JHT/hcHIUrgcf7vDhlOELVpIPyijGZeu6V8poKKYDKOornnWeh7FVU96S98NnPV5feJbev4UfgAcEO7lQbgk1/vhO5OkZ1RxJcBvgLxUKjQFuKlRhx4U0LcGzNAICbf3ZFxZIxXgVSCENHnoUugEHQ/zu4m/rRW/c1qrpb1gICmKlHfS4ixVJ0ZWajicHNn2kvGEm2tu6i2IKyY6QbhOt5fOF8MxIQP1NJBhtqYmx8iajUtR6qejbEmWTlPU9MdnnsB7nI5YKP+8+tzyOgMPpuifJRLjlSKhjl48vvgvfes6bz6oVkOpTqsv8jmHdoVZqijHC5jgd/lf3KCRA/jo1UcjehvVkbq9NriCYojWUhdLZuG55HglE15DAG0F2MQt5zxP6fH2XgeSXBVS/3sHA3mSHstZpWFzi3XcvOSgmCR0PNh1HBAdNhNeCKfoWz7JzYvWWzEpml8zxq/tS29/dqM5vLwSND6p1KXqIJxHZgwDxA2VNbmN5ND3/ufeEN9Z9Fy+Spgb7BnGDioCQsTwM1q80UxkGT3KumYmUQ1ZTA9OIMPQWE/7gf15hzODyCu3DmnPdvVEatiZVciSvEzKWnKUnEBWA8iIlxToWEe4c7/TKwBtMR0RXnI8LlMrxgz3C9pEbo8PXYhwlwt+hCy+CMN8ZRaPRaO8C++1uYmAT/SjNYSKHlPSyqi4NCSJw+mZlJP5aFRCIlP3uM0GMNU0S2L/MLAGaCmaMzyUTtJAbngwJCT9LsH5Gl4kUph3Ln/wmJjBkXAZK2lDWVG/RX6NMaOeh9rjkxuBF03TT9eS8A1Kvri8QG6g5Vk0dgGWUbUoNYFKwGRil+eOZfifN7ajstBUeNtOygkAOAPmJI8WO+n3WkLZdMB827AQIRhhmMF61UIuh7Kmc4y7XjrH1nRE2Im7z8ASONYq0thVqmedQeW5f6evveJ0Ly4ud79ygd2OqCAYHRoo4vDow70h9bNvnBAdVki7EjQtSZF71qxorJx9sGajZVrgC0yZHSLYjnU2IKnK2aP5W2gSFgckgIyOxdkd1n4gycPP3xPMVch/vLeA2ZVzbvTQ8Q2f4RL7q19oBY3V0fTLsATYt7Dcjw4Ybjx6N3RjMNbNAdY0chErVSADaxrgokGvz0QMsQqf8aPAf/XRc32F7JohoMVSnAzB532UuDgKoExLXKqSVasVtM2+mW/7tfKIM9SCLTmXrgjXCGZx03VJdZv/jz81Gu76Xr2YVb49ZvNu0otr3gyknPdXshZe0GLnvbPTOcAMomeSGNLqXO5jIaxmLAGBE7zokCC9Hwity/Tn1ElUgda4NCB+XXvac/0an9t7UrCQCxp79QR7PXK8R/lxz2x5UeuxB0trE4XhFrRD0UOTEajHEIiL7SDng2+lsZIkPIZXyCrf5ykOtmIvr2Zf5CXhb/dzK1zH0hqxCFBTamOzsqXhe0Aen6WkHxmAmbaJe0NWSoZfWO/gwvSlEUxYu+dFPQNu6/tPRPl7SMATyezw/94aamsyvNW2x015N36vgrcpvt02rRWtfwQ/LY4El4HM3UXOocKtlEgKpaCs9CoUI4o6wGXzkKvY9+65ECEaxpeu/S7asObTLLxbrXpqH6tMKcpv3fULn23loofxrFlYEjjq5SwE09ffVtDcu7nk304ApRkeYQXmV8ViPd58wdnttVazq/9x3OlmzBYZJ4HE5QnwhtG1jkWVRjP8rkAzcZEi3Sow+/4IGgEuVaqNjwhHh60jE+0K4/MpKlrm4/gj4jSf/XnZx9H3DBBgpGHvDU+ma8BHtFlIi9TGuZNHfeNrVFvsf04s0/2HolZNoirJlQQTXhRcdtUSR6ePcFBgpCHFubFOZPM4kaVfcwiCwIu1pHhLC9+6SeNe6LCnE0P9eVNIDjY+LVhXG8LADK2W+S/VaaZwICk02iKD+NbURM7ufDk/yHsjmijOlU3pD+qyCmyztXjOwOvaLS/cfbANZ9O3XzPFO2y2HcLp1zb4IbEDZh9uMGm4oJ+Xfg3eOjapLm3sXSkO+bl+vWlsWz1ZR9KO12+5iOBozoW4iDuQWwvrSljYmWqiB+oYllschpiwpI6U1Nm/+qsIaHqua+vWwXMKZbDtEUwRTUj3Zv+tJlciIiiCkEOmcf9IvB+392e/Z8keQfVyUNR/hcU2o0QUzpF6wlzWjiwdUB2HMwbrvP96wdJ8zzY0ZChxPeNGws8aGxtvLx9v97aCCpMBlEqEC0EkXRAGWC1DkvP1rnMUkm7AS5uaAgD4+Exsz0SdryZ5rdwVXGnBAHEIKb03WknfzAUmt6HCshIYKx+8rB3xM0cXO4R20lXQgtuqlYRfy+yKzse0lmRDxKJMFdJpfAKXCTregW27+GN9juU0ZrOdoL8/0QMlbcoVELwzaUWTWe/48kEZoL8OIQSVehj/5XAyZvkI7pd63n9Vqi61QJe2aMv8rc3jsCEIrREdufkz+ZbtsHyd31UMnIrDcRtxkEBxmgrd6vhw4bdQk0mDzFMfWHj17txFzUu30ZnRB/gkYIYFi+7e6wdiPovFMO3ryEI3A5PsoPXMEqPJYBpB4TzmFOzkvbr2WUrZZpVo5ICKp5CSbyi7R13iu14TZaMeF90kK0SxpGwv12FAxUbDVK2UuOxNOAICCK4fIcHo8/z/CYW7S6emXV3jbwrri16Ohy0efys6Ob/NssUWOJIbofKErAKwQ8EhBveGVBAVBb4aTMWj6bq/HotXnCPhPmldlkN4cLrYqoF4nsYaJmSP+JvzKwLDztEuL4WfiK9L9OP7VKkXAv8QB+ayP4/Nl9qb3Nhi+uLzQOV585rka+XLFvW4ozmI55/vxT3qvUeri00RyrpdQr6Xg1aMIf+tSo5sqewf2zlcAIl/lshXqolVONHGo/LkXWd4Zx/4OyGuVR9DmnDhiTxe/knrVaX/trPCOp5I8aQobF7LePjexV+aUBWjTuNm3UL1VO6R6u1gtVja2lzMUEdbyj9DGUl5yDZddrlMdtYt5lKcaFo1xdz3MGY8nK2zCL7OlSq2qcBpzwl/irk4btnAKdGpJyK0vxKeXt/iGZeHVOvbQ1DejGyMEzUo9qnMALsWlGlwDYW/4rhvwTWdfJNf+rcaiSJI9Eb2Ze2JbjOxbnOutUX09Mq6akNL+UQgRdEORG6fzMwaTm7OjobS9ivpmrN3AlRR9/SQkMwKoPYdnypUtU4Uxq4sHH24BwXPzVXfQgSWJCcCfN5C/CGSyFWL1cfDXkNc+u9A/99MyZjMIWsPsG/1IdDZkHzu/sPCtb887mg2ey3t199Vd7JZikDLIjkU/U/RxjOwiosRS5nA+CWlU8jM9m5LyurpvgT+2FXQYUxc1IRB41naPfvANrjIZvxwElG5qqxB5tMvhTPJkM+cud5xXlOgpHKnFGoH3+J9XOBKjAdBOF/Y4cpkv6nKyS4QWXHIFc5sLIFq+tmQEs5FrRs1qurXAELoCcdWi7DBxN0MTJw4HRpMVk6PSI/EkrzZsVkvYX3R7BodEYLTvR8/soQkWZpykfx5mNbLa24ZMiPTzzQmdbeP7A4/CmGpRFuMepttVe3B5fe3MMUDmq4cffmbPYQTeJFvhW+oXUvaNfO4ncH7uy/7908UND66AO/VQ0HB6Fa4q50r5uCPgYEIqWs6WOz5K5iTyZznR6X7jk7nVNckSFU1MsafHFjT+I7yX8ASaDWvhKDDg5KxvcnKVDueT3NEtmtbtZmP3YdM4inXEQKFUO9VN5oOPgzFADbf8LtNRgVeI59I16Ie9dT52mQ92Ub7X463VdpEIHcSaSYpmn+vqio7c+BHpI6XnkRLNRHnaYvWNOO+qbLlfJCeDIW6I5u7vsRXlxuOdj8uJmziLZ0auCAYImxdtxymymF4IvSdE1P34oCTKPXUVPoD2lL/MIJQBq3S0A0tVRJded9uVMFAGt8vpHBxCtm3uTQbfbEJQEl3Kt4LnJ8uwwpRYRGTCa/uKbb0M1K1+kNxI41RDEsqKPwaNEaLIhlkAp6IfGhvZ3PpzviRoE4/KreB2xP7iS45oVs9ymmKHFL7NyUWflA53z1YIMhPbrCP9kfRQEDSH+IEtucKflkmV1KFmtOIzH2o2nh1xELjGhDD+M0NoxJKVPx1YKb06QrfDQDJO1MZik7ABSvCWf8CmuxXkuheKEGpsp4Fsa5IPVLRgPBUgxIIawZ3XBnkCfLQ9oB8/hpAL33MTtA5+l5Oc7X0xmQPTtE/7tm1NU7+Ugj6+/wHDhb5YVg88QgrN1mVqj/Qw3fYx61s3q9OVARMN6a+FuWby2mGpQBLiJtLwMh8nDiX+8YwkxkeO/cyyFaNcZLaawavB+GrF9PUcI/fa6pna31wTofub836Ddtf0A+ANy7cEPIxCZ4FJwtWIEYnKn3HGb+Ylfgiadg25Q9Xc+aywQSz/l1iM6H92TfjuMgEnxMtlxOljPk6HnDmNXv7w9pYUQWBDCKY77ty3rkz6zLJUoYfoYbbBK8WYgvkAhY1hX1rcdfk8VJWalDUEsJ0tSnt2v1HE76ADz/+DhqfaV7QcVHogJio7ohGOEatO1Bu/+EGwJ4Y1mHehCEyi+PdC542Bxe13naGSkz02HFs1jKf4pSw8zR0F0D7QiZjyeSFUPxyMFk4bKTUQeMti9icFIy9/AmeAVns0oB+dtBMostEJeBHz5pI90zyvxq6uaKHtUqBit1mXcXT8w+jZhsc0nziy83elTKd2Y8E+RCbVlYLuL6c7XGYdKMFNufmqbhHNam5ZmQh6Og8yHT9Ud02bYo/orvt2ch0TuQ9fs6ReemQeiATGGMF2YMxdvErr1XtDmsvNYdzXOP7fzAfvwj4htZ9ZM6lO3ldWAlEVH+ynz5nF7Yf2CmOLeg23aai6xNdxMEX/76YbFtx8ZGQHPK3MK+IGRRTYGHwm6uAWiLumeBHhSXQpzu4gEfw4MIvmGw9DKge2VOhxpQ/dMJX6MaLVs8wbjAFbf9m54LzQSn86e3A+lTmKGYwvoij7m39VAa9n55K+GLFfXFu/Ylzh3WCxQYvAGWp/zY2B/KEX7mcUG/eNJ79a+GJNB5/K409Y9m2kf2l0XE8mcEce+/COAN8dVxABPyAabaHYi2FGFh985jFVovem0lc/UWVPfqW2Ri04bt7QwZDgQ3qrBBLT3lTpzYSKB/4cOCR5gXWr6ml/9apBL5YpDkHTIo5eObxcdVAZfbXFON5+I+ICuobeQKAqKoZI+F7VflNQGT4bkwNI1r5cqJoXAIhsM2LKuXW8U7fDg2EjXX43FqHn1NYarR4iiOHZsmnfYTgnjSqS5bz0sUgFoEoHWxhWoqlcXmde7+SqB/K3s2XXVOrCmAL5nDNl2BdENiiU60CKKRyzINFzqKw86GmLGVTfuAAwS3Pjz01q+1iWi5GYBoL/4qrGJSvNLN4ki2Y0wxKQ+FohTfD6AFmI3svdP81nZ5AyIC01OgjknKeQXYaqM2lJV81l+4MM6V7xQyC6OBehbE80yWPTnAWyjNPJ44SLXc0NmTJqxO4ZwT2ZKKZC1/nvPZn29iGXN+pWI8Yol3GxzKvUuMdl/AuY30jm/CYuCpGsm9gw2zLsb6itABpCql4EnxFN1RbLbP/jD+bp7CE6BidoeTruEfxgXt5zzsjCveGxkkp9NJvdSYIczH0IM+ogfev6uyYpPuyAWFpHNpvf6crRnwYsdDKkUxDKJCcemN0rf33Js23A9WjPB3BAqbiMf/QPGddry9eSJypKxhPwoMHKOy+8Rq0beNczCdMFqWp6NVPzcaRvsLnAGWTHd00QS+/IVSrNxBDnJx+7ux5b5dvvNar6Hbls6eBlVqZy5fyScth4ABv65dc4ta2JuD2XGeJzbWUDtkK/2QexY8tFr/xbF6F5vEYlhFic6SEfwo1prqq5ppwbHutOz5JvX9QvIWkK0FstYHRgwngz6uOhH15kGO6ZbJDywNhkbeP62wWNXPtlr2NxEnbctpJdoKFcx+3cIjcABqTT0M9tsPPuIJ2N3BqMOCZ/pv9j1/txTNmPvuH/IM6BhqD9Zmu0LYv0IilzSeavzNhdPj9DIN2M1wAcMx6GZkmKNNS90ItPoB4hCiNGABwACX7hWh7f5WMnVE5gxO+75IR0hg+7f+/FTlElqSHWTZzoNbEK8zMIubrZF9EoHmog2epXitGrj7VOdufx+qscSl7kO+/KIamvz0e5m2XKc42WLgIuiJkmY/HF81+hpwuqFUxI6+YjRozsHbGNmHvYzAxMrIDS4IzQy+xEqNt1QesoWGfUDSIj5YJXkI0mUwTLPr6/iPFSwg545DdZOkzeGfLdN94mh3UpHlgKqGLygER9PR9Z9ancxv93riA+qLrMPz35XcpF02hu6yhH4V4Mvr8YipbUXVTXurAchaSM+j8+QUAvB0FtnzDcRxQC0SjDC5m6elLa/xuvt2lflhRvtKSmhZetP8r6Msgqq8HOv3UOz3mOiVPIWuyDW40cZRapj8ECT1jk5BnLcqt+hQKgZleE7NQiJAs1Js2qGrKA9SV/OCQnrD3jn4wsF0EkBIEAeCOpHyqWjXAs8ffVCy8FhAp96o7JOv6IYcMPwvyToky+fFUChXiwz60g0MH2VEC+CMkyE4ayXAP+db7M6lARTBqOoq2O969LtFRHe92J5fS4W7Y3KcxBhk8EQ1e97YVwCYpK8W0HzPTeSA6TtAP0/sOqSUS3ZHL0c3DU0EubXRAN2+VlUPI+vMU8SIiRYAXNPhcJuO8VeuOwxxHSr8bADdRss6jKBTIeQZckqw1RdbX8dwpwW3h4TkRZSszzMqtJchKSYkedSkjMRF3TLNWHfX5a2j5tWN/ds+YQz+qxFvdpXwRI8C4prX9z/ZW/79/umm2Yk065t9eRR1mlFGude5BGsNXyiJ2YLLIONUz88STvmhwqptrv6u7/9mcr6JlBebP11Bn6vfB2L0UiFoIzJyYOfPr7cPAWuHgR63IJXhj/Tn+JjEx7C+EDNeJ+kNBoUsfu0nJCEhynEwbBeHboCQQZOPXPWQdIoe1J6I4yLQ4WNnMjuwkU5E09VPEtrp4x7NZhajfAIN85FaKfH+aGxVd8y23OQRDW2r5bWZTlPCaDo8yP2Gw7gFxsXHS8YI3WivwaYeC9G/Zm6DF1YDpIdZDtIzADQniuTMbbrCbdF8s7VDGvcTxvt4hXq+fpfUzY/fMTkXa0BtEoLiRU/v2NIHWXRNOG2/JJIS6LdgzWuS3dlf0IR6dgUQlYXuiiY6d5uX90W0EexknKz8EceXZIDuNHv7x6fhW3Fk3q6Me4XK71hqtTAwOSRZK68V9y8hL0ZiQspLQPv5wIa2RHhPA/h3V7V4D8jj4Jqp6KGylApkIbB0+FqoKL9lYJiKpIjyCjcvw15k8hONcUmr/RMZHmJ0ZYbmeBlOLNF5q+WLTS4ualLNg/3wWQxiDjaIwfFBEa3DTBSqrjjNVKD3FYGZpcHYKJiZZPCGHgPeXWNkQcoHvOVJrvzjXoDdinGB1hFQIuSGcmXnWw1TUPYJPn+GaL9hzUf3FKPK/RP1HgV+TlUgLmBGoGCOf0jPDzCuc/nfCL8F6W+2vwTaLIwRfEFLfXEU9UxMQHi9ykJXW69f9ltdEvOQ2D0ZNI7LbV0dOG7xnWMq01hI9WtRWnny6ShC5Aj2dfLnTsqE25FXmR5g7A3AA53zq9LamNcMWrUuz6Nbq47ndV+NVxzowqFCvwvl5YIIcx2gYsiSpEHZ/o/2HPMhzHqiyAQ+l0wkJmvTTuQt/BeqtFXK14sQRNm4YVz0d3lXV2JOBuEawcHzcNI1yy0x6usarsuoIdUWVXVzcUNal7fm77G752zdrp5NF0k3xvGycsPhWmw+wMEYTy1oKgSm773ST1C0zX6fWkoMI/z7bG/suGliw+lK66smlD83oxHK0xF4HPtRxVVxj1ioqBAdUUw+ia/jem5sFGXTg3GFt8PWohIqiXWa9jcHsc1gGd8j6JU7orZc/whtUz8UtB3TP3mMUorTHKhLLegWMW2d29lcu6unR5G20W2bzqw6OXDGjuTFOLTKXvmqfkbbzxwMWHS/0PGvjQvhEmAR1+rk/LFdJ1/YOox/oCNmJ5XG34IU+mQA1KuHzzifopjM6NQxWf5FfOPCGEQE8DnkS+X/myolfzOKPWo9/wXpjcwW4pXNVQ6Dbgngg9XXmq9GqUltYEWznGXXN8piQouXeHdeIjuSC3nf7Fd5UGvw7tqCfter13R0sr1aM5ugtRvjNB6/rzeKEKAQ6fsR6PuRsaqmeLS659ENgPrrnqk0Cu6wrQw+mZUEwsVdqk7CI98KgxRQ4lpdtEMlklRjVg8FyiAp9blLSmBD3oRpikUXIxrZp8lUQnGtBqzIelKi/3VbS7SUMqu9RdlEEB28izBdQDof5HbbNIrJaoLwQf08o1gWNoMQn8Us/O5SCmGLAxL8pSB1DkGz2+gTolKYCHtU1t2Y5mjBmUavI9nE1O7egtFLcirtpLVE6FRgOJByUorNZxO7uGCjD58MdmyITbflgp0T7PQqxBfRgSORmw/zo4lnZ0JweBpFmZ6A30AuK7osdRFFDgvsUQdFLf96GiK1iHEQC3apHpu7loBfCsOnvYaGx1LkyrPXM1TxKatodhgnuuButLF6jzgWAw4kAa+XIO4num4MVt4Is3irED1IMCLfgiu/BykKg1fzDQR9ucjQhVTIJ+RWPYMZZd74eWMoijIN+Al8f/vo10HRKnz5tLsKpmk5uo5ZN5lcbwQSTHmEJBYyaxvINK/xWsmOPtaS4NeevZ3QucXnyG/cm4osTtkwhTGI4pDJBE+e+si7eul3I3TWIijgK/jZRxOmlEzsL0K3RPcXkF96bzTc5qdYun82Bj2PyQORVRLxKoebEBHADKBUWeHU0Op47XpK7umoxU6DRoNzZlmYd0wQbMAvrWS4hf2XANiUu3pQeODlQ7ydQ9TDD9Y2sWc6LY/yLhxpP47n63pTueSPV9JwMtRuEHN9Blu8qdcQEZpLMnr5wgxIyMynwTafV9zdQ2a27gA3/owUlQBvG/4dLdRwAM/vecOnCGGZym0e2+b5I3HmZkG497RcwuXBO1Vk0SP1vHSimQmmlWqKuHOVLplK61IRVdW05KKqOUdzsaKdN9U1m9dVJYse3B4t+3hGADuyj0Sef3/gLRNBqXLyz4g10NSNIu7a4VzQRkFmlAooLsstdBfr2OBr+fRzz1q+PZ1pYZyXTYqRP3rOlkSjoBYby91L0NGiejwhHw159/+82RLZ38STKhAHjmtrQmRu0UQoMQ9GF23wbZOF/ihDKjXQVRTmzKwnj+3Q4ON4hpAA0oJvQy9i59s5VGcwOdw73y0xPsI17ym5Wiz2dLhBw67N0zLbNr34dhbUdiV5tiX+DNyVFWtLBJF1A9WZPYAPYG1oMhWj3tyq1pxjzCbe2ycA6X8gQ6vuxtEBKxCtjHeeWC9g+KajXArQZ1jIC13kT9Je1v3F+Ahgz5NVRVfintD1gaHgh1xZaoKov90VKtawSReBOeO7JAA7Jr0N4CN1dokT9pyoGpMzGLIC5YQ+RwGjqU8H8Xpyy/q3kyFZ4B50b3EFPVSTJ7+NcAGHez2RHAvQ5NneAHPVTkk5u1eyBL3ppDZI1IZzWmLssijWMnQP/oIyUjS5z6N4iVLgZyzwlOj17hKZf6OVb31n2+tbM3tkXN5d+OTP38yt3G3oB6jnm+HzzFONCuoM8gvmtsaV7NUmJOvFsc+tzLOxnH3c/uj6Or+tOj7t3hZJKMLPFvabfd0Wvz5XIGGr3OmjEqgmnl6vCodetmSlRVNdvjNHeALWkqTCjGA0Ng2t2+cKmQQpUQSx6JbNHHTnvnr4lqUUpogdKrCU+sLbHX32ojITCKNHwaC/BCX1SEVwoM1yC5+5c+rFraHTvMI7sbL7BNema6bZglu+iG3j5qx8AAWSn1RDU8UI7zqDwMWMdd6pzNZoFoK1UsaXC6UkWIWqm0Tx40b2Rog8/pS4JH72dUxNnlVYaEZ/LGC3yeysVSi32tyrLRXHp7Rppxdm45EIwyvj0XKTXA2qerOO7klm/blp5izJenWkm+oVzFPJLua7JQ3WmNxAFAPBzZP+lH6eXze5n5czaqDqvv1s3GnTmCJSACGjXqNsyKlRn256JunRCRPIHbxn93wH4dKPfATuIM598fqNqWo2N7O96VLkOkFrZJkZQUMooHV/p1a7sj6P9PVGEhftWodPAQm8gdT4gv00V8ChP/Qy9EdpwQcE018YZBZ1Gkiz/xHQCNKk0lCDf+/88Q7DuBTyl6s3TZUl7Q9MLFRYLu7tRXosO9yxusOAcFgdLEf65/UfqCGmgzGzksj9h62TPEOx3k+yhdMmBATmBdOldRMFMj+/waClSxUnvJUOgcd9MHmQIIH+eKtRMqmmw3FXRup7e93CpZx/Um4VbAymOOKuUzfUwesG47Clc1ABJATRsVxuilMlyRxrbgx4JE32s9ol1zuJ0EZzO+z9wsPe+QMfjeJrBKwJdau5SlwGS5bwxvtxoVse2a7X+WRc77xWWFyEqiiepqAZ0uia3mU/uNTTUaYHv9m4W3rSNf6iQNRylKQ6YfpC1NexBiEjkNT8D3yUGguArUUdCde1rIrS06kJDWc/K27T9oCp+XbmSFnmASbUtDO5Lrc3UuBUrhnNfNHGYQKIwG2i9x2epVcXq1+7xW8MqmuSfQDdGIwAgXsGialLTR3AKwe3/p2rlTpr+DzhD2jQD32o+iIjKk/ZU4juTQpjt1xFcobXkf/IDrl4rDoAZzSTQ3ZLx1eB0NB55XMiTWaXZ/r4d1oxIrF7rgCv/If7rqzcECorkW6SDt8PsQB1YjSABCeM54vz/9SczeX6iQq/FlT6fkJgEE/zbyFJLNT0U9WnPK8qHFGK2eeaSIObydx8q0YO4kZFnxGiZCKoQrCdumzTLr05IrkTRfd+E/4tDErYDNtrpHfx/YxJxETeGv9pAHakvfShqcSK+gBC8hm3obOP9t497foyyjRHnwgLV3W971mCPWhvhLnzxFPzChWsvTiFLqKpep5aW0bnWRibrbG5zaeVpIWzhDBIdsdwpeLniXXU/qYd5TX1Xz/2Ung9UI3jcxYcKnh+LW5CXdFlrBpVhTgp0kc8VcaUI/SIICC5kNiG5zDV32vlXfSi0zTV8LHRj45BPse4VutFz0uBhevbYRA9lNeQwLOKcVPjkchT8nzH0O+KJDTnIVMzrNEuQjnM1pzI5GfEXCQ5qvNuX/BT3NoF56C5PUz62oz5OULnPJpzhf6RU436P9hXYCEhoixU+50XAWuEJDP4+BMstbX5LKjBrd8TkIEsVS/hLX3b4mLRQQSGiFGMzNdyNCBImbdDBfFt83x1ZPRXYE8glNHuZqdHj5OjltClAZUXQyw/4kmR9bNdqGT5x57kHspCZFJFwBVpoCuwiAASPKCegOgj0eBsPW25PB9DJbRtlzCpKP7zVz3XQkgyvkOUHVVcR1i1uPI8VqzSA3SoIBY1dryNOMI4SJoWhOIGrCv1zewJuKrOadmaSWf5W4RltpHATPbZm0f/Vgdc5NinXcgBSUqLR8nYZhFf4EMv5DB/hrFPZOsJYEzTIySDjDhT2Bf2bU48zbrBxkAXOt1c7s5rd49phZHc05w/DXcAZGgpqoarfKqSw+BzWG45cwTYqUqFzEAzWwuRRT43RHY7sPe9EISDOvHtzlVCHqobw90nh46IY5VZSqAIUxty9JG2lKEeCjAj/sAFvJBqDTt6H1CuiNtXVefefeF6H6smvNgi562Ld7/hC4+tGHN6tEmlQLeoepsvpMforuQ4vHysyl45bhMtEPYZ7DQFbbt53GZdB3excP90FPLL0x8jXzJ4i3WrM5Kfr4OgEpc+KmtU54XYdh5Nc7IWldEP3EGlbQ8o9Qnw+yWnS2Y7pXH4yY1Yd92JuQssui7pRbgnlX/eq91nad8AZhsDdXNMmFoPpJ9f5YtWYhsJLfsgNs+oe0MbJ19D5EYjQNkJkAKJ/y+P/dNvyVsodvxkf/UKFu8XLgz2tJWMV9rCBxZbYCi/K/Nva7M8d7IzqYDJH5iRPFD23PYg2enAnph/cmI/+kxierYet0y8Nmgarrt1oY15FRlEbID4xK9PENBOlW7X23q3Qbn+asXxnfl3x2sB3Q5QM8xqkrA7qKoNmSV9vUJyXPoKrv77qfxJ9uzAqpIMPvEfCrGj4lwaX0EFzB/c0LaPcclLP8P7K7U5t7LeFG6lbw7Q4LqoD+5GJkUYCwnoTCWsOnnyIvNG/L2mEuH8v+XCqeI9oTVrXGNjFkG/RINbXru0xTKpIAMGzEtYFeBkoIotVrZ4ru+A7ZQIAYZEjCnzdlGQ753RHt9DbGg6JfP0YuBdusBwzWA1ygBclEznTvjR7sfyxjdNFemnSdJCE05TCmyd5g2uDwNBNLNcPpkFWc20RPk1GyqyjxCNftRqSee1AUQOnpnRamXaPOh82Ll4julehBWH7lmKuOIW+v/gQeV26eEMNeumXsShDvX+ijAPpPw6aYTVJQs40cDHQQ1iSnODhb1mKaR5Z61CJxpVVUi4gzkv/raZOYnSLAX8nn9elw0CQOUsHMOZnRCIbYlDSdKj795vaZjfs0KD5S+C6vSCfgfGHZdUd9w9RqvtfkxastULikdCJqhPBIHrFrNxREA68xghKDqmwa89HRBPMH/OquIjsHZ58bbw1L/5tCQDoKdyoxMPQ2lqvt2BqOmP2fNErMYh3b3RrgSC82SFmvriC3BavdguQLeGhrdQm8l6e4e1kNxogZD6JX+1jUql9uVMF737QboH9I89IQzn5MuqJsvpXLFHpKfwFDKhgRWLX2+P570s0NnPZAGqRDiKM8NWS+Joz5zoianVZ/d1RkcjLHl3Pj8Pv7+hFq73ML2FKPPBzRafHrQNbJmFqokqYygFQMUmLKn+Zqlb6AkEwIQDXrWBIBRphUZLTnovvzLJm7AZvAs13nLxrWFEG94ZTc3Qe8wQZ7op+iouwDMz0vDRgr+Ele4jvNMKcSuDidT9Z01tdPWsz3j8AyXzJgCbnb8Gxz24Lm2hVcSWxOFNODJ75d1Xl1CR+Qh//rIARuuioMwPHRVSHjgSjqFLM1LAwCFgH2fQd3Rrzi9ZMAg4qYF/kXxuhYe7Rz9pWSar+8He6mdkyfRV3lLdyFE7QB5PE4wB7GLdvfQjaG3s82JMXu1ZMSl9+i+CyZZktupx2LFIVEda8KRiGkIdTLpSPATJieE+3QX6o8rQoD4XijORQpfhVPuxSb0ce3k3Xu3oJGVq8eq8BCpl0z4RtQr1zzEX00st4GqSbteR/e0P08ZrW2QMGPFSqngegKdVX7w+FypBOR/HmZeNsie0OE2m8qSnZ2FYlcOqBLJt/bs9pa8HiBDj2odBXMEJAzMt9bFgdXFBZ4C5BslPfvMr1lLKo0yDqXrwRKy7CZNVLjP7Oa2AEgtvGeCQuqCCb1CNzeZsTIzdAoI4ZyKzEEncj6G4sxM04SfRbuB6JN6WSU4x+I/P+jGYzLvFSHzCZdDt0VIKgAz7F2QoXMMIrvk3ov24mbkdWStkAdByhCzoDOsgIyk9perq93aucq1PIOVhy9R6uPUTwM00um1ZvqrMoGTys6qCHeXghBxGw6pv98Pz8GMovIAzlwf2jjylfiwu69oD95O+MBP0bx/AtzwPDi9Y8fsXApmcAvdgKyYe6aRCpuAgLxc/D1pJML+UsuWlLTKkw+QFjbmkcw6mfsc0SXSiEpFjqsNjkwEb3ZOm7oKlCNDi3dQHw+thrTRdkz71go1SAHpftjwicOJ/gYhiPYjuImhU24a4GY3q29WZrr8tjsoQ9Vx7PJpHEqYt6c/sIxDeYW0x293wkACMzpbGfLLBpiK/kiAx6fQcf0H3cKxkqukFAk3jKn+1ujfOafiq9Oz2oEUlx4524glifxOwd2JX2O/k4jJ02P8fnZDiX6ihw4CiTDYkOBGI7w60EVPTWsuupZs8QdKvcMb+65x796gyvZfV1lcc1vwsBe4qJDYTQT05L3vNv35IyvV8QD/HYQZmTlOKqG4OIXCK7fB2HtcQdWzwS+x0zMFHUnUMZ+Q8ObIsW4YZ29AifFXD5EvE2lK3cthhK+wsTJdeIWr+59cPNaDtgyKILBbHZ0DQv+5+Erdw/tKksFLsUdzktiK26RtfZgwCSxEd5rec99MFdstpHVc9b6HlrGf6cmysj/teKcTFo3bQ7dkze2jvUd+MQR50+XbIfKSIzhLijv0J5SzM18FP4QNWZWaHphGXWa7/HGXLhx3KLW1Q9/uuyA/DzpatHLnKCsRfHXoGS/ccxdHAUXVdJ6wCKs9yzyuYLYohq1qNSjrjstGR2t6wPX3yk0KCBLJNbvwN3Ez/TkH6nrJTAPoH2u+6iuBhoqy68ZtIpmLjiO4HnTHdME42/dXD7jj0I8j5kaR1MpmN0ujQSX9brtKGyrcEK/cBYWdCd/jo5vSAHrZwTFpVYNjk4ZOV3kf2qbNpvQvzj2gm6/GLKPtH/0WZCOm4UdaGCipk2B+XDNt9SRb/zcNVd1RZutyvmjKyN9upB1oV5RnGbocWJQLSNq3NK4MC4xMqqmf3LGqJvGt1Bk4knBaBDbyVTvshhx02gZE4lijhWG8NkaxxQqiCT5xZUMJ8ZRf/WSSu39+HXPpZJKEGT3q0ZPiXzNNEi6yNP+gEopFDvsnt8d8JWfYVXgHurIoAGzgyXIivyDQr/bgU7RJLp9ZjO4a0vEdbqaWovbt5Bl6DjIueO363sAVZ6JUnVqRHVq08zaUv3ELwMYc5UpYxOKGbpYiP0xcZipf2c5Bg5T+OrPOWddRCCk5nn5YvNgbJYIDUw+lJu0+krBppy+52sCgV0Be6E83d7HcTSkClCmEVP7xn+Hz8sQVD6ttMjeOWnDAbXNj4bZ4JW9OiDeYW7L+lJryQEkNFqDtloBU+w2fz7H4OempqvaSrMs2APq2xZSedQ5/fuiSGv5EQmsY88EKvfeHnQfrptfWAxgjUiLCqSTpe9yaVZjQRmQnSbiL8ygkde0/sj8jU1GF26WfqptgSBNibIglzscTx3YMeSpfGlJdetRqeHxXsBA6TU6jBwOwXqM5eXcCnXh/iIGii1NCj70x8BhFeg+vY000U6VnDXw4vWai8IY+/nPnPaunTHMITYQnoM3hl/UfQIMJT7X/Pg5mbV0dGjDzyYS+kvPoTCGHCKjXhx85D9ADjHKQRTRB5xRLrk3P9UgSVv0dib/tt5O0OzhV/Il36qgw9G995za7hTI0bYPpuYkyAGHJnl12DEFZ1hzJ7gOhJUhCpsNxvJpZCE214fb9d2XtacS60MvOA3ENkRgWN6dGVFpaDcyUfjdikyj/MJZ8YAnlxER6SaU9Af9eYSLiSu1A1tcL8YdR5g2tmQxwqExu13GAjvbqAtd90v8+MciAwOQUD/itDSHBZEBtqWlsrXmJdZnCB6SAxf/7yQaCEZDyGRqSzyRv5+BripFM92scFqteYiKaLA60Y1vJnTB9cawZYmgiZQ/vUzzAlvV/gN60HguZyoQGfth0M+3UbY5AEBE+u+R5Sugp0hDja77nUcETIHlI5w0+QmEbC79vUsr6HW6obKmpMq4qsJegpDfq5Fr8nzm94hbvoRyhUXWtr7HJZL/WN1twqRROp9fZQrlQPst2L5ATqYcjxE2CIT3GHxChnq83B1I7fcU3APf2YXukjEqeU+5zfduOrI7VUOUe2aQHr7jzRYxfZVzTgD0oToyUKOf52H1OSt6SXcAeiOdTI7i6RvMP+SWGbN9VlY613jGQK8JaI9a4tof9VqiRPtHO7wYAUFBaDTmsQu5HUv/oVSprnZwu594D1oQSRm8Pw4ARHL9j9Rpbsd4tLeDH076Ceb4hpKD4EdIODRydqZNk+s0LudEDZFYy6bp7E8+CHQ0wtf7IsCJJcQb2xE2sXLAfKvv45JfZ69sfTPTc/rh/f1QSUovgsXSFxTj12+Fzwlv5ZCpmiz9bXXsBhV+LXMGdYtxVAgFjpSkTTkQe9Ssozs9JDwog69XOOIwRlEDmSMPwfsmS9x786aB9mPDUzIeLPiGxF+V7JA8nhOMyDmHdCd8bdbBjB4fzhq1mCYSY4aJYGeYU1hsmrR7706sjuW0tHc4oqn8GFS96aiRPPBz7mweVsKwuPHJstktqb3VZ5ke6k3YJ/XZrIbSHnYXFizGDGx1silblBjvm9mR0DoKnyQiKq8EKkVc/Wg2PC9tVyiz+H2xRiYErwnQTnsMxw2pnCSaG2XfdDMI9HgjzkBoYpg8DBpX/Y8DwDzNGmN2RWQ3rvTm4zlFePIxh1Mw/xTG24L23VwlHaKrjaQDlPjOISV6RRh9y1flp1e3Fhv0WrZ3sULfZA227OznsfKrjVzyyQsM0p9q3b9sv/4DVB3WGoRhrf1VyGP5960FuJ5tnd/tL6eB4tGEeFp2EWvUDqkQt50Te8JEru59dNE31dCAnA48ISJfz2aAL87yDRyMXI/ebSHMsD/OB6pRNehK0UhPTsfZQLqJw1pF1BTgCB/+wYhs3lPUBwxBvLEovwvsSXMO0RDF5jeE8vlE2WMIfbG2PvtniOb84jBB6Q16FSCJ6GazZabioaO+yOuHNDeFwl80c3llTu4u6hc3cM51y/Nq8+EswAU4gBMj14sP1x/qWi8FKQKJXs/Vu+tiCzfEl6QoIG4R4W+nXYEJXF2VDYU8NSFtcRsMF//EOm3Isfr7ufu/snfY4DU/k9Vc/JfMBNXkVge50AE6H+mcM5TTYbdJY4gIhfK49nqh2Bfyz0nXEueJww6ob4vqVJFQHKucvhpHoahHoPewnXF+T6yybSSxBQz1Zs64dsjbZ8qEdGq0XFUpNMR9XtDnE5WC/RPWZaX2roqla4jGuZyFb91eRl/juCudRXhhj9K1v3vgu0ufxLEHTxD1IOeUPbmVmUamK1i9p0i5cXxnV+KxrxU1lzitueLr5JpScMRK/mcIOphm3CaCTOvPxvo7RFzPA6xCmRVO1oO1KR8YkQGd5z0ZgSzwpmaRB9AYsR8kuqnMJezM+xsxuWd4Sns3Wf5+fkGBH0cvmMbQfc36ZvFdrpM10bIxRUZBQC2O6WjdWi/rQaRXIrRbDwBQlByEzYmXjvWIbbwCpTgOzysPHRBc4NQTo3je/PoznfbTedqaKRHVdVQIX45hNOcLGcP5BqePmyvs54Obggt2sgi7Vh7rQTpqFSLm1Nw2e2KvP+9KXBs5VVT5TeJd0pD7CYA/SjD4DTAILd0XGhauQGLjkCv1fmteq8ceel1uheJTfukASIvVD4hCgD5FjPjUtYp3ARm9usDauZFXH++sPzIBEw56v+ajGg+zjDW5+Wv8OLEk2no0KAKmPsuhiyrohbg+AkqbHDf6kXgKitnBVEzorRmajT7mPQUX8MGGyfiNJ7VetL9fQEnR8C+eo8JY+A1QSflixjUvirId6w5YKo/zLNNZTNYvWhXQRjsIimwH64ShZ8wtX332QjaDXhqsxrf3SdMLZwvzXG8jTfiYmce9ntf61VuK6vgd27rX38iVIiF4pIk4ZudGGYL0bwjNwTOftqW+jv7nR7xlB6NPnSo0vHb3KttLDngvvTGgUFaD3yakLrlWNr3JdNHcbhEgNEAk21mfU0CVytzRAZSPC7DAQo/TXQX+9vIwQfY8mrygzTtQ0D0lAEs1Bjiuki0blJtL9Hex/qk+ES+S1Vux035CmL+06q1t82KgT83l78+z0yiwVrVM6ZJXYZ/2pr+f9qiiw+eEQl4nCPWjJlrWjBiDRRR7Ua9keU9Wuom+V8U8w8ohZf3v1IbLWDfuns1ujCvbKDi3sI2xui+JmlFbvJqOyifIpc8U4pH+6loI4xCik7z0p0xcfV/XTmnfdO/flaY/qnNFSzCESPOY1TR47cpFCkmqpI7Shigz11/I3lXWOSdqkY/RY9pFuCVCVq6OlU/KfKD061N0aioZ/MTDQ0C3PJmVGBUbiopEnuFS5fTHrJ4UoTHT3T/2Ir+FtWkZiY9zk3rKAjOUDfArAcNE+97Ty85A46KkVXphQ+gTLpoWQ7J9OEnfOEwulG6B1mejQdtLxUgNNtv/tBUrsVEfFC/5IBU2Ac7f7Mb4bZq7gPjCEiiVjy5ogsTCH89aGPzXKodtv6Ip/gFZaBO5vdml58rXi49mCEZMSr+Lgn7HmM7P1mK1zg91xO5iaYJ/rc3kq7LXM8bCx1wl/QMBpICQ3c43x4J8NeznPR4tCfCN9Hklb5ry+Gzx815/GfoY1BE6OwEYjPSU1cWNFSen554j/OOQiqxFjZrgKEsHbECTcodkWHM8qB9HXr0DhdutEZl8348E2YNbkvhTaVhNUcPh3Ega9Y3W2Z0mjKfhTYqe2atSKWFgflxuDbIFI8buj7g6/k8OmMIBHiKGmDu5CHDxtC3PjphoP3Xvmd/mtoN4GB+4ThpWC7ejHhw+0PvsPg1nZhywoH/JPEN3FYSRWf6x5r5eIP/oyOFzd8XbDQPCDpKW5Ar+WO+uTwN3AbV0g+62jtjOiKuI1RJpvdbv3kIK5Iz15rRAb+UMAbLxwTY1GadmJZzk22JV2uL+8rbu0vXuBL2uY6hwKdgZDtn8cqaKABWhwpa9ALEN9/ecV7vEWFMBQDZOZZZp/Au7uljRJn5gBhgNlWt5IBsujKX6Bqiu0pO9gu1yqUqmotb9mO1o5tg4BnS57A6VitQFjCh1ovcPTfnPnUjpR5TY6QN2IDEoDvsqTSOkdg06zgTLm6Y8SOcyNYdAOAHYfccXwsJlDh0xVovVOyrmIyBvXmPqb4iBq+nieeXHcPik5aE7Mr1FQY8nGtHGlozTDPjg6zaBuWqsr1rDOhKPep/3xnzVPPpTtjMLmPmUvgAls1AV6PxYUEMfb+UP7rnqfbYtqlna1T/5mhQk3p6UgLaEBLUJ/e7wtN6dfeDcm7G1rUqJYve4GudR6lZqcd9t3qyYp/qeWwULJTVLlMs5x6fmdDftEM/AohoG9GEAGXv84L/lKhwwAdUU0WQbpidhI7pOicBY7a/vU/qfu+FKSPPH/iWloeIGEeVQ0XJRBsGNfcIxY7u0STHsiIp2SHoIXAAX6oKz6v/9LRoE7YjwgEB2+71/UjgW01zw1vxL8Vxd9atOZRg3KdIvdrmk3uN3IfjCTZ2WsL3gRf0JaQzE1/TdHXXiOdFv+eQrZ8IhVOAzBvrR5RL9S/TFL4QWNzJsAZdEENBpXbwYT/tUzS5CVv77U1954OEJiyozf/0KfNK/1RtUPTLo3zLgBNFVeGS+axKxcT4yEKhYJ5YPWAvbsaatMSKCx1cqPwWcQ1hygMfu6fUZ9XCMPeEAoubEz+JQXzuE8d2fMzsDZs5xWSC23vE7FoSad3LJ363T6EGjhKVXiEOxzi18+IOAAk9mIgcaZIfKTB5JLjIzfOgqhsn2G0KE3tRWZXn68DBPS/UA3hAX5n55/RbGEKbhuauCANLuwogaaF7Hy5gWalY/77iOUSzCZPvZE6e1d5HBkkhtydhppgnwiXpsDNvJmD5AXQ0up4iE4gWO4z8yG8qpKu1zEKfZ3syalBmh+B1VATZtO4QKZoMsUXrf2D37r7g8iIrq9ofLZxNpSL4+FWyu5Y9LDDzWq2EwNpNviqMLJow/bJStgSPlQxSfyJqq+R3vJnpPzp9UrUD7i2oi+enMPHBgJSI8qTwxmLvFdCTX8TRwUJVZWbytgqVo5pQOGCAgTjJqN0RUPWtxrCebM3iWRV7xcnsrN40apcgbCbd6a+JBXHCYmPj8eKLUljLBB7GOGiKMpsEvj5fkAk4yIstU3QUMhtpn3Qqha/GrE+/EXxRjZriVV/2MIlRyJWJELksjds5OcjxrEc2rv65gLfJ+E3ubdmFE1wD8QnnXPcTjOAEDJHwsbQd0Yv31fhMbVEAaZCFkjJtBM82oxY/Xrl/FGhOgd6E3kfylu6x656UVViKPoSIWstAZVoEjMbHyczNbOMdkrIbJu69E9tZZ6lyxJNjH1TOmjfDc1vhXSuv+BtCW4zvHRf5jjLw0f21IoJsOjsF341BrxxD1tSVNAwaeWlNqiUTmUIMz9YSQ64SRs5h36LrVrFJtBiTARXt6cjSzzBynQZhQcYkiHJx7aTTHaqNfYHrfHJUrFVYruQ8aItpWBnzIy/cpx9BW40BuFBINWL+7SyOCVQsX99JU8Up4uA2FqPjlumd7CX0WBYwXctl72Mka6RddEHrFBx8IedQWloAsOFUzT9YRYuB65TNEcaTDgK0vYudcz2xlxGRB0de0wt9A4zMbXpwKlwpLL8zPsWYC4tiZ1PkHsnktpc2k1MXnfxLpZpQl87wl6nqef8o0NXyRhjTkCiV69xTQq3XEIFN5qd4z6+M5yxO/0CP8QIlA4a6oIfId3I/ygia5xYrv3E2FlGL5cGSsNc97f4juSULO/Aw62puAHyDj0cHoootHv8j07OGiDDOxpqtEu98xWhTNYWUHt7T5HLHaHAjRY1Trafiji7TnakWM4r92hdy945pzpJO+emkAIcsg9AU1vHEdjq4jqZzopSZWABajnMPuDKdfs2bII0U3bu04/QyZ8WjOuAN2v69XSbzAtYn1qNZNI3q4slzEQ9HxAR4/LK855JmITpCrfNluCmKs2I7KJcolCihgR4EOslEg7wPucfkNQ9SQ693PSq0T3GDFa8VAt6a7qzR179XSM373MvrPkRJ7TsFuLlnI0aUn89MjW6F1eVhCvN6kRKlPecwVLZ0S13IYpV5bkl4jzJX4W8QUsgU5CGmKmgsKAPIfVH7yY0k9bqC78lNgPToWeRzrErbrZdH9RfMnkNbcyFDaUwMfV7qKOL4mwj3EYKQ5A7S7JCHLuCf1dyaV22e7Uyjon7ahuYgFU/hL+kfAshAhoWSPH4+yjd74ybEUKPa3RHkYSkrr5bJpVjNB/DiG8zAPc4UrInTV7QDI0I88qVdyn5q7uXoXh6+JDRkyC3PE9hsRRraX88kQ+pzs8c1mYiNd5yABSdQvUSQ7DAa23SHBNewY1UP2YlXLlisaa38kLfSlRObR9G7UtSocTif8a6avnmxjcsiaA9A05Ww2CH2jQ9hhBy/94DMUH718A852LrrKc2SEgErvVdcOm67nS74FiEOG8H2lZznacCAy0jOgyOiDEDhFysWhDe82kUSzMJiDtWg4P3fAWcl38n4coNANhfgpciSjKKl5y+Xw52Ndn9Vh9VKtAuaUtNbeKzWdBCCB3vVy+biiTa5OXYeA1tp8Mbpx1i8aODlGaipFDBxR6d0z0UV6wnSSt3zIFp7ikd3Y0/rdkQ/YPfvErkBmUofrYCwuVwA4YE3vWkSWwHe7gSdqLpvMOsAEb6PkBtdRg4nUCf6a4IBGE8HVU5f/kvj6ts7gW2/eia3umy7kGYJYqBwIMXdzYNATMNgj2S0Hfklozyi+H1lGqM/0eB7GOYItmn/EURgqDi8osQdz/2ENFKMotzH+j8xcEXtjsJzKCybwxPT486xceumB3nEHKoPBm1SzAc1lZETX9yLXivkPT4K+Dw2sIBr7/DQ5P6pF2+ElY1VYzgjCrvZAKKhSEw1A7rY1DSx7vBzlADTGhbFvF43gzWrB1WV55mv5+rutl9I1Op/uz715jm8fYSr8uXNV0LLL03dxIj+WTQ+7biFBr/aUk71/XYYJqn9SPJL3nqInhijFVvIhELJFrInCl8msACOnBVLcQbpfF53NKXmwEcinQq1W/8YjcvUTw1KBXG7cvBhoKg2qk9boq9nniKyCH+qmMvmq/1w3V/cOeEbD7NxPV+f4dGOYd1hvjEWPp00w78S9i77Emrg+i/YN8uu1tDj7K/AKOWsrSumaibLKoLALbpj7Vx6+E7PRjxnVctH71yGhXP94beWAviogIskPwxGMXeNBv8e1e9JraqfW7hf3/DcjViI3tfTOJJhlNEM8HXVqxhzjBY9B/2dnWaP36nofapujq395wj7S/9GWOmD4X5cJzUNJEGT7LpYw5v5bmhsuSdC8Vp2HxiTcuLtBEs5aII6BnJGzmoBTL3YbGUmwiiz1AsyabXGIWsCWP3BiE4cPM6c7rf1fDOoColMqoSxzlzWLLEdO8nCPLvF4Bwk9BUmi2gFAmIjOhJRbdJ+uOOBud1ERrv2qSJrb9Y+TYoE67onGWuzB8fzdHd1i9IjVfcRJ2Jjf+UqIUHfVja1FxtKC7sNW1oTx9vpesZbgKV01EtpdhlYMo43O3pTNzO2I5bVOyX0U7lYY40ymu/0EmpKeaHM8MtzMWkp5wyHOWpaYwyh0Yzfcc5z/KczSvDN+m2zxdys+VLN6RXqWKOdGJ34QAkS8OIbUte6BOZDaOdX+/Ui4vyh5Zk9IpQYHt6STsU2xBXvx3OLZPybsVjq/7hslgG0LON7wZyfckdiFMZ+Ni+jyZqRZv7CrD9VcvZ1yEq76NFBg+lLzcSuyk2vnqhl83+9Q6BPN23QBIklvUnF4P596th1MGugS/WxzLLUN6ec7+9B1fVgl9Aq+iHCjnG62u+r6lOnMQ7pgn78ac6Ut/yC2zGMgR4xtBaqhQIIW+RTSuZUCVZ23GGVT33kcC++rfU+gp5OhjFotEdQBbeeQKCiwVXd57Tm81aHkROeqU7I2TQbwTaq9oq3zO0QC/96WP5l2C+hGVA28D9X/K+qj4f/os/+5l3oAhbQmL27aeV+rA/3BC6OQuhCC3PUzj9MoWpPaymqXgz8rG9nsmLzoUYkoHZkCHJZNF0IqNWycM1hELQJX7KqHbNLHnweTGNb7lBfZHnK7mKF5fGuBRbnm/PPo2fXkaAwI2kbySJUVgtEd8AFCNwkoLKPNrL10vlVwsYn3o6EkzdK1KoaKelZecN1lfpbvwMIuy3j5EIBsfEInCak8q2xNWhc3xdEiwd6/KMinrF1mXr0H6GLZDBnVCLzsMKAgG9idZqW5GI8Ick8PkdgnDz35scJ+Jmv0vimZ+WYT3SRRNv/qY9YWSTOedsV4OOYFt6/lfY9eV6SAKofS1tuSRbprtRFBjY+CY09DEbSjaHVYbPgjq24uDburPM+5wqLipjVb8+V8HoBcaWnJtoEL8XYCOGHHFFjheOLCAgrDnT8X4oeUBoEuu4ifiinUgsDgvP1ESf19WLe0I18mRTBA2kEVmxSJ/u9D1rY3nqZCj8/Yt2AFVS2ln5Y1CJiCSbelEtUVvvQX3i0BkwMbXiS6jsbEVQBWxnZQNgszXV6MoCFn/cUsDN/wYzSVvk19w9QSOMNCawAJTkSaPnD4SNHVwDqVW6d2YQ1oqgzdqDxla9/boYRDH9JOj7MPYwJKYVU2XatxqTm0SkzItLHoHQ+E+scXkBj/+ZLUMsP0KWDDLmMYRU09PP3SHlOUr5gLcGXCcaDAu5k6XR5ys85q3iEg0aWMlutDLiTWH9N56xPNjyP9dyIE8sDIPn4ngBjjL9/DB/gyLThv9pj6kR/1yp5uPH6YLHED3OqMzEILzZ6qHJPWzFkyj2f4mi7t+idEw6d3YIEjhtj4STVHlCAQzwoF34CTDUTfCh6H8rlwMj+ah5f1w5TjVirVzSfDJ6Yk5IRJ6wwRUFnYoi4s2yzZYsbw3Ii/w8CdVFb8u7BPTce9xemJjNbhkfeprhV/nVZPjzRR05XAu0/MWH9uBBuWn8t5AJeDP/tbOeVlukaxAyBWiqXorBe3CFAi8oTrruOtNlrO8fcJhi7fP1W+rxMrkki+fDaBbOH7f2+Bd2+oBi6vC1rdhKOalkzSeGkjGqKvG9OkYuhiiC/km7nlwPai1F1E16EfclCrifrrmVPYH8mvEoz8jFNtbh+GeNw3ZrqGa/6lFbeAC08xrs/S2g8aTmcFevirzB8XSwm6AXPKnLW+AvvsA3EqlMKgCSNbmDFVcCXf63RWg/HVAgA4igDdR2x32icFJ9+kYjzIo0viLoD5NvOcgoTCZokGiFjXop/KpcM3mMvytmVogfMbXB8P5PkM6C5zmAuKTP6iqIkwCGi9eT1+rprPEmLH2S1b0wgwWyiac63s31bB6yOmRK6+MQ1l+g2xBDmP9X1usgb3P2z8U10kHjh6V6v+jpzE3XLkis/Tv86yxLB4FxEGR6r8rWzKK4fr4Pg51IpU/1Ol3xF7ypMued7ZcGT0e47ehXZWDv2v12EXk4UzxZ1QYDcVb/BreEpKN4WAnFUOZdPmy+iLtLR8OLV9HdBH3hg3DZY8tjeEmNwqLIPY5eaUXJ1HJb+RhzEM5OgqzRbS53YYcBgQM4dq0GvwjfyK/k6k2MBQr9k/sEz3ORmDIPnquS1u6Npd363oBYz0RO/U0hP8DZ7ZVBJ6+a+mu249a8aDM3KNRYKzm/8EpKsDXASuj91x9YDv5cIHj+ZzWR5XrWQDV55GljZSHKVlI9PBYGh62wqXYj5eHN3kt8sMZyQBbBBXpHwiw4w+McnjhFlEi61xUDBP8+H/KtFQ4Q1Co6LyclY0A/LrOmJZ7qCSCtAfSgAXfQ+kbWX2jynEGMs5NsLP4/crk5hrOkdlufuDtWKiIXe0tfp8W8ZBn/L7m9V9voN91Qh2AxxSPnuPAgrTNPnlRmHnrwXhcxqQ1b/zSCvN7fXD0lOrG/R1JrVotO5lFAjyFIS0Tso4iK9JeduPXP2Y41nufxJxl7d95gIWpUHaFYZrVjNGLkxqQ9Vif5CPjGo4BB9jAMPrygD40lNrL4XMukti9Xf1UHSIXmIaW1ykoHbNWx/FfRlOGhM0FOxjfx6AgMF1R3VHhFYWOVBL3La21bwsVauuZc/HUr90xH+WFqug3qUIcG631qA7VzEWRU0sAd55JBWtdHzD5ASPsz36t0LdOtIHDHa7n/Xga1YL54m/Et0oxP97SrdxyYZEhC/XOTNVtIp3A4wtPVtAuYWKaxCJ3OSZP1/xAo9ZbaQs9sTRvvVi2xEX5u72iW7tvDC4kB+8RVcrXBNcZVAovTkRZaPB708hAyQmxtz4ADI92vSf84yDuBtyOedmqBo37J810B/hNkaexQ/KrHNYipmVLpP2gVGR9WxaHWP6a/mDgoyeGSWFWXP4oVIysTlVfvw0M6HGusOMpunvZT+9WDudh5c1vbc3eIKB+39jofoMQbIiMS2SpeVcz/Xmg9nwIlW0TVVCoWErfB9FsbhjR4XTEbdqI7wl0ZjPd/w20+WfyqpCkA+Z0DIBJuvaFfeFowtS8XjzGWmn/D7UDad0NqSTFpK7fzEbhW0MjfYd2IyjaG23n2rhFYaE+esMXy3wSuNPa0yAcfVr1WHRzBkWvQDCYimAhNIXV8wJVDtreJ0eACJjRmSjWJeuqa8cLhi0lkZIo4yX5oCi6ZcOPLav1AbIovh3lt94LPC4MHglyfAMSouhdbOdyur5CN5qh4X7JLAW2IdiiSg81zh9OsaMhAOJoXLXk9Bf5jou9fiuP2VmC6FY+KhMyIVwOafPARKNScvkX7/r7IuLo0oWabU9tiTegqo+eaYRmS7oG7/rnFqMry32RgVSukMMxyxEQEUDf0rKQnb95kXd/gB+s2mRDo9g9Gcq5Jdn4xk8XoVDuVISEAtW5Y17UossDbdy/PtL6SyBig0qh9ITJGMuyCq0LujaR9VISpuzBirhO17OeIgvhd5bu9itPv0dzGdw24e/AZraCCypVakiqZ8R6XEOPhwz6qbT6Y1iWpz9zFZGi1hY59nKuTKrTmzjejk7HPu0F4TRvHbolWDhz4GZ143W5hN+ZwDB9TT7qoVByXCSx8QyBpfgfe6EaSxmk4HtNcj/IbJWwu0DUtK+pp2Hqf05zcDSy21HwE2e0QFNB/e253s7umKuZH71SoH2Ie12233tU9vsanc/zx0jwSXwbz7STnO4Z/oX9iUE+gtaQMW0a0DYZ5LNS0QNDpGT9XUMhRyK2J72rYeloc3b2/3RCjfSNRCYYSNcU4ZhZXD7qcIKj/mhR04ztYUdhCup91xsHdKR8/uodv+vau8GD72JaS6pCycljWP0CeVF5qzUjD0+uNdiTCvW5iLQ3w7zRQPUAucQSarLSrhNJN0G9SZwa9IzUepBNHXS+Mgd3nbTnOoWmt2DjO5x4LUuAnNKs8o3nNrfvyCF0a9fGo2M7YIRKKqd3iUWA2Bu0J/eohafganyq81fO/WPMzXVulEkeJrAp0Yl4kaY4foTsTNJWZ8EUyfwKinZ+XtD8V5At5TO8wfbmXrqS1DM7B7qqb6N73n1/DiB0rHbn4IOL/PFQBmsTe9sBbRpwfZssKx3c1eUivD+jh6eZXEEPISDU1+WP6ImmYmTl3r1UisXOjgtj+boFETThiEQgnwez9KLo0u/CItMtRWvwIOu4GZ/KQJ55ZW+wZrZiIASgwqVJvMU6RsgWd2zSjzeaVfnCZ9eDjkOJK+4lvLimbr1Hsq980WJcHVOixvFdbWny/MryHzKUkeE/g3dt05lT3kj7TmNvwTMvWTWbB9Q1fLbKJ83JPuIOeuE/pcXqDFxIJP3FL88lox7gemk+WaADH7afJeOtQf/z/Quyra4277pUGP20zyFfpKAMCzJD09dLfwnnFaT0i/coTZzNst89bf/lc2vFLsDlNdQae5tLLoHmvIZi1UYwBufEYbo7thDxqS+wv1R13cuVot0FOS6jjDNWza5BvE5d4B2LPKsiBX3S2ZkkfVYxKMpBq3Xn9RCKiyvPVrgy+WuXbJY98G2a9HPQZgmu04jijCY3gblD1hR4+GtfoJrDUEbqhevfkdZ6hjkPVZupUVEieK/Dw9sztA7vTDhlp4OGcI9f2DQO/hSVFZJNtf0EQfKv9/J7+GRQKCrMIHqTKM63xoSku+loUG3eP+bZW1FMSHkH+JD3IXxzy6PUBmIpGT43J7jQVZ9Y2kA39a1Aw+L/T7BmZjoTy+n5BBMfKcK/O+jK12D++4I+x14la6P+m/VZWwqQFv4aHaasOVDVwWAG7f5ZZEzYVjNCs8ElSXoaqDIjKiwAYkgJ6wsp9L96DR7l63BMvxKqRkADJ7VPwp4Iqv8n9GNZmpQX2dvzIjUzUHwfERIBBY81chio2X4PirG8kBxhtkwJREx3WloLAH4c7FBzspbGfPv67wCj4kMI5MbUZEN8OJc5TR8BqJZ8vdq8Tml1OlbrNGR18cO7EbrOeuUcjDGOAZfEyenKFQ0xWEEwUKviV3VAm28ptAaUuH82ry7c+SxhBWt/fGhrEZz1vLRZemHFjZkSPW9qzIRKGbSfMiYY6MO28Wohu1QFTs/xuZeRH2owcB5cSi1MSNKa8gaEJuAg4tlu8EN1FqRcXWLZl1/2ZSFCxWNjdozKP3PM/09wWTBYi4Yzzlv01ghE2VlWyvL+J8o2Iw929CvQ5eCd36Cyw5qDmZ4BqqTxgkJf0+F1MkcXbBBaab36k2G4qbwXHZdyQkrXONQxzEmMo+fWAtvS03Dk/OQWTxR5aNYE+VDXo0qOQHftE6uP6JBg23KPpRB2uX4r2VcrelEe0AC3nz0+GfAyTKdpEjeqBlnw7IT6GzOJAf03l3JVuR90zgm+4M7k6KwscqK/DFkAGU3O4Ti3l25dbsRHIkCkcE+vtZzCt1BLgvdoUxpiokv9XJ4bRqDV5+6P1fH+2GIZqls/BmAj4iBoHzl5PTH1duYZA4wFij0yjN8v554LcPpFa0PzYUbPFRxADxs09H2HAigpuYSisteqU/gX2vY0lZNnIDIgcPTcLXkhLrUeNOmQxyvDh86raDq1Qg3ltXYKtyIM8TgtLorEZYU7VPjpTwHMJum71jgkIuVgqVKVJHsuE3Qo7i4PtwAtvBYgESEv4cuc+mRDUNsgmJeTR6l9jgVZ4K+TFEQL66RnNWe+apcJUK7dKGorj5CJN6U3adB8Vv45S8JItz96MlQO/aAWViVuCc8S2WTK/eNTfLuHoZ0GvsCT0mEdmZRUGa0FqMXRjFycBQfaJ7l8CM8jSFI3q1RRat0HHoIFd/mjUMxSFmeMMoA+L4/NIKRqv9uq9B2zeRd4dYLzoD3hY0DBqYxeRi5kstk5ZXM8aRjedNmBHnm1iuNXjdq//fW2o75/yiWQPVXgr7NiftuFBi+K87RUUdYxbQfMCONRBJ8QRqEpAzZa/DQDA0UdDpZToNb6/GXAKw19n13PFnc9RJ1CfLh9HcdyN3bjClmkBjlg7nOzeIAmo2bKc3jdi2xhw/YRooxrx1XpYalvSuYvPZZwAYJpunng6W+LMdga7rPrlKM1HycXD16JN6nuI5vUcvzO+FifTmekWoV5xQfehGZ1db6x5vUucOX9OO8J8A6rr5p+XJWUgMBNQ10wt3Gdj/yq4XIMgx0QEDcp+7X9+r/HHP9S5pPeu93d55T7jMqzIP8pU54gpIJQoWuVtGrtF7V5iq12nOy/k6NGIIsfYcuSYkavto7LP/yYREoe/qwkFmYXnG/92AU/5hQ14GB/TbUHmf4s5DEUdaVgHY1wKdYf2h4jG9JATvFzHOsiMcFTyNulBt4Dz1QZUFy6Ov0b38otDyv2MTaTZfAVgjuFnJG412IHGawAF4rEGwv0+MJc1nsIc9EqseO0WTmMB85kHX6jCQKB0JU4i7iI8yvhaAN2K/CryeV5UumPpGUO/Bn21oBxojydWymxK6x9ju0mNEaFepHxv80GlvY3thLSg39p5+GuJIlBy/xvDUFbhkxDwYXrmEaMCugZ7hfL07G4LG7tx0qvOLYXi6m0tNLtIpuAaqazOsWAjQPupevtXEYblHhzDN2b0joMAZ9bEZEbQ/WYOr8G48X5HXv2mWRQxUp89leFddeh4KLgNBJqs+KzU0QwOrL5T93KmUMGpHlnw27PGuTgtOiXQ87NfncijT37PIU29jpkQ2VarZ8AMGY2SkGeoB0tGedPZOtlsWezxqGS4uSfJmuWEySWy6h0NNGH9kweOiDL5JU0wf9zTNpu8jqlGkoGqkl3vsa9D5QCxpQPjCYj4OnrHQua9l6MwI7SZVxjrXP8ysWaLplUahw2MKBjScqlkG+qL1trV/iXsP02JedTxXFNZROFAtVkts92Wj9RJ8Ksy7rOmqfg15CWuyYUR7bappqGypl0j3gn4Qv9BV4x5EQewfEkQb8ARxpsI4nq6f7tPKA0aI1IwFu3kh8An1wJsu7wKdiG8/lM2SOBUjNjzP6WB8WaXUduakp1nCRPL7T8z0xAeW16hv00DfRy5sYrDuWUmIAH9JC0UtHBOTr4eWnJ75fdIbfWOa0namly+iRV1PrrKRKZhY4HhDhuumzfLPlkfnkBmwEYHb8uZwWP9WtlphhudT5CEg/yjjv4GgFN4HrkjGj7mo0zUjZSK/d5NGDyRj6tSlEcTju/tNB37fdBs6k/7Wf3ylQT0Jf2RyjWno9e8HBoF7sZ3jRGfUlLVhjOnSQi/nIJ53TpPuoka4YRmLNOe6PBSyWUQmTIAYRAflRy0v/yBHqqj+wC/greSrWP6QHft5T52MtWKNi4DRI5JXZ9FBoiFn+GSsfLwtsKpxLB9PFn9MZ/I7v8pooZ0+QojCN7XqPBo5KKXPATDElZnv8YesblC8oBwukiKpMOxFmfQ/QVzkSygYJV0Y4cN1DSxRD/Exf8mv2ql+nYHnxFhcPJ6XRFwy3tGeR3lc0BseFP7RWvHFu6mq2DVjKEl+7aNMwfV74i1qIe4zITt3bOqwFU6eSyAQdT4tCjZDWMV0tOwtlJ/wOB45T6cxZQeUviHAXALQf47qEvixqgJvLqsnstU0/63H0RmRdU/317Ld61bIeaSpPFp+kz17qHd9410f6raCb7+TGddYqIASLJuhOBu9xKa6oDqR74sLuLqVDc9wZ5++pUA74+urGR8fWv+8zUdX01W2k9GiflFKOYCOiX9+jhJ3XSgCr9AZ+BF5KFGz/khq3el0p9zqMKM+WP7tix+Ki0RfjN/X0pJzq/MCP1I8YJRZp7NYueXaEEqCX5nLD+L5Z3P1ItS+7nRlGRdz6P9APlG8jOyI8WEUTUEq44iFSj49adCw8An74WB3tn8x3JO9//44ASV4gWzsZvD/zb+46P8oSOK68POGTB4Dsq/t481JJECuUTfFGX8aXe/SCs9mI2XHi68buXKW4WaTGVa7qGfOase98gkyJjq1BWl88dYJhiDXtyeC6NS3Wl3BrwQyO+ST16TaEzHyi8ogttcB/iadnAjcyLs1dz33P4p7JGjGt55ZMKneZdACiSuHVTcPf3nNQTVitPMh8Ir54chSFCWJ7L2P4XkVqC4ude6Ps9fJ6jxPs5veJuPH9QZ9IUawLutbq6a6Dc2BJZLYK84rdAx02csV9MygQo7R3/wewzHqfGunN2S+61w/fthOli4z9iYYcndpvBRmb2Rd1T8Ls6OfRpbQ/fzF1aOy2aBa4497CI3NZqAFIrCgBk4Kq0luLKrzejZ4m81I530PnWP37QvTKKjh+NEQc/h3BrHRNfKY0BDCV0Y3ikgxzFM9KX5JvSKuyxHLhJFocq/7HgrDYIjCgH3lNAFFyvDcZX2Qcb8CnMOVguFvsSJIEeVMtXwKTzu02bGx0qrk3f8dcKR/b6KyYqn/Ga+gcq5Zz+E+ircCctoCgMUTX2zjnAq3FzjNOUWK6Lh5ulSWtqOp/V8/E+OV4xpHNZjKOelVgoBcy89yLnHygqd90AcWS7aK+uQ94ye6mCPU5BTpc7dMQuiz0ytkP8h2kCPX+A2kHzRjqi+dH4BsuM7S0H/wXOBwNKQQ4NZWcev1QqDG/MLA3yy88nTVM2zLgEHgoCjEhSHIhDfvJsZgHBJ/VgIazYnFX86W6fKTy7397mJpVrF1DGapb52aMaYDODqzr+JVIkTTXAN9kabgtiXiWdWkY0RcSIKIDOdYIK3bauY9I0zxf7n2qPK9EElylJaUmuYG6nTa9rBughR7zmzwe5VH+VF4n7eOokHT6LPb6DWKdhUcdzDc2yiTWHvNl/4piENNe1jFKwTzVP/iH7KK72k/s1knP6VwzcYGxWRWCSkvn1AqnatKms2v2oQA6Tgpy8XSAuu7c1MY42F6NQM2hlRQ2htY0sijxa+SiX6eY0cwKC+fyVdg+IeFVrIECt38fPPHjz04VSZRKh+HbmxJc/Tpf+5Gs2pi7lUpQx2yyr5p1EDar5rlssLLFMpG+ZaRYr1W7BfUWp1vd302sSZKYeKY9R1kMU2aB+tIhxZvw40A6K/y1sQV+ysduCkBchRie8CYl2G2SFi1X+O4JJiZEZUigNgMrY/goRXcPPiUO5ErAheENSy06Q087gpWi0MvWkgH7rC0sVJYLjMIET48kR1heCl1fwP+czt/oOQ5M54J4mnIXiywO3Zbxh4E1o3cqNCoDooddBdQcR9g4n/fAlx/XbO57fqKWrN9BXjBH8b3Qa563deGBEVpmOrY8vydG+JwjN+JiLxpo2fi38ZIv1X7ylmaGfVgH1k9Pg+rHWVIBMudc38/ivuo+nY0o2/Wh3i4DagFf2OASZRB6h5OoUC/bNODxMG+hDB+k+t4FeRFJHTr3/ES55n8f6hZfpJwPaM5iQDq0T/r04g5VaaSgc3uv0kjV2aVj4S1J7MU1eCIyDFvbYNRB685QBiGNvhteAyia6KVYnPxtyi5txAT6ALLxqfSTCf4HD0d+UI/VXKIZx5dMv79Vh60DpqK8T1msMIgJNFBJ8isGdnpKA4f9avy3PFXBw2fR1zkqV9BHctydhQ+f0pBm1o8hk4k6HEmktiBWqdQKX99JyitZ4IIX+Mbe+nSJ9W7wBcEEicug1bGlOhLmPUwn0N8epcsLPnMOQu0FOyqxIK7RqSrfYIBAt8j2skR9Zg+DvOuJVlvtja9Q1uV0b7I4kXncDTlBUzSH8+qe9Bgtd2Qr6ektQ9/icJYbkngOWPop03iOdpK+c3GelRquruGC6798MWGaK++KL84Mh6cs1fd2JVmIgKVIYpc42NliMBQkC8srEEshvkWSfVzHstXwB8fSN53rp8cqApRZu+vdCrkSdpwhce6PtqROre5jAZ0NX7W5dyGkNa7xb/P+vwiTqfXYQhJ9Pige8JtLVKOD95CJYbTd7QUobP6ADBAAjSdrWrFNiDCOsA+LA7Bb6IG6xYl74+4ay+9Cot5eY0GaO7UJtdr75O6itVAskqD8QTSV7bhDX11YfgM+w+QJ10sGoKCWX/CX8ausIhFmhfl3LsL64gvm0wCaq/GWpIoq4AddBogiq24bM9UKXQOZbO6f16bJsqN8J/XZ92sM6s4fiB0t66kDp0DOWaXQnXlRwi1lQkICwqKypTYdUeixB20+X7KyLmazGOLrM6ww+SzFppv+27Uvn3UMG/ysnoHX1/NpZYBkmdR5s0nJV/Q4jhalKEQHsaTOLrXpG566MFyPO+FrtyIkuseJyRVbCm+fGHgfkbpYreMBc3pJOVC+bDijhV4Hd54KfwueBPL+WvMUZyRaUaByz32rcY3c7qJPSmH0ZtaZiGaMe1EaPHsb7D1nDNha7PKwlj0n4PlnHocI0kRJuu24+NLZ5zY2bsnIEANmZW0tSj9Cj03zyTdcDWv4s0KnhtqHHJzfbReVJOqdnYoQhrtaO46I4F20AiQCoEJ4hN8l2HJlgU6Ry8mjK6AkLpco3DUD3c5jFB1X1cjFJAt0SMD/m/WCQOg+844n8dSQl2u9h3eibfEiWlnfpydjU/aD3VLoO4TNCPEEqkV6k2qiSH/WBInQUnjKgFJaX5F1oAYPyOYVrt+J6Ca3bv1DpteXgwFQ8KHwj3G2Vcj+ESNBg+HpFn8Wqcq2L2sBr6XgQNwkqiisDqJeJM1Y2AEdWw0amdvPyKumN+LlalShPphXt8lR8F9poaoEe3n56ry3yoReySMsbfvahDXJB8wRCKw7flkJMpIy//7c8EmTuRN7P7XSbCf7JEWirMutSts6WAkfCP5KsoKsHqtOZwDHW20VJ0UebxEXVIp4fe+3iezSJUc5H5PnoQ3oqQOkXSRowQCautopHZHTz0eqOK70Kb8bt1rL4kF/76M1cjAl7hglG4T24632pRAsSSQ4ewARH4IPUQU9qdBcw3Lpi4gF0FnT0CPR6CTZg60xnmbKJgcsl6I9epaziMMofskuWKKwP2VEO6t0TS6FJiGCyQG9lJ/42Ss0LfzwfAu/hO/nWtGfGRvUj6+VL4CsUKQjTwB5hyp6swDPjX1V8of37OKiRocdnFSWiMmTQiiPnmosuvm3T9HowQWOMEiYtce2IQg3/ICdyOJ9PBPFZJLWfD3PmC8Rj71D8LZ8vfM0XtUqD3e7jmO6vw+/h4nZjWB/p484ELHiEuLkOxcjKdS+Tw3h/2IRO76HOr61HsAy3vnQhj5JG5cyDooQzB3IdyQHrWlNfqy+7/3MB2zYfZ7mvZjZE2ernqv0nnPwFNKUF7+zyWPrblIkxY75MuuGiVJOaQHaBosoJr5bqmJp+immlwqAP4e7Wt5Gz0/0HDuOxcAbJ+zwKkDkhn2ui+fMQhY11w/JeG0BKIWpgB27IEKt1/lfammOY+XUlMqVpeTyjOiIPrJgXgrWPMyLBV8sGhu7LLc+YK2V+BuAUZKqsmXQObQmEQBDiY4cur01bxlqRGsHk2uGiW4kG/NLj4onjU1bf8cVl6ILTWzzoW25b5ffWxXQNRoixy6LDAFZ6P+9TpApRzG1MHjVK+EZc8ysC4UVl87GthLtkVjbEAHjdHmPwZrYobngU+uRomoZT4sdXAgben+mkSRmdHs9vKyMXGHzv9NnfEiYcP95MvlC46CFFPmdwV9HQgEUUFOMDIqwdHjCFf/k4NZZ2OyzBLH9/paUKsSkb1V8l1Py6VleXQ2GoMbILSpKJAnV8s7Axqezlqllq76kEookwQY7pEOSKSkEYvOq+tc4YNGWYDi97/xn/deKhsNaxMf/biulsZp6yVRdnpR1uyC/khTz35k8vEo9XN+OYv5+c3wPy4RlR9F0x1s6e/rOQadAs+I2D0x///1/m79E6JvEmB04oihJnByuuA/5yIQa+kSazq9YDZxQDRtHitNB5gms3UvFTgHKp8GtV20W9af7ztNvc6LjfxwjXlV9Z8lHZp7gRsZjlCQP9Cpn8+vIYZdXc1/ipJoj3Ja6QMxXU7xVJD4YhXw0XrmaPzcyta8d0b0bpwoklQxM8dLHVNxjES8QMygtPWrsXvhtUD9ubpIgCqCW0ZDIgFBh3j9K5NrR2p6I/Q0yf9cQO1bh7treYCbX0dYvYgqEeQEeybn2iI/ftFPtIRLVtZx0qb0mU9Youp7k/tAfUA3Rjwlu/wb75pWUwWnwSeypcjTtZ8giyjYIcUfxaBTUl1QIf+OmjTbfTAG/UtHgdZJ/MaLzEMUOS4Vg2P3o8ieBr483ViVlMt3r5N/CUmzsEU5wiD2rbU/uS5OfZiNHmpAaAS8LOTJFF0ANh27MMps0kZ7v9KyiB7DVY2cc0EZMoHAmDcBB7QeyhOcsyBKmoWPGEC+ru3qWfyUmBv9jWozccNdkyOT1Lfma0OqI3mOOU+Hc9OnossbHqfacfhkcaXoWqBUwsraDFey75cDLKGfbT6BzYzvEwZyLt+wJ+OhdmJnTnfRAXkpq9ZY/lRpNeqfeUiQVonnGsTJyW03P84/StJsG1ybriMu2AEdfPOmvV8alp01DA3TcJdvB346YZ/zMUj876bjx27tVQaEH1s6PNmiErVdTT5+HJQZyTBv6pwb+LT/tUpcSSZ8jjOBLJG/W7lRhvKEYcVdG5OjVESU0veS+AaUrD0VRgkpAvZFs8KaViC679ruo7ORpPslXwmNTD7xaDP1R49SipYmaqWABxcrX68vVkI6et+9e6so4FrF6JlPmRmUWl/jdfodaJTCCnzk5nVqFoyoVXlRB5ymW5bbFh1C06C7XgtDi0A8obTN5Lk8xV/TtdMZAQiZmjlMxAHC4QceUD8EvREG5/7+sVGa2d1BqW3kzF7+Fy95Qs0w9ll5kye/0Tgitjhrdw41hhlIwtDTN+0qzCHweI3fMbntgOt868EHeyJmqM4TGPQv9xS4KuaqGHHQVyULi3wybWRZHG/K9CdcTNSEagm1TZfJYoifwhzWBI/YX5rs4TKe0FiJjpDavCxPpqxIyzza55SNhiQI2QrWgz80+LUYAzdY/iH2nxaNgDaXiCVgrjFHT53Fdld3m1YTwV/9tu3jApPALkDRbN3Pc4ulMR6zY2EzS2bvz0T3WeGU36zutpK7znrp2Zlf2MdJtaJxYHk0S1RhftCK195QMkuhir/USjqtKOw7Y9qfcRr0IY3M+n8AFh7f8i4uTTf9Og3XQbklD2iE3EEuiohtBoL+IU0QWQQM0CUfGFGbXiNxuBYQsDVjxjrBIAVaEx+YURr0XOz3eCdE0k+mFb4FwaZ36G3wW+2o7eMhQHNbMMcUcSpzFXF9kjd4QxDqnQ+YhvfDQrZUc5r3LyjSWqvA8GMYam2EYY7mbC69IMXLrIMgmfY5PyquHI66YeZTs8AD43SB9TC36jtlE5BNV5Hhpw0DP+T12C88zBNJXZicOJhue9iTW87BBAAB9OexaH37kNlBbIxuj6A7fGIgBfCIWfWvhL5cTf0rMTbPPAEqlNme12g0f45MW9kXvtn9Ep/SGlXhju05OzZIfaaHOJ4NChQgYf3DznxbA0CYLn95IMaEKIj+eDs789+jzVp+jUR3fXTnlaOlD7XEbU/FHtLcKhoTOsIFX7WHQbTFsi0/wxVZXHBcluDYc+OhEZJJ7dvfCMluI9MLRq59g/pvNLn/+nb0ZZ3KafRUKfRS8SGDdT5otXYzMeQWaV108LTbcXvcbx5sq9tG5lwLQrTAGJEv4zGve5pll9ZL0fiJ5lpqUOSvaXFkNknIpIa2PG7YybzTwY4qXsMr9B+cNzkBUsXW5jGCjj1vCA4F6tpfkQ6X2K18v4X7Dn+tWb6Zy44nzz7t8RKO2aaSoyYuHOFea57fOVeGj07RQHxSaSoeITVrQGhG2NsB1b/FwSF7bCci8G4bV9YCBIVNpDpzLokfJBGE5e3fqWA3oAaCGv/XmStP6ls7RA855oQ/jGSv7E+pkFUcQ3/StBMSSSpoaQdylb1GA6f/GCuVaV+Jv+I2IpUUQe0oOjU4Chjv7r2r8yvPZ6GHK2GocUUd42VVNT+Xk3PKZaQaxjiUmlR6ES5Fg7G7tDeLyxflTlZ1FKLHSZD6kn+pgIFUB0Vcdxvrae85ktAGaO1Eoi1K+YBJRq3IpJRcaXd9s6WtUfy7K+f88VPWbJ5B1g4tYWUf4n9C9hO8XyqxcPL/QAiIP913Z408KVKzIaQypk78kc9bqykz3bI4zw4Al8gueS5MdPzAznYfEnXoDUCB3tnmeT9mEew3QzuHuaeKQLSofWwZ6KJxxE1rcRY32qc9t2rQcxfKCEBb2lQBNvVzFGO6JltmCoYGpraKK0iLQm74MGmxTI/Os++Sy8ARGVcccN9bKCNrG3AEBUfvzJbjuQ+VWzmHvFEPOa2e8Hx726CUxW7RQwBHS4x1hSt93iWWbf9vetz0n+rTkw8w5BwweRZVPUF2G4KV2jIPFAcAxJrltGv7EIUlxsVfEGQNJUztEKhGH5h//o9fUIcEOgIgQOTUobyyzTyEfWOIHapiahpHLb7PmqAJJRZ4iIOKESXQr/G1PmoSWj519533wlWrmGu8h3y5ceuqlhPbgysDMX0DjHi4WA+GyIEPnxWERbPZT7fTCpIIik2yOC5Yim1jCfN8wMkslYXWkgXeSLhvqJlmllbXJOu+tfx+Mj8tDsovJ09w5HIkZrGCzbS3ZQj6kVLkEYWn1QQEbomJVmQl79FO3SjOOQzA0J4EQApgkL5xsGQbFnp8yzxpLWjO84w9+h0/uZAILDeUxS1Hy23MmewHPQJ37KROvvOpASDjt4DLh72fXsrylWT0jdUAj1hgemf2WKKKyXnRi+SLK52DUhE4qY3an2UxfTKVBB5wtEU+lT5ghriqbec0piJXBGGkHu/2QWh60vs1oGMmQnKjmg3cmqhGSJglDW8q98k19tMKGnlxKxWDSD8ajxsu/Fk3S+kkJLr2QHEilVHVZy8v6ynSL87La39qx/IaolCs/pq2YkpA8tOMR77gJ845/oN7dxINQz+Vqz0dw3dRXEcml/wnOxfAniZMozxxQGCQ6Lsq4ZDzoGf4jnKR6TmCjdBJu/sPF3UL08F8x+Qqyf7UHLM4B43KX7bCWb9G9xmtrcfLXNhyTd4Vkks4ion7KRV8Y6Y9z95Kmjad2junS+U2dFG5B27ZtylT8TTwWnrPzvDtMD2MvfXJL4YQjrf/Hoto1bDnnNAWLynQ1fMEu6DmbtLNYc+iCD1TvEBG/oHk/SMvzQmgsf/rWGqkhr4uSyFjRYOVuwXLl9l/lt6i9jC/+4CPoMFjj01xXjWefrl6tr0GRkGusEG8M57EOXb2XYebJ+bCKB8IKZ7JmL9BE5ZZzXVTl5z456KGZ186MtH0o8U90q60bEQtqYuYUuL91Mo1I/DP7dZQcib+4sk3HVEZzUMF0gXTUqufyXC34ZT6IYiVelDJes/Jk59pPfQ4wbyY7YU7pH8hvGfmWzOfgVNGznGrEMuA2Io4LGoYDFa0FLnfdHTn98T1SY0whE4Emfd00Yk8UdUt2PxT5mzCp92yab1sC19wKVH7XokSj7PAMuN5W5LoenQp2x3KxSDgUX6JvkpZ3QluFQqlaVYuE8U4k6BuUpfMLvc10nZY688yV+NGfEYMzgRTmwPXqBHyCS7pXP4NSjOnMWAsYawQqoRApDy3w0mfVJ2W7cX2bOgNNodnX8quIPbNvllm5/JlZFQfn7OxSvjFcSmWgvlYG6emNm61B6I/wXqwj/SPBol4kl04TXC+BTxH+LX3abNcrBrPk4JUbGXFR1oLIfs0G/iwIMVrJCXMmIvsONbfbW4yYVcWrBZj4WbAFkA5MyXXvFhK+XBQ+YuB1qDV6m8QDnncTrd0Jtx0l5ykSiP/XC3llP5uTbJcAC/4q/bwmOyCioKYVGv5+/TB+3dRSzhHVfiiBQ0Y7sJIayvkSgMbZWFw2aandEzgo9ZcQocliz3RkrfmrnuM3Kc5g3mL9HqHg/W9f61lCwHk1qF+7XmDX1jmGK/QR8lr27AxSfBUVE2M/XrI1I5A/ycwXpUfo1W/dfhB65lt7EhHM6F+JkXTuV/P+pQrSpX8CcRyFwUB+w9Dm8qTFghudRwn6U4ScopRw4E3/IYa1f6eM/eqrshy92bURw7YWm4wqN9YSmgECiswOSBTebRayXIVnauR6pmbNmEFYIDCZC7qbb/RikQUCTcN3ws9iujy7UCvDD+A5kwsTqcEL/SpGpCHEnubN/vQHDdbc7a0bv5xTkhskktGVaXwpFickXefFdgIQUzls9UFuhr5LuZkKoTHEDGlxOcErRv2MeJestF54wvtF82xD9oq9y35Yrq0Z9GSVYZLAWCzEk7tPC+/2DSjW4n6yAeCv8MBvGGfkYxNExTbELj/G9gO8abMY+6T4KFPaeJ1XRgghi3mjSDw3C78FhM1qHXvl3Y1xVamVa0sOnKAcFm2R3rTIRMczE1w+JE6gFYNtPYLS6NCImqn92qtJ4WcP4hw4h1iiTsTjsfMDl+c4rr/Yg+JZkTunLzpmNGyA0UwUKMd5ly9P2ptdPCzg+4pCpSVjXqEHHKTwv8qvFNtB8jtu8A6IPoxMdQOBxPZGOpbvcV2rXbQafSrRsfgAMrPv7OZF2uyGvuFfRpJa/lGl0Ou0nX/Q5j1M9nxivvXsK4m4vLqSia/I1fT23+6uJlOPLr1E4jbjylwauDevWQYXmpPYZSSzHOF3M/a7vQkX35Sg0hrA5y1YYOm+zfrjANAIRa1zWwDJJOrUrOlv/NP7lp5ztfUCu6eIcgYtUTRX314z0FdeMS/zrSYc+EYBqTUAQ74Kg2LE0Tt8bebMAH7zulzyfpj39jNKDRDjzjT3IQl0hL0NiR0BV8pZtYuuwlkb0B3aaSXnh5gplb8prj3gBXtjzdcSoSdg2g5Ub4w8LabN1adG5ZSnbGHkgeZ6CBixWVzPdLbc0Z0BgLs6icaWbVyGX+2iGmNkpiWgPZsjODa84QZ+nMFPaEoxF4KtHuet/oXdxpO2fJo+EkPya/GTWHFMEar+KqsGd8uq7jXiEl1WTLpB111Z0XWv2BtZQBZwg9rCXRQO/RGWPbunUyfasO6QcZM+EmfU76qu59SX54atxi0+1r+TA9dXZJlSuDkTbP1mgqh0NynHRolfJQynzrfd8swRdgw+QqdUvv0XhjfXq1R666uGrWtrOWJ8UquVXm5yLf5mLkN4+2+kqMmHbAKyXFszMRWmBkaTdhyTk0GgDG8DuTtAUZQjGauhA8byPmIeioAut/Iy4gM4ViXEPT4bvNeGgY6belLjjCBWk8tb9plj1PR6FVJwLOJDRKYdse/RhWyMRZHjo1x2UwCHaB1YjDfjVJzZGjvuabl+ZyaSwTcIxcP1USJvXMdqRlB+Xvt+xgyftVm9loSKSlOx/cBKjVrA8ae5vAd8CNh1MrqbNC+/Q7LlkZIdxo49D1m25agwlm/x3GijUIHoC1zfhGz31K/CXK2Lyb/ASCO4DwnaKbHBRBDEuXDoe3GChBT+Dk3vMVUCHrjFJwhbFZm9BR5/LnnFu0AsMewYr+2SsmuYMFwMhNFL5FH5d7uZyf2gn/ZbRHzz7d8cL1haP6gvdgg/z409r09M/T9skV/yg9FV3UwFg51TozGW8Wvk1AtQyHp0MJDfFKPF1zUxAx8uPZzWvWVNFfO8uxPy9VDp16UVhPkAnZLWTHkJoQ/KH3ozojG8ETLyliDPPx4kc/2uw2T8WCETc7+nHOfojv7AEHAucOEsC1dwaWaVg3YxQdSHI+6uphrXbFk4shZuAL9/0fC+B1mqtbJ1QWO5ihwVX3FukzhW2r8ZvjaBi5pm7SZMrDyvli25zgFA9Jq+JUk/7JxWSr2EdhNIj7q03MPZLWnyp+YS7MWvd5FctULyXMKdscM3WGO/wOH/4LYJZErVVYFBkbyh8CP8VYYk0ghdELxPA/Fp/oSNKXzW4JtrWgMSbgEQVcRrNAHxOA3yrMgsEWvR6Pfbd2b0HhzVayv6c5X4z7fyzAh/1S8ZNcmkofld2TlJO6uPM5WGWYdypgBtxHJVsiKjZgusviv9kW6gBzCD9M+Xta8v+wzIW7EJaIvIdWrcxcRgfpVOtCv3+crUXoRnikF9QbA/GqYweZP8URjCKIZlVAI6GgZZolYSAQ9wLPgBSgUMYBbXPXltbFnt0xGMdaA98jq27yuyFuULtE1wkp+JLClbq4drxexxVXwFuTgOcPgL1S+IeqtkPzTKapvrAad7m2qiO8mCerkg4XRxKPnQJHanw45Us/usaHWEjUB5IkFw7NmrmUCiTqV45bUlmz3+g+UQlsUOM7LeH05KbwuWseMTkuW/BSJYZn9mCOyjQh2TMQobrWuqj31Bmc3y9CxWibhHKabsEH6CHQ4445zcv/Gp78IneJf4QN+szzJDaAhn0yphtzVvaL/cEXfPParoHLME7SfYMzOzqb4AZyUhDVPJ72mmZruyFiPxisjmLFE7dWlORyIxT+Bk/A4GXvENBNyGd4b/GSi2EQQDgy8hYvTxEwwVEvHnISqcsofriiriGQLoYnTmOFTSHlbT06065/+8krOVoXjOtcEx/ZxqlKx0MzW0PCbcKM/laVpiYbBom9WJAOvbVBqsmO3iGjrlQK6f2KVAUaZB0gegkM8D7kTwHVHJ6qaoEnimIol5qpj/miaxdRC0Rws7ILgYqivQ/u16AZc9warXxgPBH9UWePYnDueIQwJ3FHaahN02YHLAumkQ+tfJr67R1uEuhFZSWnqkVZuRvH3Mv66IiTpTnnMXbVhl0dByGgM5eR1QNTRfzGYXf5Xd3WBxANcxEiCoxXvHDfp3kkZ4H+uTBK3Z2WQep94enBNbUVX6w3u/1Z0Tb1B3fW/Z1vcNAU66vayGleepvNO7t+OzJOhl9CCMoFbwQViLVMN5yoqHpsqIqg5+81CS3XqHsqWJrVLSc8GaknLcVpvN1i2NppkSXNAChi0a47f5cNcsUsCmPZWTYtdC3EbrMQqsUEFCPtNBDw4pT60gJfSY16hBA+oTTxbns87QxLeFVRQO554qX9f0gs56VvKN0v40W4oDYkskR44ADuqMDlLcFpy5B8b6kJC6zXK69i5KzoLZn4J2a6zOOrxFBOFAseNNArCEowB8DDAzd+Vj29a3N3qpC+h55ZKQTz9CH1YY2bq7PaxtPuyM3IATgbZzv3anXVT/qsKY+vAPYELqpAlzFAcOZGofZDhL8soX3e90EN5uqXqPI7rtOye0PEyAqBV+nraeMAQpJPX5wGxTFIxP/wPUTrEvRGaID3WpPp6Q6NRtNNRdAWrPrUgfjURFdBA7kDS7eII5fpFy573FXH+efAHd6PdQmusTtr+FeEjXeSfdwR0E2PfDT+4uP8euqyyOfYSFxQnB7kK/qJlyp+YfN7ig2p/wfZZsqjbtTH1+6dGYo/79FxBDAlSqh3DCrZTCetYhFFnzzsHFNiJ1sqP3NBLH34EnClT8cl7TFmpUnqgfQdSmnixqRf96xPH74P+nAGv/xbJ6Z7nrbAqyabqeERYYTqc2783NW7MAnrBSqPHWOXAHLBj9KmJxYkRklIvEwrXCPTl6pB0nFhc67JH2kqHQFiTJvk9YIKQFPF45D+a5jVZdU6waNyQLxHQJTYV7n4InN/a0yw54vm+mKyx5bEug8s5Hvti8ZweE7aj8oWu5cBunkK/HFCpjD50llXSMczGRPe585F05Q3MFDLbb2JpyKk2mC1zxdH0Md2MwOz1t0SkXFNs+Bu8ktzCOT0gE+tYxvT1SY+LBOTBB34O2maBw1lamZBPjaAXUGzu6eTY0LHqqAtV5XTjsRK8O2hpq7Rfkh7lgvCp/WZ3+JQQjOuv/6OEyzgjBX3o7CZi55iF7pgtauTMa9P6rNFLRU4M9OqSTKoCfEulf4NTzuj2AKUjvjfkCWot73x6TPdskPq/I0Z6Y8YNc6OxlXmiEJ1SdYsul5VKwyaObMO5HQIWM07uxxDaFHGqFJivxLf8mn5LVOSwWjuf5rZGlzC/IKArRWevRXBNFAF1nVL80CY/0HvJ13zDuQj7VDlOhnK56fHcDmvnR6hmio+WgwEP6tM7MaQtmGBa5MW3aEM+ROw3M1ZxmuheY4b38LEuxmfoY0AvTXsrm4JE2Exhu3h0nlpPS88LJuZVahqHtk4ZHDv8kcYAD08RC3X1B6KHQzq1Uv825dVEw4OwMv8SN/zjWGAAMTjJFrabj8EVpwlIS6OV3zZMaBBm7hg98jKb62ItpqRgawfTMmuV2vIIIHzF7R0IVVe70ygX46EsjmExxpWs7KwJeCQAZBGFTChSBvoqBIVR4hCUsV5wMkLnHM3+Dt+oi7JK0TEI44H1YmC+aswGl+zYqr1jGTm8qZoFVgbl8NlBcNtBPMvvCcMU+MJWVKAnaem+wxfVhvn9O3py/+58dHO0La7y+5dgYq99GJwZOp9LqqI5LcleSmlFrS7KLnEPhZqrP8cJumv2OyOKzX4fLQF8BV044HCphLo2/CkgwIa/tR5qhFA5VwuVZtjR6gsJBod4JGfrgVdQSMK5UiSwZL8T+13XLoyWp6uX12H2pKIkdaymUigD4M6SKP/G/XXaZXqTvJQj9zE2rG/Ywy2kB3qSq8rbnwjc5yebH2G2HCLyoixz9IeDGYyDQvCAAmXg68fYxXSlJMmlkXgzJ+8WgJAXUwHq8aNbEMx+S0nBu6jPGz2paH8deo0PaEgQvqBhfYvLEtJKobBTCxRKLuzp9gMikEgFxPT6p4YB9PJpJ3OrS3GJ1PFj/g9agJOvio+065mgiZGokrnq0n2WBZDQT+PpIDAcHcoRXs8/p9Hvi4/YEBK3gPvy3/Vk1lDLkqUXOQBOrIgkycwJmHKtcXwdcWTTlxJyAo2XNfELnN4q+FXUUt2FOj31wHXVNfPRyUnoaTmj6kXq5pKRRKf57r42B8DcnlL4L852AfmkCrxAfpriPVKW9+koILq0hjmv5pp06GXhFnDjREyTnkC6erpibu3IuG3frBcs7OxyZAlImT+kBnpoBdeX8GSXM9j/CoAv/SUcf+1V5bEx7ByvverDIEAoV4iVzNoKsv+EMmM/n/Od8N0Og6yfU5Ute+1x9octeAi5825xSfh2kjQwiz9PCAI/d1EgzlqQGA/+d/H4n4npqcgMBdAWlz/msCojlrSAob0zyhNVgQvKszNN64OpWERHKEiDlmfjNgfHpsB9o1NwbG+ajDQN8uQDV5o1cBkHbC5/Ggu2BZU1eS5OWt22dzGU9MQrdhxTQ3A5q5j12Ej+7Mz9MqyqpRVLD/pLY51u78RH88bnjESQTGBGywgRmd/FbcoTMx6DT2EO0GaFLf70i4F0YpxPk43yXH+sT90YAbHXR/bvxa6Zry7TT4ofRZLhrl7J6fYIE2zLeYmIq/fGgHAds/4dA79rXlcdtn5phia8XkWeqY2jUdGuzBiNTJiB0rpAEWGqDXBACEgSYv+bIp2j3E6ARXaVgPSglfJV0sWVSRvghIYxtxuv6kQvt0BP03ng75uW0nnGvvagBQgcbuTlhB4jxODobie9Y58d4p1AG95hCm9ZLCRvvBF+Xik+YjlrcLlI18eZ6mAX1+Y4HQ3iJG1hfm/nwWmRvdggKB3JjkpotMJSsN2SB8NJvBlBsVBZgtCR9uSTssYyJcfHLcOM+4V/rKvoU4md4z31CGgcVTQXydfOn/IUsbes08XObM+UuvwlMFgM91sOKfKsbh2/POj9XUy78WCpxIdhAqCNBmaTSwbEyb6qG17igXr+q5kt6jQkVr38Xy5ZsoBAwPgTPD0l6e8ElF6Tn8WFrvtDqGYiuSsjtF7G0/7QfzaQsKzKaPEJ15iEMS65OTaBZ1rwhmIeXqkhLWHzCRIYtGx1SElQk7HBfeGZQpJW6JoY9Tlzrx2ffEOh+/JUxIetH7Bv18EY+lA6AEAmHnf/wObbXpdXJLZk2nE6JyZd8fJHojT+c70CJlI4jVEwMoWpkaHhGWbsnxGiLyLdZpHHJU3sjcmgbN5LdoPEZzkLikmnVK8Xs3gxNyUV4p1w4wW5GhK/cjWTYzoAqTmvx3a7medUTCng4hbvPVAKHX8oFnPNz3AGYHNESK+ItQm1oPwqPKxiTfjPaCkF3rdaXdOpsbyQ88UZDOFMj8RauCIRNnRcJAD5jVa1K/U/RmhlWyhwbghZbOWmNKOENDdBnnvoe+Bq3zlxUXPwmtJZq3bnlEmIKBGPGUaeHZewNmFTLeiANv+TKkFTjXo3FEudAXlDgUF6ihLobDquJGXAQvLCn48zRkM6w+OZ5rm8VGKePoOJXK5ZcTWYdOqFPG+yOElflLQ50w0hJORwzoaSdcaOwpPcB+3D18JyERrkc5LTmBNzNprgB41cspecXl7dvlZA6Y/Mm0H+oM5juh3tRbYAthm8thq77c8N77M2+uq5QUO8ijvLANzy6LOX1s3a/L6dfasmbJU8tjkeqosTGf1oDShWiX1/1Jkf9bUIm2f5w3KGkfalNNFJ2Hc1qCt8ojCCr0DnWz9JQS//L6xoHUgtzm64V2imYM/hPoM/LrwUgWOUxy7Qck47Wkll4mV3r06cYMmfynS1OqDeg6j8QC6bP7W2Guh246mMqvUgO+hZTwXSXvcUtmvfEY4oNlQUAw++9H2ppUyLYtj6JlHaPevq5r6hArSnAtxZZfjnTamgupkAr0YAV59ArUkHTqVUuGLzyNDHop1SXMHI0q8W00K0NjXkb3ILLpI5V4HHd7PR4E6DPsBf3TMCKGkiYZXo826wVc075sprIevaKYrjRDB80D2pdpFuIAJ+4zCfmwdjgxpQZWbxDn0BdSKobKqo822ucMLONaQxkRaYmMTlP5w4OgzEWinvfLEF4HS1eqIYuNM08FqrwWmtGP4OG7LosDqaKQLoZdb18srIh7pihwSIsDZOboTonwHxzdfDnr/BveMflOXvZRSIHVV9MnHAghbEO4t3OSTtlSc+74xr6SGuxaCaaEwt7LTaUrXLugBfEqtScIPRivgCmZjhLOw8xGm0inlLC/Y6OjBkFA27+TZY1CtrO/P+LJIpcp0XMOAiHVgACO4OUS0JZXLlwQD6R61WrSvokVUmPfom817yqIDbmTM4FqtxoXhcdItpYdGzOwUaStVj0vLiBYJqB/La2/MaaWH+FYt3e7mze38DRbSdHqAOnxhF0LpqSBS7qeLmdo05TrU4sugrPT1GORJoCGSYZHD0+Le0t2nq1ocYvgNfcfv95jvpVtAlNXUK37KZm5UycPynilbKiDpKt9jQhEWdvsfthNpemI2rfl9gIlH/E+1rGyJTMdJvcx+PflqmZN15ZDoHiJp95QFzYlCwShcBTzI14pb0UD/ZzpvsgZ4KzU7kUypZutwMH1FIejbXlNB+gg+74pUnJP4twcvQ/sdPYwuScsJ4Hi2LpQG2rU5rj0ACojesoiUffIMC8B2ulggskiwmT5jrfu85Izz8s+jxW3PlcA3kLj9s2Fw3hF+eMhBowg1Z+irjJ4VLMkAJb7HUcvpgvLNaVD4QICltHFt0W5ctn4KfZoTDKGKhpVb0XgwBhSIMx3wYM1lTNM5CtFIyFLfkF0z5ajLTDJTsq5tCAeQb3MRTisUx+9p19M3pnFSXMOxM6YjUeplunzXR0V6TdKyoLp8WMIckz95XlPp0F/x5m9aqPHFhfIhan6MKTt4KYauhp0b80CIniQN+DP0UHgphtg/7R87zzXmlPvwCpQ6jX2nrU7fNbUDM7KLmys7swSYiDv3SuOT2C1ajpwL3wiBOS56QN5HGtbWSbuftb2asGqdPmBsUxh3f2HiAiveoVpnvElu/l7Oeh54/ktKO3Xj6Q9Yvz5+nUhncrGttK++4t+cBoRPcdbdqoFowHOtxpwDH83uu1yABUxzvpOzOBgr/C9uHXicvtcZDF2CIdFLEg50U2YbDK2UQvOXfNe30UXQco01Ic12Ab12tOOALot7cl6p1aXspg3ry/S8FiRN0CnHY8vcNnBQ1Kam6JrXluSNDzSycWrOqFF2sJ/xsxESp+gSFJUHKVEiUpDQqk7zumSWSociW6ogbwh0ilk7pbJcngxskzIDvnvfnPWVgRgLbTUbTYCePsU/OzpQY6Q5TIHhYfiUPIi8fbaBTQrD+D0eassA3tatTLgOZUH37dF9iWLPAijcABI4YVyYNnLT/61QLYMTOgF7XPs6KU38G1ANxKfKkSnrEAUh+A73+vYeW+TPEg8FYmtaEfkori4YTBW662ComC9ZowEWBpUJzcjoDAo12QqyhFHmbpBm/Ag2Dg4DSUL4xhxvrETa1aZqCllahobUvqpRgZHtl2DsHMla6GsPpZ69telLGAlLEp+LPpbgWcNeBcebQRvaWczTlCPn9nxImT5y4K8zy7XhEafHIMVGG2Dq1dmDjPt96zSnD0cBwN0rwqw0m5ZnwvYUiYenN1RFNAj4m/u4GAGGgIqih7fLQ7uW/iNL+BlVvnMkscDohjtviAjZ5aP1WJuRe9pd3pRDfqaooSbnSra6pu9ngRfVmiXZ+UsBCs6Qu8NoPzXZk161kIRwdjRgeI9mC/mRzXdBsxizyaXs8h2tC+Ow9cL9058w5Y4kbPAt3Dq+ll3fphpk1pA77RCc36DTNqusPB1dcV86Hj+eto5xR3VHwYteMmoM02cdCzbTJIpLfVISMrIZFDGnVsfqFtOkG93JllZC8VY+JtvySZiC7zsD61ZGKjfBbeMX1HDr1tePAzJpZTcAF08EDgS+nQCSUA3uUJ0gexhSH+mwKf3Ehb7XO/LCVIuHyJfT/YkLw+bQwDoxXnFCwlqGjFBqPgiLkKc7/rRD4/LLFewzwFwwom/IUHVCyHolbdUWp3mssKIdMP2KslFRZ9gE4T6NdZgdPeSO+LLPtn9RnnJkmN7n3V1hQpMzs9/tPGifN74klEL1SxhFR3aHOBacKXPxs94lY1oYHJcUrJ3OD6p44YRNiWVXFPfee7F4IBdbNbfj2TPJv7lPEmPEfrs2NCPihDjbLcWWDW1j4gQ5kgjukyaXqKI1aUb7oOn2B1N8yEi+zJpruMTl57eHMIp8IvKcd/4tedp+n4bUXFEWqZQyoKUy0qNadkbDqnrjc1KMjGKym6+QG6XCpVBZFrGS5t6uVo/MzLncfgEHfCDSOF5K3m+JDh2uihqm655pniDZ5I4pbn3rsrcOTUYOspdfHm5m77Z8/mPKjb2KeGB/5vAg2SsF0muCuTZ21MP/FeQzl3VazlvnQjjWBuie35i+1pMF29UajyGe8Xxxa+k5gBKZkccM2hlQxZdGU0scd5GNETiYyLapPMLqFggc+KL7vqr4J80DX8XzvbUnLNWvG/4tDuCWLXUY2pmtUCWXNAfN2mGWFpjH22qBGQudBwUd+W7dLa3RPswDV5dNyx+XYUnJO69wKvMnPHjQgVTrD5TyiJEwEaG0kug/fT/QyJkVBYzzH3tQZdoDu5DTy4DtYzhDiSOUNECajJwp/qxIX8ARAAWRhUbeZk5ImKr1dk3H1tt/mPw960IsYn5OgYq5dwcbAcsfzqmg3/Cihc/rXD/dU5stVS81p/1rgH9j7aKS0FrlwnCff1/z8TWBa53QFvXWZho9EI8vnlZzja/bKrrPyhRHq5JySbid/8L0bLS9Uk6+nyIhgmwFfODeZMAj+XSAuXH0XwUkPl68AvQpAQVPwqJxCmlVtKbryquhIvi3V7JXx7U01CYxfeezKbYKA4VFMAzn6/SUUgdUK3ntR9nCHxe3YIigiVcXVlHNKPL0OcLCwraitGtOBzUiPE3ZYPoTXkx4XH8kadi+pdBIw5wuGZPvdr+pYyhX2/B6v4AqXvhgyr3GafPwgem2/Qn1jCkHs1uBaQuNhR9LI4BN1KnDhOjpk0xpJNNSmfB8gelntuCPAtOZOUcjCuTtNCFVoSOWH0xhoKLn7OEEJjzQhts/iTOEgRMvnlo9RbcV+SMOM9W99HuznOjdG2Ax0K20ri5/f7yQUUzpg5fZeiEOjhd4NG0TmhyvWDK7lfRdZpmvZY1Qf3RJQKRCwUn8oRKqAN8BrADmF8WOTNWRtpZMjTxaPEMfwxsd9LfGmULEEQWufPazQ9WftdPyjFlXMs83PFsdduLNq3CGizFptR8eWzYxegh/rUb3k7chBOEpFojnu+VTWRYmj1oDVNQcsavWUkxv+dRSwbJRgSMjIjKC1ftc3XXRiEG6ZQNkTOSULrtr3akUlwFjNHoeexB7GsvW7SGHsRhsI11ue9s4wDnhtqf3hSdwPuBi+t2v0pjACOpDSuc05Wn2Wez5AyCXCrzly/fvgidVNGHt5iTW5GqKD8dX2p8CUMs6xLxaft1GjzotDIGPsgBtjyLgqZuZnIxS54rI1nexhR/U2874bsJ3N+Vxy6XhgVVUaxvLzK0GJITvIJAdSpEIoQYP/sBd/Rpf9aRa5TEtAai0JbuOaBuj91X2xDXDY3YpHk1cRu8sMC8tGpBWxFmEdBWw1j3IPv3zu1uQqlX9B3bvGeWpIfwOjhQkUiqjsxVS92Urr8bfPQh7JtmZ2G7U3sKNQ9Ulx7CtMhNAiLpy2rgxGH0M/Wo3PBCoK5ZQpME5T02QVCIkDgk/bf6UoVYfVdNQJfBYGOtNujR2+vKT/8EmJASXcI9yn8MAh4Uy8vt/KS/u/GEEi08mDq7F6nPz65+ypwvmn6toqx3xwmI2ThZ2kR7/PqsREjqBc8vym69JTqfEMRb+SgFZ/Tvlx19qkNC1nK8GcEReesrD8mE+P5AyM2S+3qXtFtDKCrtlUI0SPIuZnDcv8KWbzbPxqY50cST0j7lh6T/Ru+fworSNM0Ohs06HBDZnkwHbLdB+85ZT+6Em4ce23MLMy4j+uiEMeFMTwGW0E9AUaZwB5qP9zkjkfg1MxomLH4ZyuUYKNGEOxLVv7MnphoRppMQH4VJD143di7/e6QBHGItaTOTjKnX6K0p17vz+0JSB/AktUgCQYKfxkje8XEY7sJKHhrYAp1n2h+D9KyfoitNfshag7v6pehjnW0s7+Cp2H5kJqLzUzFCfeTUKC5siqaKNrOsncJKzpP6OtUw/nsFjGuhwKt/ACdo+8VWp4tQNBJh+rEq6sMIB4v65Cyr7eAeE2zbmynKgHHNCecGjmRUBxBA2yYzTZsjZUEpS3fX6MacsuphWYQc3pRJgDO8MkjUKyb4dxyi6JVXX089lYDo4N2jnNMkcAnmG8xT7BNt3Nanr745Lbv5z4i786HlaTWDvg8dEyKZfi78s58pT4L2p/s2cqagQyWXGWl3iR8e+w7+TvNbDfK0NUStrmUwDv5OKbf2ktCYT+TNmat2xKMivwaewBtAcvd0tJU3qDaNo/bXSp11sv3owPqcOyAVEEIWJn5SMwc8NmslTlDhRaTpwpR3NvbNKg7/9tTGJAm++a2r88AYNdDGQPAwU9EP2e90B2opZfjSsSX1kyKrMo+wKsJdbL7CH4po3Y1yh8AOzv9DaFNTiRH+v7OBEsP+8oVCq3htdoUug27007aP3Rspg2i/9VkULnAqN77WZ8eksAqiQwutUCu/PKezQXaAx7Ica/xQBM/OLOrdrKxX9TOyleblw1TeEo0ApY4MHbxdGZOxFkvoBP9UaYwn5LxyJuEdABEgPKHpRYZ9eYrweDJCSFdU8JXr5i/OifnCrDWXRPs1kGjyuywrUAs//xG5AYhvCK3jOgJLRNhYkPk0sv1oKO6LM4XiQ+I55XV4uP08xQvDchwLSOMYx6OGSdi2grQnFmcCN5nWF7qpNXLGlNGD+PLe6DEOhLTj7PEV+QAVJ8pf1TH+aUxfAfCo/QGBORgpVq94AIa/ZHKPb30WsFYYvo2bulyioyzPiDfL+KXeu+D0nF2BUdBqapIHPRyH3UMUL+hbGu5SVBP/JVuY8if/Ss7m8kMn4V+PZkiyAIdARkaZ771G8PUp2lTmmY8qKnGszz3os4QOblcbOSKAfFneq7t5XeazPV8GOaj51v73ptmZFl0gO/pjp42UN/vnuqaD8jiJ8ny4s7zM6a1wdUe8vZsr+XL8dnvV2slKrXPcftepep/uYbJP2eDVweqPDtH2VAPicdChojso/wnnGbhFoJrmdC9ZhKxV2RUG5TSPwWoWtafGjR3ZVn3jzFweW2DZKJZxCQuAK45e/+ZKGluO97f7xQArpLazjENnthwgdch3XnJSZNioEkHkI5RfCCHVRAqJ4MHgDxqHGQC4AX8UJC4vPv44N9Na0T7Rx1a0hWy3ikQ/7ASN/dFAdW6B/A0OoWDLizuxCXJrlhGcx6/DqF1xWMnMz2/zjnOW+75WAsIUP9ejY8wzXt2fWugZeac/KJdm41G7wtAUjgIHHeUNCATZaUxIVfbt/YTnNhjLHWwr/flnA/zNJRhHVm0jfAEWQAsfOrzvMDaNG7U/8rCnmXu+v55Oiq/TvJbCYuQEQbrzSnS9M4dhL4dHBGeAU/7LJXsY4sTfVqeb66/YjBPbZ/2W4bxY4HefCKKYMpkL1lFgrv1uw/s+dzlG44NQ2aE4v+V3RKHnMBHeHUEFjdsNUlIyUt2oqvuaWqeCR2bmgLiDbaLznFlQvVWOaZ4eizJd4b+g5cI1EqaKwP3Rux0FGyQCuB78vyn1OaufQznaIt0w4B7BcyG0oxBEUbVhmGAGEQ3j+UzlbfTZhQRHNnw46iS0yn4wiI7GfugXQ3YojoUXCXP06+S6TLVnFB6/E2whhKUvQRI94HELRKXgfQQNX8l081L+SH7crbnApbg3V7ttmHrpfbO3pjLUKX72KT7xT+NwC9HgvPx9HwLpNVUqYDOniaU5THe2Z5pwFwiJ/bc1gJzf8cqII13l85jDIJlsJJhPR0bCrpskqCbjKjVJzHnsZ5EgbpxN6NQ1rn7Y+p9prgBJDUMIcGagsyyxtZfTjv7dSSiHKZNoAGRWkWFsD17CsyOEIUbtTqgP1biFY2ZlQjbMDYwCeYt+8ABvF6idNfZMy3yhJOa2isikTQ3KfliwpW1MByTn1HQJpflpbkOxRkFyQTHNrYEPztQ/cRce30LR6Rxb1CTKyLFlsmNW7QUIRJLDsoqcW1OZGMGcZYqkcKz3bUmwfFvpnQwmkdo9l7ddI0zACmuTBmX4KKtPhTPuNHG5CcGuvWvwxFeh5M1EhW11XLfRU+kQxrGbDj3EBwSXetFTkY3/wmIAIsc+wZ6HvzbX+WJxOX51YJ3D+6OahPuud4J4pX/xA3U7zWlCIBMOipzdWh3m1K6ajMXZVg2WFQPeOL2VXBN1jBZnbj03FY416NUeBKc4UINKJGeMndWGDpt5MweBzJl4yD9TOtCVKaWQH8TYZjue4/X56OOXBY2ghDFQfdDnu+TsP4JZtJNSOyy+cx91TiJ0ceKaUXkB6l4og8iwG8Dxr+LIEUf1igEl864s4y1mix2sn7K+Xh4r/5ljpG+UXQFi24C7tCMJ07LAZweYZnR9Ug9Jh3xNepAI3xb44Kbl45LKDrwWwX8mizozbEqrfypAgg/vNB/diT1bODXLaP97VpyJ8eRJH0ehhZ0AwubEiKCAy/6lvfaimfJ4lqsINtxw7sajA/xM4qQ7jlgJbZVA+yJd2lhoNhYbg4bWLKhPnaAPs7lPqqUgQhQ8dLosSfZ4cTXKKFjapjXMExxpx4KFhw16/hM0ZFl5bNcJH4TsAKzHU8RP3/Qqz2LcaNFs8lP1MXPKrgKrjKiLNF44m9ksLRGWJwWC8aV1cMO9J4UMGnr8PMMgYw/2rfyl+CPl49vm9fDXmn/hvW95yWCLpSo44hcsfyHv8/wEcY6z4RnxLWhs/ITXjvpZk0ljdLwiWqkYt7ir42DOk3J5md8PJ37+uU+nLqhsbvGAQi99yYXC38h6rG1JgRiSogDLz93xffYguxxkSJ8IOz2dXEgKoE76VOQNCetU1utxcGmIosmhJSu/QhfP6cQ+mmXZ9r3dsaEpQKYzLVmiAqFniSkdHbZRZhzPqLlXltBpZCuqyd29e8bQwYTRNGvoibtaiURMu4o5gURuqgu9/rWAN8TRsW41ucn7QZpTJwt5TtfUN5MREnT169Zl6jB/36QektbABdCGepx04kcrXjcXzhKEhpP0ozjlT9h8PTF7oH+0Ezg6NqxUks0HJ7/GpwXAUPOO04Rzzb4pxn2qyWBGU6dC5SpGdYvQiaY+LhsEHcF4Vgs9EknE1T6aQd//wSlCCUx5Cx2EHdnk5KUbP5Gh4f8BKppOaYltLMcjcFVi6SgZhPFVz9ur9V7fJQusf6VKsBo6iEh9izfr3SZO/i5hu/+2Cjs87TWvI6jSwAAPK3ZL13D9H1rYBeGQXK45WkcSKkGUJfc4nYXxSkjQ1doHVKr3HajklXN67OrQhNn8LtWFXGaXPqfeiF8d0sVpftL/q5yN68lxzsTpJU/oYjNN9kNDex+QFPs+MD+VsCx2QCpMprsc+wGwd+rgimUIYPW/yoK169+hILGvcLUImuV8lH9dyEeIf/plv6xelfn3FxHx+odb1w1EMfMT4fFxHE0owxBC1JGz8GMhZFks2qhlGqUMeTYNY4x+/norzL8s2emb0eSBiY5Ic6Umpyc6apMSFC8UYoGouL7+NYyJkVOPl7Mbl/HHGkV9CgHA2yPQGT3zE79+LsBAeDptf5xAHUZgQFrNdzmb3dWPAaTU6KLyR50JDVLDDpdhDBipMdQmmshagLx22zaiqLLywnu9oKCvK+ZFhrr6L7yAZbQTyW3mlx2Qb8oaV0bNjyx/DFpNOOL5pJJxJikO2S1dmT2QfhCEm66Xr8krc78WJERsgEDqCkpD2cHW6XEcrQvp5jykGyA1t08DyDIua1b7n37vZC1BNIFYxJM6gX9AbXP1SbozAifFo9AGzdr95vIm6ZpbT7LiUjJwQwDPnOu4AGfO6qwxHcCNRlzwVpJu3+57JAZJ4qQTBZoYtrHt2F4eh67ZHyFqa75jYxcckjtXyHxPQvg3H+cxNVsNfdNI/KqRgDRXjyJYDqfVO60C3RldLMpTeQUzbpIj3U4qyJub+8Tzd3CyuYPZ0bmngt6TuuNFHOQBHTyL5CYlHtgxwzzFdu1ZkWI/FyV9vezOOlg3q9kLFnb05uIPAEvQ5b1SVUSMfpeGT6gshrhRxa9+DNOhYat6HRCKSgj+eAayZyOCLElnY10fRL/ZnfNsCACc3awLVEtAftijheNfBDJaijssu1C+pyPG8yILqMlfx4LetDVPif/ofV86Fvt1WEB7s+H7yFCiiHjp2OHWoD6C5AX/pUQakyZUVk5jXvl+hmQBVnM9nzupwmhl9VC0FrYCah1xfyn9vjPDH3lkQmkPTgvlxt9M14cmIVSwRNb/LFaDvUcRFRAxPQUHeDyv8yUs1PW5FTK9WWLX5UXJUd2S4m/6FIZ2l5QYrtSQqsv2SrHI0EmLxHFLMoCYHj43cXdvdNYtf5rBmTVor23gatXdvTREIQysK3jthzpusaRKUSnmOuK2lWxY4TjECuDgYqwjehyui9kI+YJzoL8YVt5Si+kpo1MxT1NK0hynXjXd16cLJk+oJhgDn/GWZC6HhwbkiEy6/h8mgE0LT51slodzwhAbgQ61EOa01y7sJlKLP3bTZrRVPW+sxUPjpG5siE6owbGzQjFPKMKaRjZtLw/nGIwU7WtZ6ovw4PQiQQqW5FPwHvxTpF3jWDeLk7dZ0Y+JWobb/Yv3DXGvahw38FLUnwhXd/OKUUYOF18uwjikX2O6gcubnWgrgCHQChWrqwteSrmJ9GZ+PTrouE7lsC32bvE7p8C6bm4+ejO7198QDUvFfgjdLoW3+yPP+GpYXk92EtSkl0JYXsCaM/2BrNI65QeeDQyCTLhxxe7bsc3/yk8RFCrENSf7KxCGrxgHNs1ol1lM9vSS0QkvnZaGzvMUxSDmkBS+l+E+XTXfG48/W54Y3b7rmKI79HSxXdnlgbbPUTfzBwjkyZVvS0TDL6mx4AvNKV8/poG33qs2rzzn/uVlxuCzvRHg0z4Phlul9TD2PnnfU8kNYBDUphapYOIFWa2h68fUfVP1aZwnLU7l8dbLfXnD9fZvpkL9+Cqr8CqWIV7PbhJ+aXiye8MvqBbKpR+38i72EKmU48d0p6vkAUCjVNKkd9kSWDIe+wcWebkBnzfMOQW741K8qijJFIqmSEBI4M83vQsg1Kxz/y6FIR5PVtK5vVuTAGAH2yYrlLVzOgTXfNXWgRLam3nUIFw0gs5Tmu3MY5m19dNVszTb7raWHxkrT3rmoOTZfjPZfi46VWWORRG9B6/4DhF+4d+E7SycsWy6os8BrBFvJBelvOElRnVLldc7TP9Ba7bp1SidJjxyUaicDjDD/jSJOgTRw3R9m/rsIaWLA8xDZnVrKPJL9SRwHbv4KWZNcXS4Ox1TleDrsCRQlgTxuOgm/X/oun/ugPUmsP9jQ5CRo/dDsnVmB0hU7BugWbvadFwqg9Jeznh4XUhkf2Hv4FhgFC2blWDfUUTYBvSBRbSeRLh+n5yCh2B8xNGH69S5KLufvxhqIvkwTBGHjr/0Z/Lc8gNM1Q7JvIQzVLK7r3e/jkPNEZW2yXOt7aSTpxc4Q+TEPjLdCXRFvhzE1xPOtIzl0Hz+xW06vuwF2s3/QZg2rV4zegSsE1jINdhx89CjpoujwbxE/l3s7yF1tk7efDBtuSw13ElFInreeC9aHMBf38Q6o3wCq9+rOBgFbrYd8xv9NC6o+KiOMDial1cUkv1HN2d4qx5654z/IGrulHh2KikPfwHV/n0joazSQw6l/KXup3PbiXnhDBXRxG512WKzWNq10ttK0CqTvh1ZAmjs944aIMr8/Aa3ZorFgLAO+oKgVcxou/SbL9+N6GoKu7C3j738+yWBnXTR3NdCQKgBkdZWwUi0fG2XceYiGAL+51ymDd1kNcAbrIymQMVvs9I+c2WqWsga4+91QgWETPDElJiD7R7Kwj7vSWDJLYFqLN+R8O2QW0KjDE7jZcsTF9erI9xKkp1SNefRMxmgfOv1WQ6T3cuhM8C0w024vIAnVcirz+/NeYqDkqFzwkh08znQxWTmA9bhd0Gzaj0TkFy+hPNKg45fRMWb8VWLmgu00ngprAE36dfATSEeqFRlYO5F7eri28xqPM59VyDOTjsEU7OVXHFdEhEcZz76SfDmcqY4sM5+Sue8CVu4vhOljitOZhpKW1Fxq/93wRCzvOG+Q797ysj1imb8Ft87dNdeVpG/7WxNaId3A7YWBqs/SuE02wyetB/BhXnfMRYgsqWtnxQNIGdEsXdBKez8sM28cxobPaETA/G00Cu62qN6FiLbFZ69+9XzvxT3G2gzJN4YVsVbeW7abQ/2z8FOC5Z00BFwIOqjY1V3QvNLbLTu9xCfNbTXUQlm5pn2MuYpHBdZWyctvDZxGMTQXH2rXbiVCeG0kNkoruBOPbPmazdzOlK55pvVLYhS1qT9X5jqy+X0JO5Dpx5OjyzHXIj4eXb1kExPG7vHUF/GgbnIYRDQkR6vfbV9db9SWtjRxsX7ZUV7IAqroWalckNUJ38hz8RY+Bw+2qBCUAKNO46xLLIXoIARGIobjA8NYG3Roq1b0ycqNJMOppeFrgB7oilvr5vtI+DNhzYw0HfA9ODx6zr6x+tzyY4IsRtCiNSOitt01a/LTkddZefBX+bEZ9MB/rJTjNgcc1nafIZ18yGPdHMOlCIK/bmXQ5Xh74xuA8HBfsy4SGLRBpnq4EWlPLZIsvPLtwXGYGaf7Tem2YMSH4rAtV7fXDiQgBTgJK+TVdngi41F/kgfR1uv8OZW6o42CMPVyqUWaq8/XsGS8m3Is6kkoRnf3wHOF6W8Ir+BN4Oh/wigsRAFXc5zycuk+urrOn7IuF7EH9gNx+b7pewHuzQKDhq2lHMfq6PKAP4Rn4nhIibaKPpP8qvnlO3/2pxA87iXa9V2dgURNwaaz/0APfhbHwhf5e7yTZFC3YU9uQa+UqC3XVfNBlFBZx9GLrV6mNQrOWuxJs2BxGmTo2mdzP7BoSFyaTLbcaB8s4yCP6WiWwAqOB/zVTi+b4kCJq//6tzsMWHBitTu8yNdnB73YQV0671f7ORVdTFGbfmMcag4jsjQzUQlO39B62Ombii1SVxqbblWQD27NE7RKHhlixZV9V+PcfGvfw3o6nPl2gq2BcHt1Eg3SSZUIjDM0bvAyIZwbBD59IGSPtKARhOuzrVmAOHe4eIeIJZRn9BRLuJQVDSRKhZarZkJGYodM8tDg02ECJRhGFteABp4Q6pu76Ud6g3Rd1VS0ChKNN/jCXTWsDiiNyZngvwjh1VgkDiGr6bfKB7leyrro7dsR80ttR/KYvcfpoNVi+lQoiYrbB9Ac0qAnMVgorCgGzKIQgHRXhwufpWSKYJkdp82NxSANHNZx6J//Z3RPUWd0Ny9p3eq/U4cdU9knW7CC8YuxCt/pcBcSGZXV6el8jr7mtOB9gv03zfV4Gn17udOIaolZg4jm2TTLUxHjd7l44ItvtPbjJNGXyQiw4rYyKkdetKSCiK+gBashg2knnRba9ufN0x2XkdXPRMrwF+ro6f8VK22KqJ/S3YmVQfydRZ8UHGLmj3tQYTUjXROAxAsWxKuXCKH2nRggHfIVmOy1WoEpDun9OwRJYB6z67S6gJ58iVGMzW8dbbNNbT8ONmeE28bBWSYrE/pILBMOoqTO6/Ve2V9U68uMLCFnq8Hpthb6E7pQojFm53SxkyV+/FtBDeMUEcQUlnXnV898zHZe49oNpt4GI0TfzggCjkZ0JSc6BrImDyJ7nTa72xDNpwSNFajp6ujIDPwHTKe5GGvz9ekDq+/FrFrK3j5/nXDcJIQpx8A2BicBuaOY3FpqRgOq/TsV2n4X5rtUdf5g8Ze5QcV5bIHe+FbSNKjLMXqlxYN1LeTWfI7XOLJY3yyNPJqmgSK0zGfhrWuWlqg60Xwx94vxYRx9+0QaIoMFFg65Ae+fOx9wwInj4pRW4wgiUZJ8hBczJsvepJ9WjYHY1+3LxJuwPegq2Q/l7WJUDuhaTHmHnkadPvQ1PDG1wSCK7zWsNVq0d+G8EgWp9FDV5jJTRBfxmZWkgR0iH5z8MDtj0YWs9/MbIxctQv089KZd2rWXYkj1UiBfwJAsmGhBJkah2zuDWVonPA7dADxpBcJLXbZqoZJhX5sjN2D9Dq83Bql5Q4GVC9V9aErRCaO1FyzQ+Uu7p2E+/hD2cJwjI9J78zigTfIATaoCUpatZn42nGZ5JJA/CRXZtQBocRSlX4dBMNq/YGIvMzkz1rY5GpDOlJEdGTwFR6rHEjlD0RhgcFaIjqgqlBOA7PMn2b/Y5y0T1Z/QLSs9evh6I1dm+620hFspJGDeAdHJHMEg8IDsYxvmuahPE7PgUdArXmFnSvqrMOBtNT3FffSPIe3UZGZrECOHmfor7K0RDi3hM4iF/jQTsV2dUnRdZ9Ltla8J9D0cosy35ZFHJLdSr+BQfEXwj4ENBoJWSSJ3lxTCHkPHp4Xqlm1kwBqXBV+S1Egeyvi0qmjOh4gbSXFVqCOk5F7x0R4Afsq55r6XZuWqQg+UITIosnIBdoWgxbAPXN2t7N+KSn5+WrrzOG83sji7xRWIE9tGxKVp7k11kjh/EhG0V19UP3VcmvX9Bux2rILYQMrTciM00g0VfHBxanhLx9ilBBKWF/NjeI23qkfSX9CtiOAphCEFkXu68ZXq2eVUgpZVOyF8y1o78yDB2KFd3Z3SdPr48bxkA/uEzBLKcS+u4AnDb5R7O8WmNNnlTm0hbmhFXw7utpx3AcyxiNG0k87GNEba/F7ETEifzZEfCjDGRZXmM2TCEoLfa2SBnpBBDR5tiAOKfCzFn3YewcCSnGyC40M5Att/9Ummsluad4ReXxHyGY+D6vRFuHQ6RXvEFXWW76EWxdnJG8zIPtu2Ca/celX9+fIOm/gPsEFc6RzKFwNjeE5rxY4hT48olH1ZhnDCSGapkDSUe7gV2XWoAwY0W/WgnIpO4mrNKRY2lN1wT8e6+Pn/vy5d7bVXWSTqX85r3QG5fvKMwvxayutADd0RdPAabIYtzxlvqPjsLLjhiSGDDzyY2UV/6OGtyM7argn985TkMYClUcr+JBfwCmifZJXJI/BgZJ+X7EivRVj/3CjP0VBFfPuI694FG595MptZ+TvKeSWEoz/uedr6ozVSPi7Rgk4+oz//ZIJyagQ3u4xeCZ5bRoF0cDjl8C9v7SzW2b7NSgXAYp4Yxo6wmanp7p6RL7M6Hz3vBl+oElFa3g8Gb8emgYSYlnn5FoaflpM/b9nbjffh1OApKorY9S5xGdNCN+RfLHtTz2JS+Fj9ejdNz+RStCvouwFZiYlV54A6aLWDuihAwMdVXi15oxXzozrXy6AP/M7MatDC6sKB94/HAoxtkt3METwZlk2Ed7NK6tQfPhZP+fdPNDbGzkMapCeqYBF9E7kb8Tl2CqTMJ+zGNAb9NMJlYESYGaLxrt/GRqADZ6urjdXJ+3bsHc7bVuu3LjWdOB9vbF0jw17HS27vy1OQEvpFlefUMsXdEqjLaSRIBJwpSIdUnCRJ2xdSbTPptrtS/zUWiOTH0I2/WNMBhtDGFu50K8KdRKvumMJEQCWWzK4tNblG6+FXozG67dNV6JzvIVzCt7yH1ZetS7K34Jnn0oPNvnT+KH21P1XXpbhompGIf/GkRFymUFpbnyKH0BxLtJaCNp5ukVFQhxpT1rxuEsECmqEokTUvJZqLnZzW5YtOSy7AQlF1/DKToFw4d17iyxYnMEgNhfdo/Rta4saR03kbaWlc+4oCiCzqQLBBjpVWIs4m9XO2pEPZbQwoSpsnHbFy+nFAkj+Sz/qCj4QKC7jhZ9vfGBH+qOnuhzkjNUFzleGTgpfUxfjlH50UFJb76I7G5gfzjnrJegCRp2K9D9Jey5DoQSV10wMPlNU5zhNUBab0BUPZwxs4qUE9Ho/HapVurGhtdueGgLb45qyNzOeUuwrYRTiAf1fbrMA37LrWtb8RMkWE65b4bXxLZbMlH0DIcX8sLSZyOYSCF13JznxfC3b84bvfbtw94UPqbbyyfC7YMe8a/n3C9xZHjAW2wJyeKUqkMj1SU9hQz5JOBgT+3YHAW/q/jb0bPCtozoZf7bluOKUUw4zLErjsPs1a88EbEmUD55fiivckJeOBx1Nh5pkVZjyfdiJPTqf86evYHXSlNRTBVlI3YQC2H1UmoG0c3n5pC73UI5zeEK5iGZZinLX2E20bXFx8b6rs4djPC4ePxH2nlepDY8yRPTw3pWojbreO7yMw/SdquwzIjEzjA2oBklYaOaa0dVlBCQCO9H0lsVt/5YY3qGC0CC6qtHdaU77iFli994H8cl3OmjSY0GPNhJQaiASvhPTdr6uW6Dq/OraZ/5gsU2X3KMV3RY6nOQzlcaCfTnbKMJA2ay1arDjA/vd4YhhzOJ9SLqhBX3Q0ca1Rn7oO1uNLaEOC8B95qkcXFnYewAlBt8CZnICrF1Dkor9gWYaewfLhtrWsZT+k8+3K2C0dTCdUWinrJkhmB1BNq9apsjm5pYLXZjDYz4GF3joES7Kbjpkd1RYlNkwXtL5Qx8nyjL1XUeDfjMYwQeX5d1aOQU8bmXnW1Dp4zNL1W2EEhqB4L5TrvpxZfgFincmMIwZ8VJ1I04jw5ehmUXQAOYjxh99jrZzTn7/hyVvxmH4ZpD9+RQ3QIA+bsinGlvFC2/1aLIJjLLEmk/akjH4vze9LFQu8ONIhnIqs/K3lR5RbACNZZCI2eKZTdzTohvLKC0ddPVpSjYWoEZw77LgsastmibY8BHFgHEOXf3i7SrOq7rXYndsYrS+JQvBiF4O5s3odx2jFoeDmsu5dZRTJI95KVu4cOWukX5QggwXaw7yZzyC6eE6KGCdVMUy9Pe2ENp94KOdCcM3iSaAT+RMOTmVrgVIflfLchn7+/VG7rwbQkOtsMr79MKaMCpGd2j5yn/2eeq596zr32PPruxwGsFLlIAALN794ozK7D06aLl47sd4voDUZmIYlVP9qY7ekjZmivSLN/8AQhM2iUB7NnStl+rMZQnG8jwb5Xs8jGFrf9B9LJRbkkah6BXZ1naM6s0WzzpScEoe4o5QwirJwG4Vixe7cr+yIZyq943xBt74CT5rc3pSBxJ/5PubOKJ5TaLUbKhLSQCpaoMLzNllyQSD1qJvLhYem+72loPmlhHspXnviiExUcXJGLjc576ZAe6DfdMTlDQjeOzTJAQNqwURfTEBs9p/heCOt4K+i4C5RfvsKOpMkXe+/q1YnaGAOepnqmc36vGY4OsG4p2PKpmuoNZxY3kkIX6i0ArhEoImoWp9VBqUShTmvu9tD1xw6RnFeiiOuVR5M+ixaVeMUB01H1esS5tjRngGfwdRq8NGyf8x/Awrt7jXc+Jy2pQ3SVhXqSf3zTINiv063ial7C4cMWO5aeyDMCPP5jh4o+BGDCsXFI+RvHP4Ko9b2lhqUh88n+KDAk5T5ho3csFUMpu6apNP98pRx+jKNnzrVREuWRZeV4tnrEb4dAS36FDF7nE+S08OO6lmyA1mKKdOkN3N+v1uKkqmLrVCAanpwHj+e5U/YptZ5IvzC94FggYw6Yfg1YjC+tqVPVyIt6BGmxjNZbNOOznuRcVy2xtzUQnbxWNnl3ZxW/T67BGYXq/4OHUyyaBXUORtrWMLsEdyNzHq4CWJMAIsCEaZ2abWD9kXIOF021ZvAEcRShm4HTpJogWtkhjPMr+qNZXcljwE7OzpYDTUB83uxipw9NnOYe0/TQREAJ8SThrbKQYCQNcHpKInI920ZuS1o+I6HX5oEoNESNYOmmuXxXlLhi6Ow3lL5T+5y2/qZroFqVyNrzxPHa5g1WtkIyrfPhNq42vJGurFIQm9MX1QrdKjJyhjatuWXhTeHQThGsNpL2dIRniJciYzq8aFuCZt9Cn0e+hEdfyRAKL3Q6HncYkdJO9rot3KZSuh7E/u7G6QcidE0YiWGbzFwAg4wxmYPIPllT7e8huY3L3MQgyw1u/Do5d/exlBstIEzG9eHKXM7BZcGDKSXTZFbX/5iTsmWgPYzCsZdLz4DuyODDebqzzdC1009wVuxO8kDbsLZc09avdU2PiWIhdsdTUBsmAXzVdMCP4G9lGJsIRWSZ7/DbTNiEc2IiHnjAsC89ARaDc6W6Rd8+6kYg6UTD0uN4vpLsdl4NhHLAmoh+LPi5tGyae0fq7puitRDQgJCaUDqiwthNvu9O2fEGwgTqaDhrSM70GoXEPHAUDy7/APM56laTuRpDvxa81SgYjmKJfd3Q91gTq/+ZtLG2I5pphx8E0xYoRWoFSetFywEqs7npYILoOfru++s8zNzlb4FVS7I/TyEUmgeI1s71kJWBjbyKK1xc8RUsmKKqCTpAzyCIcud8a4tChJohRrEJ9b51AsaVsZKhpzcUwgcoT9TkrwGC6qlINzlGKBEbji32HKFg9krSZneqNA316Z7GHRYVluTN6hNReHwUuDGBG+mdNzkPEGE1Ex3rDuwEDkm9dIf7QHTqxBSEGxDSFF7ed7VhrDe8e8hddhIku5cNPuJFtQl2drQ9KFUjDm9FVBe4llB84PIDYIYp+VLn8hdJN7SqUC6DEtArAixtg8S5GYkOdDI9Qixz0F4kabXQ2LVVN6W8Ra2Q0XTAtnQLBBgGvqxRdrBRq0pP+lzLeiLWcH/GjV6CFchjlASJesofH9uOP8JzYhIK0R2N6igXwPsVTxEczrm1xOSNQXDk4a9yKDkJxOMtn2l5K4MN09GY11tRjh75R8wJAF/9kxyCGTeYsZ2lUoZMiuaIcRlFTo5iHlHL7mBJa0St5escJAwLGa6xQ2rB9X7TPw5Rkluev6XPyFgXyOCIh9bzymaJ2QHc14+KyPZfHt7MOfwNrQp3I6Yk+GcCJvNh2mLnghPm7SaD5xG5QkSoDwK5LHVTNviT+a/uX2c4RYyKc38SyAmbtD3ysThaQIPBrrwA/K2kx3Z17Hsgxr51pbvsApglmB/MCBjNY1ncfJL6A1zDUap2EZOZ+L5Z9nvP+1Terpn25Ve+a0Gt5NXO+CfF4OibOVvH65P20O+Ol//F9wliukHt0D7/olsnH2/+qZ98V+k6d9+I/nLqCIMPz5/vYBCMB+RnkoRpqi3eP5jP/H56lkQQP24pyDFFJw/U5LwhXuEo3GDDWm29u+foX26RyWBuryl0x544BFy9COQRiJ6ngSlkQXSYflIMZt75iTxaI7oDgtpgr2gC96iamjABbHa/Xpoa+de5ZKoHs79uVOYzkLDb01ZnJEhAXvJ8jlJ/YyICsL/l+VvNgdw5Kr/Uv7AKFQcGq1S9GGcDEC/l3wN7MkIbACFMGX3ej4NggNM8uoyWvhuCy4gHr0RT02CefBsx35XXedSYeeBjS2lmQbW5dH3YZgA3WI3n2wgMKUpqqXW1rWoxcY9HVwTnzSfhd54iHRs5actaNPLtIHaBRngbzaw2OaXohcIWFcvN8+ixaMPrq8kZNgUPdNkAH69YQNT6jGlXsWsQGaKa8nMXQwaFihD+SQyldNLlePd2dKZN1vuKpX0KY4ke9vWMyBhPwwZGDNxG8O3y6r6ZggZgiM2sDOdMzUnSqIkMFVw3/7ES1F5wnpMQ7ME9WhIRZszttHw3i/kBGE4RWeaYOD0Vwu/HsK97DitxxzWklojsWreT9peqVatNx1dWSGspqdx9H6YHH27QN+AV3XXydm0P+BX8gQfUEGGdAiF4zJ+2WqcZrzG1+lqm/7GfvYw9PTbbLSO/l3LITXdlVdo2Dd13RacGPJYlVbainyPkMcq/GeJyQFtfgZQs0I3y1qPnn3+tyBdYHM3Xmp7Fhf0Nc0AGhrJUIfQgDFycRwGROK+8V+YvHwCNdYoISTLJNECJlQ3rjXzTX1e11g7Pk9h4oWT17xPIzg9Uizna5RR6zu/DL3eFGEtKASy9MOuKUgnwsfQc8Fdhqy8AkbLYKYQq424alZ7+RmIi2GCVztFGgXYuUctMYXQwgdCugRuMhdIJxRwADbao79Y8DlQZTPF0weU23vkZ3fcuf/HpbNr591pchuKyMXIXszwPcXvUgcy/yrcGgFAVKU4auLoeCB+DmanvXjQat3/wryduT7Jmng+ntT8K3g7leFYtBWw+SDBD0bIpopdMkErwhytIzDQ0DrfR2+WcY/zf2NtUcLIhgAwU+ycV6LVyw6l3TGz0Kr8fQ+SuFJ0I93zJxKx+rfFd2AExkNVPnPW4hl+2YHTo3TWmy6vLiIKnQvH+1P7uuOvpksz5PfgJ04mLdxedB9YCh0quKZb+nNnBUuSAnO09uwsMkKJWjxUQP6FzR1jvC+Sz7PzFOqe1tKHoHVNQDu+6Pj58pufwAbdURK6Q6VLpK6nG3VyW5JOWSb8xKAVCBLsRXEgPvtom1a3VnyKhwJAmVVwhzzbe2OvSn1khaKScIpUCqD8gt8EC6xKw5gPvRMmKawsNO4WHd2XYxTSSljSWXVF/kHFWZdMr0R49VledRL9ZmAKBC68kASdFozjQISHhBJesmRJEcKHCdh8jrIOkDtXMrwF1JDCeJxA41QU+3Ott4komFZNYmiC+qo5YOkWVr0MjFJrzptLk6mEZZaevtTABufmyTDR6LYpNxd9LTRkjtf3WOZu0FiWz6/MLIK9MkkDQ/mhUV1SZS+EYRJwSuManNmM79KvuF6aKwPCQDT0AASjFZd8R0Rp8gg+IDoG2g/FT03yFqIV3Q68+W3rqlzYAdJm8DXCcP9cC9E3E+LrRv9s45SPD4SWTMhVP0/+cUcqaRodeYB710ASW0WiWdqKa1DBpg/TDPNzExaDLSmskzvCDaJDwZb8U2ZnVNLf4ZqFhLouNje/QAlPhaUw9QnP5jzKnLooZcjvTgnbGXnft22JOk5IfyD+TKuKuc66dxhEK/DpZMC+FDABGK1XvDAGqnzKLDi7W8mweK0rB0B91gGftDzsM/hBph8iFw6sWtmJ2ADXUsnwie9KR15+rsxl75ZdaUQFhbc0F8fQioNxGdFPY+Pc16fefuxrCR+SjMclEUfE29I2/Z9L3ZxTislwBRtiodHBhCoD74gmWMAnod2rTK6+U9J6/sCUPcd6UOLdDkElBOUdwkqhWs8RcbpJszroPNn1PPwjXVv+T76UHwQx2AVJTxI0mrhIt5Vop3Qs+l3M2/64cNJtM78W+Fha+g8TPPeTwPPsvR8yhIPInBYwb7gVqguaSOJ4Ahf/dVtZP1lMrjvS1J5dTIhENBMg7zqOkRiO7EiYa3hPMM8INEb2kCnaco1imcyHuuAYKA34Ns42PIbBO4Nmd7WaxWo1zzMMP3AYX6otijuSJefNtcEkd9vZHq8TM9WYsrW1x4TgOfe+Zce0wGBGYBL3NXwkPmlplUEn02zi0+qTU/q1T4GnmzSY1l439JzNUowauwGgQVSPdxO8Mso3Heo+or+AX0tKrwBPUt5K9tgznPrDa+IFtYwtkYvr8UBXr0gCuiyufWvwLnFovXw0i09F4LN0nHZ7vfzqePZm3cu4c6LVzYOcOXYmIHNPxNZicyu+fiSxEAC0YsSUhqX8c5Vj/kRqTt4h0UDgIFyrCYnyjDeim04naZtYrFF/vOWAmuEfSGk2hXxK4J5A2oY7xn2J2VlJabJ3sG7AOF1MoQoi+hf2YoGqO10vR89IpLzs68Xl7IJjo0kHH5ro3jC2/0BKmVDbwwGFHQjA6TjJSSQyATAh9Z2O2XIPNZk1nChLsTiEvAkbCvo0yJumd0wydpGgdWG3ZgYmOU14vBCpFthCHD9lfZNEE8JTgOL6yIooM6EcWGHVpyGF/JZGgmVm34fJZllXtXJ13g1xyxSJNtcDxkaWKTJ/se7K7OgFP7uxLDUk6QBJ681pn5zXyXrmHgOgDfZDJ4CQ+4HLVn3Y5mvKH+Oqg2qFZsbtsu/Cb/rggOa6fjKB9hmSEulGj+M5ACJrbRYJN6llPU3VxSldgPcO2Yp30Y5ypbgi0MSKyko7JClf3C9CLURT4qH4vQievhe757W9R0JvBhKtoE2gGJoo5wePebDHq4tBIfx0oU1Ly3XC8+g/7b8MdIZ2KM5oUCkHCeK+1uA2AP0E+cQDbDbYNJvAqCIXCC1eul8QH8H9zrFLhdg++3EcCX6S2He/0KDO80rnatVore88MbRi2Xiw1hIAEbtcViAh0nJIqenBYs8Q53SX6eDz85OjZ6M+ysxvQ7UZOvRCSsWA/ymwiYdxb7rGgo3UvG31dN2wlTQo5727Jx83/a6mLN3jrJQBTPyqONlqlFcSE2WVMfJPGhw73ID7WwWQE8k+qtQYjsRoWbkq2OGlGybrmi+tVHqN+qQa2A5mRVJ54ZSNkHQNFlp0BF6JQeopD865cUke5EmFZhVisBnzr3BSRjYYKty0w80V6udWeZcyS3vXQCiPcuuyE7/lPmrSbiSW5dHucwbJrh6fvUQDa6NA49M0yXSd/fauQ6Nx9YysWbbASFfGmrqtjF/xQzicF7Jg0EzImLZcZo28ppz/DZmD1ydVdW0coe/qqFpcMQxJLWIIwCN+XaRSqveSWHYBGhqjzZiJAbHlMD6hTd6aBpCvCTAwE74ILlntg4C7laCqhQyrj2PPrlonr5qNUdM121aKA3UDmk3hZzD4frzqvhYOvGtGLapYxo92ssvPhb05L1SueqKJewrvMovOTexsJ2og5VhwbebV2wxPvYP2JSH8AIkWghQ439jB1avx2clTTa6TuOI2Jo2IhYH+ioe3AwKvN8DYG+WxasvlceZkB+LYyOoUrSPInpXBaFBNONwFdj8DEo6CkViNZEMDHHopeWptfE5EAMyUt8TewQa7ic6W0xdOOaoIYIlWEbz9FvYhsjoRD54wJT8YPkOY0H2g47EZ0FxWfx/tKZikbMmS63WeBefM6OxtmA6EJA/FzNPrNSBTE+MzljGc3dO8mYHL3hv6sFZEdLPKcXrcDhlminTIrQa1uIENFCH1CbD30rJjdzIhRlU4w+fWREjGahPrSQbWgFwvHrtXqt4O4N27cEhhyltCfBcXoJ26VlrO99MSkE8wzWO2UQXKBj8+bMcbRTKIK0FZk+JabPW6fXIUe/YahnH7MF2LlyzU4eFE7Y8pMjFIC5MXHrmQdGNc0ejOVzG91qcASjAAg+sK1R3xwymI6iR3mR8qK5qi9uNH0WcW0ULnpEHvHw+BUgxUqF1p6AxUoZWcsPj7uRSo0ZuxDRNuulo9plzHKdHnQIUGDLHKA2Xx+FPWvGoc1P3/ta7stl24gAgo2M1dg28QOWY3ExYfJ1LeerCh4E4/SH9rLy+P4lkuQ0stB0AcPaiUTwU04ctrj9Mnqob391VeSzc1ULZxBf+kWDiclUM+JxCrx0txYluYPSEvKBy1qQXkh6wqq927y6c6aHLjURIfcbBj1TMcjz6zBleoAnx3WA8Q+4m3UooEpzPeIQS9YcxI6n13aAzkfKCSOBFjyrJl3B97ula50F/SfIHx5dDhwqTOgwRGANetbHIlm+bLnCsD/n4gaSAHoEncQXVHYFQuT+sZ3Z8K2VQlMYT3NTQuyPdwKus6Ez5li9spy0V7RkZ5z/7IRbzaVRAGYuhqleDx/OMcd4RR/YVwB1kJ0ozPDQsq5jHxP2x/h0P7bQUQLHenaa06XCxefcfEQ7E6eHQDk8+dvP98LssvrWWpkvWDvmSCfs1BLSy+SkG2sGRgnMcAHUmNzl+TCgPA6odorazM943fRZM/ZzOXz+xp7uydgamxnnCnUBn706ZXGozBqbWKoCwv2rpwRtwQLBnFDmXYJSbT2O9W2gIsi2E3XpAxZqOk4ytA0t7VdXVynaCWDnhXCdLqYoDToBVtGFgJlwGucAkMoYF6euh7fI+gtAKiEs7ZkQc6//O/qTPHb/MNQw6ZwQaJGIrGNwHFtx3OYLZVaK9E3Zus5sKeaXTG6MIVLUfMcYnWJwOUHyoJMIC/jeS07uDREd+k9dLixecJ4bIS0XuBSIKeAfNX/GZVGi7XFO2QjnLd37Q+Z66MVQ7oaMER2as8cQHIGgnuc2OQrFG5qoIoPS2ggKno6haSucldmQRdgLet7XqRBggWnM6fDLAesphlg2Pb4LfrJIroyhpxcoSWxNwejJw2LUyxXMwqHDVS3G5XinlkYFpnozCyyfxwXiGJooi1cZoiNBW3Q1AnavqUhi61prBtBiX0iku0JdvaYuk5WmPTrWjrQuGA5rRGvGhURoBJHWddwj3ci8/3Mq8ZoFa0ew9pEaMNMaundZhaA3o647WQobKiljDEyUu7+w5IVcWxpT7uXmh7XfWn9S/hcwAT3wzUmGwgGyT1R61pJzIU3B5tXaYTXi/bSL3QYK69QFig4tYmOMFxn72yrWLnC+04Qk9K3zhL3tfqbzD7dj72NXJESNysn1o0EDFnujLvp7aV0aPeQ+8cFBjn0H46NbWdFfSQRyAEF3UTSiS5MLLj44H5gmQNT1PVZmgJjB4idd25omK9bvwBWsaCd+5yQLhUDr+64/isr0boH9ayugbDeoo9Rl30QCJxvxK6NeI4hJmHkL/U4Q6N+t+2Y6SDroGhn/zN56ZevlT9tPuadve//vQOwXSeecyrXQGWfdshRfvXxv3fGep+wC3mfIvfUsDLzrqHhwmh+bDFIcep8APX7IbowKIGMnX54Ge9+ig/DtSGlrz1Fhwabq811OmVLHzq3QAy9rS7YotcrmNh4+gsJg6OZSgxNrbQY0E+S1OERQQjIej3dAa3NuJXfUQM1ukF7OMSHN0P7l3010gNFsMDpHuBtgUlp0bac+1rRPvnQ26VBAuCeXdGfGgPSzQsCpT/z2TM6EgLiGFOekyShUj7EE4zx9I8ALPsHiyvxyXsT0oaTnap12/Z4soDkC8DuDjkXTHVoUdRbdLfoMiXizhKAr33D2+VYbupItUUJZqYGXrfixiJpprRkNhXAnDaNgrxfyYMmFl1ks0vrN79eagE6Wt43/RmXmTTaIAaOeUTPQLdMhP9sp5P/bAyXmGj3hJ0ui843ngu+8dwzfoYEzNA9+fp59tO90btwRkNoRO4/7Gf54VAwngomTx8NIgjrUf9OG0mM6Cqo6RbQ0DJ7mYz4ijSHwjXXo92oNMXkK+uLDv6H7627nNSCUarLXvQbl1PcG1TYdawZ+dFjEm01ACsk2zXYBP4DodyeeFeZrrTdYnbr/bzQHdgKwIFPzXDEvh/SXC+PNTPftiYSBlAdIyok9QGVTNmpFK9ac1S6tvW1XmKURrrz8w9EzQuE1WtDkiC0xRJO4e7ZKr2IipJoi4IkbO/ru4CQMikIsPktJIp1Xj3wBfsdH1ytgz42AXNKn0iWqf6ThEAW5ifaJkt6osROtkYlBYvEnhl8dYpcbaa9L8gImzzidWxjxqqKYJtxAXdzo0uyTc6MOJWsTjmqEFAnR3zuNxVKsAJO9NhC8rYOVin/1Mc0jk3RG8lT7vexsb1OIGQbmU1XJSaxJ2RNCgMpLevYLnjTxRv2v/H6xwBlsIj+EoyySOZCM8I1U1lNj28uVlxbLl2NJnLiaw5yzX2W1uQP0h152rOn28otDVHndq9lXysMo3fuUYJhJ0Xo58mvlO7efpBZhYo2riaZYkxLbnqkgT5ODLTTCKbbZ9he6w70pyi6sL0Z+COyocWtAKbliYKh6IejCg55+9v5cxdE7FP8UCVfQzqO9c7VHukKiIkv3/6zaJxpvGDSPhuvhZU1bC+lZ2d6hJ/MLXway2tjiHDLFq/395UKPhMfpHNhI4koSD1SBSGHkcmWtfZFRkha85lh3sTBhJrSWTEmIegxwRfafE6LwFVfF8YcuMjVnhjv3aKHJUowipl8ZgnWvg0gDvXMAR5p8rOk0XdoixKMWRneXVOSzkMPcH7JM3uET6mU8lRzEld6mNXk9ddSOvIL0pftVlNvHtKr8jheyP27qRK7vF0+N3lGtAbqxo7cHc0rN+qtwJB+sMe6a5N12h5ARR8oQovGcGc71VBw0ucgYu+u4KUPWJTcHMOIuYnVE2ufuqlQfE9WCnFlTIwaP5hd/JWGB9meq36SfH2919ZnDKsA4/YpK60hcgoA4HY4QeN8NV8iNIUwsQ0272yrW2bwy1PM2pwThDTLpYLwa/j2rTxE0FsNpZ07lTOAe6jtZFJvnSaQht7MVqnctBVAZxMDucBTjLzWXbU1vSBD5Q0of3z8MK6bV1r0eOj8dx1IpMYWuknauSzJA+vwVj932cBLeqHsNOMrGoyivvSCSoPJelbgHArNR/DngnOToxhZtM8YV8DdQABMQ6yEH3PsWVqlCYn8uu2U44m+4G0xa3FfCni2gZzUvZJ0MgleqP5mEVXHogxJYJe/QBUut4Kignkvj3bn8qm7Ole0kit18jxV0R3UQEZuTrfTqyKfoeENOW4aLEzZdD3oKnjU6W5lZd/0fmHXEzmIRVOwQTVCGIexmpyjh7hYOLLLt/B/do5JL1Q7QXDFkMLXbIzSBBeXhPQoP5MLkxY6LJiXcqDFqoEw2aSSVwaoQD559o04EB799meUAhMxCOYnZ6MqaNmEuNlyThbey6XXf/PD7QoBYtOf3/qYwn6ONig3jvFsywEz6Nt7cUX9fEUmeeQb9sr16KwvuQWg8eDj0iBeCZuCpefqqSTtB3zWjVhhMhLElD1jPGjimDCa7+oAK+esi6N31qPpd52iSMXovFRj+ceMVPbvvV1GbZn7ylmOyRVataOwQ39k43SxoMNoXPOXoXWT9mpQ0gT+XMMTDwroOx06GciXRV82k811jKWMRgeJzFUAn8KI0KbpThrhSpVKxdqmrFhYYqlTYlP5WkpYuYVOWc9Pxiz9hYBnj2VjfaMCjcrAQ5TeAq5tHIqtVgaBLFeCuGf7fYIej1N9MuKoAbeYfEToukiZ+G0UoEzbQYWTWVQdhuseNSdnEj6PsTu0zvEbudi8axcXCwN5Y3hLKdLDSrSfuZdLN9OtvSeUvvfPGF8eb6DTFTQK/La8Envr7A/vbokP0AjLzpb9XBAuC/PhopN0B2WPN5DHO9WVufgReMNdfH13pe2dCD394C0tGbNeWG29hdC9MmahWRzOPUtun8pzm9cqwfE8m0OIqJO44kVBqsivUFYz9+JR4Z8EVt3MX8iQhzTYlrH3eYe439q6+kZy3hs7R7FEXy3EFKvYmnfj9cr2yYdLvFO/DzOaT5NpUOUjaL8+W89p7yuKg2tPL87rFbuiYMueKR58EZsnukoMAggkS2Xnz9NwRLHREzyf1z9sQ538cL1ZjqjXU9+5sXu1FYv2gcRxvBfstiTJ4OR800YIvLBPe69DoFu8uYDWgReSAUojKl3y4JbmkjYpwTpvjtZgutzzSy9nF9pwwkSqmq4fL3ObvAextg8Q44HhUHgx/3Av5L8erctqaJMiB7sP0EzN9qqbE4XrdZBE+GGRC7qCremksH8EfiP9TXzxF47HPw/u4iBDHBshoTyNt2X43rRJlqsMwiakOiK9nlih2uknkLJOfAVMQd/t+2K6EdfQU+jqjGh3FDuHLdNpssvuhu2712Zih5tZeLfQbCvKqVG3mXkYiHFypo4ebZ0kgiMymfYihcYSey8FVXYe1DYjy95DVeXn4FYJlRk5boPAPtEEJqn/JweSGprlWZI7XT1JrnqrNSxLMPQngW4g5hvVyw4JyBk9mPaWWuPXfTV34/7YHNrKeOg8ubqTV7J7lX9owkOGDuzPOqBv1ibwStJKxuEXdZuM40z8V4e3ugFzVcoERSnijMuLgeDhGCX4u7tOsg0xEo5+wRQCfEDFNKXpbYdKdzPTfwvmpGLaSPl57gjahUsYqH3zLxUmfYHV1tYp0CObS7ecirqYZTEaNntfRiF3yxcW+p/+hwKv5MmRmIIchFFHp+zo0YiDHeBU59WjrHA083T6RPbhR3331BR8bM3x6kkqzAsPHfIeIQ9+y1G/cmXR9bvtquwgGNJaKUxeMNdAgsJT84PWECk5D/uuu4w9YlVcdom5kMQMxjv4usKYzqpcejFHRAqiaoZfntXjW1f6rp0h+AEnpWVp4VgD9akMXeQlHjeaVy20M0jPpWRdOyXohCMKIx/w5giR5r2WW+KmZCP3Fhh9jjfLgFFHRV/yDrDwoJNjY6TGyFaNbT8eWzDcE3trNV4I2RjBX+iKVYYq18YQOODK0es/I5rgWPeu1z9gbGM+WdTnuo56MEc0fsRlWEbRE1/J83Mc+0jGbIdV8T0qySQlNVIztCpOH6xQR8WSieWH4mHtfjhIuTOn1csETJCdCHHvGWNA9FpI+tpx8UGMRXGCoedcZZbmqWmeONcViQkrQbiuK573gVEX+Y3KT+zHSSkKI5dyH9ta8tvWOT6VvzWXTvAKx/tbwateHwOg2QLS7H8WQpvVPrEafYNONtimczQFJ3AVjy/M3MfdP4cjNMra2dvEhdpBJAcc3YryPT9ta8+HmO4oDCQrE5zMqeABB1byKTLdzjboBOE+4Gd3yAUSslODmLfzWXsS4AtDTIJW6uJLmfFymbyFc5I1XlLwEYTEVYWBSaOYJUF1b3/8Ih/6xnNPEWH0ohkK3sq7bhiQJTgVOlrNgwQOuUJ29J1GNZ30n9Ni3t/V7yxEXJ2jEUmbMYYsWFtBO3O7EA8WecwjZyGPUGaGTA021h+hwWQ1zeKjubcx0aNbUOlUWY9JIa8LySUTFbZyiv3ZiX1jpkj5nD0on1cZDeNs/Q/o92HdI1jOH5TM4FYPorfra9WZjzYzrpBENS0XhoheAW5caOxS/aoeLqOeZTub+F66JeYdkR9D9whVwMdbXNNwQP5o2sb85p0anoTqbquaxaDWmsEBeH9tAGyXPuoyBTnFItyFzodQAQ/r4eym2BXJDTgkn7vAEMGYNNjGHY0OJyX0LjcUpj99riiCpUMwXfIzVzCJ+hbrFy4EdOU9xVweH5r1dXKCz8GyBvwGO69SEAhIO+kfp2b7jLGYUpKwSo/QJa3DHM2R7gNabO0vwjTL80a/MZeUhiTJDDu6x0rRIIBcDYumbatKy7k+pRD5Bx6SDVtnH59m+KoS6ew6mCLAS1F9UgwfbRjijLBfyKKKHt+TgvklJGmiZfhtCwgdXSn9t/sxSRit2PKXo1gVLTG8saCzS8Dkk2u4MWXq9H2H/9MQQfda9HY/hFWf8mfLSGpu2+tGWsACdFvIIBkthGmS1lFmfIIs74BFmTpLOIM4ipdSbSF9PmPNjxuKuwGrF/YSCm4SkAI43CPdRZA+ooFH0W5Qd5+bCA6NFRkowCWSIYjDiWJM5rNEy2uNNuRrqv1d38+rDgtjGesaxFxH6yFmRyjWnGK+b1+gy1Ogje9/0Yi6GgR569u84ao3U8hbvEQ+25R46B8BGoZpiNVVeUAvbi3Ad1UeAa2jooBN7OCKjKf6dU8EbaQDUosBqAvmSCHoQmZya1JWgn57cK/xYygwvv5/7498GJ4qdI796eGDo5ITKw14Wa89etScP1iTDqFBteR1H14ICUExPvjAKOA538Ta+2OLygTlf+DmnXghCBSkvlLt+6dGtog5LC+smPfRpwwHUqY2yojAgFbK01rctMw8y5RU92wdFtV/gMthEj8ZkUAYIUmpCDwz5lZBAxYNFQ6qJF/8zX2tP4tQVRQTKmEhOWX6XhjULC4HZocqYbyyvAMjIUDB5f1GO9m1wmgT7kIensSzGna+G8u9FI6GUItVVtXTTmm+V4Jm/SB8uyD6HtLcbASZvJfKazD9XYUZnDlWBlY6OX6J32oqsaMLqwub5rGWk/caJJ3H5Bmoi98Qp+Yf3zA90m+7T+eHzaq04S3ZwPkPx34ItPvC9R26UY2tZzblrUm8dOQaQQYWrR6IBXDO8tin/yihcnfU05rOYLh/fzQKjZBJCnzvj9uQHO+GXh5XqeR3YLzpk0XRKfJD564CqYgQBGHQIPs7demk9dH7Es6CsdeRMmbg0Eq0HB5s3unUYNcCC1S3kld+a2E1A/s6NoaaRw6FPaMCv8tsx613jRA4NqnrqmtMQVG1eh3v3ZFHk+cOalOiRmKj2X6drbnILqYXUluQjHjnH55VXx+hZCwlnOBGYGk9lkZgowg/HqjsXA/6miZZ3yfx0eIy/OYLivnGantCNmw4xj/ew8b1M/1wrgL3CurNXofwI+opDJNrJPmTVSRNxfOqNg13L363Fn6vN9lP/SfjXlaH9nGu6Nmsr8zyzGul7W87dLjSZZwHseKKO3Ol37DNB1we/I9F+XcYIh+ShXMXRAbNkmkQvgbsjv8UCQAqK+/yMLwojzDF36MARz37WWCp4Zpcc2ft4qALmKO3Z20sMdcUCKsw/z2FByXVJ0wcwhLim5aTHc87VgPrjktMh3+kVDqLa9QnkeU2BxVERRrNPMGs/Xz8NJRJxZFKLSOXHc3uOom6ij2LjHuTUMZkpeI/p/2YB1HPa3Z0clPMMMrlfFy/H2Rr3pD0JmHOOE/kYt/cShUgyqA113f2EZUH1MHJeacUkV3ikZgY2oRKMy1GXxiEw/XFpidEMUEdlM+d47i/LuSFUJChUzxH4p6M8s3Od+G+/r+hu9LOuW2XZKaK1WsfkhcEMiN4vPS2wqIK47RW49DwXG2tuSPoASEyR6TY1HFt4HB2k+pfOyCOFM0DU6Nsha1ylfX8kScs1YN04xtfcuM0OoSfCGJcVi5EWK3bbUre5W1hwDaNqQ9Nc/T3tB35Hd6ak3AT6u1fyaA1OWKIIgGa1+lMRasSPoA60QyjCsDUiKpPrwfAXe2ExQfsVo9Pundhp76bQ0tGVoFY/B/QRUasjoO+szx/7qxd965zNLZuK4bRY4L/LDBf6Yzl2aR6LyvHuNueV+PvKlbJ2vidMYDhoUBXlspl2DAdnPNxdfohISRS1xkFFlJ6Vvpd04o4Ls5AxAOvhRhw/l+lR1nsdN1p7AC8dHdphvDJw4oKo4F9KIpvUJdmOvZGe3jscbOVxS4eHTRpNrthFxUmyVqAq+lFnxSIYwnVh+vPQeieOgZp4dpXv4ICy4dr/pNjT5RIDPsjxEC4I0vONvDwetUL12+J0cnjTsaV9h3aTTL8gXRdlXdWq9Jfy7fT+KQF5758+/ls57Mx3dbacw6666iXbBTR2jRLnQi/9VEVCgRLpmM0CmLo0/aLETu1AVwRB+mDXhr5O4s7sd6o5DteJRXe0+B/6ZDTBMww5g9vhrURqAQgyWzQ2379+fWfmE3tac0TbqHYMKnp0hITqyIBIRXOB4JW55MESosfkjJWy8xRQg9wyeR/zCkOAfP/gj1jKMrdC8eiYdURkj7qdzxR32x3IApiW7Y5P2F8NpTQgnUpyykJnFX/axlS3JW/9167zF9G/Guo/ynT62SYit6W8MWB8qoAWfpvyEgZZvPuDpwu5kmiZiK49flc3ZtEmacsjgkkIi8MKd8aqKncLw9ZUtgpMcy7BubBtMpoESaInTWjLKL/OkAumFV//p+YVbYCYY3xreTV13rnnPjiC1LhqD2pRThhHuiVjrDyl3eBXM0BzE+NhgclytWTJt67qxr2mPciwypxr7pENeu5yf2NleP5Hs4yMzj40qgCPt5F4zO3JBCJhH9KfEM7Eia2JGC84EFqFTZs3TatD0bI6sa//lMxMxlDkfM7jM69srXIdLUHByhgwaC0l2mnUdMQm8SbcNnx/xx1fdEQ8CFiuO7aVbl++Ndn0ZZ3DH6z4kD9zh7PUWrEIXw117z1PJIoviygCpBgUoFSeiJx/t+a66FsltIKlV5wnDu0dvgmiD/VFe0iL0MJA2Y/OnUU/2ywYr/D/9s7bGLUXCTLa8Z2ULWxAD78YEWxWOoArP2efmN29yO0On3CLsYJev6sN0x37x+gHiq02VMq47jTL7JgbhVwR1eQ5WiGpb8IuDF338rhqlnFFl/lZoYJJEZ/sjlHDD+7d1ApQTSo2mAv1y5kAObr5faaFXy9PwJzSdJdYTDcN9E++7JRiNW3Fg5f7Al+088RBHBcJt4ujN8UBztiq7EHO120ZwP7SWIa67U2zLLkRx/yzCsz/8MUfP9bAs7mfm08NkAvKHcJ62GGLi/nYHrHjyJY0nzWB9oPhu8pkJdkPF1TiSstnXz7ThXpslX5NwM/yl7x2ZnTmhGSHuPZPu4jMe5bGFoi81JNyvVGg4sqd0Snkg+EsZLB51udYnZV9cyBD+wJR5pRHJvqvz+5sK44eyCaiAUm1bEJZegLF2hu+Vp+winUyFTmu0DmyJMx5gp1eHhqP7/w0ZMnva/qshZp0uXM4Kk7bXccgJge/IDdlgRanlmEzV0sqGJ2iLQaDvKHoZebSr/Zlt8r4+k7B60kzGEgjHBVDncmODEzjAIj0yIMu6PBVZkjQP8UfWyWUn3LiVc8kNCGOcApbZnN2ZmPpRpQwE6t5VZPD6xdpdmF8CYSd410bwdm4S7NTQnhuUpZ+jEtDRj5Awe07iHEq2oR3qGHVNQwieJvMyr/ayHaWyAaRBYKJpE1Vr0GwiDRZzM2y7EWjnI59dwtKPQZs9K0kzhOzbNDNs6mQJy4t6qXJKnyyEAGadIMc0+Of0pY/2Fa6+h6o1/IB0f37zX5U/yzPVJnUfEObRo0LJTat4NRbG9VEiLhpPo529Z+ERfgoKRPPDr7dkvCOxaR7nAsIb6EzhwtDGHUVBw8OTvx3xiUe8532F2Gu2KHGAbKXXAVGzDy/QCbBFwte+/o+yWQp0kRmn9iObGKRzDNEIT5jUPW8Wc3e+VdBolwhj3bYWjeHtrFOhCjNGzQmdK0O6Yj7+sv/+pQBgGHmiepOrNji0XeRxyU3YJA7+ABPbKSocqWh+bhdTptLicIbyugcgHsEsFqaObFnHhBXFZD97C52nE/ctnsOU7yi4c7DzLGJavW5CWV4uy82Hvh1TDQlrm++o84GiZC2Bx2QcPqprOii0uzzLpQQB8XQyqt4tvSCwZxdifwXhnfPVGxDRFF6BW0aJgVh69nKzP1P3qwyZVh6/Fwb+Rtkb0j0yB48E5ItN+MCTUYzsRVAioX4xiRAk9KESlvUE21XP7l8aYIlq3DLDwGXQHLFU8Sduao+ZYa2nqeYNVV8XUAxx2LUXE9BZvXtIhWr4oZD+frwfLe1w2VCDmB1H0o1GFQC71g5ZSCSAipP3qGZmiKAy1LVoL07uS6imn7fkcfZYYIjSJuOtxQX640K3d/3NqaeiIwN1DryS8EEkwygmW2glDPNEgOYfZJhDCt5/KWxBTdEpqUworl0VZ5LI6hqjnk9JDFPlUGQhmyAGpeJiXnCtGQIUmYVd29YqMMnMM9UmoSGTxbbiNus+bupjlpFWPPkOwTa6bJwUV4oWVJoehfxQ2yIy9ZduTNsFxfOzIOA7oPa/F31Ao6n0juta1PFHXRPWxQX7MKRMbEeLF2YMrUZi2eUIfGqNW837f5uSFi7XaOpSILEg+TiLENel+2iFMrA3YyBV4qamUq4abfxLZ8okZOslPFYIERycoJhSd8BnAK2YOxv7D2HaxrQbRuc1xcgC/szOxScvaHPtjrTy382Wtpv5hoUX3Krcr3JY2/O+YxKeyoidUu0YW0YqsODMuUkE/zjysdtdbVI60v/u/1uQUQSExWE2+N242cF63WnougmdTVtvGOS49rQPF9eAPANs4V19f0iwWprP3dmI3Gao1EHX7tGa0kIxWMM5w1VSQCMovEeeO1qRXqPDcELWEf93s8WUZ6+6yc8A3PhXlzVjvPnSIonE8gyGyisCNZkbS+pqRaDeu7BY4aosopVVLk7IUV9vBBc0mw/3ny9y4vnwhXRSytJSGBMKDPmL2iO0yi8CH3bJlpeafVmNk+28gs41C+2O05Hdyk2VdLytbDqSKExNKI4GDPhDtiPk/GebeXyehR4DyXf3s0RCbmdSNY9a+gQkRm5CXWy3Gt1xayHKRxCWChJ3Iw0+85AOlzk7d+0Bt3BpaW+f5WmCRRixRLHwiEUV9BsWXlSnFLp8NWjaH6drKql9Rq7BnL1+NcRdw4Swd7F1JgOXtqnh2UYkMElT0ND9g7XNHfQTOwavAqioafthQbTgihpj/tHrxhJKd3kDnyRay8zNBy3W9EiMea9hHGbMXHJ5T2HxTWnWFrWvQEtkx5Ep9tJ6vNxj8BgdHUDNPmtEe0i0Yt4Qp44q2Ln23Ss+fRfm4+VtyaI+k1DSLDQD2RM5C96DyAkImerIsh14wAvKXldFisjYGMYD+vzIT9ZwNKUNh4voblZcJWKZCbciiaqw69POMgM167X9PcSis0VmscY7gWkXH1MGJTPX1KKNWeqC8QRGawnTfgt+NU89XlI7w1JvnIVwdl+7dsKjNWFdejqIGv9p/oJltWieflfSWdgemsc6uJkspjuUfv/PmfUTv4RF6aq01ImjwS+YiRk+Sqn0N1eA01dOBV9agPk+/jMspdUOBFU+77VmQgy+FlEBtau5nm65F6PXTr46gMvCQv17LGg+taE9hNfQ/vzsXE1VJu+DJsTDJI5wqzZcU9NGndiye0MQ+KuvMokm2VpOH8N5YvnGeU52vqi7Gg6zFVxUvbHx3zp1McGj2vs5GEnNTnHeGziCtTCTnBzmrPhP1tQR7x0zuKzdZUAuFBxbv16j2DxDfaTPiAYCMMxVkaYF23Sb3lTdaReXgScrvo4sLIiQ7BIbqhCUWpS7S8TPE++qfsDsZ2lfla1ZNXbKFYMY3kjc2wi1NGGO1uW/lTZh09kGFd5Brdd4TVty0MsO0ucjLpqxCvQackOkBVVvYknzUQQRTWJPZaKLhSjlDvyJxCPuManWX2H8c5R3t95W6cmCsNOp7C8+vucHWKPZpi/n3Vrbro1I+s87zk1XYqEn5Tvje54itQvArdmycvVJ81CK0OzoHA6thKLqYc1AJhB57rjyTbvgjTeff/udfsuQUnnpoxM7tIYtYj7khSkT9bEp8EzJ8TkfbLaLsOc5ZSIWGodpDflQZMHJ2a34Hcu1JJYfgoTeHv//5Wybf8Ir/wlMq1xWiK8vy/wzkNWHDJdsTzv0701e1fvy3Pk8pezaeC7Fpa+wUXV7ccmEw6vxPMJ3XbI1Bt6U6VNh7i0YRpPdDV+xMrGgtVT9ChNeX3Q7J9HZz4kPBd7vjte5S0grwiLi5elZ8FWd1dbSKwcLzlQe0HdTxODjG84mCfJGDV45bQizj93CSQ9jshvA2VaMUbOhaQ3B1Jl4B7yH4+v4GA4eMclRsjGLzDY2pRGAhUmMTWuwatIhTm49xQ6pkj3LDDlqoM10SRcE4jFzgk0jko7JpwzOHr6D3ZZ0dS6FEPql3KBUAnW6jqJKNUUrHioG2//OxXUje4Mytcfq8+hketKheOIBX6+vacaEznTeceQCecxhRKKobKu3XqlhPS3PCot8qPTKYbsXTWHFGzmnJBJx/ZiabWBr0a0w7wHrFqIA8MquTdA1qdk+/R1lyucTcA50B/gboGtznc9KUUqOjLSHQBuV8iUzytsVHequLbRJ//o8bf2I5ODv6+uOzUKRjPM3XbvZIy+mWCO2oId/492blDT0T8aNBx+8BV18VinWEyi1uovqvH/M6gbCrKg8gT9OOIJoHv+OYGz9a0MyoDhuFThnWr+Ee5FOD2rcYnAJ9Fp36Tn5WbDNXzl/Bbmz4y88cenSDccOV2Muxq2TZdRC8Zb4/pTeYy+p2bjcwIMpi98mjr9Hrqxw0ZitorzVHIHzQ5IaYFLakGkC3bXlembhGXHF0/h4k91y2pfs45BoKmj7BiSzcMkPjSBvDVSdiUNQxo6wnVT6kek97fhV5LXdSmmcxyWJin3b5ZAeSa7ztsJ+yAVxdn+qqMsb0fgAqXCC/kPl8G7UvZ/Fuw3D7SjdVMW9OZ9jy8pTSAZIVD3E0e0iqyzHul9koL6diU/dvDU59UM9gTy5N813ZQirdekVP6dP48e3PJ/1o3uBUAOE3zsrsRW8qFQQ/b2dwv3/spz6BHQX82YAm+CH6LhrghUDWGTnpF2Ol2rzJKKWAejtehMzAIK60IfBN/SBHqo6ndZlGkdJNmxGPx4tme9q/5ZgOkRoFpdHNzm1CZyyuRwCgizwDs8t0fxAzwk9eXJUl9H99lrROCyaja//daVbx4XY4R2va4iRFfI56JVsJnH1r1Lb3jajcmuFTkXX44R4/gHLlDrS1LkoweCyEMdzNlrBRECp5qIvmShpTbJURRnCiY9YYSi7RCF3xtiq9TRrQX1ecQZXN5HZrT4ShgL6QJVbl0l+keP5KU9efVKhlGWwtYOi7krfkyqJPlfIc/b7BeVVYwWaAQiZW0NJzihZdU+nT9VD9Sf1kIcHSeI0IhBtI7F11aFMK28538T/stSUJQGsSmjrhBCaWiF6ZwQOLADhgkS5TKg2vxNMitcInTnpqGQiJ9y5IWwfvpBFgEIjWCuSg6hLiCE4ayJG8RVG5xiUCKUhVs9KJisIfxBJ8kU/CVMLvLiNLPaSJBXhytPir6K2BgohI+uX/QDhzM4Z1flw5VefZdAEe8lvfvg1yYiCP+ryMRWJWSjc0HgXmxMxDm92QFfNcEU6dvaaXgTzj9JPOyH4jt80qJ44f6A1pobwJlpv7fy2YkizSgFIJG18F8xg+ltO6OJpzoA9IZBcnCEgRH9esGQi0MVAfce5sQoKCTxxdU4R88Nc7FaHpcU3tbjTSX88nbIL/Kfm37RKXB5Nz/qr8FEEcdJjJfNRFZ7op4V7Ty3f+yJV22XehRhs10V1gQV8psBlTKkQANrG8mYYhOTzjGI4j5rBSpk84DRz9PN8o0rtHhBvvoA0CIjsK/O7RXbo4cK7lgDvXooB/6Ph0kyKzNyxLHNqG5lpuXgJ5T91Yce16d+yqW0reWeJSt7cmApDnZpJd3zusOKD8T9UqT6zw7pS1X8F4uXVmh9JkgvebxYurraBA+r8N3VwhjrtgQ9kqvxX35JzmUgQ0GGJafIU8nN0DHj3JJ+kkUVQQ5QQhCZP+BGyGdHeM52WyboJRZyP3dEqqz+3x4OTrd2lPyqjtqbzL1cpUjTGXJNoJCBfUTidWlgA44naZsxbRK5iSe1s94fKJ42k46Sm832fx6y0uN7UZQsjmk6Vqjvd1IuDVgg03scsFvkYnlTAGAUz38bYC1uzfrJNFttdfNWw1YA7APE3nIm5M+9oejBcq7Nh4nURxryPzWtfvRCSJEXYIhUie8VDCaSHKIgWr7ffVTAUhwnYHrd47gNBdR+mypzjNjJzR6tcEE9I5JjfZ3Em/Bb8bP3WYsmi2qCz3HWoq2ZfvRD5hd4kMWvZwP/gx17GMZQz4Xw5F7ikQiHdLFPEFtC2C4+sjZeZ8EPru6xv22HPSrvqRARPCBG4Nd5BCcP12TQcPkPctlJ/inczsbySov4T/5ocAJQjFkKiNp0N6BcffJgZPttO/NIWxwMtJ4C9J98IOwyFRQEHejJbBzfVByUT9LO1wCYJhB+NbEnUwoaXKWYrcLemdaCIruZ/Etga8a3AUlOqTrCsE4zcCRcrE66WjmHldeKBPDp0nvqWUmtMzOvs6zl9v6g2TmbbIhUmBoa6EdTQ3Tj6xhFsY9nZg1bfvPDjJLTwBCvRPunhnSr73mh870pGeIarkaZ9UNhRbTItRPrup1P9OnXhnxWVMvJleLpyEVz86FrO7l97uM5VyU3Fl6GDWdLGPVidXxvYZECiC8eCVdl/vH3swv9BJ9J3/R19OARwIFDl5n7Okp2eFKEahP/xIwVZe8tRV5eia+YoNXgIqDULh1/PIiIfVjKHOFC31BGKI7reR8EnrWwBxPHx/zT2x/fvjaJ7cq1Ifn+Y6tPa0ZyDRzMY33yYpi88HMtM2OSjMQcKcuCebxEu57CZRh+qm249yBLASzxtGg49wmQ27FGY4uBnG/9qiG2x/eM1NcpkzhZUVeKhnb7R5BNI6j59pwDmkhK9nOSqAhlrbgDSEzz+XO4TnJkd+PTHN59iSkOFMI+HmcGQHwEKg63GGWywRU40KxMUx1gGQ83Lv1pD0dGaoo4PFZAE9HWSdHw8GaQnuu8cvaddBYQ0TpQ3WIfs9VP2bDM3CkL5FUTfNHjSlX9pcsQXBsCtbhq9g6KhJwduQEfFHeNK50bIKDtLz67bDg+5TcSgGYDyofAkFktcUZQnXKcWdSwnrr6nsdsEs7JFLjMTSicp+UJdxFYfG3lXGTtpN3yS+3IceUBBcUSIZzYaQ2ODTmJMzSZrh+nxJaeCucslN8feBpPaLAgklBTa1aGPfePNP33lnhVEYJmsH7AFOVsHxnHYLQOnuIojCUc4bzgx2SD8abGuwXhe9a3bOZ5nDdIqB6FYsV4rjbtlpb46n5BLLaso3ObIgtzPQmgIfskI3nknmyNn4cZeGjC9u7yTG1b8hpjmKSYmaqLpuyFiz8bwtnDIEZT+iY1qMjff+g4QfwQXCTQa0B6bOhqt6bpYq6Vngtgea4tTmcza/7mgGo1uIUQTdZ4B7zU4inq7qMYnMQ/lNypdciDID7CzzOW9X7brdczCAFz10GCNijlgFHbGyhCPJcr1HRJlLX4mFLH3gEXafCN5d45lgjorsMWjIexdOsyKNDth4+ZcN+1VIDyqO24KmHqMRE/EmZDF9g01iXOMd4psks6AGZ14Ygut2sPEy+d6f6zfn4M2i9+zl3LpVSuOF6OdYZHJ86J6T7vowxFA0T0z9+KsaER4D1sd7KDl5mwPzufDeifBPu5QBH60HlTCYDpzwL2qsH8ie1XWe7x0PM0lPMIO44r+j46sjL0Vs/+Jsfl6tisZSpmytw2xo7JS8FGk1qOGDbzD8T8H3M6UdCjD0glXZBAlkrdmS1dmigIMNsSJiD1RlcinEs7znJeS/gdLHE9dJL99NTjnsR/fBpcPjiDOYWdCXm5GdzfT3OROb3ZZScNYaUWSdEDivNkpRFYbF5krF2ldxkxBV88qc5PTf6F/P2XmhHWcQSmYQHa3/m3wztt2Ga9DQiN8l6vPtaon6rDT9msFnZ9LHzTa0JYkagwRkY/IF9tf19mycXI+9HbjyZXfdjPUFVtzXOfeB/sLI5s9QAuN7ztZ5bjEkgLLlG50iT5Uz8psMaUWEMYR42/4vTRV/phvQZ5/e6KsX56qY4sSRtToCFSYrGqZZmZRWYryVRYIkkqIjdrhtZKGoyoIM3MgLgo9mqjyySSot3BmPqmhqa46NWmmDDbVsxNgy/YdLQ5rXGjczAYsEM5bx5Kd/u5J5YtCDWpv0OgLwAEQyer4JwUzukwluW+10NLqeGVguyigZBTvjalGFX6SUCPyZXLEkmdUsEc1N5Vrky+RqV4FDEovRkA5aVgxnyoPtbyyuD5wmBdsYnLXdCRSN4fXr3YfSItWSXzEabPXk0qNbHuCYAFLNTpwyUL/Z7oG9UF8lCohne8OxkmscUH2OAH7Jj4KkpglrSq9clgHsYxXZXd5Vp1QhoXGE7BwfG3Mwr9HU8EBCVMkgRAW8Vz85Uym83YtnfZcdTYlfdkmMiA40oOU/kRipOok7BG3JfFJuV4CEWR7DwtmkGDzMz+bzbXWJz6SAC2PPG5ki8Io44OwPM34K9Rqs/VCg31eg8OpvWEyKjypbvTpxYicanYe7QM1K1f8Xi9c3k2dSpBiDbUBoATStrLz5/Y1mpXRvkP3mG+/mMrp0V4AwaXAoM+vPWnzQqsl+qHvIADNfMWqRRJvYBVXKZiUMJp1GsfItsBgquPb9avmRK+CNUV2S8ayDqs7k8Z64hJrxof1lAbjGxx79swnuKLd8t3yIHApyLzUfEUDho+XLsjq8wXWTbq175WM6OoXu6jIZHvAn3gGAOcc3BuYgtj+Ex6iekIDDg8D/hmMf9+yXY1KLzHFov9BHl+/NtNXuuuvTSUQel3if6zK+/Yf6VIQwfgKQMfvjPdCB+XwpKZ3lW4K2LKL4ZnglFM7sbgIQDG02WMMDx6J1kinZ8mZp+3WkVQNxpO1wyzQpJCHuHw8bCgRaASOR2vAk6HIqTu9UrSb+rP2y7dXwykp5YELD8GAblPshcNkkxYwYDlTMBi/JXslqPTgq9KVxn6thvFOSkv3P73TAJA0RXTd5zttOuJsIR6EjwBRAkdzHu/5TvsEbWD5uNSKAnvCGjM8kxFa9d+abMMxbBWM4I6vNmJlvnHooQpcH6IVADwzU25UzXoHfY2FfGnucqlrQjwk2/LlJ4RmGrkGSP4Vn7r/fy0a1CsK7bHJ6Z8cVkExmajRy9pOuWa/2HSvR4/UU3voEFf3oR4xESMZJQA8vkIf/515b1KNdMBSFBx7Jnypx8m6EG/y5/FMiNRdzDc7svHFGOZ352Bqb6JXa/fWzo3nWCyU0sOQcOmp3wopcMEnk0q/rlu4BgKNfmEIZdMIxELh5OZVuZVuGMEJPywOmmSxECnDyuM84cKSPmHjkLczuJqb6HuzCr+sFXfwQBnFHkFkG7krWQsmfvLx7ftnB5U8jYGy/TJBlb5g38XRDEwkKUqoF4oprZUoFp/1lJUvbkehwH0auV/r9INbGVtD1RH9TorZbyFHA6mHsJgVBRsQa94BtEame1QNclfbnqfDHx02eZdj9Brje/2he/rgNH9OG5R7lgizqCQ64YNnLrMbITp+aUqrsjux5EXl9/Z23uCBr49ktSRr9RGjRuZDlh/RWWAsxJOWso1l3CPsbb8fd0agVKGMo7QThkarrnEoKOo+zthy8AiA5qgGbSgl0TXLDH9YsuZNCIb3L64z2WiudvtLvKGEwoJE9FXk2cFkOQMX0/l6+LZSIxndzyB1bvV3uo1XhCqFSKpdmU8x2XIGZv+eLUnxG0dEH7k/aC8bIgE+085NjKO3OXczeffWdo7ihZ0KbePWhJUM/fPxEZr9vsUF8P/x7lTIO0TRIVOoVbZ/iI3yHptuFDk7yqm2C+34HZttN8YgZjcz/E9jtzzM0ym9nXc6JZQr6+br5mIt/dXmBlo71WNhgJYvojQUv3oPO09XY7F3Kv46PStXqHtr2PlEbfH+v4iepiu/gdSx9BxITNdsuJbPWSAXTsZcC+Lj1EpVut244jCcL3fcLdr0LLWh9ZFIKgahYAoMKm1nLfLI+K6n/VHFGKKTzIMVvJW1plYBLtN4L9hn+jCNHtZNZ7pOYNy4XS7cHgBAYnE9hZG5YkyhoA5zXfKlzxPssiDsurW9eIMyYglu03bF/2f0LAv548OfCsJYQmaHciJyPZpyrz0tv1TXCRsrt3IjMcauzgQUHFgWnNgcO9TtOI8Oa7zGZmpxIy5BbuB1n66JMyeh9EKHqA8iDvkOYi8LozbT3VL7a5B1w3u24L8EE2nIWU+QTLw7MsZ97LZXmQv0gRGmHTSaSLAEei6/lySFqUrutmRcWmqDITtAUU0fpwV4G+L3RMO82JEEPHACIlSIMId/t26uGMj1rKypYZc6kCSoCmNBfGAvZk0tTc7wdxhe+jPhmJj2pduFGCFwxtAMta0N93xL/Et4Y1U7GU1Pf6KB4C/A1bv4vVoGJLNzTwZp4Z5f+l3mHsoIVLKVHiir+ks5Iln/GsSfK8KmYW9+4SGmUlxed9TAqFuh86jLLzwO+3SiJVjyYNzbPxKF2KTxahXHd3Ddvb16JaAin/wFQ8Kr66AqVdx1OlMnisKg5CtoO5amQsi+Mut9Z3KaZYYm5aqj9VLQEH3dCDM/SzWF0kaO8SxUy7nFoko3InAeWV6YyhZ9vAS2Jmr4/DuOkX1jRS/1k5ZvCjwavvClR/7JMdm1A8P6HE1ud85H4sLggHQHwupm0LQx8apEDclu76CNoTEYfTS4vGqE0U2WM3IkXkes7V3PJ3/n1yrIOHBl0BdEaBj54+gc1pLl/O9GgLm9EVld5d9WK8TNdwp1VgBfxJkwrRkm4VJKjuIddk0NmKC9FpY004/sh2JXIZvdL7KkeJIA0Bpj32ZE3Y+J2eez/8D+vyg/kLjvgZ6trW7gveH7ixlvxR2oZRxLehCAl+S/f0bDWq+k8NXQacR4TXUoKSM3oqQCo6dU1rg9yDGUJPlgxJaeV2NgOkQWDfwhi2O0gP7HFhSqUMQbJTvjTLD68EUKP/doBeCiIzKoCEyNzQjI8cLjkGGSwfPHdiUqQg/i7ehVPF8voGmURHAqowIIR6wbtNMWnhI0QOzJJJlQSOvCLyK1Qd8UarRYYx/9G70smEtCwLWk1CLqfJYIpb9sdCYnwzC5ZX1c/Zt/Bf4Jd8Ovi0ZldSjHqFMCOXN97ayE2JjcaUQWuilbQZTKVwtEKXgJhOvv5wRF4QWUUaCQb+XHN8mwTdLEirC2Xtj35lS2sZaljDtD+7NWq1hS6PY4sudjRoY0jrCF2pmRFl+Z7n/ZuscDVcpzQqIyEq1uQCVU7cOdhXbrkjEOyOTecFrcfsDNGavrq3zuu75ur0ug4Tz+CU3ZyK2u8Lw3CZAKOumNuoltTGUZXbGZi9I4h59CIPHqn6G2Xeb+JjhgJCwmlz+i0WXjNwf7JWE0NZMsQbZ1NA8SDnbCsKJr3RuCrSNMbYBoUXeqD2YMZlNFzxsPyaAD3+A9vh0uPQpQz9j/+iGHFyRL2Ujjbtqj3rzm+6nj7jp+leXTeucDIBl2uLgQmEjdJQ2O9qzVrg9ro6j76yIutEuTBGz40noeDln9YWqdRMIrqxM6r5xn/R83qYP03Yl6Zun+t2/TKB2LnDC5L5qHx1VPOM9RKTOyQXUK6IXi1GdHtZzwLnW5BU2eFxgKzo0UkwtDw2s6s6CjWRXNYqsivi0Yc8bNrfl1nPoqNYFTgNaYR7gw8TbwU75BhB/4Qud/LL2pbyJ9r3Kil4LNaLL42nHCmla7g9lgFNSC3p21DIwX3661xCAI5xpl8PE4TCvQMByQhX8g5n0Iq19anUdf26Fxg+TCvKMT9Tp908Ute+dxaV5EwE+1FC38Z2oGt4qutbgMoP9h2HG91yZ+cSkh8estAH/LhkGZtCJimlo49BwxA3osPCshlvYgpH1DxX05Fz3y8kYstaY7Vei1xYfQnFIrJ2QpKts4/8Bg+jjlX0ik3hckJrOg0aUhAPrmmR0ygPFIiKpX4AOC8rxGSbAFWQRAPZ17jqlOgr0CXfoqzjJprerN4HNfvCYruoKzRB2wOEmYIaK1LmrgT3hUfl7GrqC0UWf58+u0HN/6t6qn3bExLDVP5ZSwbdWk9Om4seO5KkraFVju47LLdXorG5HYFWpg8N/1g864rvOv85xsF8nQEAdcZNKYpKcrAJgm1Rni0ax9gQQygSz5gO6CaCPHNEukJWWqLFUahQKiWuICpWRRcYQdt1oYRiQWmoSG9oIiVZ9II2Yid0FDIvTEnGGZhoTjkogf1YLnJfVs1nzUqWYZ2WZe4R1xsMATcLgB56bOGvMjLTLIbZ107OtLbhvy0M288UvBK1Aw7vTj6FxGwdTYDmCr82loOOKhAhvW7viRuJt3WspepNu5ylQ6xeZ8MeghkMvOvxpoJi62HQtS3AVv5SVInpTlVCW+bWOlZul43RAC7JELalJaja85RTUI1kTZ4tjtklkaUaErhW8mmKL2Qv3AawxWYZE8T3fBrgqrA1qhCj5up76iuK3qc7wuPdT2EkbpVs3p0mXfvjZ+Sc1NQGxPlj4d4V4jG/MNfK6xyDqxAKvDmj2WK2V3+hShMHimxcMVHX2c5q92MSowB9e4GdSkqTwPdzQe/G4vi9VkCqQDl4niNtwSim1ao9uBarI6JvTVcufGcpuPFxISw35LK/Le8EZ90THILuKx9J/o1GRje00Tnwe4goY9sGQ73nWMw+HqNvjMy1ufUpD/7Nwze1O/1aDh4b8v/tDPjVf/QlYJRQXUe7P0A/ctJXZdBoGh6O7m/oZdyYfADoloCCGLsZEL8fIHdOFi+wrZnwk+Zp1dyjBrW52oUN75dm//GFOHXeXEmkgt+R4pgeg8zMwuBu9gGGqaPTzArBycKh32XaHE48ddwDsujSHwz0XHutBSiyndud+NhNNKl0+Er5PXSirPY/qAKGuTty/fhBwUXXUc07hZuNW+LfzA8Vy5qHVx22gaQckol4eIjfGVqc7ZRWsvsLIxwMXCRSJDfHEZIkYZXqYgTBIAPfu7im8osqKFuuzO4CMgYrpvi4GErMTePREgcsjHY0IcwW7lH71hSxZZxEKQwSHX30qO4ic5jzvFuIQ9fNQ4z3hyz5gcvEk7QZH1CQ95Va6u3sWfmX0frmdJzy3SDBYuLwWy8x5QHpbKY+B6pB8Y07oPQ71t138JKw2lO+JGGIuAXV57NvvIALUDS9OApP7d1i9VWIDaPRmv6EUBFvY0R6ciMdFn/lb2G2gAAEX18H0ovtPKsnqK2Ob5R5XLC6j1fd+igSMP/f9Clsn639DfOTbU/N4b6n9tvBRpTMzlrRRF+t2jcVHesIInZm4iRuvXtgbU9WapMssjkNNrlEqWr9o7jm3U59pZeWvZ/c+3Bb548xlBnMxTicJ55/TWXlqg3x1X0O4wsaDO2CNLNAWYKI1vHBoouN4Dv117lPeIZxqxRifQ3muKKi/2it+T9OKNx2GEDLcJksThSueQ8W62WDjIAeDcymPa7d0VG3FzXVBlXE/gKnhRF5pbWi3tu3Qr3SGkri6RByoXOwi2tIYooKRHqmzPWREtsBho/ozXGuo/zm7lM4b+ZkcoY7dF6rVMyx6YJZV2NHgzUxYP/lnhwNg0EJq+pEv+O21VwdjARoZVqCQ4Jac6hu/S8pkxp1kpZTldSHxgc1+/awuBFcA0m6rMpGWAla5gOeLrzm2KR8Wc02nsCKTvL4g18HSEJEcmTH1vjnn4bvSb2f2HyBl8BR1gnmcuCRNiPr/hZDHCIcXhmwU6DeOqek1reBj8MCL+Dkt+foS+42C8nmgtliozEgRJSpcUHLr803z9hNml5i8Aq68Jsa4WNcP8XnSZMGQnfkSAbnbfIHhEBzRvfA+Ya0ivXPNrlSDwmKvC0waUMZ/UrqxDKjVxPTJ1q/ZAi94hPmxNU2ifNRtFs2ZWlGVYZ/4Tz3AUhACVe92bGy0BQBqKvpjnqkA7zrcuzoF3WTJWxolFz0yHzFgn8RvBjVD2gsbjrRMdiJKRU7ObIqqTHBe7YhWWt0vheV2a8gdaq5WOty61UOEoJhmoUrm+scX1H9phofEnoxHDHBM8Fpx75rVB5epSF7DGSAAh2+RLUsvJJtZSTtlnFsXpv8kyYZjVMUUBOCHYr5md/P5/apsACCcHS4qSdv0YtJn/pSB4GTvUM7XpJ0cYctDElGmdfqVdF7UT2AvFlDimTaAc2QzwCNj00Ucl6l5Z6WNADdlx9xhS+AV16oLF24pw8V0s+4QFA1MbhDMbUuAOVNbf5LRonsCWo2MMGeDB1F9Sshw7wj8Cw/wM1AuJMZqDTr5TybVLlCpAMph3hcXG6gEjvhX6OMnlnDxS65Pd1FgIzrCwNfThZGNs5Wvne/FiWkGSqApSzer3cVdkYe/blKYDCj7nbGwqu7P5ZEUhNv9Zz5pGbL+RSqtMt9bzYmAchlLCpS3zsV3/sgo4F1VHrpg/3P4L4adRP7YmbT8GRN9IoIUqgBCTYaSZ250Sg7Prq07LXsFPkRtMm7ImEew1n43ngd40tBP02DCZOk5qf1/3Nz+GNvpVEkeXt1CaGj0gERGoAuTU9JZlXn+yTgUFVpg2W/k/2yWjF4/x1zG7/Vj7bCHrN9Cf6RGBYJTlyE/YoL4FAJB5wa/QdiHIfw26dCnUJofTW//iCSPz3sGq4hlXz0QMQ07nxgsp/S3BuG++xpZLYbYxyvpKokK3LhI1bThuNaIXGfS/5B6HM6z6DubFHXPBCdPSMXulusmlxbT+r3aUkgdvE7M4D+5BnRApgsia3s16H3o5dPX1z8IX5QEuTaPaE5juSNI6YBt0n85ft0Kc8NXjmir+0TQaoxzoeZB9XkPv6UWlDMJFctzVGiYx1IlP3TKiwfsxYtjJgdU2pSSi1iEtbu9Kux4J1kYkMDYk47TqORhyRXVHnNYViA49h7EL8ABUKqXoujlY9Z3obVobiJ/EuszsL11FaXcvoP7pUTBPz7mgp4CKGIlJnyTIs/QYVZb4qxK/cwn9nv910Z2GMShPHktGhQrjejuGZ2DwZXoDr8TMrj3x0wn7ZXlDzBVAW1kDh/TjQdZfC9W+62olFnviUU3LYL7SycUhsRtpUx7/C5sh+9VISQaTRde0VblcjhMS79x587vpUnjSfiLtwea1NyoH3I8rQcPB1vQ3bayWWo874AEJWEFsvfWUbkHABBA6C8cAt24bguV1DByMQ76/CsUSP4UVfb+srNwqk223nY6iwqye0fFqQcMkFWUo/oj6L4ukoIJqYeGZCfna0k2NoiWczQV3SXvTUHLqd9mAXb0vj0GGcfqSaMQmqercp1Edjt3U62Cc7C2IBpWZ1H1HIYgbiP1mwlQuU4WYsLFc5rRF2pypmPTVPwmrOSGFYe7ljQz22Mt6xiEpn73Zy8Cdl6FYQvphgIjlRnCzK9hyaPOZISbexaZi1vuQW7WLO8xQrvCq+rHIjqtQGIPK5B22416jmsfnOM6wNzRsd0pvRj69zDGBG+aB1E1SUK9YLHiJgWNeyuLC8UXE/8iw6auQG1g2oGAQTi10SRkpfFyopyrOawDNQFiruRjGaM7Wb96TLPRSB4Tz5WKJZzUeAvl6ticsYEuqwFuJLlXpIKR30hneLqhoXkTpd0KqkKRnyoQtN4vEq/0oyhUaDVSg8I19rG3XSTamr3msuUR+BIShPEWDQb3pXwi2JgKzNdwQ/hKpTNG30h2bICvy0RRlyuIcC5EZcjcL3JbQT+qP/ZnQ8YqcSxu2yISObxh/CJzgIaI9X0iBqqRX17ocjEjGkxCjfs2heqXdjFtJCxUzy3rSCtmhLLjaAWluvruVdg6OWUWFdf05hsaPhrB7BxcuT7GNwKpPpKAtC6g7fKP+wTifaGKjnFGTiQSDYOE7on0EwdwVUs+I8JViY2TEvVJ1rI3IcuRxD0V4oqalermtPlDLkuWYnTlFZ2qgUYlGfca5Kyv6q7C4v9+elczfB6u9tNMNVgOEU/7MnU7YdErgnN4xq3Vs1Orcgx9lweq5H20k63uGROoM4KA9OST0GRaGaJb1yPPq6Ok82totFMAXbFUps7pHlWSxc/cPobBqDUE3PAXmFPAKHk5KKqLzguGuJywMOwmg3XpZvph/JadWjRYWsikmMk2gTQyDIPN1YylJwsLFEmYbWdgjp/QFYeGWGDc/3YwTL5TNqg7S8EYie5pvfRstUwLEXWHfAiYu/OpS9UGXLL9ihvteNn12MVMdVi1/EwMibf4GV1SjaMfMufoSn1SyRjN8EiU5B0FELTvmcXcx4lOEVwoBVBL2Q692i3zK3gfpr8n32SFcnjLb5gYOw19tZsuIQHaiNf4TqjbjrnQ6SWpbWfruANWhT8nKGnUWs4btkMSl/hFfwiAzRCZ3h8LKhc3z1TE6GdeIzwK4BVvnzfQ6fjK/XVXaehrPS/5yuSD5a1RX5Gmt+qhHxSCdy+xqWD0V+y9ouVYuBi+72zd/TMSz8Qk0q1Qygu+JxveY4YAfR8OI8faMr23SDUKOiNvH6bgXtZ+0ArSX7XgVNOzL/WM6OCeavioKLxpJO5skYdScF64LXqt932BUVhjOKYZ0fmadEF/RVQcwtjzJ7pGTy+rwSPi2QV9barAvyhY9zLDT0NNIAHr1iCOkXDzOAjQV2Vym5eVes3A0yS3/3rMvorm+bcZNv2KBCktI9e/Z9nLOEKzt2cE3M2tAOwRd9n8yaWSkawoMqqCRkPj+vcsQj7djL7ShUIOEvhP2sZ6Xqf6LjsFRJN5RTkviobMPqU6UhBWhJKEWcPDKW02Fs4YSRZlUVrmQCQu4oS1YYBlJwiEbvpGgLkxNHmOdzB1KsjUNUy4EZaSyDtfw2FDo/JJJTKqCNWxrEoGuFBFeqjgksLGWlTqjzkqm6rxpLGrLOXDaEGgrfmOyfN/5oPjGC/zqqEi3ur2mKGnrFxZwS5g2yUEAdxZTAspem9/cqmXeBPGYNQxEMw/D26/IOt8Q/DEjz/Vk41dX7PPO8tqFN6Y15QEcVr/smVVXF33za1Ty7dlsHFN42P+mpYRB53M5ejS8wR69J1KQc5mghjOUKu47m4QcfK0GEhtiSQTSq91B6GcGPZldsy3UF7ZjAaWLKyfn/VFRw8RblmvFo5w8r75XK8Z7UMQKsTpRxQtP+2S1XpbT1pqoDlV7PLxl4F28XR6u2c7a+8R/hvaNZtlTlbw31fRQiyElATno5FWyf5ZcxmZ8KDYQKULeQh/1PtA/JNf6NChKvHQuwR8YG2InxzSGYJf6eDFBGhEGqtR+Rs/hdKyBpJhQGY3VFypvW6yN/T8388/7MX3DhvTRjB511JRYhuts3QMhX+S74EEAogsQDmURTtqWb/qvfVKdOI3UH2QbqauGSRAkYYPBO8DVN/Z3iL5/wlhE3iZsnOH3CYeWz2a28Yb5BBrHUZgK9SLQoI4LLXn0xX7GdwgZd8ZR5QgdSOF6hbLJc0rDdlAnQnMjaSQAmHArxfRxqvUz0jil4LimNqVN4w265+ukpCbVzF1atbp+QmaUTTrjYO3o0bBjZ9IcPwlc2JedLpJr+iqRZjKXUP0bHkmsXpkwDv5C/OyliHose74hN2g0Vf0DQxtzwnb6rtQdjn/kMelLWFoXTUZoiBK1QnWNpEewqc6w+9tkvHF9j2qJb3Yo6qsSaMcLzbtGsj/m9QZ+beVfTqCyy7EJ3bfrZlfZEoEX3+Ww2Z+ghak0/atYjJUMaMq/FtIFOuS1BAfHIqnSFTEnuY6UXyVgnVxIJUKoWV9hfmxT4ZPualoFznTZEdZZ5Y+NV5k7Cy44+J0ddXJeoOxJlfF9oTy0iTJf9lSAYdqksPG4xvvhRU1I+fjN1XWwGPlkhHL2GCfIpmLFwpw2oQzV6LfJwYpIyAx9Zmn4XIFLu9qnXNd2fOLuUSlAKwvmSyFs6EK2jVAvU418Ysj+AiG5rJNxwwr0DyM3OJVFoGDSlld/pfBxL8zcdGb3T9TX3q8UXOdG8LvnEjWLdrFkgXgwDmFzR7IayMLfeAcxq+9PcXN8eWcTlztEJYMM1TcFLo7mAmhCvvnpzAMO+LJR5Wymz+pr6xLjVARoYLODZvioEfHPNRvweDlc+pTYkFmUscbylBBclQPtTiANWHBUvXiF1WPdQgXr3G51yOdbXGJuUqLg4UNzXAyD5Ycd+Nx6/ukduuV2+T4E7vVbJUzHG1H8TgTkwNJszOR+cL5tBqoHpd+NjTnNhaTnSn0Yrusfdz1hj3WUYiDUNTrb/rb78t0UpIoR3YMnOwaqftM6ltpstMSVqz88PoDa9xEJCcOVgDf5yKcyp71HGDhefTAMKgWj+7HrHIeIXOPulV7bfuprZ425uHjrom1svuaDvQ0ukAARCDsyapUHgwHpeSmRTV2FwyykgKvpE0sLk5TAI3WpQfXmjmhxQpvMFDLtpC3rGX99CypDtDnoWfZkIRzDgYwk2yDoXfHUzw3x0bppgVpqBqy+15mzN5XQNTTZGqCSaIDO7hnjjhnz9hW1OJQebRiYVWNKadwcmQn5KYeSDFPxrU31oH2yt4fELLf/Wavj+0J59FsWPUMxdizlFPwmYbLvtBFBbydkTLw7Fs6W+RThx2A5YpFSqJzj5eupCWmh0RPF367LLgpWItY2OwDHGY0E+grMOW6GMBelbW0N7UDL+Xw0Wa6PbY+SXrrk5xy0XvmocVj8olhpjE0MUYlGCa6UMhFjo0xA5QkavDghlldeBz4Ekic5+ZsCETEoCSKHsWKCTpryS75IfiSnnjdyeSe3U8SDSALw8oW6XvKbpvmCHVqbORJbdpiYXHy/KaTeIUBeEsHLDcKBQ8KZWp6pIeG+wfjCbH0gTt4ct2g3SnBaw/e5Pd+nryG/46oK9O7XUlyND4F1j5FJh9W9fXF4+OHkBlr02oYUrmUnXsYoT1xrwYHwAFC5p7tgZgWZN2B+zx4gBG8JKtp3EWn/GBgrjyFydfhMm5LFvj1SoWmTZma9L3mvj3YZMAM4RyKyZ1RGMwmNz3eL7jdkDd1Nc/2sAMMvUe3eJD0PG8tHSLAyI4zu1S1vDfWBHpXNkjK20begoxY+ve9rGCvQLh1NcqfirMlu0CCN7EPDCUbBWAZ4lRIrruJ6VPexIe0YwQ5Tcfj67tbe34wDPdlkW9kEDMai6dRPuNZ/zOAY9hae0aYoF8KtD3SswBU/O5NIO3CB+J+12y7m60HUzIFEpWMuI7ku7bRgrcviI9pyPeusmp96Mawiu2i3HG+Z1vJ+3KBh8iFVQvXvE2rBxBQ84X0MpWHRKHDiRAxNSqStZkNTOTHq1D2IJoBw6nc7UhwTGnWm9VQ0MiTuY/+sWNVp9yfri8tiEq3cqULndjbBXUrfb/Sm5UFHQNyYeNsLXRwjez2idq813+euNT+/8nkGjpDDNjFk5NRgoaEs125dzKkqnaapeteioWZNksgb/o7NFRBSgh+nM1jp1F5cmAApXPgW5pS+TXbQmfV9ZjW3GueggaeL+jQGuxnTR/YYfKgwXRdd32zA8A9O0o47fLvvQ2VQOp0TzZUekyKB5lj1hYUg5v2TlccYwFz/9uFqBhb/MpOXPEvLVInFRl0n5LqHaxP/2ygE4F4n6ETHwSBJoShKdT0NpwAT1V9/5+ESmkyLvvr00L8Rsp6f6OdTlY2uKmWYpAWoJ1MibpjKHWeonuuPEX1cEr06q47OIDVcduskoPkTiOuUL/mqr/jsL5SwsoMgigR2oR9wtsmeayMJU5+O9w1JmQZbCAdz0lGy7MZ/0HQbjvmyxk/+yGfdoyTgG2i0/tkBMw6oLAlcIINICGUMi/V7MW0oeMa3qdUnrQbXaV2vztHmYmO9k1+ARwOX+0i5i2zDt59EiK2gEf+b1c6RMWxjBfJRNxZNQ8x8CiBbA7xyi5IH5smYcaHmxeB63/Flzn0wW2CJ2X+rEN8X3qpM6QQiRuQBbi/DenPRgeVUrdM8ZOfh9iwURkduEq1tTUZ7smGzqyI2kknAEqXv8w0TPgGLhezAlbrU2x/CbEmCE8/DRytYUju1LmidJNmU5QmceXPToKIJt4gA8vURL0oVQZ5E/Tw6j+8nF8ar8UJr/kbslEt8T/ldiwoOvaBe3k0a1sOsN32FQjELnHN1HIQXVpDCGAnZj6bu/RTLA94SFTN321yX6R0y7FtdXV0Bauz5zXh8jhJOt7WTYK+r0XdXySU0jb0iLbap0OnwQ7tsm0T0Bx7ADAwHc8D4HaWB+Dtt1Xcq4Cz0jtBFQOz/Z8kzf1ukje9yxUQsG89v+EUnlriGXS2SkQcJoucU76LKovWVK824UY5vEtsk3+DPGw0+IofV0ViYV+kGOFTh657Dj+YSdZOaRmNixnk7fFJ5jNu364cKg2vEL/QRxb4x1gPXiJvfsDqdwErAiBFjlTxxCoja4rnk+UwMn+8kqZgMv+kPSbNKp0zldOXT/pEcaBU5ZGiIJR9po0c82VE04MxjbFfgxmgpZmswgNlZaxQV5tDqB35mF3dRBaDeqxOu9IZfzV+N+1ipE5zUe4jmE4ffH3iaxLRaQHF00bcc/wfKJm4a6EWIZ0vUzoGKF3jmAPa8FubKAHPqVPhad58kqcqCkwTz2ykdgC6TvobkhEuiGREIb12RLdEKkCykHa7M8hchUM2+nv0YHSQ6IgPxcLSC9SIpezo6aBoOsKKbbvemJdiPMIpABtLcmF8uLvA1JHnMuxdvQiyn1kobl2wfVn8z+YkvmTVZti2Se1dp1n8AJmvOnvOsR79dpUDVTgXf9C26krToKoGiUZfBZC1CjN91gpBi20iTjF4NffSSUIuqbttFT5Miy2Gpvor6RbheW8Rk7KaQoteKrW+SH7XKDt1/Xljn45leBDmNnK7FMu2iayLeZUFLMeNVdnh//JQUlWCxr4bhqmhyScNfGh7eOkxG5IDcvn3DXii48xjeiba//KWYiqJdXhVJl5hDnRqoOi5JDANy6vQK7gS6SBBWzLQM1wEYwfN/pqrzB+wJRYCg7CMhNVd2hGU5ezpgauPOV17KnpjNUHWOgo4SAFjd4eFGxqXkTmfK3dELUTSgB/Ov2RAfESGuNiKF6WRiH6fDwco2JxaP594xwMGvbSiLExgCF9Lh+esrhinIHqA7mlNv2qjH0f62wqg/kcAhFl3QQ/sJNKjk9FqW+MBpBN5UbKFLbMEMNDr58Tbmbz1fsnw00YwqsEQfAwgqHk8tNP3PgLIJJCaENXOcn0vQfSm+LXjIVCOs8nZM5tHTKYD7B5UBo47FBSUR/CbIG37EV7BpRK/gkUKEnrXU/ru8a8E8Y5ADfc9uf74k9qQJbvXhJpPSslYtBIQSoPTRkFh/FMQD0g+QHqPEaY7pTTHagUcPgmj5AzvU9Hc8NQYGQrXJwYsK0KLJtuLhVMq+rbrmBWg8qcTdfKk4M1b0i6uTgmcGUz9Pgtk1+tDJucnARfye1ZS1DNVbqFvJdScVcfRrXBb51cG8TWdSD8hXsRPVHKYcwg1uF31dqjjeeyHnId47fxUjfLur5ZNSef7Ix45KjGxtZGVdmDgluZP75zPuqvngip7pEz1WC+Z4fTIxO0yrat2JpH71XNNRApKOFmgBKiZvF9dvYkyexwhmUcU7Ai7OM1AdZePv2tUYN/CFTZSRQ9rn07DhiJZD0blcoJYxmZdCIXBZT7P4Qv+p8Cd4bFkQIcjaDS9Mu3FQq6S00hXJuatvCaXnSjqueXmgKiU3pjld435gy7ni833kqPQQnImYJXTilIf2L6Ft7IH6wBITvdASltiTtTOiagB52qlR5wltLG87PRO7yRTA0ERXQmphNyWYqcHfJqiGaFmirh1E+u/sKqpFMaP0ldCTSPDnol41diGi9vTx0bBzuSNPmHaKr+rjSfBLxakEMqvMU9JFh9kNnEOTKSUB0iBdcf9mGlWcMJUVQcBzRXZx4s9UJRsY0vr//Gy4ZV/VyHAMk9qVXZ18lfjd6L5N7GLnWxa9v01XcFXXaIlQpql/pFiZELLGyd+n7Mo+AEFqf1hASMXJ5YF6Fucr66Ixx3MHLp9fw16DGZpkF2tdPGyn+OzgYYtBLY0Nu/Y8X1U10weJblNuXPKrreu9nBtTy4o+WozX1CPuPWyszicyQ6gnj4t+MPSS1SI1uODHhBV0dDHvSjfNB3rKmQ1/i7BrHYZSJm0dGEUlh5/ZcGPBOonpVd7226wJHfCRqRDpzguSEDndd7baN8lA6dRqm5nI0CLtX/5iExPTF0UF7suVV6HlJt7I9GlmD5fKebCODhcrl6oc2VnrAgNQ9WBSyPDIEBDfJ/ZCy9+/BZprqOnXG/XOLsNCzXvT4BqKbMiaj9gLzVb+11kLRdw9i01Q2oeD2Lc5au5zAb5+/J6HtT03iKlv3Sfn4PGPv8YkwIEXY+q1VFO+VXuRjSKLNSVDCt61dEAza07dzkmL3UN/W/mXk7fVsKRbEjs3AnmoU6TLnAFn4cKy98e+YT+rO1SukTXloxc0AQ1HTt/RMH/v6h0Qst0HIFVm3ndAU+MQb6uNeBL7JpVe/NWYZL3H3OI9eGyrbjF5sk9Uk+WnlLG0DAr1l/gVAjPCmx3Hn5EytAJBdWV4855aRYdGflEuxdpOJitXYzNrMQxutxiJO9EL7z6kqJB43URA7ZScDZ1d0P2n1m/Fdzg19oj4ac6l1YVseFjKJyyX0sJgjQccwNojK3KRorwpxi3ajcP8HNSPrz+lL1xe2H/pSd7HR9uglDl7V8aWM83Vzn+Tbk3HFndGxsqqFYcib0Gz6qTBkjC7Jljh2A4Nls4WFvEDMkUOTnsyYEwNFmuuhTDI6EoZv4qabdJYEIIjHMSfwaQflxh4mx/9NiPPhRsvfGGKzCmXx/aopGaQtREMG0jTIclyQRjQFFQ/Kgh36Jh3MrqLdlJM9d/NYe12aTpxOoKtZFJ5jbFxJtFQr28bYvClxwJCnXMfoO5kKfmeXiE80MgrF96PmHbjYZFiqlWKrUEUYmlxAEI0lswIS61gpg4tYQx9e90nY/FBXGup1Mrz9KcY1iPZPNNuvqeetWZ/mbQ5Vy153jh9WWVbrzW+dDds11dUdKZY3bIOJVPGNcs+CelG6QVcC2Co17JzNJu/z0E+XPZeTbD/Kg6CK6PApQMlJ5jhNZXjoV10DI/jVIaykLgbb6r74IhzsiA1VurWpsz3B/+z+hFqukIfqV3eY1ZeJVuEJ2YANyjBqAVVS5S4X2qVmCFL1ZcbgCbhz2YuvGb/D3NCSkURY4AbW9T6or5A4QRudygyowoPtovmvcIeZfBn8AxLP3jbehodJBfUUXwtYUarI+yzEB5y+qd6PQVGpqHHUtEmHAG4Zm9fyy67O2Advaf25T1NIyZ/X54SzF14QlN+OLYoFs7UkCi5GbvGjecXqcyMGvs8WVrkWscbcGxas1QXhL3QO//HQDnWK7btq7/wLrqOnvXlYkDprU3pUMx8N/FmBDAfnWvhhantS38pVdYlLiyAKIrJaKB65oV54mr/Fhmb8zZAXKPLnhkcYHKEy7t2mfbE/xVl5obW3qdjMMxDs5sIQ7nYpT8ZxcoUIR9wz1bTTWnX8bh3O4zvexxJP+Ac6/SQkk24HhQoY+ma3Wavo/xt3NGpVMMfP2UgGnnTUW/4PR/fakffVhGf0ScrW1X1lyTaWQOKmaHEHhzbHbzejWSq6+if/TiQIwblUulnrMWeU3WUar1mhuSrN2VIJxcvcpOBvoV6FLblTPDxKsVtBmv8CXuHnk5iUzqCtbl918/MTXaPmaJSEL4kZf4VpYDSN3d43UbTGdR2HvCWf5JodSn9XO3EHv8aEOBkGOhBBziERsWNGFT5Rwz7SFEyqQp3otBp0qYHNW97u0tLPVu5FKoylWcRSTiwySv+teRyE2u6vzvPIWlBZQUzUqiVPtQYkB56BAwLuSqC4s4PSo8k1IwWavuy+C8A/JVrui1nYwskzeFsVUtOtxmbZDLoFvwLmw0JwKwoK0cO6cQfU2xT0xMueQ/fOApkGavKFVNP9yQq6Zo447DkU7Qb3+/UMdHuRnp2lfEHfxre18wu/B4DajQhHkrfvyk5zZsuKcEQnmoHG2iDolRg6BGXHQMdbA1yGzlho5WRm16mMV9EsTGviNICxtta8GZKtWsm9eHLu40IQ495Y+xzWOK4QyFs0dRW+YCbyTN2BRD5s2mp40K82SXU+ZrwTzrSOqRQmogR8K0MT5tmBjLMB8yp4kV6LmxowdXzQq/luj26+rgAFOwxZAvHeigezEuKGxzaWuKA7xGRHaKHrrEI5MvaNLFeVEbHGcuJV47c9bOY6xnK6q20FcVw+tzQa0DHa1LqrwJ4L4sTDC+Z5aBnBtGQmPpY/sn/CJh646KL5tWbM5NfnM/OL+8sLkkEJTrxp1HODq+rvEwvnXLoF96lmrxQz9HGOBVC4+nRo49+wC18LddTYn1beH/OPqfTRUwLVhEBvB8tGWDgQUOGIrMQwlVxu9Iy6us9mcetIq/x9CstFywmKmwp3prr8kUWMnbA9ZYjw6joo76pnkAiFb6otD68PgprngZH0HcEF2cVlsJUfvLSLLBZDpnsJOE80LNwPVp+b5wAnxlkD8MTe4Y9Ztpekjqqv4yy3cNE6EwooLX+y9HVpk1nBfCMKK1t0OYiqavlm5IZUWV86f9mAzpLQo3t5YwnB71mzUkT5OYBYQ5OWmVU3X92a3cbQ0k/KuL+9aC89LSxkOwhoAxG2E8+Saadg6hTY4mDOBVqzpPvAHrbKyJbm/QJFg5OYBBiBsnFnfKo5agqSEaazpjUOHXemtQzh5jK8kumoPpo5CTw8EU7FTKmr7pOycPlIm0lkrubL9g00xmB2GMNyfarKUrR1JUh5bE56LAhoNTFDfd3xGX+MugJuUHNriXphzJsmduCJHmNap5ZvduFjxIucKL68wIFQQuBDV85yinsq9ZhNEj68hQbqUxk9SbBgnzSGQ3mE5wovYN11khldrZI4pzkMoQ/fIwM4j58iPVAp0B5EU1vtP2pEXskQe0V7oAhxOuXIZ1rEb/IeBY1mC+lpLhmxapoluX0eDa0iYdKWqNSHdSY61Owbx7uk+4/6ZJCtyEVVcjH4ob/6v7c/iD5aQBGWN01UUtxwaKf9gwW7282Z44OaYwcTajzbj/gBWxciUFylOZVzSWKijR4rcNGkEaUTvDGmySWJAkUgImCaHpqYNpwu6DditPE7m2qVGbZTpMDEhKH2wDlVFm/8FCBzIpCteIEVJRatusfvY8NGSLt2HjrPo/BBuaiMcL75VS7tWHQ1mtlOQzDpDcaB65cFocy1nPb9rVl8TRIzdhKEpR73Dnzb4quNBiSw5N7VVPHrUvxrgwjzBYOmGJeotJ3L4JcyyFYlm2oyibDkPCOCvoM2yuPFBIUpGDmoKGJ6uyaAYEN+0d7dlv5igwz8fFJn3twb8L0i8LQT9chjSyaBlc+0TPRkHbfM5TXvXU+B3KSOeeY4W63P5qEynJmyq3xpbs1v8kqwWMhT3i4n5oU3cLtiNqvcPUAJRQaILfPhxAfqbqwP+EKDpWQQAF5PpzvNGCBoEzhaKV12dp2oN+OYBN8C7EsD2YwT34jG8Ca2d1+EFxppAH4YGBEbNDeyIykERWP2TpsbyceSMW8AmQM+af7laoA3Zms/qKpLIwD0AVhqtfiVjs3WpKA3qpGoQ1yxGwvj523MLpSMY8fSTCP5wlzsgKv8yVh57V6DJc79OFI95oRWx8CKzUMCto+9beqQH+QwLBnKswZTCaBapcHLIEbREWk1fHwd5szA4x8lefMYzR4IBgPOp6U649nB7Nn9OuVoh0hFGiSnd8F4CZVRvkJ8GfMh5QkphI0PRcxsAWOPlQgfkBVQnyWYwvxeQroDofCGP9JyOje3B68Z0CCRcgJ1NLtzjK8ry5s8zYEjm0pChlivjp9kGZyZuNy6cW+z+SlgF2TchzBVft9auHRFFlS3LNOL/s+dygz2MMFVNb0cRt+qf47X64pWzhNwAZDDO36qx4rx8Yg8wcqQxtgBZDVP3Vpz+8MTa/vRJhk+hnxCmYc8tleChSOgVcef1g1S7GsvRUkTYQAsZ96itK82YzJn3jolGWktyXbpJyj2taFrWAXqa3sjFAYimx8KiLYqI63mb/nvA4e42iPl6Ebbxn5OTQ3KiKBA6XbJdDXYMvYgwJhwwyYOSgMFBW2hseLLTbOlPBv7KKRZ50HdmWbSUEnROvlNLjkAFVTUbWpy9n1gFnXCfofXZIJvdqIRWmvvod3zJMNhlzs0AoaofP6ecZFjEEiBynPL3baSkK9do1A3gsXDoBPj5IBv4wh919zUfYtqeA/byGsa6F7CHrmawRTGAYaTIPe6hiPi6Fv3sEkJ6WGL1+5DasUwednwNz4/lfd61ROpt2zYPZwCW67RtnKjNBN7qpubmjhcKyVJnFTNgycuYObevfMhpkNp8GDQdmIhqx9p8QI1yn+6QGfXMAdEZmg3DpdtjKdfRKIzYSwr0uHBQsQM9M0GZerSHsA2t0uGDVxMGifN+VTOx+Te6GQKO522/He0UJX7/a0mrCUxTVx4Z/db7CAsIGTdmHCktqGOouY0yEskAIzZKj3SmC66iQDtMoH5wqNZpW/d2zhTMAttLolehPx9DJNxd8yn8MNmvNwGu7N4qVImOH4nAa7vJpLUcWr5R/R7UufWCDnSDu0UlTpcLUegsCe36exBUPHLLMgR95ow4Xrk36dMfYgcD9phI7FX1BN5aebEpXYdZ2uTMj0G3LrDSqvPx7DxsG+PVSfNMhmB41z+/U1IngLE9/iNyEQuHikB1gdOK9HR3cREsdnCpVqzRISPhaUQl38qWOJs8gnTHJBW/FHbqBeulkkhsYzQzbWcYqtqI5gRdCuY74xXLNXkIYtGqSj8XG6LD5+OJXl7q5MfE0b/0jddw0DT1QW2eiVFtGRq47vJZiWRrpYZJe6wNiBdiOSTQIVkUBSePmOJXq+b2EKZt8ovB2aam7RIHSjgcG5TtBhISGqB/rtUVoh0HgHKVbjLBUwEY8MM26CvahiWX71qxS67TmGerZXVyGsV8/2n3RP1F22/N4sqvKJt/S4RJNk6fU299uL4orC+nQWmGPXNA6VjBXWcPeLMJr1Ta6en2H9PsIRHDG9xtLHr0qFYilF+oNnw8DUgsFRsmSi1TAERwp2+G59AmRJlfw5gr1+G5R+FPBY2UEGvGFq6tTXLTdTKFHSDSccSIjsvSfjA9tteJ9KcGdY3cwa6z75BnnIexSqrzGBuA0bipVh1i+Eec8u0hT00HvUpj266fGOp6IbluZjLVdbOuy4/zeO/c0klhzGZvozsnBVVaJNUxUPfwrb9Tl9ofuU5q2ToLPAop4LYpjl68LIDj+DegND0GUOMbWWLW+CUr6d0E87ef20epAhP8VrvcEwnd6I6RCW5S48F9t8Jn9FaVtcp3yoS+1rNLMk5YBu9xP1W+FndlItCip7xGZAilBdSPl/PA1yBbXn8Frv6M7ndtvvKvVTTW3fiDXe9Xs3Zj10J3R4lRprAPAKFodiYV1jil35LkdtwlWggFnwHIjD/S9XP6JbETw+qP+L40LLSEEFKhA8wYeN905RN0UITP8IjOuAw2hx8Rkssc7EbuQi6BnvSCSDlBqF22wK265c3O9oME0UZELUGen6UX8HzAjorawgEEkGGJQeuucUE5IVXUGD1MPWfBZhrO0RauCkI6zvYlomvzr9QdU1tXcvGnFPR+dKrEV0i+IsX/b9FzQkOTbgas8ibYmf0RyR27EFeNvYZSuBdEaCBQpHdeoOyGoLl+Au4KqFpkl3oBCn5/Gbr19XQmNucfelgwotWbFrvabcZCCOQzzQNHvxrG2P2burL7bVjS7MxSqCrXjUTTxBBwEnpvc09mSeE3on6+2oAUbebZzwz/jlX70fPDWcXM/LrD1R0deI/qQc2fmQ1maK3LpL2JvrCWm6EhRnaB/1rrbXNPLKKDD0eITOPNd5MW2Bnvl/wU1c6RGwujny7dfAtteFo1LQG7+LGY8sOnJ2oTQt9KQpmi3dBYtvmgraU9+Q2/1yetXN7xIfq1SxAoa9tT+jxgifxn8490Sc5rbZ7QMCf+v3gcUg5uOGF32NR8CIa2sZlq5QTb04OwhkJv1WVzKeogb8o8eEHdSrf3EKEOPQUnWaDueAWsYMAJEnD5QZiAJWdAIeFqlEeAWvwkANKaFS3hEJXRKG3hDmBPKfhLoVNkjmAemD/X51qw2zBbGrVZxoNuu94va3h6VMdKbMeKHi0dSCFuQciqHNN8Dp1W7eLiLD6aX/Q+MVCiA/eUhAcWVV1mpBUMYSL8XwDN/iuHa41LhutRDASU8pmDOm/TW3sGOOZ1zI4P3iD+QrRGm48DV2VKyuaZEG547K8Y++9BQtlA0lyAxmOkvVhwKSp2j7+L8NbxtxjSQLMRaIG4qUDuK1dzya5ZTh0hIFnrYgId9P9yNvxFZ+JGNSDLTZJfkRZ0G23X+Oc2ZHVlWjXbWNaXx3GbwMQskNU4JJPYarnRUuy/Y+5n+hbFQSHJ69ZoQREYubz8JoYAWKkATbYVl3L9ySxrn7a2t55rObUrhx3om8oSHyDK3iAaPaEbwwbLIj109ya36YVKJ6fXl4Hb5fsbOVRMeN4wHzI+KhGkT203uK29ZVv82sy2oE/jNRR5PgugzLKnnGK/zph3zg0Np54C0Fph1MlvW+Wyx2G3P4Mz7Ym205p715bIvXEjzVccA2wNZNGhnuCeskLGBIDSXDwaxORr/0L/AxvIzzlVtFmm7Ea1LNl3Jsp0xOJOlP5/xAXy+kQPyu/rDD/UJncy+vJVbXJifPeaoj/xH7Xam2VEQMMLGtEO0PZICEo1tzThe6thV7ZUyOWJIz7uGV6BD+pKUkkthjpSBhLEequiIa4HZ0+x/wgL8/WtTnQ2xpmIO+wEiOZPHO4whS0dA5t8ALgIbKc51WY/B06qEDOskcEJwuoPdZ9uSeM4B69GCF5tDQdQ2XJQ2GvO+GfmXtQk5BROeKqctq5GyWZYxyzytdmS9sKLE7c7ZQNT/q5tPShCLhMNm8fmwJGezb4DBjDjggUAqqIIL63eINbx+iXMolUi+xYoff5wHVqg113ar88ne1E41gjgotu6OzMYLK4/HoKT5MLoNmttKvu5qhnw54C9Ja0rlByXvnLwlKWw8UbxzfLFlvC8dHsonMhG7TE+BzoHK2AAE/MbySSP93/Qh2SX3ErWXUBYnYow6prrDV5Q3NR7LNq4afqMVnY+W7tCuXhTFP4/sHDVT3EDjz7+JsivfBQ5ujVsU0aAsXheNcgNf91Moa2m+rRn9WXlPCT3+jbJmMATqDTpXloWaJy7k/eP5mwM7sMyM3tVoPpSguXEp4Kpr5sq6TykwY1w24FD481gLf7cpRpqm/O7Hke0VtWOpUj4rIhb+jJO8LkSSaUPWG7d1f3ASIwrvI6hTY5IA2Ynk21OZvBBqsOFJlwaTDHvW5GvSnURJ4QfXgkk78q+3XXlqq0cylx/ZyjOyf7DrKRBfZhgLXHYXcTnwdx1bNfQZ1k0LI7fcm47VffG/zX6UFAb0kw3l5KIeqae97JPsT8J2A3tAD19DlwaKLR94oTZQzFkE/9MT6dQlnxy75OvTX/Xrs/OEYo2QCRTRBEumlfQVRrCXeLxNiFkVwNP4dkpO+iiDtZ5I6dmIiVJh8w7eUH0/28L+8Trw8m4I3S7uOjvFG6YPYom0Xf4T3SqiErxty/6WriSD9VnvjZLv2JEAIHwit12ELFXe1OhXY5oBU6YPDWw1BjcVJeAUQyzhndGz9snb7Y9IpGpq9Uoz2MqQf7gUXrVRSY4mdFFe++/ybVTk6LbytOOhn9vLn8JXhDwYFgA2NL6E1aHLfjszmg8Eke65Y0S0Ct2KHgC1M+OZTvn5p0YNrh7e/M6lb5S2zw5rBEoUtTmRtArRcCPTI/TiKN16t9rppzrh+ul5Bv12Kq8Jzn3TmeR41N4Adh3tt7piB8gVXSOG11DRODAHvSc4wJVfAPGYaHrdpARWLZmrwXVX7dxGbq0muePmVdGsfkaP/F0MZ/b32oVc0dRkrpSXgBcPo+2Hp0Gt5z1xtz8mH08C8FbpA//ZmMgnOLQsz0p4tx7prLvrsL6pkSmxnhweuGj+A/pPUeXQVGx9sfF5vra4nNj37Bvtaq9TgokALHPpY9rn8iUMSlMBNE2g1G0Fz1P04QX0hiRwlMfDWyqGdHLuKeWMCa/Fc5A5uYs8WmXx0SkFghy15qNzM7K66vSVbaMXC3lMoRRz9XG0Li0Gv+8krytRwl+ecC3I42FroqQxq0DjRIJi9lNTeHsVSRTfWkKx4RlQ4GXEg8ATTjbl+8X5+IcgDyZZ/iVf8JxkNIVT8enHZB7R4aaKsHI8nsI9tQPys8zXGcCFsJGBkNZk5RoB/pcqRnDB2GpCaItRqC2Zi5M22eiJjC8bKZi0j+R0ZRbzy7giAROd+HTnn5g7Fg3QbpyO16z5cEbBtcuMot0ndqPIx7kiWktzVCXay8JLmXOG9hcoziBemOF0BUw5kd8eHFNaxUTuQUBLVTvLtftD/3qBYBgCI0gBw8PBluMUxArOWgNC9DlwuEH8NoVFLWmo0tgY4V5fo9Rh+LOObsOXknqqLnVv1FSaVuQLB5eD047lAAX4OD7wdI1F+T4xUXGkbsNb4OPUm86NmYk9h48vRF79bOS7TdcWFvdmgSEzwLlYNIZnRCQC3A5oIIsaxCBRONXMPPBi/J81PLdsLIJC5sXIHQS1jRA60oXkmwfkWiTxrpXqu5WkBoJPuJ9M3xDoZe1aX7J10mWzTc9gUMzzNOfQ8FFCBlj6ULhaJv6fBnJd/+Dzox47Hk6v4pQanAKgTVlOMbtxoLRVMDtoxoBjtwhpr0G/rRKMffWR0XQ4hBG7YzgqnM5wR2Xh558TKmM/rriC/XIWBvg9TMEMdx/3bLZWBGmM2RilKa/o7l+02WHA7snPabxY8cb4beRRXh1MlP0IX8miVn//VEOdsQchB+desExQ9hi782zOk1EpAaWd4HZ4HUcF4ul6VI3NC2C+1dwGC9TbL07WsFPzToNOSIbhd6e6xe4li/zJevvDKxk2UBzKNt3YG5Yhw0maXkSBxl3ZkiCKeYoFVgxGg5izyfFivH4VIXcRrypwpQpJszpvZCy0oxnhcTSxH5092FgbZclNb+d+zN9It/EreVuDrUw+tJwb5Hsr5MR2NHCrT5sHRIVSRzpKoU+bJKNIua99RhpDKZZIwFS4lB/8qvBHPOvTYcigqd+rhtjhPeDtyuMEhB6/D3DyM5PPo6qb6fAPj+Fe7OgwXa8ihWuNnljjQHxZ0lr3E66ZBVbloOQQ7TmETWDXWJMy8L1hcqLxZppTkMIWi+TOXwL9zlmQ/XUnH0ttpC5Xlgd372p5oVzzCvDE6GVNLmRyAUQnYacxS8ZFw4lCBdQjZnLMywN5XImpM0/NoIBh9L7pGSIYDehyuBc9Welboyx6Zrf4n2jlujx1Yc+hW8nd+PIhVQHJBrv6QK864YpYh7da3Avjf4lA2bsOyX/U3VtAV5wYFMs/P7ImPumZ8Oc5spTK7odqYZz1hODFHto3RDAq9df0FWazG/Jl/9oEuKj7Fu0d0ljNVyvO+hrCwUrDd9gA3F1C0+gm8fLpglDEkTqIzHRnmHzyKF0hncoHbI3GONtXFgi3E0v6ZcJW49B/rgcNDUwXs3JI/Z1KpYcAWtnLe7/5rdnOfHr444GEw9jxBgXsO9JI+jsGSAqqgEguHbUauNu8AmgNEzu7WT5RaSf2OihxnLG0/P2I/A6nCwtS1a1nB+SgLP5UnZr/CJXZ4H9nw3WkLSB5rS11LR0vX8k2OVC6ZAF60X67iDX6oOPQK17msREZJyD6kEHWRA4yy0JFxp2vG65KXOBODW00xI/PWqJfEVu6dKG4JRkB8xTWwTrDORqUnKVPeApbqbJKe77Enebv6UJ0sTQmZrt7LRu9kqohk3sZUEotGmd0O66F7SgzL421hIblKIlwpn+xQVjXUDrF+iiQHS5Gcej1Z61HiPWolz5Qlul3/rEWs+aw5Uql+3o5/tmJbVGHWUqAyDCLPYPMSx63Db2OQ7z09RYlluW3NLrNbZFSNXqzwX+p+bS3dIkXracq5Tpfj9KlN0QUaC7hfmPZ5GppGnm3/1AOFiHGimXwEmCGrJ1ShWW5sT/zD+r72XdvaUHbOHha8Cgor8aTh1oU1/2St0MSVFBWQxP5TQxdx2/DGED8UibkPZU6RHrdB8zF5pdh1nffxgJkuVBL9vRqCBiUG1camQIKYbsNJy6ghaki4ZvcMI9P5TDezTr/tDqzrSf9CzkISUn2hBsnXXwD1tbuF9XexkzWfCBo5alX1xW9tc8zcyoS1HaWdpjncorBGgLmHLRYmHgf8w3RAEWN+eVPXWRCwB3BqYYizQP6PRUI3Xd+FsvWToLDKX8d6XT55ERhIen6drYG7rZZ1AZYMZ50AUspGaIysMxOTGN199ysA03DNAqWFdiCJwotZHIQThpxG5dFny4z08UoiXtrNjYtNxRXbvywzFcChP+64NtXplmMqgYRPl8acHljhecdGfQdS3BBn35k9y+C14HF6OyfkN+AXHqD6jRLMuInN3RKidmnXP1qfphjbZgYEbaLYegAnc2rNHv+sUgTG6H0E0SB42w/Jd89+sR8EusTByWIejfXNpDob1FzHoImlV+FPBPM1gH3ZUN0dWWsd8B+6xbNtMn5qmo6V76x8PTyn31QKChQps4mAG0D5OnYNfy6WaS8wOLOWRQi9dw72xErr89TkMhwvu1amXUWux4SLUx6lkS/+G1vF4tl1EdrYO9aYX3K/AygY8qoX0lo+n6XcAAaPq/dHWxcmSGXamkOs6nlLbDp2x1JlLjRIgZuic8P7fzGWlfD43GVyCLddNd6K0g07FPXqOS1hAXRpa6Y+N0BHA8NwduKfQw2PWW8uMucN1FkSO5DZfYLfvuyFhplb6HqG5dHV/DShKxYLK45hUlVkz+l+Ud8/ty4PFIgEQMkwhuQUT3kRuJGuVtA8wv7Puyewjjykl+Rg1oPjZVSixFS9+JRqr+2fOHmJfgvxa/Uza3++NceeKmXHElf0712hlcuUEiS/+I5W89LFUoLpNW+BdTte/BWtrMpOmAEbeWUY7q+m4X9RWh69TOT3wEh9AvRyPWy9qCeifidqHeEbH2fxUjc6UF8AC2NCcytJrrzdFfnedtWVbZ0iDybXeeX9mQayOLVNnLwNWaxVhdmutHO6/o+OXHlqODnYsFtueqQpO8H/NUjGDAJrbxNEUhc08Wkl1kigT5kiK2oL3pEIiXIv9IvTZ7/g3r9mhMBdbgnzYNpNKsUA2XSvOd9ajPKkZ9on+YycDQOnufQcq2IC5ZbJJw6ZdG5M5991I6c2dwGQ1XdrwLXKth+NBSOcUoQRLu8DmW2FtwAQn46qMCcUFr5rV8ByTh99T2cWwJN4tUGDiEMFS6PUujIuJI6dveMLoqbQOKIqnc7B0rgb+UP8S2HaURnwY0dLApDcAtSDuW5vDXoT2ba4oQQil8HgnfXzyytMCxty8lm4fXgjpW8AIN94fgLHm1LxGvgUicnemhU7zikYI390zc7G7eYszeVG/C1b6FG5ZT7FMfpmHj0F0cqeKYfh8dnYwScmC2X2r1UCTgVwdRB6llxWsqQefnt6z4teSEjrU1+5y6E0hdh/nGwE38IubCTCIzg0YzaJkRo1bexIq7G2C4mlDsMT6lvczEhufQQ0XEPy2MQChWmcRWACXY7hj+o8X6Z0djyb4tXO6xNG0r2Pb/duDHcc4ghP9TSAhM6QsBg1Nvcx7ila65llTAcuuxUvH/pCFsIt3UAQsv3+Kdi/mRsCx5hoAfga/Gt6eO9k3JgkFpKkzn8t+GrMIn7YtZQcMN/axPr7Hbe8hv5tKYwnUgRBB2TvCGl2COq8XVF5D0m36q0+pGnlCWjvxG6LBTVuPkvrbtu1PpM6N5EHPbkqPDQg1DtsS6D+kVFf3pmUF9UeeJmEBohdw3fLeklfzztLvo4Er5F/v/jqhchmabiNxxV8xCIukscR9GFL+wXJG+mgRf9MIJa0j2v7pmDJhd/84TLb8iGx/NAkzW6MHTiKWtk84Bq2dJQt/28NQhykXU725pHLFp77owlS14hu087nJb4i2WbXfVfBwOCufcPFiZR/EPvipYNkc6YHRWDDar6Pp+Smbc3TD8uvueCJ66cHq98n4U7YxIt+Qs9KY5iSask4I8vUdI0ffuRAmqv7HhrWsq4dKVAXSBz1lO02OFKQXbtHCOw1xMjLgElncYZIQrUOKc5K3usxCPmRNLCUZnISo9qoewmuCcEpSfaJpSlRvbJh4yYkf4Js78rnn/B8a7l4TzEe4j6mknDeMARWxEeuaUGwCKJH095vrit+i56qTwFaPliXa35AOscae8PVBWsnJPdvRQDQB0nkA2C7T7JeYA4guBDXpHZyC/8P/wJW7NFO906kLTdV/U+FP3ss9D20d2vMXtAr/cBAY1hy7CKxTUPk02CZy+VPLNF3K1Jq0AoFB3iQJq+KcMrDuVM8zLaydRZxAcp5ZqLMSdEm0J3GV3iHUuxzRqyCJj85disBakt76khPsNTHVc3GN1vIzQl/awBqZesl7wGMtvtt3Q0QX2txb0h2Wpx80bB+uhC9qYTz8oKw+S/V6YUDLq7D7JukTJ8P51GwRfuRU6mr4B0lBqCOnHkJVmu1BMLnt6eg5HfK1d3OrjPRoZ5DJwM7SnUNC7Z8POwRB/dGcPWOdEk7Hbu465qPoXYxm3N+5KyrBchkz+lr1L8W4X62ATnAVdA8X+es1gsbFw/uWI7Y1jJsNZnLuoEPXGzNMhOnGv82wTUjIJbFvo7gij1VuWJyyEwe3IcqoTauwX4NVDGpgWoe2KuhADXbpvSq66HEz7yitJ4JAG7a2adZXeOwP+6V811BA6bqefNtLM7bNawSWB073eAno7d24B4z1pEG2ahr+8Lx/5D7Jfv8WQ6pq3fF67ztP8bdY2tq0yVuqaHlKWRLH+y8h16gLt0tn+ehF34OMLTc6augRcroXVPyEPK49z+2Yl2PBZO7yLgqM3G87mS2tgyQmbQFAT4PHCqySfEtaAp3BW0oSwyiBC0I5YbRun1GrdA6X1tIcxCzatSC2eIvnRb1VVYrrzbRe3GpniV4BSbwgyPYJHP0eJsG6RLwCee+BX4hglvXbzrpM69XLp6hSNE3SIEHEExxunK2cW6jiGqF7fhdYn8EPY/EZwztr60cJ98zdMIA7WpjBKozzO+6sDnZQUfnh6o4x015htlTJHkVc6S/E9uUIToySFB6oS2nZVZwypfmw9oajDHvdkqpCB4xaxGAmmcL5Ii4RvDA67Bm0Suj2SXrymJEXUC2eXmnRYtGt3Y5H7M9tYC1gMcCFI7XMmKNRwjj1U7ewHp2pqOsMLmmFmcTLylrygXP/jRkq2jH6ijsx2Ndbp6STsFm9+LCI6DgzRdYCiXQIwmkWME2oFstNsHZ4Zw7Mexb/dtMoaUWQGPQz183HYqInTxzvOy4KLIYOzvg0naRN+fgSC3fnNs/TxPvpPKFv3yXOZ3KCEOGiShZGhQmjpFhYiDkcy/6nWnCIePphQeQlWwEeo4dIi0bygv9Frp5UivHjT2EYPbDWqyg4mgmo1mBZ8j5o9qri5NczcW5kzQ+HngnimomN0uIsP+dNP3gSH4Nmd5elSTGvxsfwtFa5iYU3R5PcwgGWCmyUnq3Li1CmP22bZidVkXwWkieme0AqOqKE/qfC3hfoXdfTPtJovlbHrmEj88HjuSYmV0v/yBKYnm7rdYR0CQf5uqvVwZQl93tHGvO82VbRVDHsOYdfaZ9Hl64qrWUKlAnQgjMmSy41NBrYoliM9GAmQtAg+hw8JXvha6R1Dbddv04xPpnIX0G3qIU1BQdI8AtFn6xcPEJTzzTOpovijaYgYrmtrD6MRsIbVj/Nfh7kcEqQN4w9wkLaqVB1frTLuEh29h2LDvjAiHwsW9ZD8MSQ8794HbC5ZgHc87VFrZteYaDJ3y4unE7ACLkcyq+k8KmxtnPW+BtZciGtkim/4NTgUYgQhYCbpM+OA2rn6I316SpE6XoLKAGJ+92Vc6b0kh5yUDekqb08DJi5oTB9b4X5n6eWdqUSyygoWJdvZ8TB1mlsnwmpHhZFnTaYyol5N7b+Js9LVI27BLF5rvHD/tmRwzg0HGTi22l2ZrRFH6IA+LHpLQV9bwRizFvrB0SM9klrTeES/ersWpNX0CW7H+xuISsgvoiSfYJbP3RMq36f4iIXkKuqW0pKP05Uze7nNNo6HTRWGdmCeCWEG80hmTl4Ou5T/zDPF22/0Fc5GD36CHeSMcYwY3r4Q43ggAqD77vP8OZwgY3fu0WHpAHwCc146S3UP36zOcJG55bH0lNcbeWac396g3qK00YVL1Qsuh87qs/lWjkN2dauIDFUGxAH4+OK2r4L0EHgcqFE1wG1iEx3d2QZsK5AzYPdABpwFuj0fcZ2I3yKwzBh6vj6e0wA2uBRY42stehjxi7DvM347BxXc5b4+EBMpyAiAdGgue7PjeAgxEVah69fx52WOfypOYzqXgSzu2pAVOXa8qw9Yq5wLJZg6RNVV+aUzZEbwLWT4PLSirv5gU+HM0AR1bq+zWp/3WNpVQGI5iSDOrJ+tMm6DH/JCqJhRjIDr0sZUcW8GHBORDo688hg9xsHQJZnFIhj3YVEMqAF8pFPvddxqEXZEgHZeZG8X+PkWFjMVQ/4rd3d61dfBKohZHKUkAe/4KD1+/vBsv6aem7REFh84hqrNamg7WTJmHRXrRsCc9fT3P4pD885l8cfZqJYheyjMnpKzYjjBDbuSkAjKi8V44uX6ZB3RPP9xCnTbiz5866AoWE/fyfRGuwxnTx7VpykywR2LAy3BChhKoSTr1KppIZN9TnrqmHzbxR8m6QstgNXQcGJqSU08WHcYVDbmctZoHfPmXxec/exZJ7SZZifOiNM0kmUKtIbjLVCgw+VYEhDwfZkdpCoy+NcPF51lvXtsspUV8jrsUsd84PQ/IqyfXR66aJXEy4/PDDn8/edd6xQrh0Msg4AZYING2rT8rBwK1B9FIfmX8VBotNTMeAyXGJNOuDy0acHhXFnONhV9SpK4KNAPzBI+R7nnBAAwenbnI51CdZdJmRipxN6j0awRYrlWSZvma7g6AC4fcfYsqeLQ83Qekql+Q7MNuLxJgCr3fkQrpBMSXN9C49KiOwzXNJBPhHc9dXuX8GHBtVM88xlMllxzVEnQqU21NYLYdieWUKiY6PdhNGIQpjCGZRVnpZ8JHG/wXE1qJOz8MtCEVoMILBX3urxjVg09SZ3Shh7e+iZTTZze6MxBGfB+/VBI8IycJRmKlQ8EMbkASU/sZv9jlexszA7aJq4wN3UldQzv+by+2+44h9pM22ptUhsGR4mygB3Dlf2A9dtHjod/8g+DWFodt4UzutIBaOW17Y/Mf2XkxRxOVtEX/y6jvLR5EJ2gb1MZrcuyKYDDNJeReD4r5BzX7DpFBXDvrDX/KMNSGOhiFEu1CfPgdL/1TyMFGcEwHYokwjrhkIZoOKGb2mP2pLTd0vFi1g9uLxmFTomw1wJlrQleUtdMGBlleaulp2maWcjeAVtqCcr8tME83hvlLL3/OpQkWKgSmcnCBVDKqrEbzcaAVlE57delowP1X9msP621xbAV1zIB2mdMbM09vAs6jTfPctoesPIQ8LgB/tKfFw9ecqceYzE2W51h2drp8/f5Zr4l/84h2URFAQJTr7A5dz4N1zYjJOGl2kXcX1hgEjpkTg+BhSTwqZKmbZOeVlRvCPcGqVngpkG+mVLGwRPWBX+sWrd7/8uOBaRlaBDsaKk9MaClOWBUx7lgvdYiKXWZTS30R130K+stU2a3H5KMxKk0jAD47RCKDPxHhtC3Ws/DbvHodPU2RlL4TSXKWg6bAqzB3JNWnLu4Kxl7prEvbZk44Dzy8nCIEq12qAHMyHwIi5ZZ9NYwl80fH/1XJumdND4Y7i04Xum6ScUhBHONp4JCyOq/NOSRxmpH+lnbalsNnMYVXtVXkbnvlSoOHEgI+yha9r9i9POKHatrG7wILkqcuTMu/TjsZ7oAENGjtVywM1++PQ8HaYsQIMXqvwIjA8Dj008vdXnsHlnfjb2kSZVIbiny17J3rI7+WuAK1n/X5vMRZPogKxPYa6NRSHYXKqv/9pnKuXbvfRK5UIR6b2Z/fylAU8LE7YAlEPd5dmZIvzKgaECoYwYM2jiumgliOpeK4gDzrqmNgSb1tePFPgI7ygwuc7R6Qbac1HjuIgxgp7MlKAonBMwXFiFnKowkcnqPRNrLpoaCaRy2vmLrpsM7RCvIDhchNqNW923iFnLQ2w/+EZauZUgaJk8SWCcGc+ZwsDGCAW3tIjMQ7+inlBn1p6FYwPSOHOiJVK7I65l69ztMHe+kezwnZSXYbJ8SVTiSyM+e+IooP3PqckrDxk2JHxN02wb2Q67V0rK9LtptlIAF6BzlSned18iA2nq6mcgS5Ax3XLCdbUADxHGwmKAnqQRZNyZx5XFgCU146W/nLlHRWgwIvnvHF49UxJsZIcSAZYB9EVe3TscEf1Cu7nGcV7KYszi54uns0tMLo5ze8xR0M30GnJY8rTc9lNJpq92MVKkxWj9ZQ9oHCQzKakENWl9IxrTJEZrwrX1Ny36hc1JLTQ5LjPKfgb49ToBR25scp6wslyl9NR19MaVPIjwDbbuIdY9XgZ6jN+8s7dqdrns42jTIBYUZdKeSJn+cqEp77Yn4t6QImZRlX5l46CMBYVrb/rQGj0uUkBtgxdRB5V4T1zHb0QKrdFcFqRe5SSZnBorp0r9z8SEjJZtVBcnYYTbkpZcDX5YOSHjS0x/ZEKLPkYvfX+dHknGIkWDsZGMDoq3YgDBqfcPn0IXzhfDl7pP3k2abClHus1ohP6IJxgheMnO+rgarG7tZ8ZR3G92IkrldC7yhL9ckiY3kV8JG8fgq2yXXIdGqUXJdDxtSSbG9BNkfHDdSlXSU15XzSrE77y78RDJoXPDnvmcT4CAW1wzT3LD+wGlD5cWi6n20nODg4Y3H+YmVDLbrL0+h/ISZZYwZ+GRwW7KYPfk0hsbWC06+rwtCcbHfH6YfVaOyrRPqbBMdHjXqWHMIjRprFgaTJKi2eO33af5jCy52SmOcyflx62T2Kz0/MidCmatUaB9r7CRXYmbJTULh41oUSZPhP+iNlCwmtEtq78AByHF9YO7tWMMakEe92w6RWMhu/qcRv4EGMvRrr4SnfjklNQGpypEbRIBRuUMrqlzsUIFQqPk2SueYv+2skFZYoT/TvLQjD+uKkguTRrlm8eN5CqN6K0ViN/N3Kcd4xmlt0qWq00K+A67dF1wdzWvBcZenqhE53LAr+lpWqIChwiTQGDnSxzkJCrxyVVP0vSsz+iUDgITgTCn86iP3m7AU/wNV3v6yilfxOUUc1iPQrThc/qTt7IOY0+kl5rIBhsytysSIQZGW4ypUrtQjdwMa+uSCH7HOQhbRNjtteENcI1nETuMZFHQToY3YM8bjKtRJbTcfIavi2foaMsDVvmNYWm2RT+XiqTJZjVoFlB/1PzJGpkpwUltlZX7wN53J2dJ6VGkcuxuceF4PtMaGrVaEDX3k0L06SdEVnsMLVgi4Et6WJmfRnRCUNaEcX8i8Q4EMMfE6Q5HpkYBKbgGRjWaOOkhfF8yTqgaXU4EUBg/yqy6HtvOSg3cml5HL2DFPSsSyIoICOs+lm62Nb1rp1ZSaA7R3TaCgJ1AIId81mbXYbHIhOqAUBge/4Z5Yy++QCqvc2mQp0b2qTTM3oQNIzKv1K7AlGNw6L09Plxs3wPFy49Z0InFMa0gXbpQNciLmEE0aIgndOHwQvp7pSBpcR7OdSQrERJe72A3KQQWxTDvil9ioVrppVLpqEIP6qXXJgZA2+g1IQDrWNFHGDsJqBwZnjeBxQUkXpVlz4XuGittR2RRwQaOhfauwOzJp87u6iJjDJw2fQxdLLDFwGS/OIO9rgEF3GvUbsFMxwl2A7Zeiw6jjcu2lbT9fEkHQfNg11Uwl2nf8ejms5ekvvJJAjYQ0P4Lijz9TQ31L40HtV/Hckl6ZH2WvTfNIl7HcfZVaWzHubfgUTVtSpNT90dwL9zFi9AN+3HHGnbYxPKfDdMfOJ0UqyNQ5SBw98c2jvxCQKsay5ZUX3JGyK6oJJ8t5hSRC+M8nIji9uoHvunEQCbPDRNPQKmpcjN/dSlh0RXm45Q5Q3JwLBdPRJa50jlvjSt/pSHjAkRiT9L/zOWE+BQ6ulfYNHeVjAJ9o7Zhs+SskNAlGz4dGW13w7UYxfAi6iBeQxafCT84h/vdQj6uuURo3KzxLdpv89C55H/Idh6S1xvGcHQgU/GNFPZfYED3nUYCRFqCHBI0N3BYD5Kg6HzXwarE9aNBpA4O3nyRZtZiN0gsX3KdmM56poiu+RJu5kXM6RTi6a8WKuBqF+qWS6X8mFTYWMntW4y1Kc5aEjOAbUyb1DfUS52emVQdtXvOLVU0vdy3LGN8KMU/TStqt+V32zijHHfCrB+nFBNj3CMtVbpjKxmaA7rackboHVR+1QOFKjomDSitVI2igxkzo1DV2CREH+iQG/bMFFo5YYbDGpb+dtp7R71A2SsVwi8ujja0nd3oMzhSYi2vILz/AteqQ+dOZJtX/eWKhlZjwl/RjQKIyHv8og5V+Yz723pP6ytaIu1dLcGIWSuxMX3t5ECgCOxV7EuAVmiSclPYYtc/Ze3MWac20Ppy358iXbRWXpa+CUWedR2hHFqTg/AeKmpPwPoUkgwLZ65zHCRdnqtTyyrA1lJfdJnZTqiuYfaNGhg1yWcTA6c9seUGkk2i/DHL1HeGUlRgFaR+eXtuQljf7SPcHbnYAcd7v2MVTvZQtoIBvca9RSgs4ggdD9rhv4dOcM087+oUcy583/0n404pv1ZIyePg6mKQUBOg/K5bBjujFQ3Fim1llnZZ0XYj7FPxzzlHWTJzfcNY5e6VXJI9mK4pqmZwR9rG67WbEnCE6UZ2LLOOYThcKdWN8MZQ2g5+OwV8aGPCehnio/Sl9liDhCw0G5RmyKPxGchM+EheKiYiTy8HNJfhtTxG077UnLlvi/AzQROFN4jCemW/24NuBvp5HMX3xfZ+A1wogNn665XbHTXeu98VwAGyQntZdEScdg8wcGP4uyoHaRmZy6m8GbpKeTIVV19GgLHverPknMTn3+2qIUoESnjZQu9pjuxLT3wmqOYgrLXVWdTQ5NUXGSGzmgW97jTByyaKb5CYowYA9IJ7mBn8qm1HYk89Ecr1VEUivfrW7y/XixeQGHHf2+1p27bB8MXoWAYdgBm4uZiK/voYOI8AgU8pZSebGI5ADGywtEbb2CC7bVSjVYA40sb9qai0VIPOOdBRreVjorEPisvulRP+DrJ6E3/2dTF0NOyiLZnMoaqkbE2lbiDtj7opxx25RFstLT+nG+qjL3pJDh5uGn6L82hZERvoVr9GVcJCkogCrlyDJNM37WxlUvvDVfNJ66cwf2/jmaZd5LjhCUJ2Nea91EQ93CvHO+YBEoKGx7tgm2bG1q1xlwgzfh/QtfnkREvIb+MDMnKKc7nnK8ssnaH3lzBDlO67FJLGJJ6dVCBjPXD+/G5Qva9EYBl1pgqmwIZ/uc2Kyjui54J4saTcAJybd0MprTm4sCh4jUnkb6B+z978o1Cei74EaUEJi2N7ZY8bFkKLruVOdEJP7lHsO7TOciKYe8uiPa9/tYOqtHx0q2cA9ochqTvDAqSkA53ddAkE4oFAh2nwa1ThbUu1+iGGx1EKXk/gywlwoatOOs06ahelhrX94hyEFb981NA2Bj/mxKTsB1JxgJFzhzq5zvZ19ekvu5hCkwuPKAvu9rnwyMv9obtVmxyn6m/qhbMQ+tdKAUFbv/91HUORCUBWFzoRCTAJzxp/tt+q+pKREjHqnAHCYdztl0ol/Ec9hN0BZPqe4QwbwexuSSTFAeFojBDmxpTgYV734D1lFFsRz321TUB1nGwUeRnLLlHKwY2Tv+h6Pc9xNEbaOQYWTU7p6ZNA2YwSGpQH2oO9DT7gS/AOr0/zCZE0FE6K9les/CNOI7gpidt3Y1uzSPULiq13n8bYIHieIwVjm9NLY+pdh+wZLr72Q4z1FEbhT9bu6DdkQacKoBY02z+l1FbC/RDVodBdb9hv1A05bCj0DXvk7ZkFv3rVqY6jMsUlyPVrnPcV6PnLaj5MEcqMFRjHCqB+zKwxpmOoxXMh5LNtqX9kgIyl8CXGlEiFBPNtC7Odnu1psmdiD0ARvYUUh82Sjp06XIDe9m5Qd9Z/lqoo+KXumhjIUWC97dU6tUDjLQFjhKdktlDvwlEWmpoxsSkB0j6gh2JVsmfi66UEG0TcveiGmzG60AUTjG0zAQsXfxRgBGS/TKR0AiS/qQZqPTrql8ATCeqF/LJnS/vFNgxYkjKoEX8E+kljR9x5HuTo2GcXpuao5WpRIL82cCMpL/hHYPAooTm4AZ24KLXV9iD845i82gPbMZNI4Mr4A5E8VYrtBJddeXyvIZRv4VwlNPJILp7RnqKY8DKSECRZAHMlQ991zczc6eqMUOmnnEayfEfFlQ+UoDhxjOiMXStVKAH9Vksv9QVce5qSIZvLcHKm9oEjkgmYhqn4k7IGY36XccHqw0nzvkh/cck+ff41eCKWuIbmLHYS5fNjepRGSBq1hsiPUlyKwQYF+qU+J2KDILafA/Qe6GyY8RCsKXgxXGL7GoGH3lO2UDYqjXod22pmWL0apEiuFBdMpPyVoNb1f5eOr34tmjWMGx0yRx5G2omo/tvXxe01RhrG5ny8d8yvEJgDlUse+EYJtFN5wK8lxYDhaiOzV3mSGZhqp58E+j5pnZ4ZqojqNXi9EenUCEqQi9enJrQlln60icQCmOW8HeKiQrIFBSiRkr87EsQy76/65sCkgtW4sXZuDUCuT7/tkTViJpiIIMzaIicwNP2phrqdAlVQ+NkbUQjyrC0nlvu3DH6xJiw78nJUqVR9QlCbOpqM36fHpEtgg+7vh3WiEbV0fuQX8LpL9b0zsHuvfW5gxypDCE0v6j3TEPe2vAqI8A5Zb7a8bx/TZ7rDNsmMKrqdsyAbBhAEfdGCe9+WNA/kmC7zCWDA2+hrX+XPjYU7ft27KHbeA0h4wVr5xJU2vPbeIIRSJlTjDMn5NUbmfs3a/RQnO3rKrZjHGHzoPazMJfNmbIOO4/qXywsI0yNj8m+J1zNj+05CMF6oQN5f4WlhJX9uIh35iPhMhD0qj/KP62hXyZeQ9W1FB++VNZtTu45JqMrNcRsmngaVH2W8VM/l/ESupW88MY2rWDWs4kEpuLQQnGs3hEfYH08PMpLIg5wkd0gwu6p9s6AgozmZmrnQcT9YM5L6XkiVCaobFor/WkMZmSt9zzEF03i0WiayaE75g8vDHR//TnquwvV5xeILmePiGCd6Py9/XJeNeTsQmkdTjI+hoiUPwy+zlKjc+avFmGt/td30zFEKlpyNhMJ4e18/jWWua/lyApk3GeHGo6sfmgWvT4uJkZGxKcye86aZBDFbZH9ASA1w8quYQS4Z23Y7HNxwUIxjyIwxSm0gsfWQSriNETuNJLUrapBZavnxHerc/tLuvwJwPewNEvtXC4tYiGJK6sG7y43cS7kjcUt7wAoSfrV/sjxTcOrFbBYAjpynvjhWRHEu71Ytja0zJEfm0SFCPe8M/T5RVQaYzh6EujMdJXaBkSPDYeI1l9+9tLFGY76WUcUXlpN7doSD4e2obCqSFgZdk/ER6+0dShLgdQnWh62cgWeWk6c05OpIw16m2YPJ3H4Rx2G1PbVefS1cn3H0opqU/RlZTAVm8nsgrnMXc/22i5ajG6zqjpKyBOjG9W6NWZigBuk8Us45z8sphtYIPS+3fJ5oWEbcxlflLOjDUQ/8LAMEcwkAmP4RiAvwW/JraI8kZRYn2iDecfW52/GKcY6gAv3QVFeQXO8p/RNMmp5iP170tmS98uN160CcIav/vO6mZ323chp6Ur00hg4yVA9rBuFQiaXRqLQAQRW1CJkKSYy/7NKCgqrxU8SDbmotahJtCPZmOUqI4dtVFzp3Ks1O0h1oTVji7okogBHKso27+rt2imOCm4jWmwvps45k7q1lB1RNxztvCmfUYfpp4OipzLoywnynvVqe6SVRElEGf3fxDdHZCxTevFv3EXk25MuT7thHnX2c3TRbFnCnUUG49cKz+Cza7vVqOEzdhQQ/DhY09G0xM5im+HwIU9bha9zd2fLhv9O8WEhyktMek/Xhi0z0j/vSojIZ0XteA1KmBQDv4Fw2L5J4X5fo79AgEjLIJPoSSAbhuHnJr9+AKr/yfqiRr8/zAftLpSQDfYNcSQncsOFpMVEbJFPkHaU/q7Ttwu2WmaetPIjYNuOpZQxFT2otIHs3Izh2V370z5TbziaMa3Z1Vk2764TdPtMoZ4GYmyIbt9GQmaK44zYfI38139fHTxZuoqkpOePCz87GmMl+bv74clFTCo3NGcL87QVzM2byorVQzZC17zDzIGxld50qFeaurs/WbA8x4laY0r2goYs27S7vj9BFcOy7okjtqWdgQPsPULO85r2FjeRdl43oTn1yF7BXcfwbfhzHgz7UPFdnk0F46zrov4cEqMP8EMNwstpTzaJ1gBSLa+U9orIMH4OojIhfyEboPfBtecBWo4n+lHJrumR5vKX9JIh0OqFPZyQRI3hkQCcNGdyt8wj3TTREish8kq2SSbKebImrNKCu78S4xFSgt/9obfBoM4BWJyzJxjRFcpjN+291IWF7msxI4vnO1p/l7vdYUmGTrMo0fW5NPga7K5lOv4TWHpkbvOaWrNPhSYEnnuipuXybCVHpfLkxqISydY8g04alr/4PN+lBKJouBeuPagde2zoyimjbaLwjovEeCF+h0Xm4e2NzuUuMSft6qmhtwUoSzMTeePcS+k6/y1zOUNWfhiApmt8AfsgvE+/1KqT1czGFoJHVRvmqKMAO63bUn2R2C+/wFWEJ99bmxmfuhER8mXDyNwWmBIpA1ljHOcNfX2WZ8BtIOS+WyjjEQWDU1H5wLPex0/Gbr4rFB68D+PHHhd4MI4h3P9ySfAHp2itMlxiKbjscR2+FuRBO5XnFT3TikEvBlK1baN9P4OVlx76Ee8VUczCglW/uuW1PHIsvh7eauaQsaL9VnOky1sVMZ/6fcdI4UUGu9NnvdKEbM27BBcDwDTJEjLWVv2X/hnAADrHy5bc2dJILW8fzIvxxxKu7dGHuvsdbOesOdFkMUIbmSckJmkxWrG7HRCu4CDDZctL7gqgsYzZOWAkZMFj1kp93uK81BbYj5nMZ81kFc9/whAfIRJCak7GOByhLIByS1U7Rl8/gPqABDKS98va1wDn6YQVmeZUn57P7AinP9qoxu0gJA9qlSOQYzRR+Vdu4LlzdSqbFs10j1kQ9S2kRgfjPxAwJbUBbuPCH03A2yD3p2rv5n/z6x86f/0qU2FVQ1tbolsjqRHREBrIafQuGbdE+NYoPF1eRSe6jOBekcXdQCvEjvU60Ju0Pyfly98TE9yZTJel0vKbynS74Zxyafak4ZifmKeYNQ5aFEuFlLOu3f6AfzIYlw9DUOwRrZRsvQmNVnWX+e17CRHIhmzJMbwdpNvcw8mJX0wTPqyye0TE/gMsh62NHCCxJttqt7LJ7EpT4i5u3yAlEhYfzZIWSpFh6Uvurr7LI6w9oCSeXpCUv6kWjUIUeRvzZy9YNOaTF7RJ7CLKk3w+hKlXyxNmGGZcS5wNDFspjHhvt3O0pQLiKr0gj9mC+ew077fwkfKbZNJkSLsNnqX5ZJ7YYheAeWohjm/alnfxEstDmdU38mBr8UWIBCgwZ4G2Albjz5b3MRr7N20kwrC2h9MadSULD6UeD8B3lzLOwi5cU0YitJMWad/IcB1RuKbcHvZVn8mNw0VGBUtHdMYJokzV2zysM3Xp+dm0hDHwkiCHTSA/lMcPPSCAx47lS8unMA/VP22ZQV3F/q0/PX454WqSpi2IjIc8J5cc8j8/X1bldMVYKomonHg8gTi16pJRjB9NY+jRiCkmh5bn6frTNUsrzzcGov88Z+AWyphHBYtXWGbGk1jytcMWUiT/j3ssWDTXmiru43o8+aYJTEXdWvckf5QZ99EysdXcKIRxKV49I59BeLg+24NO48BsmIFUgIJ4J56UvgrYLi/DOT3frsOSo2Yy51HiaXvp6lGoc8FVAF+/MPkP7fiCv2z+1t7ndu7JmE2ieuNa30Jmp5vziCGkvlNVMOdQvvO3l8DWdsKOKGDTsy349Fv6T/0bJw40zM/ymBglgwBjXHRyXnZZKSY9U2fNjLRwqR4mPmiG/2O6BX2uJmz4ot4XtB/lwZLnllweRxA7QvcbESvAUk3/YnVFOyHdUyNZJArIGFZ5xvTtmXVQEzIaFEINJq6L2Mx3+9LQ5LO72pIoWndTJwzneRkKhWP0DpJu+GuxkJu6RKwGrWXvfZRVttENP/KukF+iv2sxqtuKNvfCOSWcft1/tvNojRDNu2535Jtc/3GPXMV+LJO87UeciZ+UW5OH/pa2zXQpbTsiIj0ecrIHGRB46gd+5rKTIUgFR4HvOoHhU/yf7xX1K9vU1gCVYHY+LvkjYa39h64gVyjfJduTFtUTRPhvnsE/fyvreDYWoLR9xGrAScKRJCZEdiaKbQqCrN3w9MkBgP71Po3RFrNqun/q7JupxyBIL6F2PiFOsSEc7fgZlRbvrVcuWc9ph3ZW8gKti1bEX+ihJXynf2LmCke9vk5uS+EjBpOm9Rha8oMcjZ1+d8wvRZdzPM1MlbdENQl3riZHJhO6sFJw8uTVOZW46Uf0iA/g6K7CLUoS+1ymRcW6gTEwZr6XtlIz4nmJmB0fmPTsrLTuoCGNXjL93q0FLgz/pDdNIdd/2tmhT4Yl0IBFIlekzAZCN0ZcLq9GjM3pO4MhFkgJaSs+sbXFLzpPnWG8StzdmCQdPLcyakMVFr/Qa5mJS+mngInDhIwJLEJa+95BkBZ+WhnfjLMp5SZkTPjqCy1z7RSws7Ey9wRGbFoFfxyo/iVXaZAV42DUKfqrQ3KWirzzC85w+zGtfebMt7VZCyi2yHg/aL1l9U2dkIZKBgoPuzdtbI5DRGqeGFfM8ShVcSUjVve+O8LD1Zjr4RFCWBhDmrZvpbfjPawkXLdzX5cp5Ghp/EpowtVTdsrQoIj1t5y8YRXEvaJbKtbzubypZIV3by7UIqIlkunR1Mmbpf8X/+8dwjl+3yDeGEc16ZWCYUlHckbfeR6ZwXpaEBSf0uUhdmP03I1HMvBx0S44eYkUJrA28Zd4y2tHRReHs0Y7Z8cgKoUy483ROE/rSxyFbvyGaET+iOsXLixXy/XfnWGLz4OpsuyqAUkTy7E9ujZrirL8NRWVeb06fgjFptPCri4CUhK0i98VbpsCfFm4pavzP/+xF9GEaHc8o8RCb6B1f4OeWCaaVVodYJ0WAB7irGIgmGjtsXeVaaK8NJHBFbeeimjK036a79jf48qZnJDlWico9iTayyqOfNNeGCPT3f7PvfdMfCpkOxyGtnlQRjhXa4IJadQfWYh2fycseUiTxbdfL6GERy5s1MI+UAppiNbM0YP9Xz841czPDO/4v123wg3FiiDXgyHy4ABgSVempHNj3+vgXgei+X4LB7CYwUEJ5Ga2M1ahzUksyFTAyS0y76GC46xy1VsZ/3O+eIMR8w0NfupY5RZfMAYK6ephR07zwwDuOP7YYjhDWm/uDxjnj3JE61xjm+f6f/728dVKzIKFNNRX3wwO6WJVjvpY5EdvjV+MzXEcY4AgZHYVBv0sDopEl9FPvqJrdkcJHIBP4C/8nMIOGK7NDee9OOddBkzrvcua2ViESTVWql4PUrJgSmdnLJgBOwWzN54nHZttRT6kDKlXswCmeN0qeizNaOxXdbmD8XuG/iwVaJ3VP31C/Sf2K7IuU69rit43R9iMaGGLZjcD/7UKxNeCFn8CK2sypwt5achG08uvtZEe670V/uFZCj2303SjNhQXyeWNZYjdhgf4WskqV1aqxatgfwow7G1wu384mceAmYbsbxVZl6QWZDmF6zNAq5IwjpWUM0L/hmCPrA8MTmehpBI/5pWsvsPjr7xOAMPEH6Ylesct2LHZ1fhUF7L3zvSPRlthxtsVHku+Xp3ZK7RUJU67Cr5kXU1yyt4z22j2+QGVc+BKplryuF9HKuqJh17rskWXfDCEEA9iFp1N/n93JmUms5calhhSVxqfBJy8z7kHZBKI76YkNBF8YeU0DYdfQQBYh5fsVL6csvNDvK92o8tv+mLSUwY4pArR+ORfM03VAqfqFVReFIaMRTQlEex+5WLc0HX+TKHn+3uTIVUXEqEDXgofIL9dP2y7W1/v0h1KVcIzVMABj357cljJdDlm000T+9r+7Wr9DsWGsN2wL1rhRcgIy1ifWBD68c1xSmHuY6Wvt9k8wrjrwm4L2NprSPldIBG543LxDM68hAFHVEGoH+rPbjHNEoVfKAPa14+aoKHzyPz+nYgkYxKemk3UJv3zMZemM8EkKnk6EgRqp9c6IER6NukY2U4L1Ckru1orqtxbPMKMs8VafJlUPNVvL/+FaHoPMivuGPjkT9zJEaSa6XfjG6sMnzSrYhOpLdhakRdmCN79Bw9A3cbQpr6R/cuYanlIMMlNFD+AoWtuPVQIQZmc4p9deGVpwxAx7jMrgTZNzDSV1JEvUEH4MZfw0ydIczZyUH/QMtVDfO0WkCanog8BFHnx6A/lSJbQTQUdc+XpbP9bKdD2p7fOaiTrhP0H6U5wsOlbYeCbvL+yH+Rk+ZWur9rtk0lFoLB/ci6EvVW1GekOKzvrWx9QjftQmBtVDkkILWxVKB4JWq1Ge9PGfLda06IThoy1DLUxMiPk89opS/npStfbdUcw3oiIGa8n0F0qDWIKDhqWvTWorPc9V0YAZYx2ZS9ioK/pk0Qn+7Tu70ezHdCPPqKfYFfHB1tdX28TxWwQk1OH6jgkZGA6vVheGDK+7usAlBUdg2L/acqYGorTXF17wCd08uwUlqasi4cUxSaighpZv65/TYKR2mmKxLhE99KjPINtgzrYEDx+NUFYfmis4C/cZAr7XJqEU+JaNxxGLJNnw8DcO0ciS0e5tJIB+QeuchkFxfLiIPIQLv3YMEnonBxSR2DdElgCJeJb8ql6ONLJDHLh91OuK02PFB8jlDcOLTtgHiprUKcRh292mzoyxOs8WahiyVFxHn4KDCMqtIrzWwC2GrkHqbQ/8/+vN2WpBEzQFwgRwtGCXpxLJz7+QBuog1CJcu1cHlGpnbiSfwRiDpfkz8mMSpV3ugmaY6mIme2vCm0PgQNYC8Fd5r+8Xi88TvisYhQg5iOQuhCzxQxFO/NVcQAoIiHb2NVikJGZnhTxI9+2DCovVZH6al2Ax6AuckHUTvcffAs3ONUEbTzbo7oxpcHXc0tXZscRtzlKhD3HbbKFKhKNTm9DdlnbIH0b3Bb1muhQgo/AsUMyaY01Q7GNcljdBwkiZCBr946FpU2SSLDQW9uqJGjx80e7h6bQ9JDzIVd68xiKWbf83RNOv83zm1n1O57FDo9ohigBHeVu2XPZYQKirn4exRbULZq1bpxGwN+yg4c7j21amuddjM4PxADDMu1KdVE8WT0xLQT+ZG7mANUox82s4AkcPUpo1J8GGLl99JDeQSeSSLIfDeSqoJLouA55dQv6I0WfMFikKMpOXNLenisSNYJjKgocjVZufmZgbXumIaPHLWXLQ2kM6ZrnAOty0YBZsIb3FiMDsKphXWsmLzDh8vRAgEibHvUquBpdCwUI3rbeDZQoQOjz78yEx27bcJwY5sJSUpLhtkbp4SoyX+7ifUEdmmQ9lHf6wQ4FoU72ytAz8+FBLynDWT1a6QIYiMsCoYuMLBzQpScw7KzGlCmdkXOOWMie8dxGQHyxbTUJkhZvaeggFWlTtcLNYhGw8QjwjQQMtuxnDNkfiUcvnGk0YCKhPcO45cDwqTDJalqEOqq4a8J6QNdLgEx7TiKeeeMWMdvhqOS4Axe7hoKxc/NV2sIpYk4KHOrA0fgcAtcpnkcGyWbrjQICYU/gDsgTjP2gp+BA00gOLb5ZLRS+DlBRH15CyEWgyz/sllB482nWTkP45JxTcX/r33S32wb7IUlQ2U8HPSnOoCSYW9MFNRctgUXqfoLQ1//a8OERsGRE3/2CbRd03bWF4nqSB+FPntZT4r0SIuIb01VPgG1AweMsVremKyGbAINabB6jQ2S0luzOAOUS/ho2aXIGWzTYoul4B36atzIXieS6DOPDPgQAwqICPMHhz/CgsLmCad1AwenD5+PzczaIT0Sw81A56U12e2Rzntk7LQjAG2MtQDNDM1yZe2+6I03snZl+7OQWHYNgSlaWLUcskV30xDMjxp/e95BZbQqiqOHACN4zgFX0VCvxeyxQKD2YyJF85L2PiRM7S2vt0fG9Ncdi72iuoLhKb2KDim22XTbZMvbVw6h8CO2YpQ7ZWu5Doz0i1UVBtlwVxRa2uTH8u7J0mgnp20MPbN0QSpG6bQkJwMjHeYQ0YigRUIj+s4KTLXkxXlwJTMYFTKgUjouP/311rVejiTipKLzkJpkZtIoL/87CDpqk90R52oXd19i8whaw50JNxLnXqFiSdVe98Hyg5yV5EI//tfVKon4juatayELyoMNa4/EACq0eHu1IlUFBZjA2WMVMSHIuTx0JRyd+inSaaa+6cPGXQ1E7jssD8M0sdfnJyCRC/9xjFd5q3GQbcMuQC6m9bUQfGP9DsMI10Zl80rl5YPvuSEhRmwITg0TfaBEPLFVZZg+vac9B+fCtrWNCsVdn9y2HL8fivj4RpbMELoT9ei0uFxybnanMmriIn2QDXRTPNDfBxBKNiNBgVGdW+pYbO/jIhX0A2dOtdaSHUG4DsbUDklmK1dGAG41xZFhe7wCRG+tdZf0OV1yaQfHdATgpoR5HBiYghk+ZPPr1TnNLajOX7bPSep+HTygSuVTIm06bHBAHqo+k7UPDQObRYntkHj7D2ImcvZR2czCzC5F8spcOd40rpupS9/5PYyqX8/01LszFyrB02BM2uWah9znDKAC5f/uR9wlmlNnR8+nFgVDIpwY6dnEwuRlZfZnIQ7eeIm2batxw/PWiPVjCRV+WTwI/8+2tvjSm/BD2AJYMN/GKmHhImksDzwlxynM+7K1MQNaM7XbOyI5s7YHubEAx6zmSUlUvJw+tKG4QzUuW/dftXI3zLW2sdNkR1L3G83DGwaXjQzFFSX7oJFWlB5n+WAvA2WM8GGjOW0S2K61NUvZAyONxo0qB42OJ+L/oPiovQwjSGa4lAGBL4h3pfOcARWaFwhuhQ/cUfr+26aQ4XwmTWCRGqomAnId26BwjBhLSf9Tl6CxE/KFwXB3vAHfPTdF+N6uy9QNr4PPWYM1ebVI/AMvzQd8scpQY2TjNg52AZsIlMsTmU2wogqrVMOl7QnDu6hHMYdHa3Qoqqzw0jytWSew81Sq2CkSUVDR8c9khrdYKyaqN3DwNgbAoQOQwZgLACa3y+HW2rK7boS5sPjFais8rFFB5VJhTbV5NwIP0TVf9KIdNTlUkfBwjgGbaPRyTb8RmYYZzAH3U+vFKp/LG89ag+ai/NOA2flBb1Rfi0cOUWl/noxA6zmd++UPX5hhFIKmnt4IFiUdN7oxhih5CDiPVj3gl3uo2o5DMiKn8pmpJkzJjiUlsXo/rlI7nRfDJfoXlPNt0lR8Sqzj/xY8pIQGS5H1RYEnbHONxJ6O9i/hlqU7m1tYY3gJbO3vwmH8u2sG15Yymn0rUzDcnyq80s1mr6rVJF7QgGK/WwOKIKoEPmFiNrWmwS0rPVd8dbk18UcpHCqUqOXUhARcQ4oDM9UIpXcAa1+j+xjGQc0o8iyL2fh7EC+aihNC0qX88eXbrtpVJykT9KTR7zHG6ZqfiMhTqPlPUOZmh8MFnUm80xUfXAj8cS7jV/2RsNrpcJRFL6vaouBf/N6tyVm4fgxtjh1W+3fZR+t2hK6gvz9WtPFFzHdPGxR+6Io2iyLjP0ufJbdhEKeHsvtVLhPOqGp3B+nDMT6gFW3zh0GX46MvO385e8NCepZZ+ODplL/2izoA50p3ndHvGvHhgC3C4lvEf3ToMqmgYhzR1e60hJoBZuSlI+B1uACHOwQa/69j9qM4z9MvKL0o6LYnsEo9rSlbWm7f4kLvirwLQAc3jh0sI+AmvmIGl9bbAEQdIFGe3paNQ/y5RLiUcaAyCjfsS5vwxmZjJniAd1CHQOA08NdVyFxAfSqw62+42dLmkoFRx64cX3COXRSdyes8BhMi79CcPUO+ATyzj8weTxAiwBK7VEohlYxSr7zClnjOLwC6lknwwpPdmsy+kAYnpMwlgcwGeW3hGkWV4nmQCb3S7URzzuq/F7lgr4Fp4wmX7VMUM4HsEWmOhRqW7I34QWOE9exmNxnb2ohG2iQ3dKEAdRbopj5HUFDLc+Czanvemc5ePC6Fet02ScXzEFD3jwpZ6tH1oTOwu66FAhpDpTCG2fXcVbmcn/NaXlb9vOANwRQASsXp42NwDjBKlTQs6yVdAB/Nx+kvqc+Yv1UbJ+Vl0KVePnXMiO+ifwpkm2qkO27MvRp4QR5o7sjAJV13aI8uVdbCf71/Qep94YMj47CCcIb2mGhZt+5Kdg0B+O2plbkW9J7/PTtc9ff0EN56UdHgBBzhTPIGAJgw5umt81BSokl7hZjg1tS82zMetjAiHBg0zLC9+LxxSIEfKFxjpEi4a6mpa4eFline9Yg9mzG/jifhh673UCVpxh+6YZoKO2RMgLqHmhTUtlavdqm9HAvnehFxSS58RYxgBHGhL4uJer8MH/qaPliofxhqRXi1JokebuxsTY3Uwfk2nHtoFKyCfDoOhPrp4pCrwxohNK+sjnEBAf6e6m4FsXd/f55fJdFH60fVaVoZqHOKilNqJoUYjKu1wh0tqXA06XKDAJSAH3+IcdfBA8e0+RQC2tclZGS74LE4cbKIzgDydX+tVh+4RGtV08SY8LW8Ptx0qv9dmLYzAI3AXhpKQfCxRA+u+I3ybY2o9VCd9JLJHxK/Jao7o+HqW6pDtIYtMOWadcXn6ttC3f8M/7ad3tv/O7+D6pEIVFq0WEwpyKLC5b/bYjTWac/MfpM2qEI86Zn3KFaTr3pOEl5CScnp+OiSI1Kj97z/q2OnFF6Jlwt/cosZUyvwHuC4g65MEkbqd/15Ue/aSUjoMjXW57Tv6pABaHlLiCpVFQwGj5BBi4ZG6Qafkig+7/m/Kcdm/Hh+szlFRmAdU/hjT7HvFBIr+9nF2c8XR67UAwcRUWMuL2wA0M6/2rmiX9YPgGACeYTMqEVDk47YPeJpE3rnK/SnM/ZuTrJmk8sc1+vtsLbHjX0nI8xJI8TzeYXS3zMteNwlmNiRisWVvoabU6YqLLtpiR+u7SkP1dC9YxvILzOAOWpquXek0ZCueDEhaBJyNLKiaODgyNrWgwaNMGWWM5t0X0iYjD3prhGz4QqVgbM4AwjKtXVWtWeG5GxwyJvRYUGbsz5YSl4xxKMh/dMHF5X4O+S28956Xp2IxUu554szhqzWFUfEagUBzvIwvjZqFi/wLV+yWAVdRcYFgKOHDFCCoJZP9n/QZhtiaA7vBWh7rmQ6CUHLEacI8ya3JIDH3ZHHu/nQnwLdVFC/m0NGKDBKtNKKxpD4qxWWhnfPJvqs6jygvstXnQRlov5W15u/0KoupfUDmVi2nK3+dTJeNtiFTuPsLqG37rtRiGsig1q/yFmJtoZW5izt4R5gpWWKwbR6yGVLKPl8/llePO0B0Y7fX2yfE4aTKS7Hdu3a/lad+k2yAjXquxpSQBiAPqST9Vw6LjAoM2qqVOC92P4TfWL5zaDFR8/W0nQfe8/kzRudJ0yAOGK6GPogmaQyMJvIxwEvqBzjuYclQ9W+H4iP9wWxTgLwv2/ozZzqhlYZLb64/MCGYiOr/xlljbYQl8SxE6lUM2EUZmPWnSCbBVdSJOySdL1yuCvbHficiEV1Sm8XmmaeGsdNstEYOffCnyKnICKBPZAQewYI8QowXgNNaHzQDy/RcxqvdhTuXtXDTFM1keW6imrfANFA0tzV9paUPDbWmlLf9EKQwj1a50j6xaWEap1Bvrd0N6JYBVka9Fpz/3lnS/ooT6YVmM+50LlCp//inMByVuvo0WZZS/TGp8qftPR8WUGOA9SvH073C2A4gcNjI7b+lyC9aijjsh+jSI2dvWokbRoi4CYodOmro5oIfBqqmkXjvyxus5obgwOFulH+pd6dYsII35FO/IJAwW6jW01DeBE2myEalry58z1xEs0Ai1IwGrsGHlKY8ztcYZZHZhrM3+wKIbBGUlAANGsD+YSNu0Byl6F6JDzNj1dqJ0DZODGYbjcEycb4TZaWI86alb/OlMuLkpVn1IqtwmHniYkKTQTVBBUgx2E3B95fTFFucxHTE0mc/rspQX9fqJfrShimi92JHrgJN9OzYPUHOYUezLWM4QXEHNMH99/XPQZKrv0XYu+Kn/Ev7XBkuj67z5qaeR7oaTUYan2RgAu0Av1MVX3inVWWXwqN0OZdA+B10E0kFiIyS3rXJJYeBftRzQXT6+a6fKAEj2WmxgMeD0eAcxS24wMSu6CYOz7mqvEO9CMk69+v5jYakxe07uiQUApWmHGyDcw7uHmkpzOpzAV0x/GGshY+fK8jk9CrJ5X68YLc6KEGQAHNR0qPMe05sEA7JkHqpWAuLj7t6cPO+uomLPo73N+40JbMCEGYrk4wRESRK5rjWru5vo+dBoD3asMeWulpQnFvbJij2/WEsgKPShPXuH8W0ETPzxoJuM5bahnuMcL1dOPYoskSLDs46/8mAa2fYeUIGb3Co0wyhkzvzsPKcSv9XvRCvCAn0X2l8vWNN210VPXc6XkPjlTMYnMIhmBRNBE8xz5XoXRHILcypLOSpoSKTMDMZYzHhFqPTUmnW18yf6nPE5TiAHAgwaG/tTN4QpC/mRVnC6UHwIvxIAd8VFisidoPjcpzZ5uTv85ugSuoQrWyqDpjzgqtTbxrxNaLJ2woAXu7Gf259G+dnRGKjlGbHvD4Q+ypFsdkVK+eAL8gcFFHFy8i+mFKbHNb0jA4Rk37Es0M4ZfxwGh1QYk/qjojaTsjZFfB0hC713pLjK4FKxri4dpNFDpIM6Z2icIp3bbhCRmuSZHAi/KJXHzqosa0bboRrHk1jCdtXwUtgi12BqxBvLzDUrhGpue/+f+AYTBvDg5Obarst6LduoaPE4xbQ4357kQ+/XYweGlFUcA69Thu/TS70kksjMtm/9FPyY/M4mSeUVWlakHvrYAFoajeH26y5HHF5Zu/IK1a3P0m4nYSE7Rhf4HX37tfGJ1oFQbeflGeno2sw8nSBS6uHKydrg2mHgD/NjRwjRoTu7gfxxNDfzqsMLrhHTjjxTejAeJBCwTPYUkOO2XPzOvdjEImI3AwxWay6I5E11mrRiKL0qCO38dkwL0eIB6Q+Sz5h/Rr5R0g9GQl7X+x01kx6mj/0LFFK9HKY8nMtXEgwJRH+NG+oapMiCYMZ73BFkuPqzau60xpC8cWVsajiMOOSn50S8PKhsVVkp4elnRB5SeAnTWEALOV6j2tjOhG8I2llejGetrapfuv5Uw6CnebKzEykoRXYwBJ9cLIxnEL7mbcCqKHmxd+nmiiEZob55+K0N+x74b2aHhW5/VKnSajcgjB3rHNEHUwtHa0P3DziSEMsyVOuVirMPleCEuqXLSEBw6MVDVTI5B++bt7h7oqQgTumPTy5xI1TLLOACQVIKQlpoua1AIHIRdPWu1gCZyfx4BeBPfON+5+wX7iC1eXDeZ64InefYWk0qLVPaev8BKpDmdsPKYi3GK6cX15Ct1J14ilNZiNXk90Ikc92Qzt3FG/Cu6oF/1KsSFg2ne6FUpkPT7cQK+KHB1L1uvIpoQyXk5ysGUlyPcsZMyiZrP/RxYEyP1AlsdeZH5cejdugKrn59wrYS3+U9nN347RqSIqVmNQL0r0owCXHJwRV80AFfaUCeKGX6c9wepXBAxTCc8SaOBpTKFmBOA+6XEy0f4AKtRM4nH5x/np4Sz+dXmaBU38Bn2I49xoWFcspK1XsvzvflICfPm6xL77/llB9gTQ9RGIwTZo1caDWRQ7wd4kASLUCz8Z67U0lbyP4rJVf7Osk+6Ljn9i/zi4k7KKEx/9ry9lBEqf2iuXk3awsoZraw7rRdD8D5l+6wRuWuviffjhBp3+baN3ew9Elf6e2esR3DdvIZTI3L2VexvpOZeb/ygCvVsG2n7eARwIUgrvTm0qf92H34vxDjaNESiJgupPvIn02JmB4qKGXzTTs1r5/GKZ20RmwK8kHTmyJLjA0AyPY5rbB++c87JaLC620eRTHOgBlUmIfHcb/BL8xs/Xy0aiTfJd6CAvyClv5qS3h5gjYmTELzAXEfOa977+DZKVRoAbgQ4yQCTBCICutx2P8ydTP7GsRcjXvYy1zoU0zfIhuU6pdD37WWmz5+4po78w8wvGH31YPXb0fm6k9ig4rixtFd3wdUHDbr7n/aSP7P2jYiiAYjIOL7JLtpgpc+veOUsSGmEPjuc0cev0dXxfMKVNEq/PwSw73iWTC8tUVlPdJbvLhM4jJV/kUWlxAc2tIC1mi5JlTlc9Jo22yUOLWpQhKIn/zZ2oi3CJk+6WeGZpAIvAHRNL1fHvogr7d0FSEM6w2UzhQqioamMG1wgS/CthsFSj0i7Dwx7OHuRysPu8f3tSMTzaDihVonjQACkEpO5vi/rxqLHr72cZI1BDD5d/02sUYcxRpQOllgPLdjzDmmrsNvsVYPZ+lueyIn1h41LQK0qbXSxt0gPAQtExPcMy+3cSRYOJ0JBiyMc+ETjGQjPhgYcLQ1b6WiiTk77lxMJXzViKFUC090UXtMagFwxZCuQ2C+ymguCyFrlYLtPv9lty8NG+z5q4sK4iSZpKm18zodSdPDmNp6UdJ+i2+gxchiBJrQTxh0AX8p46/DpHwNaYO7NGo2vKF6T46Gm4JbwWeU14Y9a1Dm8hopAJprcFz6lwo6KaHvomCrDZwZl/TLu41pNbIpEjkNXXSnwSE5FJ3iIm9bBemFuslUh63jF7mKejxYpppVXXpm5eCVOTrHBpknjkEiybJ5GrwN/XTiHsBnFj/BbztWxuJu6CCp3oe9LXMjStmTCdm7gEWmZ7mo6ftSR5lrh1rG8bOBRPWqtLP1NAmNtNB432F6IMf6D/Z11H3N/kUuRmR2UL/4YovsTsZLSLhRXAKehM6Enk6NRadQOvn+QG/eUFm5LOdb8cwgIAPq34azIJTwQPKOm44SZ7B9zkKv9MReZBUOlU8eBn+r2v1Iu6qSjdNC9gIf8zANC1seYQXaysaIka20v0pm8iG6GIRVIdK5ooKefTDkwOyl5JA5oXtP/QsCOxfWkY2z3K7jFTtKgXv09u6Slrw7gW19LT0uuuuf+ObZmatR03VlNGUwt3qITj/ZfzmxCwjmy7faUlrbrTbnsr2ps2QfbqZavFpEym3vXHsE4Gi9ZWTwPhMsxTzbF/slp3da/NPIuGV6wz852WdDQen1KoFherGG8gOf8TzHLzBPgZ8Q0GITYPSjQckNYpaqGDYgC0sqpm3BJTA1raG63rXXyUIIFSH141yb8vmssK2yryuau/2fGq+pcMqhsNAUhvFw3KcL7QcWhK18q1fpWrJ+9BaL4UgyMyeAOC8+lsg2UccStRA+xRQu16/VOdaxaVR4+4H5CHLqgDh6l9IISAoXfMIyZJfXNJnZeOu3MLqibAh4ffBKU67QBD3lFK8mWojJ2CW4mTzsiwKb4T6ol3z1S81OgE/0i9E/Ij+UdeGT7RIFxexRjHNEMCXx5es+ERUkO5Va+cAzBTlSF0AN+NfmCpyLYs6HXu79cSuPjtVNNl2Qzd17qJ4+37mXy1KdbXyebhe5kz8ng48xxDj5rZf3iTgppNxaPDYsdKkpcEUYmadFMKfNe2PPrthhjC2bUYVbcErsJQInL+smcaDW4b57yLej3s5aWW3+MqobO0zRI/XsS8TAa9zF7PWimHVUmA2EUE5Pp3yjsZl7Knv1KbfKXq+xTXCYqc+9V7St/7NxVXO7z1011JUDRbn1wE08/FBqpmQL6Ips5KB6XGdLkFKYtzyY1YHDVYqU5M/RBWiI8jQcm19dh5hG8CkhejoHYujVx8jb/gCo2loVTuKxe0Mu4WaY9aH/8cqouM9Zh4w8Cw4F0F6x1fDybOl9Ri1LhZVDkrd0R3Ej3+YppN7c8pTbqbv05kpLOiI6ePx1tL+biMS3IcWnVAJJZrSfc0mq0xzLoUJMT9EWuOBeQi1N4s2iMXKe8qUvFIFLL1P+IR5xaBSju8pudPfGAW+4AFkgWg8/jX3Y/9qCpnGLbLWTVFf0lncsxjsHox8l6BWNQEH3+wxi5a/BPeRYY8YhvEio0WSBXvOcex89xbFloH+LvatosWM51ep7IO7MJ6CKL3YKjU6ETCrF0WEQ4JYBo7nUQFJz944TzXx0BApK1UU2tcEhVXjmdwGakPIgIol8H1u8jdqTS6hkldFE9srBtFGubSjI2eRt886DiK5YH9caw4gwGDgvwuyj0kDug5Gv4/2EUb5acH4ahCdlTCDyPlQgYpQ4nHZQXMZB90bawb5DcHDmK5nG7uj0tRPedaChSuM1n9xwA/GiHJMOVhdhKyRRaRq4mkMt6mcFM+XoXLRU0upSBFMeOT0tftPFB7dR5HFPPPs7dAAs1A6p8Pu2Nng6YoXTp3ZdxhHj9Inu9W42bKCVsDgu3Q46sXDHLsTUV+xBu/gVWoDVsd0opJxcT8/n8rbjJ8WxKmH2flZyrmkyURNxcsIpQypdQ+ik4dOkUXEJZiRgpQPO+U2Enoi2m+1BiFWwaF2/YkMRlQ2nzQAzlSte3Qa8bsuD7AgLZLHspzg8zjc9pl/0mQ9D1fojfBt0dInQLfzDk2tJYHZNIMofosslq4TfCoz9TEWlGq9YuTiYtuFrV6gwDAjeZfGiZ0lzDac3QhSZIi501U6GiIBiayqpnhQOICoOf+9XZTtZhZpsNwiRTl3NlLcMkeGPbyoBoMoLOGnt65I7S/PwjC2qM34HWfAFd4/x0ShBzt720wqgWlzq7f3MqGXBbFegAqTPvaaeBJ0I2T70H5Kd0DiWsegvNqit9HM2zbJp4DI2tZrF+9GMFQFkzUHRXpiC3Rc478Q1DGcpHKXrXk0nYacXK7egKXv4IWy8exd7XjfDuYCXVSUeDul+G19Ulu7HzOwL5b/I//hna/+c5/JXCVB/E0j+6MAZbkgL8CtADYlKIBIIGYdWo4diTVRo/204EbZZJmkVnCkMQYnHQxQzzZs3qjrSrIu5klS5iA7j2rvKvLx/bKAvGPjLfL5b1FYp2f1hgv4bUsjR/1OwcqQQeU6ZtKBEWNA5wzHVVShOszQVBUbLHu8tkSZgOK35xBD98bdoleXs/U9PssjfHwbbN+KbcEPZMaeCB454Gri7VcTCM59UtVk70INNGb5RmkSYKO6xcUeinBT9w/BeFaXmkUtEwTjnolDhpLYicKVtFbrxxghUYGbqnSu3YoF4Me689I5ZJKtSRWBChPZ6p0Z4GR14oktCIgEChuZ8ihcCu1zgIEgc+hJZDhMYaYjq1IJAihbg5dbIiQJVjNV0biziYa6rb9Giplk4OC8uFyA4NBwslFIPVtYOg0ONlePeE+qnisJ7seRS+yoTrcLnOokfgyVsgaH5iDJt+1qSy7yfwqB124GgGMq55m4aZoocHWarKjEnGUbqbghy3oYGCRweWPsq/ah9HJUJqECAFlirziUy//VxrEKnQWy4ClqRiQ8jc62QYFxZVEAMnw3eTRvW5kryCQwphmX10TWuSLA2fUy4DIm++1ENv6hWSS3L4O2Pp05xMBlx3VaiXf6KQpINWFRL3smQ/u6ERL3jkDgnxVNq/NUeoIL82wrDLy2PSlopFUR5TdRxVJINU8e4DAnZQcyaZ4VRxsq2TofHDevKNW/x8I7WAOOhtIeePdj0rsbkcEMDCag6bdqza0X22oae8CvL9QCLfVXqZi4tH/3/tms4KMmYk6tbAHLbI/ZJ0EdQZOoWrVBvVTYZRy2srhx5g4+WDg1Wqf0qlWHFJ27XmFm23rgooo8155idN3cRQBjpx2aIsREEtW9hTpjXs0IEQQw+PRgHb9V3LMq5UnFkp26wvvGF8v0MdlQNSzQjZ5Wq/3PL+fIGaa+qOWrg+XDDtoq1z3CBNjZYjOO94/Oz6PsI0XeYW9NvcslFf/wx7LNadtt/+6usr1n+hPAIlUwXY3bClLdzFf7DpTbFCp+y7mqHHu6jPVilA0mXx7YNviOCPQmVU0pA1VB9msqYx+3CVI0IvEuEeYeXAw1MKGiNuWc8YnEwQgalgab50qGNQkB6zVfKsTJRixMOzs6akCH4UZs9zuV2vfHA79jvtcuWkF8v15omLBiQNLAJWUnPTqjirCy6qJE0ahVJDoazjjk2fRnJhKN9IRJ4WNZnTkNLguxJxbbeVyslA+QwNOwKfTzr6NBvl2LiHPOZ6j5wf7COnOm+tLCB4o35PHTIec1dgSWawsMrKKsCy4RssyIAphmTNnB0wihDwyQ6kdXhL75bR4HAQrczPOWPhmMpnjKM7AfkNiBJrkRYg/Aab+kSeJdMQT+pg/9mwzQcJ9Wte2g89NPFDoaSkRq4+2yuuirolikucBe7UceKz7AKHRN4Q3gS5RKWPmDon2iOYEBidLx6LLdNLx761vJPVpyVM6EBR1e87zkjCTGp8Gut8rulfUi+kMmttGfHkMTOq1RhZ0Oue6YUE9C1eLgiica4XuBdR1EjrTKOf8RUODjfbkrMGhhz3vW3gYWRCNoF8+5KVIfhzobOPLjTUCRAFD0qlbO/368lODQow7LlYpRXnP5tKc1a//z3jQoKHJY8u+UM6vqx4UeRD9UWgTi+BSwP98f47N+AM10XJyLvQqEzjyf5fUGUReJTwQALSqKJMpyceg+Zixe8CmeqwVGcrVHIzFND+tPqHVfAzVEwrjQHTWoUAZ7rLmH5oDBi0QVt9CfD2+D0IhOT7Zw8Nu947mXVtTvo8DlqQan5DuA3eo47HHoUDdIjNhCTUKh+Gdf27urrPOiS/WdVAaAZwkIbiHrnNnnE5evWnSBzJ95U2UwDHrxQNFHgxvjRhWw1xjKQRlCHasWC35LtsvRl+dKTyAWbSdJyH0vEaTpKZdBG9iaWbiUpXbnWl47Pks9qp17J04nNCmpAeAKnpqWnpwPb8yBIyc/u/3tzNu/9+oXSQEJWvdaWxAJMlXlN1+Y055g/utmPgHWst+h832B4rXfCcerrbWdMjpwMSa5JEuLHkNmCtUz1ul0kWamueqY0Api3sNXF3opHflshHuoqs8vTqRfjvIb8u2k2Z7G/nPgd8Fd8QdrQHZySHVivAjnv1ZaJcOx8ZdDGB9VIPgE7dJU+h9qDsNoGs7foqfHPUAzgbrYCkD8/eNTlA8pN4K8CX8KcKHEsaMXfCsgU6p1jB2LqNLPvXUdVbBMq7JL+7BUvYRc8suX7FMQAdTm4UnlEeJNr/V1Pv1kV0coL41UxP6ZnTkK1UWgPym8HzJvr5PPex29CkIjtITofjmB/fdJUVLyx1ClpGCTS7sHqRfTCTgvn3U3MeSx2+GkLrhLoQemyxDqBogj+9NjLlxsD3hLuKrmKDWkfFWe8BEU/CL2XK/gVMk3zpN9A9mvhS3In/ydhZDz5nn0cUgcqPBuG68eSvct4wnXNWyjOsqTMbBsMb/n5Wz2k1z7E+sVK+rZhuxJXFH3dfGAOPEceAh6tXummmGtDrvtKbIUJXz8kFd8vP+qTvsvOATwsSW7g3zw0KQjLM+9ip+FwVu+dQR1IXsbdgPoAnW4mFTSHUoNBpKRaRuUbrWksY6kGEQddU9Rq8xJrA9KzNODrc70kwHYPL0w9Pv7bcKezHKoUvaEAWRxCT/WpNlzuXUNXmU67X2kwvgPUGfnoItvnDPnbDIofchY4bq4ZqMYr8XAJ65Z4W2LWu/Kwk6eGFL2u9jn8JAeeS5hL9WBclETjQSwo5zVRyKF9nkp0Rtg8BkzBGnNedYxbPzMi3WlWx+nSgvPmHhAxW1vqlDAIT/RAK3XHa7mAPH+/pu2Fb7rrm2wasx1U/9MTP0+Uil3ZtO3LW6jDTtX7DiTj1anhspG3HE7cJHbopQETYp70WaxAqpitSthSQjwD2nWTe5R5cH5w6195R9uebH/jDGGvO2Gi+P90Nax4InSFAtixzfRs5nsHJZNIViIuy7rizzkXb4B9FgRdcK8OtR1DKjbjfJgDAv4nrvms4VfI82wWu6nWvAO5JaiWOPbaaQu5dZQcK9OaSgwyGbeIwHRVQhn7t43sTvCsu0dOebizSshahU1jHXQXGCE3EgEs8PIg2AQHSMRYwlaZeAHxuA2LJO/TIv8/hM4dklsuWStVP2/2t1UJO5beSlbORxmKWAXlq8t5YliMXSb6V/Dk+sRf8CArEP+V2xvFVRL2sT2F2s2RC1lEtmsbTRr1f/ybIAyLPBl/6cCK5Awr7pKVO5gg7j+FGdQH7oZyJHsTY7O7t+5LQ41KPpLGckcWUtpVRoUQvT2eE8xWXF8fXRZA9n1tMh5ZuvkmdGUTMFOpIMQ8JOc16XsytGN/CxRsPgfbQBfzAEocrGTRh0BfEXTioHqiHHegkQ+Bt67Mv6W0yVtwkUOVIE6FGRelwajZg8i/s7NEHe1O+sSDYLDbXgrjUMnnW0TGwexpXA6qYLw0Oy4QzIDgAer9Il5cH/TafmLDZIVOC0VKKi0SK5a7LAZBmbovq7cp6ts5OxuTI8qoKvKPhK4XUDqrzJYFhDD4pgUtxn+lW4sgTmXZXjLs5B727lOhOQas+8vRJbkiOYsiBdgp1eoqpQyf78YhjrLrbFykB6kbLS1+e72tQD1HSv2bJ1B6acsTzim9H1PjlNCylU6cUDeTKYrYb6fWSVrd4gml1oF6XFCjr5QPlhU4TLrkwOiGJYNC4K7tCx6o46sNvEkOa14yo1eyoNGjpJgCj2p0as2XUKMuyza9j1V8AnnZgW65i8htWK9SJQJHTDloDDjw6KVc6O4re17J0+aQ2VTq5LAGD7ZXT3esFwYWu20ZC4UpTKwWH73VL0Gfr9YwNkc+q5JpoEfMckzrRKhyPjuecCf4KnEIIlq/lIBybNiHZ+6kGT/s6yaHF5Xn/2c92OT7oTsLLOx6lYyaKUxiVf1d6kkE+BGqCwnQn+BNKzmYuIDILrNfqd3EJc2Irs07yvjjNkUcqexnEZR2BQ3trQZxI7BF3aYD+tNhQ3ZSV3AzsnOivWLjikMrotmYR6dWCPsrZNfsNa4ElmpUODc9InebdjFvb4NCUEGpbuZS8c0eEA5v5BQBjC+ivKx0t+sSlqlxklWPCbz1zcV+L0GRTqBI+/NEtNrwHCvi3fjIgnH8c9figs+nU0CxhbAyopGLMjXMx5AROJbVpSKoXxpTR4radHhh7FUGrXEcdqwK3749INtQkQnQCh0jUaFrEHhH9iv1WDG1bUJQ0bKGdWR2P9z+6JvrafsvoDIVt6272jxAHUJXIAd7b8FNSAMBV+meWwaXNwiDX916ikcwqr9Hw9ru5yv5ZRM4Erno15RAutoECFlCCk41PM9fncjEJjngiCSchvPIpnJjAaME/6fBG5MeTrhaIFYlNMcLPdCjqGDkqVHuUh3xzrxjRKfywMCQWNREdj+/PaAe9usrqusn1WlgTAREobuLTwRdWcnNoKDm31w+UTl0GvPtp26CsNmUbzQFdJq/EjswbN97ISkxZ/hxFwSqOWa4DIrvv17blk1aT5vajCj1CDnw3nlA46vIX3LF6gFIMAX4Q4gYLwaKLwSRQkcHuLNOw52Cz8Wut24SgtlOnU9vGCNCta7QmRPwddpucGiPG+zh4dsVZghrlkuROINA0qLGZGEp84MYjabwuo0wZs/nR0RkhOTQJQ6PyhTlmKbXm+AlFex/w7YIwZU0wDoO85fo9u3kLwwT0QjbsHV0FPCDrs2VQhFaIeqyBcrLzZrthNGRT/BvnEACGE4bBVufEaancP6pkXYm7pBtXEbHMLEdzyz8tvx/cqXtUcXyY0uQY/OmNEdY0qu91pVHaDD95Y7BDLfNl8I8WkbbpQ7MAi73JN0G8QcB49sQR4PnOgovas2oWtdXXoB+B1gvTe7geJLAATfelypqOO+wWkHciNon6PsAHKftObMQhTEJaHDuIEJZJlmsqRwgSiUZGRyBs8E0mkS4309lK/ih/ovDQOstnKmEdviUPhCQI0UYuz3GmtkzH21AHs/nZscgDcfTT3X3WPx2VLF71yLMKD9U/bSvxItiCBijbg1KYor1hAynlhonS8BW8Ogfe6h9VonswRFPe3b2tGfGTn6WjGMR8fgHKoyVPxBRjI5P3RQKR6S58Rm/sGmuMlNOYCc+QHirfpfcTavF9HN5owHKEauhCg649XSVxE21sXF7AtuXV9NTwg+CwpoR6l+HSCYYO3FKug4oOueppklmCrkY/XrBsl15w0SD5uF77BwNOFRjoXk5wePXUU6bNBjJmF/FvZjT2GgMb4azpca6XVvNw0T5SXKsbTNMx6LUTvYSXJmA0jlzCEzcruefDei92pR8sa2qogvlQrmKqTYYpIFwopINaXkJERs/dOpi5gsZJ4EelRAKXsDm4ndSjTdNg7ELD2I550LKd0mQ1UlwoUBB+NXHW4IA/j52yrFwALlRZqqxchQgujU9zjBhFMlUHS+SyF+CXftzF5Yjp+qEB0/yIfCS8W/33YESOLDpi7KmiawnLL5lP7/in7XmyY3YkGZlh0wB51XL7H88brhsFNzofpTlpbjvVWohrm2v4uHwjeaYW7PzWihqXPNPaCQE5S/mEfVtEtY/Ss1/rON47R39gZEYv/3tUPFD4EjYlx85xSjei06VqYmufU/NmgwAF8KW+eCboCknsk8Dm19BMLlMXFJ1a9WUoMJCYWh8G925xlIEN3FaeLDoox6rSwf+MSXYOPD4nGGJkkPW3fOqEOjVyYeYk84fddIlBiw+ixUBjjoqOd3EZXsgUOQ0RRc00yHfhZ9TM+OyJpBFgzjeldP6OjQkCaZMRPMZkVbkEwmvqKnqxGKaStvMw829HF8Dv+LOCGvkLXENsE/XQOaWNNWWgeWeJQursm98WbwmZhl+luu/D7KAyVgrwuAHmN6E12tMtAb2QQTYn6KGPjtCkpD3YtyK/M7Bj38QRZMmI992ziECCFRLsW1Aim1PKUlVgwJDg1KI7MHSJgAhWrSJIH0xXLrwG4PpN9eeS2ZZN7u2WwD6a80WG+JfSOyo8MMPI7k9qewje235Ldinn/3TwRwua1yNKx5V+l8JaWzrlc2Re4n0Ed7QiZUIrqMDXsQPY2nj/irsBp3HVFgRHKzi9bGdcXEiBl98aJwyPpsNPi4A+DncNJFBuZHJqiHQzQjpVuJcDRpR2fqZhS459CPrul5JwhQKLff/hQGAui13EsKMhVJP3CrgO3Oo5qypwlwcoc3U3PFe1A4tOrrMHBtGNJSgn7Z9ZSI1iLzC/vRsFtsyfjQvX8R6EqadjbvrSaAcDIHq++R+C0qnTvxBrUOJjgrmollAQYSPk/jclWNPlcIUOyqdkUlenndRb7Qr1j2rNAtPhcIrjidL+3HyHD1F8FrIAbt+FTp4kFiW/sJd4LyfqPIAWhdsD3d6AzF/SdaZn/B3IP7zySWLwuAJL/EDoucrM0enNzMkyTQuCBWLoalfUne8/DFnDowDX9apIMOo5KSoNEUhjy+whY+n0aUCe2xL8UjrOZVCvDxYXwSzFuVp79SP0h0g9baH6G8LswqFWj8BzGfwuKZn6pKIBKBwHP+TpPFq37AL9W//BVKOCohaq5jNQBLqfoYSzZPiqU3k/bPfExMxw+HkNLKX+Iu+aVC5owOVgXU1QXnzTdSFopgHzdBBylRAaV+ZQvvo+ET0kHz4yRt6tWT6YlQsqCzRDGdrIkGp7jOIfeMrpZz7FH0biyepHHogps+9HHJJDpqbz+nBn+SRHunfkfoeb+dYG+8IDwaVNFXeFx7j5hpBOK1QplcO8NnuSD4t/pT0+ohevZplYIO2kV8u3TS9qtkV4cMG6D6F++cdPZ9AUOVGI/kUpWjypZJsDIL0RiGC0khPMpETX0lBQspedrWqjIrn6qmbI/rYmIeUTAtllX4EwSQWa4yK0ImgcLBVvLoGXMULMPs2McVXEBqWixdN/EI5T/Km63t9UojBS1j9MGPtIP2xlJXNZYZQoQjGMxffIS1zNIgw/ecJA5Febovmz7Jva8gqUsJfT6ocstHA/0NADGxqNcVByWkuR7i0avBiim31o8XIQxDb6ZxRdji7EUfS442/sapGPfrwlXRldOGqDqG5KgEJymPRWWBOkLjpM0tSsxvLbuZUZJ2BSwt5kQNKqFjFmu42SBgGil1XR7fcn1ZZFsQsjNJMruBCb+FKUNs6X5PP9llBIaeXNuUAfHYYKmPMXRjBz1K7IEwbA49iz6hwN8sCv8/34o31Srf22dpcNrXpQn0xpxvwTOEtHg6lmqydcxBgrnO4w20koRlCzZCdwTZrRr+I4HLds3xneFsWtsV5iU4ftVl/Xy7W2xJhwRzyITpWk373WEBDtT5Vvl1GEVka2mOH9+HEZB78ggg8Po4W16ajCmsy3Syq1oOClxZqBuhCjU0sr2t0zNBnhBPJvsl+mXkyqYZ0YizZkuPeDdXIvLcQAcTO1HOitmg9IzZP/WeKarPHQVzKIMu+WbRu3ZkwbneF9FI8T8RkkNgH+gEII3Dk/azXE6Z442Cvg6srxoAe6KuGKtVBAoQ7ue6KByrt2A/qkvvE8S/kcZBGwwrztGaQWRxPSbSmhXC+xd27rd8yLapgVsj9/7BW+B/4gDUOXspr9N7PSVvWRhmjOkuHC7ceLg4hI18h6YHwJVmXAsF+/ir9qCCnCCWEJABmE9Rk+1JT0vFs/i3FiwLK2jl+cU7IIDGzfULifomSCCQsr4hXWpzE44aAlx61nztJBhKGUiIUoniPYy1yZ81npbcWL4mWXX4SNkCZ68gey9hSdZFrl0kSExmIT4TYBcA3J7ufeVmcXJcV2JVpkX4T3Rz3Yl48vbXWWIAZd0dWRzFQw/l2v/I82GkrVV79ED3dW8Mho7QEi5cWx0Vbp42s4IdSiiVplhriyOum46HngVQnFVB6e0mhAEDqrgmVr59U7SClQtzB63EDGLowtRpafzheJUN9/BgH/ns4RU5kxOOs7pZbhQKmB2mpeIdJRulyX4wolMLdiLV7x6fCd2wHajAwvSQiLmW5twP2hyjWtbqdtaxwafT5XbFiuHoEJTvduoW9AHqPqgWAY7zZFlwD4W0XXcSvnmmFnqDzXF0hWSykGy6/hQovOsQ+gwgdQcz+iLxa46ykm/Al0xVFjfqDLEDtu1OLCcJDgurkcdRT7SUOxSjgzyhCP5G3nhhkerIhA2w6rm9lSG2jUG+T007lsKhLIZFUpMbZP/PbgyPdtxGATeGeMNWs0jbR7abtEy0lGrvcTIgwoz0EPi7WmWPOEdqeIVOel095CmXdplMqVDHnqI66iwvRuXNMmD9N53QB9JZZ0Fsx1+gcZ9Qf7G9p3lHWIiacRM3K4y+RKruL+fdHYWbWSZglobw+qfwe3gRPDUhsM9TigXOzLQxtjJZ/d9PjmkbJQA0m2OEEDi4sRlF/sTNP+/Uwp8k7jvoNpOa5eb3Irbv9/eNfnEA+ziwH0PkIp+tgarupUkYtGkWPSQ3fSej7sM37DxwsyUKJlf7Y86oUmW6Un2R9AZylqFB2+KM7A612dj6xlQjpa8ObQ5UPvWK/VDdoF/h2raLBsNKN29cC0U/Z1jm4Te++fbZ5XbXUqoZT0atGcj9sDkC95foZFfFw26DxZapBsTUlB5yXV5D2jU505jwWH2Lumy9BbJUe4m6QwVVfVEJD/g/gWBjnD0Lii/Vg4CqkA04H/7wgPPjZkv3On4pWLTzd7Xfz/9F8PGii2N4pP/ormVoB324gu1eXIBqlnUb9yb/nCfVdzp39QQbcyOH7UxYS5HTXtQWhbf8lLkYNefZBite+IUlxSpZ9sh7B/SNdMfZUHjMLNTVUYveOWtf9AHtG33ddrrAmlW5ivffY5ll0LdUE3jIW7f1/b9M2xgXKKHiQqCvNszVqLxLIsxNo8IyCTVNMeSEAHYGNciDSU/54zuUSAG4lUYVu7L9wuGbsqYdSr00c/yoBQAIxWGEgqhLEXs31Xv94Jq/a0FVxASFeZDFYIEQ9+zBC8JCrn/snLRLNE/RrJi9vVnu/c1Ksfy41IAF0NkwXggAraVzdf1U0k/xiVIuX9nwRj15INb5s4ThIdNvPr8IyBB1Kk/ULPuoqPWz/dK2eCUkjB6A9zuFWRs3GzbUjbm74x2Nw5WKyIzd4YDX4uGGVXtpy+MPwMvaBWjBsjjz5JhEjYAVe7a+n0D5RSWNy6ynF61x0eZU5nlMlSYj1Zb/Xo51XM7d6zXyrEdppbE5WbcFw6hCe4F921CTtkhCGFgle7+ENAr5GrYZRxLgcDZB+5Yo8MmS1Lqr2DUFyLpJYLHkDSKshTAtQdUSM2dHqOdRK/LX4eUvm2z2tNKbMLzN7qKmgKjzA7u3pJ11Jii0TmsimBQpb+fPOEJKfFNFuLj0QuYRur5z9Ul66tq84LzsBP4SO53mOJlT9RhmEYFk28WFPuqGSwpMEn9IElE3eYs7BSnXPiqeGVS15ImCEmGidSiTJ73eBchN8SR+JYY8qs/cXmg44tJsPTScPmH99pasMxZl2GyHsnIWgaYNntu8UL7BO1wSydZEJ9zsDXcKjOwNaOcd7oIjX7alxd/1jzPK7awDtVNUDm1nuYsFR0J5OuRHbEXvcVTlLoGjQITVirz4VNZUZogP8qGhyz8/6LdHZcqE3iI2wH3wZos3dxlb0yQc3k3whlid5dWMaSn+3Xv3l08Oo9Iga5w2dFUEoZmiUAMP/EazbYcSV+phhcGiJT/3wd+qKAJEkQvwCDBlGKMJlBATwIaNqmTExbCw5tpKkf6oH2ghwV7sVUyW43JML9gnAtbIOZagdVCnwJksjRCsberpOssFCRYhoRfzyfhNzVxZQHZ1XiHdrGoJkxwol6F7+Gfs33YjO6InmIPqLtEa+0TgRvh8/UREuK1N8Q0m/68R9VoCxrm97yU8riwXnlgfuMWY4L1T3zSbibcsFnFAumVuhcKCvO26zjOqadBIkjvl7s5x0JJgRq+c2Z6jVtR+AbASx/KLi+urx/ZFrg7tDR19HqzSMPvxTpYHEBdOwIQ/wLY6VlXM+eE6j9KMet3nikN2DlYEdUhYD1n+0nlqR5s2GODNpktZUfcLQVnOr8EOLig7PEs3+muUtLhAvSF9BjAZ/IbV754v02G7SX4Nf8f0PirrM8C/qXMMfXRTJC1hsxy8ye/b22JJYYrCWIHf/aGkt4XQySQgxGIGQju4FrIBpPd0mYtEUfTb0qPx0aDPzCZiKYkuSzGyn66/gFDoOn6lvfjIGjC2ubSy0TlEJD2vG04E0ySZPxPXB/z4eylMxqzRDO5o6XO+j1366Pv3si9vMAFxSzf883IMdjEXZfPtK2rj1noJLASWqNhrXoImuiHGR4GGojsmncuCAL2+YT2OrC+8oZtEjdsWbcVp4WtVpZvseAuFV2tw0J6xRk2NZdNbaYSy/gHGJ8/vQRsJidd4LC+wjtJylHeLfzU/BTfi7VIgE2lTqRC2OLBFKExhZzEpfwOAgDLEM4tF+RfOGoFK7hL7NjKSsb5sC/eczdovkm4KxH1fkzCTgUVHl7JiH3vxFuFCg86GDqilY/n+Q6JwkR5i7p5IYcwShi24RIZrL2MuL6opC6dw1sto4tavK/pA2dSO5lVlqHa4tBJBSKgYKJaQbdyq72h+m7WkOsQDIpkxP6qHo90Fvv8FQ0iGfbApx4ITxFt/oo9FEzH1XHHOfM6ek+A0WL+qwHLIbcQxst0ouKLrnbTb3ppSQ3kFvNbIdGZxB6SVFXLMEfLqcEQbdifyDGNJ5LnBF7qn5UEl19Gu0UfPQglUX2cdTJKvlCKGwqUTK6FzSefyUDzisjaAj0MRqX7EAJkkMwz3GsJ4/W6HIbxpb0hJ2El9X9XTV1Il9EosLDqxeQZmh0jbIoLFW78QfBpkAhBoSNTbZzdHNoi377rcCstO88OA2o3cX+7P3KaKV3fAKf/JyTVfQwWonhecjlNP4Q4qCzl8ZjZFTetiR0sgfWlBeQqW4vgLcarB89U7mZhDTYaL+ISowO2YvWTOsD1RwJLNXsdJZk6TZ+mFTZR9FRIRAS1AUldLpgGO55DcCBxJPqo8zB06snzb/llD214oAvud2Tw9fMvj6JX39HD7PJRSAYeOGkpxPWtwGRiSRu+N8zWLCLZFHkYCiY1TSa9vmMl4W+40SQjFHJEvpwTZS/hINLVMsxWAgOrSbwZmXpFuzx/bKOp6mkk9tDQX/W7W3Y33mlWcuPPdumX4vmOk2nzbGZaiPZMr0VsUyZqwHXP+lYSGJqJYbJYzA1aXmM8QBddbWGVMHLjY/JIkLM2NzTQeygxjFjkmMrtCuYpeFGDUHkA4Gu/2O6pnXgP6Rzlva7P6S1nGFKXORQL7Ny271LmR08cFPxnvdBnrHz3HJ4vaWSJKYAONVF2PfNYXM0jhqXvNUTdx2y/hXknhkA3uBXH0KsmcEGOUGpV+oXnCvixACRAq972afUbN/V9AEICywr06cQRAs42zUfabn9teyErjCpzP4GCjm5uhX8qfchg/3rkOsQn23UQHXHlchLQ4faKGqNBxe6/8m7uWRWoiSMDw0WQpZBk39idQNCwhHJ1GaFix0j/MBexlSdUNIZ75lM9ccPko/mqrChZQjbBnmmj4Q7Q/Zdp2sDa3kJ1QtcHekdnGXDaazexTlzcttjfHkn4QqFJixYlLD+thkvqjB9MY80EKbOrAeCA7rEgqylv7IrJ4eQORZgUOaZxxVtVcOEuWg8q2CLe5bzLrJri/dfJn7orJNp1cI17m1gyPRiIt3/DCDAnUant+CSt1wZNhmy1feJRuNcHvPSyC6EE0tZ0S9A8F+I6DLHV/ApVU0b5BClZS90zSDIi+y42cLl/tXNr8r4byySbqIUFLC6EeT2a4yJaq6yOd9IbFvEman9T2yGlqFlaXqalPcnofS4+7glvZ2IavdbQaKpT/9Wkj1IP+/kK5BOcErB88rIk/t5OoMAFCQ2RV6TmjGkh/RrvL0jP0i/FXDSeJzqp4Hj1VaYVUwydEyitDmxSamH0kIHSXad1pUoTXWGNAaIjINoIDObvFKLX688ryo4m50KZeXYskPz6qTEGM94cn1KLGpqQXLk9hHHu+rFgD0alibuu+HwFwukLgjtuJeccxIqDdD6aU6gj8ogDwDCHB5IjYjGKeGsnj41OZ//h8yiIQng/o4r9Mig5j2wl7GXx1vSkf1cj72bTl9z6HfBdOTpbsPiHtPAMVXJenCFzuc7Se8r3eVFOK8awusBNSQu2TneqDPrF0Uf5O032FhHSxPMiouXFImmQv6UIpAyrXj3bjQFF2INL/7MFwL+lgYArRykXYU9+hjhflR56LRoT/tRb5lOiwFJznHkm4NTSIe3shpgA2Z0/MzA8BoGcIuiWnFnMJB8HF4zCYSfviugIlvoPz5Ygv8o0xtCMcuA5X18+k66XVrNTIUbY383Csp2SgN3Ttxrebd/p0bHCLM3lYDXi8xZc+nmlntX+0IUmnvZcbyG7gzxcBvsjXvxzE5qoQ5GUChQY5Ot8ae6xca3k1bgm0yoLleqoyvkgeoZVzsC02TWae+oZNZrJpK7vjmyUhe3clNW7hL6b1876Zsbx8nRIv7r5ixdXZULPL6TwnkqpRUN1vl9g3XVihlcIzZi5N4JCw5uPnMusc4bIZVdJskUub+b9WIF0wBhF/6PXwQHqq5EC5g9ZgSreRdhZ5Jhl2DQW2LhS/SAp5mKkTUoJfJMz9q6LfqPEY0wmFb6jg1DUrZbaIKh5ZDBUYDTfR8mms6bd04V9MyHWE+yM1in23s9um88yhg34BKbo9OztU3IJu01w+kex8Uhl/10qX8jHWHVWSVDJeGlWdzWl1m1YxPcTojqD9ItkrQbDQWm1EVM77L8kBCicaTwCKiqVmzlHCfOqu8l6Q5inR068beuxDAgFSvenA9aQCQ2rYpn7tTQRKdzkMul6MXJ9O+ZllCgXobd8mg1BirBx8oN7P0YYXHCUaS+g0fY97mzaD7hGuW+sHiwLNnXOBB5tfGqDMawAjatR+ZKMBYGIbi6vW+U3xEKVN8f7jcwF9JAn0IlYebZMhVDAP2ivqlJZMLZET41xELtmNMFyfRvoZxoO7xRZNGQ0/Ir1ydOZDhRHXUdUtOmRyyp+PWNzBRg8TGbOrUPbC/z61xXZA/ALphj1TiIHrU0Q7Xr/TVo/OoFvuh3wlfnQfOLyEV2wnq4sckoAL8s/WWAwgeNTMsrNig8zXxZJHK1WRZBLEhXkKaQFThCnXeJwnoZmxnbA+9oiajOOFfrzj6imzsYAaQBOcl/4jU+ZUzA6zgiU+9o+UwwtgbbObYP8kcxGJvOUuRBpjQfZv6PGwBN12rOGQScFll/yg8vIDHv4FZbmsqG+MOLNow56tuBFAEAujyoIPnsyxqWCgHc04zlC04sLXx/TIa2kVuulsXhH0iMa2MFiRdK0bOfOJW38/HMqmyX5VcBtY5X/d6QIUU84rcIySiR73Jqeo5zRLhdNTgNmcgii/YZ17otM/4R+YLi1Dm/U9AjpqjAvK6yplYXdQunZv8Wwh+VHQpiyhx1LmPEU4cNLZc4JzrGYmE3OUqGDMzqfS+YaYMMiXHpKwVzI2rVMnDzABK6sfFFtQTxoina9asrc3N/L5SiHaXgcq24Hm4khu27brCHoQ1cL/uZ8NhCOJFlGJVmWCpi5TrTkxeZU9EEB1Pw0ALatSzAhiLLYZzu8vCWlUyhGbngRBEQOtVkovd51FI00QuQDL8aodaXk3OqR5vC7kgzZqo4EWtP6sRajFemq+JyyZYqGqw68W1Z0miupmEEJVJiWkYQ9trKHfZqtt/VCFdcu+2uL4OcIiKlHNUbh3LZrZHzS4om5Nfq35F/mehg6XEyuMHBNjUjDLsFPUE2m/Tiq/TrVoZlHt+6YNL4jrhy/CuHkE/c3e+zrNNEFnIsu6uRQiG5oXMlbdRuKMaqRuB0C0xcILOMmTHEOt284tNDU9denfWSbPI/lzqcAEdB2HA6PEmYWeGmZGio5YjKcs4cx/rvuYjnHELqIvomhkHnd3VclRsYjp+/ajZOwvsYfyF2yhHQ5YdVtEzGcjPvcckEIiOPHLT1UDCE7fHIJUR4SY7bP5qM0PG0qYIOQwTtF5ivnczVFih9is7vMxhzbQ/oiTpORZd9gFyiw3LtBVX6DkNM1LzaIk7LQX93DyqUXY/arn2tEWMFStvlTDD0pVjaabDJqAkjXXe8doSRuVD+Jg/OaVjB1vh6Yjp+FyMpBwF8z6K4yF4mYCp2gUjLzC54U1nTIN6H7sv3Zm/9Tt51ftuTZUtPMwmWUPaWvvMv22jSbTBEvH8DNCX7dOtTdoAmKUEWt4B1OyVw0ORw/v22qlXw+lkqbhtEOCVNeAH8AcXUuHBQt27aKt+2MIU4wzCDkA0C58138QJot7CX94+Y/0jMaOzIqga8pqWN2UevOUKMIBRUX66XkmmGXADh1lFvuuT7FJhuytqVLi+BbfFUPpySVBVxJz7g7C0ayYt09S6DAbOYQ053P31HKtDiRmUt5w8DOFta2HyPBvBKS4QjJsXuDVWxThOdkZFmM8vv+zewh3b6XNj2vaoFeGl+xY0E5WYQR/wIxqBzTMzOAAtNhfEApXxDLOs44s6YVKEcYFpsFFk7xFS1DG13gkQ4RY2zgamUQSm7jmldnf0F2vMNbqZM4Zhp11r7K/6J67fn4n3AROD1irIJYvHtXwOMfNboLnqXA/WghryN+ZXkCPAkiLGJ1RTnOxYk4GaLRjZuMDlGmFuJNL2FVYVrm5FxHl1h+9v55fu5B6J19pJE9hHKXhMig8UNbs+SPyWkaLpGXvWgxowP8UMCeigfKCerhsi6z66NCFmolaO49oD+S6XNvuqp1NDZn0jFiVzgaMtva5y1tZkQMnSS81nNCQD9beWArSaJKDeAbmu5ps4w8uTs9EPpkt7UP/pRUNkZEviOYPrRztMCJEwTIkgVa8Zv8kVUMJPPpY4Av1IoOahecpe+m2qyPsWn+Ifl0UMm54TQftbqWn0lmOvoGE2tRhw30+1Vs5KW3c/UovOzhGZX6w3IREi2WjlkW/x8NrZTgJIqq/bXBhTGlM4DAb6BJ7doQ0i4+1Z2lm2b/gMgdx9AK0MUTHfTt4x6ICM54x1g0EWqd0YLUx/6UzyQ2ZHfH3P04I/WGR+47kHyUOWsjLQ5P5nfqWMaxBB/R+oj8uEeW3A9ZwNjcVInrEMH5eY8eZKvA1w1f6rjVDF3VVOd9OhUsV8eUFc/PAfNzB1dh6Fohw++AR2l7vdVesSZXYc0z8CV2bMjqr0FamiAR/TFkfzI02JwqiU2R5+GTZGGlqtTVCtxyd3VpmloRJmbLCQKNI4Mai393svgUyHSfJBn8OwMiluYbcozVyTBEbpEV6yt7JJGFb9ZDAB9+Z0sXlfQuUVjgdJIC+E2flSvs4zAr6sF9TkjvUWF/7KsSltzoP2NoKMnXLoASHMyJeuvai+R0E1hY7DhgnzT0mpfM0x8SBOfbhJZBa0BNjTWKUI3VB4q5FfwrVvJmwa0zLbXK0aDfJn7N9YfAJ6ZVcLSBVcfX31q3AHu6IV6XX7nYQEs3zjm/c2+X5LGalHieqiGNESm4ch7oF3J8/CM0hyCDHn3icYhERYhanpSRNT0Qs5xiKcDMvyrEPkzOyucIDo/bJvT67aGko6zXgintpeWqXFvPpF2pYl1oZpbdIrSHlDOH/EwSlFCAIO4NccMg2PXGqVv3QQnmGwTJWozcJDsDLicB4yGVbPIaH0plA+1k9f6mxpp6MNayPkL4Q+Lpsi/Z0WEbjb+9dv0vR1Z0HKomLzwVuHmE3WJzXytaAzDw2tTvY1uL3wfokDIIST31wpdOHRx/iPavN4S44R2Vgw1YRDhZKIQW49JCY2aZshDzwULyaIn3fwoMbZgHbVXCPLOpkMd8xCC9ZF4QQU2tmKpmOxeX3gQgmtjdQHVCZ0mIuq6SFzaI54AcAHvWf9rJV4DBSfkVEAGvWQZsgoKN4v1ensXkqCQ0Xb09QfdDPu/Kuky1y0qEQnLslyt9lw5W+51qhEeqvikavswX6UqywpxIkoMKX3jgI+QyAHkRaLi4YmXyqNMc0P7gDHoPcuknOMgj2YFD/vRmR0zYR1HXa8bI4mmarZyrlV/cndGK1mvUxiYI1Wn6Vyv9ymZwo5enhEWRqmtcXupXrvzgK/jWUrlP9SF1I3EhnypAMLwfy2yKlV9K0iya0xOR17NEOh/sAZcH3+qJzfhhMelipDUj7VtkdXZrFtmcOr671JbLtc6tKZ91b9iZKPG+xTJrPyPMqfv4mbwerHgFJmlDZ5KEuagKwzW8pH1Y74YORqKuF0JmHwqgo4GQdN3khm0uqneO+W9sbXdVpDQ+PZ2N173VwAngqrbdwHufpWnETRv3FO2yfSG9KBgBeZg+jk2jA4H40CZNOGS8OAnR9MACCr2sJto+yzF+uPL9Z+wZ05r7+zBBYeol+z+goBIrbNWoHfXY20z/MGcMpChSRhY76YnambSef/apQWjEVCfDWM3orNKQ7s7ooxcXNS9UEwurF3PY6UAYrYTbIMEr4fEwqXyvzVDnAj7TmA2Kg22QmxEA1U1hYUnWXeJSpki4LXyEqddMSC0Yctd8D7cq60rD8MCXVWs8yu0JBBoq3eTsw81ZUKSs52U0LR0MWJVLQKVgrufC9QWDuAAClvZXbebTtBcVw5gr9CQPCf2jnbjd0WGZgXQi1cEuJ+pWDfaFkmcWbCRd7jX52ADuyTemaMynXXSmU52dEcBvJAeNuicN97L7ZJbfRlXndnOT34JXjMVQdfx7n5rtDFA99jxXPaTYe/ZhDkUeX6qHClmzj5mXPJndTBMy3LwTLuU1q1ZbkSgv4aJpbmAYr0LcWnYmqvIT/bX5aAfhkQbCEItzQfyc8K2LKeW7qTtRlBtAXrdFnfEmcffGaGXwM8xu/pHhTLBvxiV9Zx7RdsNBAhgUoiNA5S+E3JpwbdqpWcEted43hjNSjwlmM/yP4dF4zXhYO8hWLLsMBrWEluk6e32q8BW4xBAM8WZ5I99LEjRfWXViBY4IZlW6MbAK4w0GHgsaPTZo3ZErxSMwMxA8cXjqWTTiHRyRrGKo7LdBfpOCan31j6Y7oDRJ08Y/Iz0VK9q10Pb8MVgf8rJRpvY4w8/k1LrjRbxfB+KjFFEj6Rgi3Fij6DMKoggUL6PPVfCnRjE0CCepB+HZGT1PH/cGXRH11nMGlyNelFi9N0c+z/gIpib32OdGHuexQu24Tg3X+yXKiADwPCywBbcaQp3RIq67W4k1X3isJ9swGieFluwY6VMEdokuTrpYCPHYvwtfRR3Z+CTjKfIyIYGGbher7mwZn/sd1VfOIZYSkd5UP7VPvoCGB0/5dxhAV50pxbyVAl7u2KOio2k2wljKuBXC22izw0goIPQvrkLBoOzJ6YHf9ZNZLMNZY9ofePQGJJhgwYcmJdUBjbcIRDqQtWD1SX1Jfg6bIEu4iGhMM/gGU09vyGr00cO7ies+9ibtWlJIshXZVydj7lfAq4f5sK8BUEmYm8nnx/wBgLHnaSf0tZHRRcrFBvh/I9oSsLDqXtM4A9oYySbAjE3mt1G5BlbKlcApJtLJSZkWLeR5L6Rg2wZ1rHDdicdv6Ml20tuujM//9xMxbgesePTIRUxYN+EDkApH11fi1dTD/bHl/CeBpPX06SazGKvsLRcqLUByk4s77ELnzNqZaHZWrMltc8fB0dfiZnAm0l5lo954kcjP5D4wxdo33eJtvcyTkvzLH824XU1eKjwUgob4UM7DNKoUqkiilkbBsZecf7RHRziyhXE+b5ALn6DGu8yjM1QvHknIty8q0dxkSqW74mvJ2+chzJ8youcf92c1XhxaX9BTeEr/gyK4eqvG53LVVi+j4slouMhJebuuedihx7eya2ZQGOebpI4DhLFlJLXWCUOSKR3D3dPd71Wgre40nreM7wy1PYv+ljyJ3HmmJm/axMJEpicBp2jkH2QW5BbUJqjvytjVReqSg455lIWWQizds6+DgQpMbR8/UAegAEqlGQh5o2y6tulbwBSx8ORDaBujnwiGWV0Wdiv0h28VAg9saUN12N/u57wNWmVoSn6vRis/ur1keiEHY25rcgxsM5HY9l8BcehyV0LNshVwSiNMLDWuIwaJ/6P4Ytv08mPRUDoYVinKuUifvez3YvnG6PAv5K12o6b5QEE42GTCLZz5EyHuuu0FuMEvikAzO1lpk2MyFY/bHXqKyMuLt9K9pqhLnVLY4L+ltz9aBogc0NxcNe3f4xixVbD/oFmlc/Ocve7kWU7SlU82/6LVre7itU3PgFgUesc/HvXQW6flIAF/P/9UlLD9uIr68+j7fA03euPVMaY0KPKYslSRzPOxMjkJfzm6ostDWP2wraa7PC8df4UO/fe1HKx92/qbNSR5IHgrGh4s+CTdeUg9DWnMwMi6HeC8PlCnZKvg3ynt3sl7ic1C68W9dZF3JzcgKjClXD2cS6tn/fEd1emBndZMxeKTmrQXarCgifzTXVcGG4pfbCTohR86JOICS/pq/sndaAVNNXiey+431w8hGJcYlScaEvZNb82BC0esP64FzxPaM9+7JaIypvJXvJBQ9BbOzLHMGITOxsChJv4eunxwmVh5Wk0sUPuHk1txoUZi6E+GfwioikyKSazXQy+L5M/tWbE81XsuOIFCgQ42K+1xKaZTXYcLyVdxLrCLGzRVUQYHvimDi24ZNhQKZ/LpfG3Y40weGmPZV5oMeTJRp9tgms18MXLGudxz7H5yPi5x6p88QBqXAZWDvl3uriGCPkXc4scgZphTN3ASQxBj/l28WNDFilXtfujJRyPOZ8q6L66BYVkz8BMXb1GVFGyyXI/VnSSt52iDNMk25e5KESEKYIYyVRwuCYD8Dfb3mHavGXHrx2a5I5o9s6kxHkD+Tli3CBLEM8V9VkjLYI898lybsOnCza2rYOxHWFlyiIYW9Q/2em84lYRuLEUjOETxski4sXMZ4xJobxtTdAOhlUhpTFYma/Btr7KuUXrjvLGPXMrFjm7DlTOl4GjBMjWJarX2w4IoLODDxwSlqL3exIejGG5QIu9T4CYQ6GBVNB0v4C5C3QMnDJk2Mr0RKFri3sP5jWSlRPGDT6T/snFzsQk4stZYhUf8A+/Pw+FuaJ92aCyHFt+/NGuWdEb2j6qfmxX2/rHmXNI0vdBUUzva0C++B6HhnOdNtW/GgFPiqggDxRGDEeNBkhtJ7J8jUaIuAkIZvu73efhsJksTNjmmdkA2HEnftnrt393yfWapKfzd2B1Cs5Aa+Z8spzL3dFUdhJ7rKb1BoAPmzgbB8HeqlZIZKYz1heKH2fpmSessr69oVqyiq734igb+FszmGXlKA+wsn3BGRfxDX0C7n/8TmXfBukfgS9NcXvYB5xXLdZePkaZcqzHtHXF4bkyIkwrdEK4Tz9xlXN6jV97yqOLoesT7mZAt9DwKazeqkrTaot0sAnpZaQ/1DADnqS0ZPEfysjinpPixuwBt0bd4FtopdNPLQx73K8a9ZgasR3coAkGRbGMLNLC8xRJxo8KViuTmFgF6atlHAtlflI5f4sDN5u/mUp9S5Osknhzh4NtueKCcejGMBG8lAc1wjAKp6Lxem1QQFshsEFPBwG+ii70IFFpHpx7if7GXpNQh4OwlaqkvW9WBB7Xc4SAMh3vyatJTY6o8cTJ7hVOC42+CPQLvL8BT+I0T38+SVnuOG2FFNsUNYEyjqzcHvsIy3q2MzigtYuXx239PTm1yUF48Pk68AgKoU/Tu6bwDR+hQxPtBx9SQtYnUPrKSMNkkWIJw1V0Sx6dbZsYBR038Oe+YX9Vw+HiZx5kw9P2vZm+g269QdglRTLkzufx1JasL9LBgCgaVy4yK56+1RPQcHDbxpo9U7LkhLj4oreNRGF9gNqPWqRh99HXpOQGDgbhC/516fG3+u5hnrWxCfTrAyGvVcFkLZJGfVbG8lhQn09IVLMklUAD8lRDLrno4kvPlWzVbny3cLPd7OW97TvH85Q82apqsBsWlONmmBouA+jzQ/vSFNHE+uhgssCZqNGpmZFJnx51t9nE4PG/S+mSJLlqFOGfnCwIGaQcqQJX50ntSrA0kwOmoFrYqqFCdraigfkWJp//xSr6ByDp9wJp8LpAdW9YHErZsHzbAEg9ieRqi4P1CytGnorj3OnRxR0tRpRPad71bTc4Qmn8tn27gL+YJ88q6UPq0NtaVkLT2tpWTd4mt04Udx7ylhS/hBrUnQnNnIjNfgieoKbk3Nj3MHwKTmheIVaedve+suEeDmikDNfwFir2bpX87w5iMGuD6Ln3uqcEqxNKvdcZfk/SXZLxMEZA9qSTSPrthU7tmTDjQKa+DyYk9Xwms7ngdOUWl3yvqt2MTBBAJ4jIvBaQaiTho9UNfM83JpHrW6Ngj29pc+UVMkYnS5C8FKZ+6+/oQJClQBO/WVTf3tFivJZ+3aNoQqToExXguM5iu2Fj++cnF19cAPcyK1cznTBJ5+RQorpLCHbUFW8NemBd57qFHZ24haXKgCoXn9Ff5olD97hGjTcXQJvBLdRXuawX1TSwCqDSJHPFMwkjzAVOW8zzh793Vg7c0KnHkxHPZabkcw/x3HwXUAKfKPG9YoRh0m1URjQDAoeTFF4JdMUzf+0Z/j1PZNg9YfaxccuVAdmiPxv1HwTTVRF0rVIxN3Bj95n1A9rndoZII8bAyHuCwXUJ4vI851kpqL6Vh+/zvbce+8QlFjiR5MZOp2FyMVscZlVKfbNGUzbiIAeMw77grZQ+5BiZzADYjRKZMNVpVbCuWylDJY+HSCB6ZWPp3/zaA9d7E11XGksMk4xlEHvh0yVeyY/TbOLMx5tTaVwoB/G553nBMmgmIHWz3Bgwgbxv1yg0+V4iXtdgdfNW9TzO0XlL8muTRkw7+xoI1sK6i0TdnZKdqtothQGHfezgdkD+y9sWZsT3zUvfJWkRfRTEGBS+xVSxB9Y1SmvNyvQw42B8IWFLcQu9iP+ENKbpZWMHR2LdcMFwyhOMETkcDH0kw8jNZ05HmNfeem0rMsvIXehAi1n/PEqoOPm+dYA99i+9Zn83T0Sm+eSEqYlXwaKRZTbGpY9aZW0hyuCdwI0YXKB54RWRVbJMnsxb9A2NZEbc5ZJ0MhhrDz4r8pDJrgGSA8P77Kd8qPnSb/0mKhF+SqiD+J3gN0M76saLwXThPrlLfEBJPxAn+yY5yKvrjpBGi6Sp9yhil8bP/8HZYVg5loS/ROPUMHJPBK7e2yYy/uY1XTSq46WcTYEmR8ww7kTk0V2FG+YtPplBfK3w/WoBWWkfTcCMlEQyWkr0fLZuyiDrWDM8SpL111cGUWD8bhPblAQwDPxxzOQy/szWQNu5LJR73t7yNN+0mQJYteDL2PLF9Uww5TNASlOe22Tlwva4gLhwaBJk9misqs3avOLqMTLLyai261TKV3IjSJMhksjMqb/cCPxEN7cUnrEhYkwIPR5q7oJB4R1klbqUakeL0ONt40Y4BuPzaRHrUCzITT51054JAkzscHEFNaej+RvU+exPBWb3KEdf7uo2+UEqOZ+tnFZA8fEc5Y1arzzU3DLKu+SMJ2hdMnZJs0JZGIgRRxR23WiOICWgvaF1mfko3wmt1NDcy179e63k9v6aqet5v8msHfVwLpMKLG9nbWaVmZaNiv6NlxUYZ+8Mz+tvGT85XSPWUY9kln0AtAEyh45dp/07VgHggjOo9bPsoERiYYNLfjzBes2atBwW9ufW+oiAhwQT30VSD97cM+Q6KaECXm6KIxLgOT0cBuu06dMBWLiAVT2ScVxXbMfKeWEhzPZTpo1PJag2Gp5UbU+8vKix279ccgWJwZL6h14xSI4SQO1QTzbKBHIhA+bf/wxXhZVSxJqxpThiKmNbXObDFfI1UGq/2LllvYRvae3+4wsJOmHqUcdrvWxjk0QmOkzxGL3shrWzo12mTClXAzwFpI/pVZfD9GgwX7riyc1rWtXvIlStPQkTNti8dm4fl8hJ04oTTOrxnUBs1uGzY/jpS73gtX69PmX/pd2Mx+ZkhOn8w030YfgQ65fi39MYxgJtU4vaI4I6VLXS29GLZBdmBlXwMpsXsvLIKpdOmsLkykupyrlMByXmlBS8GsLh4FfKnDOS0qRICEk/cAbO35vauXEG1xUXmMjXUrkPOVFPvo5xhHX1TdHFTj5fy6Skwo/NdIdk58kmPNMkaMiJSH70dCdDmhaDS9/AMLPdqzdtqQ8Fq8g68NLu4aWoMred5VwX4oNNzeQRB4An29pmDU8qjepyGqQRgGBe3x03I1bkUnoq+7rFQHEErW9dnz6Ta1ifwA9SnxpYEjO2sfDMezcpB4zptmlLrJhiBsRqkg08ljPykwXHxLT8U8M9G6MvFOP+ckb6LE8ahqlI1Ow/tfdYIaUsXlfJ9xrdNvuuRAIeOK1hislTNfz92iTmXA6V3dQxn49aprwBK/Eww99Q4tCPjbPwHAH0P+Dy4/6IrjHUqRMJABSKd83I2UiHBUWFE+sC/dA5tru6ZxCoVApXurE/HJ8bUcGhesy/uKq+9BexWdUT00Wzk29D2mwPhYYyQtL441BcOrlbm2kVl0oUGp+wrAVe98RrzWCV6ie2uqD+ntte5dzPdL2AzX++6WvCnIUhB5wExnIQaaIVFbqXHVy+VNAOA5+1nQU9NsWH728MowpJEsTRUO9rvw9BSsJyYv1bM0ERZkxc8sw1lQZNlXAt0YYze2G4P6m+u/dDnNX1lXuV+PzqTVE54KW3ZqO/4SBfzwh/FgrrPWA6LJA8s02sc5h26azTpIT1nj9Y5w6fZZ0gKr/BZFDQAubXA4nt/apukbGRfc4EdGTi1KGVE4oVTIdrHAjWsEEHNZqOo1wCzQ57SKhFhbfyfvOAQG9slvFxCX7IkFUkigKSJfVV83YSwrSOwL0ya+xQc6JkMesjn4wex1ASttqd0ZOtXxEVGXZi1pzPBd6ebzXqcuXq9UuPtgjd2aseho5YwVPN41pA3rMKhcOT7n7wNuj3rLfVRwbDXO34suzwO0gSgJ7Q0DFkdbE5VOWktF3XToiwKaln3eZ17QxBoIez6Nmn+ErhEQTziIb3jU0Mi1UPJ4amZ7sP/zRvk+awb0PeVdeort0jXPKOF6xyNgq8/WMWRIErlw66DrDnzoVoFmGB5uj9Mr7atMAXHqakLJnCJdLBIOGqxfm7ogW+lwu22TFoMQoVE2zOOJzK2U9VEYq3cLIXIcp0s33Wvn28aO7yDzXPAJoYWT6YX6cg/s6yEHsitWZGWto8rh8Ctv9vQKl599yI9alg08Ho9U/o5jYdsliI0K7bbHGu61u6wDCnDB/yHnIO0PXc6dPWiQpLjnK9wyBcKBvTU14oWR7Z/tb+LSuJbVFGdlppQeYpDt7nwi5m1Rl3MVOvx1So8b7LmCGMylgcZ1ZAGs0GeEUaVpgVce/YvC7hIh2zUpvb9DZCD2SziLW3TFQTQkIjeG05H7LXgwfVoLoSQaek4Yik7/xmTgsZKFMF+vc2TsPyoXCIiXcfNNHYp64ROywBTH+P3H4dmff1+Mx9bQAvlun7p6HG/txfHGKX8QAMMY4mcNQb/EbtOTqyXtXmGSHmhKFN9a12SqM1lMY+5299iRlxjRXe74DL14fnZL8RH5qT5QTdYdFYyGQKCYlGqqCoTHlwMmhsinWs+7GRV13x3/hbqSHNf2kwbfA6yEeCe2GgQDSfVH6w1/6TPmZjoBalOH+/cdXzWe0PGx08tOOGgjA3lFssVeH0RGyufu44LKuGThZZ9aw6EyPjhe/nt0P1QAvPp4e7hxOLy4Ccy6SYiSVittc3NFlcBzwR9NvK7poqWYid//up5e9fqit41sLiOzug3636d+R6rqwVkvh9K7BdU+8pIaQH+IQoaJJB5iSlAWI2vedFjgx0ze0BbHQizmF0rCXIpgNzeVX6WKjxpj3TB2kG/nSuF05SMNg5rgBemdhnCrWZmG2+Q1y/EJQyYkkqWQGVaSVxJj8iO3CQBxM2aIYdZU2u0DaFaHPVt9zuXjc53wUQFnpoL3/MiR89f/w8Lj63xkzOwNbFOIYus6mCv0GjkKS9rstYa6vefCc3nISaY6XqWLMFa2Wpmjsi27kVIN+spSWcAvvah1rQ+OMJ3ooeIkdYX+bB37U8RkKbYycsRh2cokqbEwgm05vnh5bGfZWqUIXSe75KqtzkL1DFrKeS1oRmhgXJdfLKJpki6BnnkSSleUrcSwSmVinPiy11wciuI05NPcA59h++MAQkDQvWvCvprG5AmnZ3BuebRMXWfL3hFjmgzhaVs4QxDfjPcX1uNHKDc+8ETUllrz6hEPedxfuDdtpxjGEbvpQFSZm+lO4hFdZaYAX3d/ATbYJ6WxXaRt7LnB47YBJ/NKobUSnRtL20o48q2dgJ8th8m8iP3/LD1qTIZTn+WSSmf8flq1Paf4xWo+tFkVyvLtw1VqD2EKEPNAfG0xrSVdD7EEJyr7DCHaC2eopni7XLAUw6xUTkOPc9f1hy3VmTvC1uroHAoGrAOhS+a7D6Xg0TEJcpotr+b3SQctGKSYY4GjZybJDqOabTLswgxxtWfFW5i3iG6aIRd3FdHGgX/hz6xx6QN4WZxrj0gTE9/ZJ/eSMpeqi+X5T0hrrFHI8IS0MSNr6RIvAp4POio7ibT86BJ546WBU75iEqkOLdVOHw+imaM9PrmrvxfuGRyerYD81SA9QNsNucu5B1ADJ2dMRwEV2MjR0se1/XwdpEZ8HxwGnOjKM2nunymajmWThuz4NyaSX013m/W6++FkyJSvWXiqSEBCPKg670ebi+UsmehKVzSaU25fDXY2x21QxRDGl9q242c3VM0xv0sISNGvy7CBDqKq++GlGR3Wozmpvb2Xyggxo9vQs4ttJnRqD0G7hYkGe9xmp7ZIvM51BksjEUm82FmMrEzjKAZ0o9WuCtRPMBPIuoiPTwGsvI+ju7whs/jI3qUl0hVx5E88v3wSEIwqvARjBaf2P7Ugt7BfdCDuBJ4/NfYzWWrc38LGGK06FfXrdXxzs4LBgA3DvLYIT1i85MWrSR2roRLak4JULZ3a/ZiJKUYg7Un6ATy6XionLy/3JcQ1X1UAksLBzZlqYy6XEEwKC27ZSAE1YwqIKooQIJ2MPQIiAgHk19/BKRMFfhf9QLGXd8dPTGZObECV71eiZsysevVqeX23SAG4gfRlq4T/a7QzjnBUxR3waquVRhp8ffwfETI6yfVgTtpACMuAp1KSfGRoB3bxBNnKOW0Wy1VpvX6qx/u8DsyB+ygI+qgEXKGZLskMzzGI8F3vZxcHhpwzYYAuh6OMyHGNZ08820mgmW5XoZIgTGsP9vHSFXRwsgjN2tKCbICfCfjaZIoswtvoy0Bz+UiIYoBOXn6BAE1VM24dqKp9SIFtt1lAi5kRu5lzSDXpaZTkOXF9p6KSjqok7SFYVUcIwp/JgcpIYcLU8vnbEyH4/aMKlJfB/OaHcEkZbVd/o/5nZRlT9lPOtCOEB2sBDcIRcSPxnMlZjci1Y1b7KeMmCzm8xbf6dei3QSGmm7PneKiG4SohJzsrCiF5BF/4nLGOkmNwIka/YFVkXaecfGk27cDynNXFgusj0mXv7BjNusTE1dcoo77dfS3Ux8ApukRi96tDl+2iqKj4Lkv8lltb7hbE1lRFGkbjsQnHPkXy5aObXtlb5l6rfHvFCKGP9a8dFSHVBjD3e/6YQTXqCeQV4UX4+LXwuaVXqTHdYFuieINsfyxTBPbaZ0Yk585VfpHgKBuzYCDcXX3lE6XYlaLXHhly4uG6gfIFAyun0iRVbVskRWopTjfl0bY98xmR2ilo8+YKnum6I045G6QIB0rHXttQgbpsv18nUsK8G66pujqsge4/7aVz6IM9xq4YuwEcE1A8RVfXVrn2FMTFn0DaHs+gM2+M7LcJIMZzLF1jnchDIdhGTKT7Wlhp/eja6DUKaCp72jHKlcTrNlGroS5spAjYv+DPK55XDNX1lsfk+1DNxyUfskmUiUIMBoQAcjFq5ZOHvzoEzZxV+yOR31h2IlrwVUBNOFU++FiEcYd7oJaVR1aqfPGbaKa6Wt5qLTbFOQYkR0leUpmojct9B+6t0wOwMTjS4v8zK266nB6W3SrqWXFJVhlxo94gvRvAVT1/FKO1SpDZAjgcZH4aRT5UggxVFqdCShcBF7K9p4DCXVnvnq+FlGZ1nWEehVhxCln4pcJLxTIt9HHgrQM7RTiggy0E5sDmPqn3w6geAgHfz6w3qWqdNpxHZYJ/KtOXsIZ4vi2OAU/5bouKD6tY7sAGL4nQRo6pT7IEQ+BnKV3Ovd7Def9/TMqaji2RaIjqzSIhGGATHscp3s1N7KZesMW11JbO9YAqrRPxZ/liFN5CYvhx9AaKzYNKAFcjo1X3oV44hIqBHVHQTd11WvZDMfKXd/YNU7eO0YTlDjzw+GXI8Lo8a8NtvEbRNWV2xeieZYbKHjvxGgGcYx88eAiulrhhHWoHxcyyqgG+nwU3OWxiVXNxgJ5lbA7+jEXS1KAumJfYMlE77+hVxKd+gU/QQvag8OWj2oWUVR8b4q+z4/1zqLooxSqOCbCUQ5CDglx56mXmEGGVdv2jlAu4PUyolZqi6T0kjnPTYw0YOUfN2O4+6/Zjv3dXkxpmon5g19ANtZCtrL2+6MlgI/OyW7pXzQGC37Ppuin3jwJzuoiRimifubMKA33Zrgcz6jqjAbdFGNKgBfYmAkK0YnxaxeE8zHBjiS8Q8MpCgJZqdO1EH9EUeYjPNKLh4AQgrKvP0IEGGjWyiMrTwVfs22zqcG3Lqs71jJYTa4rxBm2H+bv3JHiDow76qj/KGlyDzs8nqjVhJYXkZPFpTrLdnShMVTvaO9X7SNeA/wY9T/yi5L0jXqmUYnRW50H0zxEt8N2iAUDjyMDqqFJpUngz9cAdNothrTzi/VgtlI9na/VTa6eYhLcPWVZTuKnPuO3dl0XiLgOFMaU8UPthiw8dyib/vZEpKZPno4ShCFWZNx1QRKVfAXPEEzgLcNEWQmD8ZKJMrTFfWV3ndMRAsE+I1wUSvpdoXDIXTHFzT7GuJVoKrrbNNekn6Z1ZbBNQfMq4izjZUB2e/JVhHRQ/nV8QjpCLA9StyxRs+YSqv2zzau92PBdtg0QimSdFdRolz0iinqu1OzEv+YSg72RILbVvtvTwegBSO4i70rysrt4JkC7JdUKctndKWUrUB7nRREkHIrakYvSW7sYaAQZvTpQUno+8Qo9oqqIQhjoUan1173Ib5RMbLlRo9KJ7FVSpsIgUJlQV1RHo5R+t5f7GJKZp1cAccRuy0Dex/WZq+3p18Z/sdX1V8+VcNse5ikgGGJwskzjQvz5FCq5cgyaEt2BE8PHL5WitUQfAlJRbeQ24043fu9R+2A1TbvOT3j63nHMFNV88SHc6vYdELIOjzXrjn2PZ/+iiofsh7/PeA7xMZF7TESHpgTCr4OW0Me0I+cAxduGWGZN0OxmKQCRatmewZZpdlGLHvaqwTBtTjub1wxnYWOVf6rxizQiwcKbt55KZf04vinx/jX4g5mu62yhu1tiR4lKIUydgn0uQqzp4oQiMTJw/8lwnEVd4KKD9cAPSP+zF2J9GGuqDiqxeyqmrMSzk0mNeD4vERcR2Uv2acj/fUXqfS3rZ09PKVQRdWvX570O6X8nXx6ZV9X8ZOrQIs03iaJJ25726nxp24wnzwQ+dU6V6H+Mj5BtY2m2fSpeNHhRT4vh8zvbIwzIbFsGcW3MNR6JMj7UCc07MoWDBP3cf0OVHni7QYRFEaxBPSkOUN/sePa9lTvH39fcuCYLnhfzvtDMmxMRZViQnkc7wHHPNz9q8Hoz3jAXBSgFRmUIkTNetZYYhPPyOETCIlrVPyQqH0ckvMx1Csvdkm4YJTTMFVtFPwC/vZhbA3nMkhpzmAseiyPLOcvr+kgqZYJcs+dSIJ8FIPyQHSHpSijRc7JMH8w0mAeVsUwnFU4Ty/x2Yeo5EkpGZ3HHtt6zLjU5thIhJhaI85gcxUEIexJZlwpwcp4BXB7lils27l9JEpB91i5Su+hzDRFMHLICvi5VMxf3xNNJPpCtxRLNhrXghUemWuEDOvWk4F2oWRa7av3XEzh/0xSf2ime3EzSugAyBwG31w+NCDZ24QiaF9xzVwFCWRO8BzxLlcjKxtDOUkXPcio+lFQtCpIXpKK2LEoITnFkgBU5yvsB2JyIVscZQMfT9dcd0rsAjHC5qRjMQrsejL9KcWNBkElz4WzOmnXiKXkoUlAaJb2axj+SR2oPJUG+xwNVu8feceHFw+6aIwBa6+VPwrL1AFPkIqfhr6/fz9jwpwNGTdhmWuV8aMlkQgVIiFB+8J6+o8N8cgqkfQuRNl4E9mMgB9WMhR2nyf/i4U92Ps6dherWCUadqzjJPoXv2KtVcKLawRpKOfd5792TYa+anK140L/vFrBEsflIOCk3M8JtYWg0k1ba+TJzm21Pj5dNvP6tgLh7SzF80ElGJ7b5Abj9rws5cZhRIUH2JM7QTncUu6eyS/lxy0YCO8OwVEXtFIpL0Ef1rs7L7VQcqhX5ivNHvLUyOm8LRTQBTTcdXTUMAxWzONIVx0UFxa3ZCVjE1dW9QoUUbrt157UdSpzJKa6X50MDAfigchWezFhX1p60hA0rK7+6/ddKmHEQDXotRVhzlsfH5X8Wnztu0MlfCOJONff5vBbd2yqeWfMSt3j3hlEEimoxEu5SY4nShAF/w0+AfZjlrRKM37KvKfW/VybqifDrq3GYHvjL49YJuHTkeRhkWHObIW9pjGVOH5GKnmtRCTRgnyCFvvPpzMOljl46F338GWZiKMoPmeJ/xJmOBSnckPOnfZuGmwF5UMYkAl+RFmCHPzEkSf1nB/KFixu5jAf+Jk9cuU/SK748aGoBHb5J8UQnmBJk90/xU38AGaVuZ4QyBu8OP8ik4xMQmCrvNl0+HxvrzSYv70cmPXWQRrkEm5Ca8YxMYmecB680m+vDyDP1s7VSCeMJDoWyLKr8dR+yqTvZZUic02dRjPIcbr8LpiE1QNwTgEyQxtY6T9JQ8rDFC+ZbCoHUs0dePba/JPBnc1DvfT9sHMZ9ERdrZ4K8b0z7mGyZQj223S09FLIWj1WcgIzkHMPQ7KuphLHuM10Qd1Ea31HrpmjWElzbebxIh71rCUUPubRFux+36yNGFiHN8VUeVkikXXRoSb+q/db4mVpwvnTQITgIPhzJwt6yc5FQyjgm/fqZbUkJLDb1Z5C3TNY13fPo48nuiSBj2U4bcYNwvbU9a5MJg8K9WFaxRHB05cSWvTH+TQjA8Z2VT+zErLQCNoEpYfBYQOL7TdqzreZuVlXrIeQub7BngZe8zgWiQKRTlyDKqyWtSjpqhHNhVDKw9B34WGW7ZIN4O+nxp2jdjZX3m7E5PgvRJhDZXTJzOKqDNiRFfyiC8whOmKjmZZmW4xNY8J9NRD5tX1CMegBFX47mH2er9dfC9pP/7j9H9CfQHj32sJC7ZBhZSwxo+VRt50sukpZojziTqrODyG2obCCNFHribud6UYN+21VqbOw8Q2/tBmDd2UnG/QueA9k9EVsXqUAVs47IszPq+xupx6TB7S4Oz1aKPzMQi5ytZqP2LoTzCiDwocrDGOL4suC3OziWcp0XJFRPuG8o1vdz3tOKGvt0HYkZ4Rbfrt5uqNOB8AcSCkIkLIousOOYeSXSQNvy9BzSZMt+66utNbLnEruZUfWPAKfbIk2o5HtRwm3VhWESYFUrWsv/F/7gyAMGv787xNXpwgEhxnlmfCmZeEcgSgqYTLc0wlHmHSSc7uqY9aOkm6yeM5Fh7JFm33m/t/x+BAKAN7HXqIWT6C9txs3YniKFtO36v5KP7kKnkcrfaiwX9rEjhBVmtp3mRsoCbnWvIML9XmS5l/vD1rirgMedqcPZEAStP4xHBxU725M7+1EthxFNlYD6vAJnHvGmylkZcLFlO3GdxNqCbkimV7IUCfrsggr28GwbqvHqMbtxd74x4boTOyqWBlR1fyUWvHI8sV3DozfBrf7Ajvyp7B6imH2dlcNeoh2y06jhpfUK+gj3rl8R38JeiQ8CjrSnYRAlXnPlEDzcYoAeEsybilwBGjJQLSp17jAQlPB7Gx2SwRO/FzcQNeDpYGrC+ynv2zrSj3XXe+zc1KAMFKSR2luMIq0ChQV2FdWLYJahIy6lMFGD0iasfOt+nE8nuNyzXkcdyxllwnXkkmm8NYcB2B25HH02BE6YvJeEiraMtQycXs/mwnP+h7d2GfCuM0sqxCLiVjj8NiI2DZSgd5r09kdTkf3FEI7Ds8Ex/cd5X4G3j7ZCq1aWu5YAYq+EHQru9EdD7OaLsPalGkheQQ9mNwlgdDZOVoz0Gr46KlYBgGrb+Arg4bAaV0jdoGuL85/sOh/rtV8C/vbvEJ/Q5eRI+4a5XfZoCmsBYFBEd+CQiW/U24j+jlLaK+zFwIga0CWnDo7js/Uy2ywxcPjvCywpobOuHtcUHlBzbzfVhDkegHsJ/7Qigi0u2cNOGpbGIU3LURcg4pX+cnhlFicE+I8UAMvryvbVuj2TBsV9vkeEc5+sKjOJ3mZQZx86spuIvCMT+0K+EcJ0gUkGFwFXW1oMUm5WhNLsAT40KRNj89c6376VKUCkMkf256OhLpurfiXnEEt+jIFD+GuQIMpHzdVmULzC92hI2UqNyQ806CfogiWE5lUWihkzmCmUBXIt+HukZKOfkI51xmsrtLTUCfh7WVa6mID+IXAI3S0mSQD6jwgUr8FoEU/aCOgAwjrghnZEtjMEehctCxTZ1UGmXhLUqwq0lrQBoUbjJ0xIaYbK340tp0BxV4cqZSxDd5pWGyIGxOgL0oV0MkwDs/dN6WgeF9BhxSYPKmhEYCYnoZBdzuC0u0AuDXDaPnJjEyiNZRDUjlDGLvMXDZ99hzfIqJQyaRHE3K60yBw1Wrz41C8dUCqbljJpycHQ+Ilpy/MrJmSrYUD5+CW0Ev9P02l7aZlWNVS71Z6lUoH9PeKM1vjqQkALbE8HaMWgbWIL8bKt6ownxPc5iN0nGgtRwJFNBw0EGfkT/ypD9s1wB7oIi/O3WgT+1Z4I2y6EzcZfY1gqe3Fb4tbGlMAVABTvCfrQj83vCBHLfjg7bwkb5zfDM9T2dgg6q0t/GbtvSwBVgy3gDgcIkUV5LjLfIVhPHpkURszMGNZXJ2QDQM5cUEXa2NVIpzpApjIlJ+xH77PZgDhoHRxdGzBwSgflWznPfxNo5kiLwAUOCSm8TuErMUipYjuvBDMVkM+7twJgITPJ49g8LZTQ7Et0f4A8FS3cK79TdQlmfcHs0C84G9gBUljDEcDJDsVoA1MDWECvpTXeCDodKB1QJyOMFKC2rLR7N525X/upQEIIpQxqhYRb7TQ9VppzgGyJkBM//jMVi0ya1FeShoT08+zQcIVKHEC0Etz58kq6S73s7gpgNCoonfCjwFNOoltMv3fTDIyg+HGCbEDbKHiHTn/ELu6emooczJaBufiX3/FCvPu7evRG6t5DsLVcGvF+ZtpgSvdmxe49vIYGOgdLy4wINrdgMhWRBE4RDYChuvJRpljnRnTEPN7AmbQio2OZjftt55FBT+EsR8w5hOZ0JynaAEuOhwyScUezGN/awy1Vc11ZE29fFjM+M9ikYFzX8QL8RSkuixUw9CnnfoRjOcT+/9ubLDU5gzoHIA+WxjCs057zTwow5izcoK4P/QOmzGOM2tBxrQ4pJ8WUftUytzHVlJY8v1rQ/S42GhAy/oWxWcO5d218/jS+RUuCBd3EqWVWSQRYX7+B/5oVuoKR7j49Lp7gv2FBrX2bsVJOb4j8pe/JRT0KGUdlxVAwaRE2OKxx9bzB8mk+I9obxnbAeMDKXQwn0nhHrsRaJqw5k9KxKCbyKMLtTtuNmi6RT9NOE4SCW/TFh7Ud67hAZJvBx7ayKqBUQl8yv5V6BCSrhBV7kyazASwEu6nA/UEDgeWOJ3LY4HiiOVkuMLgRBqV6690PzqvawMhQ4plcjFD8PwroqGfjVqbfHJJwwNHjeBlndKRvqNLZFxEAGh/J69bxbh1EZGRySBjwJqtYYQsKmeD460GumVPfVw7ZFzrb868CfXChhqYRFhM1TZJxkC9m0mlOe5tIex19CDAyrH+ct8v4lu9lmv6uvCAV7JUrdCdqtDMVH6SMF9f2+2dd4qdU4M7Uu0YnZUlNz1ahdpM+v2lxbiv5Z/aroWW9eXUs9AQZXvk+34xpSPYa3jl3tIaK8VW/ahpXpsZYfn6eCub5Ej4eeXD3NZkrgpJoqJss5M5cuLZuwVN1RyI8+w6zMaAOlzO8ABQ1q8E8WDagahc1FfofwwFuS5QxW913MqHCNtYr1Bwe1YjBSwTEpR1mwKNphdH53Jf2H+dSUFUmlj+x4v3X2/nz/L9KQ6dY+27vWiwQvdrFdBXNhZcxHUljtwZH4xgLS2kqp2ilM/9HnSUvA8VyjIjZH7AzkqqN2O2UyUOHATxzZ05bYw/PjtXex6QLHBEp1L9SxZRF6Poyt7qY/VC1dif09W6/phJpY0PQGrc+ZJ6XhJMLc/+C67TKiVWzKOgCVHy/HjxbzfNlkFqEziXK8LdpxbaY5GbcJzzGS9X3wwhvlqmGxfqZjdR6HQEzcln9H2HjcOAluJ7NsrAWXsYRI49NZmb6bDtB35FzYyOGg7osFQCOC1vzie55CBU109EgL9T6jxl+uDZuqTlHbnXfBjV4fQIHNg4URkNNS4uf1SXL7wNcv22/A+RO57Sy6mAz3ypJ7RxKBv/catE0mWT2ldD/bd4tLQ6uCsftk56//uE0kqeCSmErqyQEJPTfatODcsIUi8EjqT/ElRVludnQDkMQVFFISZGcz0/YuAU+PARIN9f3YcqNK2u9TAEaxm/QtudKVu+UrVtApPHQJC2fs2KLKEJo9cDTDoHplur+CFuxNWEDxFOmrREYx8PBTCxbk53fxek9dTeL+f6ey97c+Vi8++Jan0ectndZ/ZetJjyrr0O0dCbroL14l5CYCTML3eBD46sXrWVtIVqjzhJZple10BcIpvcJDl/yx2V0YcnhRyUY8JwnKWLioMQ6+cgK5cYU/ilXWoX540Pk/SUSOZtfzeNk6jKO21h4W04E+8Cd87ithI+bGcQmks+3dlIacxMEyx+Lwq3I8aiRZMwoxv8wc/CiWtWxt3aFMAs3rWLVWaB5+FdFKfL6VZWzu+gZMQ5gz1rCZgDgQf9cHkJOv7s/qHaCU2S+Odf3OU8AfKuPUJRa1AYhaXBlKJyrx3+10WLiRAi9oKTfrOaA8/mD0glbYDbk2dm/zb78z4Yp4AKBHXDxtcJ3C7aPMBzm1tNZEdYWmprR3CGyz0TL1ivylZ59GhPjcL5ul3FJoiaogEEiUROmOjeROHDswkqduT3fijO1Wq5x3GN9uBA5fpdtK6V81hszaxBLV8Bk3M2r0yZPmgPYqVO8Is2p4x7WsDzVsqV5/QECKYpRwuY5av1AmHtBfotlIV3Mr3Eneq6Z+HOQ0cSMoXLzi+NpszZnnRP6OIqjNEDWLFxnNodWuIh+OczrKfcuuZAho6et/cwQb26KCxDP4QOnkx1eK9p5IZA1pYhvbd1myfRQh/xjYmEJpsYp2dAs5bZLboBN1JgV1mGlkAm3OWoMYQiUCPZj1nzYvm5p2QW5B9DDGbWOC9oOohzsBOTfYU1411JZF/hZU9NgRB5Vly1SQWpFzjG4sxJRRnvvYxqYQJUHsuI8s/+8ZYB2pDpMVPrqp5MHflrYQIM7+68iHnuATDdnhgyU2Mg9C1o3xsiKYdO5t+fsb52Rbk3MYNwPqswrs7t4kdknKiZ2luxABOK9TUutcWn3wZzsXGUjjmmwxkLmGWM/HiQ7YN8yh2/vqrOhcEME4n0IUp6MY6fCnb5214spT7HA4EuULlWjDmhOvtbyV/yegZ8b8kt1S7DvWWe/Dqvko3gtjZAhrjf0XElLRbFNLe0C/ciI2eRRDZn3c31AXm248bnW+rpfeNzC8NHFN//V/+3tNrI7e4O+bGDIqXx5j01IbdxeSI50wmPkoDxbWesKlMfHDNfUXg+5scw/qnxN1ZPxU4NJQB7m4r0LCgIvonJtLTKEEal2dKUB96Jmar3+Y7IOZWlR/G91kcNHo1yL9zdRWtZdBV2LZvtRL5S+uYxZvGDXbqcSqsfvZprsZUmM24zpCdDh9l4x3oXM9j+DAFaiuANluQjrq8fO7AmQnj3UINQnromAs7wq+9coDlhFkFTjehLL7QRpOogethkCvRPnpdNdE2GyY0qKelGSsgqMrm4qiPFWGEn9l1aJhc8zzITzoWAOXCRGfUl8gJnDYeaRZm5H6Kb6Xj1oqmLKQl/8h6MAeKN/eL7R5ZyWKTPiY4k1LsFMVxFmX0dCRBoWR9/QrG+RNWaqQuG8ZgHYlamJ9sUoS2ekyMBjqPVqbTDIw6EO+1e/AVbYge7pggKN/9ghSi5WF9y8s01s1n+jIKrTAGTLWaqpEOXpbchJw/wN8xSjkKYWuWKYvNlRbw1OVEkMyADTaprbienenoZurb7sCsuHylAwfAvbi0XG4YD9xVob4mNnu25BOWXIwIgXPUL+pvkvgVhZ3fkfuaRfTgySRt0n8w5IQBJSKl0VmoP8NZ0lbMN9UKne13T2Y3S14CXRgoC6LDN6Bo9p+dQBrepercQSUViVqRCtaQpVjWb0i85HX5aBDdgdhcLKFCiEusw2qz+HO0+90rOmfDM7mxItdo+QEcKWa2t2tml/NFj/LGJVSFbSzICG8BDKdUIuUhDQ5MNsqL4Khp3BkpOM9PZK+7IqDGBBwuUklHgvXuH3CmQlcHg7CpD1R4NkSB3nkv2t7Xcyb7Zd2PiW9hJKI36aLoW2oWlAaiaDATXyv8ICQhfOFEJ33i5cNs57AR17tAYmyMfDOYGFjAuoBjS01aT6bvWIuSn9QiFxKo1DirPhiNDsm/bqWhKcZjWqVPDIM/NOgsPX92Xfn3KWAMjbrPeI3vVO2hNM0g4/gran00apZq/L1Sw6LWlX9KzbQdl6khk9hSWuBkO3LjsHLfJ7li3yR9Wc0i0WEiMGxgoNHgIURgPTIgW3WfQtmcLt7JHXfahAQBqhsH60d44AldKjsbHmzu5gpLlI1t2x0yk0md+OhS+UnzlfWXXtziX8ezobRyzUpahzcXvd4dM85KUpRmrQaIuMYP0Ir+r/+Qvqg7H8MwARYwYabAaAdmayYJwUGa5+MIXu+4wf2WEfzn3GyceQi1kMQxPSaPpQ2wuyrJjitbyIai8D8VqUoGP5a9SQtCS3SdxZG0MzSyv55MDrZdgSHzIcXNW+NaHuFe8LtnmFWxeDxMZgoR1MaZyLdkuW46y+VscX9TkCxnKYZ9zQJO8Ejpm0zFrdCLTZDVMNYxKMerUqiIGWhmPPocnl0iqWPvrYQPUmce7rpWb4vdJnNo/1+Hb7d6/ruummIPpzTP1/JKb1fpvkQpzgcp6/4JrCzW6Uq6hNBPannf1XqLZginODvmvPEeo7npCJKfabtKl2xph9q7cmCoyB2EBmgg+AA9cJFdAOhw83KGPSZKMzlglwN2pN5TSosfzfA7TNWFKe89/eR7q8mJARCb/bS/AkuN/5zMzzEmqjyJzj4YDgbWS3nrvCDXuETQdMZCkq5NFq3Q1yCnSJ/ULEeAgsrLrpzwBhM+lZFH5hcDrHExa99dwoFwL3TW85YEovYwlq4Twko07olIMwdJSoR7X2kIBh0YjVunGVBJX7ikp8mXzKrPt5kFIr4BumR1/jZUwLgc1SBLJvx89UMIlSn0dvgWzhGK4sesURzthXJRZpCYXOuJFpd7bYhTmJ9Cd2WQ2q6YL5bqXKt/jD9Ei0uigkz0rwHjmjCC1IIGgZAa2ln7kfYJUz2IRBOcSiEvjbnrlP77qc94Y94Cr9sgFs9xVp81oERHPmQKO2XulooS32IED9jYwYG9FZhf/7tSXK5cnuOvgDkcIS9C4l1IsE6VAsD9Zigmi6BU1KDtvA/sUZupaZFdrg9yAfVPVWDWPkJS8ZA4x3Q2kVxJTKZnbPd2XogtFBP6aj3DizZPaSAi2LaNbYJxo4JRd0txBDikDQZ74s1IuQBVMRvHDfS0jxuj+9V6g3haxq6qPkabynLDE1DgjOOZZQYsDP4ZKzJ0Obm7MWpOupLXBfozeUXfi2pOfkFrK1AiV1CIaWNhWWCfQadZ3X/8X8XE6qc0ZC3Uqc6KEZWcKj0EYlrMgZhl+ojjHhMoEb9rcYhEXSFEZokYWsvQVIBRjlaDWsETeyTmLq+4rwUEhkpJhrP8HNSLCuE40wORLttuJrj6tGgU7mbKWHaanJR3KDN2U8gYUmZpfDnufP55s8+XqIZf5W1B4WSW9nx0EPAPWhWzvBEYILSVyaJqaDN6KM9LX/3mab3qRn7asL68ickbUQYQaaVXrCzJ55hsVmQahKyraZOQvpwWiNkhb0ZLUnjOhmUCKq1fIzXyT3FO+/cckoqqrq9cznXbAKMSUqrtL58xpxcGBja1TobPgbLXxsfxzD4nHwHyPN2zyqWiNqT8WNMBTYZi/ZXSX47wVguoXsDRjwZUen66eToOy/r9YCEXh3RFSQF67duW8/9NrEzEdhcHDKbU4DYXBgzyXJQ3qx9McAFCP5MSs0+LZI2VUmAoikk8/zvuWsgWL8aEB0Hx7bnlThlETGMYtiqZlV2GLREPOiJHKjGyffX/iNGQzCJkMYKqFCSnBfvxy5Lgd6QXv0AB7vg/K0gQqH/kxuUiz7XAd09DjKipaVORv3XX8XCqJ28ovbOunA8z2Z6MZ/9G0CtNnsm29xM16q1T0VJX/RFr5GjRfCXRBWCMzgiWsgTp+FYMgbDuemL7LW0CVlxgExTFSS8Mu+WfGSrda4PWkJmJMznlT4qLkCTnlZHDRh2fzfYv38nboJomaPSbmQEtALPcu8SMrKYdzdlA4g8MHNL1RK0ybMBZaTlAvxuYCewj03RHtQb3xaQkGtve2kr07wUcdkkPBIVny5ydfAhVebyDsVm0es8uXm2a++NVcI/V2bLYBF+9qSgugCzikybgOt2KaNpuJzZMRvlqp8+rNTbZGE+SGKKFW/EKbjeGZq1xC9ONof9UE4lItL6cbKxA9FpWSKkn2OL/iJL+SEXRkhEdiP7SzsLLfxfJ0cCn3ofM4XqRYet+CTY08J9VHnru8zSkQB2mbTNeX+2ZpsU/oQ5O7XxXEd9AjEZkO070q9qh89qgVCpvnDdRGltLzQvTrA/31r5E7/sYGYSsSHyNmQ/oubvf8g1z2bmWeck3wtE4Nx157DMD+ud4DehH2XxGvMAjHVO3lEgBjwmIH7RldP96tw38X8yFVWxu3Pqc7vptPKNnop/CebLPYLTBImmMaI8/paHxYp6W7F5Gw3R9CI7GE+N1WXYgNwDEgs2OYbFdqSupPPgX19b9P89LVy+dkI/hBPuOfZVI7MAZW1Ho7vca7Bg7KQDU/LUygFUXSXBMLwxmHn3fbmLqAsILS/e7Q4Tfux822mhp2ZdpXoAzZxipPkw+DXYUuuqSQkW8iReQgj3F/5HanvLIU3DQLP0nU5n4EDkHCji+jsry26eoV4rhBijgo4mlDuvqBT1bDiApx6F6WJGvCLr5cKdfZRCYG+aOLGZ4woIsayS3HrfS4rB8nPV0TQO7DroA9UKUzuc5E0PQsKB0w06iUfAQ2pBV7wu3rGDfAXc+1hlk1vfQZaz/VmEagEBHHaTed/FFmfxgrFcCYZEzIQEmS1lmgPX9UZY7bwxy4yk1p3wjVM4mHZkXcpWLi4OESAOTwcG1hfHCijm7IDwrUUPF3RnTruGNjo2l/w3gZDBUFh0ccVzC84WtJRjZUkYYPnkSe+0f/kHgMewoiV/rXMS4YJvDMbIjBxJqQXR4cuDumyimWlfaZkXeRR8RpjeOTCt1/6C/vyYQ7VVCnI6b2bUs22HmhdtVr0bEKcSvIm/ZuGwNbVnklc2TxPklToeidNIMDKG30Aug5ubg8p4uJgrNT0cSXvjdbri3HMLRIFFVHpk+AzWi0qQcNbnnGj2s7hz8SoBcLbimQi731xC2PGDGk90X8qOE5ZeMZNaMDjhn4aMtxvYTF0fATcW8ioTneyZ6WxpBImOkEaEPhoJ2u7Ehhy80Bnt3ywQ3Iy6bsxfxBnOUcI9CbHhgxkhLaVJitr6Wl08WyoGxDdKLrHrNDTAI6RWu3JXQKitbMxsCh+5Q08Vlry1zBb+qbJ5AlqvhN4w77IGWw0iAaYcpo0XlTDaDIk7o+2K7NDpqPNJ8q/MhVwEnCAqcqvHkYSz/zdVFkPpipB171xIM1YgQdZ3ss6+WBmphbtNQWtCwEARJjWnu4ye3/5ErZiLVkaWEdkqSMa1i4lor1Uh/U2XjsN2pLSHrzmTx86irN7h8/aCUwKqVOX0cfFBhFlEGvmcp2k5775Y5dHEfG8qHw1/h5605uutiEWTHbDjakO0fa7kFgWPMwL0q7NQvF/O0JzH9PSUDIvI/WbIvTEl7PcP3ZDi5hSOSHGktg6IsTkOaa4W3a0evpKiE9nwNesCDd1UP8ZOZ6oqQQJbWLuraM6dWf4389qZxdwHWaR6kWpn1cVYFM8mKOHR/nYGK0NOb83TV/kTUm7F3Din9fnxJyX7ZZdk/rOvy44OSc8SVQeScA+uxHwPY6qbNbzFAKcyJsbSgtzH0Z2v9Bv/x1ZGKHtNXknt+P4/3kzj7QN7emzlRKXdmz5v7Okt13jc6AF5L6S8GoMvKsvaKEXZ2asHoWJBSvvS40wX7t1NhQfPVBdh4ccdoILdS+HhgSQXdHMOc6DdAAvTX5lZGnn1yb+HpGwtZ8UgJqTwxST4jHc1+Z8h2EVF5CqTitutfH+YrtnxKTrpOmeDaiGIYwsHtpHm6jV5vBIrAK/DKHCxl6+JlzvMvCgkeq/F7nsHIrLeqxCX2pJuACXTpPDfpSeNzT5fbVtE/J/1ELvgKBaw3k5qILrhRoBhzLiat/CsJt3O+9Gw/FPxxtzRPPz7kVdtbiNYDQb5ImWihVSkpBVR2/2FkiyEWtDA4CR5OgXUIll21KWEDZu7bBWdD/+D3O+58EejnrW6tSypHDs1F5WtViI+hWw9O65I5jLGhukk8WpP8huMsPkooA+9l245rhqvQhBwJeHp5LDfY6cPmIAq4QFvZ9kkU7ilAiYiwBjhUYiqz2pLQa1TWriWZqrAyki5nnL9e4IwlLtq27kazcioBwljUIIXZlPRQ6bREFTy8s7Mlopbq+RS/rxLZ9IZ+VwzwA1IpFbFoZoHv5EMcN7fX3Np2jzYXRgWNfZ/kOeN01dAZ+EI8aGqwchG84ORjsB6PUYXK2mi4GNAa8jm9kS+za+hrR3+Ew5IBXxrTdRUUTgGw3aw3GmxQiI5Atp+MpSdBwiTdp5Qgr9d5jW/uWeX53UYffb8CURDPqz++bHFzy2Xvp2NtKc5hTodD1vrWCnaOumR/VkvWdp8jwrHBBDGz6wf4dgU4Z2ZGGpB/KCYzLBvIb7UsbkoFp2ku3qxZ+N79F9R293SXZJVuSWLN6g6im522QdmRDyj7WRe8bWm8Yn68/V5mddFvOAkHLlRPwRsW1R6Y3LKYy38G9L+3kDEyVofUroiOcK/vEPvTP3+aV+YlAqhspaE8xmzF1Uyx4YEUZLmUn1VSKnDKQSchXhGcyQEADKMchkudyCuaX5YelT1TQuBKJsYdmEwtBZmn+x7amdwrxxzxd+niulWrPPrgN6sKek7c5nBUDLzRtURK2gpKOfmzs6oRos3G86ZQJnKBVc0ui2WOYihc7ygJFfNPoutRYUz/GNhPZwM8otGDGTR33FVgyhixRPQBRiGResUKwfX39WsrvGOFOx5EEV4PzDVIVu3kRioBgtWFkxrt07cXWDe6ufPG+C9YBrQ7tKn1ZyOc4C8Wzgvz9KLpi348feBRJPnkn1iO17VBHyvtNBNAVNyDmsgAm4Tm3fBQoh9c4R2JkV5GWeehItDYSWs/ScyblnC4VQt6WBJyg3yRXiIxOsZmPFGJs70uZAkAUlXuyijzHu924zOUmtG90kx4J7AuWbxNuU6Hzr7h83N2yE8BynmZEdBFGLUU/Rxf2jTfER3ahoP/Y7gnVLNxHL9aP2pJ44drMZlpb/WqZLVC5PWKz14Oz3mmB8FBwMnVh5C84hSK3t/c8QuCW61ePXeaMbCUCRe4+T7VQyXAfF0NnQ71pQ5pF350r5Fk+HrgjHB2WV+nreITu0QvpSPiXGCZswh7/X5np/1KO2/pnvYw4+/iXwsPyAAuHJSh+uEpgcP2qKoY3+qOK77isvj5KWrleEDp2jURaX5huOvDOfqyR5cUz6tJa6JASpdqTJPmBLiaWiQHcUCO+JGn5f/hRdTQzckK4OClXRJRstrcKInNth5QIiNkO/xeF4GyXnJBXlIvxDhqvNBSFq8f443fFLcjZdFVqYom/p5k9sUt9mhq6GVvnwO3F/af4UWUW1/sB9xmWdYXvwhE8yIcW18XIxxu8IHzEl/jXeNTm99lxeSywHAO8ryC58RKjgGsfdFtRAprqb8ogiAErLx/1ct9TVYB1YjNqjRU+/vE+eG4YIPzfI+QNOWCskRHnYHPUd85qZD0bhjfRHTDd0DuMxkSRa2XWvcQwxu/lmE8LcORc1sgs+FbRaK5DXGFaOShSPp2HwQqeRsXBbNaHfZ9YoW2aAVQTMTsT2V3h7dWXExzS2QIh1d5S9jS61TvJRr0TUbhtYiAYOsmNbaM/5kAxabpGNrdyaVUHVMLw+HS6fwv9jx8cpTo6Iv/qzhwxNute4/UBStu2yOJHVmVcO23Fo4gHUELAGwnGuTg4AgVlL33ZOzkGKWDjPOcC+Ta6ZzmO1EdLQGfHkx4IJwqmG3xXj2fWQCJhYayA4IjO4u2yfY9pkSinuZ3gucgNRGXNVJlONZ5OmuXOoWUTXHRAjgMIy9KRRTXHgk/MI1TLwBHHsy8RVRZ3nPTFSWLEHD2P7bIhcjZaYvg2gaBGpudGsPzdFWkKm1J8UO1gcrUP18kUqTALco+DUX2lqWoTExwmh6A97ExOibE8L4ffmeZAXndjNhtiCGFWMK1cb2oxs4OlZdzvdD2E/lh7lVYbcDTk6zx49Z7rFtDKD0ihMghf28a4iG7r3X6Uqcc+t8GOys5mTNidAp4cdJ53pDLtPiqQSAol3ib9MSCRdXGyJvr9X8GB3qZttc2DNjE6yEh3LGsNHhK7C4SjiWOnzf5pMx6ujK/zbEQUDbLQy2X/nuSMQPqZzUW2MNkjYvf3euY4Gjv0C5XAgaiKE4mm/zEsw+wHVxxAqEBbrHDdX3Pxaof9CRCjrcSVRhGR6xWQ7k7i/fcvdraprtG9dN+XSgbrvRA3YDXB6bIwDFquFg1dqpEDEkA9jqVkFEg4+93ZAAbRgNDYOKXJFvM/9LZ+TyqQ8xUBCcaHNJ9k8mGf53higOBq/cVKpiWthbW7hTWJR7TqyzpOOuzPoNa4LMlg+o4gQwZ+tWdOPEg+LDDgglfjQnzx32g94XKLWQdtyCJCyGh5BJqyrU5wgAuOuaxf1EwLRNq7M8IU5B0Wc3Je8FOd44dyvqK8aTIHpY0cSk9GMwVpbplkgHob8brhm6/ltJHMEbtGR8uHW4Uqvm99Vv957ewaQuWdpyMJixNKZ/tCy8rFk69tW3KOB/3cNCuaqwrP1NbP+iVDXd6CP5PqcxiyB4RYivJb0D1XJg/1lNn6MuQbhr4pG62Z3cggHm2qaj8WfL/SNKPSiNTMDTAPghhFxriSlh1poJGXM8+UCcplE3c+E8cOKBMymElXDyWGKoXS5f0HiTZShD1c/oTcJ7yMdMw0Vh6+Yyg00cffmNELbj8nBfDV343ql27rVmViXutQgb/y9s7C/6+eOIaNV1n+CUb1WDyKQhprlKWCmWu8LiFU47hLYN2mPs8Avx9EY9PdnrKo17B7YN/y0A8gtcmYUcsdVnHfZi71vJdOR9t/5J8m6cbnvRwRnE2mGHfAaoyNXT+v6/YAaz9q4+HPhKcKfRQzFD/KRBAWIXL51LnbjNDNPEzE1dFl/gSER6bJx9oFxrNK9jnp3Mq2t77nTM9h68mXe3QlOQoHPd5efQfqhaMrRcPlomtSvJ83zLugT8HFHJJ5fM6eQSILhNNf6CwxyuJckg++wdiZEZLL+QyKCi7QsAl49vxQEBAYoPVGGSFjeKBvedHxc19iDQhOy6quGuqwRAU/Qcs4cTZ72ud4qc3OsIE5SopS0MCmTWyhv5Y2VXw+9lYnm5MCXWV/VkiQYMOBj0nFcc2J1D77f0Ongc0rBqHguF3e9KdnWxnbPOiURtefBHCFkQXt6nm0HB3/fWBY2sF+cF7ZcakXdLEP2R/A5e5vGFtdXOxxi8qoQe1Yfmb8VZXX3KeGGEiHw3xM0QZGxXDAWOA9+jCDRHn5kOOFoMxT7vjYWuZS8YMEQjBh7m+Jpk+PKbzOuDiQvMGdOjFNlG27taMw1Xfu7Jv2Do/anl6b7kXa22BGnOCu8lBiFZa+c9ffqKAfyplx6CoSqyk/WxPXYjCurouGAzAo8Fh0mfx8O/MDQ4S+5jfGgcLuGTu5Z6QKFhdHol5TBNS6nS8gMIOMdxWnbqLyotUBKVQiaTB4bdOBfuSQByoxwaDF7vqXMzI0aFsxPJ4bdgYZCColFG8Sijf0ewiJkxRyviZFNTS4BFUoHBCBavzBpjlXpGBs0wz3dpOElxQejTDra4QxQPYe/mmidD1fh1WeRFwo+PIs1zSgX9XNKO4p7Qq/7gX4H44B42tjKMqOq7RwUcwzgoCimbWbD2IcceTcfGWZaEQQOIyuQwXVNFQudymx8Ap10Kpn+ZPj/S1zymODO73H6uyValTQgAilHcHbzh0ZqeybkK1MLR/nZ57KGpHE0PjjfIylXudmPRDY3ZrzuBSOj83F2oqaYeF+OopIhV3f6CEc/zIix4mhDabfwxYCdS/RbsloCH3gaP799lSeVNVWTT5ckR5cvByv8uW4BhCoIcdsnHeWQKoruLwUJzh5ljVxQrf8Rh1ZHODBytSUZqakeACstoMdlyILNSxO2vC+z9ynfyXSF5YXJ9ZaWYvDVEbo3yAuOus0kPI9/VFQfIMqI33wLjAo6fQ6VDlzh6aT9ZOChkoEKQnwtb2nsAKVrB/BdLvQUXozfdrpNnCpbl5XX8Oyv3lN/BV+nDgUMWFVUxwJfL/bQImj8RflnzptOjV5Q3S9YrRhFogMwblLKSKB1AjHSfyabwAS6hseq12+FqgJ0rM1clDw3BpqxtEwbFQoUbGCEc7QfORNeSILTimJbsbAv/DDpgHYHYNa8coUfdaQdeXMlKZ2aCFhHs7KtzEHilRx7x7Y4Ds80bYNkkUpf8ECkXUft/nNQJJ9fTqEj/1Cs16UX7olTeY6W9xT826vylpJVTPlbztVcVZv96K4nXGABvFerICfBo1o6W7dznb5P7FpGLEGGM6NWvYlUxw4lP4NF34KyzocbowpmUIZdvr7iC7w7qwsxSWmNwdGL4u/FiI5i1jwAWX0YuyZqrZYWsNXBJfxnWRaJTZQArjbzXM6hU1K53ujxB71BBILnJW2cNWfJ+VXGyOBGbqHjc17eejMuJHZcIX39HTEWCQL/Eu2Q7IE8KFRFtoH2eVTmfZbweTDQZgEYzo3XOhai0Eg/NGXH5P7MP9aDQIUHUVkO3CHRxKYa1NQyPd1c8iTk5iozNZWAAb694BHSt7u8hke0GfUZvJxbj21s9+4JZMotJZE2W+lgj9r7LMXT+I4stIax3Ou5HDKSqtaXCG4yH4vOn+gg+3qgJ4UeaXe3Cwy1ZdD3jPKVduPfsmI5bGFGy2hlpQ+p6KnyvAOfYmS9wUtqeg0m4Ak4x4DGaceFcQs5lwj39W5i3HhVXikH1ibKM0pC9u4wNkRjoKR6SpuqGP4DB651AcPEeJcsjDorU25T5+FP9hOMTm3HUk/Th+P/CeYIv810mmbHWP52k+eEvil0hnKOH9tioVdQ/uuErHI7AnVywgE34gXYjR3pPTuywMPNZtRig+3OiJ3yWbSb/E7WVpczKAX8HVionDAhNxsKEPmnTAI/c4DbWcXk1ij+lz4yQ7k8Oztea7lcaWSCn4ZJfJ5smzbeZoPAJ5NJ3vLEqKgmkd0n/5MiVXOkM5vZVSzQOzrx8+sDhOgfoR9sANjfnHV6NGC74eEJLI17BVZoZwQdyHdyU7ZbDxqpBDu4udtmPw01BGpqd3qI+tHFvZrxKr748JoXmpTtSC77+LLFsyVoM2DTU5zF8Ma9H/hFKcQ3HDtC+t7TelyR7/aWHJYbM6Gu/F5zMjSQO6zRZBeC0+++x5mBgS5P21JR0bpjj/lkZAFSPn7WwRUIYk6IER+v1kwLClOG6hHZMxNhRACnzjN3iRiVyKdinTTZC/unR6V+gKkfGKpQI4eokz1W6ogvWNkbC6sthe+HWLUIeKQyTDDe2u+kDdGJGtaYmFnjT5i6ZxAET+G0Q99hKan4Q505+iXFpPaV/P6o4f506Ux76r0PIS/y1Nhd7qwiri6ZfgObBHxR1hMCJawEuj6/oBO2wqtTdaFqf1mP0Fig+cdpWIs7x6O6OofoL6fOuVD+JDIOpYxTWRJyKqMpAidNuJ/vx6sQtXsiCNK0+BCjPI85ik4ZVgEionxAS4X+JBfyXsYSjpaLgR+mZyAofNbuETjcovrmLeyuLTUtGccX0P/jFsMlkEYodf6Ac9v3XJ630/2MBtSKkTuvUyEX+4K8EAHQmjNz8tPUCVmmb2iFo1fVkQITU576K7eWOEQZmnLhuXVSk/FX/gxi+nt16/gSkuMp8/qtbYCoe+qLkMxwOtOKis1cwT1iN0oW4/8BBn0uPCxXen95q2DdQEqPKpjP7WRTr6nnYASKLvMHYMnYb/2ZMg10y+iMCFKYvkk+oXePXUzirWkjyVneoOGFLR4iSu3IgtM9SUh3hWi6Y+XT1P6hsotNVTQhjVuxbHpGxTeFZxJMSmL/KgbPpGu6CBCO9CEieFEOrDIg8FH1JxXv04C41iPLd+GineL78ZGE5iDhB2s0F8KOjy3wLD5ZE3VWumqa8WJ/g8b2/vJWtG+1LM+O4qTKj88dqzHLx6y8hws/V9tsxMuP26f4UQvdVT22+snX+TrOrn3THdid9op1AeINcV5UQ0cyisEhUCsTKzR9dlCC1LYh527YArdaLyBDhrSP2lQlpzaqFBdD5b/Xoh05O7AXqJP1pPDjT7Ql0oAnfPVKVvN9WfUeyiX0kCYEArlVoOcpAZ4lVDt8k6X1weyvcI6kCDZFCM0umb/cTWuY8yR2GymvMGwibQSLXf0guGclcnoLnWBVPyOme4EJXYKlb2XoUZoFNulQfxrP3vIRYa+31JQlYTZ9uMrvviQ7ObjWuJYLRLmjHj19+HgVN8fWEa/XaHNbIrEjeYY+A8g8JBIoEo0phBWxqahrXt4ZlglJEd+wAHikv3tf/JD+xR51ONKL2rizHSMP83pQ46+uygk37kkaK0VprYNZljnUor7bn+UVlwnI26oZODEcfExhc1G4HQbkYudYRelf5YSFO91Z+talTLdtJ2OO+huAlwAAmNcqjtSix4zh7OekJxn7hrZLuXnozlcJFFxWkg7NzFFWb5mpdI0LWwVuzNx7m/hU9pGCsLxxdJsmpR91VqTmWsLSdaUNZHZ22j8a5wgc66yL+uuWX73YSawNMSZ5SrSnU4RvafmvSY3uqujQx0lZamOskFBkyqXIERvCst6H6AcrI4Jbnki1YJ7f+k8Qc0RyRABS3lNaPIsxbZu6Ws/rH7h3G3DXAsuBqZ5yrQ3P6IT9mPyvOjPEV5iPkyuOMW7Hc8XbXvSXl+c1z/RC6kU6BAjrnjMTH8YCkmF7ByljIf5YclY9chxs3Z8GQjNRO8vsinuy8zmFJBiWxrcIrRHnJT6/uSRnLkC4J6GGkL9Elr/HnW8sRs3HMO193va17VAx4TMqZ1X3qrz6TRosAa5L2QtSNrNKgAQWXwKxxOlNGizdgrK37rSzhhKgK8yVctVb0bwZLeqO//Q/s8c+4Sq+OIYw5Z8mPkutZ6L9VflAWJz9ow+IMYAMDaxAsBJQyCgomwCqh4FJ3w7sdsZfaqJuVbgLZAt24AptSoLcKBig3Oss2pj61pjdYGaZ+d7ZD5VzRT8vKCNHA/h0kHkyaFGdw3HETWbLd/FXfS9XvfRLFf9I6AvfknTOKv4JbiMtx7HnFQYg1H5v7BoTrf/iCHftK0+0s4iqPZbXKbqsSMfYhimHxHCm+nHCo/YJTj/0Uq6vFwrkyYZOiR8hGOj+tWBEZxCpSgGfKR/Z+kLrlmGGIpQVTkOs7MUHSP7hPqk52YCUdHFNqIOx3PUCDjTpURyHKwyV2RVUyxWSvX9NXHTEnTZ9y7wizW03hMrDGYuOYAcxQG8CtUccTCFW8Aqw8hRE6d0tnqu3h1SmxV7cdDAMNnFKHFcK+TYNBZ7Aq0YFKwC9zSnX6qGX+GebmSkoBo/E4CpzCxBys3cryA58OZ3a+06hXkr54/dhJZnj+9QHjaNjovgdRIo0n/irSPUOxLbMjFhsiOodlWFbrOQRW00aMRGhg4NX/TgjOs+ny7oKPNi1C1gUcWy6O/g5PYzJdyYhqNd105vg0tJMg5TLwtpBe/3MjQ4z4esrwKZA1F7v5IGsHmFpObupPZkwYpPRN6Jt4vuWHXKVAVq4Vhg4S2mA6fS7rHB31R36hvoJUqrIXBhzlM5+yrNOL4v+jPteTKWOCiLzKxPz9XzbwZqph2+8Q2i/zbg6XUExJ4RIWakoDiiAPYA7lXMUvvYlct41LezL7ce1OmukUf75pFwDQNK37c8rP1hivPtaGJwUKyp1VEqsBw4TEJU78S4A4D/oC4v0hhdxWXc8UzvHHlek7Ty7GqdF4oy04bxUCnctyFHxm+759R1ghFbxCCvsYf+cktmQbi8KaANTfzNmnDCKOMyw0ppOGJp2PqNe4+B2w4fNE+KDcbcFfXs2VchVeb5EodRPiHuH7sLZMUOfuadhLoelNIbzvQObnBwyEVuh1jVi7NlSE4udF5fmszH1m+ehGbO1gtk0915VyUauFLliR1QBPUzi9AQq2D7VjqlU4ULbHYDJbddIPIyKXpVAh4Def4Gmlp92IzAwxK0gFR76qmIm7k1BPbAVmM7wtYhRYOZQ/OL/jVcS8brkj8EJdpfDUICpNbrtEgj6BXCZy9cENAcmwZWh9Mwb5XkczrNXDw4N6w1VtNVHAz1sFC2DLdWa9SWJVsgj6bH/9FeZeM8GjwLYvUObJx0GhJI5mJy7sl6yITuXW7QCbpDmtAQXcBx7JWtBf5aNb4uKzUdYN6og6uZt43t4XN9LX8bwUb1TqdNjMqHum+7DqeQ0MLfnJjDbnFN0MR2jQz6yssUrOwJ1WgS08dnryIaX8xjZIQ6w+1GkcedjlhzIY1/BoD9IcWWrSZiOiqJso5vZQdXVumBdh8U+6Os7XVCAzF2V6nz8lRGMuYCMwBMYOwVifza2rA091kEJuGJ4E5u4WKYLiGPbsE6y+BgAPwQv7zpsSzFdphuBKOnXhfVQMUOrQXkYP1qOEKUeH1fFXKPdo7UoyNJA+OdiI5ISkqaS9pFcLpBoMxAmCGBwe7+LNU9XYkFD+ETofHIcTzq3kuBAjAdMAf2W//jRRnaNny1TaDw/lQvsgQAug9R0YxFlxDiXbwWRaBgAltZ7224oZ2sAqhJfCRj+BjVs34LBn9C7hFirJx8XWmVerhysVaGhRHz9VU+sAFCS5NRFjaAfsWXZsJeSmkB1J3y7523OjzM6N5X1WF0rAN+XDVmFjn1l7GKoYhiH8uL4ujEk7t1QYpRuKM3M198E5M+l/JwM7W5kDPCF//ZUQi9h/vupSD1P3o5yeXdweaIHkaZySK1pFtSxITdz5Mi2itataJWSBQt7mNh/4j1Uo9HNvvdkpd0MBiRVwxax5pyWo2IkAKREFXiZE3P13Hk2x4hI+vcdYkAzB0I4X08ebFiofYT0uxdLxPCPjbVv40PJOVEx5TA1s4mldCXkHMCH4q2lorN06vVsOnXzzKHj0YOP9kOBXbr7MEnLSdVxZHtZ65JEe9OF2IMKOv4aWqeQNkZK9Cv52XJumRlsL35m1JY64rKqX1y0i25iajIM8ODB/dbuCdkNulZ7RcmT4xqYd9Ta8djWgScTLbwL79LqmwAbMzKQZU/2I9f9+M+Pa5iowFl77P89HeEzbN5sbKQ2l5nT4E1JRy1IY7UF/6lEwpRKRc9er9MI/rZTuQ5oArSbEcgATNrmQIBbPhF5C4KaRrHaocNaGYmg/6lHiwbJTTNRBZZHZVfg63XlUERvcUn47xK3JGrLNzRLyVdulsBiaGQ3nzmDc4w6DTscwZFclQ5TCXG+Nlk9Rf5zpqe5j/hEAKkmKSoP+A5weM9o0J9MwKWH4Ez6XNx43gU0ojg3cOxEFW6zV8kHrs6sBuSlybe9lAKx8VYV1q2bqMbF6OYgKthrHskzV8r6Gzutn7XWXNriSzieA5RlX8mSemwoYQBOxWZuClCZBtJKxmh/G6Q7Tqec0tGDbY+VUEoBHXu1FmtQHUKBeQZPWWKdoXo2bhbmRAROnQvb+bszpyFOrYXCyVsuIkp51at0YPTBnw0XTw5KdyuQppLUin/AFTn1GG0JQmGXEryK5tcnRl3XbiCjUbVJw2H/5wfI2V1rjCeW+jCdKG/GAWRyFKbE7AMkray/hC8D9xMdfCViBVnGiq91YfEQvvRfjqv8hIUkrqopEqat+J4ojoStaQVdhaz0kW72c4iCGuld9bJzYkzXaWAi5OCPJ3KjAxsYdyDbu0TIqAJdHieYioRAXlBz64AShdMlkg0GLioNJLaarmsFfRrYXtK7YvfJkALAeb8ftPsuw6jVs1SdopOskLwzPeode3W6jzEpKdm+imSzGJ9vEcYzNhnPoCIH9n5pWhZ+kQsxMCzq1GFKWEBeoP71BhzMxPNRkvTcc0TgE9cUC1/Blf0hgDstfIedWp+6w+K2ds9fGFhhFnq16TrbCM27JfYzWCV0tq1e3aI3W8HibyU0w8uFmDDd6Ksh8u5i6qUesdv3MnF0mvG8Vu6ykPOb1/mVr8KsHFfoo/fSzM199+m2+K9E8VGBxYKPV06HqyN7qPeLkdPUl99xm9TirWqzAK84skNn9ZO3FyGUe5Y1EOetjOEk6HxUbSn0v2Rw5BVDofvfQpeYvLKkVuHetG7pXuVu8uFUqOELYKMO6/w1PY2Lz6H1BRlu3nh/bKiJU3mfDf2j4ED55Rgxoi4aUvPYW6mvhFhS5lcafqxHQyFzL4+mkLMABbGB0fys0VEXmkThnG1uYZHTbUc078zRAtdPL3YywanSiguHCydvYGe1To+y8DzOZ03dP5OKhPf9aapfvvo0+lGqrbsmUZiMKC1AWycZP0MMZNPXf7j8akT9mkCfPVOJ8gGT8+Osy2GFmdyfu4YP9E/qWtS0JDCRXvkb8uXkEuu9la791NpULvw2v2KuJNFF9ONIeyD0U0CzVMAqE/uVGcmZZQaYd8TOLZacXR0yermfhEJcYUCuzrPFIraGhei3gxcKZ48NO2Q53/JO4Rd0Zpnli8atM3MD7/3VbcWlzGyBu5n0KrcoSchT2pteNrZMO4e50u5RR7wfmFCUweN2n1Reojk2OinHlb3FgZovY/Djt6P85K+XCdIJoLYnKAp0m80CkEIH9XVdRcwbNd5E0cX2ino/qA98SGzbu38KjS5bUl7buZImlV+C1LTocNAle1b5+8WN3UvAuvCS8Nt/BD9wyIvoEZYhMyAb9xwP7jOYlfLWbUDVFgH9ezCNO44frh7txW7J+M++OpGspBB4JzBqt6aHcyrIFiyojf64ZnsJ2v8WbK8R3/LVTSBsHYIn3aB9bZBQp8knCwo5opKoCJ+UXwCKRQvJWtiDCcZBdhDeWMFU9uOQBN7CJUzlVChYiISIwRLUoXi1+xH+LY8cuUjaVxasZehw8xvhA3Y1gkElKkt6Y7sW0Y24XBIZmOCVffwguzUS9ZPSRyBAQaFn+T0qgsdNNcGCSCkqMpsk988+8ewS+d9tAf8scETp79vKWVOPq0Vtb/qMziHxcTvVqXfIxqBGedaPT/TvpX5Gjr5F8EOJglWFip6EkQTscN8qkpngtFFnPXiw4lP1CGITD3NUmBczYF/IgyJNY71CtuEO2fi2J7Jp80FET9kxbV5eQTRBXlZZVrkUGfPqs6I1LYUp+PRn3qfVF5NjQCDk8s51z6j/4zpOVJXfh5TzvVw5QGc9utY2gaeGIFWmsvEzz5tVqS6oT+qVeDtHT4FjVOZlfek7jXMTosX/asqEqs2uobNx3Pn6Y2MEDckscepWWNPb0e2oQWz9iCY/OgdkIUnTpDnQdtOfiBRvpi+d4BjKvOY08rNj7iCZOBQiXhY+GQ60SX3ZLuT9BD04JZdfM5eDRxOIGw9MDMLQ4O9dKJvSntfGXkclkhyY9dcEiIwAugZLSGGFTNSkTGdPwmlYuQM0j49K3KlHT3kaR2pkij/Dflb429/d2o9s0Ntj0WsCRjJwaWfFtUhLI86qlWBCQlTQn9sz65GqrZxjkSwFG43U33hkFdZCbbaG25gCtGJWhEgiDIH/TgyT7cj4ywdbffUkZDUS63NiRr7IvFFaxLcnyAa/ir2cafhwn3yR9hHQ8JkY8fBKV23wVdTk52De7FTgGbV11UCUkXYgPyItusG1Q1BEZNiIFW/fDF5TpsQHINcDjuHk1Hu0payfeNfAyvkyPRL75sasHlOImd3kFTnG1XzNNEg7r9B4GnbmYToCOU0BP7fGuWoATBQ+PbydPIBHKDaJWYWQx/fydcOO07M8az+eRos/Cn4ibGi+J2KK34qyxs4P2FrN9EMcUvaZqtj4n0IxP7XqRVvKPD7uzwgx+Zt55NFldSPPS3Owovf3DogGmSYuM3EoHWq3fiN9MnyIJhd7VhQWUK0zN1Cigv4FBY64kBZpiHGIp8+QGF3eCCfkeSJOkz8j/wuF0YiZfETDKCvmftblxbukKHNJ0tjI+5lLmRwf1SgHuOsJav8ozwN7NLM/7RNxok6skAYfDxk6Qlp+rF49O0QuHEk5QqjGsgxLWXNNnfRcZXxkCUMaQdKZUV5H/XMGaibIgKQv2ZmwySptjVcG9N/u5ve3TWaPMKPJXPd0gqq6jDrj3WDoD8yYXZpCQFwyoU33YPA/B0brYSRstpVASvmex6SagQU0YqUzuGmeJSjNhXnSN/k/noxA3nYie3PlIW1DB/ictAStwqXm+WaCP4nPURJuqiCPFNONqnahdJUliDwlBozXa7aWIzKbtHhZAQ7wPTdoWy/NN7mwvPzQp6ASJICPccErOCNkzGceaHuTd1gAMtu2UEbCJZLfZZPAFVyxiMLmUTgKYeoQBilrx/iMe0yu1Ftj+TBF1dNHF4W8kJgRWgv+XNvisW3J4c9pB3Io4HrJjOTYaCWcrSa2nNUH3+lVC4yRjzp7OTkmpMLScsgVFw5eUBduRzsJcFJICiI1AnXH8AsLaAwKHbdV7F+SYLICtwDOeJ6OOSlkafeJ7F/ry909Fi5zNvQ2Hx9vJcgyfHnKq/M6dL80qWy2ZK2G36ASHKZ4Ml6LgfEzQgurczXmg5zut19IvoPmz2hv0UKJxKTNc3rLee1P0+WMVw1jf0icBpAbFapKKFd6azuJnMKyZpbiP/OWwzayBB2TA06cclfdZavPjUj0Pg2gCw3jZT2sKwC84vp1QdoN6piGbTGyaaE8OCUwd3Igy7kFufBFNPJhUuuWUsqVic1Fwr8VoEyzAY2SxcvLrHv59yvnq2oovsCbXH8RFZRcUBL9zmVpXIGU7wXyYeyF76SslPd2bSlGc60ELcQb2b2LJNZEur+1bCRgtt9mZy5DrHeDhc+TPIVx6MgqycEWWOdWXyBVwvmXTJv1rrPLzb8/JXOmXB4CLKIJTa6WQuoIBSV3VziU3sTU9HMyw3ZCGc1DdbGScrI0yl9AWsFj1OAOTnt8cJQfJscfhrBfrMjeD7AX1Hu97VZA+I/C/3PrOoOyxW9vCeDUe/IozSGI7QqADFbuy6YrjCX/Js0XjXavAhIno9UsSIIaXrQfGam0GYCYA5wMYyaVFFrIYjR2hkAaWVhNTy00DWsCCWiQ/wk+dK02SYwgoZX3ZAHIZ642JTNCOQ9OnVlAjYGuG20OPnHGYZRFeB0xOi4EPzD7oNOLhQLeFhS5/QKDCzL2PIQgOLspBodioobx8AmdJoOzz3Iy4g5uMOPImFcGO/mxl+HoPz8VYyMgwdfT6uVp7zrnAoSDGOTnieMSwz1LMRWXFexQy+ceCcMw0k+agZOGMVyJxHdhQRLHd7LqkO3Vixt0l2Dixdq+zLeofqWvk3kcVYB7nRTOVCj5oxIu6PUPTN9zDq8VfsHsTit1jrG9yJ804KN+S3QVqdsP+Hn7twZCLu3sxyRh1lkzdcxSs9toVZ0ibBo6Y6QE+hzLw41D1nEqrLXtRD8i5pml0EFZR2mpsAgbQc57p/1E87ssq/hbXPjLvlH5Z+/GwFtIIgRDqPuDk8WMH8txJrU115Y5ETfxyA9L2exh5RscUFLJ5Qm4ks/sIdAnM9lidE/jHR9Vj8NszLDlnGX5Uv6uv2liNdQJnV7Zzy+oTh9FpaYiStbwAHK+2Mk1ZPY3lAHwa6F8BfRgBm6sdEommmP4gxg45NCu6BonW7YYqC181PSAmidRrLeLoBbpmZXjsbqizUvKquj8RaR0QR8rYFAfWboiwxTKHeNjMwpMyU4R5fnfT0D2WKCxAK0vqtqXSY8jTlZfzuB1rQjc+zEWiVT8SSMfZx4RdI73g2eYeQm4gChu89Fi98YZQeystq7hmFzA8Gbzw4imIAL2lDrgwtel7XwgYUIPGb0w2bf6IzJkNRjSbt7FKoh5Uj4PvKs4unydk7WN6Vt4Nt09csNHGuWvzf7YZFQB8GJl/OeFY4trQYOGxkNom4GcC/IrZkNygQd3jeFSkPMmZsoJG2JRJVC8o5SET2dFXYVyOt28I5wZRIV4ftOEjCh4/xqwlhSE5/lZwavwoPJerEVNOY/BAPLxf9DeezL3eZ4FH5DFN5qqWjr5H0QHTWYupIUs/9rGhbjtRgNvdcEv0eWaS70zb10x0szrdz0Ao1YBeHfS82x/xTnLB99dfJ5xlPennAvokdaa9FVZttgQO1iwPXwhzbhzQKjpHQ8ufmVPbm2d7jUUugV6BJdJpTbbMOROyYNX26HTjS0FWS/Cgl+WCdOTLe0R/2W6k5Kc1mHRzsh8aCFAcJt1hqPYILCFF4pLuc9KPTVNqbSgFE8OLWo645d1Ucxn8jT/r110BuwzO8bVZ80R268XCQn8ILX8YN5H4tdr0SVdszxoyTScUxEpRdb94JGpTHC3ENUyHioyK1ifY1k9nKfLiC6Sp+PhUTJQ3CLIzNPPyRcpZhn62LQjRnQjLIMpz22jodLE+OOQcxfw9csoC24pTDm786m0jOnopmVwi8kD7kR/6/C2JBU66HRYu+I0KmDwgiYB7lmyJBCSeM2XYFnZss1E8xmUqAsp4dM9uuK9wINXcU4bHyKAmE1vCtaHarnPcTntg2CX6owq+l4pT9PLeuWwTNWKWPhOPC7KupAuXzvAFqEUoMGAFs2xpKGt3mVBTuut7Q+M9s9fEKFQul4def3kZi9uW4Rn3umonilE9+9TjdHjBhpVk1exeB1hh2uTmZYoC5yp3Xe8Xit8F+/H5zYBQYj7ycwa+7IRQf6dh9WOvaj0+EjWmglRYcYTrneT0dPtPGer5kkJFn8brJ2IAIBLd95qAXFaS+yTWMaryojsYgPnYS5zw4caCTfdA7j0H+y78o6roYJIbpV1m9Th7m/31Js6T1ou1q4KAZCO6NhC0mjNr1PLgDdXBaZu+aco5IibClKo0UrMo0do2RmMwwj7PVoewywWuPtZCY7FQ9XPdOTpC00bTfQLlkWQjQybTVxwo+NZ7nLNPEz5awzMV38tkwtBSO3Wwo8RB4j4zVk/dLTCrwiXjuBxmcuLB3rsQEux4ytTFo4B4kLLGVfsh0Og2fukdBdEay8Bjk/3RqpPQGPZNNUBr9GWNvsMcdUk0R8s+yaWiPf4ExrItju1qFikTzfwsvnVqI6NECoa+eZk1umpb0DCLEUEJtvFzXfh3Ff3Q83ryxEeoxxCMiJSoJLZ/ejfJZGPJqW3Vbw07vYPQIDjz0+GTk2chs2gzXkdY7jYPmyZYMdRsDotVLqRs5Y20zmxcNY4TNxVQ+2zw25X5HVmjTm8Ya1eB9t2uhtbXvHQi+4iTeLEr7dsAcWsGnmtOFnD255rMwCfYZS0HlQspgTh/jXfXK2r7/wIqejoSOqlkK/1v+epGjZV4EqYSgyxlS3x0+KhD0gnET+o2deXEhNv7V3DXvGzfCGp7vQsCul7F0D4V9W9w5XiLpRxleUtzjnIHumvqqjlDsmAOyaw20c1ufho+48prwTmlc2BLun07TD4vE9kurQzaB0F3iRm3wEPV4Nu50PI0dN7gh18NWRtevE52sNTtXQIA7s2F3EYbYsn/1fvBXkOP2dmp7FReaq0COjUcAfFsTOqt9Hj2uzCjIdhzdV2KGnzGyGIOiPGntq05bw4EJiupQ+V9PuSuU31kwWAMr/TSnPTcY69VJYNrU2DqhGGlucPAPE1Cx2EqbUTeDPC5rUYDweTtK49EkKBpKvgXfRLP9/sk9TN1/0nO6NFNIpZ+aoQgemd0O0Sx5dNWpG2TXdL8z0DhQ8u4EtDLpMUTOxiABdtaQnpT5hV8lvy9lgVVz4drVg0RldSdQm0qBy+YpErPc1xYRBVWY0zLwtKjV1Iqt3KMuxxhT1ySU6JbjNNVdFacSUOk0DyYHULycA1H9nDNRgUSfX0PbLLjiNoLQ7Uv7/7DWH96A6ui4EoIwh9L25sMrVSjheUji3LLO0I110HKgIOLeiA0r1c8HvmemNKtEOiXpUPqC+FSkjlnZmbELQU0Hb2KZT2zFPDyaVU40zFqNbu124Ck0q+iW9rvGquqD+KlWjkBmfJLWApiPDsqxHlBCv9Mju7WcAyMYFN7I9+7RLF+hL5vKJ9mYODrGflziz0R8sWeC/4ZW6hdVYhPLIf8lUlD2OBfJ6RZxrbgkHxC80n6478uv+JrWKhGHqoWvl2zPx13+ZjA6kxMOxjgwIg9nfyWD4+hxJN491iIoi0DcKbqwwWL9sSmfjtW5pAR4uIHqneBVxKB1MupMXJfRahm/KU8VepOLOBARd72f4KDFcdcTLjz2K0rcp6s9J8VveaAghVTDrTZa5gEvvadFAcha2sfXNPFZnnYFL67rQ4Abwf6ahEfDv8tenxTMl+JcqH8ETpBzapRHSn1h57oHR2IOhUQc0eluqNIwF/l99Mc/OJo6q0CgxiMW5mMoOhPAwvbOKGhccPcSAsSAkq6+ptjrm0hsC19O9+BTcq4uGBMTqfZel0AyH7q6UjqTn4LM2/qJb2jVz7F3CEU4ZBrKkjWnvlGX4qKaoR5BxOlpPhJ5BKtCGJAtgyde9g3Nlm84aoBiYwp+PFo2oIz307l1QzMcBJgYPhRo19qitmiCl9jsHT2sIIAkUJaYZbSdFVSRFkl49yvMkN/eGXwbAl0jHw86EMv5yokQWLlW1yjsJNqZTi1GLdvo8AgUcAzvUZ/RhkCV1GuOTSjIhUXuxAcA//YNDNFipZxxyYiq80NsQxZvsgGwsFZ9LtrBby2kjyTEJ8vvm9F3RVPIdguHuun7dItDiY5GWHO6ZSIU73GyW2+9yq39gePo1GvxvQqxWzDVd65JwN27rXyu/uargRejgHRedyrvPgZL+5eKUnbWZKMZ7vRqTIcHDNhN4MnfuSUcs4+Rue91kJxgBQYigjgNEQ74Cpx+/1mwr2DsAKjZou5E0ZDTxeN+6eVjsteTF201gC3Rt+nmxgZAYLPEQGDh8eI/NZhqfTpNF6lCSvjiut11lYnphinhpEg3KuQByLAUqWTXa8YQW6mfK77bCenf2ZaTmZAML81D/w3+wX1bDpMCdd9PKQVP5HkZt4MYKeTRD1/BkS2vs/T2hhmmip1m3QQVEoquM3hwJQenG04ENemrehjR7dbmogtVfgXUdGIwCg7p3pMwdCdwMSGDggC6UM6rP36Nd3qFznDU6LYZJ+vXeAIeglwUExmVxRjWMEW2KdPeyCV5FakGNOBUo3ltl301Idg6gp7bT7s/Amp361fbTRoTGKD134BvGbMcd6eow8bb7Fd3Psi7H7i7ulHQUjDH8jj7Y1vSDH1wmlJIvdtOkuSU3/cXynQDkVDJLYXNXq5YUSe0UJfKgmIhOzUjNF3B/IZWgAOezeLAD/+7RQQqPwFNMcu9GiCAHa1CboNoY/9RdVSTRk48RLRSYMG/LbD9UDGKU57JQDgSnZW2bLBK3+Q29ze9i62Bx4LEMRPo7s7Lby+Felv6gJyMLlMipNgC6BCBipc0y8Pjvjw/YNg/VdXor5jUpq7Cl6BUWd7g7SRkFKZWarfUXl1MQCHcK9dYxx+NW5I4bHOOrvaRlk3r33SBEuWqzCPCRs/T3+IaC58I6xHs2v0wa8x4wIfTIoqL3gx4npgAjuhlTuZQOPtHGT9OnjobNPA7DS6cD9IP+kYbJrulSCHgJp9a8lRn1zcg2Bb8rhDCA+sWeuAjgba76i6MXI87CoeTKLw4pn98/zGigpU6Qhr8QbepGRoerHbFIDIn/LfCvsOx+Ekxvu3qjnp1jZUU+jXY5aYIDT0m1XlufL76u1bz0GxRyAHlxJaKfdeJ6t2AeRpUNtYf6ubbsHu1sJszPaSpdNx1oUL+lJ1a5gqzacvZ+HSWsEg7w7tJPEcEXa0QzBekMh/rGr4O3xvnqI5EsIF75Kfreegf6BSfVg6lhocbDm8SJB2AZJ0n0PXCz+FpLElpzYFA2Xyb0ozXhFoXKi57svZWlB7Ol2sIvKDKIGaQDwW8pGQCZaHJcRIsCbNI14yHChjFckwmMuazkEvU1HLSeQLKPKBriJykSXRTQOQbMrTfBtuhPbjipZ7KoFshDU/POsnFpDJIh0jjslttIsTHljMKR6GckAupl5AAHr9Co3B6JKrKY0A6QJees+Ima6iMTjMdaGOvN3N3b1Zjiw54NTb9jStnELbjdpJMX0rbYR/Ks1Ay0WgrQBOdk8MqK4igKLUsuDu1C40OD9d9AOaVDo1+lIPK0EVZxdulLylLhXWdgy9+X3ZNPLroE6UXcdxEraeDRcHngBfyOH8LPe4TVQhU5GIVqstRQ4sDBW5cOTkAVT44FZ+arekXpXnP2hsmI0dw9odZTSyFt+wICj6IhIf//kh9hvxqNyfnsEVEavkPm3GX4E2xED5X/HkqnHdPrFqgw/pGtiBNsn9hUdlJFE39lmvUE5sFM26RpDcwUvsimPkblWQLWfRTrp5CRoshHLJPIvT0OSaFEV/os7LdcoeG786Co2dXZoh0HTKc2M9cR8IizHs2RcC/HjOjGa970U+7a4Kt+VbWhxtJ+sfjfr610oY7eeL5/Fh4OeAoJqri4w8WdwQoOP5KEKlcEifowTdR18n9JMOwBST9DDNDaOooJAP/J/owv8xQSlzNHsSsLzAT0W8oYaMbIkpuAQ0vvZJ1naSGiAUcMI2QDXPl5KRH1t82JJLOTc/eeR8/8A9OSJKp70X6OQq7ThYgi2amjGBMaJXSrHc8V7duPhQvk2/vLk0L5rmL9Dhm2+Gq+bwW8nys0fbrrWlQdpxw47I6B78y9Zjsf/y70t9GGV18zPjNRlKp03tBypWnZ8Qx7cPc9njDAxNonRBVGb7mmlMU5zRIHalZ03H3QjcyL0INQG4gt4oJhwFmiB9cB3JcyUtSNh6Sfzr+IL+4KZ5s0U+42MT83m37L319ItvEo07m2zS2rUv2Vz9ByI6kAE8dPKDcIC5wKSfmTvwKuHx3SqHjysoSwwS+e2KVPqECK2fMl7oB8RMPh6z8xy5bMP/0qUMhy4ATxYASZtHe4g71J7fUS+z55k9fBP21ddhTxZUnvgPbPYmtaMTGTTE0DMfmf/6bxMDE9Vv9JC4EyuDlwofVc0jUWAJchcFLUWdMwEn3jDw6LdcRPzRlKXFzC59GeT5XHQ6kHcuPVREgRBr8R+gSLjzEhIz1HLh1t6l3lYmjGpP560cLrWnuK5rDceKo0nd0gZdAfh+Ypk3Vo5rt3KErfGPNin/Ddu7cPVrPWtS7/tFDF4tq36f0XQGEh/4cxukZrnIBjWR/JvjYwsk9ULen/nlECf4Uj0FoOr6xtrA7aEVobsoaBzfaBj8INCRjAxx56DvE0xNrRToXj65zeIxJqck3UwiTCKECw7Z0D/q8kKg3xnr6PxU61Ll+Y87FTT8DBI1mML7toa+TpDhIVO2WugIrAJa9XF7B+p7+qFxpfjHpu8T3/SvGuV5EGXTuvSjQ7gFB0ZQVzbbWrgTVaYf7nNhjCGkL2UwFFFfi+f6mNVTREueqeJTF4/dviwTs072E5Pp9yDZZxwNpkDcfC33cygI8en8UUIpZwZRdPy6cPC2IWWSsgWE9nj1Zi5I3y6LcpljvWrEbLT9Rx/MrUF9RDWs2UxBwMPD/+pFg2hk70zvxHLB7w2jDB50NtZftJ6sOjOetSkKF/VipMPcWbz/EzEPF1VWHhXXb0wC2X2v2mvlVSRZSHfxBbl8UVYfCaioKRRSsMSVlcyjmxbDqM3Qha5YjN46S4XZU8BIWMBi5/cZmOiyotIMQ4NVOuZrWs4lIN4zWXW7dNFKT19K5ZR32ZOt111ayuxNtegMUNgAI57DJWs46pDQk2pL8/hstyjdNPEO0DO5DoXJNlbSD5RGk2NvGynvuKT7MCwv/F0qqmRauk7yCfmwSisgnhYWXHy97ibzNxhVN4zaU3BCaAccloc3kLGnzhc1DX2dS7BZkdZ/fxODMQGVqfJ8eFxlxUhMvdNmZ4VS5WodkpR3TkrgNCC+nBW9pgfDlC39351v2/dHS5dEy7/M5VsiLJ+MfIzx/ZUe2vX24ANThE2FipgRjdfxtxLk0XQzPHduTP+B5F9fkApF2WmeYu+zsFQpBUpUzSEjY7XPHtxvELvoIa/OVudppYXBo1VuWSKN7r0QhkU2akUxS3jsHa5HuelhIaABTqUeaAlSEYNxzS4bhHfmdm1QYI7UToH3pUkEMWnDNnAozzUnUf5baHhU7mXSwt5rb4zX1u58opcBlkM94BFpZdgAznjl+Qeh0hgezGo/k97cRFDgBvRq0gBtgr+sbi1PwwXshUyYHbfyGKB9N7oq8j2u1MXwoRTOB7ek+SaTe3Mti/5Uv1U2HTpVYPOKf4OyQgFPYINhEMsG0FB0RMe1+5MytoINojygP5wuDm8SNfNJMi4b/r4nhmfmGOBOdym49/XcyavaXjkfbCt2ZDqCSJvGtseciuAHo0CaKD4dg1QghJBSw6JNo+4p26XkiVRGqG9JfLZlKE+xcfUC/Y2zp21v05kGQ4od6uyhw+mR7foCL/tl/JyL7hiiTzm6FWc4+0n68asziiI5/TXUXC2jUVH0naz8JsUiotHxG/RMLJATMee7V6A7xY9eCVCdkngRll4w5u7oG39EQpjqaifOTOPe9S2whYfCDFWEgTuc1AZvZ0k7rqHTNXSH/SxEVXWVG+1+HC+dXwFveOcGVRRrD32l0Spr/SzAUTTEBuMKW5gp8pE4KYoQlvnmbqLTPCpDpN+E9oz/d42MP8vSpzNDLETpMi7tO/MMKLJ7j1e01f1PfRhMKCpcw4/FwKEEYP60ZDHeHx06nLlC8kDRAVhg/hZLRIxe1EcIMCmpVuq14DEJlWR1+0NTP7yW5xrm3l2dMoFsD4IPB+KYDydlvARcJ1AnGUOUuItxiYbSL2pIhESTRRO9BcM1Y5QrpqxCgL/v6mvwWMu3Kzadkp88dcv11/89k4LQO+NJ5rYuQctm4YM0CJA5lY9wWQJ+RtT5JqLDywZTQbKbU4eTWA3njYDHf62NHv+XB9BuwKN8AJOCf9NHvtnCi2jberpGWHb61GjUA6z9iw/VSlQgr2dotQUae6teEAU6AIVql5vWTskL8X2kcsL9YTwhAZTd8SeWEf2P2gqu9kks8adAJSXs6qOusjsAbQScsbyFxmFfaZYepUBoeHFbKYViGpsRXFniWD+OzvOdypMz8zgLBkr8TMMoG4Bfb8qo8wPLEGiu8iu9Xe5rWc7Z6MIi8TzPpLRUrdUtoOUzxC8btNFV+vV/AE8y58jLXXHG+N5Vk05aeVh8UoIEPEdNQxlsqtTlvbWusO8oeneEgCR9Ra6A2mVBhARVhm+NSIcQKeqxAjoJb+IKpu7mBaeEWTYlXUAJIbMfinYLvWqyDki0/ibXSaO3dfDk/J6PZRfMh4LlWCqDcSsY16vqDYffMqpiYnGpXaywV6qibZVEBwHWBFo8FMZAjjv4/IC0uKaj8Xgr39Jitt/sFXn9X2/OtHaNY0tGo8XSF9XZGoIsmrCbTR3eUVbz5AovJOPuH2RsSkGsmZbrzV7Ri3DjR8+oTk3rXdmnYF0utGxwhSuFINyNbOE3y95WtaDVMySvs2dCzUQI3D0URXqCSC0nQbPT8H6B+tojg3IXKcyb3vP2uL7clml+U0bWFyFn0mhq2Xdy1Qp1sJJ6Yjkj3evI4tHhmweYeuu58VZssYERvIj6Ko6lpUXnzG1tT6gd7sCFuyJuRgfQMdlM468Z562rC47JWVNIw0ZsnY9NDsNAbfHoB0ajK7lMVYiAn+iIxMwABNoX4Ldb6K0aylAlnXSMfzoH1FgOnRqskrCMZ7IRFh+Jmc3x8XxdcU7vfor9wxpWVqVms/G39wlHLHqaH3sqJeq4Uj3OOLpOFgFimpNJGH9qZg51XGxIT0lKtpxGS1NHf1JtAM2Qt6O3cttifJlBsybjNjxhAAbrOzvhbfZNxMAP40yQpmq18lv/DRyAUQ+vMrzQuNin91/EZf62sNdG26/tA3HwYQdgGQUQESAx1fdKu7KT56QWWps9ux239qoZS7OuzHjEHpVi8NCLUpaxDUtHi4zT9Mp/mNhnBAx6FNhy76gbjWTLxyW5amAUKis206plsNXtChhbSLtlcKiQVo2AQ1sAON4qZ6hieytVpNKKzZNslqQZvHI2WirbCqfYSYjcRVKtJl6D/SPchGCL3OSq/BACyq9tbavpYr8nlTRak5BJb/MnvvwN0RU4zayYzjxC3KRGKIpyVX3/UYr0EAlmWmj9q0BAI0G6EsKV0gzeAwSgL2zIAE4pnVTQth0u3Q4ZpAWKi6iBqHoQfGrEphSv7LovrQMEMn8j8+pR3xxi/ICTN2kj3TcFFjYVUxfQJw9bCqQfmWU8d3+CtHuwBHvswi21/HHHhhcGkzCPJM4uH6ZvkdPIFDmg7GkFju+Kh8SVkDUzFqnwuKxgTu0GC+OhC0p8Zlq2eos1gJaQQ58P5eBuNKHzmb9N/7jaLb2xzl30K1Pbb75efacfS0BqvHtcFceTPaVwYK9YW/AbgaGLOpNEH+PyqO6dIi5CPGhfDv/u486lApWjRT8ANdwdBa2m9Q2wZUX5OndaHC827sTVq/6viV6ZEDUoUPJxwk0YMslUfkNuIYRoGx71h3rHWw4dzpTcE2MeMSTiYrsChKjgXcYZCYIhS6UkqeYtXDnlhqeTUxk6cvEWbxI8hvkbep/ngTJWEmy+IPdXavls+8Bh5akHB4naT564C9hH1Y0s9xkZu3J0H8XCSj+7H7rgwfzED6MSRz95n+k5TqvLMW+DtME27S/3Jg8GEP95pDQIAHv+E4NaOhEAXacwfF5WlnqzKNMAHvL5tFo32dFpkOJ6vf+OCelpyNceU2uGHGMTvTUe7LmTGxqXSwTwpBkH2U1NoAX4zzP/wgeToeuqYJRWHc93WkWAb3DhvYANxuBCa9W9dYPMEOKq/Oc0q8CkP+vNwDrIB6+aSTieTusK0M1zptbmnRk4/sOwGh6973qWSACgzYqU6ix/nbBx+eEyj7y45rsKqQWzHBH1wzw40pqrXDohD7Tp+F612xJI00u+dQ5nicHHHXQTRxSuU591lMWiD0AynWVFQcYVpjJyg2IikcGm1YO5ImHAC0G/o4WSR0L7TE+j5sRrXzSG3VltSq+vBauzK2pWs4AcP3DhSTN951getECdGYdZQLK3P27nW/ylD03hmGqAOKtccXtDHLf87Xx3aYiRW3/eR3aiewRAlu/e0rwwnOSvwn06ZDLzU2ugaoWjgPOm3wKQEsLmqrIA95T7eA2679QMaAVQq+UrbXCloJ8CSgAM+B6JIYQAeWqDNZYx9DgU50eNcUQuuQXvYQOR9oofPsOXFUAkFNkCngb32gut6rrNuPEbaAMgtCCrgKz4Z6MM639R/Q0tN3IiC8QasYjNirmPu0JRyXY5M1LvXoDFUsDYxtCWRXtr3xE04aPUc4s528Fk63wa5aZ9xQKN+SQ2SaDbCmHOfjFbMXi5uMtmmmCo6ubUOb8cfdFhW1HU4x716mVNq9VOn0u6AEu8VDOWCpx46t+RIvTCZPWB+coIoqVaOzsHlJ3QoidbGC4WRYR2CiEl31a75XVItB1ca0QSc/fk+IcIIred8KAeRy+x1k2OIW1qQXEwJP983WjjmoWCGTejESIiKoNEhBXM7bP5onDbpO68e+Wx+9fB/YwBS/xs1lPN9hhMyTNonxeoFp34B1zOBDJGN3HHhQD4dk8SgPYKIybM2tqp5VNDPhxk8fNaPfB/djnmQbYOLZaHa2pgjVkLlqzPMpIJwRkHGoc1ODpEg9o0oTelSQdsmiTakIurbWA4qnphxB+eApTGPmiY3OMrV/6rubDul53rIhsSZ3bbmgeU5EoJlWdajNS/1A/2l/WZxB8UUwv1oozcgWVReVE82h+sBoXKCjAriPs3fvO9IJ+ghtH2I9UKUze7VTM0XIIIHOXPexmlrSs1PGpVNnMore8xH73aZcVlL2GKJv/GXVcFbF9tQrbPJ1McxWWAghgZ9759pelCsXz21M2W78KvY/tKZhvep4yz0LZqmYJDmb79RJv3wqLYn0HklOzz1Zksu4qA7YpQlyBEWuZMjjlsvx9kFCJxFVJwRJr1TGU0bWgWaQh9HgAEx3YK1gFN1ZrrSyI5qx+vG75wPwRRtbT0izwd/h1qPVZ3dAomRqpcgtAUIoZGma7g2uYjluTBMeMG1eoKV7+yTvQNsCiyxkfWY8ClOgHrZkOA4IepfpK5lj6fTjyHsUCX+LOeX36mlaneOZDfkTLGPCTEg1ZI/R3W5zUQ4Mh+BsOQteOAMyCvWEbMwTVldNJZsDj4+EqmyxaEffi5/TwfYNjkmePGGAceAB27cMcKNsDExVsv7gmX7CMut0b6rq7vNJMKlq7NHDBp5U5ktd1NnodRs17rMqZlSbt8QEfYvy2moAcXWQyIdDeMFKkOAPrwjQQfz+5x6WHeVqBXgF+WMRfffLtLfhD73C2K0U2yyLHUQBAVBm+c5dlydphCp0t9dcRtxzY9zVvEqF4wS3/+MXQob6zFeP09qixTdUO+p7crj0mf0pme943aoDnfyPcTA2+sAo1S3dSCVNmS9wpmSsaeeRE7worYdyZUHoR6gbPGy2vnjWXW1M6oq7INAfGe3jKUnZrE3BwvGWwlEQxQlt0UlVLDMeUGAmuS5sh6NHk/v+16/YZi8DcJAJ3FZSo/az7Ggvx3OQkufNePaWRWpN5F4vS81Gd1MB/Adsv+O4hfegNffOrQanhHONgyULxtg1D+zBXACWqWWSYNcJZUjERvRjukty2krmNivPJCtqdQlk4OzL7w8694lQJ/9WMNv2/6YQExcat61CdmQcA/94/52Aje3q8aM53FUKUzAAQuzbfYSL7OchsOEJxSSBXpOk7DySvaq+/yWIrlknZc3eePMixC7+MfYm3hdM2KJ1pOuYS6FGRVI96caTWaAE96zzFI+hTvlHrIhxfUvGQNTY4r1RZAoY/Uua6LUY3G8xVAEa0rl3g8PljFut3g7kEJEL7++9lh+nhtJy4vRiRNvX391Z3ytz3TdK73i3+at1Mg5TxaOQVhzimZrTkO7uiuDR9zpEK2OeIR3pziTW5BN591B9ndSTiB3DvuNHhIvhUZFISD4tVDxBR0oh5FLgWImiUq7wNRDT8PDuJKewD2quuENv95fnG4WTxRnglwnXuXujhGM5AS6JbP4Xsz+hz9+lL8gZhTh7tLngo1JEddNqCZXcq/fbjNu2zNgWqjDwmdkfwmZy7jXbCeoeGvxmfOzhdbNMN1+MpY/KzlAqgEVTYJ3S0G9FP54UaEXq2kJ7tS7HHzcvbE20lE/aCaWQhR+/ISfS5bqjYunooexS9BKE+2L3ZQcOGRl6CGiW9uxDW6CX+2DRnsYkiGyuSJJwYNsAgk17TkZeRC8ZV2dTRg8J4aW9Pf003VtavdVtym7cctwFsLB507sSmxa5xoMKJJdhahvfb8RLom7K841r1SsW+tF6RVVu/XeZe3d0HgXPB9ilnoDiJ2bhqJ4sMLRbNtLKYT9H9Sw0ceysVtOFKRIivCKX4a1d96kr3M1Z4vbXXkLuAKYIUxn6NeXqyCKexdMRw4IRFYAQ+1KAd5s7blIMqWMS2IaLEcimngJnm04eHTzPrq/m1kgYypR4tBnIq1GB5LCTWxEJABqF2AI5SipvZQUTrOJd66k6pMwGe1ZxWR/XXtsBJSWwy+a3ZSgwVMtWTYTKVxSmZ+uj9JiTz1Nx6FFw70JxDtscA6rigzeCNLAQy4K9K4DzTCmB6KgoPqlK3gS6cX7YSQml+J0MFnP7gKhenndoar2TZ/xiSAJg2USE7Flk/RGvUCYVdx5JAv2TEIyrNomWj3a+fy45/MB33fQ4VomgWsZE+1NQ5kD70XE9rM8FGcyw3yb3qrm/TMloKVoXzHchtD6KiqYHeeH1MZrtSpuesThUEm8+v/PBGK4MKSdIHTAe9dDxgTLmwHlxU+W8zu6FZmritd4z61hNUFwycpxWyVOOB0fVYyaQboZstTm6B2WdCWsUv5iJIrdnevEwKdXIbYxDzjhx56gBHCNZmtzg1GMHaPGCANYMIxSlDbzxitxYNfY9yJgPEtKohfj5LTymFmkOjhFfW6jH2dQ0oTBXb3nNpGogvXzK/OB59DHQSyALTB91C1HvCyHcvnYOCnfnKUcOmYPGj2yeQdnYYwlO8aLCstMKzNwLv7LTL/fztXjBV4/eMsrKdkk0oS8OZN8roqzwMF4w1OVjWCcgng/eXVittFuEiO4Oaj1EkCBhJzHu8na57mhleO/6MQngdrKwy84nUuMcJjwf5zVq5n6SLVLLCobMwPdYjKhvdM/ufuS80pqJ5o+BaKyvGQlK8Bqd2PUDAum9QWmLQdzbvRjHArimt4kJhifoX2vZY6/L/SLsway+/LCPDZzUTHVuofgSrXmwtBBg0wtd34zwzArSYcR90wYRYXP69oRbMe8eXVlsrGGg5i0yoycWUs5xoPyLl+aJF5TcOxTV8ZOOenLN6eG1LKWs1gwZ5Gb7Q+UVXLAx/AJDusFHOENeLyxC1ViQc5nlQaGJhnouOBWbU0WMrBZ8oGdCkXLygdsOdKGhEIGmoXMvyRvjVoshbaIQ9ydj4LzqvhD4JZ7crsXdmz8G183CA1ja4YuMVA2Rvk/DL4Oyg8+7li2K1oBBZxeR6Qkwb2EjkZqX1A2QOWEDx0bJpGqQJlG48e6Vdga0VcRZKqxfBBeqSy7FHndbqv9f4Kd0Iw6PIUHnCta0nC313KrV16EkTcv6bBNspyUWI+XjXXpQfRsFKMa4W2PgaFUo3CoIPHQwCKEIb4xCbl37hsgaw39PfQrsrm1iJjbHaS4QqfuDwKdrCMWmlwQWENWvvsuSSmeNWm/1Vc7sYU+e4U6zsxd7wZGl5ziHgW4ylB4H7soz6UVyNVF/ez4A3NGeeJBUb2jQbkwpcEtiKQ10WhHbgVlwcOYRjU/r8gACJxwQT5O1ueuVwNPUP+FldLBc2Xb3Ut7NrLq5ehDh9NIniFiTcb5+m42y8GD9OkrzPXT1+jj5SyFUCOMnQfYIP/LNzrIio7TL16Z7xZlplq5C8S1m/TrbQd1uM04lH8hF9+5AK++M04ll8Zfbiucg/ZAS5CfLBunpRC0p8Y1GzyJXXxxWUMD7EBcgzKjA7YC3duliPw8B5SIRYKbaK66G5Th8t9L76UiTL74UqeMsVuwpTLln1ZWjCrgAAazE+uehgdQL3QZSRgLMzaDgDuvwQE8TA2797LFMe3bOSf/GjzB9D8l1gc4ZEYaBhUzQumk8am0Xdo/zQAPeVMJ+kTMdIvopefeQTURPQYwcjPsOpdZmbZoJpniK/OpexRrl2b1RR96QsU4CpuGoBZ3V8crJH2vibEExjoHu107R7HYfRhaWT85CdqHvsNwN8o0v/5wCix7VLTjl+eYvBy2Som8wxcpfom2h0OhgruK0T9W9G4Th+HDdsjUIXgXceH7VHfszPfOxNqZenc/IXdK7QAQ2STflpzJRFUim5SpxCIq2R5XiMjz3cdGrP6iNbXTVMAXrUd5gP574mkeudH/6fwhzn/p0jn8FNjddiY2RtnZlmCgNVSmMfkrmkMYfBNmqE2BMJNpbEqEssGgrC8QC7xSKlj8+K/+yo9NVv58uMmR8NTaBGb5Oo4OwABJUMFR9x0CB+tDe4HqnDcI6AgTAzbiToloqLNtMI6KRiHYAUJO4hiuJWi+1NPU+Im24YV+fJyRKa4EwRBZR4X1U4RAwUM/TJWY6urT5XHk2F1qbFdn+wnLlPptAs0Bl55Or85ejwqNTujL1iUCKAKb+FTmcxC50/yA8hTLfItleYBAlOcURyTQt5b8lTwXs8opAxPM/W4nv4aGrG45R7PTWFUjD92vGoYoJQjXpj4cStg0idY1+n9rabMI7nG8Dvk/+FuWIV/cdcu516kz/jWmF306sy66twW+4IFGQMOILJXfDzAvailQK6xionUSHLK156pd1Ye7Sn/apcUAFTjmNN2+dHRi/YT5DNm9IF3Ax70kBLqXjyLzOuE5yCIut9sThaxg9/swDACdYKr9h8XIrherle8VzDUx4OBsb5Ziz+gu++UHZABkIbzHX38mYcxMipqZJV375oLK7HNEwo63WTToHewzCXXKnrnrBnLgCB3SqIW3YZgXevaKd0g2mEnVgmTkJFTfSmN9oGNsBz1wY1yWycFeSfauerK8YR5nl9O7TQcoDDMuzDaqb0iSyB2BjhYI1EDJMY6MHsG2e6GjJEhF6gKpvLFOCAJuycdEbyb/DSjlv2l2QPzpeezic0K6ETiDJI41C3c+5yxtsvfsMktxGXYW3U2HypysFRREGLrKMUaWf7KmWuhuYnfPPT2hepXvlYW8nmnj45ZendYXCx2I/rXYwmdnsD4lJgm+hFxFQa4Ig+Pll60V/Xks/KWE+xyYM+V/yRVekOmofKqX4VgRf6wLNMMXdYg54X5q24uDP1C7vU8Q8sLC5gOoO5ue6mBvM02OTBXq0QUL+kLdMUU6KCPGht0iF8cCMVVdQwVBFrlE93TK+goBM8dFtZrBzmpE15+T6IGlVwNeC3RfbJQeNlzu8c6xNQUT4Ogmjxq4iRCileZZwPcgpGdpPwYlyJE1b105IfVmg7ItRBAEQH/17Wg76EceSRCIqyHNn6qV0NHU8DcPJmLWaQv4fu/WVCiGS9UirV6qRy6vTKHezfAQtmlloVjAebLRo7cZhDd5ag0ukL+N51CUDTiCQL+9PttszaTEPIySfZ0zUhBpSeid/OQXl/r8ID3A9l5qqZ2ARA0urqUZmwertzTcJg8cTorJxYIgb0GSPACMxEwAbhG3iS/hqawxYgCqSLoWoxcmJCY9hRIQnWAoamC3macGiUYl4Uiuj2ZH6dHT940JK9NYE84YGbdOTAvowpwJAeKRHmh5W6yhsPbr1sZXIxWvYCQ/6bTlZWu47iFMOsew3vNzBL9MO31Ps968vLzsM75XJFpZWw+18vTJwDbUu+HPPS3NhVq55/eqSgmvdUeRE6N4zBxrLEvzseTbKJL5Hnjjqsh/hgcA+0zL9kmOLCPGXSkd136YQ20IVTZ9cCeAGNQSCAskYY6myXM4RTJAN5koEJPkyVhCXlnCX6GBFzy2RMUx8udnPCCv+JER6hj05DQTEQDdRIy+qletuCnwNMtTlp4Hc3S9LFy2QOFMk9zdTDl/iyyNYiaFZRR9oXfSjapOm2+gIUBptAvQ5CuCZ2VtluggaTZGBYUKwzT5k5FpnG5vMQvb1RmScyQT5axi/835l6OkHyhI3FP+1AAcMmMUQ2bZ/WyvoknogSRWyS0YK+FQkydXwnly0XZMu1mSKLeRqkZ7D2IlPw4HrETfJNKjcuhPuqkFLmgI0kz2pk09qHyY3EnM4NYWrtbQ44e/wgcUC/kmoYq5ULa4d7BFg2mZaWezKR50Rwdaz2ecozbSSQcwzaIz50YX9/QqwYRODrh8SpR5yLNQu7cbqt3/rQBMKeaCozKsT7GOTu80r7/A6fQF6sG8fEygIvpm59jCDHC2hc6dqYLyhiYb3NN7jMtNmLFBrsYiE04ZMuChDiZIuIjPjtf8d3frfK8NeR6HoY9o5jMBzlJNM74Dc1njefug75TwHyDL5fji0+gDkz8YYIxEs00sAGHUI7C8MKkW37WBn0OMJQKBNKOHwRWqEMd1QrpgdNN6rK65WW4MLLB2apQa/0leJ+DuVd7q9ucQ+2zXTaB/1lkOeEAQ9gVjFvDTdsAe4O7jw74gt52qrn/i1BBY78k6XgTo4XxAU8UZBriW3wRP18DWoxdb6W4BqnRaEzh8R3Ib6EPpO3Jqe/+2ugSznLNMNg/liwrCMWGHHEa8RVEp7ApVDUuW5gIh7j5CSndJDdgkkp4fH/8hPMkNfuu7m1djwCS5thxhWDkbE3Cr1tWZSIda7sC/k6DN5/GeNIMrmfFeq6eoEtKVl39ZD8kGIt5L2+xNp5gT6Nhjf2LLl2FePjV1cbLMyqRUWGjwwFgaZVO/H+7jI9i4VvdzNgxNuBFXCGDMkAer8xLZnsMGZweQO53opxjxObef4PAVpNWb/NLmFJ5BrTEYtlYxcaVdY+wqLbvXjmfCs4G0MesOxip7aKqQCk2Ng1vjy0UA0dSKm7a6QtgOTvE8BpCGTJ38F2Ejj20l9ustF41P4h3KH201XMGZJwkbjx2Q9rH4fDgAGFPe+TZcEnc4xgPMN3cdWugSw/r4YWjtf12VBHsPjnDvWYc4t2ea5+J5tNNJsj77PSVMK6VSDd6zVKZeg4chVqnq8XC+rKYqavMxZkAlRAlQfr/gXVWTu8/BRkCWaQXGq4Ri/IoUEDxgzxqg4tE7kyKrBqLdQK3vGvJqXvStiOuzatcagDn7GvL+TmY1+3yKZ5G5bb9PGYn7fbTAlrbdUwCOVrbybPljTSdFlMAD4r73zZIWXzpEiQ8DIRpSPxAX1bR3ckLaGZeryjqWw+ojgwZDstG6re23vYJRHpxbchbObshWzBsxUG7rjGZI5sNIsfVP8o7fMs0LWMvBidDhXKrXmWWR4uV3geKkdlIls8rWYY+rfX8zIMjVtTIHmRV2P/xGFbp/IVGDuF7sB4jJnXw0T9gYqh3FnLAc8aBJi8MsVhdN1iqY2sjaWbegv6Og7uJoYzcbyXmkYfm3heY5SReaU0TiRM90pG+PIR8Mzfwr+ZShYvhrDiJeCKq94WSB9ciEVuQWn7xvvqfgOEKZSHdQIoSn279arCO56dqtIXlo5SX3lFJ8vZx+Nm0Ie8HmYvHBhYnhwJt+VR4t8WLc8ZUllSuyQ1DG8TuO3zVItc5w5259JJDiF/9bEyixI7VOXYnLIfI5BbAIjkf+SafqIZWRfCU2CwHdwMQoZfyUaWGPFhncihJqtNrv+Kv3rU+wWWXnJ/iymLYdXKNlZ0oGlBEqClt1NYov5G37ZGFRTDOoP0SUPuiQZENG/Ytu4cL/XPnaC38wovv46owRr7Upe+S+Ycx0dJlM355G1BygOCYU4oxn5P9Ft4UQSFigYyIriF6mpVNvPGcGlxG+D1OaECyMz8TbnEHxMKGhQOSc0X6+QouBIU2Xp3d9jJWb8mzu5PpssOX521JrNunVrWUbyiscBo9Xt0mYFPnzuW4qcosLC38NLs1Z69oVLQc4YXBCCOONiK5Q5bjpRBK8pltNPEK10waFK5paks7HTakHb7wZC7kV6GyKWT3Uzc29BCBvLlyuaZG4sRrnlQjLKDFrJIsHkyVkF305iU/aElfU9VQ5RwV+TKE/R2Ga2wBNlVDfMlsc7s+b2m4SEagYmbTsgGjC2KDH6S2p/NGiclbY//9P0I7iTgIJOXY9PQXzaN6znezfruIIDFzZxmvWmTLMFdhNiJfLJWnRPs6IhoL1xAiCThIDYKtcIpAz0KfH4uAkyKWfzJaVuYwhMYl8B86Nmy+jIA38tIDIB1ZGlPfdtxcul/lwYHt/Kx1IJN2eNcGzuuupQis9AO4QuLZcPHJiqi2FZ6Mu5xFtD+RiFY373k6i84yIxcg4FfxoN1l3eddne35MrdV49PJgx7Uq8nYngMUfTyjt72AgCGWGswpUEIxH9P8CKUkVWr5BK16krwOGLFkk2KMgXXqS+YN9UN21JKXCTu3h+NdjdboQQY15FjUAZp06Ofb77x/NmVzzpf0h9KNcM8Dnu4jCeXzwmtfM97KaEumWJ1iMRtuxEE8RvyPC2+qJaRmdfprXWtLYCcGc3f91PVxyAAJD9OdIx0+p/8c8f7N6MZCWhK/g0nCtjSJ5NkhCavv0Lv8Jujl7BPU05yyIq/0BuSPT2xM7/beX3uhVmPX4pAaKYNGfIXvze1dLBNTjQzVr8i8t6eBNc23xoadYlmIh+b0kufZL47gp9VV7lRkMD2Cec8j2Vb7nNsWOEm1/uWAOWjishF+gdUwICFnldJmz4AZmfC8bZoOBrHQQfGs3NK1TlSwgtbFN8TkA2eSj6u+ufrrMgemfEqSTeeaB6CFSQ8JQdyCiPm7h2e8WPNrQYJ0VnFnfhWflY07HUoNpXoKCHWVs5ZljCnRAAtl7wVVXHVr4JeTJ489nT+WF1t42YfkmnarfCw8x2shN+eAFAX8bCUqk4vV6micEZfy7i7fveFHdtb6GnHIsxDXXe+7zJ5WqBdLWzgNGQxp0rwpMt2bVdNOQUEfDvBkUf/+tXt4bwgKanzJotYvaE++lQx4RwhYpPVmm1+HaAUiacr1vf4W3BmrpCko+8ygcce5/Hvjgymt6Ek1LIamuI3Q4fNDFYFkQp39Mjm0tISP+qPX6IlAK8+eqEwoC+UlHbHcwHNfnD22uekop/Nb+pqsNjuX1A2cHamumhwm1sz8pYdnP0XftuaQ62EcKMHx5qD+8rWKZ4nYHBSOfbh9jzkRC1p8wu6VkL0HNE7ufD/aC/IRyB64LD53zgH7fD0UKx+HtRWSndF+upw5LuNTSJcMFb3IbmqZUy1C2ZRkRfKs1Gv0sEJJpFEipqdbtklE4VBLxZSV+R3ab/QSScS7GkRuvyAk1hqPQnBclmbfKft2lIXXbaQmuyHf0RHV6fQIvBvBl6Zdm6C7d8zuul8OxrEJ0c85zqcarD+/gaRGpbyXYLM3idn+fsr1BNHQ7mbfyy66i+NQ4TYoxxSV1Oh3cWdG3MexUYxXaLDzkS+VJS9YvFb+kif9ayyOnCH79nWHcm430K3+nZZ2YKn7yWZ9d8Zn04glCWCUxpveKpADKanuh0fxNq6uIBjkJ92Har/DAoDrVB4wI6So+RVlN8UGqtLgTB4rjpaaSrTvY7ZC/NeZqgrSeveu8+l9jk1YD21sSRlG/Pr0Q4FiZ3ioKh/MgWBpZLBJUzjRWGmEz/sCSNC02LZZvWug6ZwfcrhRpH4zxTSo5hihmhJmq3tyjAbD4tKdsa/STcijb9Jb/h9Mn2S9oVON/jDQdcsxAmD1VM0vy4icE0TphwYsPYXpVbyRKvmVZx71v077MzCvSyEaqJLo4f+AVOEdirStjiC/DHjd8CTdVQ9qN3gRq2QmPC0fjeJH30H0+X7xsxUeXM/RcknPb/ca1SWlHu15iNvxiu+m9Ku+B+dvWCXt3wp0m1mwDnZulldl3jcNGprKW1IzkAb485rEQH8qUZRy5Rm1lBJ9B1PqVdNAw4/YfKjuWh7ifbzlNiYpfW3XWfqkxEb9nFFZUnna0NiIX9i4sP5MXDeY37A/Na6xw21Ff3cwQEOCWQESp10TjoKPyzaKhkbpFR9B/pyjExNJuzascFBpt47A6U4aruB3BUUwQNo2vJiurRrNWWlTZvcINs5ziKntEzjv1IlqxNTWwvf5CIshLml3I74xmS9nYclXDUIJZtddeWVSCXex24o+0xu+gYxR0Tekm+eCeGmZsWaYsjI06uBlEPWo1HMxAPZQax0RCHSpOPR+J9JbOvetLSBkwgX76594qLeH0K5LUX+2VVeP+ND6LTeVr0A8v/G09/69GVr/6sMXe7edWJY2Hl0x+Lqu4vrGSDI4KSUfcPFlD0c3CEHHwTgEJnVZnllqWwa6sA61TSBdHUSIomDjB/2LHwienD84TMaWLiBKL3js35V2hZg/KzZ0pSPfaJlrXHA9+mr0kqAuziQakpY7uaicXP/QIqxuA6lF28/Le8qz3YeTWEl+7rv1Kuxju1xROsY/bUQKixGWMUv2PoPsoz6Lnw5xp/69q1oFzxQtz1UiqsPtAJ9LN/CpGWoczMIGbkapJbG6iuPxkL3QBnjICHk/d81hWk6kiBO1ICgjTChs30mY5erf+0V+okxA/o6RwHQG5D3/9obFRNnApk4U4Khygqep5s/zgGKMd2S+SQjEwDwNXcioETgiDfio16q1cmdaKC76qE09QRtwlxmVhiM9FhpxOcTMm4EcHqy54HFuQy7fiR5mZ3GWe41PkC6IphaxZev7rYVv4lndpfoKgIL2hiOn1z/deov1F1OgJ0nCu8nw7RqNQjBYhTTC2CRB5oKhztc1pAFhvq8W+G6b1QVFzjQKKkitFRW6M3/D63ZwGlC5Pe+tjFEZlmE81qq4v2rHV89x2COgsLZtlTGUJoDJMWQg+dwwF5NPgz9QzW3ntFmzNyJM1vPFb1exhcF+aguhAd1v5KntvVV2UGbYyHAclJYguDEurJS5H60iY8pRd1ucAy3+aUkBI+EDdfRPGNmYmI+n3hCHZBuXTqE24+gB/4X70tQYXG+LrP4v2nh8Ezu3/8tlrfiJITmsfzbPTErxWSHsyfz/wIRn2yOtmMz8nrtM7xoaNAb69sTFXIL+ZjCHTV8trlK/9BYOjPXR3mIsfxjX9EP+a0F/FdsKiGfoubtRy68mt066R06ngSVBKMEDHK5va8h2vB/xZfq5bFKd5PK8BGL1t4+Qf9uZOkMisUQVcKDZq6w807mFxlW9AzDLAeGiphFws/lbT1IuX2MKd8Mp4wX9ABlnnK+RqTysYF3KykqKAvupXzAxubvpYsdnfFTe1cAGV9mnGhX3FH+NG288ykgMq7mQxy5ita9oyP6gBJYsxpUD+MhCEic3unEbGAEl6raaQ0tHLxx/lSscDjpPa/w5OvoiXzatr3VGhgWrdFg1YPyyog9GynHdlyLz10CFNq0CX0tIYwQEgdUJqy30JJhWSXQrlZajGv0yNBCb4w5Kf20UyLOne0Jqxm6LhZpg0yWL8vPMANnVjl/ThCvnula8HEWz0I3R2BdpLLDzaIPem8j83t0CwGpOtHTjnEoGg2CJSahTPw8fqbTxFtDA6t9yl8pMjpmzrT+snD1nQyvyta/IOBQPPdC9Du7tCRYVuC/514qVTAqb8WnwCod7ttsv3AVSw6vG+XCYhF3COgEl9j19qDB9M42E/HBEgtFB5nsDOOnF+/WllEG2x/CjaKfivuNg9rPQGJKEiRdMlJwClxwwG7RPJ9z/QAu3lShDyyK+qEPyanHmfeKwQzhs0Y4AWMBlzVCw0x2vEzEFUq57svjaSAK5Aqh3ztHhIeZnKkdX3Q1C7zs2KytbHmrkc4zrm9xW2IbSgxdwm0AF0Bvp5hgQEPyGTvO51ynoT2HuiD9w5YzR6iXLSdhf/o5cbuWTLIxFf7K/FORo9PnQf10dwoAaTgFwAWFfevc5OZHCY4Kgl5AVjWgcifXwOxmJVkG60c5EBr1COuxYjiDuqfvE+VfCKZcw+k1rkfYHM2jhg1Feu1puUIckXjEIoApHIO/4Rk54GWirQ2f72XGZbv9SpRkCgFnjdIA2badOFyh0ipNmPo4f1WBdRIYd+WVEt0vUqxz4KwJCPNgH7RsibNytTudLfeehhV3N6InGxXG+A0V0r8hnUcFz5B9NZYXX6PeP+UcNndxyXnTk6H18Lb3zaszIMGTVafuyPts77WkxztRTbGvZdWwE8UU1yWmbsw+GVOZ01iY0lrTKf+7VJAm2vAqli42g+3yE4fZ52sF5kTBHAsN1ur4Kzg6f4chrv1ssxZIt1/JO2e/NZ+YlIuNX3GJ1R5EyhXxFV6upUHzOk4YN19xXcccQRLrJtKFuX1SX/v2+5g8abo196KLwom7PYDhBSyvlA4kTpS82DJ54RPQwC6d7EYYM5hoQFuuONqXuIuDWiaN69i5NvguYVkv+kxFW6Cow22A1MzYEyCy02MkcThrOJ87cWdgX0CTHc5Fe3MdOBomON4FavT8Gr3E53ozLwYAY9P+Ws6c8DqAGv3dgPxqFO9XLf14hYWgpkmm15xDGFQXa3lqJaFvUU2B1K7/Qku1LrM/Q39MuSiX0dmx910HtiOu1jkM5Iw8243vlRGgs1olaHsRtC9uaJ38u/F/QGqLot8TTP4/CIdU7DXc/hOznk3vmQCMVZ/8Ra/YeLV+U18uDPS2nOKumButF+mkrf9hUzNbp3bRo9WvN0YolZtbT98ABIJtFYrU4MHNbOBwsdSYkLISTPvkeZjjZ5O/SyFgHoIDqYyne1ObIji6z4lL2omf/57+UoExR8w6bji6SuzGxMmuelHTtQTIxXYB4dtK07hNpfRWEKqNRV+hucUDhAwNIJi99u/H1RidyHlzvvlCEzpr4rDkIt98vy9bffd5RZjpdoZRIa5PQcQShFB/yHxrMCS32C9DAfw/oJQa+qAptl23Jb+nSp8YvdwLjXHkCjac3Be8ZpVNS3XSyCwbWxs/32eMU6OavOvP5Y7hqqrW8mUP+6yKxE6AcPbO0E72GOPdlO+KNPNSFKpi/CoVugiYCxXG3s18+VvBKnLXRoUFOsL/nCMOgxR6KxyZdTR2jvjIcPJYWR4lht4F/AzzLzyA/m6v7QLwPMOhA4tJZXZCyo1uQeNNeDGDmnSMqgFSb+NrYP1BExXXkWSR605Ps7tZtAOZh7i9wLL0etzAIrGld0tUV//9CVjyyAL4oVMBAWfq0IWOHs/8P326BtKnNOJmPlqn/9ygodXsoQLu5y2yTye/5LO7l+ej62LNlZ2xQ8muncAocy9UzcceCsFW5E8uQqpsYuVCBA2AwJXoy5cUdDhqt3eYjmEq06mINAsj4HssAGsZ+SQITIM+1BVdxhbH2Yf+2f5VYyCs8sMcSaAoXhPyQ3so6wjhqHRIlaUeACEEzjh7I2rxzaN7GpGT02d4TbrwqyyN+nogIjCTga4SU4B5nRBjWOnjJuJ3hN2WqdTA8v+ht05iEGSV47eePNz5WkH2oEHNZ58oEoYi9zePggERYhXdHK+HNh4VdO42WZyeNncGL3ogw4mkhjZtj8UVRruHg/4AyNUVRSKaVr/R3nBJggt5c4LBhuLqMjXLexB6kXvk23fnDV/amXTek5RyuIhSuVI6IQp5Zac37yE/OP1gwDBjOTSBNtw17dMbGlR+L2NizGgXRRYZd0BX1zAyvetYWeezEQLHZq5JixiiqQ3S3T+tNjOUc9vuO39JXozeJiWwVz/DAHza0rqK7G8zm6wsb1qBan7tpMVCk+VmqrUxexyGo5/lt9S0JS2dpauoXRtUbeMEn05rzOyofHqE6HjVmpuLn92KY8NriqPypV993V57vtOn9qGL397//ADeBQAF/2ltiX1Lh9NLPx2eEw1lcRXx+NmeLqFmjF+4cvUSfjJnaWvMYBPUzGlnB9D8Na4vEFjRT4+lK3hhBA/d/t2lYt7z2N/TKDKXyAXIb3KJugGDk6CWEyNZRjYwsj75gLtA3D0XShBB3p+GuTZCXKRMxWE+vDnO+64eiDMLQCc5jX4j75akU1tPkIGc9YeFY1NnwRWrtcosLztJQNXQOGx/NkBtmLGMXP09rthXpDJD9QcMMgjdMWLmCJNvobuoXYl8fGcWnPQtSuTy9A3ZgUQAywPzGof7QlvqnWcs21AuXZFBeYu69W4mNo29lTu0ejbkVaNQt4/7Lqj7Jy/5kAh4NxOCUYRiOQ8o1Fb8mnwXYBeBcWQEG64qlCHPesVRs4LkLhM6J265AD2btXw46nsx2u3hC7tfnU+FGZGxvUgfBK5SICgic08yZNAczhB0FAwPwoB9xF67gdkWKqU8Z8EyhjaH9foAvwnKoYonhDsyrfA0uGVnEfuLijArRQKYrgEMJpWM7eeYmtOyNxQ4unu7UZgBflP153yZgnjmySRpGFFYiLSFc3BW7K0BWchynitekDCq0R6V3YAan+U/C6uhlXUvbiZFPfLaZrsclbdlMVvMRBk6JYowXelRo9fjwgmVip5YRqE3b868BKDihNsHNp/9IHxxZvzspsNZtV4Ftpbg4b6y8JlJPpTFvt0hLSDigb+gVKkJQ0RJcH3TssBGzRp2630/twCYAlMzkjKoiM4DWd5Aa/XXmvEarDv1C59TMhAOqxWO2e2vbmHurVr4RWZsGt89CcSt+sJ9V1zfiynBUr6xF423j+b7d8LpIViHkZO6p2JTXlzkz6d3Tp0Nr2Sav1Dti6qr7N9+AOvkIt4E9wWI62Mb2LjqZOLxhON5NnDo/TT2UBM1t4W1epqlG4XqYVYc2nkc4tl41gUsYcEJzV19wlL5FLWJlHUGlMectJjR7oE/XCx2ybAnHSAFSJh3dkYSjEV/7Seg1hlFth1L+JTjyHwt2NGDWdxGkYImFSIHuklC3k93UDg6Xw0wuINyHLGciefx/NauuMYn0vem6tDCIKTXQ7VQkfaXazrmEqwQ2CabqOXIVSZkZJS+3rwuB3kmIsbgM5R8gIeKQ10b/QwMtEALDsO+7Ew0B0X58FFk9LnjgPinrtMIVzufdOckaWDtrLDAAjp0euFQS2ODF2vttPkzOYRjF/J8Smb9Mn4W9TqYxQt9tqbLe5GjYheO1fAj+8Bhy5BDpqHV6MXrmzYUEnT6JAhirPHsrfPNTwmGG2jLEngbD5FYOomdF7/77TKyEEB4fdDhCV4QIZkxNl5o67poR9MIAclHTOrzNaPA8Y8mX8TIlN2nUcAV8ihkAXdsgTFHIsNGvPiwj3FbWQtgfo3f9vjFSeZP5ZeAMzY03T2VfWqQhwQi0rAHAMoqpYaVjJmEkWFpfH8LcD3QRLaD+/WcHWFwV1mqHl3u2hYqrFgJOBNwWQD7/c9aNnu39ufDXzDRJRFc3TgG+ZMXfLOBTczg6Rbrzx9JlB7SdeB3hd/m5oc8bPjIGJINJzr8o9D3Oh6xOhCzYuGIVIasYuvOvD83CQatbffPakEIA/fOSMN+90oP4kl/E7DTb50tHfb9HKb4abR3tumiwq/ZBsuCMrGf4yG8jNHGQB01AuDoA0IHwVlEPvbYq4gpjB2KOstU5tB8Ni0NJVNU+K1H0nEgVVzltnIlJAbBMZteKNbRqncKqxWR75gA2sZCK0BoURWFM9JmBVdLQnYF7fbwz0Y6YQuznt4yIL5jMSeQSD8oiuCT/SKXmE5Hll5A77jmsUB+Gvi1Fu4nZ0yyjPxq3CiqPWqRv+ATHwkBoivfdiN/D7QewNWNmcIL8GBl5ssH1E4N/6R4hkUbPSO7VxHVMQabXxtk2yxcPkH67WwcA6FloGVpDYYZ4CqVWOtlWHaBNkm+HR+MqmteT8wfvSR1V2ky8hM5pkQ5l8Zs3FDkt1ns2KZIbEFBcVfAjizuRXd5RJdPrYJhKcevaHXaJIYCYwy/iPWx67v8H+byk2UMT28v0eGt1JP6u2doEAjZGmKCMDcwDcXgkT+vZRdqxwToGfiHeK3N/ftf5GpNVBL2blvha0jB6yuUuhAo3Deh9DkJ5nhQoYjHB7H7eQ2wJUff6hNvjBdDeYJpjfjrmpsHPFU5IW9FPWhvS3mKdVWQwKLM63F87vgcV3QVzm4z8oz6ddzqnDSv0s4CxEUbOYoVPWJ3GUPVTBT5hm3A9Kl32YbfrpsXJauUFFLZNAdus7J0u2u8dq57/kw7yYof/y1tkX4d5rZEci7gb778s+1KVfL7K9nfynighs+bbmra9z+J+kBMeh3D1VCV5u4+hDTeDSfXkv2Ofz723oVI57PEHZH3HR6g/MVdalgtS11OP2etjbJCNqZ9QU/2497sNNUNAi26j+2XkmGZt4Np658Bv78U8HAhVun3LJoEmoGETgZVF3pgg7/JaJhnxq7mW01xYJOKd/YOOJqxZveLsW7w19VrkQl6WXNIGki0NGjy6EuIaUfcWIkJ51wEdRMvNR5488t0bhiq8g5UlmBdOCEYtjShfVyMSp1FgYrt8FZnlHq1IZCvVAk281L27TNB71O2khk74sQG1LCb4a4bwzfURL25d0F43o5SUQ7wABcnRHKI7otb3NHJSexQYfcexTImcajc/dGNM8eEvUD1xvgHwL/+yK5EKVWD/m6Hchkmz7fw0PV6ajbOVptyEkJwLJgNLT/g62S3Ejb/aTzLMrbzUCAkLQP0bXXeVDf7pua52VaGigO0Sezgl1uy7P8+1IS2P5zypkinWeUcFl27wKV83oRgfBf4l9jVPMb++lfiY8bVfawvIYu3PIGBE7BZb/hcz35YUq4bo03wOWZ8mAKkZIgZKohkQKGEWDZ2H/QoZqWTPmKdE82PTh9y/TnOQQfcapXRhr4+wA4sV+/LL0WAWqZ6SSUvV7REeSppkw7x68M7RDv3/3ApdxL45yAqjS4le8TwgQn4l4izL0cVjL6+D8jAuVTrZ19Hbmp+GJbx+zX38O35DnfZDZUCT/4Jz3xubiVq8geQEFlrX4bUSiOvco1PtHIpRvsGOqHCqKjH+MtlIh1jY3ZnILChvjnr+YfvNVBJHyjCanTBylodU8nG60LbbFB5qAPnYTNsuXG3/CeKfZj9djGZIMui96EwZKnpFfGFA+G68GpyA1FRpPjLchQQBaBVqKs1oFVhhZJ2e7zimXmWSIrZ0PXFQurCis5GmLpMGXbpeccd+TsrIbiCCUyyxQ/C229KOq1dRvX1SqNiBah0b5K4D7IhvVDzENeCWyS/5B1ey0dfyjcCnnqbEsd6NTm4LopxWEHSWW8JT+Jh7QiwCZ0FTngBvE8/q5wnECCopCx1G/+ZPZERlr9gY87g6mos8l0sUVBrPG4U4FMm5cWq/OWCwJXQQodwj2Wk2O2jcU/FxqkANIVJLmTOkoSpo+oOSlmxK5bR1LtYabx1hxKZMuRKGuTH350ILcsElC518h+Q0EvHI3fOSyIfxb76obcAzoIc1mzpxaKfffb7DeFXM2QWftMDPnudqA03HivdK50vnCSMTCOweD8RSzM1E5Nde1WSEZvyo7NpyNXiVmwq9lGujaSHDlqSPF7rR0kGrKSZGCgLQCyIejxENfQEYoPwpLEH2y3JTH0F/1pp+fGnjnDoJic0T95TcmpmOmHLb8YcW6x14FNnMDbqaL6COUyzQ98pHYPQNtcqly8UbkOMyieaY/FOf+yA8/JhOFxKYU2O2y1vPsxfXhJ0+ZoeQXi+EYF0eLsDXsR47XLn8HR8oujHmWRK2Yj2cwrVnHCcjuOAzNzruCfzUUVaGYQ2SAF+7DWlsD4EL2KsO8YWFxKNzyHMjGMDUW0CGQ6cbEH7jcUwZZ1m8jB1XfmXS83M333Fn53Blz4JRKDssLAmAKTrY7O3kRbRe3SAdvwiAObNQVrTB47m5HZiDn7ADVGKVq5MOGsn88nm1mp5VeIzjy6VB6kMzANFZjPomI4NPLCq7mAop+3HvcqGiDQrgPvrT2WJPev7otXadFI2Kh5G9jF7fWQi2Vc98UEnWjgEwDmbiy5v81aYKkpBMLfIh4vq13Vi6xcq76aZWExWQ8wy3gafqGhL5bt0LBz4/qpkQ21Ppv+MdbEvqjMxQxUzU7TvR94dx5617bGDsRdZkZEQ+4wiel044MQ4/ixZ46gA4zlKei9IYgNL73AWBBn63RF0fhSkv50aK5UgU1f6BrXaYLS4IJxo0Zexgv47u1eRf0ieNK1dDwZEfB/WqCJg3zeEVhB20aES33ojkKzHYUS7pdegXAjCMHiF4kekzvKtQpI8G5kWJ0oAVkzt55Tj4c21940vEr+PJZoHdMwbZLb5E0o+lHpUFma6xbp/A+eyz/kNevc2z5/42TQ45ZQru9e9Yj6hF/r5o66JC2q1NBG6TRjFkDeYXbZRHycMLpf87iSn/WFxxa/eTli0E0nxizGOkcARBoihoMi+S2MX9GCF++O2kkrjdynpLgfvKf24gFSKBEiDOUTwLaFF6ROOvsSr+vHt/L4y+/htRZ6QNe6GQ5/V+OP8ZrRKJtX89J3X6Sb0aM64DzLKfpFYtSfXiMX54UQeAEVJSvAocKLdwy41fjFfHh3LMvkYojUUvIMb5gDUW5zX6wkxtfpA7zLqfs3D7Sa52JkYN3FQiXYGbgpbyr2hnnd2yReMH2ik6GIn7uBoGsDsCtvfETq8upjS7VeHNNSn3QCgpyQcX+zUY3oLfIJud9NqXtFXFj3SlC0K2SKo/CWip5m2S8Dw45YcU+SKbs5PoNQFm0VVUVb0PygSVynGdCyCqYWp/+Eqo3DdM2U6wu9HkIf3auptMa/Yv25oaHvYXWqPKMS2Vt9tT04cu4S3erNrZoBNMsbj5OcI0GxLv0iz+iKlRCFGDAqFJf+S+/sF1ppigGev0MuXQeFhPsuE3iCVPEqq+gNqVoQ2uYg6Q/Fmp85xVj0mBtOEwRQGsMcL+bltuQZvhyCzDp4OFjEHxgV2dJLGC2kYy9k0ksinHH+rU1bfXyJUjJi6wjUp4p5SLRvYR3rrgIW2wH4NprILCJbDOfpH3YMJs0RuESUF3chZuhJsn0uxrgBdWMsUJ3GfatmsZQXdtmrGGEUELpjrllKjNU9WgRxMigHb/x227lrMS5Q3sJiWTUUOdDbXn38FHwgxI7/mrICRGaYltmws/gPk1sQvbtKGL3MveREJG+XR/1BG1ZfptE2EihMdSegKofa1KatR4EQS+GNChDY9YyW3IBnMxLCcGftsgyxIi9GgK1cpXuqpCBYA11zLhQ/AGZ08jehE1ifsBJaC1juetVKoiDLiG/tdi3wQfZ0vz7Bn2GbA/MQgaoWBVJpeErjScZdVhMYAdhxR1VvRkktrn6px2UKdUJ78ecY54CM5fbXQqtxzBLBR++e/4uv+j4dlqHbQz07H2Woh3XCMvhCOJK4OAt6m/iQ23BuYJ8cj9/NPFJtMhqqROB23J0rSA3T3dYCsPGygR/197fcN1gyngs1IHcSEqTMychrFNtqXzo+6ttClrMZb2k7ATD0Ed+WB05MaIPlBssFxV+JjNueETzxtbw+uCiHc74mO7fuCfBVgzyVuakA4LMs8QNrPXmmzw8PgSiXmCYpsxGVGhTTFuVbQniWEAfXPUywoynAcQWxQZcPrizs+YxzvMpWiQkmtUqFsUL+cyo6ScQge+fYetbUIQyWVl7W8fCM0l9PGY5KTdRJKfofWdHo82fXEu6zHuSfG3rFxhoWaUo8tWqkyYTG1Yr7E2bF6osbmlnDlD5HEN1dUcTla2JM4XwgXsLb7py83FXXe3pr2AtHM2IQ5NOlAJFTZyyI+oF4Wt2ej549gnZPYIns5XSp8AvZnWJMJ1lVpVQMD9XDCrtyLKsaQ6GXeHt0gKWaTYcwlGQ4T6q1By6J0bWq8vv3tbrRapG5IySFSFsTmFkdgswWeB3zei4aq7MuuKYBuamGvZiJqzW55uqdlDHm34HlimEMS8czsFBmQ1T7SKEvDx9L695sbsjP0Pygz87mPvqWsuuR8+mJ4Piag2BAW6Mgzir8F4M2ZA+3ZDxu5cHjMn566k/gVJIuQEK0NZrNAPQWb6jX1h8o7Qo7YS3EENXodptwAxrQJ37AtqxAO4ODHYOOW+uAJHiNWxm2WwoXGHTQ3yXTYhZGYddFWzIYkm0gjJGggdxx1+5lfUxoYff66oAucTegU2Jy8oZ508t6VwrMqt3MZnJ0wJTcKzN2nINwuAAWeaZeLgUWZve/DNnbx1Kq6J3zvikwA2fmFaPL8SKOLZdlNj+9il3cHrvcfhqbOhRjd3PHM+zt6ZehuvCRp36/Q4tf2Q/zZ0rDuOznTxG2aLzqJ/3jh9cYqxT22MzPHm//RhvOmGzC/W8XS0ADey381sxzX+1KeAzHTg6ByiPQ8wA6kLPQoR+mxxfRM5HYc9PgtZ4W95Et0Yh1pG77gpEWkX5E/n4s6+44J7nwi0PVhkRu02hUBtG2J/trVHygxwdFxHeLIcEhd5dW6IPz4JChxeMcXWCj1y5+TH/3wv9BQ8FGEj9xHIXUxAI+HPbTvzPtbHHvlpUY6SQ0TPpbmFOI4m/DK31ry2iadSW6Yrx2luSKY8m+PTNLCb394WI+w0Qfqfi/TGeBagn3+HiU18js4mi4GLeQ/6fbqMFLLLXP0rtLs1RGB0e06SxIDz78nweFyFEVJ9Zq5i9F1hIHJLH3YiNqiNUktEPctwDhkBddOikrjW12AmXa+1v5iry3gbEPv0aJjVb/cPbgsd+MzMP2FcHGKrPH7crGVQKRkJRuwYUtewbPbmrbgIgQzOox25BCywk1q9M+CbBT6oanKwHRFlItTAiVxzfi0eM4Lc7osRe0PBlqULyBfhmxUafrNtOedjM2J+PVPEnDrFYFBEdetWhX27xzfw+WG6rytwivpFN3c5mkUjBIzm+bwqaLKHODh5YQ9FFH6G3J+U2yNJYPVo3JElvF+e3KL4W2wK1/e64xzZboDelCsqB0wxb1K75mza4xEkTqAdVSrCzs38SgRk7TtjuDDrP3yVGDEFzOp4g6TjeDSe9jZd+Zt9Fkr3JhHNzXbxEpPoVaibntPNtsm49jGLRifgl0lLBWEMxBG+qcj5ejBsXR5spO0XJUDEo4GJDMhqDdn0o1JZPn0QqfMNvmAXtZFE4sfyj7q2qs+63vN1j2kXpJRdtPCSKYPMd39hJ2IIAaQhSTIl0lfbOX4tZmpu11Yo9nkcr4lLfQoSCPVntGHbVqawzky6Nct2iJdsM2jgbqqQDiwcPTXD3vi5zgJhyyGY0HYDrJ/YvH8b5w+fb2Nuj3pbQaG9ZVoCLPeM0Eq2NuXrm60PlIK3YaU+3/9pX2FWKfhEmPQCXc5ja2PF2DCmhWgIb2OzFn0gi0x9lhEykfa7H4MAcOtQUGtDOk3Tc/IzExKjLwYIDXCNzQwVDsa6EFDDVLag/5zqjcgiskytc5x8h8B5s1sRhob5ooSWuogMlfuFDXURahiWhaNC5+/Oi6FehLXdogDM6jzmisZvQCpKU95ofArZcOkej2qQWgtjpaPYN6g7c4Zqf5e3ugkdFWdMbZUA1k882Qo3s4Ow8O3QHSF7YHeU/nnPiQnUq4JlMHLxbtRSqvAk/7tB+LLJCmeUXayeEDOH6n2Y04hytuv1wt26JTd5CY/6OTdoHIEzVC5I1nThXE7oj2BdBagpcONGaPl9W++GibAoNrwAwIoTBoRtHih1zg3nc5irQ8V1mpaq9Zb9iUNTg6z6rFzN5lCkwjBEVsIOirZPUudCmBLGo8GTUcQkoQxxF2f+09obBKbtW8Au2CUr2touTI1bKxPzY8V94BpAxl/LaN2e8PjMKcWW7v096UGov4v+cNl48g9ZJJSw7Q1zzVV80xpi41N3S+lM2zhsir5Q0Ful4O8W0PWlxDtMa57hlJBTK80xW70DrrAVSpa8gFyOhHAolV0Ye6TgvR+uRm1/fAOCiZrDQmGW+jP5vk55+LdYJxM1ZdzE6geea0xZOcxACntSyrr/lpvDFdLnEOFkxPUScnUr/Y41HN36dECGvj9g200WeXtupMAkiPXZQsAD1Zw31ZeFhMCrNBT3cMRqfoiLaTwWlzT2z5eZK29O6CIlv6iFYQM97dETFQmn80xycooiXRicxuxIBHSpkbg7BDVdqMB3zsUAdqKwyiAl6Iq8JnIPfiJvEGwP2Bfn86UAQMa+XR4xILgTHftqnRJrWKVE5RGQP4G34OAYzQFDs8qxWMp+BvL3mQqPScm3q3PITlB7qkx3NDe+BOcPzqjdBcnteg89wnsc8O2Yqh2X9t6JeSigoDgdHFsjcJsjEEbS3NOfNI6cWkUu4R/75+E3Szz0o3ypKhwPqBct6AVDDgRw45W2PJNfcQCFav9zbzzpKMLtR28tVc6NiL7hHIlM+SeZxH5OZLrfvO0//xq5/Klq5eZpH+VWRz083Qdk1DJbM17YsBW65khPMIhNCKswpr5bzEKMJVHm1VcmZRed604wgwBW3tvTkThYGVH6KQD2qFsGmBJR/DtTfXHh0kOoyxOPdsm9s+CVyUlZh48BgIOMVnacTBlMVRnMOjSeQFz7iWCCAo31vuJOn+m1mFz+K2Fj/2cmJDyS+Po8zl9aEdotliCa0sm4d4UUtlr2IdS6vfNQbt3/oJZYnUnfE222VSiI6MuYCsK5QB/nsBPZcgWyUVPnOtMpUXlbFrLgMN9ar01nWrM3JsY9tsYCj/bfqY+c4zYvox4tDoQo2YvdLFiMLC1WqGitjO/Bg3XGViNgoOJXpd3xk+lwmZTQ2MmBNsUj83GE+8guiZN4BFX1uma/2amesdgGdEiDqNtcK9+DeqjLsvo5tkDbusRCbaVzUBW9xHSx0HEmeFFBPbXWnKRWOlbsjGF/J6Fxd61cT4fQ5/HRYCTYDkVewhYlut6j9Cp2J4I22/uMFba+GmxEZ44F4KCc+ge/qPnRYbIuSnWtsTT2KzbEyiJ3z+6g5FBefVvqfi1SQyrdTzilsiz1b2S95rxmiyosEHAZ37dAPiO55yxJaSlLETONucGDiPywReehEJCHsFyXeyAv6qY2GL0jUHd2cnkSYKUiDbRQC50RmZLg6ONhMjXQv6xk0NliAtqX//SCHfuDDH67DpATwvq6KMrKfHAHbVw+/5Idydp9NLVpn+QJzEboP+CPq2Y90mt/sX63HKyvSwNbF0us8zgb6Roa5Uw9JpFz0fd0URPeougOZemVCO0UO8htlSnsLzD2GWmVsmZsXdi6FUNwVGTLYV6hIdIqFyg7snmMLaxUAzGELPgDYGQfQtrdnKBD83L0UYQu2NVe0eMdoaOw9QQ1wYr5QWnv4fl768D3jLy2QmYKyX9PFGtBTfh/ZnaOjOe01F+8mYZ79ZzZP7r4kvEC3bNu0mzOynA94j57JNYzwu88m4lVXJ5Y0a5+LmRwaAepUrVi8o8Tv5szjKl1hbHfW43wugOrZJGcTP+bt8FWbbfE6XxM8LS6ZWsTP2kEwoPr0cMbIE6PtXY5qOzdTDMU0QfNhauYNPxSwVAEmo7v7F4QvE0mckQrCip+yCUBOvThstiajLGGNZtfTX7eqvdhfV+x6Tcvpiz+caGfbGdmm4pQCWrJj2ExZPidMyO9fq/84CvVtLMpFHB/PDafnBcdZ7zNayotxtZ0m0sO9yeuec7giE7voGWroqhCtmWhOuhP+ZS72Gw2VHUgeu1avCVn0XZfGsVWNvgfk4aAKv6f3el3qvvRqxh6JQB5oQmXaVajXNvuWrfU7EOvnCfv31mLxkBRFQz3XS/iVvY5EkrzLiP0mY0lHb7WpGVsHf27xcYtC6wt8LDXtHuCUtVb4uPOCmt+zmB/TeatLTHqYBVEPfuGneoSBZwWJZsrKpV4wG3rtwbo4rgSVPlAdA2+Gd79wslKNleUgjAk370OhJtHxkpXoTHEXRXurAbi+AFUSnmPGIktNvpbzwQMTKr+RWh+NIAuwXHsvuqLzkRuEHy02NzeR6hDVLbNOBNE51wYR48lRxKZLOUwPL2tyypaYg8ieZU8ulMpntla5DhTjf+J83C4n80/yR80wP1idD/uu5t0PmP5ufTfII2MFbX7QLPO1HbNiSSrZbF7LzIvcQNYPvA20E8l2O6uwaK04/5bsiPoCd+RF4lxBzu5mhwZuAQuRJ2pv3B+oEFiV+gm75JcN+AE1Kpbi/fGxwjjQzNI9R9Ygs8JXFvtC3AplKS5517K03PMih5+UHoPFTlnfAe1ObL4AdHI7zm+pbX6sDH+VWOrSh6LsHukspKsVxI0zfOqykJOdaZaem1miBasjF7cauJbVvHrv0Bpl5TZBCVLTWIXZHoX+ZE23i9/kZZhZAGiWuOlp3z9gqTzXXfKUY28XqquKuRSQnrWA0c0jCfGCn7bDY7po2ppob/ZTUIOpgXgG1W7hfiyDfPcGd3nqxqom2ABw+PtJNeAuhMOq4ZHTx5G2YYeM9ATaazRaTg3ra0QeMxp/Wmk/TJF930NfKBF6dziZqehEPMdy2Get1M+HhqzQUfncDo9bj0uPyj+/jupxMy0RLYxjn5x4kZZgNsL8e/Guq6YYy7LSMs5k9yalTEHOfx9j6hj5xNDbzy3t8VR77XY4AZq6jWMYTxngaAt0VzOeUG9Qy9ODLEdF9NSU9AVWpjEwyWeC8gBYMJXhYSzIr6iSD0i+vPFPY6SyfOlWGi+qgW/Tb0oQIl2JaIhiZcFQpMb6MvpzPoxAsaW7I3MAPPdLcsVH2crDLPVnOQEJRvQWla51gjyYEbgm3iYD8LOMFmfnVrKlb7AwE5m43//FwfFeGOgPcCdqQKD4GIjYt6hAWQgsxFR7p0zLuclmfsDHAwF8HzwFBeiToixq9jdMARxe6ALZ2m3zp8tBM4CqfHxuYPtH9MCJUTWUQri+nlIRLAHUS9P8KYj9PNMlWm1YkWoDBChECjk/FURn1qRV5O46zHJ0xdzcoaiwkGWHxbM9DbApJBHvDitPmcDEjgkmJvQu6uUpGlF4T4WOnziDZ35HVgTezSHpSkqXa9wD1gKOPsy9aWXIn7I6r3B8U2M5GmXaO9IEWqvPZmWJQmvb1WJ2ObB18oJ7qO0y6m+NPYj6zF1wsRSJCWwIfr11iEsTbxMTkIh5mQ+lyAin4U1iFJn6kJfqeKrO4Ox7iBu+M8XRGHrMMXIvCramS14ryv+8EBgBhsTgI1UZqeyfpqppnhyInbS3AVKP7GUDpPLdQHhZy1Z0YZttZJwppq7KBph+3Z7AveAVDUJCUpBlb3M69K5YGGEKR39CpSUkBXoBj1ZLwrDfgFGDhluFOl/dibkYnorwiU+SIuKbpfX641jfKXmukjd0jz7+1iizGNyEtJ44AKr1E/p+vKeoYonWn1+thHctey4fFhqkYq1XRZrDX+WTk4D8kv5B9wHzwkp5DYCelZUa4WMEgRePow5KShg1540lwxXnoNG+sjjbVskJzAkqB+1l9rXJXZKD5F9ESwsp8t2BMq1A70reLGpU5R1c1ZqAsprPSWE0EDbfamFlePKVAUsYzctENG+8XvX39xvWBclCbs4yBVvbUpYkn3TXxPsNv4VdzgyRvCDPHV7JHJeOonTvCcyjzznmKHwd8WXojKJBh8IV671VXH6mKN5nJP3LPEJacsSR61nRbtvCBXTq8gk7zKPrsbfW23BreGEWJuyY9RjJGH4APfC/FiH8HRnzgqBsXfZusAmBbNsyi7H/lOB+JCEb1TJvmZPz9p608X46v1YvxEjv3dLeRJE3WeGewJfKjl/apB2mVtRsKxU0ljIMqeXdrvivf5blQWwCIJCZr3dUWvjjOeocG8WuDLHr6nULo1FvjRlCr6GG4NABrUnRD7pK3ZirUaS8423ONN+7vO6C2LtKAA7VPvxP82EJ9s1w7567Tu4/u3uRLC1sHpPd0/rX1uEFrmoJFD73r0EE6nGlRmvbcgfy0m4jfa84blep1wsaB+X5TkAugOs9fjuv/I4JNYHQvNtDFtZmHt3tm/WZAoPcbVluTppQ5Him34bbWI+f9u5lA242tsXPuPHZEWPcvHQJuiXzdd2770n84vEVBVVAgm+uSrNsQdXXHNUBXUhmOgwa3Ec/VCkGYp0cFY4ccyjZGmCNVLRfALh776UEm8UXKacRGoOXfe2AF+JlJVCUmUsATjFsi+1AHhmWmyiQrnJeqff9x8JkwvGKoviWl3rWkKkE/IG1huncrBq7U35dN+SMRB3J16ufiIpXnY0KVomM7vOKCuTPzQ+73Vj/ZO9O+JpR20nZowjbI6ZF45rCrFf3UCWKhWlhaifRQ+4p9gymXfjOqkzU51bD0C15Mn0FGanHyUbB5rEd46B3yLi6c3f+Br0e49l3a72kPfuB3mTaYURQc/jmG81gX+inprYL/9+L2zfgpSuIISKUoh4N45cbz9Ikk94hc1Z3ZIvknTsMQ9OxDwNHd9J7qAZU34jD6jrxlDWNehXc420h/7Ye9zgrRzN7KHwZPUDOXVLIrf/7GZIN4SlUq+GyHJIJwSGrM81CYAtU0r4ygnUNOzuQx6ELVAcvpMJ+gRZb9fcBy2E1ohvTN29D80PvQ1tUSWPz57fWwianZYZsUifMx9kLmWpl8+sPTZ02SOUknd64sF8PQGXO9fcS7mUkBo5VDJQLaSWLnVmtMdsGz2koddDFO6ej5UJyqN+D+IfQ1ltv3RhwkwZtyCuKrCzAsuPpCW5lMz2sXE0i0CHSHzZS88XC7Hw2TO2ASwAfQma1+D+HLawTt3TUMPLWHommvpMoYcag6chmO2uncsOfdXPBdrqmJWPYI+6BipyUXqS0OrgK4T+3gCZUffCQe34/m97XSexXppdgHNpU3CDBspFWFT5SU8sHyywckMm4BWk0cN+NEDnTOq6hGs6DUkIc8WsYXZYN5UrVJnszwhC33ujx4zfdFOFRwTEnp9TCkFsxmmQcOONJjcVXQtYznTj1Kvx8v9s6UlhA7rLVUrCSZzKe1sRxyz1SUAmkC6poOZx4GOnfkOZYIqOJLMZhV6gsDfjxKTymE8s8XHKKao0YrBIc4+Pl6p2s4xgRdbH9P2/nmFt4tD26f+hU1MNTkfhxDRiJICGCSkWUMxRxtHe4h3Jg4OQHsdwvvlu+eqjoEBCnMQU58yDgEWEHdMjYUXZ7WL7O1ohXAch5XuCvGFqttcOA/MJUevK5PZOq7ctcUeMmyIz7hoS7P+SEpLWk4pFEwPh3LqQBefzAq51uqcFRCKnNee5bE9WyW6b0FP+n8BbL3P899ITruRDLXe096no8Qd5foG0AFYBrqI+mhdzKxH80hVbydf0E+Wfhy3XEWmbwyiR/WbgMpWGpUZB9IdevyDHwDPReJn8nX+fOIU3+q8QWJXlh6IOk+5ZRsf/SVOT07eq5e2HdqzQQfsThYoXg+J59K4QbPOdRtM7/ls4VoXag7owPLErdu2Lk+mYAIMDW3NTdTcAv0N7mCMvynhb3fibiym3WPwWJbD1n/csgLfZ5YDFIWb7BtLOHURbSldWHlwRr3BbPfxcFJAcWIUJw+DqiRYZ1PvM1Ca9OCw3746El062BuGWj+8wJ1rG6HpZZrLiQULjgqI1L+u2xYhQ2qmmDst10KYqi67c69T6lu3oSEPfqBMJ1ZtBoL3+lr+oqaIngfY2FaHyv1frvn1OqUhEQjCUUNgdBoM/L5lneyyTvXPWUoLLXhVeInpqbXRd5pA/Dodb1QlkGx44bAl9avvELNE27KNdZpZdsBPhSI5CoZMiIPGJ6/Tjnqjo0vMmskOg99phhBubvNeunCgL0ztAbdU5Vd66w/XGCpgilNM/f4OekDdYf2CO7q3rYDMf40u1Gwb71TO7Q2R38wPeGVhG93UsWcxyXw+wuUbxWpmcyI8DhDldMAbBFMJXeiV2Nw6uDbt6TQL/Px+MUwRqXc5Z4aHiMNbascm3r1vF+eDjMoqBiufMc+rbk2YBqaVZYzGvzaDCnxdQtDLBEbwf6BWLwAGeJ8MzlIyvYYl3I+nFB4GRRuKSdHyWVAvTCbBFq7YSmN/xXsfLotFaBjz9xcwPS8ifkAWtfgMn5LCFt3e1z7nMC0s3XV/nfcKNFutYixttPHDuVfQWu1gO1L5rdZRvAluCugDNFiwXaP0J2zHNEon+jK51RMmgH7MgLTJcom7YGxKtkosu2w+no55vvo28AAjnP59ZMT/WfBJhkpBT4y4mTL3VvAy1AJ02A7lt0FnlOju6L2ibJ9q/b6+wGlR6WXAganxsaXiABBGScdoiNvaNZP/93OvrD7tQ4DmHo4TdHc5XWePDmVu5I3sZKZaLvpKo40vHNGOBZt2nqa74IWr6xkMauOeSNI479aJ2qTTdCs9+FdiwwKjF2QV9mkneskE8+kzY2Q5yucF57P2fqG6+Hgr0e5xx37NfleuTtMcynC/ayMqqkK4VK40yMZ51cDMpfmYYuMy8uL/IdWyOUIILb3NpJZVXshPFyCTjCAueYcTbRx+YkFiSW2jhzeKHozxfi5EYUU28L5kajN0NSfOIiEhWXMrgFllWmiLHMy1K3lCBUSbL2d+4DheoDcwnHRonVrmCpYfGv81k+E8cnXn2s2TYYpYyAojsWr8VFp31v+7T5B0wxSnz/JtGnUp00c4pJPTPAYFXfvMXYwnsBS/rbUSxjRQi1h8SyyUVoOfRPj4QpxJQG2zslnv5UE1RJuBsRvBhw5ObaMV/uENNUyWKzIpg05BV9rwtQjSBp9tgcDuSQ8ihYmxCZULmmwf/GGM/Aly2ZMVdEMGknuEdSf5hxhsgg/HAbJK9j4+IRMZiujz3wdbVukjAXIdr9uIDbV3TYm+bmWEjrajlcJupCZSYTn+9f0+B4TlXinMTxY25p+YGrpRcoSdRKN+LvKpgXjh83E1vWygbR8jG6VWyvHsEcprZLNLYlz0j7Pa9+jU7++zllsls2/6zbEPhwVk6hHWYAOjJRYDh2bxlhBCcPei80P0M/yUAiD5zEO8ja5YYITnQAAOIIKaMdMI+ODTXrYO/beOsED2/hP2ZFlk69fM5WsvG1izdhUJPwPiV+TiWcUHYSznf8RnxvTt4jJDxxR+nK6EdPG5NOnk3x39h47+rNAit563EGvNPw7Latexad/4D+ZVDpMjOnbi3ouXVXnaMfXsADcEwpKlkoH0WGbIqzxKR+kIgE/izXK4QWr6mEsKUlflHDAjU7RN/mGf4zGDx1Yxb6q2+S5mJEHAE+SZrLobSExJvp1BcZPPJiWUEvRvtAS4Nb/zbsbvGB2BAx3AJYiTXYKwtig82DoTDjQ4EktPTUfaw9Rnu8Z2akrTkCP2eDNDhMfpoXU3j8sDZGRY/hK7/L1SoTc+M/Tie4sG9l0wo84+8MlqlY2RzVD6UHIW5TPFdVRgNwCqpf8U5Mv1IIP411G0c/JfUn+Iu/k9k9JmwbGYyk17aMwMtzyO3e3NVlVpf+q+QjCVUBZa2vNq29MvMv/SlOVQR9YB5IPqM9ywJyp68WsXOkA0QNXOrNeLnHd/pE+g5PyboZttfiskWud1gIlcLo5y8NidmXUBNPmmGyJwpTrJhu2/mu22pu5dwM2gpWcaNJtWmzEVCv+CgKXQJ56Q+R7MqnJFOq/2aMHv0OwjOIiK576ckWmSfC+RVosTTrwy0z44ezFK+UDQjMLmnFt7ifSiEAv4p4Dxjoez4863+nB2koLLPippI620lbVHrRdvVsOj7jYNcZBcIzShKPpkZ5PX7CxWoTsY/fze3RVRMgzsxF6pfRQ7/bL1q9xY43YqYoVj1hcGtYH27hW08GglmuVGQcScA6CkF+mkI501l+V6oEU2cBxq8GMXKqWdCjjDxGJ2yIiSa67fj++JG18eoEWM98N7PNe7vJ3rzzmtF5h5RmNH516WwzGf0MWMA6/wzMZhnsHZdZOY/xiQ0vgi7TU/55hVUyLShUkv1bVaEwet9a9Po2lPvD8My+B6G+V2n7AwtyzJYqhFc4Ev6EgZr47OVDki/mzFNhqfxuyDWWTviY0PGsmhdQEX8MDY/CnhKQJMm+sayh6ppoirKapJBR/YNlbjZaDrHALlgc02EPPpbdM6p8V/CsW/2cWArqzsVMHGXLcrPihnyRSwr2y8qyZndEgVbs0enGJo7ITvdtFJmhxIOzY87JPZedw48yqwJXzMln43+hMnh+Z9C/uhpHKa3RDE691MY08j5UTLdmoZVXq0hyCTY0xPdFVU4zDlTpG9vXtW7NC1QGZxpf2bKm2MisB3bpQE94/i3/o26XOsWSZGt1wdZ7fp/J2GBtNa5C8t/Sp3+fZrXnjJYZjw3ipFBNrlooWeopQb3vThAV/JxM4DO0mp26qRCvAfhBveLIelS3Cb9je+yKtEQ4IpZa+6k6VcGADyvxgQzVwyInA0h/e4x+F2pFGgHFhSUt4DYNtX9o4qPZVvfJf9YIzvOnl5Wb24T3SCYwAkqe5Kk3mQL4hpWBTw0D8vwix0oRb3hcb12UXB/Hb/rCZkL7YglypqRWw7+bR/UhRVC2bEyOuzQRPTXx7NCBshTWCk1b8blm5HKFyHqcigJZvP/fvbvLCWYsy/YnChB/9T1SJoIfrRIIOVtPoA529lhMtqmIu0jERAdBZZd7/U5bZtKOxKYYm0s2wxPFDPVPLYVt8YxrtRIBDRz7jB1PfzKHMcxNkZsnfNm2METmBP9DUyYgX1QtK0dt67Tvvd8rV7cDwNmfRHP3/EzIQWZlQAc8wQF+A+l8k5mZn0L+j0KggBvuWWGF7cK9zHIOztRdoqW0IUJzP+HDaCxLZeBCsNnuW8+pMgykmzfwa0Ks3ClxiE3iW9DZwLThKgKIDxr7w7E9il69llzsWEJwiyhbuCTdz6MxXPIABjw7m5pq7YWWs3O/LPCdbtpEOoJIhQISVGYdQAYhImHaktwwZZh4uMx9kG3AHm2KY6VrEm/M7FYl5/TWQArSEnpvcSrSqKhD5cXSFh/m5NyDnZ3jeUtZSzuwrAAZ868wRX/KtSGC98TTKmuEp+rmUJ9yeLGIpzS64ufD+St1tR2Tp4Unhvop7+R3JxTIiRSEpUvtK3aR5zQws3HGGAUlmMirwlqFCFeOBlRYtO1heogp+r+QDeQMVCZLyTdioXZ2NzHLZ2olIhzBM1ZwFynyi+q+rtt3B7YKu0Rj9xcdFgyAZqs/ANiA0JVmiY9SxDrSmh2XKz6mthnDQWCotSNCTHKf6jG4CADGMV2IPzkwhIwcyLQFvflREbNKK9fkY7nMOnu8mhemSAMzms6rwDkiOYFH7jB0Tjn8j0Wdh+aYWZQKJ9wO9saOQQdw/s6tr3rUOi+zwWCzHs5C+rKnRcUFPqiecxJuuqN3LrWurb6+egF3vi3CgRcVQIO4wIDartFT0aug2V6hb7dW54tqjbIVU7pnOg69stiNhhL9GTdUb58XZeLog8cTvlkIZPdBRGJpyesjV0MznFOg4AchK1ZLKvvcLwHGVB2fDMW2WQ3R/IxlrI/jKSj4e1FFdzE9osoFSrJeYRIzxPgClIQFXbbbpavvLq8X/FoX5Rk1Y9JXBVEJzFOCUisJFw98t9sViFHaq0/g8YHmLbBjrDUYSR8gzjF266mWS7W3m9H42hF6k6HhfPbAAbqFIYQnEDmvuQGgLfQA+tc5NNHXT7ra2RQzVi9twzOy8SSpnqMapeqyna1jhCHlXbtaLDjkvKsWCo0HMoQnROi5k0eD+Goim/xWRaG74x7pl+SgIxsRiu+OIfjdyVr/9HZS9xjKQlHZTWKHJSHdAWatA+L2o/zPuJ4Mkj3PAn/feGTHcL33ZpKlrFknMXIZWFbSBBZ5Vl2/vIMKyZDRWNroAHsD2gNywj3BeY9l8ZJCHOiof1ESD2Nqouzoum6xU3BgBVcIAJOVzkwZfVElDGR1uA4q85bxdskPsJFNPRCKRf9a+PxNWxG8VSmMwUEELQb9cYo+LXRYEl9MqvRGRvpVqU7b8DmFLP+70fUbGo1tAkmV6Jc5L+FTeJl0yCHF7F4e3tTxZu4eAC6e6RR2Ei3JQuCX9+W++B7W5RC3RmjTZG+ZGapnoZtRbCthQjtAfPTOkR6CyELyzeVn7jK6Lg1UiY5afKbNILdfO/nW3SzkbJiVLCwjZtU4yQjYo8PQ88hNN25N4i43WJ4ICMe9lve8MQcdOkU96VEur/eCNHmgngNw+1w+xWeu+fUCcJlveqp8zyvw0+4CwUfnhG/y25JwaNL/2jn9yIdNVD3NAn+hy0ScUxF01kBnm8PSkJPFaz/8aQAAZtzs4LEN0t4Seba4148ne+Gs/nR7PE657t9xRePWTNKhSpzWVRNQO7M+JpR+EM8dCwgOcfZxaI8R433TjOpHSQdvfYo46e7PAW0dtma+AO8R/oOF6afnYg+ZuiPbUncaeB8q/Re3IUte9y9E65e6UMTdhT7nqUOU8RM3hoPCXLWrDTtp9tDjheJrm1sC8WUqJ6PCGumX9q5JvI6SaQVc0zaPDm6fkwz+EOLEAjTJA6RlsV5THuB9qje1aUWUzY9vzpZfPojXOLS+Gehg7ANNCL4A85VauBSYybbLL8aYbo39gVGqJAnYhGOktzVfpOmOeDfQkLelkVFDdISesMA2L80bADVf/AU88zPH6WirtuQe/2ABuLlLP3qZNZE8nIbtyEpWhgmDNqNNJWEOgKocp+P5tzsD+C6xj5aGbBB9Qt8FTGlqqGyG5piCragqmZl20foiZLjXxLGMe+/M2AbwN8l6jU1KWT9OJtqo08tc+segnCcWVZr7+pehQPX9H6l8Bq0CQveYbBqRv3VNn3PSVo0oG02CEzRmgI4egKkzDDVwAZ/6BByUBVqTTKXhkh+geeJKYnLUhXiYP/gI6+PRcyUYjHcdDl5FFOcCaIHeCnUQqeYvTx/3E46IJyZnS2p3BDIIO2Jy1ALME5DXhwSt2xm3lfLf2/ZRguM1DuRQXSnsfZbxoB+bJJRFY4MBHFHxFrxcXSL14G1zDO2A8kxIZdGPhYKbYng9URNvJ5FdUEOnslYGnhQounzhlliDrCrjEy3vxcF1WB9tuKQgljrGbi7iVsHTtLGQVClnEowhAphBovvrro5ajXdD6tO+VIUaaEScWDz4vMKdOXdhtJMmYvFKj31BFQQvAuJM+CqNxeSUjOCYt3jc0qPZCFLCcoLtnM4g6H9PRuQ/HuBHTPapFAvhR+kpxGzUXrCqHeS6WrX86+ykBwF14gms/hhSyy84R+khOxRVumM4tEjub0wxjKKiZdku8alL5mwPOLd0VexcORp6HxVkSKTYJGjaK2EWpZQNOqsMaiYGy24f6nIwEU0pOMjweAih8mt06czjVdbtyz6Vvd5QKgJkoWdrsXgE4zASBAb+Sv0R6e1bXUtu2jdH8CeyzRO1ByUtQZmWWerBZzG040FuzEtQIhPp9koqljTGA/3ye7HHO0Levg7xLXWYOXWkqaWEEC+x6Ried6niSYuu5OT7vMANIYMWdIDD72XW0WOME7wunCjnkemij0aboopPJVAeMKbxPOMHqC4QyDf97WG7YHoHqSEdiQUqX7JCTUx7BUZ7de62ovtPhltWqF1pe93HGHs8dUxJkQua5ZfRYCtkCD7M440s9jjEqBUYlUldqw3dpnOHAC4TphEUiR5w3ouGgVjGiyCBSrO7ypwaLO+qtn+WdSbc9xkTJ2YnPgJlAswrqDSCC0kiya5ROYnZD5cEZuc+v/yxKQZW0tZSSlAoHx0bnRCWTvii+CtyJylMCRMN1yU5Ejy2STbGKLgOx29ANLHeBY0O7OMjC56iFIlfIxEyjrwd6ZZcwt3DpB0t+RJ3W4eY5RYcl5deQnbUztP/EK87Yl0Nkf6lR8HQi0k3e+cRd6Fln+HQstMatYFLljUoWxe3NffCI2MhslWI9hCX6UYLYOUEzHMUnO82HTqGy8DVoLELkwdQ2AwYTnxZVdLHS+H6J6afkG20d1xTOyC9u9cozu6eNWYq0Xvf8dhBrLslQUiruS+Yt/SM9B1dRIHJRvK+67Jhr2dSsAmIJgs3d4UnZ9uCtH/FiMKibP9T9u9vhHaWbM4JtoJrcTtkGNDiauX4T3dfxx6tEGc9rlAfyxVcWHSA5/fWCvpyJdjl+/+e5cu9xFLpaTW4GaP+dyoNAqKFNauB2fDwGGtzpL/gfEoWBYtk+0zVBdl8d71yKQ0HAKtgfbi7SUkcVdD/K5jxjRDsIOC46aqfGcYEvQ2/1/feN5u/gpa1M8bc4hEtLz2zxbkbZS2K/gHN8rLvW3O1j/UPI/iuQGTSXAv1tdttg59Zxa6UUEVV59zu3ePMNo3L8HiJTOmvEcLuksRU75duWdW4f7Lt581mHtaM1dNucuRJrot+zm9dCUzuODIWQDXG3d0zWoLKtUq9ABYdXMTTA1P3eK7uJTYApRJKarvdfbRHDaxCNOzvCy9kal6rGUMECoINXkoDKglPMDwtCKHKJsDIWN6n26VSMBiAh4/RtC/NJrqsmiQeEQD4Bc4tDauGe+Brh0JSliM2pRbifXlrN32f15dPayzEvyIM4NqmXrOdIJbgAINJH08r1MszWYIkf/1lIm1JTSZpvF7Pc/hK2Jo5f9I+Vg2DsAVuLktM9II3d4xnb+EIy4cJUxtR1m53sitm6LVAr5CoHYDIGEVsX/a2L8whPx0nMnZ/IvbGLVBBhHwDq5C9soHRjVVXqlQu37ue+M8tgCLu05oGqDZjloyuLdaB1zTco1j+Dt4qYUibUfERZxIajZ1Yzuc9yqhExRXFmx1/E6u0Rjmk4JQsPEtN6LirYf3AVet/+vb30Dl3rASEUVZiIxReegqeRViarKp1ObTaCiBGYxeW0tJr8c3kmWI4eZ8JMkX3QXa+Qx0zq4/+0aAA2sTwNpsmY+mpFytxWA8d7zdjJsdqcMqrs1MQ7jhKFxl2WXX7DfzoQ3EK+Q0oijoXb7rg8YNTTY2C5Osb8uuWgo3oG90QVAttvDOX2s6wkJ5JmAnJBVjON3b2khPmKMncGa2YIJXFIbttbDrPkJpLehxMNGaZzCMlI8G/9hmqefUgNtT25nNPSdCmM+KRyjzIYcw85oVzLQcCHztAiHHBOA8NgVA5cL8fVhf5ldwiBfH5fLrUOeSykqivEJ6/l+x6DO5K9hhPIM5VYiei3JIBPX+L81yjgMBRm9ZFWBQy29xiV8Bmgxa8qJw2vmQ+WJLjxszt+1ZcG7dr18QfD9S/K4wbXWKJdx3v1/xt7z02S4hbapG+li7TxSt0/DYBD/374kHmhn1E0yCZKeDCwzKAjXW5HT6iQfobNDl7jgdhKe+8QCw+Trc3qRcgzJd6tUlUszRTMpGqD9tsnt2qCURC6pg95fn5wTyZ3cFkTk/mYrIztLDae2l9qN6fyo9twU8NiJZ9YIHble7jmgu1p9DJ793pZYUPhifpVm78WwNeVrdxUxPM5W1ZfvV5iw+e3PNXatsQoQGvtOQQopkxY/ciJrdHZtv9Qrv4o/hF+PhtQbcoV0HbWplD55fOEJcwUG+/GDYp7jM6VkQlx3hFJBr5d/gxFFBRV7yumoaCzOkhhbd+6ttsxie5tFxNkzeXnW/5oXaRY7nHtc7NYE9pcEW6eaY9IXVcyWAhZar2fI9gx+SYXrl6biV1tZY7grtM9s4ZIEKHfP6TM/JVY3n2J3wqETifAaPwsvyWG8u2I5zLfzq57wumpvjR+H3EjnpQ1GzPiinmE93qFie5Jemx1Pk1ZnJiUW3s2bk3lOQItkmeTFtn2h6EI76/Uj05bgktPq3IzKn58xUID9qjtULUZ7YiyUPjW1H5g9SIL7VJYcRzGCSXou3ddHX4/rdSkXfNBvy2oZKUFKACvrLj2u3IX9lhmNXaVBuPP6Zgqe+/lpCI7pfD8KWVEXz2EIm9GoRMi/XzpBOiC2Z/wdF0/uIVC60QABItTfG8Pi/nIq2wo7+b4+ugw1E5b5pAW4wnTcAD3As19JkzbnUzsndUuhYN4fu6DfT/y4YrhlAMKNwyo2e1axz4DFVGRcLSW/6HDbrHmulgRSW/couczSir9Y6hpiAC0PZEHqEzFFOj2cM7E0Bc+TVw88z5CmJmBjPWupzdVU1vCfwRJgHdhyPGoc5sg41XAM4aYbz5gatzvKouAIc9S4Kgmj8bzRbKb7vuNnNP3phcoGakJlPcubeveuRXJ4oboLjeBzhaFDKvqQabWODhtMsJIx+oDLO8Y/FX9isEeYs+CyX9kiY/i9bOWyKiNZSXd7JbN4QIA8umgPeKQjuPI+JvlGMOnlpMKjkIlcIHg8LCS/5yerGJZ0pgM1Udqp08m6Egvd0syUhBg0TT8pzVs9SBpRo87zgkfXHOgpeP1U+lu/Wx0LrMXG3bnqqNhdgprYhqyRVMb2UYpB+lXUo6fFJePZCJu+4KZi1bNpNGZUJzFmAlVO0T4o4PYz38ZYEzjTtNwpTDx7z2E5Y/Oj7d3GXuWul1uDxzg0euzAuoCF9Ew+/uzIOQPyUvnuAPqOz3i/enwODmC7ZgV95fkkbxPwbT9r7TUWr0N5fKTKwEemmURKetCAMzGX+6WPN1Zg2iUoK3hDCLjT2uYAYHSQEwPGK0od8XP63ISo7m0/NAGSZhWLVC1tVfedzRmLXtNERqmkaLJyoW8inELEIK98eOwmzWzRdqwVxm74JBqPUrpQT92gr8xVpMPEKK0FfGUNiVwWqSo5Itpb2AY/75V5StpJYx5/kOQkRZWeebYS9kDFBsErmWmau3lUtbx6K5wCo+26HrFbb975yfjVZC2uzwSHvv30ZBGV7hCIW7sQgXbmHpPKL3zqXWqP8TIvNGTCaU+LmLIVhrkhYFLt9wPSU5ql5jDnbeSTB0Nw/AU1MYRUSQSkJv3wApbwYxfNfR4/CIlm6WNG2NAwIkPP3BV1GuYxnNPiJmV4KO6etVkHBcRRrYfRPJbQLW6Yfxym0j71bN6/JHYnSN9ZWdHYhl4ELfGTLj8Ows5S3cjLe0vcpNg2ctkn3kAlsH/fiY/gdSuRHR480QkGPrOFqPF/fwtPuBJqXxdwJH846fIp6DsaE2jX/7DWwkDwTOvC0rOy3On6aoV6rtH03xYEtT6YqWiJ1U8Q5AyKG3m517JxF41DmCgZvwS9JSwu54/rYCP8SF3GV2O2qVsYslZ/fo0g0i3eKJ4PIY7M5KQXuAXFTjkqtpbk/cK9PNNdjBtLnbwn+hckC8hoRGjihU/YN2YgH2i0pQ8csGl3qPl+vvPaoGC0T1XPZSJ1F0ozXu0TeuFpbnXm7Oe94XtsdWIQMNCw4tb1TjgE7cgyD+JGUfR4Ph2MjGnXMBg3dUyKo+6Igl/g0zbNK8EF0g0Lif1gA5JyspqBAOcc5H6VYA9JJuoggL4k1OxnMcO5EjlcLnt2z1WYndUuwDc4fNyQp2PtkVISZXsOfHu339B3n5R2+3tnVOsiyzt3WR/N1DybpehpTyloGSO/C5Os2+8jWDm6CS3TOsLJPu6i++HjDIp2Iv/6z3Mno/MKpz6FFTvDtxNes8ZB9DctFcWrKJWzFgT1kK4bsTL45hVouuW8ckr8f1RklBAzQizDUhBFkQqb3c44eUOqVHk+5Zs6SrM6S6tY9kXRu7IlHwV2sXFWcUnn8xQtYsGOnDvsUzb9HcHU/EMxfXXqKFJk42jMDoCTtmC7TCpabIAWx5XLEBE/jAtGdMcJ6fzr1JNj95iZajIVOqDWpgsoID9VVy88i2oQpzQiqzaBOuEeiRWi69WwT5y8U8TEKwhQH9xXSWYuB/bx3ll3p7uCQx0ZJQIaAsXtWLx5gtsNIeka8D26NsLTRh1135V8KAEhsQn8Cb7ftpL5pwwcumAXtGYzlB0yMDtcCZ+m0LdUzq5A+gJ/suCHM+2uq6/27ZTbc7cOYKhQHkOSMhbl0jj0Z/JY1ADN2brmJvIie/EMZgXGf6hj+YuqGGWUQw/qzOX6uOXlU6sMYtQdv7zd1c7yH3ubn1ILODHT8ycKsacztPpLFFneqaKLFFD9lu4BfUVTzxkxrryWlLdLgONYv1auA4eqsh/6JOl0hP69prlL6cJ0jfVLi7Q93mkafyR4cKsAKCLIF5pgIa0B2UibglQOtsJigzyp+EVA7tue1NcOCcfxBT/VQvx7se6l8GagkbooEnNBr3EWs3tnbGOBt4YDtUIvdRvQY+iXe+Az7eTT/Zm9XJNLfHxlInDLGLHh6hhuAzrjCRSGujCHzqmEZwfgJME/PBBU9oZWhSQ9xlAQmwc2RqCBbDsOq13Ji6rSKA3KEoN0LVlX0j3SLqQBKwLVtdo5JxL/qjerruSgZo/FfJfblvwBgCIaHVRTlDR4HIOAx7SzuW+xn7oJqkhL4w+3iNKiB3Mb0xAEjy3q9qHhblWdwZxMDlTgt22iTmBjOfgv1zxL6VROCryghcWYkUS0CeOxzdxounPTVQwPCKqRe2D1KuYQyMxaf4tGYegT8ENQXeFNjZUEaiD00NAac19VNate9MqzrUfd0XR4J7uJQ2UJu2vMAHndvVWuFRHn/BL6D7KbRTgud9prHNMoy5zSX74xJtwWrueVBJj8YUwzzwSaG175Z9RIzZalCjze4HSZ9570Y/WTOSGpyem/K4YlAd1NVP42ZHTI+gHyAytSYVVqeQqIafaBWwHJ+JRMfnGt6wGz8WUXH+8fQUdDXydjELtCiHdxquDeE/PN2ndnAPeH+CvBaFW7sLBIBPv0Kpl1k06IGOQFr5f72aTP+oUmZ5qynCZADYacdqbKXWbTlUi38/JPJuIEYQXr3kS7vT6NfYFQxDReGnLTgnX7XyzszuyE6YXeIe99T6HnunqVh/3LFLkxIwtvoXXQ7BLOCbZ+7lUq/SdTjZQpp3MI0taFxWR5+7CVwg/l+movq8uvwtDXJzzbnstJ8+T1YpLL364hVod7/Dnf5aeMG/FeTYO1xEApC2BpMPmNWahgVRjVf7jB3a7Wcp8m9ag2Iaclaiw8aiqBuglj7dhq2hEb/KN3XaCQygB7TO5FuXop1m8pjgdr0rHYxxK6wVIdaHNt2Jl1RhGkjS7Cf3YA6m9v4wzcTki/cEosFEeCney4seV71rqC3YLw3gLaS2R35coz8DiR8dD901NFzvdtjM+x/nhWj1aHpYHUlNaFPZ7FZUMZc1MbxtBoKpdxRGvZiQXNUH0KScXCoIZAblhM+kn0dM01TNBcJLH9GkJ6haOUBsaJsY3cfGeYfGTbLD73av28AYrlQEStCFUyLcGRBhBuaW2/YG/i2Ea/fjevm0fwYUD7MTKL2Df+QB12OHaPxccDOLlWMutJK5jW8Cq6Qzq76iZ+Ayw0rUqOORjX5W5Nr8NCH02pz0FMIvHxUE4eZGW8UflXBwsEfDkNKjXZAuCq0ZdTseKom77APhOYVtIsFh1Slehdb3kH2kVtCP1S3NOX4kjMvIIyZX1KySB9uWV6aJpJpJUVK0Qw7SFjn8YBhB+6KatcRvUVAcWQMH15JgbD7gTIaM6uwXV5ThQ2GemYZTPKBj7bCnEO6oBJQQn08ZMs513Qx+Wo5eiIEXRV0WF8k01FQbRMF2XmAcTKO1N3l9yTCm83DT4F7IMpGWpmksO9OH24l5Pxl2xiRbLqPf9RAZZx89pnP314/fZ4M10QB+SAJTnZiL1FXxR0yJjUMfJJtJh3XbvglRJzwUX7y36edT3EM28yHscmG/ny5dKIjcAZkPEhZi85C30o05ay3kgIQaHI0tULNXfWbpkGWzGJtxZWragmp5YeSGPs6LNhzWIvJPdk/tJG1LfzpUfgXicsDd68Njq32qX8NnO/tsrHQAw7k/P0JueHQABzV1ZmitF4KBTMOQVIimnckV5vZNFbY3dcok+USa+8LWzY7Tmiy8aTVuevNIk/9ahkYL6vwXeAa2x1cwFOBZWdwQ3At60cfTfWWNB5Tgbna3Uyni2bfFju6IY/V3AvAZ2YyEWSm7tkRKKx+cZ2xkWzzC6DYIu8X475CBdx8EqLQZSxW8+SXfZhOhjBRn0yk3iZd35PaAEkAQpY4pjPab/2qq5xWKBzh4t1ThaLgZ/kPoe0CkfpftzLhP4vViZZGt5yB8Z1h5RPtMrLS7W4OjkXvVMHPsryIqpccc4YmcOvL2BOdbXOdDLTJ+5yLLQuIIgY9xIURnDu/fttxdmhbxwlyM0+7egokQIYeEo/IUskqKs8FPPJnDKwMz/fiHTkUQAHKW+jWHoTjI9JaojB0512pgsAhQGcUdcdSVBnnwoa0iqQIu4rvoeYwbIHQOJl/xoeRsGIgkJabaACr/wFsfd76qfIvRHuYI29g5ObwRW4VECUgnc90NqvaeOWBE5vEXTz1zmvw27qI07i/9LrqS1ajbFK8jaR2nYSH6Q1W1JJ7pIZAtzl8ZmqcsKKTlzSWaijwtYabfFjYXExd6JleKSQ67YegJRdJkicn/zyaQALVZhdJIbhsp0FJWIwDSrm5HrlwxfX6dW+giYbBeqELWnLkoXRXggNdYOyspDyBizwyWsYA9YcBhxpsXLukDJqhqOThNdLHDxkVG02e0eQvtD51coq+knVoUjuX9tNNAq+DY83jHqqfFRkt6xpUoISs9BiQFP3B2ZYxPQnRg3E8RdJsQ5UBet9CSaKjDAwjE3YNIIRNRp0ayI6JoeeYFptfLGeEgyxNLOGFEIiiFEIl11WZQqip1e7te5mg1xFZEyizHIttkgXIeq7ELpKhAeioaRm5OosR2hnhRYhJ9M/zGpb3x91kbwhID8t/MIj5ZEDhPp1otLgixdl4mc10xFRTwJ/eizFtAV6CAjXLysmjkwVw9Xd7xHQBjwHlqhIYmjzp7vYEj0UE3m1LuK6ua0zDmTNQN4MRrtZJ9leBpjpPFajHEMtNOmj7LzPIrRqiiC6UNQ9YQFugrbUf/J6KlcFqGv+T9fIrQ+I279tQvhSO/dagMS/654kAV7jo37sGGeaeMnYzBRKJaIzts2E5FeCUxQaMrfQ/8Zca/qsTu26ehXTICFddDwEzVaYk42p3fVHZ90lGFP2qLQt/jNT9prtk07pd9G1mZrnTgsdZcYSVnogIcJTV5+VFkrzKoXZUCTm0F1Ul/Dy4+UeboE2TILrFryp+dXIjMmUZ/IDfzQGrJlc2CgZPFReoqQ0ox2Of67Lw/CVL9/Oj0pO5guuRxv8wAYh+NQKJbe43T4zkuszqVOQ05XxlAvvkWR0qgPrH4iTtTwq3NyOizez/Rn2iI5KkN2+N2o4TMIfSOHbOpA4C1aMEah09+hPL8aZ1M+mOQXC4TCb4GJu9XFwjGGmPzHmokyXTvjgFN0NIyMny9M3vpWfLSNkjAKbURbMHhe9W+KO02b/WaFmtQrqY85XcleuHLEoVuILDbg4qZ/KNXP5nXD9Y2YrOKsbrifMxZnFiu0WJAyxnSgdn6e8f8e8owYjRJyOZ1WHY5FgpwSDgUkAR0xVwauIMmR4Nu8rcKg2CBqb8ibrteRTodPVxv3sbh4FcyLwrDn+7nWMqHHxf1vJvf0PHwNuTdOv9qhMX+ksoFTHdgPjCm1KNwsvGrV7D/+nD//cGDh7KTRtzdvei8ECuDafFQI6HcfCSEBap6JwCsVxOKpPWY+gyUIYouYAb0/JdgY0lpX+PIg1FkrH2tqH+6+zhu59y8V4y5kBiJFAeTmEp8n4+veHIZ+5pjebuLlGbQOFyxW81QPYiLWlgDOditGWHVJKpsN5v9MLDD5LCQAuv8cEzvBu3SruSp/kFvyn1KvpjBTRkxab3d8A2AtVqsHtNMms4SXOQ1xcoIBXnQOXDREbmD40W7QqNwb5iIyOARDHUVjat0NuDfoAEevQnEqV6Ho2WmsVwV5x082y7zY6Rqp5MArWlzQ07SzN+NpEBvtwFzitnmn18PQLtTE77d8Z2Fd/PbtwkqBOQ6vrALgNtFfEgeJq2OLQJ1xcOQOK9ztMgaU3XISL47p8bTsVhavKG+0vWmJ97i4O1/Tkv5QdwZp9VKDo5e3D/QFWxSloqJMq9tOYn7KOKXNjecMsXCPMCYoTqgxWJ7tuYsAORSyH6HN5AS0Oy42AcEwRuZvnQbYGGMieQW4Q8RE57vjBUMpjxv6CmKC8wvRUwKOfjj5PaO5aRdfqEfvYKkVwdxAg3KFelEQERyoyIFQtgDqmpTxEu0fwoinRypGbg/BColSO1R5vJ5YqGqbYEf9J3PLLKpLPFYsUMq94uHet9JZuZO5cjBZbGEz2E4G4t+gXU5ptdBbRWcp4f4/K/Bhbls8vkBe5zpU3/Vt84NbDLPCzFw9p029434aN96DScvad1/Ez2HpKVIoEKQmVH3RSGlOw4wkkwSQ19h06T37Khy3wEjxOfQ5iegqIZHojrlm2gx28U2Vv6TjmmeqMsSnFh+jHs6mpUf7DhU86rIaQHXHDDEWHq+SFxkALNdDx8ifErNr1gY00Nt1HdTzLqvRjHuVoWZ+Vmc1d4sCTgXZL5BsHRkpY5ilua1Mt9UmHBH66RkUHdlKVtf0wDls6a7uIwdMD10nl/G2acGGWIVj7FWxHJbAP8yBsEThyggUuy+RKsgVu2M1cj77SSvnzUppMMhLNC4N36hBRz10EZRDpeD5YCyhHl3qglS5gkpxgmdRlMr8zIJJ2uTulBMQT9NHkVe2oZtuW+VVsQpNeL/hph/Nyiu1oITvqjFndya9mCxLzt+m9GWD9uK62DLHaP+BOBFJHYJGxJSNjIksavxXpziKPf9nyW8IneTLH465HSYvV8lncjTEMS0pBunN/IbxkidnJA4vuvxhD07hkme5m7PWwZCVdDAgU2t7AQ4LDXlYIIZkFNjrh16oEIDssc9NK5N8bc8V+Ia67hdLNeX/8cY8ZumZMTYCWsy5jaL7UE9MnLGa0CzrydWRHh4nfpTiTkOoYQgR+GOf/MYbS5OobbUL4krmc8bOfn505y5cjiFHF7UHf4qbGLjXnvSgPWsMg1iRhn44I0nAr+fJU9miX+QADFgw8ghUzbg6rd/bFHTqg7RYL7y8Yp9x8QOYgCEV15F5dnGaLEhKvnTPH6FYscCRFpV2QEmtKFQjVsPbVEqox68KveswccGgkechAODM+q4GDnLBDAaMX+8dZV0lHg2mSlHJx+fKIyuUpOLeZONIdEBoktD64A+6djQ26HQGI1gsMJngzeyGmW9aQaxLDKDWblETd0gzHpU2Sh8ZTRfYs2M9JxwfNoYy3J2V3GRELfC7NVAgz/SXjH3YoefP6qVJFIbEixFTZdyJRHWZ1EaiftwVHXGi4CfEi5wkX09+uz+fDN9ro1wsEmHiy0aNPqkEpu8JaPqE+Bl0+RsQu4mqf3cKO/lzox+PlrehplXCICmv1YZC8JpfHc2J4n0itfG+WfANyKaE3Bj1IrjnYWTtHgNzEQo8GWpEtgEIuGBuLXlfd41c/yYiqW2+yPlWf7run1EkKgsLNgT1OreD6x2Y4wpdSr23sIKEtFzsV4wqEccBPioyeB9Ypi/nQqmjOiTHocPmL7Hxla+w/hVRyXcFWkyIpQpvm2jBLyXfX5m90aEha0uy2gRVt6nXQUxTKXhGQDsSfMCiMFIT1VGGYnkJ5OId17LNYdPAqDaaU0GntIDL25ZUPB/GIBn8d+mczCzX2luh4CZAQXoVY6sxzaT3rK0MQ86zeu1+acg/opCPOjts1J52j5rycUFSahrFx+0Lncpmd+Y7OD9lGhrup4M8IhY8t2EygUrmd6kEgmd+9dGFpc9G5k4B8d2VlkGMycv+8vdEETFxuJa+26IQepqCIsiY22p0ML3SKiOia6zGMsfKFha0plZbzUmU8+v/Ahz+ZklRyZ87bcd/+c76apNneKJAOZeXIk7S1LP3HM+YOZyWKzNZiFjovMSvkrgO5DthSB+r0r4DlVZ8khifthb/fjNTGCC0H5RPadGg+GCodqMvCOCOgDUbHrpOvBuzgfQorOTTMLgW+atxZka6TVLWZcl6XkUTCo7q20sQM14ubWtQTfu9yFqSNA3tGMMtZJh4cXWzxvf+WX1YOhR/TFnVY5ZBCA8YhQuSIGhbkq7b5WMNBcKhxXlMQJMDsg2qfrjRkdY4YuIdUwkbvO5BZ470cpsrmL6GOueEzhs2DvUFogkQIVIxTOvsfQEjK4y7cuq2KyNiRiGKE/rAdQaX2lPPV27/Lo4YAI2ehp0LP2JL+QK44t/4eJ7JuJ5HY3uJOA7fb+vTwn+tfnn8x6vjjlHDliYm11E0CnHl7GNMe8D+ImVl49CXNhnXsgdJydsptMHPNspcFevnJ2liSGgBwF95m8PsoR5cM82Eh8LZyAlz0aHQDMi6/bpHIkKYEScwV6bzFKB56TkyOxStDbjRNcfmNH/x5DSWhgOImfThRKXE4r1Kx+DioEIZdGN960qrQxFHd0aoj7ufObR5LZzHJbZ4Qbciyjgx6oRfXl3k5kvnxYiiro5OK53WMFArRP/W6f4o0dze2JPrRUB6Z2j6SNohf5T0CZo5hjEmyhkLmgnVIA//Q3bBy9cqy7Rf9lsDtGU/jUYTxwGS5825znemuYMl0Ei2ztHjn/8F1BTM36fj9KFIGh/mOFWe99Bl+s39XhnA2BqzoykXP32Po6dmBYIJVMchhYvqhu6CM8byqPrRgKnBFW6G+AHtCKPqIRPIq3EfWNAV3IgWLthE6ZAVPxornf6iKbArlkDBKxG6+Oet18QQc6kp03tOyDcOkRMJLHDlJ+krrmV+iqzNoTNWf8zlzDmn6lb/LVggRBvwtXcquHCT7vIWAWtltsxtmvCKcaWoT2FEvrMFElFn6gFfLi9xJcKrbuYxVe/Ib06k+NPcRvV6I085l28z+OoST2YNbHhqJxwEGrWcS2NnS2fcqvRgTOMztqC6/1tQaeH6s610jFA2weHeBqSprxU8vjYKQJ2n4aWGAf9s5+QU7EiwtZMp8gTuQtb1N0gvWebpFC6nioCi/J4bvXW0YxZuXNxVSwshye9OZv7yDccPlvbnipgGKhFEPZVJBHf0wGIb5BKQ4slaeHz+aee8T7r5MhGTpHJyDrvFlPzYxePPZe26rRFzvbFp65ux8OhrBsm71DGGoNj61X9V3gp3I6amGPNC1uVRhYFQ2ffrae9MBaHzx9QCxM0qO/iMeyrXAUgN8N1A3HS9VMI9T/a4JZtHtEHMRMPa8WhqdOtbOj0CiZd5Z/jrKKJVeWPeLZyjm3SSborlG+AcpAIuE0u5zMSJxKoBCy/dgtjGbK1CXnGYBS8AiPQI1Uhxdyz5L6LBkon8op3+98x+iAmuHM7ZSMhjzJM2NUVg8dQDFGpaM/hCI24lAgpO6SoRD9erNAzd0ZNW1Tz83h8kBKYpny+3zeoDtlRE6BHrQGIvpf+tHgDQeeGw69MLDGuYgAg5C61pWOg4YAUZd7s+blSMZWtvAGRGot3TiCp2IpgyruQ6pIbc+0e38k1coZagBSZePfegbV2R7K+0kJkdSx+XUx/MjriBOG0WptlZXM+6Vu6Wr6inhIsLMIzokYxz5rTa2UUOjbiFQVedzeeN0WN0W4QY45vycjpx2uBbMejrSXjWloFPuM4xeiaRv6A/1lLxOA5e6889S8Vqwx5fN0wAVrbCgBqHXUHyVUSq9sKA0Pmss6veL81q7KpAGwzi8lPKcs5tznEuxinZDHpoxJ83MYD0aTUPjoM31lpWu8WY1MwJT69/0jGArKurlYnUcb/Vi+N9GjF9MHPx2ih7khC9Hh0TfswnA36mWNhKu0J+fUDKURoNjU2hIl18DhelAtOjB3hhMlIkwWsa+d1fEEOjv2dK3nql2djaJGTtntWkNQ5cPZlVjmfXN6+5oNQM8wNgrEBb2KivP5F1r9X+OIAMwSNLvE0hZOUZ3KaKBViwGE0jniqeZAnZkMPPT7mwDtDjpYU1OoclxH6ukiTNq5FKcJyhQcmtD92W8oiUQIqxgRUDftbdmrvlYGoQrmhOxu7ohaldvj4an81K1pWaS3hMOWPle4pZ2iDvBmjv90/GQjrQlPAOAzKtWpvDCZ+61/PQgmv39SeJWhEBFQO9Bi1zTFg1hNLDKVCtpL/oQ7qDDSK1Oq7SjqibRdLTZLAWakR82vnBpjnzVGWv2ZjCjKaR9CSfu9q683GHShqKaBZDfN+QzuUVDqFmMdf47hXUKOMTepq2V4kLIDtkhvevx8ID+wlsHm8+C7HLDKfW09Y15NYctpK6WeuPKT7P0QcLvDeahyVkjXo5lFBZLhIUpRbwXc7KtQ4CA+OZIDQ382WikTvEGQzDgHuMfEpuRhR/XbDqijC+CpAyNeyFzBJNT5NBBsIIQwDjDaSIpND5uWesTJbWKOUxIhbWCm9V8t9kzImK6UwXhiTBV2ErK4vB4HtHk71/dtr3VHUXGvXjK9B63O26v++ufeVVLf4Q/RZ4od1vHqHbhEKdF5kewOjoc+gFZuOvv4L1EVku4E9yWBDLsSrQYeGBQsEAMn8WaWlbQRn1qaALsQLADKqmnhiFC+Xm3w7i+5RzX4msR+K4zSAmb1DOQIKyX0QIjnHJK+Ou1iAv6+hdP6UzHaLjYBF05aRJHQ5YqioV4TyrEl4UHmm4iYpudx2yyHPT+GIk8+QZgUkZiINQPNFIOZar1Qt/XCz3xMWTdClGH1vkS/F6igksJF9UgPfEren9bRFyHzCcbA392IdoC52hHtprSDRGPIrfmZpUZYJD28UISizuZ7kQzi+D9tOB70PzNbwgbGlgm6KXWmNIf1z5bchmbisM1H2+ccRz4HCw7jMpt0+iqx0217zrgQgd3vOkKpSFZkOGRqge78baQyk1ZjkKASH4xFldX9F3OB8N27w0ZXIp0wPYvZNOln5J8qx1qrgWa/EFE9goUabpJMtmw16btEtPYDLSMs3HouMEbahOabq0wpkgqvI0J14kwDeXpxLdvweYVvLg0U5ummVYh58LHTbrlIrWLPpVPYbMIXEMp/sobTp7uC7+HO/p14c73KIBeKIe/NwmI9c7wZKzkSet9LmC7IHLbvClAOpiKquiayfSZC+g9Ibv/S7NlV62GBm3efdK06JVDPel8UbDqK3wCfYuDCItdn7H4rKl6gTBVPNc0QFxhvTwbtjgJZFzYTHQ4eP0Ln+GRv56yPTBJL8rbPCrIVm+XmbeB+3YO14ym/abRayJJsKhXl0L+qiNRyEUjShXaCFv8F4nHExZksYq5sJs42sDQVwdH3rl3mbeaU55463TYo9rq68UM9F+ZXwfnNlN1mWvGgyMZFmWAgI46un4ySIeZr98aCAfLT9DAJGQz3yb/IEDCRHoGCuggZVYjGJ4qtdriyXkOsyDmtj1S7GW08jKhw+P09Edjrk2nBXieiUx/MS3c/vg+s9VF+xSBynk67zZ9nPlkD5oQy5XySyma3je1a/7pLPjTcqbosIFV6qmjLXY8IFyG5LOUC//m4Uv9pkZFGPCyupdWXfEh0KU6Fc3YNmsD4oEj1iFfcPIb/7Y7HKS9ZjMHS5p4nRC9hWHCa1Mdv0dnEj6aET3O5M853qacWeyp6hLsB4rhrBtJ+s3CjgN/p2CA9Eh68+of8Y2m94eg5B5RS032Zy2D1nX1NgQq2I6vkpi8aCTyI91IrXQQW1WMrDcNMfMxJxvAEyqSQDsY4tuzKrXEgapr8XA8SJ/tW2z6bL+RHG4jSOO7PtLA0taeDufVo5LE3Ge7UVuIqgfrzO5GkMJ6j4ulIDKkyz9fKBUE2Khu4OTo+mEtK/p9DfqaUviESk8V9Mv3N3pCeBN/giRZ5p+g08e3AvYhgcSzHHPsDjfRDlZEE7Jj77JQ1pzZCDSqCeQPrJMD6nTamffoQy/LmLmBYvjJ4sDMC9fmevOH1Oqo4i/KCKiUwzAM4GNvdd5sqy4AANbFKoTrCpWGvGcfEmJ8260wrTTnzB/7EOoVHwUIo5acU4zNC/ECfecKsH9EtdMjNwx7lIcBKHrHK5Hfpaqc7plaW7El2jdG0fhdCaBsnUTVzaRTzsUHDF0n32dmIlw7RLjgNVHrnaA40y6VsdIER7dnjkUWjNl/tMj1mYuuzR1Oqa5Oe6EReBC0eQBzY8fxlB1QGzdH5Uhk0XtRL3HpxCB61i11ruAd5eUYYH731Ygi0dNP/xwo4O296O4uzhfYyQJ6yWyXtWp4JYIJPyXyNtCidUs4My6hQ/H18NPo/SC90RuqqC4g99gnBPcn61uV8suzjuqSU1soGYQrKjVx9VhvTtUdCWKNtwjLotbIoigPj3Sv/GP8pz0g8zrESS45pSQyzW0TRpDvAhJqPDMrroYC+uRg7rXSgoKKHyulEcPc9Lb7tQomd+k4rOSyQ7cEAzZ8GcLaa3T1J24uC3F0fPrN6rgsi6Al4lWAd/XURGjxq4dZg2yRULSKRoG4XkLUnXy19HPVG4gmx5g5eww/tkaAaxbSQuUOwuMYElgcyX3us0om8yuGualnNUMQfF8Z10np0sKsxf2pCa8lE/9MeX/uVX7vATTpJcf6P5go/yTTAHchwO8iFIeE+tAiiTEFL9aq0TzgY0ADsMMt4Z6f6D/kSZvC8TO4S/UpZ/GdyNbpAvkrcY0nrQH1ZCa3pln6w7l/U6JSlNcl67MXoCnkjKdSA5yRpjJwSYPpH6xcdvb8N/ZFUDn7J19tivkh4zz81/ApdcGgA51wOfdTJsEcaoul0f/tenxQfPbJlh0YrtKPpiFkrtonAk3C3tjsVtuRtGU/syPtb3uDEmVPHkUuCazf+eOUtgYmyZnz7jN8h4ZEu6CY22OM2sCQSRjgxen44rkSmryM4stiUdipNEoCxW3AFZLbXfAHQfjbLG5oeFbaJggIZinveBqSoGnxFXX40yfHwTbFntpGnNjVT0elS6fxVd9GGYMLMyqL063h3JWCMF79nvkA4/1ANHOqkoCtxQradm0PU2rzrk2Wp0zN9y73nmKUHmGdPywPs549/mnx2XM1QAjZIu5wvc/P3CFgSdQPI/aW5aB8dnzbCDTWlzowZ3Wb7mItAn3wVYMw8lT36F8ySf1lqo/XtiXM9jeXu0g1BqEcnx/6DBoB4ZUckf6f+T10aNBvkuKAQ+ZX0Ew/AMYS6QJ9M9pLuBn3YKvZenxjML7k8WcN+PyBDwpPmzegGBMxrXIMMjP+RF165ZLK5ZW/ESN7XntSpinwgSW1p4olVllocYArJXAE6fTZEZcvRjUxEVZO7688tIiEouPiEmzu3QQ4Jb+JVUPLjnCdrPms+sV49QhYVfPJgQKX4d2LKaX1DZrdG1hO6tphl3CVfBJ8BAudiqea3OVtMmXPD3uTrnin/zNPZxXT4uWw/SCpk700afW2x0B8CxNWq8U/5S+uhMvG7L7PRjT0fWArxc+NcXKHBRznZjyHaUc4yWQsz+BXw7YFBT0OFhyqlfEuqagKSbj/rxYbp6scITk1TXsJHfrxJQCvgw9vf7DzzoUTfacJyZSViMV344BITzGayQMPGOAvdVyWXqGAjI9BOA1QotQ19ZdJQMwiuZa+RuhRoZxjcL1DpvB4zQ1LnP36pUHEI6Kmr1/SiqHah5s+UeZuDskPfKI4y39sbvaiHBfT66FN01eA2QB0KNyv/tGDr7288EsZI53+6ETnYZeF0VMCzEVwtXrhoeMRe0/fvJRKEYH+sT4csqQTF+W5bYGZMAFg+xsLT7ho5oydvcPLOw2/xz2J2+lMmTAdkm4qnhnmZPpCWRBVFhVe/0Q9GLX7SzPoN8b4C0FYZkg/yAp1ESPyLPycM7pWMbiQ3vT6agZcLEh9rJ26/KrX9AFipv5b7BXpa/AgyqYznCx6DKdsUPdwlnhQF+04EoXBD6YPLyyCGG4/ZjxNfGJo0bQxSL9vZ1fO0Kjmqibf2eHa59bqz8z+ujpqogwzKVfbkFMGxm0T5ldXuWRlXQzlGDam4mWqbhOyoz41FXXZE0voH5en1YeKaxAQv2P774rAteitZUqp4b8Quq5pn5p5pqM82NVjz6/OdNlhnV7d+mIzQd+Yyo6M7ehl/dplPdurO4rgw8MTgvwHGJ7veJIubhtOUymj7buyBwWIzRHTW6YiXmp57tyK2P8pXoGMGn7QYMBcTb60Cf29nt/IwqgJg84ped6/dQAJ3a79Qfvb+JrPeiAMnBMwB+JpxTt47hbtkwS1DdvDSrTzmGKIHH3dqndNjZZQCRYxcQ36AnsUkFTt97TlHtnBfaiL+6tizFRNCHOwqJEVRxtBkbDxBw/E/PUpE7AoJ+Dr+dADkMU/J94t499rL7w3A4g20FNak9VcEd3whQbWTErcG42e5o5NYkte7Ytiuwum0D3olOJxS5TbtFWWMQ8DsO1W2f4lgTdp7sSNWNNEy6whkMDB4vedtY4t1bTlUAD0DZ2SKKM9PBx6MpNxj2RIi0G2D5Cgzvev3Hhhdrc5yjrqq/kTavubVul1zmbOnCLlCwqg6xrPuBa2HtJ90/RB7urgSRxvCN6yWcHSHxnYo8rAZtcgN6JUGIhXkOcRDyFQrdb7PbUtd6IrG4f/P/V8LYsfA97Cj5puFW5adJu3FmcCikWjkdewqZPz34xsdV1fgy3DWjahI/h+yZ2NdEyuYD86gZqwZl16++iNncpf4XGv0n39FuztJNgZOLyKHRhCcSKYuze6M9pyb56RT3NroLLwPAhlMQsQL8Y2FE1+qQ8bKbi1ioOMZuuDE9xo7lDTHFXuWWOXwQBdGTA8xMQQXsXVoySfPqhhxUMaCGdvXYjOy8XUNxA7Jjrl9mlHCvO1nok166bq7NLWcQF+aqVDEAFIkkYt1INusChSHoFil4lDfIViWkJA1EzdLC7/TP1n4g0H7mUbTmIwxcdS6qUoR00+dg39504Yt0V9fV63EXQHdL63oMzUMwgjF6/p1YroXEbrFTGXm3xhPcKMh1cDn8oSK+V5qEijzH7H4a2zQaS8+558US8KEcd+TxAbOS+d5Wew1tLQ478mO9bMnXKdG+AjpKbEdNRvSqqs425T0a+J1Kj2sEL5ngIKSPP27omwuRWKN1BFbcYyUVXpDRaV/sVKJZ9GIP7uznzIVmCgCiFkqPvsjPbqWjvkGsUySPxgavoSLY+OF/ax54k9/x3fQrA98X8SqNptCEYv15zK1FXZ0X1RP63N1jDT7N5wvxN8s3ivXkHq8yL/QXFInjyBi2tv6GtyMhgdcytMLBwCirwtTFd+Z/9Tf8F1QIk69I+lO4flVBFb+6Z9PnGKX4ot9TkoggfJR9Mrn5S/ckkcrJXLed5IPZ1rScmUptv+o8cRgsZYU4YgzRmf+vOuuxPzUZrZvxTVnwmmEmJfjkCeYjPcWMKLxLrSw0XTuJ4KgOrukrUY79P+ErdvPzjMjiqVv+76w9m0sX9Lnoy8KvspnbtOybMKH5aeXxqp2IxlNV4FXg0ze7RCLpN25YxSP9ESeWnyOM5EatSkw2zaedKALL7YPEbi8+4yC2dRDUM0Aauy5gbCsJdrN/WV18vD6NemiRju3/N4Dhu6UtQqoe31UOf1lueMIJ5UycJopafpb730rBnJnS2ckcReBLqZ5HqbMIhpyI6HcEXHqy2Vk+N5a30S+aBIR9SawgXvN3dwPs6sxHxrRyc0qjBEohs7WecUUrLhGN8MpJGt/XsSU1x9J4q66xAMyI54EAF85XJJVcmt+FQ+m2RIwig9uKl1fGZrRMMnKJ4JjkOzC3korfSSlGVepP5jkqcZp9mNjtkr1RbhCbxXiNQ85PkSx8ZYlcHGyLnZ6+PIxY6Y01UBTdrouM2sSxx/TZ3mS6QAxQcADqC9tgcOKEeoVN2/5BaGlicf0BCXzuRVgdBolnR5wINYG3waZ7bus/L9yXsbHM9bLKTnLBGhFYftl+C7ym5ki/Va7FNnzHCNgxdN9AIF85L1gZ+u8+XYC0MGEnn09lHTfbYyuivTzQwPX5uA5ZGW2IlIZIKl1/MTJbJZgV6D+x//yzyMUdlsLPav4156vquVnhfuEQ4LAjKZ69h3syQQF/arhfEaNPtxEqCxryVDAsSfhHTBZbc6t9ZTeHUf6z8LbNAnz44q8q+K0zUS5gZIcqEb6zfwDJiBRtIUfO01eSDd4yvFEp2S8RCdDlKQP+W1NYgkaq37lAARfRJEwfXNyXA3Dty7SRhcYE5bi1b+zDv/wgl0Ydp5+W7f09vTlU09FNNMi9yDcX3tn09SfZolATwlu2Skf6fwIrqSuXt5UCxEAvA2RFBi3XrNLRjQuWJsVd8LxzkSFlGRUq7L1XbxekSd7cvRuEblj/C3U/SNo3fMTr+Pve6T981hoG9Mb//VFC6gUGyMWmtNyn1ZxR90c9+L8Sl67LxDAe0LsU0A3rFzv2CNf6IOPYhqDOWOilS1iDzcJcIodOPZa3Zdia0stWzPUOQkhbBUHLueNwcjw8LlT9CRNn97wpWy7D0VsSd/2dyUcCf+cosHCkjp2XanoR/ew4hwtl7nO5MJhfc855ozcBPyU6wUd0/tD6Bw3RcnSaVyELsr4gcV+HmyALLrhLFyY7iK5pqsJ/10KZ5UjF0WRIOgJlob320RZugzRS17jvrpUflWZH9zoQzB8AULaFXpVpfVyJWVWRjjYLiAva4GbsqlMEmxmt2pamwWaBmkigzEOK4kP9BNScSS5AtYe7qp+LMjKk/srXey/o+xi0Ts+f1QuME33ywfWzXLgCx3Q43VmD4Ex/M/EMYQE2T0cWfyyVlVs+aq322aN6qNTVifQEcazDfOb3seERqGC/txtI1C0+R3HU4Q35ye2E0KBLZvu5UA/kjqGll5JKA3ombtP7gZBG3pXsf35pkUrTtvfrwbol4CCSW/G/J7q4rlqmzNcfeNc8UgJD+g4pHUVbs0XI1un+loqAoge99xuJpXoPoK12+N1iqXrlUL5NhDkXMzlbZ7DbqGnL8YjERWxekCnfjFCGQOLWvE6ZiLSsHjgDQ/gYPZykuwyInTMTSlzn58fsUuGe3/iyTOuROlLqFomWVtbMRP9UhZYkOGy9wV+Y4tnLv2mmZCPQO2FtiucSeZVKikPTo74PhPwIjhcEqgTTGykma+Afoinr7viE4218eVRt7Hm8yBuxsnIPGC8RrL+wfNjV5hRFKwZRLa9k5t1MNS3LITtdK+1GVU4PaMpJL3tOKyfOKhpz6TEEY/CD+XUf7Na6ZNwORaZeFssdjLOUJ4w7kLovGRnGQvZDON1weAoVGWM79T0hoZz0yJ2M6RpLjbi3SDXsIzhNxB1c0rkDaM2ZmvxQQzHNF5On94GLY/fSQuUwQxqbCJ1qcNXqko36DJNknPwa3QcctlXYH2f/av9HX29ZDjPeEr8INuHDgI1r+XJx+BoTaMXi5xYM/1il+sJsmejsy3RVgzpviRQqyH7n0TuelIHHOAq3YqY2r12j5WIwqf9nM747BEikjvJv/BekPE6GM0aHMLZKB03yGjolTyepDbnKa82YucK6Hau2RvkUv2MTj/r0W2wvs0LFlTRq7VjexfFswIwJNTbDiy9h3dIzxyxiDFfjtXqctb1p+1q23d8xLQYw3RWSWcsWz9EMET05KVHr8sTxpD8Sfy86IdKA3RIWUJmOe6SPpj3ED/hL0f50Bb37Kf6xsyHuIipFrfJGXoEalThcMzu0MUg7zcxBF/b1Mfnd0McCQ4HM2meLp6QniC8kmphz3gRU44RVuXP60JKXzdHM3QoM6xyWyY/ehyV+CDRTBkaXDHJ4eVkAjjxcMtMmBtMwh5Hy7a15g5+rWn1mwlUUELuIV16zsTbovFJGbUm2ajZVJQ33MSKJxll6bm1XYbgBRIoFU+CjLbmAC65ovUV0ioiO89ShLt+/FoQvD9sKCnTJL8QxMplxhJKHn6crmTgZYpLXBWU24ABkn/csoFtxeKwfI8ExIlzH1GTMfQdelL5Fna+TuJRIgcmeIwFo7wt08f73zPALk1DvTTszIp38M4nqFY/BNxdQn8kf9Li3anEJJXPXPls9IdnFKVzpLQJOzHKyeVsU7ACivaXccwwdZqpuT5LB4xXs0tKOQJbry+IpsHYhWx5+CKsbHhakBRUKfEA33N6PPKyq8/InYsdZCJm+OiERbo/jyFHiqnAhFhuuF28ABcZ/uF1ggYdfH3301MtALkwh1SxyZ5A5aoy5+Tq6tsaEHLBbe4CGNO5OXLiV+3+T0d8rHr6y/zON60ZmbGtpx/nNsTY29Y8fCtuoR1m90Z191qJJMUB8mn2TNpLdql7XF0fdecAAA1sVA9nUUeNKor7rSTDfM1HHxa0rhaLh8Wf7uEDIhyqVvQcC/kMWOmVyAi5oTC2BQoVJNQS9R1AigCz6Qph3htbWgCfVUJ9/Xoqpe3cut+OOzj5YP1qNcGqeoFBJX6/u6aWRMk38MjlQMMWMJdJfuhBUt3UIn/rYp+j5WrV+xebXban0XP3Uy7d4ip3GM036daHW8CBh8uzmxzTXbTK1sQ5b4IgCU45tZq6jhvBCvIMVy4foWw2MP6EdqfbSKthM30auBVGEZnQLlr1RZov9ufnV0nJnwDLYwxzIbpBFMmovJ0EzRILXbLjzAfrU2CubLfr/qYwgcYnoyJs3f55L7fvVHECv0flxie0LsoEaj6ZE2pWBaVQkjN7FWL29FlyVk8tfL8y+Hcknkey0oZTz0TZN2N0L0jF2Tk6D3QMcrwKZ03vPuZcZ1jeFraIGVNw8HI0rna3FCfptsBzXmb9LEc2iYrjw0EyvvJ8dRsZQHw54xwQPx9aZ/dlENhESssOd8WyvjKd1X7ln1SyAXfnKyS8lKCDWFdG5ExYSszetMsvOksmCiMEDxkgcWgVSuth4lM090utsVV1fkD37rn6NDzPoKvdYcsW/zl522m+VTm49lGrPNtlVT06ao9Srm6ccnZJC6k9OvxU088AtzZaQTKifMvfZCsL9dTC2xyY4lahtJ8m4Iz3t8yp8ZiKN7pXnflUfWEDmh8jcNQxNKBxjbj8wlXxUgWKEYseKiiEMS33PpEf0SyFZqug0zdma9/jYZyfgWB+VtjgfG1hRRNI5zDzPNm6MkAWS+D2TehYjpbzapoI3KL9oPP5ZcxQLnCXk++SZvXwwBz5EYMJp/7QnMnrEWSCr6BHE7OEfJruJeTkhze5cXCMusZOb4BpDEPq1HeC5c39GUq/xSOJv/WXD5K7FMVx3hC6px12s8lJSRQsvDLDM5qivncvvgMbWwwrojGz7BNuXD7bxwEfAiIYBOy1qhCwRyWfbzGdypTORa8fp5XJ4KqFnjmfmQEgypeub1DTFHj8s0aRBhALODUjyDMy+1pzeY4TFclnp/2jvxPpr4IkGEw357rtLrWWyVbyY0klWh6k4Vb3bo9/CSYFQPkfws6m3P4IbgkIsjyhCKjJ29Mmop5TDQALLAQyWwb+vugQJl7bzPvqDW0vxIIaiNLpKX4pa8LyrXgkEF87/rwqNjJoeRxkCw05gux7ocSomfqgdnVLr3d1TByp9zAcATb58RTrTWyLWHBK6NVSGkBzH4VjwCzRngcHSXz1ySNrPMO6/1qinqpLzHDbE+mWoGVDSfcH0XQFuJi+YOs784HIdAb7H8PwYha/4MDCcslkBZ2VibLIybEIjM7Nj+3/MTONMcRClTx2JjRdN4aYmSbmj/qgJixr5F2tvvi0O7zIxVODYjPwfz03oqawfZlq92FGtZoxrbWnLPO+TPC/bcqAvM7W83XoI8C2XzHrKW0/wK3wP+4m8Zt5n3DP5myKtGj/tuVKsQT9Vd26RqW6oGSUeGYvTKSjD3jvWhVKH0fICebIqga1rmNXKooMe/qxWAs5nui2byV0U0HHy1v+jKwxmhXaQs98CUoiCBYJTCsC2oZSWoGcyBLtjatZ8O3cLQOlJas5tarljYbtqUNzkOcNh80GoG3IS79JIpfT6GCgNEcq7efjuDnTrXzIY7bLb8lYACAAGluUiSLw0WZmzHpu+uAsRlWlhj0zyX2PBQH8A8iKx1wkyPb1nGpabONhqFAa/WU9P0Akr93p5Bd0pYTGk4XXqjfS7VX0ZkpeJMna1yxUYPdiSWjbFt4ltaUNABL4YrgPIVjOwWE+jP4xQQczuf7SL8jrZYZjtugYm9kMyQhY2keH5N0piiVFchgzVck+4LdhEvfBrfVa24BXuYdmVS9rfVL+GP5adOS7sAV2LKKUX1lc0j6IvSD7sgXxmUdt6O2O5qnADBA5xHtwlPl4NFEYK72cFe0hhOlfaH5/fnsRjgFR0Dic8zhxVvaNPhRqGDsJucwUNz+VCm+9w2QqtsE8P38IX+8KiO565d/b5FNvSyu5uQxZNrbfY8/Jk8hUgZLdRz+7DJ2JN8Ztk1FvlgZDlmDmjJ07DMfxr7Lf+MVlDpq17DqtUyaNZyetUQ0BC/Wmt9t1Si6djeJAoHp464RLyD2LKRn0KAaH1mCKMPN5a+bKjoZiwIBbDqMoIqRtRbfUDOmwJMTcDUZrMeiCCmhZVsd79XMubIjmXyeO2nevVt/JvwvXrPvkfurQoZgLQy3/5cKRjozeySBYU9mj5tGfPGkAxQaTAoT2kX/HrYfF6PjnNkL+t60KrIoowTM/WFRAJc5AZHEoZTSTTQg2muyCOjTIPRjW8qPk84XQTSCSKbaE1quwMMEGdhu7PZo4vU5EXfsBOeYmUVefmhBXKFv3Jh09nDK7jv12ahYixx1E0FG0Sq4+P2YR8z2mrEQvKYddUX7f5jAQo9Sja6+zIIl+weSIwFafhENe0yIJ+83N0M2lfmZu1IDspoWRFnn2XieehFbkklqTMujz+P/nO/DuE8ODOAdlXfgTlrxV54+bXXYc/jrV4PaQRyGvODuiYDTcNT08PsuaQ+aIp9Io6PXicYMSJ/NeXNUzwbe6GMF5jL5kES8tZx+/Z8nRMwDbmXg2+CWXoIewN2ZIUtKftZXJ4yXkX6/towYJgBtwqxcfaHFTHbSwvELVNQ6vXyNG7r+27F9XDoBOmjFoFmEw44pODzqx6MpJ6LNochvO8fmRerQOsYGA3CnjtwkLEC13C/8TjXexooD9gBghpdmvc0Zfhqlcs4fzzUomu6b6oa1ohkkgk9OhCYcZwybxmiKp8NVUYNBZ2/WLEUVBGroEiptCdfds8ZvbU+XIUWgvcM2RLVMvthAnND1a5QraXnT+w3AKlkd/PHcaNOe0J1zN1mXAGYNtrQyjTEsMv1P08oY/sODVhhFnxN6QHHN1UFU0pjt/uyO99r3yMYlow5x9yGa/4lXEm2WVVR6hK1u/wf6BfsExk7DHHsRLg3HjWMRRIEDf4HbyAoZ2jhv8Uf8MWFv5VI+UwFdi2wQsolR/rmKmmLvA4orfbN8bb7PVY0IX6jvs3CcZ7rwJMIufpZGzn0P0StMaloIjsZCiCsgCxZbDI0ocEpF2x3qaWFpR29k7KWgLAp+kendspCc747Fawl/yLnWkpJkzoLP0aGvNiQ8dPxW7gAIn6tPdr9En32XlzPScjnvebS+qsqEBBm4EBrjYEvm3PhNVhihHCw2rvVo+ScxQSZu52oveLKJaOj0S9Z3GqxNokpcIvMSXV2xHgJDOmmg+dc5L9AU7ORDjZ92m5MW7FpDpFacJ6b+/c18xdn9sBQUkWMxbwFuH0J06rqrxhCvDuz7s/MBuFQJWzgMJ1Ky4dvBbRUrhgaVfTftKM7oXGrhV4iwJcSMxEOLUQAIJ7aFF/YDCzBisYozs2JkYo61vD06ERiSTgygd00JjWdUdVHvYjMX0Cx3OYkg5w440WTGhv24DYaURsL3he7UnIxLYOlbacejHqB/jdCVSsmAb/LcwLHF7X4+Wo+Gkz3qap2YV1hzlFbaua+H7hT3FGiFNljKfwiEa7XCz7gMRKroviZWPAAjXpoAYLH9ZuEWAPHtcPUfaCdeH4lIo9rU+uM0GlqJa8mMzGLtqJMMlbiputPHu9wDMxAhYO5PQqE2aIlrRK9yrghOttXaka1DCf/hdQty160269qpGQIS0pJbMJ1evB1TDgJCT2x1IXZvCm0zj16q9jHgFI9+ItE+tqwLqa2HsTwQVTQZmyJ89XLwxXLpfXs3BHGObqxkszzMdVbNh3wTYZE1oy5XIdrRMU7AtO1JJk4cJORZpgGMqtbagdQ9royfC94OaMz0HgguaqfpxW+4ELyeQ7ZiNigD7oNtkyZt48Iuh3s9hu2MLYHHOYpdzw0wH/lXKSho6CGzDDPFBCd6+5+c60CfpGCa9kNgXwm4nTSbAnJhzn5Xrlumhy1Swf3uDkssxrdz/3Q4TwAxdmqXcIu6ji7NX6s7WqBc9kzKzlxKN1HQ2W5oFD75O+x/9y7CD6EH1g+kFDTKX11WAySIylaVWboT/PmMrbkLreAO2DoWlmhMjeLfrZvz8G8bpDDNIgvnaz9aq8Ajn2ALFTEIcPmd5N5tBSr92PLWpYAxg2oqHRIO/2ifzEXceIu5be6ugNHtp1jbd2VYd0jjjbYzXV4fS8kmrsrhIKAtXpV87eBV2xgUFvZsQSvPd6yAuVmwAARlTTs2Q/r9qmu6smp+xdty4rJHtcJ6iNpPGkkHOg27gKi4aYZt9Qmpl2PJkE4XAvpbINQdLdkSqysfIAvQJ7MjqXLvCfE5EhnagxIE0B4xl2igUKmy9Si7oWrySW1teueidV3FDfcdFXpth82FHXiiUcE0GkZS0Obf/L1/ZA2PO63cl7Zvyn0QQ3EApsTHQeLwq/rqXJDNYmgYFsKvwJtdZPVwsSitHw8xPz2RSn61ytU2/oitHcaVm6u39RysviOaF86t8NEueRMB/Zn9L6DmfYUMzxxoixlBlT1zxtihmTXoEHF6DbH1q1Ui/yByA8C/Q1hGfTwfAAgYE1z9uuZKHqaKAyjzCuHdaMlSfQ9WvjWhgkB++3sPK1a67Hc9JJb6I8+9PZuNtU+8hpSw/ikHsUUqyvs89E5p33TvV4GJS/Lphvnm2/os1ahVSEJuxd0dMOFilMQtAjqit+Azn6nln8rXKFDgBsAuXKiuiCTA3/DaaW49pmhb5hCY2lKMnSZcmbBqOMyOpp6KO2RAGfaONlkNcYjJGzmlOatciScIdhTr9y6rvt1w2rHWbUFP17zRXVM7I23b1Z9vpUZz38cjtpz8IlQ8Zq50baiqTMj8WvIyeOVzyGfh00p9cn+DTb+rImOOcExT+J/7pdjOivNXtsQjN1vyoyjzTElzAt7k96Dt3dFwuTg8jriPRyuuG3BwdZifQBw9I4Ta86ikkr2wBY9MpanL6ZhIOug+Vm+qRt+/uNjWZg+T4lcKBydEHY0/R5kT2i1zj5jC6lSzcvZd+Zs4OkPm5UFGGwQ9JSahl942sSCTPIhPTMWHonZMADd2EmVaCVRx+Gn2eI99aDT0sIv/M7lzEb8G7nMjMSvyO8dqfOg+XQUcVnxb5QSSEdV0NYB63uG0snsUCRzLY8K+oMDZZ2yauehb7DB0lAy4vaxA8zUii3+DM9I15lxrCu+tmA63zYRmL9KBizTrKdLSk8+ZV1IJvdEIGiwIq2ocI7eXhYNp891uxKuWDeKc0aTSEzlmrskNyH3cBF9eOFimKxzy3vy0oVnqg4lY7F+NMBmLktfrVEJEbB5aWyu4SiMTFChyuEdcG1r5SzemKJOEGq/7cRndpO43Xsk4GhZ6CwDXqul0FCh2TJ/7YZksNWZGzHqKA1yD/NAYLyeAuKLKxLPpYkRI2qR8SlT8GnfcPb7mC/AUWhND2tBtJg45RwNVZHo2jsb6/XRkkw+qGN2sRrXmnMdf2cEQZ/n46cnLtP5tDpycaAyiahFjSOkswhQyA2E4DoP/VZC8rvTuq3H3GipfCbGoYoVdKYOhgutDXeGqpZFJ4WNaqnvoxSA1b0LVwXi/G3Ag13qzXYYHypTol/Nu1TmDAGxtEyMtzXujg1VoerWzeevQFSc0x8wviNUh3uGRkI/GrTXtvgxSsFQXF0Rqdm8I1JWwdg9KtnfGeurBZD1Mwue9dvAV+Pb1uwFLnt2Fkn5EjB/YQjJxSyNruT5jaLxZ3ftH0eXFe5x1DgTY1CZ3hCy6a1G6Ps3abX+n2IOWweplcq++QEKA/QjDi7nz10jalh8vV5H3YRaYhadK+CbZExocmjfdC4sqgpBVzc+iYvGDELWOdnvRZuJqZwBDKX+H6nYJXDGu4yo2veBoVsxyBxN48kXwujvfYm4RXA/GZItBxa0J9dvE2t3m82BAROFfmdcJEhcbe5hygPJZ6rZ6O8LNBuAR5NTLP4V+cBMj+5VFvdSfxLc53iQ4OCjAgsA9Ngr5YCMVIIboIWaGHGofyFUT1kGseOzWw+9JmlDsXOG8WYqHgaLVtNuInp/USt45EuB9mk+3tlQezLOAhsTOH6hvqt+PmnLHeUzyCJJDWyBjE0bkQ1Ey1Vx9dc5+ipHtBUjVXnupDUDUpBC/qSvPHuqm5ZSjCpGi3oIrZLYG8tgS2jScojEd0DsMzTv/PkEDSDxIFvl72w3ncfD0K8QyihwbZI1mAfNNTz9glaor/pm6Nl40cttCKnVz6HlXP+Uve044oYL4U17YzILPT588t1fbcXBhOHUIuxnBLeLNvsVIe/3ODio+5siqjYzwbeFmhFfRn826H/0mkCBpo4dQVbtrwOYL9VuQFpOXFN9ZhYGOMphs3kmBcSEBPFJuwh7opU0bfE43kkhSmHPzFvcM+NxSo1JlDbl3aiDngkDiIe7/7QjJSQWBigUWLnS6NSvsmtLcb0yYkbWLSO3XHGfdLznVKxQ2EVZjr3eQWH833peuc2aOhod1VVpY3nHSHh3VMsVb5mkyFW6L18NyQhwgArTOg2mFZr13rBTsKMZ8oCcfIhydvr7606a/hsvitvf/YBct+BYrkzSEbQrQ4jSaUm2/rbbwon7IgT4B5sQNWzYZDvFg0p72rNkybZpCkWi6HPhM6Im3WBssdrFzbTdXO3/Xv+TQB5zJ5ADyJGz41WtzX9qXyWsKbVkBVELfSMbtBkKBRWXI1llbbnsacFT1j1omvPgOzbtrkFs1pfrhy8XM6AMuTOrxbA6NU2yslxyCZ7Qos9LHd4Uf+KD9BC9ANFOa0lfK/uj+bb2RaAtvnbV9Axl/KeseH6ZugOM47Y+S1dUE7dz6tE8w07m+LulXFYC76iOFrhj3cAjJvjIY7NCcID+PUkHEV/mL/YxhzTs+dQxbTj53nMAXKL9FshiZBAnKbwvVVvvVK05rHaDHlRevosBjh2tCk4boCFoYkmDUJ1kLDip2O/nmTWE1aRS7bZs8fAsPVAFCV4bOMvGNyV9s1wJcgLugiDgqDtZ53h0LEthnTmbftsOreEAaCJa6xTC2i86THqSbU8lpwrpQBSx7O9NawUhu60cZJBZvCIyZiWcVmes3OrelwbCxzUhRR7TjeKZa++jcWLdaJ0hbtbzwKFeS69BRkoklyOtPNPOAR6IvcTJbPSxgOzTgq0mUXivGFzJQnf/vHe/sYzhGjTXIJuSQ86S3kRjs2pDdnaQAFrf6G3tcO9dFIdIG/9bNjUvD3L/TLKkPRr1qZVqJl527YSVEUbIXdpDI/5mVbYF5+YJ0CRGY8mToc9WgOQBaunM9TFa3yHHOaFjARj9STPQnjImPKMln4DGecg1Ki7WzrNSQ//mVT8n6BuTOYq7TKAWBeOvJFvE0HGBOZoRykk8z/vMjnw8camibw5Ho2km/Mjvpixxdc96sDmym21JBgrUVNJqG625aRm2wd5xNLrn98mabSi/Cd96nHy/POWcaZGyV7NxbYdRRhHIz3/7U5Vfdexov7jW8SzbKRI8l6ttYWLaZEcg7Ik5Xdf2LTS5aaxoFKI0q4QEBsCOqVvybc1fha07NqoGgATmgOoBZAp0zeMFnnv0U9+ebLGWCGcqnYk2+LjyR8MfHyt6uWTdBz5EB3KnT6yaNxGIKzCQJk7tD8fdnGPEtxZ5vB3Qkcane1hpoKHHbmpayvws2Ac2G7VORxjJmTJhRlaaoV4pBCTPsDaoAkBpnSuPN+6XUkHaY1L17ozbEJo5LfMfEPa+0pGX0ZCHrrkvbhEj0opBt/nC61foARsS8TQHHca8G6V6gHR9FY3tVaS5xRZ9y8WpOPR5ljeJRftnbCiqSHxHvej7s2RPecMLqwQ79kFsK9B4T9+Z53h1f9W0HMxV10zPbj9zsBMLxzS0HqL5D+dECQR9cy2NQZUgqGRicccXVfZdZZIYAZHQss/ofuDSippCg1PxthhDP5rxGfA33wuOAG/VttQ0lv7kCrCEGnKpEMOFFwinPxSwn70rCuU4322mEW3Py6WuXUkI2Uxa5MmHTNBns/MPQUWJpKr+IuKFXeVHnyvzRSDDmVi1guYmeWZoThDKxPDLCuOzUFKwrNScj74Bk68DUriZOYDddQGpjbGRMA8+LeYiivwu0DG89tqMmwdzq1dI2L8mf0jUqJB5cNkC9E1loijKwilAF1LXTCD6nSRev0eifTXkcuv8X+IkVEGwKqJr1Z+QmuIti8g1sT89muQuqdvmqSYaVuJtMCa9WoTFOGUAhwN/FX/bob4z6t6/YIjyafdzZmgnV/Mynh5JAuxGr6OJoQQGi3q9qXCIRVLBCE3I3YyZkFncFhkR2Q+6aKuJNa24+XXkkQiocl13MyrWUqVytK48NXjfX0kpEh1hwePARr1MpcAN6djwP78pOJ0vCK1KDIlNIoR9DDaHiZbRgq+jxKVWrUCyJtbX8shuZk1lzdIrkkVESEcWSHrAkJFQpAhGxMdN1qO9LNTr8GAu31PrW0+yJhb01D58hPn4shpCWXI3WbhS8R6dQ3YolC+joyDmwBA2QVr+cNAgtZvwshBbnbiyj+3FvApVvwL6DT5sGKO1EXL9Q5NXwJ7iy+Ur6gJklURyj0FJN+ecC+NDXM8tpPetLCqcK2TFS5IGlU87AQ2iMoaSEYX8b2megGsF5Zygrq0GzYCEB0AexruwsgDmPv6A2fvarGpaBfVdHSFcPPxBw7o8I6JT4OyYvQhwzgGNGM2z61uurWh/cGM9eX/6+WZyLakB+COkDpP0ek+t65cqU6cJVFkBLaSyniBOcc92LbsojkyW/LxG9gKmiwGaNk9GJ3bRYFi0qBirxg9ytvIZC5VSo+edlWHxeNZzQcXSab8wdyeyJY7O4meONYxfKYFpF1Imp6jR+g0chZ8HTYMbeufkY5NV/sb1BWnVWC0EAukmDgE+0gcRoRjfvJRzQrGcLKVaxPRX2nzt63T0G2CnUiZxZS34Lpdywz5fwFWUdPX3Gdfbx58GVm00/JME2/4Urkt+lic4d2eB8dc0ZtiChPo6L95OOSVYlAHfAAqXVA9Cz2fvVrVay4SkKY01KNQbQnEuivW/nNJGcGlCWY5E82yifS+sazz2ye5pM112tvPfUQj5erqFVQG3/VHuzT+xWOgLLMNbkSsYvLWHnT+7tXRb7UJP0K3IikhQ5GIoKbFqyYx9ssf+/+suOkH2biTW1bD2RQX2DtwDEsElheQdNYerrWunLJj8TGYWL5arWgK4B9gjFfDse+ipT71a7MmrpvWox50FJSZ+F82QrzVgv8Wi7wqnVyWdcuHA0fKn1O2bocHfAw2YJOJKsMzwRZN6xhvuGdnZsZqdQx7IyrjnW/ERsZjVmEXcCobsqH+jbdLCn7lV0Bthh61qOCaDO7vJU8ov66o8W72/AJLaRpFZsmUh/LMcx/j+QpOv34+oRpZUila1fArfXGjaNyvKoosCuapKJd1xYWtRsqVZw026dn9kbaPKCBkZ3r1VAO9cUihAfkIAW2EF7+H2CumGcvod+ypM9IKLFYZF/PmTorr1YuGX116Fe0FWZa3AxZmyrtHicYGhW8XK5f9nAdto7WKIk8HVZ4N0eplB2qEmcbSZRjQ3cedNO65CF+6VGwMLbboGutEbIKkukdNtvZV3+35c1XwxHbgjIhN8UBAddhks6gYEy0BauFvwQarTMrsy6AhHqgbojdWhZaKH67peaP9gJIAQh/4sRKP0ntFNy8hkllfKzA729YCXNeCFEryXZQ+AChr8Vm2AqVEZruhOjCNQLw46b6XLuLIBGPQC3JOSdK8tfc+6YDfKCU69H1ssna6bNZnAgH4aqcwd95OMRQ4djnNHG9e2tEThdabv6RSHjkxaSSpxpEOB8IHvVJeRMBmt3D4W7mY0psFQH7iYxPgsN6s+yR5zF7B82ictAEIpdr8OetsQuOeAVj72MsrdDhiq5J2YPHbQkZF+c1aAwhNkqbC4RUklcKtm0bue+CG2tTgSMoxGdlPDf0gA1W+6q7P9VrPk5ma7xH8Mu4CZJALLAHZH1E1wyGziQ9BoGCHSjgcKcGdFSAc+Hw/HLfaJcFkYde1sp/5PmY+txY4YKcXAJMezIuOIw53Cn+i2yApeaUfoTtIeFXJvhmmP2abEQzxuvBAlVK7UK/r/m5OrIb56eL8aN/d3vzPt8BEPmuQMXriKuIAssCaYFQ5ocxwp5H5p4qH8s8ZHxqNKNidi6tV/9VGV+OJUedv6ptzdhG28ufjSkNIeQpn/0aQ4Rqqi4Lq1z3PpFrGxkyjB6jMyRS2XPUCYTbknDXUfaWNWUjIE1tl4mCxw/aX5wpFZod+Igd1HzNWJBvjR98p7jOoHe5jgJLrv691vZPcxMVBuQl0YUdlB9O9vRZCIFzmwx8rkuAwkraNuFvWAPGNzBZaoYVouA4Dp68Oo1FHs5ppBqEfatuTyfb3tzJMxgJT+4j9nOpJFRiqS3h0JTAVd9pRI7k2YUPmq/dpeKuyyOLM1GmXEI1IiJ1YOudUyPfa2x1G5s6DDCz+SMDCovgirNeVJSj+K3iYKj/qT4dQmrwe7dYF+tYomnOlFTPYNgsZOXc4UMI5b3QQqNY16kWPzjNRodv7upnb9ALnseQmvmNUDigbcgzAGeQaj5zVOTLLhLgD7b0AL8xtzWvMuorMLG23a2TTUaI0fVpmK/NAYCrFX1UCmpGCdtPP1j1QTe06hA0lQgQv/VX8zHZ77f/7WqLsX7LsUCiL+/s+extGXRxSAYEkDlbxaWjYw0C89kCOd6921wdjg7rPmBd1AllEBqwpqojjas9q9zwK9+NeQIgUE+spHuAseecGjA6+jthPjPU7PddIzApAPReLb5H+KwkAMBBIv4LLRsQuzJg7paM4xS9r+Jb1eQnsyliyXggXOBf4a0ZQpiHMV0J2CARfeSSHuy/LKBEcfFKSwGQvAj5oFB0gyIGbREC0SgeNINMH25Y8Xt2R8KmX2faehhUWHAoG79Tp6kuHMcJnlZ6mmtoMofFrFbggM1zz8R+oov2Z2+xaxkSkI5F1dFAOpJQGvN4qweP81vyw8njPvVUQ+9Oq2oi/uZtJOiu3wKaJGk1Qxi2gsdR0Mi6UGuIVtIsqnLAmGQw7L3BomWsM+uVky+DkKZU+GutXVA8JNnWpIgyYb3/4v7itR6zTt16iBbn9E5fVuKCZ7k9NbblvJ/SMCpzryUH0liHlLo6aY537Ylv99wJ0Pnzh3H7TilS8sUpsAe4+MRWSiRcHhfuyHpDISby6TDroPl2P2+yjAaFLSXBiQYUGe1spLA0YCYe+DjaA/VSg5M+6/8SwbyuXmAl4X/cmrKv3Qphk0zUyVV+w4FovUZDpYy1EEq6OCRg9A539JzX5tSmJzHOm8pX6/NM6HXVTtPxbGd1uCaJaL3ZJHw8nCAwdFBlhvP/qvX9vpawtm6/KdTlk0z/GtVGxpG2NSnbfpd6o2evgFH1CxPXS+RG/5PqSLMp3o8DFuwGNSORnzMUZ/LWYzGAVqPbxrKUlkOWXEzB/VhtuJBJWZWH+DTuDok5TkB44l4XXdxkKOIksIMLTgjGn4Elh2ovMLTz48tSUM9HeSrAPa7gow+gLJzsyUDNbPAowsRccOcM3zD/KW+VuL8/eDs+xVW6UA1xJe0pxyOsWc6cOngB67zcqPC6UB4ZyW4fN2bPqhpU8d7hKdPsan2Vzi3hV96fuMV/K5Y3u3mFBgfjmirgEKA02TRmbsMelf5bXtyuEtwcVo2ILmfB9QhvIumuNRFGvyxxPY/+LpatNo5fnNin2p0tEuqp5hZ0Pkzk7t6JwCgBfcyrYzS7agBmhL/tpuJZYrZeWSEABBaTP4DaU3kRfUc22jKv1i33O0HmWrXXrGRpYskd4L4sLQxGdGC8Nc+7XoDKhiij28O9IgohdOz1QTbUlHVLpN0uGLmhGgzu4CIRBTsmVeqqC9wa5jm09DcHzPvQvJMBj4X/3fuADnnEqfh3Y2pUluY/bB1lVsd7msHVXMOJpAEb1EtYmpylENorjhu+j4x7UhxDjSOqVhYBlf2v71eEdyFqjdRe66hvJfFyFYiUMRvGD5L5+tlkoUGXTZBPTb5la492GdknEwnZe3256nii4vyYsEiyYRW1GOEbSLIhxJQqN//uZBorITYoFB6NM584jQ1XWLaAwb8oydX8yyPV7zQrQFUyvdWDZKzK1QUid9yTfyuV1sHF0/hapyeJDWEFoVbdWXpX/hSO5UodyaeNuil6F47lmRC+O5dBvMhLx69O5OLwwFCguz8k1d57XiecCZlBbjt8g0xa5ULy2uRW1URmaf7LKjyLX/1T0op+oGM2zcxuwFjgjmS0URrZgLQ9w09AyUZjSWyQtx+ePduNA50CksRq0B/ePeuE+11Hqz92Fz9OsVf0bBt74R6hbMdZZuGj3fLXjIl7WSROtOrM0a2o/CRdeRM5/RhVSIgyGRmOGfks+6G8QMt3m42YGs1TVp6WQguNQaMuyOPtf6dGhNwLMENfe6jAFYVUyDUqFL5GNaOXN81E1wEsSmSzJsmXqHAo3HrS0dh/YP32z1v805VPCY2SYvaLzgy3Qp7JhbRvt3eYtCyTvFZHRwwTIRDhlK8DJbbFuDvGwr/7o8g8oS4XI0LiYBALU/rCXtqAX7zQTyWEQvHn47vXDgtxSH1FA+mdgJ/oi8UWO30WdgXQloFbBthBQrn4PAiSrWkEKOzsC0hfezLBPYvORRsTp4XHQmDl/7dOsdQ1odbHhQG3GdXAl5O0dXWyXUm1NRyHlaCnDIwrRiu3i3/kIvVEM8zCon6RkgZZp7pKDyuXdqZYZTA19Ye9LfcpeIfJVBMUObRfMbsnz4qZ17tnjZdd3gTH+TjoeGXwgc6QnD0OsKE3a22B+4uE41qvHPNo84KOVxvr+JLuB7U7786g8+JtdkNrg9KX6h86ISIyWKBiQPQLSsTsgcXFhzS6ZQTLwmMAznsUiowMljZl8D8Je0pwFtM6MUNZDjeHbnTm4u4HW/4hWSXWM2ccC8I7EDFrnmDkyysccEv7DA6TR/4Nqlpdl/YtF+pGJ90cMggQl/gTNdZrms8/yH/p43c9OtAIBQ3n+XSOCTFOf/RAdkhqoeFP0rexGqCQFR3HhoQ/YCYaKlnwfqfNXcf68Is0h+S4iT/Qo/RHqx7jXWgW7iKHAsAV93HqJSC18zYCwGL+YZwewp2O0j5D20xMCA0eNghURvJP9AhmU91f4sVHSOVhLrC8yH+Yv8vwwYZ7+LNoLLeXtWl1t6FwPL/vo46+Tx1YtZkkDu2ZV5KRJJiQHjDAHA/xqvDpPMNHgzQpkImPZ55tf1MexvWijmxTT4H5EQbFnxQNmSk4GGaE2qxBdjfJxZrFREqEAdBfglSGw3Ukhlckak3vu/9Mt0sWAbOOeI8PB5bHvwYQOp3yHJ95L84lO46jM3WWkPWvhjylMKobsvzYcLw9JUt4PM7G9EZLzCuC4A3CxlJB3Huke7HYCQwE4PGvoyvsd2USXQ5RwwDtgOyKcy5fVueTT14Fl4oivCP7r+iXc0ry4780l3w8sWhsdLcVYbUI27M8Mdb3r2X5381l7yks/CxpUKID7Dw4EhX2AZ95Gr+JpU9vrjRZgXxiDnY5TMMDopoYD/3tuGLiX0ictEuC1RalqonPS+mgio81DrtGeAyFo7jTzQdSsQ87ldYiUBocnAPCPcHoegIj7WoeDHHgkgiJiNEW7sxEeXAkS+lSg9mVo0Hip2SGeo0Pv060Likb0Z85Dt7JMD8cQDT+v9Cxr9eIZcDOthpymP69PdSMFgY2dO0u/fVkLMG4AYSJg6cfNXeCUNfLf1lqnmR+IcntcX9y8Tq0d58aaczpqL98wN6785+TeJwuTHv7wAre2N/rsKHZ7YB2D5utBvoWtQdXRApmrNrr/wL6C/6XVH5QNDwzikm+2jFRr8xktDtqupgpiEWlmHNVBUwuj/7ioIEoQ9at+rgyxND6RVPQ3vkD84uqtFCV99XVjwADVibVF8T0Cq6JHVxsM+bFKPRQN93+kpvcvGUQVVIZkQsWwfbJfZ3KmomPNkSkgnOMfvyrhMTqyIDYTqJsfNACMFiGzSayE0BJOl+UhrYbg4JBfU9L16qwb1cTbKXG8btDQaCm5JCQ1pYftVLe7vzJcPrbRnn3Hgf+xp6J0SVJvrjY3+If9vyN93OPuf2PEFDmIqztLfyYpwMDSO1kh86LUYASlSjQJ6TFEpHcU+VjFQWxRpPEtSR0JHvaDXyQrk5T4WIpJ1EDF+pw7YXKP45Nz94iIjozvDswsQoBAC2sMkwe/sIfVwgV/z0Q43+kCUdVtil3W8lBG+ukumF4RO+1Tw3mc8x2CWCp5tMIRwEpuQB4/pLSAHG8DZzNRbTZ2hk3wHwrclt8GvnNfo7k/a6DwF0bpVuvjYBVpMHbgMjGsXuXSC4uST0bsyMX8AAP82CupkIBZA14+3dV/ESzLN0SLTZ111HNIoh0gTjedo4dQXmp+ItmXX8e/mmtlxoCL9xnVTFKzDF1gRzVBICGsx+SVXbBy8nEkjiikr4VwB80/RZKMK7djNlOHuEIJwBMx1RXJJIhG/fxHTQMk3O/ijqVp1u33Sh0+ZN+ZIZ/MVb688M44Hi3GSNe5ZhDdTyS9nwaeIpNrnZIUpVghH//dNsc8b7gxYGN+VIAsfmLk9Ntqh48UyCkH6bPE29R4GTTHkI2p7a20ml0/vOCuFhHBrnPnNhZSP+VmBiF2CnV8Qu+eM8Nfd2LD8/wD0/kmw3+P5S5jAKEtute5K7rszkDIAHSii3ifAtie5ULyiMC6hCP+VSzAuewo6ln+QxNkfp3mgsz8aQvM9BBpx0olcxZSwpwrNnzPLVt/OcXAZ7uoTZ1o3jtGGleBWatoShL6zG0qUJdU3Ar+qIM9dkJpcQE+q9OZqf3XMn1pQlm/TdvDBCriT7Xq8yrNpxM2R7A9r47wX3/axPSpUneS2933sBrOFlSmAdEargdgStzzEbab2v8juJnpRvq8hWDI8H6XZKLSLgLYw9Fn+dGDDz+S24CuL8dYzNEsl7n5bGAYPPvLAzmrsXxRRdSCdvwuHZha5dfOimjQXzeAT4IyFe9lNd5DLZuqfgOHW/4jNw36aImvjeM3tBFmytH44dh71dFxPKdvPCpcqv5X4XxxLUCWh410kviyZvL7fdv7WF0juXfT4o1TzJdSsIijFAB2kJFPAdnMn3I5UEuQ6dFrA1mbm0CB9mEaqDbZLfTqUJ9h1fbXlU68Hoh6U9lnw00jM2nAVjFMh8p5wCo85o40f/aFOfC9gb34H5RRRxLPbidcRi21aT9Ynr1crElis6+HAvpKMsx6jNy6B2Fi9p8Amfk4Nv06afxMbL4drFHnRJiGdIy/cjIUzk2JPiXvi3TyqKy8Y709RItDPpaW3NvNtY+wwZurhdh2d0LTLpNrTF608h3v/YSaoG3h7a6lAHcYL7jICtqJwDgdRKdvLBLiyqjSWlm3fRzzqNPM4DJMfxZtZjwd+Y1cYzAA3jGc1f6QwZeLDI2d6M8WfdsMvalJIzQwwD/kpfVI1B6+VgEs2Iu2WtXqbwDnhEVPojHH1mFRJMgXGt2zpab0cSUYHsy6NK2TPdG7UCEFdHuaH6TSOa7M77nf6JMkBRRkrZWQTW6dxQdVBifiWHx7sCwjUwfq6wFRoImPlwiryN00WsTdHGt0wEXoAYYF0CEmjGqmL1GhLMUIUGEj1d8INWJj5pPWhslsw300452zlIPHLkbVlNxZP3DFvOsLtgNnfE9zVH4KJOfoYaWiL+QRO8tn9v8tNoJez2iqNOGfnA8T+Zs220GiKrdK8Ri0f1tGicYzeZMg79Hb5lJwhLf+bd+Xo4SHUkDq27ID5sU0gT3xO53pwkjmvWGIwQwtX8ATcb3UqwsvACbZ+9BiiZ6YtZH086WaBbd4d50JWVm/5ti0qfr496uLTD6MeHANWTpkte8ScsHAJltu3U8TdKOBH61AYlMQEdyabPxTHGN+ozBAqULmX0H/lzWoc8agXzqurMOoFkPzF2j4B4iWvBOD7JR2L4kRDW52biVaZ9fYKzms1V9yR/kdtJ3yyDYcu4gXUBjEe6eAEvnA8uyWT9/4zUPrmpNlXw5+GFvmdGzJZxXYWWa/NXm2RqvafDN9j7jenRNdwdNhQie0PDz1f8XoGdvJ0aRo/a6WknabEURQX5EVQzws4zMuR/ZLuseAyGpCo938OAfz+TmKwz1nIPYNiaJnTLeF1I90mPTpJYVsgq7jWAU+xle6dOvzPARZq03C9TsowkhT13dcSCJzZhhPYe6R4k2r+Q32BWBo0x8AsyWBQsifPzakKrRB/XEDf1z0QMoSw38SmgpkcnCb6txmUWsux6MuYmxfEVyFnQwWsh2RFg2l3y8sivojA0iNudxM5CPX5UPUHj14vSqF4yAumS+mT85fnTqgxP3BVTmRxqpzdY+bCi7fZS08rv7bexnoAoKzDii9jO8GPh5DMG+DHWb1IVsOyOOpLzgY0f3ZjG0BrpMEBmU6Cvt9H/OgEc3mBGDH+ZPgKGN6LOXzv64WsqI/pRA1FE/dk8gGNXn07nAwFVTfC2js25VmnMd3DHyQFQGxiQ8654QAybqi6bYPUUkFTN/o88tdoBE/fdVbdiY0hrSmgviQ7Ke+PbjqrxmffN3KzZMMFBU7KdiCWuOjlFjoBwqfxzt61vFkT/c2fByazj4iV4twxLzGRZNfDCIy8SGEiMyUs9k6g5JWJmiGfPIWWx+RrdTH4jXj6O+4FqLqXy3QNphaR07ztkNKNdjL3qRvV6T5m7d9CvrmnozGzbuxKb9IE96eH1DzIFQoLeGkTRuTAdQ4KgH1bt3W2WzZDNySG4pRWX5OBc1z5uFtIDSk7uaIhTeYWkDweqHIvylb7CYTahOK92hbqkgiDQXo80pvA0cjTcTN5nU21noCScH49cffMOmMP5GElZKYuDdEgunrBSo4YmGOicCXivLfDM95knRoHoajMxNLaoDR2FH4U+bYXrUnabdMVjYv/bkiKpV0VhbNc+TVRPLStu9XTLXyNUHulyqOphGU6mWlF3mqv8+e+NPZqH77ewdkAz/bV3U58u9AxIHqI+zIO1AC2q/dgfZvRkcBoPrYB8k3aPGYd2ceS3O6OZe7LzmQrhsUbQz+EhsYiZuaqjjbbMqMn3SRHXT8Ejn+z9jjLWUMr5JUfQHuaeXRlVDs8iybKyWH73kUiEbOV6En1OQOJFRa/+70+O5Q6AzCZWynOg/Jh/nXsp1PPGyO7CyzTdii0Epyn3YdJhjLcnqvlsXwevMiYZjxxbtogUYHo/rEDDdUHEpWxekC/x4ceWFHuM4cZso2TjMw1J+6WTE0N7o1FZxHQjaGd5Av+ZssrcrQ+H6MMV5VvpYC6Fg8Nq8GG61Qg3L0nYifUl1cRIzfOOVQGhnXkFYZcakBTA9CheqM1QEw3eVDBQ/moVHiTF4ijTT5zkPHyEhPvvRst+EWW5Mkerr6aP7S4ZeUDxxIMMaLi4jS49IjiWZwXhrELoixkopkm9LllxXrCAWw3K9H0iBDPMbCSsI0IIWyIUDJ4ul6ahCJPTTTb3l+7OtI7NnPdUxg8xs2Lm6u2+YONFtIAcMGSVdBmKv3sY7svyjDNh0AF84BUEs6xnSmJciozWS8NV7xLC8lacgIKqatLqkqo0THaZP/snBu3w39N3n4BLCwGuDd5T0q+XWR+7UMxSoLcBqBqVkEG9ukHsggFvjapgiYh0imQLtQ+GL5rlgQdQ1zxvKPK+SDzmdvcXcWVPfhkr1OvMse36TKbCAnoQrO4EeDSQ4UoB2AUAhdSBqPCG2kvGYY7tG00qMlXOzVgipHF2iaWSBeIZ72f7jcxZfGygtWUDcSyCOw3Ny9oCt4spdcyma+MViUfjWdsx69ljn5YMrp+34DYqBqvXe+T6VqdlXAM2h5FO1mBuh92McmmJCM0j60GGKCpoYOgm+CZwMXxeAm9ko/nYrHNrYVS51GCuxhs8sPMzUBr/Vlc/FVOvSTN2gHZCItIAj+VMVU+9L2VLZRyFU27+5SX+oH4mQFa26dS1Qw4mdydu8t3Nx5p3CpUV5e3s2G+oUyozz/Thjccld7eHYXl7HEXYLqRalHj/HGAcSK+uSaxiTltDEBbBN53SrTrw+DuDyCvUIhXcdgw4cb9TqAxILrCmzr3hAHcgO62YV5mmq/CIhr/U9pd4RJwE+6QmomMs5Wb/zAZBk9zzTkEKWDWXOf3Tg+wU4BKWEfReYJF/YzjYsONDlCcFoS6ZGj+WHiMVkdPjER9Xp3VJVvQKEDmY2GSHZZhPBwQtWKj+5YBAgxSA+ctGKzghe7XgW9ZFuYqIuWoqL8X+yTLP65+qKf2VegurAMVkF/QrgJh7FwI7ye7497W0llmJ64mGuqGwT/UzQxzGgFcxhZWCZ5GD7PM4UR8n7vFVsXNHoPlTGTM/bkec5VRZpgFajZent7+W2og38Be5hIg11h2IbWtuYUF4Hskw27Sh8hO7HzGYcRwxC9CPCx5tWotLN2K5smS00FU+9inCjpiK2eu4U5c0DYXBGuLz8OvjRO6FL1/O3Vk7jrkE/ahUFU3Nr37QndE7FOTXHuyXo2vdVbF7wnhNWDfcC915eeUfQhzdIEHdisj2HNBD8kX49/vnBO19pWWH2O+IXqh/DegVxn2+NU9Ay2OTiiSIHGTVTzesoehRfVbWAIZ710rXyFCVGBqDNxer0CXmbN/MptV+W8sNECo+UZxzzupXtKTOzaxlOlAioVBZterpJenOhUmByuOsCrWBmBGKn82xmyAm8vgqxsKCD7FLQoRp/eANvPJbkl52e8nBmS/sOnfm6ZnhNC00yPTDQFFn+iJXK0sOWbm6E81rF7JL3sAT6sJBTQUpB73wZiutIJTfTSWLAtNl9aEgeBS19qLCVp8g5kwUyobbYjddfcEhT2o4Mib2ryk6qGo3PiRFja68q9h4P6amOPzeLXeY4LeX7giui605zztpPniqQif75Ef7PEN1SFkbh+21TGGscoPYev/STBVNMjdbyZbF2eA8kaWbvNlw0jva/LCa2qdJfBoKEmqHAokpn4QyyjURJRbHUqQXPm+JcxU1yCBoHtS+djq3U3mveg3lc1PPg/lgROlFTVRi6sANOY6nnQSvVBQsi0Angg6apwkOCmQ1dyv3AigCm85MSjJq2VZUUqTElVkvQvDlW3yYwfRnxY+nnm0P0y8lo/H164FLWMbWdcSTi1pVH9FLCQOmcPYGJQARBJnjC1vYisVYvPIOZb8PDP+2ZxIqQCY2ZYHmntlE30jJ8/1qbsoJ7pHLf8AGqrp940AZAM8ggeICVKewO3CwfngrZIN0VWAmRY5qBH0zCOxwEATuT66lnp0bWdLT3DCBfaVWCg7wwizmnWxa1+mMtWCpQKWYw5VHPBVvBc7DUlBBBQo6Fy6Y+jyEOzFKuoXRS1y7xrqHKieWHl/cbJV2muRMLtTeIGUMZRsVD4J+4lakO3BYEpSvh4jb58JmASEEGiFjKo+mPKgiH1pu6NuDHhXPNgEFW8ms8U8O+w857iObsddLNKXzlX4UrkLQrGx19img/rEl0m0xraY/p4whu5mK04urgI1rHC2rgmWlmni1ZeMM2srG4DrWsOvrmYH/LCqzMNBxkGJaqjs8RBtPKsH1gjPOSKr6+eUosQEh4gjokzNHveqy0Wjq4gAtxltG7U2oSRIpVD15cNN6AL02M4seCGNA8JElHHPFKb9FPCteyxMkUAYdp6CVmzy5j05oqVkuay9wx7gdZBVQhLrYEwYMy2sFHgnGpL9pBddxDkToD2iLBI7T9jJchh4kZcD+QbeHtk/sPJ6WRcFPJQMuM7KDwc4U/QDklhH2CGCb82wYXAwTTPtNeVmORs3DaHC05DN5YztJGR3UiYP7ZC3zWjqVvVXgRCzYqcFTagUzGNwWvbZsV0DXSuXP/ii8ooX6T7X1A+2Y5pefbtb0jqwfvfohD13NuJmHqii0BlazZro8bEF1P8S9mQcG5XzSFHS6TEcRp6WpZKOMWqY6Y52uPoRkiR9FbYnmnIrz8/gq6rEhCAOcGFVJ3HpNp4yEm3wq13tS3X2E1idcHWoK6VCt0Sc8/lp5aOTB7T0488sjs/kte5bzj18WP1iwPTw4G8l9EOB/4iR2WsrZ3HLQruwOIZdj1Is2qOxBxyO9RgkOabIkKJBs7hVgEP8nyF1A0IezC8CTmp6jXFFmuOG26trA5o76WS3Wi7+luMvXjlIz8Sp+8+BRQktZ9XQoXOccYXUoQqNhKUVF9vtPwBIupe6KX9uXNlAYDbsHLyCPytx6eZ8goqxH+xSUVISjOZDppRWt6qDI69nsDO9tybM7W/kJBki39MykelbCueRir/luaDyGL5d+0VadngfIPldeKO//7Vh9Ter3OVU1METRVz+Fb4zLWsZWOFM1BDYmc0OMSrng8hi07U5JggIZobp7hg/TvyAiuwDWT63ZblTqsYzbdL1UKqQnB82zpcLqQ6/zbx+4rBcF1PuT3Djaom40DyLxJm3JRMrkhokeU1y3iEWvTHRt5c04BxqKVStWb/hVXF5tzeqTv56800frzR5ZsX/eGznDVIufSDGIvqZvtt3WxDSFOvxE98SiX20bns2xIpsX6CSQTcgFvcPV6+TIkdDSp/t9e5IPWxV4nzBxXDejxlJVJWVE7ZVMd1IESxSlRBj66cqLn+oUFUZT4GTOChaHogczja6UYrA//g7Disxb1i3K6h4QnfI0APn1kinZmBJTYA21ahk3xgOa0mq9yMKxce5fSkvT1Qw+KnXnqHyMiaW9yqi4MF9tcBMgL+/me9IZDM6wqTvow/V+1cM8YLKQ+xXeR11lUJ2n/Xaq9nJeHNeaa13IWQBAvfnllogTQ1h40HlwmNlE1PVxvxQZHbkydguJBTn5qdej5/14/yM/X7xf4aX9AW3tKmdCxzvprSQiYVkdfHCih31jt/xDMfOb9ebi7kGQkJIqC6bSOmjbBhKWJCe5eRoJeOJSJFv3yn3Wdd5+XzmOWgYGL5dkEcB7AJbqCupH3gi3qsP68/kc+r8vCWNF/rp2m70BrTgzmcC092VntI56vCZINbMOeBA0XFVl4mg8l6O1ze52R2UgOytrkt7+WTEH5N9lKlCB1ahz7bYRnBeXHkNSniiIUMTDf/SDHfBUDvF/RVlkJ8nOtwpLL87sfys0eY14BBwrFVjThylrGGoalGmHoe678VhjW8sAi2TW9pj7kh0Zo0CR8aZilZk7TcBRmKTFMV1L6HYrdzDYRCo+15AJHLTbQ8g0v5Ziyfopljh/NQuV9/Gg2hkB0GCpT7s0eo0FEUp2qqmhSDNNx7J10FfSkT4QbEmOoDjeh/dx2j0553xXhXfiaQSCnitWN4zeqvWjegQCovawpGiCBE52vwTlKvphzl/mHlIzh6pTQQtEVudaQ4csrWC5DbZtGwVVC47InBuEgUSWGluZ1KAtEywFBqpu3MRGKYdMVuJNKUx11zlxeqHrl5dsHS6LPqnHcNkQ9WEhsFQ9h34O8IO8DQCxkCzn9X8k/O0O1Jk5BJcW6zRJdhgq6ff8Q4kcGwkEOX43zU61GwwkddZYTgjxVidTqipLusVSAzkijSGxaB0rw31TvDFjWgUatHPUj6kjo7mcMQULnC2Kydh0On0Y9Lr7Y/Llho+M11dx5g9cdJxYwbrWTTkwmo7L7/k99hODCqSKMJBMdm1/1JNWCsYqpYLBLtL+DIY6iMijvxMEuJ9F9m9lA6aNO2wQKvSeiVjo0s/e5nkzCrZ4XP8CvIOGQn7ogxLRxY+9oXVDarTsl8G+faPSM4zSI7tf7MuTVO2Pjj0uNgisAah1OQLFViK7VKH5zr+iVkzQq4Qrj23HL5m0xBbpnarVNLmrUzMzWVJ1qUCSMb16De1ISDdcTNCJZnHIlw7sRPEV5ikkOGxVG1mR6QFptiqoyIt1ieawyrFXsgMD14uj27wi811h5zzDUdraCgb85xFRluBBclGMiv5+I9KcAcsWz/GV2VccTYxGH7P+ufB1D7mr3Buxy/0eR/tOWTXy2tfvcbjD8QMmoCEtEgiFVxul4r2sKfnXwmCCAEsHAHm+62ov0PqWtdpwmue2ZUpphlwj+6mmDn5J+gfOO16cvD+oqb0mZhjDNIHTvrtxJw4CpFZ7xv+q6HLKE/v4igXHWTlwxP1+J/mENhDtoCC6zEM75pv64ngdFX0+6pKvE8EKZjHDNZxEOsQ2du7TBF/XsL1kkvq1T6oCPH5uYwNrsMZdbb/m+T7k6p7vnwoR5UQ2hIPr4o35TTjVJ7zjMUIbv4gH/UlTdiGLOMs6sriXgZ2a/W9jHmyxatxtijfz9+bQrEDg7M4JTiS5yFLotVDxgLIlFZJ05ljCS9JH7xWRsuhWdOh/6RK4NZ6tselR/+9YeNOArxuvIdhN9xxJoqFNnwrcMwWWhKL2QKkIeanUY688LJ+x8AfW6Wwd2RABlUeEWpmqfaxb4nWxJerqbpx0p7K731wToiTG3WG6SxYr7lFOdwqryRBlDrpP/+2ZY4kW37E6z+lKmGc8symOYpmRgBrOFp7jBSJDlXBSbtRdFREI+rzFTA2b4f+SZSbCIvG5eywQYcaSVN3L0mNujVifAwkjy2kn9tNSamnBGwb/JhQFSE452e0nY96EatO8j1A9KjBcVi7umOwvkFdh3+nEi6A2irB0MpPF/1hfnXtUhqhpBvN4rcwuU+8iPGz6n4wgcHfAHung0VfPYQMpOGZn14t25aIVn0vC7pUG4NmaVeOScbOOMz/8JSgStuo+bjSA9yklyWy7ztwHeRRIS+9biHeyT+P9bLUOEw2hEloTzyyMTJL6oJ2meIYTIY59IFsOwXwx1vJ3gyjXCbmTOrxWUVIbEmX3BY3y0imX+RWUKptD7vCEFOvM501zd/wxjxGpjGh6yYgZI1AUvs+/jNkYWH+bUuJt4eHO283V8qR0nEVHVpJJRDfwKocckAyJQf2zZjSL0LFuJy2rQZcbarwsQeysfkyplOJCy5OD6kvwsVAkzZ66nMFHsSTCh6mOSqS6m0HpIduKFD9MD0EpUEwAV83kqq+OwSc4gObWZC3GThb+7l78HiktoNfdCXulO/IkXM8IUD7TI0wuZ6+MeDdLdqsUKJLpUOqmsBG6fPYEgUKCe/QsXH1ssKlAqD0kJW1qDX4It1N8uLS/+ZsNuJkPH6xsvJUIPW7rGd0CV0uRWKBRLkHPCvjem+Lwo1AIDDFyjez1UFQ/ESF/x+dIEBlM+3MV3B4HngyFVFZ5xaPdolZXPbmafxO4RtErGgrBTMvKQ9NlCjwWyZdaXQHmZL15Uj2LiVEinOUGj1+N2UdQ3gygUNM4lalgJC+R6kh/6rDGfa093PDtcuRF1fud12kWPFc8YL5iIJ86/IcmMt2T7mchCFCdaEsca6aafQJ016Lr2jmpg7POI/ZPWlRsj3K5uImYSQ1l3xujCuNUElCc0J9idpPahOwCKH7l/o7RbfOr5hgbD1tas7WFWqkTgM10y2TfOPkqy88IL4VDDwAwQ5rpjOPlvwUnFUbU5jITknxEQ5+QKQ6lzJ+yLosG732rmJqkQol2NzTJI89dw9lm0AsIj5mAWPiBPa14EGAyxtsrykGK21oMr2llsN9Gy2xy3GX6a8ektROtYmNLtfjYuOFveX6OArmORYU1w95zVAxslrSaPhtRYZFQvCys7kdV8w4v1Z+McZ+YRrtjkqQc60HaYm9ZPk6mbkiUNHwUwNCubMyKrhKavilVb2bjMkUP1CL33U0IHtFs+Bfb2RM12/RGCI5KjxwxBDdeAZzL7P04HAcNEqB8L9VkIj3o8AF1UO7bfTYU0jSb5SifQApWJHGu//n0AUkKYkvPlZ8HdW6OZcOki4B+bHJd8FRGYEHLKrNteYbI9X66JbTlMv9k51UPxj6lEiRgbkEW+gx2QY9KWYB5pyqPElkamhI/yzfMp1frciir6Aqk/6rzfQbbh4ozZII3G8DKhau5At7vMB9VdX9Ae5JjljPdwwxGIOj79Xw7yLInYHLLZWxBppNoTAhol9KuggueKP6eXjJi+BazZ3kUCB52nwIKSjCHRT0Yjb0jeDEG+Vm1loM6FfJYSeybZ446rznmZMuEmbXrArUinmwgjoFkTbi6u8cWmPBZ+Pmpyd68Wv+7L7A41Q+v/pV1N0VxBCAcIHlw5a80sDEhLJXvrQbFzjgFB/K6cps/bFTSqWuhax+H3x+z8jsxsTM7WJqGitv66OSZJHYLvYcLaQJtKlu9MZXnu//zqxsBVEn/mgTTBzuEOEL669jE1dtdg1UF09XG6Yn6x2ujyh2vFgMT0TNNJFTzdwm+TM6cZzhpav+ZBTmFIki6tFqcCOqw+tACB+wLJK/L1mHRZvU11VHqtyzNDlSO/aGjmNI2QpIBdRzVe9QzQ5cOa+MfMr0xesG2Hw+JyD0yxYUTpz8Cigq0b2Bd0iYV8sTmOP5f7MUqbtdcEUSueIayQ/mJ2Tk2tSvrLMjz1q/vZHZ4VzJutRJHApbZRWmu3eCrbpgVxEec5xmTxat2osjxVIdCzfRyMGbLn0bN00DpPkivzFD1YeNvXbZgQ9+K2qtFO2x1fV3BszGbtdMOu3Nx98+JL3RBG6NjwktgAz+doDS2li1WJ308y0jGAWT6N5H9S9Hs0gD6bxnxaIVjRMTGmet9SbU+381qpp1CH+Crz0wb/sGWdE0kTq4g+4167M1BcGCcIOe5c85qKbQh5pHXMOWGN/Vbbf2X/NUbLc7Q1BG0bbxqFLuSpAH2NCETPFhF0O9PxdOWUK/vbUZSAT+GzZaj1bSIYugTV5q2BHsHmBucdDmI344X5EpqVqMFQQZKrqzcmkc06aMxgV8MCnOb3kxXP/SA5sfsrenSRW7inQQ68llp82+Xh3GPYEigO4n6nv7uUnarkq2Sa5oI/1g4f6+B6RFBOMO8AnlTw8kE1c3pLKNNfC3/3jkqamvIumWhnjQsQVPfno1miO4dAiGb/N8hAFEXHsdAyuN7yZ1toeg5EdA8tQVJoq5Cj0P+/jf53NRhZORSke9jqpgBYZi+5BNWVscSOxaSfudgs9zlVsPO+Dj18hGaG5OZRVaT3mNGbZ94N4cYxAxm+yTCmHH3K5uJ4Kc94cSOiuyBadymUU6NafTXsPVRBhxoiDXG6EkW06WQ67NtY38ImLkEzPbwyW0i9ibv6C55wWMwZjc0y6/XdP7E6PpuJ5ok5t9yOMFCSQpakbwfIEw1R0OzMv5MUd40HWyn88ruyaGnGT3Gmni3NzFzu2HjdiLxSiOfP6ooyPbJ78AHTuaZOSnrDoE8K5OohSkv79dd11rxLIYsaXH6KpmXEQvB3iUiu79vC1a7AvCO7iZirpN1n1lzvetV3oh8AJL3Af0zQGZoNosKv5FZ5JP3tE9E4XH5B9vsiKuZMZ8QNhy0SVvj+VszErOXvnMkdorTkm7ejM4YWec0T+9LuDxGgjNY/SnVeGicyvB5BYHRiYKibdPjWH44Nl/4IEj4uxoR0BMneGy8XPtZZ8uR+snG4h1p3O8023edBOia2f95No0cdXClUsL6VTGmza/zyilM1pMMRAeLzmrjPCKOD+n4IL4O659hHMm1qLEWhy2s9nELj3DKwW/TA2fSBb5BTxZHaSoALIz9kOL3xqw3GYNIz/TptvyuHGEDJMqmJy1bCH0n2uLHHk//Lc4yzSCGULEXVi9c/H3aPlasSfQ/HuvDvQM3TkPgAl2tFTL69cwg3xEuMSqe22ByfVpyFjogZqGS8GzxuMjRCn3A1ulywCz6s4N1NVJWIr5EijF7INQqmkPGl/8juOdyRQ+DqwC7b3mJPD+Z2CPqsW8aycmtJskp3w+I/2rnMAqwV43fJszoINLXFT3SwLAGoWKiXkDu6AFRF34ZG0+lEOIyLK51OttwT1sBVlg4tgyrfKCiFhocayl+A/j4QeDCZ3a519Cj0Z7MzFSK3IsXtn39dc6WBeX8gsEBIUZtxWbiQuX5uqCgdzteeE3RGELhSYz5SrERPJAebdCk1ZDJ5xWl2SKXG6KGc4zF1UUQzxAQzt0OAy7hp6kZG7eZAPAEouivX02FB44UeN0NXU6L6wVl4pvlA6q7dIVu+8Vjpb5LLNOuk3vjQAd4v9+FK4XlboRSgYz1fvkGl7PV8PSQxB9fsOmAoDuUPHQyxZ2QATs6zSJN9CcLp64Fr9hjcLlBMGossMtOIypWdr4fnpphHWHAbeWAPBkL1J4SaUBAl2Lb5rVAJifzrzi1+HNuPv5H7VAE6JQHOfMxQDqEuzcvo8AlxdstGZTkIqzObNfnXH4t2sQtcw4RRqC1oLTjeZcCa89rPQg/EFRGR+LbGBDxY5WzUPG52ok1z8lVQQqR/B8D1zYTyTl23gDFQusg4Fifws6pA/eXRTCFb9IJIX7vIJf+n5xcYiuM3/cKHO7N0M1VJcvb4ApcJIeFifUi+eFU+/KivvzdivwLIzuMELoLKW4AsWHiOwTcublWPdpzNXbBq/hfTRug9eg4+A3G0HEhXiqyLeZazi79aYoKbf81dTT+ujChpoWwuji053tf/mJhXSw8yr9SPLdsIZFstHb3rPhP2mDAwHQ7xM71hbkRDIljrfGpWXeaKgp8MPF5LyybSuqNY25ymbmLoOnc/NHNQtzA7SVB+J3UDzy2LDPL9/sU+UxaILgvQnU9OzUvxJIECkfZ+w5T81oKDj2JUW342/tzL2UerdfMtFTB9VbVd4SgPFUgF63aOJIYRx+mMhb6xamEdopWigZurHpqrxujDq2ryA4KQPt+VfJ6Xuh3qBxM6JqcXfHBl73CRZAqpvZ4IWusuwZAcUwj9S3bTzMgzqTnLbuJvafm1Nmjku7KTiliKJYWKPf70iYZB0EZOP8LRCFqxrqoVsBmNxEExE8VqQT7t81o89kzRcGiXbK5HKadLdn28uvDE8n/7AtthPWrWacHiPNonCOSAmiuGV01a1fZT7+lPeFF4n7gfBDHHlNVHR+iHDEDVxbmkFQ9NwLWKc43e+VU7OBMdozRUN6Vc2ThMtqycd/x3tkJbTJBSvLkNSNRgMzEWmM3CXKmieDlxE4ZbGeRiYCqXcTbTMzesQSQytoazmgc6ZRonDkTRbw1qVqnU5rM0BybDKVcJl4BdL0BA7q5wH1IevWr1jT6sK2iIpKkp51R8VHFPo64EDXjr90nWLDb4J6Vqe2rO9/A27HnayLXQG/f8lcM90iZ933eZjvP4FxKXP+aoQv52NeqBzlnvYvf/vg05KS7W+Eb5nW8f3N6gL+NqLaQOkbnnlhlFkmpSkzqJeye1IkIwOh7Mo3MaBWyHXRwpAY1otCVU+nQ4UWY8jdn4hx8k53KG2y2PsxPrxC1wlPjxsNPfDHt9xSFZgaIA3TPykCqXW9PeOdKSk8eiIleBPdcxnIQmVSZE9iGv3+1BWwAx+3UxjTh979OrZPuezj65Sk/BstAE1MXfGNttN6Xz2Nl/8p673m+omZc2joGcQG0lm0lGVHP8ww1hvEfc+e/06JuAo/QJmcKjinQrxGm7yOTxBszJf6H5+nnnEgH7YYweEXJEeE0d9cIYcspKtWwqz6SjfIgW1eyIe1fhEoD6urnnqCcTZR9Rul7UqzgMjL21smM69GXE/8GjhxXsLl8XG60QbAmDktFXLYi90awygcxjx+STqedyjMbZ9j54YwEOnv1REfCYY+joiMf7xxlop9bUesoZwPYMJ1FEV+s5rsZDVFIQBD0EzvdnFxdSgQKhU9U3XHmvbXDfoJ83o+66gFOdMLRiPJl7ZhjSZ2Jo1HvTGlZDugdNF9whyyFdGQouCEg2EzsJqse3SXn4s1j5IL9JNJF1HX7qt8MrTKN5ays+bhFsNn37Q8ixIO2Hk5zT7AJs1rTseNNm845nxW3Wpbqw3SahrwGBqOqry72jH3s2GVMdoFlCQAo31BsSUOEQT5w8ScWOst3M1dh/MzE6yKvFGZEHzrpGvsgdnULHIt2mLX82E/RBwEneFx1w4uSJWMcvPDTznCogjqHYWZwcqsp5gsLkoe2LqCuwyqVUk/f8PwYggJnuL35f3b8QbKC62JiTMQrZrdws5sbPWRPiMjFAIW1YmT9Rf+XWiQZFjOexGMmbFidNGYJiYO4TY4sJRmYLjiQyGP2bhwERVe82A1724qyqIkvqkcqbJaNaEBNzbRxojl6w4v8boYBUk/qazSE+bbzZJhHEBFvmyKd1uJdkOZc08eECCrBaEbhBsRgul7oyYGFDFfvR0bonlBG1hfaYb/f+7M+XYB06cHgUtnJSeeFLiaXYDKO6ANYd4Vid0GkUiwSiizr9nD0weVj8S1T2R5Oge6G3FO077BDpDHwEqu+wUhGqcr6Z3vO8d6XZxjAkKNNicbUHXkYvijgBcfj7eO0Zl/365Ue6sDh2J+RBVJa6XtT8zY9o33FVwyLWgjSh6ALKe8KKRaHxzOqvAOPnjsqInnAo8MCj+veQLAQqedbwejEZniha5PDmc1h25iNj0yI43t8Rnh24Rxg3bnw2XKMzYDgBNHdBWwGhUT2Jr/Z/ceh6aVE60+tTxXAtSww0ka0MauH/nH2n55dsOFt3GG8rG7/WC1Kzz98MQGwbv/EXE8jX6J5lPR+PysLDb9fM/SvOKV+VRdQ+tS2IXloHXZXJV5pyX86/lZ7a3QPcJVpjEcXAqpjBQxVZaBbnMJff634XoZtbEbSC+9ZMvNrH2sLxrhtsjYunaKWsdnclpG7+UWHDE9qn949NcCGFS58blqO1JU0tYBeuWYiZhXGIpfHsGZOWXv2F6hppBf9hAY/hYWkzMvLyWys2kFjv6vW5G6pdJU0jMEhLaoIU6XjxCGyAXfDR/wJak/Q+SzGVosYfWu9ljdp1A1I1KRK7qe8wHrifdTqTI7VZUyB68XobuHj7MV59p4deZ02+vKOh4nZC7CFRekmwjIdRIDjxX1+xM2LsZdaYXv+l3jDOrC/EcPpieUnyo6QCX1KTl07bRUs4flAsOpHM+biWlA45lWgXRfoh/amJrmZM3OMqoCu6JhLzdyLDBZ+QfYxHlX9bso0o8Kb+kGqsDAVay3YVcOsyd9s01QDvF6KdclI7ysmmtA3pYBMo5HnyGhaN8tFb35x2SmAXaetx/E1+AIwp9do9UnqHEv2P8dP3YyLqnz2un3rtKr51MC7QNo8zq3MKVxn+cTj4KTTgaV0iZUAuHIapnNPr6ZBvRpD6PAwCnWkwzqciE3GdoIRX4mKbNNXP8f/TKcrIkFtg5nGkKRuuChbTDiIPjnLDfqVanrhwvsWka78udpyNy5bMPg3fLR8LxaaToMNdbMiMtJ+fqBt4n4jBHhrCfKfL/bLioYKnRcvRRGqCx6ZqE4XxzFNPeoJXEjhEbGj4GmS+4Zh5Dp8xEz1ZxThNq+S/r0iJkSzd+vwSeJeXmlBzvXN443XDa277Y1alF8btk/Jw9SClYAHEdeVhzPknJcl28U747P09OjmTC36tZYSM+fmf4ZWviZ1TVTBxVvq39chajBTQ6BToj1vNffR78oe6A8+dowURY9auN2T//rbwkhToPVsm0jnYHCbL3v9y755Ot1VwyTE2b2Tgrj4NR6AsH6dpvmYT8viJ+f06GL/3RqS/qTN4ZhzsqBs/HTIBewuUU3aAiHRcoZcYGTtuGxIP1ITDT5IwUYvNLHu9VKfswkpcIbXGSBjhYy0MDXSelp/uzAWgBQvNjfdtLFmIcuoY6B5dGVF/qnWFRVCJwsN8k4D/Z0OYK//0g83RkyZxGliE3BKVfdfBO8RDTU0c7/WRIegec/bhC3TbcGfnoUdr0RRZLaW5XsHDMYPGunT3PPG6ri1uM7ESbI0Li8s5AKN85ae3hq8/S4JEplAJMRmcb5sWZ8WV5AD20IUMLnbyt8BlnBCEyi9jxxiaybErxtDuLCHLm4d1FMji/edk0wYk+GPewz4U8e/2/MFMH0kX9lbSFacKaq+BB7BVzK3Oxdfcvn5dXqASuh5gLpu7u48Q6WDkwTNLe+NXfVgVZ5lGNSzIY+GzbAGX6ao+wcK+Mb+qkKyfwwyusKZsM9ApGFdrzwLuiE1WkHq/I3S8h+LAJu6SfTVZnXgoFk3cpzF/51qcPul1Ze3JfTmjunwnWGGi259JosufvalotXB8iyPge71eO4Bg7heKsS4LXZarAQkGYBSmL5mVJXI47j1QFFhGI+M+S3fPpsEe5CT42BXbMxpWXWM2tFkT7YDI9/Ra+b803KOAxMT1qckILO2Ot9eGLaKRoUyXBQbCdlfmBwMFClz2TKz7nx/mw4iF+KbQ2wVC1T6Ssc3EpKGD4fFBwyPoHlDeA0b21CRZn2zmmeEbUIkJimraaqZHYUWJKhDeEVjFqZYLU4PX/PmiNEWRv14GDh/G0ptDGci8k7djeLCJC1ii2jhj7yDr/tA3BuwcwfQzOmu//Su30aG5FFyfllZBEArtuJyueVBjYIMphYXeGei994h0JeOWxLAWfkpPgdL5O98DN9BNY2AjZFs/MzzO04eKfPclkq4n/f3WMX+mYXstsYmZy3BSmjxWIbDGl46M8coB1Wc0oSD73h/N1H/hYrf1DNtsfKWJWIC8pYgWplENJq5FR9QTdIvwXn6pvblND0idqCTpc95BM9GMu8/ZdvZFC77Se+6aMz0+usDwfftCb5BPv724r8MamRb0y2NBo1n2XNaHUEsKehyPGbeV6nSf0X5xIni0YXoXdbcTt4ViWEjUtOfSnXZQwsn5nz6spiVW9CSupD9aOxGj7pv8JraOuixTCHhPEfb+1rpUFJVccnbsmCO69fCUAuXsfh61T5gASZcrnxeHUE/jB5yRhZzZR5Zil6cGFNllizRzhFuVlfLWljvB/OGfO1nYghaqiH9rze9vka7xp2xR7+mu2Pxk5AmjX4iVXEaSuZW1+KyzW/zCDxqP/TIFM6hf5GuMYTaWdCXVhEkqx4qYDubt76RsLbfM+OT2O1l9OHnsseYLlPP5xGAeCUGwL+3NwFV2B1saMV94M75A/TN4iA+ifkfTypCmAsPSoxUkeZ4R+GLq/Zhqp89rjRIV7bJZxJdqJGm5tEDDiajtKqxR0jN0F7KrfPNlQ4C3kEpe0SSfT0kbsvXN3POL5g9TYPJg72yirIaDXB5n4DuPUeokFmNH2ntsn4Zxd9VTKXRdmqlSILRaRzKXUz+0vhnXYAtutX6OLET5IAbxust1PUqht1R0JemG1+OnVnwudMuwwZEmq4p1GGDxImxOxNYKb9OWVOxwPk/5etaFPD0BMjEE5M57RWKlh4TWE5XnizclxAa9PqYxW6ltPifpPnMzi3h1Xaezyxh2YpX8i+mg56urSB5tSlRIQsMF+ANi37cKyCHJJrodp/IBi3BTn9NlI3nOeoLQJwxC13tKz+ZK2FWqjaKwWzK50rFJIPICeSslEvgMCZ8UeDCvVnX7c3puTtssSKu/so/TMXKg2bOyUR9w/5dweHPVUfHgsoG9lE2cVrF0UH/7S1ifFGONJFLojqenJ/On3YbzPpeJIXCIyKPBg2yxDXFVjj3M+AJHqcdkAOa8omXcLKOkPeIz6r96+hFl/VRgGEDws4vzZSvPi6f3nJhe4eH8XPkil8ZsFXXQ/CPKTraqV0Uij8JLDunDO59SQtdJVArIuDOLNLsLTyQqbLWj0c/fnEzSD1PpxdvK3k1kd2o6Ep1E3Ckjr3mYhaj17FliaR6xr9mRtnxZmXTn1y0K66RXB9H5PkKf6+DiEsl9pvNHZLL+Wgi0JsmE7bj0oiseGmmutExBpJqbq5La0GqTJYORBKYTEvahBIYFiRUWsU+77S/ferYLi18Dbgtu8k+AjYgRr1pJcyDloONx3ZyBgx/rDoBOnHc3byZ7jikhn/YHvH0PQUO+8Brtnfa2KN5vKKCIN2QrA637j7QTc1LGtrTMx6A+CJtlP9LRplcGBX24ZJGNhs4mW2X+MxufVUIT4KAuacJBsHsdEaON4N1S8nPi2JpgpNukqy/5UPn2gude4mITTjngNA1nsN4opEPllIP7fHz/avvH9dGbW1vnalKGrclNKDH8BjZpOLqRi+NXMtSWPOZo9FVYf7nUnPOFYz5v12c0Z1wuowO9P9cK87UgKWtMASwqLmmY0fFtliTj2nLKWnhCy0XWSTkrvkTk693aePAmn4REr1Y8adz/p2ILNhSHfNC8zQnbhe+JPEXqgKwJAtTM0jcfnhqtVhfPiagD6S1+qNBkWCq0aYeTjrBYwhA69axBnXEnaRuHRvmW+DU/iihSqDe7FCuKj0LgmBxMB/zgQbHiknE8+eZv1zpVpPnuaovAN4nLV5/eHkRCFmpUfMi9aFeCkhHOAZ4Y3gEyL2PL71r9Ew6KhT+BPqc2A65UP3QpCPH1wXiUWiZxupO84Ivmi9L2GlpKBaiK9o5VbCRVESOanswJrfrBFVoiO2+rTtVnbWFr5W/+WI2ocmGjgt8sudwsiA0YZo4QbMkp3GPVYfckdt/EhaIDkTxAm/NWGf2QbZ/x9N6e6+w71iXS90RMPiJFBl4yAuFPmRmoRe535IF6dFdg4xHMQiUqu2+3WO+c0zowT+j60cAABAz3HZ3+WP1vISZABCCqw5TdvFOo8MB80805phnO4aa6of6jVtudzW2bL56aOiNFxjlSfOtbMAGDDE8pl51f3R9RIem5CDJv+FU+4vGUOpWitBdgC45M4ZkhIy5Mxc3rl8FI0VOBA8mqk4qF3ESIr4LKg9lec/GPwP5TUDO4jiVBXrR2w/QU6CzQzCM1Ci9LueiZDCWuSXtgZuavHxtwo9e2TM2S4+W74pynnqXeEzLWtzR4wrCe8fTzvAKYePMq9pSBC8M6hUwHk7a9ErllaKdssxlhMmi+rrf8G0EjYsO5DheQrfT3ZXLNP7gphjnBnxvdUS/r+nqVVPG2FJya/a+QuTGI1F7st9pFqIH3bodFeoS3NA6B002ejTy6AfRGWZRvRAYHBynHndlP+N2CPN/1mHpPM/51iZq7PanTWrtsNJhgflH59MHcCqx4NkFxD7mXkx5grvkUVHoqtPEy/zfRu/sBeqv0QYjB5NFxZFdKUztidmrO5rMegxBu5Dm+cD40a8xn3Zq8Yi6qsSOgTZAytUqb1dmYyF/NNXiCn7SuoAlNl3jv5R/i2LwwkgSbpyyrsiN0OlZE92wpbdiYGyv8H0xH3IRN66kNRypz+Dqdr5TtsPL7mp8ALOIEkH892iH7M4VWCcrsFNgvbG8IiH7LzqFqVdhW5fz+/oels9rOPVG9LvQKrXyG9TKxccD9X8xiPVmUyItAWct1LXVovofYCPhwWdwl6BP77CjF1dVmyu/bWh2TbJ//gqCBcYYDw62WdrDROmhufaOpMR+4gA5StAIXr9i6ohFd3tKZaLWW6FHKlfhgmNbtJC/gBs2rOWo9pAIfd1Y0VkIgtXkxuGzwvMRd4uu8cU52UmccxWqhQwpt29sNzjRsWW1WPnU8a4yXFb6ctCHSSDXJ/clhqjNpHZQSZDXpFUuJ0EQsP1jnI1CGBKTzjN4twCnVafHkdG18V+2yQNjx+H/LVC89KVYwWDcCp9lH2wUHLaWnt/xAL6MSkennw9U4hz6Bn4Co09aI8Sc2sE/FrAbVcsWheLp4P3d70QnIPPgPjt2vATkb7WG78w5bvya+Gw2ODutYu8oCg3s2Hi1nU+iAEE01dQKJFqe99fBZ4ihmpPMujN1/a2dr6HpFoIPKlMyelsncBfWnqAOazsg2aeqhaYjMifgwmAyr51mPwvHk/3l5/Kugqr6ndHkWSKBMZOP4gZRk0tP7BX2j4d9tZPoZjfXUSD0WIfWt2zUYXyC/Y7w9Z/5Nf+j1BZ9yQ5iRcl0GvK8M4a87h96pALhzlubsTOOdPLJmJxLbC3MYJOjMHsTzhiTpXeKiZ4l9rbHYwzVQJLQXAzIP1gALZzjLQqDpYqfKZokFPiRnWBJEtnZVUyT1hZG291UnXTU9gfc4LiOdV+JWosTq5i8Gi55zddrUFRX7VxRgXtcXstzc98yDy+cAkA5mu7FiKKvs92EfEy1Wkay7IGNGVcaMGedgTmeoGr+zGL30Thd8nFVcI+2nEc0IvxFMVWHt6OJi5PEeAczNl5/xIb2hI2gisZCfTOG3x5BIbtBZZdr+tY0l6G02Yse7O0DdEiO652mrUpgXwA/kTE/lmL3Y4hLFBCK5TyVZEKviNND2s7M2wjBmJUUijGmul32O3aBsDOpLr/CAccfZ0e0y7BOdHWR+wJ4lAJrsb0A1raKgJSlkFjlATQgqRWSS0dvHzi+D198bHYwWk6SW+7+zhvdsuOIsw9E/GfTbmmRZvws9bXnN91DHSAhMpQ09xm1xIDUN9StmchtN5HOz2rzBuecyGynILrPCXx8q584HhEc+9MONvHSbwarugIZU/KacqsELYL5zm4fxigRoxfRwdQD1uPvcvuZQ8RACko5RrjIJ3J1+O+aqLYWaiWkLQhTI566Nv1Nt0DeG0KItldlWk8YB37INo82xuMoTjbGuReK0RG/rn4vMP+pBtbLEP7W+Q6E10m1ZwkfDLhnjBRHopr0P530EaGEufy2xLmPpr2X+Int5s9k+D1gMc0TX9MM92C+XgmiZjzRjBp2e/TXLHr2t4f2q05GM6Wu0kiju3Dg7d2QRplUwDIaFseBuOlkR4cYIvM5D1tE66mFB/cDnpVCYrHGIxF+KxbxgvHEtZ2/+jbAFSmMsfeUyCDJgTPUy/tEptvKjdXdgyZbMf+LUn5Dw275npd+vQN4Xx7vrcvwVdF8XKqNAqJxnkTLxeECk+Dn0QFhjw278xbPkviDIliZdfaWccTKjHj0ljTKGt7KeKfJJrnU37V8wTdG/HDUYUsWhtruOW0bhIsr5TZbPrzRlzJhE5F/zUfK3aU3ZK8YrC+mK2WR6aFTlM1623mQusXdf9myTqP4FEjdIrrundwhGa5t8C2ulF6DUucaBgU8jN8qqZxxUzZ8uCKEWXjkXS7aLfcaLDutl0UEZFMF8zJVF8IGroim1sWddKE12oUaq+TSIKyvPE47ul0fKMEipxQjos/hRDD3xUiDtmHkd9qWyZdGjFXm0IONs1WV7kVD7Xwf+q9nUJb/Z+Eboht663bpXEwmGMLztXq/P4TKFkXX6GZfpWXa0raa2ghHAp8IVTcHmlYNP945G6AiEJTzba2YW8GEbL+r7ezCEKT3WFa7MRr92J7D3mIpB66CX+9WPl/0O/cK2gS5SL2keJIkodmQUdRMsvqQo4nw5ZMWtuhoB/MHu5kvJb2XPJp7w3u/Shbt7zD5tPpEkYGC/7CiP1Pxqz77WVDjgO709h86cpuV2A7RAMA2sM0fWvW7nQVDhaA5PyXqNpx5Dl1FlN1gxpKtQ9aksAOt9Spxun3Hyceym1vTCLA/2xrWxDA15QGSTXAWLqi9kuoKmbS6qt5wQyz6mwmf/7HeWQTOEfsVGmvaTkUpTIQegEOoWG4whl1LGq65cT/S0OOx3qF8rvRRyJKT0caPEM6MSkYnuGJz4suoV6x0VDM/Ezrn9sz7S5Y5K5Vh5Z7MVIDOtETnVCDLePslHbdrg2gq13XD68ZjzWWY/yzm20px7tsD6FiHO+2N6LeEZv0Mlwa18HjR2JdcWWN6zvUOUP4XrGNq96JvCsjr23IdEY5ag/FGLDV6j8KfDTQx7/gKXlKAJBQUmj5K54xWbqvyxX1FUZwGrS17YM67gv+KXINEo+h4CkHjr7ipD1xTP35LiscTfmvNawo3+SAQDyd/BXZSnFTDJO0skdGdckCJJAea7fyAKSdkMHHF4D94r2SQuva0Xdi5yxykKylyUde1y8Z6VQS+II8MiD/lYHYjuvy9K8K9/NmvM9QIwM/ZLcslhSJ3ii0cLLzpYpCHsibQVr2Y8avrwAcuZ0vontjpB8aGX0wb1DKChf1JArdmaQOktytMv9IBSPZuBD63iZR7ugs0h3I9+Ch3sWp8kHfO+aX6nV3A+F9z2xCNtWkyTbblw87738FDtn4p+zf8RcE7nT8WzTLLVqF+NJ10zTa/OvXqmOmYfkzl323bVj/AYpRgajJwh59mTo5pUqzL2KdwMQdIC7rVvqEOGLTZDyX7LDUuK82X16kLp1/VZuKRWH4OjBcCsaefgJQc5ZbJ6WGZf8yaPk1Q0OMT9W9UiI7l46ZNunbaVMg+DSmyjrVH7DecIWgtHJu+IuyDJkZ9OIj9pwyhwoaa2er0dIqIHqXZLQ3/B/DnTW5qGd8KZ9mcffJ/lOwdVc5UVoRtl9Ui00KIkMITMdA7e2FyGXpfHyFxBdvlsUPFt8ni3IXWddrKBj8KYVaMt/KjAIw7B80+EFBEPBTH/wblGBRlGe7OMZ2tchcbCyBxUeesAjTb4aGALVbPyCANL8f6tAgfRlfyvasSp9NdO3Z3PM/L+SkSPBdoxzMWqCdDr1Sd9l32v3/wu4Zz+bICdHKWSVW3BZI7U9b1/HXeRiBm2ec8spawoGp6EOmR5rM+LUPUWEW+Lxm7HfcyNZkQj3qnE3QicNNfJdKjJT6Cpex8ZXrYXw1nb6b//IFcyVcu5ZVSD5nFfvqqxJDZxPe8NupJ62gArch2lzvwJYXQUrdrvg5wTgNon7jeePH+QrIkd2Yd22FajAebWrXTwD1clMz1fqXD+sgSSnbKLOTBVwR8bOyTShyHYQvSkumlygUdbbHrTHDF9shYUJIdYJMdhQKF7pqbD5pOLb68VcWc6PG2MEkEWzTOTMH5eDcIn89wBVr6Qj4UayYzbSlqaExAF/su6ZJezaZSO6o19tsARRR92mcpOXhyzh68JApkfktpP4I1VUdeqCtmGPQ9lXZVJFAxuyCAyhH/h0coPjUI3VJhE7Lq7Ogcgmw361hub133DY+2Se/VXuEgv9gAvp3PiyZW5/T6xyf0PiMW3L0CeClSUbRuoLtgkliAgt/Ob5Ysh0+RfiqBOojmKjzUThgCH80uc2aBdu2wN5uEjfmFjLi4ij+TybV5ZMFnm7pcHB/u7/awCSHxrQmflsMcuCrCHNRpH6lHF2xauG362IUjXzdWgCaaPXx7NjiN/z4lWzBxr1nzKt2G7IdReHUp9TOAzH7KmFR9BmjIkZIu9byxHLiFEUV3h8KiK2RSATNUUnWHcYl9qQrouVOj0nb8U4tsMPS0v2PKuKVeHa9shkr1XA/+fZhtjco1w+GK50ALTpWThKsBAAIoSAZ5uqHYVVUT4MfYiabEKay6H3F82ej8xy+5tsLycVlldiq8jPgt+pn57SuqM0wkU691qWt3Ov6RZ0A++WiwwLNiFy1w5a14Fx6GHb5M7G1iVo52PkHd9WrfR8JPIduV4YK6UywaCD0NecQMI1SJmvP/TutItKhR+OEgWnAEynS6Tk41zyeh48CsVLIFQYkOspqneCF/4+YgephsoK/5fmAaaVXb1jiZYyyblAttPb6B3iWzlomYONQcC7VbovgNwv/wMpuxMCut5ZxTupG4ipPd6mBDAmIETyAxRi5JaP1RKg5LkBQQm7mEH3CKi0w0Y/JgafTheb3sUUP+y2P1XUXNacUkpasrWdi/EbVcshDPf4ceUlb9SpQDh89xe0yJ+t5pIn7rSiT7hmM8mcfEcVpJEdF4AOn8CE+udUyhdr2hrW94QGPw2ow22AkeaukOI9vbln5lr1EFwk3pqWhpXNaecjcSj0qvT00TWZV88X9lC4YbmQdQ1C9AqGzAePaI/xwZ1osYB86k/L9B2HKquKPeWH/Np7ObSp8W6gVfIBiI53WjOGFFa9RL2EMEIZqIiHnpOBV8LyBxIDcK/0F9Zy/ontTH0JJZlpkU/v3khMehsf+/9AKBxYqXQx1D+vhqfayvsefgRul1TIocu+CFe2NwdVl0I7RCPZ31MEhPSQDHoT4n/SKehPJ5LHX7Dsu3YTlInHWZX7uw6+9sv5jWkB6pImtDNkrhFANEOUkbFOG/NzJsEkd4ip2jjddl3xCxCEUZqYsrfTwSBy9MrW3pirnKNDiiZbr8pFkNemvfrVmfCPKI5+hSAlKOHk6nhZ9Ta7EDTFDzIWEEcVKXzcOnI7Bwl2SRVehx5OnfGl5jCtv04s3EHGlZaqnly3y3xMYw8v/mtklUykwZCLsoCMzq1gNp+rL4uJFbyje+le8Nccb8xshDq1MoGk26teavdeRA9odm7V4k49y1/k1ViHGv5rhYLAsfTtpH5otK1b8GlLSWpbfo0pQdtUpS0oQ7irSQv81A6AfbqF2yY68iqpHYpDgS9gKXUQ1Z0LHEISyYG2KdoQtI2K8NYjfrq5vTMVpGB+m47SLSLpDbSId5gY9W369rKMu97XiaJ1lPX3ejFuE/i8NE/GQdye6CWGyn+vpf3zaEzOW3v0Yy4uJ4EXnrDO0nV+Bg0mwNpmI9App4PY+5SUwmSwmWriEZK+MGIx+C3hejwrk8SxM29r+Hj4Wpj+vkgMdkcI9ErSpKO13Akyz3/rdhY8V+vJ7BBHAPUt7je6bfeIM8yP5KFcA53rtf0519idkrypw+r28TMBb/B6Dv29bGi6ZT/8yP06jYJPi402WjKgi0LxBKOxbY/kyCaOIq7QhiMzdZAD6szwAByaWAwWQdEnpV/GECsCakVv7MinZJ9sPL93/zXj0qtHWh75IHDX8g/y6Ws4JEOWc4Qq/9kcSBhwR85tNKQDwmBDOId4cpnn4mBK7z0chOe4ZVF7zJCab4RWMCYXwIroa6WKAmVEmQiTeyXYDD2NK3IMyockdsYksKmIthNp0gn/MhL59mzj8YRmSY9dVBgJlLGdkEbC7oG4LUzM0R6A2A+OpFyWxCq3ZvKW57YnXo8/VoJGyuwvS1/bP2XTArfjHYPwY9eJ/8ZD8z95dGVd2DuMW/AzASO2iYTJWYOx74PekKHYRfDDFjHx8D9Vb8A+PfHUM8vSlRBJEdfoAxQTsjuEY9Zj2N+y+EKxWj7/RA7yZdq7xyhJZm19c/TGZxns9XbwjWJLvIkzZH2C98WnN9UStGj/J4en+T1qBqyU7RBx7yvmppPYVdFV2E2PSKudV3hYgMpkmk/BlDSyIrgKgoRMoouAhTsGX5nIGx9dN1E+FXnsCprvN30qbswySuqbwm/v7zpgtcRX7wQabe9n7B2TFcdIsqDus6+4/GGs+f+kL8VWsDCtvwsPKalWYKDVJa4PpDbA+X1AScxMVSEAOFq8dgMdmM6f02pA8o7EB5kmYLCyEsALKk2Mh+ZpL0hJyYaCzkNV29cJldyMpm1lqQRs+PBMhTuv9Nx5WaiTEwoAsuHj7uEAZg7Wc1ynQapUkXZ41pnJnUMaownYo5LzyHg8wPON7ujyLMiohtyy1C5f6o5Xdeb254sQBL2wOfdCDb6GgB2sIsOrcuTbHD/FHVPhGRRk2pxjQPjKJVXzhJVoRfUnOdCko2pL6pLEuwG1xfFPZfVWtRn9ypBu1McMdt2xrUMvDC0wF43xDDrr6S8ZAMLojWKr+0tP3gaPVLgv5qMjCpq1oCUY2IxmOTcfOGRM6Cd51L/iL1ALl9CpKsAvIg45w1dYWKT0UM7rfeaTJjdQl3duyLTPA2WJZjZJdd6Y0VwWQuWW0cox340y8BZvHofhBTzoI6jPMUlaOUm+WO3SFqjdkGdAMzts4DKC7ViJmOH4CrMUEOwmKKyNWjeqshyH5ofBptBiLvUYy6MVgYs704gU969cL/2Nzv6coM3uS8Dz2KJO8HdAbrYN8BbJIq7D0l9rqI0zihMCNaf5q/o14r6NdN65PmvN0oNsQ03hAe4lunnDurumGt58hPEuJMN4D50YPUyzc0GNktOgg66QmcXU/rBX4nHufAgIqdWG54ofr/2O1U160QOU7Pa3dxjJ6XK6BTXRiWRLreFdxruYOThLn2VszeNaA9XNjMN/lusxWJMZY1DnyimHhNh5STMGlDHWYGz2dhvJA6SNkmJC6m/vZAth9FekZjnb+INHGDe6tjCO1B3xSyozw80BWSvO4D3WZ4tfwZBFyo5ulHk06NfOPslJPIyJqRAE/wMQDer4Q6QqPPcUiFYqInkLOeC63x58LuXDmD3nkT2Zdb1uFSqmzwf4988P5c3/MZwykSXfEBjOeKKgqhkMvTnaRAVEWtwe58hWuHIq3bB6Hx/uQDgEK2JmoEahHGBQNuwnqE7xRGGj4duhPFLIOd6TnOYR9QqNYULIn5mdbwFHzgNlnGaU2ysaTDYjYUAkjhmzTLFksMP/Ydg4DWWxzthKWi4VO/QnuEkN6WhsEmQF13Zq9GbwftG6nFP75zMpVIAq7ECCb8JYvBCr7VXrp/xD5Jb4aXg0fixGj/G/zXJdQRmHFAanBhlcI84yrqsfDurA/78dfQdHgoS2HCKW4Fp+xEqNhDlF2m0MpxsN6J+2ioDqYro6cO2NQQ2MqMZH6MQbGGtfERxgtqREardYqDlSiOdZbgonKjP89PwdR+dnXmz4I+xj5EgtCsk1ZgwS0QtALUAD2khpVKmCWBRmfGG60tXn8NaZyRSeC1o41TU+9qLd4iwrXqgVnsgbo42gn7zB0ZSR4JOWeKiZxmKBvOwEXGijuZ9KZZ5Jbo1aTgoKJkdMjEi+S9p9CRkVqL3HrE+/qyF04Cl5jRGRswpIsNBJrKMzVyS6Hhw9E547SFI2Te+S44v3VFi21/W/LLWBkoigTX8vAaWcq01QL1vUZVo9yejVswH165AQnBun1GYr/Eh6WfYf/Q/FZM2T9qlZa9kZphbOB7Boe/jx8YWL8Uecgn7yOYztDvAk55iQC2fk1kab02Qg5XC+0mvQdvTsxhztT5zJhWgKJGbJkeDX7eIsHOnXhTZrlQrqhikHycgyRiK5OKbxUG7AJiOO865Ynov8KVmGpxhZF4fho/HVSAc39IPnbihZeMrNEe2pBYX1YrC2q8Shs8W2tVRWV0kE825QiuMNonzfw9SSl1ReIwKfrGSnEHwTKYMo+Aqcqnja2Cr1+KfBRkTjBB3XX+TVwArwQaent1dm0qNn3GfmQ4N6+OHDBRO3S69a4NIR6ZYXER/fkCMIlmnbg+wzIYUk3jqrszxF28NejvvtGe42FoVd89Mx7GEc5dMHCcPqquF1ZCZ+B4fx02jSt3j9sCZN/64eBfSLHoD0rbuA6EBLQMKhRq7ft06mIYhlp1EA2aDaU9XNOb/de9c6gjz2LNuUugwbDnktNr3IAVY8pojngjsyKlxyc1bSOFfvryYv6AzyLCG52dTCAufsOHf9fZ4OxgCbNG3rp3aw+l/9O/dfyccCSa1JLoF1R9kE1UoW0Cgjq1zjyJvOX+utiNTWMIDf2mEQdqiWvnUSskXuf1NRGWuClty5S8APrUH5KjONKBLT+CNrMnC/PzJ2KUHqqXHbCfnLb+ijevRKp1mFWaELjFpCRJOU9JrwygPY6OXPU2zXzjyiknjKigPjq07d+qGaqxWaoQkDDsqxFis1vxw52emzQMnE61P1eEATUQVRwB7pdZEO7OGgbRuru28QOztiz2YDyQSMXR2jGCydLZya6StlXJF8Iavhmg4MpfK3Z8ZFVcTjm4ka+cHlyk73hIdfVCMGcI7Q3m4pLYpeQl/aGWJL1rTeULTWB4VJ5pX83PRkNsTFc3Fg1WUx5AtlyDVQdSp4yZqH9sqvtINWx/YQHhVr5XcpguUdBYnH7NUZ2xuTMMA3LVShTLIBgL01xDGVtaHHL0tbbjGX3oLnt7xM3kuQGoceocjzL/xdmJwj5k/dlJARMsiEa9RgUZpYhazt6NaqiPAERaIEVQE/ZecfyeaK2HTUd0oGjh9OwzLBTeY+btkBqDaMTyurHDQTTEVXzYZ3AMbUbjNdYY6R82xPRryn+6oEZUizgAnlCtxazEBqVmYqYmHE5QLZyoVzaEeKJz8sFwmUVobHp1QF49HdnRyA/ChWUIm1UHOuZhsMfYaq9J7p4laGVZlCU6BLBB9E6auCjG+kSDnWn6qnQBiDU2VCpgkJ/qJ18rtExTfhPzYL6bv77EwDvWJSb5lnWkx+LpTuweqFq/O5wvgBOsZg2Q3LDeEYbeQhljZijt/QzEleVqzUHkNqtE7BGnSDPKy9+615PyVwie0S1/0YRd24y63ih6cvl/s9pFTQu6M/DT2QDOVOiKLe9V+hK49LhepHyFSrDPLphLzdY5fMipljNwjvNerWmSJZ1O/w2itRKiJosYzttylkRvU+dNvqvf6LNYrhVQ9DY5G6FXlieIQpeNGrfmibJ+zsef1TrdR/FWY9M2o+ONp5rOubbk1bxErL4qpzb9ZxoOYUAqycH5Tcp21B9T76kB7s9rHgbNCJ2z8KPTd2VwhV9e1F8cDb/4UG+A5ergjPwFMeVTA8oNJpUuGmQlBHOViZa8N0ku7pV0u47Q3GFELc6kN6AcjlWOxl2qtw4LCp1Pc5ELwDg9Pc9X+Am82rl/gnVzWyWpAgs8vILzPAdJKmICynJMNGcxnOpm8rOfYWtexD4FgtvXYUe+Qa5EbO5tT3vbbWLLlAZGFZZJTkbvsKgY261GW+Wr3hvVYajR5Xky09oyyGwRIt0Z0a8wQKoKmRLVLtivBwtiERtEK9Y+bUkW6szdihSHuByIxStE41Y6vo5OimYiYuyeFZ/INuNc5Vfz6SMkJ3ecWVfVXfxNVq/CakdYZ7rzS9CD/8TEV2nwLCsPOdBjhQ5pah713LXuCzqxkQW40kLYydU8pKv35MQyhsBfXDO05Ezx1TEByMFC4NwKNQy55tnpkVpzLV1TZVpfXhtmPpYrxtNEgWkerqT0HJoEaZ4M3us7sg1ozuvZKTD9yBw4o1AIUqUDrIekTL980YivxGnYdAwd3dr4sIWoqZZaudm7igGNvEXYuWONrP86+HmIZ32PIaoegqnSFYmH4ZrEDbC2jhD20WOv8HQ9rihKZnvGO7oW4WcL5rLslK1j6hEBdce8j41rY24AvLEvA1HTSq3dT5aaZvklvuR9zxu8dZVUh5BqUc3+Y+y5565k1Nff9TQbqSNPmUL27/c37joCliTMulAv10k/0GW3YX26HjopAtIQVzkGkK5cAdQY6iU27vMInNAGmzCVY9dIu0hqP0Qunqli6YEWVIajzPQYWcmm8lLqUpQxm+7W/vCnQUPq5mYXAvrAM26HBDxlK3/wXQ2usMmF7+Ac7HyNUejKrnegZ7GE3APh1gI0x8P0zpAEEl3x586PlHeJ853DUCZr/AJQ4jfX/BjnT2DTpcQrtV/Ewg+Q65T+1ywmW9I92eWTbTk+flfZ0zG+5+9jQpoEDsgpJz2N4Xvb1V46uR2YbID/jBJcKKW3aBhop6mhNPuG9pGiTypvHxnTAgLTzN54Au71hv5HHK3vJguoY1QPBHR/hB7Q9k62Lt5wT39RyrCJiK5wWvvTYxZRZP4FsA1IYlf1C7+9AAM4+0UXDR5QKBqs5SIN1YaKBSD0Z6JicvirWxvr2OEVdGP0ta6ZFNZydjOA7PKz4zkvvz6U4TnUSlMXHH5xi1uAZUAIGIOqwRFma+b8OKgpSbHEAwQZAWJg89qoTGDs98ao/FrVJROAZoZ+NYpjus/3695xr2xtrxSSfXp8VnGIEHqmO19MlZCUzVbaXOcl9cIsfHhoFRW7bLALrIX8yulg5skWaiYzPrXjCp9UiyDZLttfu/iaAkArbKzGAp4QHrUBQr4rUdyFJQKdV+GmXwxY3geQ+bQnLiT6rTTQIVt5etFPlLv3lLQWSTQSfsESVIMhd95JPbc9MtX8IVQUdbOBb0KmdnN5AaFmJgaYGhN8MUK4Go5i9dOMLxvXHK7S5zLreaFVEDFOQBTQ0X+V//P/CWlVVZzN1bWPKmob4v/2d6b2tIhmZNuJ8vsuvrYC0RGUavbY/rSY5RO1/q0XgNtG51rYn9wZuDom6H3wQ3Sk/qonGannLliG/LLGxfaZebmqxyfhV0Ht14cdxs22g7b8mURImNcV8n2U3++UbYmTMebO+mBnbnhZDl6rsjrUNGNDNlbUiRXApdjipboGrqtExWPY6UWqraaWJA4fon05miqM0mutzJaYuS/ZSjW08zGTYpKP1VZkpKKkPK22bjOYVO0fAI2QOkJM6zi0ZyXA9ewc5OpkKs0I7o/Jkw+mLmyKyuFmYYWTiEyS81Nj/pft1vH6sYJElqR2CpkjvuN0tDF4ytzuPqc9U3M6E3zeSztrFRN8PdNGOEfIWalqfmcJ4e+QfzRTDb1/PB9lHgNtRl0FDkfPf8N2FFJ/pCv/EVyP3lKPA8xIJNlIpL6u1jPahKO7mQE7v4TmkNANXfIUDswtnundYhuanYZYAY+JUKeM+0e0fRgIvAGTBjYUjHdLdOUGMaJvHX7sWGY9g3Da3TRAMgQS/cyCMDN0AWpBzcjBpCxGrCDB8g752dIz0NVJ/GRo9jG7tSj/QI6gyax8ozCudUi43vJeuNvqhroGomIcxtzTX2jGFYOeowymDctAK76U9lf61WyUxBlpbPErhp4MMp1dBygS3PCqo60q5Gs9vahL8nDfyV8yJeioZfLU1v3c8kOYzZmLndSEnhDWqc7yBzhMJWBypttn16Gx7ozKCyjq2SKT+Bp8Eh80PvQmwDMWfmzKEBel0e1cSSdiadNJ8y0IG/Lvz5LD+tO22ivzmbPaDnE5JbQH/h0ZQyeIFttQzcaW1A0/S2BLl/0CTI5KYYwNiuekLtrF8MtZtc7Yx/4Izj4fP03hv+BX30Jtgdt7ntAyCt0L+jW6DXsOrq3h6/CABM8TjW1tTw/XZvIRTo4Slh9pIzt+8J9jxYU2NIdpdtjw4BwIWbyqRfhTJJdPn8Pg+Agd0Mv1OOl51bzvydV7togPB1D/bTyQtZppw3AFkyoYvR/XZF2VS1GVUaJecg1nDMZWq+icF0kwP7BsfD9A9xT0Yxrnbsc+6H64Eo9vUBc55JvKI3ndOH1jxLB+KFkddggEjh8iKQbrKp4+oGrmO83/hOnqvPyFbPGkdag/RQGz5KUeEkyguG5tJEnAUekUszk1jtjUM6YZochHnQ+VoP67hYSBSwNQ96XyokT5xmeJEQx+Bu9CAs8KMXwDT8muHOQscM8L2CjpJm0c6cEL2Mi6zsLUIk9KP1iSPG2NByLnBEJ6R+54YS0w8XDew2DSyUIFHSH8cU8nfBnIwsuekKmNFDjLQHdbTvW8oEfgnd/lG1b9leLSGvC0pzRiMsNyYCPpkFvFkUINjUlgHn4BHQFzpCfA16dTpMR91BL7Okussv3SzE/7Xg94eOeCgVhlPJGO0wjJQDNahyzr0gDK10gIz7KyMT1uNOr+8DuSEBtcpCgg0+HqIWPLdkR1Bhs/aGM1GAEZC8VuE3fMzqj1jJ7qCTo5AbDv68BvXLORrLJWkZGsnPt/fPXlVBHbjeB2EaI1zXKF/WKjfqf2X9e0Q8ZOvdXavVBkuY1U4gZpp2KAWg0P8NXA3gd+ESZB3MGVxf0xgigihJSgTE/ZiVQlTjlYyMP1mFMvbN4TNmkOoN0DVEcgtNYi3THSH45IV9eXS3kjsOYyFSUdMCk+7ihWIgAUNcmpsYA3DKHZUj7YV5H9hhHmMP8CQdxZjab6w1YgS8awtlDnZK5F8Cet6ptU0H2RrBghA+W+Cr/bKlvzSSVy6WwFyYfnes43EjGHNn0inljvC8cHitpU6YUmPUYjRkYmCZ/7nBb8jPihjQORN0x4Oj0tNJd/KDTZ/u60Nb7i7plT4XovS61UMnEH6S59sX5ij8N2uncED4Xmz9+5qiGCxCMGjplbTq2bI+5IWbRAEJFNQPcFQeqKqlP2h+nq4YtrulAau43myW7EVuLMqO+7P9N+Ps1RKWkYVbhowcp1mk4fJ7t1bTBpu3oKQZ9Y4H3JjuVpRbeBPU5B9T7IK61eJ6z0mX3wQVb7nfZaqILMH2880pHC/M6YOQMUxiSx+PJ0/do61aADamaGCBdW+s7ULvc5uhAEZwtSXa2uV5TtFpgnZQZruJb2iGyOvOsB8ijmOhfarMdLG/tjIqrFEpxMQlBI8HgrWPNbQjPq7t1w3vLjd09ZlnFHKvZiS723HPESbLUdghPaH1mVz44M792J6CJ1xi3bLEl2dDZn6QJh7mg1Vgl6h8emp0tDsuT5O0kXV8xCl0BSUbCoaJ+tdpapk0OcFME3Yld3dVCytfcSQkEF5V015MzWavTAwQEm+gJWxIUUFp1sypT64RFqbwM160CfrlUD+TgFWTe/B7Y9qaAedSv2AWTm28KORkTVRDNe7kmNv3AzMilriNWUkKIpMb0fZmm/7zjD0MD/bUGK4OSN+fsV3It5eHChXxxk7woE+R66nimbNeMZ7pzHtPnC0JlXbj2Teo56D525YUbBgO5lseN0QgUl++/XkHOlmGEg/dmO+G5YCAmboNCXhIPtHNsf8ES8w199ooILgRn5VHdtbePjOZ4Q5Z+W5f0MayO6v1csXCCpdsi+PgFb/3Ar53wL7oJiQG+LP3l5VSHLUh4otJbaxsOzCXksmYKz/MIzfxIAfy6pYk4on8nP6nri+ifqPq1N+wyjwOP25BlsBu1dd49Vafrv5e9i7ked7g5HxWnSG779YYxZN4JKkL7aqSUJQTt+Qv0rXVu8zDZbREVKZto95Do6Fhn8VWVaGx0yru8rMeerd9m/pH9HEnUO9fmtfVOgDL+4/kRSI870Fw/dWqOiZ1NSPsBeijQyx3pcL6l3HC58WYifLJ5LMXVObj+AjL+vhS1xVkcAMMO1XyR4FnZ4T1Z/Ry8S1xLT5y1fRPWxH5jCXMJT3XGlyCq04498HkmiHBEK1pjHYsnbNAfrMI5B6EZ0lAp/JX8SqE25kqfLQ4YS1jITpDRtBkRVPqxRZHS692Nm7KB923HQ2q1iup8su/67D+jWOO57xvKn9pV4o94WQDsnRGFcraGCEgHc2jzWhLgJa7k5OEcFGqlSdNaPk+DHayVwNHZBYq9jifwrN7kfXDtqps4IOmXJ7sbMn7OfgJakoAvfHcotbwA/msCjaCInwQtmcfpNCOaHzO02sF1VInrmaKjTesdYstQ1VpiHgJyq0tNYbKkaArEyIDf54K5/8tvDK+VKU8I63uOe+lFjRU3v8c0WDtIqGn3MKmojfniVKc6jHZhNU2thotu6NmFFoxLIujxmTrO4iNGKxt9dcCQgryoF581qAEEPCX1z9T3Ieh7dV5NmFJJCxNQdtbDwRk0RV8fBagrLz8/fZpFGAMVH5fLfbgvCQ1qZ4659aRlBBzfDKCAPlJL4zdkliebdYy6g5WYJ9Dd8OofxuU6WJ8Ee3CwCHgEmb7TLQKCYaIPcIwSYu7YuJCRpm8v/CzTFnY5mTavy83WuilOuSI6Hp3Sgb7SsUkn1wfP31eV2xJTD1SEby/rfxTVXyH9Bu5VSCrqSn+fT/GUWr0Xvw50XzZE/dRxfwxW3+x8+TR9irf+2QBc856OCggYTj/5o6JQwwT49GhJ2iqKEZeSXgBdTxVrB+DA9eSjqau6tb5Q/LXOZj1XEbqpM3X3/cFhYjS4PdS2CgIqjKP+Hdo5kC+HBdLbg9CLq6G0o36XujmCgaN6ls5hTiXC4HAYYoAdRdi35gOv7+LSAzgk2nZFpk42GZgXyLKtsYfHgWUaDp8k59LHHzh2Inl8l3hbMotJTzviUopnorLjJL4BFsYPibgMQ/EBl2LcuSElrv5GKtaWEKSdd6oXfUCGUlMF5iPGq4/NCH75yUIxQFvOZtVzHMkcogf6Sk+mBOv6iBZLJYdBqmKOgwVQggjCiu8TwNHZbGvCkOki3qN3VW+kwkvMeZcgb8ZMj3z+ywfnKJvs3JsLQiYniKNdCrZaScsbf6nw5ayK7GdI1fPUTMlims06gexw0yQ4GNh5UBaNP//zWzMfYXrKnJ5tNqKaeKM+W43BYCpS1UOkRsNeZkOl4Cp8TiVM0rguTT/bYkHta5jaljd6JsnnCUVI8f6BCvVcgoE1xvXTp1LqN+SDfcFseov+N0UZc1rAR8qKCjU8NZe5Zv1FBJfeUwVUvKGK+170A5tVyA+SbPwDgewpvH4KoI4vTm1LeLTa1D9Qf9C2ktvHaDTH7xcAQnizKGIfwQbAcr069vGP7MP6wGd2Jzw2O066cZShih7hFCMq7cC2CTQbpLdMf8PtGGIoLRpHhAiN0aJBfiyahI70blxldHhZuMynniBKvs/5kmhezR1geTtIUl01eZD82AWnNoRlDemBCdvj1Z43HouPo2q2ybVO8LndQgMzZm/5Hs1A4ucnKw6MZt1R1digAMriQK/sfPTJmJvT37YT7N5zhP+PR8hikZLkLsyypgECHv1Yti6DEVyTaFYUG9PDZwOJS3M3odxkyoJdxGwzAJTfcNCGT1w/Bxg0Qa9lc/XX5Cc0mCSmNRsIX6ru8pI7dI00WTtNwyGdzf/fU7FofIimNmzgNBjkEZX0KM+EKIZZgESNhBHS/0BIDSHHVY3RPpmAGhADDpDROFqq1cwHdrGLeN5tn3joM18+tsg6OOpPpgD7WMQHGA0AOdolubf8vqEEOVqWz+KvwgYrN081y4WG7C9vT57UwSjmB7VF+HP9WaajqC+9etukCvmDVOmVhcnvI6V3kgzzN1GZS1UngABBK4M8L3h0lMD4ilMuQRd9zQMsGyg7g7PqvcHOtesw4ma4+JqPer24WZWhJcLHXYQ+YFJw2ljFFPD8hm+iL+Y8IeQG4Kcq4QneXKbPYrPKtD9sVb+brK3cQDPptzG9z/y39bi+rz82fm83s9VGQjMIHPugg8twO2CMKoq6Cl3TknBD9C/Ufdmg7/qaSD0K1TQy2ROVfhzd3w22D208258wKo+HlQ6H9d/v3+r0M1QnNey7KNQkrT73dgUZkjJOLto4j6eajlJPx0g6bgYNutLJ0xyePuMC/5mJyJRpfwZDBteLiAtRfwEPjf0leVfhpM2Hu14kHZZEjKSYLh/Gh0LH3RvpyDUm4VNIx5nWc2j3gz+eTNBTdkNIfDqdlir8k37shXvh8RSJKslRMsOqI9cctzMiMFQr8CorAP549119oxjbd1kQggrjFeRyFpiqJVfA/0tDFNMJaKWu+kFXN0FjB53haFEgL2bCBr5tZK7EUO4/yX7FN4tmgU5uOP+gkxGY0Yv76fhDA8YjAoEiTl6/G3lwXFG0FP4RXewIG98yIHrhHf3QxN5gNsDZsslaGrVV6XSkN1ZaNMOzZSec6JEC9I8wNA/PKvPBaG1wIAidPN7HpjdTW+5MVR7nJlZV8BlY6sfRUE7JODNJ+EEigFOV87WRBWn+4nKzevca1r1Goz1Hg4sHaSp81IpFCn4FeQw45cNK996rGU5J97vP/ah1l//UyGJzkJNS6ytD+sJklfE1fsB32oGta9qFvOi/3ySheIgVbsdPkqDfsmkPYENyZRdOnXPi/VFuYSLEoq/T+Rrgg4AHvFR2BctSyGnr6XcjtxYMpYOZIQJ2FFR/PzPegIL+zFthmT0iF7RubAF+f2eWLyHhwMCv3cn+Zkdc20h5uf3OtC+jMYft5ulIF1V+aCJs30FoPLoDzG9EFECyo47dc+i0LkjW/Iz8Q5eq/pTaCQVeL2glObcr8rG8wwFcUgg++w3mUa33++IvaM/v4BnwwyW/v1gcirxTBcNH+Y4rPHrIAjxFe3eH2j4jcvDy0WCEBkl69lcAZsJAH7oVcQi2CowgSyxgMdmRt6e5ARV5ont/KAZvaEA7qQei2AhCqFEwukA0Jij7fU9tblkr5akZ07MwbGOFQt4xBxEAzShzdteCTfXlyv3CjeTUtCEzVB7GMS4XRbPOi4JsBaWQBJrw1g8Zr9yb89kSx5rowJUs4j+sBARdasO5OhfRol9Wgiw41516ZWz9YkJWfQz9aPLw6s0j79Jxq7JUl6lJ2VTlkqc90YCYb28zCe0xSnjYRJkNqZZCSSzR9le56CI/hRh1swIhnJ9PXbIGK259Lqg9X1ysW6QU5RNG02HQv4sz5z3mhQkdHh/igqj73xTNq1UDrxYimNLnNi5Aa0Io1wPh+hqEvowI2V3bQbZ84NXMpEo3zz660BATAKAxyB/J5cZwkFxQlA06U0HIxqiTO6lzQ/gVkM5KFQPefkgRrH6oDLcViSjLvDqIvvgGQkYszx/rnP3PwnfCdu1xqL3jior/EmZhWBrDdX2PvANzpYuqJuoIHC7Pi74D8e3FeQeVmgPcnvaUsW36TdKU219Dn6TEZHSpoJN+4RxyO+JeY4vC/uznrPTEEOFXL0/XunrZt2as8vZOTMWQRPc7XwxqPooXKRlpGibGEKHDsoWvAaUkGm3uUpd6sp7r2EsyM5Ssr7S7POIDJsqkCLEuTDZk7SB5iOW6ixV2SsE7hN6/WHEWZZih/w1/1zfgiwmkoqvuTAp3Sb0upfKy+Zo+cnjQFMJzGqpoSMwZ1KWD4z2iOTfoAksZ9aVJMrcq2HlpVUe3vxOR8E3ndN59PQOrDjku6I69WmviPV7v4jeKDvfT7KDxo5Ers+nolPMzT+DXyMWkNbbIKHHT//Z8LqQIJclqFD6JvnpupwQc/bcCxa1b8nHwKUCX3PIbrQTu95odj8MFWkAcr0M9QrJ3ISnQcqy8DVa39IrWOAKnGLMP75YSgsADPsc/ls4wY8cmPK7fVyOW9q4sdQI0Li6Q8+8aTi/cgVHtyRShtc+A7v2zyzbg/MSuyuJT6iO5Y9BUPSS2+uhg7n5yLoE3S8aavAMoY28ATJbzbLBmF45sfZcuv64SaRLoAEKFMyLNYbQ1bWnmfQxirt9mKOp8fzU55Z5+6wqzBHJ7hflErYXYR2V9ILDrWb1x3JBGFrpe/Zd4oa1lrreV7vYRiacKnU9yFaoCg5hk174aS7JJc6pfhOtd/YOteU5yiXERfUtweir6HvRufaYm68rwYRETNK27+C2/4VLhnlW3Xy7t1ZP+uCR61rKn3worQnj5dhq3FcscXatzOrAQ9Rxlqna8xC1IPJ7uBDw4TPLRx9hZZiZbIKADT3lQWhDJz+9rk69o6dX+DsgTWRvu5FOxd0meyz3+5mMDXFC4UFkhwoLOEFAN8ySyA9GBe9Fsfkzq7VkRaQ0HD6sQE4dSAxMHOqcqXno3zTglfS061m3/6NlbbgDMK16rINKBAPwPVNv4kjZZzfRXDITF0vF9pKaTKo9+CSUaZS+ovMqq8ygZbV3gt/BJRS1neaCyDo9fjSgOkVikYWyG7EA642GNHxK8hQEbchk8lWdNMkgHsBWkO97WD0Di4ULyPXKGxCHu/cdKfFf1rDZOgqwBPLy/gRvZJXkoN/I3ruzPS9bHr1hSWRb+buXs4XzyPiet7IsK4z/UNTktbT/9/3yZpoy9Laldn6VPUAp7zeMZUqMlIBPZL0Z1W5NFOqbdJ07cLY5gYT7/KeQHsg6tvhc52yQMRvqXxk9+rVuWDKcfCyPX9cVFmNHLnhEj7f3kKPla6IjC6yG46/1yZPrArvGQPeqjIxt3sB3xpp/ExOfoRv+pEn+yfN7ugCSOYTfjr8kyqap6JD7/5eDhGJfoFZbiFPCAmuRFyuS/SB0BKug6fTcP7Cb+1xOeh+IRl7ntIKufl2J65noOQPd2zdHfXfDllWA5DZFExJ6TQVkZO5JcCdN8LWmDR7Yye4VO3uJubDTS59WbRy3+OTbg/fK9pGMp01pU2rRH0st+LbNsvLDZNTKvXn1UsQBGY+oNbtSvp4ioRWDMoztAfZmKIEq1foV0g+zqkiYKDLooK2/r6i8GnZq/uUxda37MrqRPoWaX8kwz7afKgGlX+8lWMC/dVxwDtFm7N1cKiBIOe94mVEtAKlpLjQy5vanu9r0SFJ7SzbglJWkkZ5kfEn/3fbBrQAXngwewud7uWTiSWzItXbstMNmqmEpLyTBfpXhdC/9XOoGQulXBGTc8djcZvFfSxHk35lr7l/Gxa/b+83QcJJLjub3Ze3dSDH0H7F4BnMC7R9k+vTz2KdOERFnFKVRyTXlPmmyG5W9MuhKTYHLp4BcZskgV2bBFdbllCmM+Oe67xWe3PKaK0jR9FMZ7sEWVAt+8pXlC/sd4q+SlR6mQ/UjyeTgM+lUyvOa4GUEUWZoBjDUuxaGPfOAAwMegs6gxi+RvK52rtub+4d8D8Izapz++C9wkH0DJVXskcye/Y00uubCZqprscppslClh7f+v5xX76rY9OTK+7ptmagMFzYSTFtcYIMg7Nj+yjBSLqjo2hcGJUf3EAwmBIkMOVDqEXXjpsC42CogFfxpGZrglaEoKkoy9pcEGthngLey1YmYnsijVai23IMYJyTcW+Vgu2iE7SKlYuh+kCdNtCfo9Mo7uPMevF62/PUM92j/jqghFL8AwsrqmtIARni+gUWRIs2RUaOkePfgnSwuEoIJv5vZT87+jvi6H6Hcm/oS7b5qNGC95GDDbCSB6YINUmv30emPJFyyvUldDnSXmTbpjufXz7CibPnBdjXRdkrcbTqOEBOdSNkD+0u9FW2K9SUN6fCSOx8VN8Vhm+bVYR4XN6ODuj81ebHCu90IbQicDpc5Y+esJXq9etuUiawAYydfj1+9/FQoWLdC6zDOpE03fYEtniDS1BeVfe75/pubLS2A7zZN2TX9aGOmNSWMMljiYis3AeDEjkmhRVSefi9v0hxXtkHa+WZVuz5ELTwHel8NoZAM5EaQ6KpYj3/cSyA44B5AFHZ2EH83UfAsZeEnVH7Lo1Kgr39j8CCKXZma+gTexFc8D4TL2/5kUORYZ0bG2/CFfdM73ddSBIZdsRrgQ3As9z0DhVOjhVdO9yGYnMl2W8+VxWS6mg7KglT4S+3bFFlG6uEAZRb7gjYXo0xK6pzXv4mgQQ6bLSJTLTRAhw8oy902NYC3GTdxWGQkPxj22z6WAU5ab1e/ucik6riDptgQdvX7/4KwUCIk+h2V+GpB2A+LNVV9E97waMALyYaoI/le0lPhqSsHh97GyZi6R9o+vttfWB7wFPg6IfTNM+9Lqf09I7kSOOM0KULze7KSGYsYUl7WDWscukdL6u9KKXkCv8oQY05Y6j8PUgYcfXEcvaYlfyCTg7S+KFZR1Bdi0z6AzLp+f3p2aO8kGRIh8n9W3+mwsJ+RPnHkPKOMJn7A+cZwFSRzU+WCYfghxlABNZHEiupyE5vfdDtT5O0nuX45n0IfwSjPJq3yAA2tTFSUMFASvovBWrUVjPghcpj1VbWLld8i5JJYNdKcH1h9pofsKo/s1bFhxBbyiprkjfLNhQm4yLf7+RwStUjFG6+t729GZOdpx5bNYs1L70J8IMUODUNeRhyXYWNuuQPYjKHjk9CgXwg54lMiwxkxsHvHM0qd3rWcDl7VXTVgQ7KO/8wvBc50uL7d42IWs0VEJOQ8WBo7uCPA9VYPOwqA6aaw6drqsD6L2owvBqCRJgZ4XPbGgREbNUqPPym1ft+gWs6zyxt9QkL+fLAtm5eGqsgguK/mukKCr1G6jTZUJpm6CmrdD8JhqiVZSh+UTMnpy77MzE5Hs/iQBD4uvceKsKRKpyODd9vKPqn59iI28JV++MAGTB4H5UNbj0nrdhzVQuw74CMkFCJSiHRWziyUib09YMmYykoMabIgkaJOe8YQF9uBbHG4CEJsiGWDHa0ZpbffeqSadsQWRF9ktd3f1haRAJuFg57MIIQEAMuWMXqpsCB1qpQSGS46b8/05zbyEtrbu1RTnDZc95w3WvMOVV8w1Hp5txhlHbICFeqLf4NZwHEFe4Nun4K0WK/DYlYG3utyYk9IOWEvNmcb9xXpo0WCg1Z/YNUigp2UvoNjElxEGzwnCK/ppYeTaszvRTfIN2KTgnw6e8q5elxiS2EfSH6QbUbljsRmLCfh/3RYYYWiFf8NaxW2Kp5MRhCh4Zq6eBDlwUE86SyRZ05egVhjJUWD7FvfM+mylcMPnSVdWFr+XlsAjz9odZxXi67hZyDTEhtfbu/D6tMyc5cHOBHKILDHD1ynlV5fXvr7F9jvSRbGFNtn+NccBK2Bd9fDowke0UpD9mAbdAhs4DxmUavlyU8U0RqPkkv5faXGe39afkJsd+BtOXPchQNPDqKvVvw68SdDAJ9XLJeYJR0gBh2EtVrsMqQlesGtjUAZRxbgSfapBdTruCNo9D2dDPd6AiiI5k9UctaDElJRZmVneT6tNwM9B8Z0otr/qV0JBf2r4I5c4CZk4net/3O3DxjQYpMtzcUQn/Cgr5aPj6+oxb56rT9gaRc8n8Bc9xrzQq8X/dHdJoKA0r9RKNGxA5rwOGIVlvLuOOtH77yVhW2yqvFNuKpCdNoy1Z4JT6qpRtIFWoxBclyzfl9Nrp74WKCBl3X+TfKhCRuB8j05u/vDrIabhr4dQmc2PITEKIkThftJoNQThb3rNPdu44Pth/Y13BHguo+fUXuBQQnbqJvRuuVwHElhj58GIHrvaXM2QFaqBXuI6B95hIC+VstxUHkQjZvB3NqStkOBwcMHmEOZnp0W8/n8cRqMdJRl+eLs6jzONpWsOToa+9IuHAdpEt/OVDizkbFQlJ+aik5u9rSVhL+t7bGzeuNlSiMLxmX5ANa6EYIFJrjRatrvHH5zABuVisZF2r9/3saNfXmCP58yM/ZuKVlYXc8xZbU95jXFXJu2w0v7QXGqpIEmdPF1Giz13cJFb6sYQzZKJ06HhG2NxaR6Mu7zxFtNYGv9BX7fW9q0l2cSzi8Z9JQIKtTG3A2SCi5uJyZYFGkxRh0qbyFrsHLlQgTJXtd7xOTKrlmgYyUZgeM0QApZ33H5iwwJ5X63pLRblJ+zRAOhOwkJhENatXxMvSujiQvRlNyDSHCFaCwyeplAoKTKha0m27wUDsYOTvsfVIueAHQdbi602H3jdJK40l8ZHMRHnW1YMb9gsV78c2Z6kihhRswZ+H0HIpwPRr97iYFR+9/gVgM8TfmCHRujaJ8mGf18ZanGJm+lnFXTHUBNB499wmqJ4oCBZ/J+U3EQ7YynT6RNOQoiUCtjV2bXaJdf3irUYt9sJ91bmJl9ZGkApj9gPvNQYmQW6jv2rrSkLfCsKIpqbAYSL5vQqq1gRKK02Mb/JkENcJwjQiGSIaMi6YxDLWgSzuuiu5SjGFkJjVsok7/CKztmyFW+HxQuGtsqLGLQqecVETGcQ0B0cgGswmcYfvJtdyaRY9MgvBH3PS1rbx2OhjdCb3dlO+b6UJx2ZszaiQVb2heJu5Af6eLtCRd64X6kJfOTcGA1H7J6U/MvESRQ9Bdy/9DAJAoNCOZig4bqYLVagR8a+rYg/q9hEQG3yDAckB+CQ3JcizhAnOxQduhysDQ9ISa6BBSCjnqVpbPdZqWpG1xB2aaFjIBo+FDTUc1FfnA3yEOfLiCm99uBA2c9RUBXQ2uwRCn1yuU2Rx9nS87+jMhmA/OxXrdS3Y++YcT3qjwqsDcj5RSfkad12PkDb6YTLO2bCVWRXfCFsSGvKwUypNhRq+GWhiXFhO5sQy6PS/tfsVMeWITOHfU0N31V/NQeYa4+mDEN9vlq7vWGdvUBOD5jTG8eTJniAvYaWi6wyl233eosiOPAg9DO5nDjXFzL2eMLVze3W+tWYIXqsFsL9w/Cw07C2AP4pGm2IgvEXjReeZ0FHJ3NRjlDL3I5r1qwPlRCKllu9C9L0s8QkzInQONom0JDZI4AeZzJ2MfWfNAlERr+GhcDVAGlgfGMFGjAdC7SlRr/X4yj5nrFQ6i/mKYKrBncOXRyUZvKSSvkybWBzkeSnqeptaKMqjythSTir3YrZR7tXs7xR2zHtKzlg81hfwrO3aYVXdIH8Dh+Fi60gB9jCaX9jnSCDVYCb90EORYhqCxBBHoPN/f4BXuRYE0nhvYZvjziOw+GtbaALqS9Z6QYfZ7sJ+XbSUNGvuz2goOVkB5LAy97Ije5KX0yYTSH5uV7dPpna1uJGZd5aKeagCdHRmC5FDdwo/r7claPnlNSDcdh6TQGKikKpt8KEriUdhAH0wSoR0NjF36Uh0uanQ4MczwgauTFPd7K5JB3tHwvSrjDR1m/WhVuxvQaXxzJrYwcIpIcmy6UEWGLzCFgUCdC36ZJ4Nh73e9NrnmtUYLnoTGRtK61Wnc3P4i0a4AHrlB6eMMY+rCt0Ztm4e8M1nGbRy4Bsho7boeBsB1S/PLRKgQcM2qouv/lO25AMFtRN8EvOg5eLLZVnQklpHRN3ois5l40YuUfOu5/J3SMQA0A8vNIHvUvhfF4hRWA9r9uzvvMImE6LEftZupES7I3wTeZRhkYquYMkTzPhw8KyiV1xrbdVhE7TXftv7lXHGK1Oa1/E8QADb4Hvtcli7G0I9lBCtqULmov8q6WzjWlzyFUoEH6pXNkuIxDoRma+PMv4xxBLJYqCpIMyJui7ksSJRbfu8VVq+tJuu9F4xGL1HP/gxmQUdXIoyIePK3T3mi7PSFoW7EfxOddmNNIAVvOR5PkO7NTpj1qGm4+m8+0GSInOS7d8S8K0DRl5yBTF39/5cF4PLUlk+C8H5oZrfU0iy5rSWMi1d6nKG2lBKsEWC1cCICNaa6uLYBSH4fPTsIZL02qqf3/pHt9Vm31SFPMyiHGUKq44zTbn+kyVy+FLtoZ2kaO4prdLLAQbzzfuPzqLT0GtaZm6ad3Y7LMaOcPWwcNImW9k1Rww8Y7y6H/sGSTMvhimZ4gV5/xxnFzoX64dM+sgfnCCziR7/cWYU+VxHYiVL/Wdyk420YlWXJqCgqnyCh3+TwQXjY56xJy9GH5g6tNYPoZruO9tK3/o7ua6RMQEkWd/VeqDMh7aLwYGQt/HIL9RlUTL/dV5JQ1iABMeL5qmgVTFd1yKzKsuYk6zelkmYskaGjsELN+qHZFE9CGq2ObZrKxc6lZwVxlpF4+3gZC0fcEZs6laJkB0p5Df8a+Wo8/PSBDMpstQco8HG6inU4mjCA1X/fXjxIZhC20d9a5aNxEYuyvpemqe0zQP2pnR5dw0mndWbW/uw02U/sifNuQFCv6+/B2eP3i6wxA6h0+UEOUhnt5Ro7tW+cd9ClXLJPP3HAin41Z7BRHkuBV33cRTr3AVJPknVavE9IcMyzJ/mvNsIHRumEfEWhFC+qybMuz6VQyiC5LzfZnCW6B4wp70jAYz2ZyMgJJxyhQ7+9dNoikBeEFC0pkQHDUtZtLVGs4RLcRNT0pxqBLO9V7aVOpek+gJ+2SGvWRYWgLHoAfz0j56evPwVCREScxzYEuxu07X/S6VNc+fRuzIq6Hi3B41Uzf6yrofjzjkV/g63lVwBJFTt3TjLx1oOTfYFN58nogzklz+KZaKtLsyZwlNIumqXbZvGDbd7FgedTx83S5V1FkH/WSbIkfEea34LSp4Kkc8z0X9411pp9lgFkO+UAen8NkED6QJ3mU4cZ1z1FCFn6WnTrPR56OKfbxWKobuslNydd4VsGJShufx4XPrM4wvlf7faLd4EimLVaSSPCSYzQFjOSuakOB6X19iUxqfCgRiIterPrZYqLQRZU94QTRPVAeUPn2jk9CMGQdwklWMp1BiGGPIHHO8hSdCHgSO58OLMeiqgOPcxJFGq9VAHyOeKVATWlAie/93Qcu1fKFbGX6/BFuVQtA20XheOgfpz0wnuDThf4eLCppQUL3XOZls/cl6l15F28/AOv1RA5JlfZC/C2InK87V1hGItcN5E/yYbOAZ46XBB0qoxNftBLrhUISyKSv3vswX1/jAH6joVuTDERX0mZqq3AWDMLpv6DAPE7tD4+Nv7jNGhdq+3MqGI7xuKTqpRTTl/uR+ztNFNpbXubppUScpQg2ldOWU4MdZmYi6eIYtdvheXqEzzrgUSD7g1DMZzJg4xN1UVlCqjUuHf2HvNxek1atCnhAGxvRl8e3kzWWbZrnz20/JTit7t1Uz5e+Dr2p45Cdqbtq5+k+/YZR/BcopUqskyt5VAAkJPmNfZyl6pcybi0x/m/uCmfCJyYJ2RTmMwIfE8x3wURCBVtkweJy5x+ydn1DwZ5KdkPsm1MBsojH5+Vzb8LdKOzP/WVpsHaUF+65flY5GQg3hSiJwFojCSb8bK8Qd43lDG3drmi1wHjUn+w8KOJbNy+oswfwexBvDk391O4wU4i5yBXKJax8bFRF9AD08F5+xHaMl+Xrz46iELE/uj+bQKs4axeUB8uabTl63luhvnBvFAIleaLSu2uYOD8pyus5A6rtJszjgHf7/rtAddQXJmYKRuPZgKn93xc5BUy3C8MXss0gj5z0ooCa5mh9P96vMmjTXdrdWgPTh1lUQNU1yHv3nQQ8XKjZXL550W+ZP5hImNYJFQ7L4L8q7d6S0yA0afI4OIqB8P4gbKU9A8AXFOJke6hdcaE+i3+Em6EUb/l05U1jWWArrlzqGsIMPBSFTFwF1wcKd4zkhrhE17NBM6tE4TLoTQ9pk2fGNiygt/ExdDINkr7G544Fl8dtQEMSCdD9eiDnh4jINkb+0v5MjUO+Dm8edFQbKZ0YpFAQbrQjL5EzVDxlpd3oMXXUPhWJDf0i7eqBWlZtA9BQmtD23RKo2aLecanOYonGrTpqQKe5r6bNGh9NA9ANdpTW32DGZfSG+gwprrsQr668D2lHst0rYwAdNT+mh/F/dM2yQeB2MlCUGFlwqwT8Vg8ACQVYkOK+Z+apqFSmyGo0ENkBS80/G+Bp3k6ngGTY+XlLGRNUQWeE4my8mzopsxlAqAQlqeU+5CN+9wr3IMJG9w7ZfpzIbH0fnL/TuwzZOt5xBfailWyR5S2/WZ4UDfU49qqc6f0VD+BNw+TvmT9dIrAMCCCW0ZdbOGlw6EAua+3hlCz9l/JHEBvTvuJkrMhGnBV1KfXNJBapUHAmzaLa22qcYV1U8UQUKyHjX+SThEP3LylBR5wy9gQhEYvM7vxHE/ezgGoNIpFv1EkGlI4rbDvLB5CPvZNbWqYPA2MbsXQE5GcnlGLKzf3k7I75lomdSjx0MhmYY9S9zAsTtE7SDfKM+lDwHAR4vdKDrwIM1+GYsks6X6il32U4R8sYz/BcZfFH5iIxGqwWSTW2MxUPpQaiipdQ7bvSAClgbz2LQNKUFsrk9Am3DO1vO4Qi9vpxrodmd7oI6cJ6rl7nlCVINOT3DT2CE+jGToeGHNmC8tuMGNNJS1gSamFSKGT9sTwqZ8Ar2uAYT4U/92Qfc/4Y9cRKX9xRIIX2EzD9tYtCGl7kTKurJZXPUY6bZtGL3vA5LqB8IcCBd8XiOk+5ueOyYeFhYdB4MsqnJU41ZUC0KG+jyN4Yodqjuq8GoL0mq+cnwst26ADDOsRxRwTnQv4jmHrebjKZDB2RSc7Imfc6CQFM1fHl5TAfVaFjgk2ZAuk42sCKViPDuAxe9xcADwGM63VtuvYyTF7HOkh46DdzVAAbn7micG7l5NY/lKqg7iABSBXJ/fiw1JXb1JN6oSetM7cL2/4RkriLqEK0jJaEvx1MS+lnBnmnmhAI6nIsRPAatWqPGjiPTl6VtBCW6EdPPQMulhCKrPJGtfww4RXN3VIH3yprsuS+TX46Nr6hB37DeXDCMIHgBveg9GThEOTkqQaRxDj2In5BFQtbAgLyqi15v+Oe84LMoF/kuVwrxTyCA7yjUYZ2Q3LF5q07K0QOlyrBbWc/W9d7n1NRjLL7XcrsT9pTFQsPbQt/E/s5IBqw490d/lASs/P7dof2fE8f9XGHQa5v7LLyUleg/nBsF+la1H76QjyUeovE/72AlXHtbI5v77hq4jPnPtFCdgoIPbVvyqG1JGOLGfQevoa7npTUAzJcOpcQ12PvncGTPFAd6SRSLxCVCSuA26S6SrHQiNxH9YV5hxgIoIOocnXdUynm0e4xXq80eJVtRkdNoWJgnOJeqWRfoaF307dJpe02yGsCOQvaCi4pajd8u74vAORbaCSNV5vc7umPSEPVUdar63T8Dbnc7iNDNXfGO04BrtmPmtq8PYPfUbjYyZmcA9rzR4jRSBdM20EtW+toOBXDIkE5GGrOzsHhnVBtdlr2gU2nZ0uundc+s2rv80/DX9YGRekRjq4erQcXkUTLUD/0do2vKGW9UNkvH+lW7L+3wY0IyXKIgST3t4+CZp8/4v10J9mGGt3pyOS9e5CaeMPwgJJQFp0vRSGvc3Iv+ptnEHrjKmusGr1/37UOTjDu+n+seaHTCjfECDfJ8GvXZVLAET3SF0soMHpNOF3XhFKmvDdYQGUuKLNfay55ggrAi/sHIyISLUsZiR9VB6M7v8sw+ow6dP+bBXtXzdWGtZvwShrCgK2keYxRVztRRUqQ9RA1JejTkC6KswCwx9t/GouUo74KEJ6U3T46shyNRzdjn+wSqYcBVIm+Guff+3LTU2ImlnKtu6lJZ5goYbI4nO9Cz91ilzUbaVXE3q7qcEoA6gPwuWfTwV2otrH0qbUee7drpAwjw1vRJxDPSS18Xqoji8aTnTzJKxfef9vc+QH4qhIEPkEeWHsDYdOKIDhqPDt3NXBJkoYkLSWMT0vwwFT+S+8opZqoWrC6ZEtF7H4DKZ+J1SeGEhUNQm8Mr6HIB6CKiLrHL5CMziaaTQcooZRHUt06oMNsU+YWHE2oFQWJ6LbZBIMOCNgFqUrpdeIxbRpxdKAbLeo3dTldv1rAYbtDeT8AFgJWWmgcTW5zRWBCgVfjaJ8X7RMg2My7uUPGSt6WC6Vw599JMe6X6n6gzHkVPl33i4dhLHBR3ZrBfxyIVKCp13Wk+2PCx9y/0CJmYcyAMdVUSsXJG4liVVDHnxMQrt9R5gW0gIZlt3903YAZul5HeEiRXDArfdXJD/WPVXQevUbSGTBxEN5umyL2rchopE8U9oAHpWGMrRGq3yI262oyWr2LEKwUtJLK8twZ2f4y+iH2BnKfB5JbYSOWZ4ZLPXXW2deNwe52+qt8+H4DoQl5PCs0bT2YAoc2iIAl/NBfAEqKJBECdygcrFPi/Mpy/h3Wz39Ox9p6RfwDhCuXSmtJzVkeulkvqIizD6M6H4iXB9g/6Ki/sRcVWqjeFgjj7xyoprexkwVwsBA7dSRDZoazmriNiaPiYZkyjIk/O9rl7JLkRHwmI8UkiN4W4XMsOvc++FBdEB0kPxpNCu7m/MYlVBgQR/7D5n8yaXF+a3RPTKUS9PKJpoQBAXJDUwmt3yBILmsp7MA4v3iDO3Z2WJ50PvE9dsILqUTSsrjcuHirgj+1oZuwQ/aQMK/XN7GG9HS2Msudm3adOWVlvxpRfVNS4LYmiS92QP7RqRupnuFW3YZ/sxBJXoHaq0B8M5qv3bZoazNVJyBI+724ZR6dnJrTmo9F8puorkj8p9MZVmpgOf7ZQueL5z1TWzpszmFNaEP25XPPqj+mzNZOrbyw9uBTX48XSYC81yf8JB5SNGU2zXh1sroClGNmr+nI/E4gaJnNBmKBx+2kyK800DnD1O8mZiVUfaCBMQ5Kx0HxeJnEY1e5HbjKcvjgu+D72ROL+OnnAZ89HntHNkcTtE8MGRP+DFKz/OuyoNjm3kiknC+XPnwBegBhf0sRNiOvsPTru3hLsfVE4g6k/7QNqDZIWYWPOAIszqjbIPiidKFIXXutpu+ysq1qYE6UEniSUX8iq0FRpNv8PH4a8Gux9XQcRVXbwM6wcf7r5rFRZG3AoZRNGcfGHdHuzKoJNJtdNN8jF5GKNY3TX0wXy2AFBHJzvIfb/xmJJUES7z6Yb3AXoEyroEo+T+DyRDcv6Veo2Dr47VyBYDLCpWx4b1ooyMtVV8MkKdG/MT9aTiFgkS7Kb7gjEyNIL5D8Dq+dR8gKoKtHDpWHGcOBqTGZgDavekKox00CHoXbWr5mk5EGbhZOG28MJ3z1HCZCmzLnOEt0bT0AebKY5hDOWBCaVp7HMQd227OEC/Ve1LUQOA16/57WTXwjB/WiqjtF0GYjfGmC3W4YgTkzlEFZAbdM/Fyqrc/dBeU/XEIliNU5XOgJkNN+GI/1uMd+E0yrAU65twc7fPB0WnF5UiZ9zflKJomX276qx/l5Fi3SyUKe6jqJERs89uNondnsa38POilDJRcgZN8X0t8FoGx30c1Rib5UZ2rudk8uJLS1VPA+2EwnKSmn4FoIkZRRUfJ3z0GzywCv6H3sov2sjdpK1kgSAscyzwemSIoaxJmDmbxcazihiBUjC/Ii1wxRszWepIk71tHXfW2Kt1z7xt8v4BtIUGok9gopspTrl7befBDF+wWlkcIGSw38qLBTMdUfvRCigXx2+RbVwMBV+T4JsZIqSKIXiV4wdm4xvGkFDUp34sP4nh+txB5YDsG9GXYb2OFMxmgxP+jdr4BYVVjbY2PwwlASbQCys68fZHfetgCQSGYsZ9pNVO+nWE/oK9r5wY9VQJLDCVmGB+2T/kKP2wdbZwrXakblpLs4WnTYAQZEHh0gKzuFNJJI70T+PPMyVfThb5v3pRxVLNjuAm38yn44C6TYDyW20M+hFwvd/2El4G6bF5kHhbkOqNmjL+l1xVZb5qa8BfcsZ1GwaOpAl+cxE3nouM/hT+xANmVwfbtLuh1H4EHSa1IDiaGnTj3ps4mRcCRx1yNky42T2JDg4EBHeT4EXrrRA7uTtA8U1zMoGEXtM1XjhA36Gca5mLTAWbO2hI3yBFNDDgeKx5F7ZDygq6X52nUaciBaY6TXhDnMwZQmL++pmhr8gSMPAT0DkWoDFXII5dyQ/V10Ndf/gvCrkr85HtVPG2HCdzAwixY8e0ae1647ChfQ4oPaFnuAw4KFxpnAuMw5nrNbqepqkz//2eIz1mUEaCk6kor7bohHkQxTy/qOa2N5WepmMnxD1ezWv3dAK69BDR3qg4+NMR93Lt0UzeysfMJ06m+YkrSDR4oMo2sU39KlyXk7eyKFIGqW4A7fnL2+QtK4Wq6XOjCmFGlE92P/olcrqB44mAsONJSq8eNRPK2+zAbHSCaUJPNbwq1noemLiNtVfYHNOZqeRYBfj893CDlwwNbwwSoPXazUtGHp4F0zZ/kiAzNTvodF9VBlAp9TegvoxQzcVtxFwhY7riN7FeOfvIJWg4RZXe04c0MlPX/9Rt6X6gTCyCYoIwYP66AFPdaE35NobdQ6i0/D8gi83z8xgqYGHkGTVAlrkStsoznofjn+DovlZIT4XNXqV3PY2jRuIu3gY5/dVQlbFQbQXxB0Vp1dOSi+2KdMH0IIfgKNbDRsxckMtZYooxb69OCQqCqNzaep+E6tHmS3nLANbHWOroKXyLLHcuzee8IP9GT2x6GZ+nvN/hzPVrgrcvFuP0E8jG2bd8uiCqvgp5yjUPQV9Qq6qgvfLsHZqSzyWCVzwWqzEE9DSfUKBGJNmFwl2KoaByN7ThYKKM9ZugBsWEv1oBzlAX1h341D/D31VSq0cUyzQsYYOvSHs8buT+0QT5/g1cRLEXbFUnERmNWy4fXrx/Ck82Vz+bN5m0++oFcFf8RAG8n0G5X7EVgkGOaIKvlPs42yhyUzf0gEPO8ZJCTWKqW+yZfpwa2xOoDLPxt8lXx2k27sgDmcRb035Xw0stoyGKEm3HZZn7+degJJeUwDuxU91vLHT5ov0AQUBnJ/JG4qx1V6rKQ2r6xhZ00oHMmmlKmB0e4OeGpW3vLECDhvYVw0s+vuvx8vCK/ZcVm4638qcy03apSQmR9cP71m/+SJH77iKoVZrUQvQO8U6fFiI+p4qeNtzsWW/ayJYDid2t0ispID+AQ1ZVMMyNoMf24dU/CLdP6lqrFA1lVua/LRZvwU2UeV1JQYwM04DQvokF4tUXjS6cnKK+saficKQujl+UP+SU5NRwm5oFBj4L7QvmdX5KIC+EAYp7yZXTEUvmrWuJpn7EscpRPwxUopVBQjswvS7fjxIZNAzLji28Y1Wbvwiqbz8I3slIsbGpx4t75Uyd0xLhWiPaHvp3gnKNVJ3WCZ+cM5siw/e9unJ7rF4BNT7uNx+mvzD9GYOsy+N//IW2gBHVe6NNkbRqhCb/csKIFG5RlKJd25LOY/JVtDAEY3IRPPgrOep7TEZ6/t4xUVVjOH3NHLbhO4HmocVwtsi1k/22J9spt7RmkFWxSwHpfWWqfA+jC+Q13Q4OAEnlwM54Nt6PZQ9RrDI5v2NQ3TQE2q6E/p9bjP/5kJsdw92Ct8nU94WrvA/eKl6K0MVxKNJLK2MYIPKtLzJALLt64xv1ZdTMQujbHO/oo/YsfRuzg0/XswLTQ7GvVlFvBQYjb1Bq1qeR2K19z34oqPWDOntgPvrobqeEEwa+tWiNO2kaWZdWMARummVeC3+c//w/61fI9V2i7UUqUoSlSoZTjJ6T1DO07KvDlIQ5n8oHiJ5xl5I300Sz9ctdNoGuPO0U917cpM9jxaaTFFO9fRqafauAJArjX8OY12ww97rmf/vxVJEelvpHhLavzn8fe40ijJTS39aCotx57ZZsSTVUhHUZHh2UpfRwS5Gb35S+/ccZai/ltdNqMGuRP79JPQP1DPzHXA0JhuMwyysqn277lZOOW2iuWrAdl+kiP+XZgInaZ60g7vf0UmdKwH6L+Q5cVOlNc/yZ2hp72W+Gx+jF5NqHYX5x8UOD6caesIweofGSSmTJkHdWtD6L92EXix81z2YZhsR1chh9dm49okzmpYSR8ZwtRQWMBdRAVnocrG1AM5ee6GGcx3DOgKNW2EKNNzj3htjZfNXjQIeasuAAiEa6W1ymcM46nLupGvNnfr9zH2oOptSZiLvNNEZ6u2w4paSCTVbQgZslB/vTePYBpyZK9QnY0axt6hqX6IBCD6NpABJvl++NYRP1QehIZROEqmd+o2c7VviZQpFJhbCSj4apZyhXW2UDlS7ubl0TZdcp16Q3IkS4M9s58ZnzEM+vFJ3pdfQzeOrGpdDXUxceW+jJQHTz3zRfTVrvNd7Xp3JoV/5s1UH0qDsddJ8ma04uMQPAj6pTjHNyetofNRfIEJtX11iiTNDP2r2dGaAgcC0WWJWBqffuviPJvSOrkVOci1/MdfxUx5OmFA4L0HIg59cFZ1phJlkXtOy+CvqKBvXgMHe7iy9XMS7Lw7nqHeQy5dLAgc/ms2z0OT0/JVdeGqtz60EAXRYajT5YISqvIDqYuQqs4alj1I1SfnPseQTkmJpSULYGLiPvwIntencYlwarcvVjAuve923Kqn4UMnBFdp4HDipbxJb8kxDxrXjgLUfQruUZMl8L+v9PxnHjx64DYUTf4s71+ygvMsTEzvLhATBDgBUyRMIqhpetUgCeOp6WZyUCpyhn/kjLWPNfaynSzp8wGeAiSWR1IocaJvDz4ADmtd3S0cvvRTrZXMQ36VEqqL+HgRuxsKIdwtBvjKt7zrMBFgY3cX7xSDGVwoCgUWrHynoBo/7YM8bECIZ49Dd/a0qStSHx0SYh7ie2R9wbMDSIa3MA9hmGYQKcdu1nq2cdPb0yS6D5kC5hOiHhD31znhHiP/4CUZWvP9J0S0mCPWzANZ3DpBWNAaQcr8Cr4yzQ00KhylqEA8NZUDLSP3YSaLYar7kXbJ5fR8Tm7eiiU4IXa5KmsPQkeaemmhuBYhAGNqhAG/MIy7AKrDOtY+sAp//XnSoVspDrMHZO3BKx3r1NQQH6yQRl7mKPSsvs3d9MLHkBw7qEsh4uMMndUrBgQxVHv/PtQKzQQCAX7lkYaRkXd251Aycu+xQak48fj7PbPO8kHorfqu9Oj9bXIMd+cQYNtGCN0uuCyl7FWZKq69UQjUDcKgmg8o8vrVELOJIWHIEB8tT0yBiUBmPKF3dbLffdLZLB645NLBlT6WNVn14gS9qWUo8hmzw56GQnGNufZxCHRlapKaOs2q05MbRwMeSqzXFTsWxHz477GkPAkjKYbjeLP5ouqWAFcKtqzrQ0RRPbZOPduGsRxFrT8adrQsvigjNv6ABlfu5z+W446Ov8Nyd4hG9yeJFRr6PAPl4ZCb8rcmpJim2YoG+HjXPPzn1sqXcavfhtuuSwp+bsHIRB8+GNfavwJSXyiJNyMMHETYtvsarLkLAbSfWDQqU7vLUuKveAumtOJlUOr2s+L8snS1VVFZytgi2/MXSTjzqIHJkPTp2Z0FTWWg7qy1+mJJa53u1P2PrFOwTe13iDbpGB6GcY218edyj5iZrJ/XpHgcE6C1BEt7pjsqINUWT4qTTEBtDZxNcOUw4FYyd8Vj9Kp2Mwh83JoQ0HB/QbdPVWJkmQc7yw5uFmAAPSsiZUny0l8QQDWRZezU1sJYV8E/5zOyBVDKYfEEb33JUVE0AfnuKDJWY1sxI5QPcyCua3wISNf5bLFK1JE0A6CZlmW3fPDi0J3AG18Olbg2yjtY+ZHrrh26PYW85d2GrrZT9MM2+/yCwbEKS0VxQG4c8/VjoHtoIH9jZMKGO6/Bv2qoK2Ph6Wi1TlApZ8TELEscm83lhUaODOC5WjNBwDK7kitqDML+RNvvLV8Z40/lu1f71vvVNf9ZwjzcBRxhDJYB1y342p0G7vBu/WV/DAVYfCmQh/Rp83NXOMb6siffP8eAStckOM5hUKIXu4WFWu9vxzCsTYF4+Gu2+8yCTdszmjtitc+FTU9++gNea7zqXK4JO40m97fZcml9+Zu2mBiYqTcpOLoxokfznkXH3bLspcGurS7+HMSsbPBivVKKkXSFi5MXbINLQa0u6pTB71o4ElYDs5OL3OlKzCW4+CBTn4HF/vTzCMc0lUVu4FlAZOoN2q46VNEOTjcn8tH50737F51JU9BH9NrvC7vwnXQSCa0NQb6CiH/vnMbdHqmPe51RMPeiXcljLf2Gdn52wIL25obORg2BYpODv+WObp2vt2P0XvHl6ZqYYFFVnJajZjqm81W2B/BjRC8QZgAIKxyk+d7/Qvr3ez5KQ0ZYNeKBq1blwJaE9ym43XGNfChmLC4+Z743O2WR49yrDnemD5uiXGXjwQ/kX0QhbE7RON/ShTgWE52pUuMqF4ESqJdWGsFBLX6CShVYBr7X1wdUaVUsSc3dddNL0mBr7WTa6LvuqbM92cQAofQOb2WmPcZNzmDtv5TJDdVnYBoUbCd5UjbRBX/dU5lABQN8BCKCBd7/HYz2kMSXTzLQp3Kw6OxM99pGQMkELKsluBmU0GrIL12K7ZgvhcgUDsNwdF9Hh/kIoyBkk3a7yWvtvWxmKVjWf2734uidMvywk9eviXnUeUkc3PqQYtpkjy4/pt/x1vZCRTfUuxtR+uQr/j+H4Vjm4UUJbo15gyX+oTtvLNTlmvkc4H559jFj9L/0x6+oSINfUCBg5pfGYLMLRvaXd11wzYqM5uwbyAYvAEX5GLGpoKUZAaocByg/+IYmGYu5L7EQLumVavvgkawrF1xUkzMUCJOpFeCzm0kjQLmL5FPzaOcmRjl9+HzOSyjlkprb9EKrA+/jAUFWD4/pRPwlMJ5hy8yxfEmYMzywjb6p/8qevqm4Pf7gkXuRYYyPfklXePVcfayLmfRQdEU6q2b32qzlVOV33/OnaOLb8s6mGHJZXHcFjz5SQ2il977gsL+z/y6urejIrQRjfB2Dj/hSE+CwOn04Y6lUgT9E4TgVC/+C+goDAx63OBj5LAfTNTDLyWXiXgBvwZnWp1Ue10iLtL8tDe0/kK4ZZWA6Y/+pjMTxSMMv+81ayjUsZUYhCNj41baGme0+kFhAdo4wjDSGENPTjqVAFwAa7v0GBFDTQ+j5gsqAOb18osBqqfkE8hbDXTBn1jcCLaf5Kme9sd3BQdJTlg3Gi574TjLL1WASJZJ2qz9Ss2MvBVi02SQcxtlvDkRnMTR+eLjh1Oyjm3KVStbbv0IgQljzPMO3iNw3zv4EFGPomPtlRNY+oU23OGRfEJa3HtL2jzB83B3fxAKibZFdiHoKI+V6EjrYsBcg2V84xeyKRQhzh43gv4lAR1aioka1l0CKYdGF33KzfvD1gcW81fk2ZwMMubIEGs0kNaSO05SmGiAY4lq1JGZL/8I+DS00/EGLP2daGhrjVJvdR04xwWCIkDjDzR1ix1CVF1Ht/aBQ4l9taDFBJEUNNaaKjNCL2YDko38SjQhUEgbvCbwbxZUJGaBG1eQKn98v+hbHfS8Fs+qM1jozHReikueq4j2jD2Oho1x0EEPdHrFLh+PhxR28OMvzAyYpb7DRBtY684ig3bSAcN7PYIpHtfUI1dxi93/u3NvH0E+9t3Co/lPmU4zFT6NHt8kMhVAbMxI9Lytn+PaAIVoA23FZAGWYUORJx6neL+eIc4Poqn+kCblvUqA4AuJ1YMzxX8Ha5cw9g6dz1C0pDNKMAJilZTI26vqOBWwhgfqaAp50M8pOsHXQ82J1NxZRItNjS7G4bRKKYlfaSQx5iY1Id6AUd9ZFTvBXQ3KpvknhNL1ONjw8A9UckdNa258lvDymabdhzjm97Thi+QpK1tlscXsYayow==]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
