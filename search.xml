<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! U2FsdGVkX189xhozl10YK5PFj6cmJ8Ieo/asu407+6wLA0i2BsOrbeS57P41vd1EK9T/UiPg3lXzhU2PH9Ybji42NbqgWqf4M/lt7jrywuQOqAIQQzKXmpjmukyW875VTHlggPFK6upSLBoRpu427/3QMKZebYT++NU7o2ryWZiC4A/yiF5AxzFo06XevIn29jX4XELi0vvzwsD+ADSyCY8mEbg1Q6vf98GKgT7e1A2rLZ6r7rNvtb1lJcGOluoHQ/KjwM1EtMwnVuJS/7kvQYbieJEnH/XOqwNiBG7aZeoavQqm/DS7ZN7HmFihB8l+vACL1jWEuCYginvvKo0/HHT8Du8G59IsP9qWqekqtTdkM0yFL4zsghFrNv/xnNlcsKvniLwW9PN76ycI+Fy5XooDqt+RDv8KS6r+L80AMy0z2O+6mDWNokhzAmSRk4/odjoVdqBsKKuivc+EonBa7P/ZRYNbhobXTsUO78dFqDl868ia2y6XLWHGz7Uy7jxwaujVRt6iOca7vu4/sLr7QrC6x17nL1B6a1qhHh0QPFXRDGskSj4Zw4YBLQf3LI7k6yOdTmrH87Ytl5VHqshdsxCgKbd9g/ECoPFiL/qKH89P4W9POGuIMBm3Kc2cjYKVUoyvcXCE3Icr4WTOAN2SSW0IORdpvzgHfL/Huaazkx/1Vu/iZxr58V6SpAIVJzl/43G3PWhz8BTjHCvj2UHn48gC70nRt/cBr/4nNDAGq9YInQo2C0zpD9/X9MrCXOIb0itCBkA2IE3X/rjEpn8SBmfAiWb/+E0K4sja532nscmPY1vHbSGan2gdGIT4JNcsSe8pnGsP0wyKffx5TZ8L4t6Z0ABELKVbNXlaBjtf9Ray3wbze5n0x+qu6OtyUVm44FvYHycHnAWDRn7NO4EZc6jjTJ+fgva7r3qDPj8/xAVx30bdKFPAbvhE3vo59ny+/4OZAzfsHj2OuZ5DUkzNLYofph0RCHPaTvLdfTubiMq4j/Q/D4FLpZY8h7AVg/EwtbqFKhLlwMQl947T1KjS369VR1cEp/oKcYds7/sP03iw6FYt34rB7rsk92O44Woz6RwGkmHsQbQV3tvXjmL8AckqBI2nBJ88ZW7CjZYrIwtVAcZqDFshzMhugfo0nw9AKJ3oKMsage+YAgsDphZi0pB65JdIMIOwQ+ENjmjb50pMIZQOwyNElqEYx+jAv1Uo+Y0PQVnEZ68Ep1/gi2VwTo3/XgkuP//RdQK1saU+EBaGgZNrD/gkonsW86WfcBmmibBTY7O4E9xi5L281KhPWc524h90B5XEEHM+EzmHl3kIXTO+DZ9jkrYQyPqcsrT/t7hHaerje9WZq1yIR0bHiG7pJ+ccXX17IG4VuZz1xhoNDzkJdDUbIpRa7zhqLDOmhvpkdxs+P7P9w/4kDLCc0WCG3lGYZyIqAKR+gGARxbAz4A17HT/9REVTZcZ+zM6Qxs7vQ7zpkwMczh5o2fU9DFMRPwZAcnSQXheZTuhAO/qsgocm4ZeJzKmTUc6HUYSz/Humd3/J73OE84dij+V0ZEIu6d4MWnFjRhqw47xUUIun/pDfCSVHAGKlO03P3uUCzS4TX8ZcXfvyetLQwBcPKesodZd9p3zTmNxQmj/MImsCcZuaqyp9UAXtzq+0SYbDlY/pxOl6NWBYzvTivCwZvpTIzyuOxB6ndfAKraSAc2AUiB/C19DMR5dDcDsmsTcdRsW4cE+GmDw1oXCAOzAnrXwM2YIa4D6fXnX4gn/ZL9q5UV6H8fifVMgFxtxgEa5c+kzwHHYqeHU76u3wltpUui26lf0+VJox53jAOStJUoQsgsZNztGf8Z5dlMA+y9K/DIjdGTmHAzPNFV6EPdottgDBshKXUm5QTZEWxpcxrZH3I1PMtqHzjNygtzX8LCQ75Q2a2l8tzYk+LfNEp8SIEROxxP7xXVIOd1w2hKxfRzxjYVKL0QrvLT2ZnA4SRs42ThyCuclw4+iV55HgCdQ7lPlmOlZoQvPqU1gejoWjFyy0t+Yc4BDo5DYe+nG9UQzXXdrWTdLGOiyu2dTHWMcnH5+QNi8ijvwCTx64rRn0TmQ+daXodCGdHzkCxwCxWvdNRU8LNMxqf7YTVCETLn5f4XoveLa6xCzpTfGFwQu5CPZas+HQ9eY+WLTCUNvmJ09Lu2kooQoLbtwrXJcJGgzPelneo+CmuHJ3Q46O+4sPqYG49rgsXtPZJqY5itVXJIF/GR1FdWi1U4xNNtHohSQT8P6vw3vJOjHFjtaxLeLcxPiVyRRCHGbxqTBeGsy1sCcmMzGb2rA8+ajoXjTlbKOZ3uWgFPU9Zv3MEo4NCs8h4TWg8OPWZEcOtnhzYLO3hfPkuaQ0AjQkateBd1i9lQQl5GdaJKm7Wh5QwRbjDGnAJ9104+DGX1MC6I521gS9Kho4j21+3rMTNPmGbG6ka6dVcm6Gex7odI9Y9A08gUmowL+bDrNroPSn4GsrKJFthl3gZzgiM9szA40Wtu3n5NlvtNS04y5a8mDXwgbU4YuR058Rc43ZXloTc0RJzNi9GT597yjncDq2H5gzKyepH37OLkgdTrHAxxJg56fewhqT6yzQcAxxBPIHvqFroPePtmxUjnLqRnsaRnlP4aEK5tKo9Q8bc0xnYDqXLbeNDn4l2zqnABA75Sxiys5MGL3EKDiBPS3THxSDv2MWJuVgnQZxR43sqYREbQmUMQbjVSeKGOIzPQBbHQUOa+k2+kekVur7OhngLogK95mjlaWG9cetCFcdNDrCsK0Co2+V5X+MEUCM09KBT+eIoozJj2rbgUwWiLSdiuhCLgmFj3tncpxuRuGUCjyC+66q/+QetR81JmJtP7DHv8Mzewl8wKRQPEXcolXwT8XBb4PXJ8nd7m5YTA/zmTchj3isuK6tYn6s04HWPj+MygsxWSWnaT5VP2WlBIl3bUe2T02OR+UCCvpvaAnv9nM03Eq0c1ZrFwjsVyV4z6q7SwP+fn4tzefjSh3uLa5OyHWn9ulKDoNb423Z85TTsdqrcfHF0TKgBVn/OP/rzvCupjRbggoLmBenZqdr8zwwGu4aAAoNi/KTkb+Wamp+/1vtQk5xoQnri0iUhYLlSiIAicRpEq08o45UpxzZM4evXvUFoCZRbZzmKMNm7WMP4+F5h+3ipPWALdUorXqj8PJk7s7U553PzGQpmYFvL1JOrDW3zK0WatjkDMgvFiANleloIEQyLUVu1FFyTCJNfvWVnl/+BR48zlBn8sqt8cq0EiFS0CwWUlI/P3w8/CRtH7om72YD64dauUj4fSpdsNO9FxpYbbP9CsBg5R810J4Es4X7BKWah/nUdAYVnWHI050IfHqgy6yXM0/NlH6XndC26NXURGiy76oeG7TBP64fvlsDA+eRQyU79jfUUvCYNt1FUG+DlFwt6gMwQTtQQffCr6V3TUjq8/H7iv8eBCJecx/2T73WXiLY8c0AoQ4VyBtPp/1ogq9O8oINmGtew7IwmrdTrC1HE2F9xg8/pb9pXJOcR3bAwVpBVzzVAOU1zpd50YxqP8T3b7G+6PbqxIxoRZAP6svqGQ1aNbE5LYlk1q8WC0EvKF0+/o6X+XVY2VVCyFLpbl0bCvy91FmUcBkQFZmFDtnT1YavmyGk6G7qPoHjDwK854fJVnldF02qA9EAw16ybUMOMNrvE9JKRRCLZWwQxgKDgn0vLYu6rhCRGsgTzpF/qIFGbtw5g2wh6z86BXxddMGc+LQKVJEqLEVsK8ZiOAbZbMbaMxfojMcyQrG85zcyhZXx3haQ86PxJqqiifyO2xnTTb2vQgN3gWx+eVkQA7gBuPZFq/lfdK2EDUsRyOlZyFXdryUq49pyofWmg6MVM2HaKblP1vUjrjB58ZvqnVF/2nOClwX2++YkOmmUWiOhR/zdB2Di1Op+fpP3IpPJ+62N/53TIGgB4QUHLB5Tp6oU8laBUcLLhws6hlRQCA3GqVjApf+PZYD8HIJeHQNeRm9b2IIgy5NKDNu/ZqMR/qINgzQjAPawYxfHRkp9vEMvAwC00pWMVrlfDICu8TVzC5Ghkn1DQa2sjp6thR3DRonAsJbogCzcofZHWw2xaYN4R/3Pw2IehboYGCrCXkQT6nONNFazDbQP8OQtcAxPsnyfWRiyCCkv0Vgv39hOGyA2HdHvuRu8tfDcnD2m/yZ2sH7Fkw4X6vgP7Pws7MQXTZWYlZqNY2x8L4rNVyeNeWJGw5s7Cdg7ZtsBCyuXr71iPt4cCBu88oSR7Pg0P7zpqii9MeHfobXuX9i9ze6zxeqU/s/wb8ylo6Eyu6VecnCs/40KhBtUhNbkEtngB4f/livf2j2kqTcidT4gBmKv2UY2D8oJlw6dvIQHVUNlm880gX6HogzcbDm0crXn3+W6SnKX2z7l5YnfrVhFORTqinPJyDs9GkJ1yUmqlqHHIdcrlMJYWI9dypORCqAzyDRK9TZ7tCh+U5buDeZrbK3UM+xkqhnSbLSsGH5U50IY/7JDc4gL6KA4VTDrwk054mgl/Wg7gGpF44zBfHGQYe6/+Zf5eXPJ5sf0CRY8IVMAduMe36FYP9shaeVtV/cK+Et1ptz4FH1WO83UmSzv0QrwgwLfMpSAjsRrs5H+X1jhIJXTbc51wb5fO7n9ZaL1ngAK9REOUGaXV1ZivT7SN1zV9HWUb8T5SN3XVuC+vghbLRCXBj7Z/ZkmmP3kvJSUh/lgUMiSvrOsk4L1ziJ5pg8N0FNWpj5fjPviPL1A/Tf8DduclJtKyOHBHeboGJbbH7/4zrzLH06UblKJ9mv+6P/dB7MmZdyOYNBRzNsdYUPDYUwUXo5SdlgI0nCy7BBSwlcv1TLLr+EHv1EanZft8YtuVKIz07hI4Tdv/8JrzW78LRkD2fr6NPW5GLv1GUwK2t0zfq88Mao+S30cABFXPFS22kxfiU5HA1VFwZNCMo2CG1wBAeb4U2Ke+DnUHYHBPsQhe9IFGLSSeOrhKUesLLBRQo7PmLJ+e4IitiRfjo48oiuDxPDbKwXPhgm7rW+BOs+c+ii9JxXgvrCkTx4MzGHRTvyKjC3uqPyKiPN+pzgIHniADUnD42urU5o0LqTs5sjQlRiYC1uC7gEMAvD86z8eRRvc6S2f431MntGG//m8nB0TqH3pCtCblt+pgXXX4WS7STvEjkaUf8lqHLgsG67ixsPZfxxMM0DMPJz2FqdIqZ6GTGtsHd4L6gSTfTxZLGAa6MdVkf5Fp+sSqYQAprCDF0hc+3kj5wyqu+ovxGmQNv+ikz4gnmuyl1Cu7VsCF58ikZKl8E52X/fh5+ebAauHbYAxGAR1K7qdVqNHr7F9HXsGAXY/AvyD7WgCWMEV0YQjWH1ZEqaf+uflseGy0s79nmtWW+fdbndPtoSAxvO6yiNpspwg7aHqLduKUgbV0Pn8xrKNo2FqJxcxHJy8CYP8KOIgaa9xs2oOTzCy+g5hx5ZCSlMJchUhePEuh164/o7y19gP6mOP4ok2my34iBf0HbEGzpnl0fQ15lXdTwOFXDyZMa7paMySvqUDahtBZvh66+qzCKPE9sivsxIxdvnAiGfpaQOX/QMWOV4JW6L9Ax7Jo7xXLfLyheYecGxWFCkk7xOmUqDk3F+beY9KMZ3ntxvUL0tIeK7abAn/u4dWeQc43RdzvPE2IWZWwxnBY8QR0o4F5uYsSPFslGxNmgcyOpWfw4U2B5dQPgIhxXYbl9vo0E88izUe8iEzoHrbiXbXiE0lVhJT5Uj0TxTzQiqcbvrtPKMhH57DXd8zTVRxREQ3Obo45SNtGeyvf+cPHStgILhzF3ZYbRS1ZrTZ/BR61GZ3NVhCyeACtxBGFiXCGAwPZYDc3rKt5jKtTwXb7txjhWdGPw2nUd0Zxrw7srXYiCkQSSJ3GToh9J7jSVYWiecJn1hOJlw9VNXs3Xxvrt/eUrKhWRlOmAP3wHo0fbEdy8KLp2Sr+FYI7iLeyl3NJPYPltopQCaPTWj0/BAjrBGzkwQtjL95pDr2K02c5Z1yF5TCVY2Jp+aq5xBRtkRlF1htNCpqDLXS/Tm9bhb/c31TOdgoXZBCuKYFtDsKD2HaVtKDeAgrQAEfYFK1ZyCjenFOe+ntP1KJ+hD4Q+FMCM4PNPK+9tS36KrE2AIT4Fs6TJSUDzqc+jcTXu7DWsEomm8jx2hahIG6DvAKT5nbKax2mEXSVXaj1aB1dWpxDokfjECQLhZPv19TNqVsVloYqjBH17g294qbQSqvGnBYiaRdm2qduLWM6GMPs6L9gjjMFrLj+ko9yeMmPt1BMMaQusaWA4r/Cc0VDaSr1DypW/0Cvaq9uTlr8UXS4WBN6TaUd/UGLdan6cjx8e4s+MA2Kl8PtKle0zvqbK08KNFPT1TzfKM5IylCYRzShaFqdzUJujxs/8EGgsKmDjNlBvSMwS3f0A/2x0iFTzBWtmoDdQ3lkLzzkjEjNlsU83V8+AMxXUVJx2RveDFws1Rxp36N2z8pUajmkA7eRz6bHc/n6zy2UxwMd/V00W5RkaEdoZmMJYFA9T2kGbJ2Vw2o57CsaqtOvTOlH+4b7ZHJD0kpONoRvttICd1mQNJiuRfiMTlo8FS/tg+crk79UT+q4jSE6B+lNQmQZJI39pI9ef6ehU9347eCkSyvqOakji1f6ulNlfg4TRJGqDJ2XwW9Hw+BC3eg+D9RXt0X6FREJiWVj5WbCxBNunQYY/qkyMy1EjWpc/S0u3O5l4qTzuHOCNOzk3UU9JdZbS2rwevtTd0b7qr2bUidO6GO6HpIpgzc8y2aOjUnox1ARam8u0iqbbmPxWx7umKF0/B77HnO3iZzXK+TCRv232i4tGVgodkApF+s9+5yw56zF1oa9aGQneA9olqTJFPaHlLFrXwddJETxgBjwACcDSSN3HfFl6ffvm+pFsf1nDKyAN699RFm75VTaxhumWVNblDtrFmGltNsO+BV5ln67qHLpyOZuod/QoFQE1C+52ebqdjUZXJnVXyEbf0Np5xIiJ0SWsEboJvQS64qI3JLG/+yaLxtWaH6GgIRAbNVxeu/zZAzR8+3OjDFbE9RPoVqI6E0IITKqBT2ey4VPz/EDxHenwL+FSuzJhVRjwsHD1fvEGwMkh7xUrr3SFPtlqqQrIeg/AfBhG/DFt1OgLlL5msJca9ca+IcqIIFzD7VW9Rp4lX10NYOBS4UC1Yst537g9CGnYwCEyQ3HFOmWczTJSFNziSwSUqSpbM3ZTpvVDqgJ4mwLXUqKNC6nV/6VYXRJJO61OGIkZmGPnJQO0rk90F+HOuzqzKMNuv7HTCS+6Kti/TenH3UfvdVJkxHFvfOJxTo76DWSxejRw7ETQsu0UkMdDyXB5bnVC/Efz1Ggej2V2G6jVjLKgPj/aSCDJU7yh8eD76JXOho2OgIjGeHqz4lE6h+GDQsvJG+SFkyk7yXzpVsoofNa1MhX3n50N0P5UoGxDRXhTcN2Fwf0Z+irGoqZwPsYl/MvxXeOwr0gEZ52/8KulH+pp7duduWYeA1noQAUA+YQrcDxvwaW+/3ad9w2o0gy/rQ2x82PIAEsR1ZAOGGzMbN6HDPue/9bMoYFJzKHTPdWLzY+pm85THyF4ZQ1PijrZk5pqWKK1I45e8svqKSvc+wwFyFgP2cjRAEhg0rRvmmKEOn9kO1kx66W6TjOvJKX8haplVG7SNKe0xpCer0wKIwBWNw0h2ZuHDER9osBakNt36I/qbxIX4N1ZvMG5YdW/IPwed9QhccPysFzkODz8KC1r9UvcV5bgKi9COawftRQvJnkB9xPENGRPWkKe+nRYEKHjY/FVEbZxmZQO13KYU99tTx3Kr2y4Ly06PVX17AspcyD2/jdl1hkdS2sNJBxG8exyJPmsU9+83KlzUqxvgyyI5dH/BLVyGCxcaRDWFOaKqcP0Q/6k//wFscb2+/+5idZ0uGouPMe3lP05Ivij9xfaLtKbQIq+P7mnaDiJ6zM8sp9esCCXUjzAKkcswVxSqLD3bDZx82+LG15l+JavGzrLuOS7RhFMnQ/slddlQog1Qu+l82uDucUw6zTOX4vmVzKN4wsZyTP/SUNPRiSVz2UOdkl0IdcqKHDF/XiY0Oni8plfEhv4EMTrKD8jNcXm4YL4t4F/R8pcN+yiSlotba3b16Yk59LytTaD/v/6qWpDwZS6pNq4oXAnTk+N1pwEKN+UK5LGTnhzYUVipT/jNGw8DckvXvZAxyXmfIHVunkSdNCk38+af80gVNQbyNm8tj8EFyqfUISUR/RFN/Vcpuim5KAcRMcmxUI9N8qxBsn28aCjVtRIZIBgfc3PFJQTy+85749/va2Kn9/FpbqfjXPGPJnYZGJc/s/pesABuUqzSleirLgihBFS/sTs62f2+TVqZ59ozNhxovQT6aYFAorbjjNvRE3WhJwhKy2hN9x4Z4slF1tCzPYb2f2MiR13gJ9CDmAdTacqIPC4Z8Njwu+buFa4MoNKhDZmVv9fqoo8j+9YHqDyJbmaYzD0Ly8CLWlJwT5wetXlWto2ikjfNTVz4Q9Lpz9Futv9PHaCFZx1QB75eXOuae9eGzuJ6KEn01fQCdSzDHMW+zau8H/c/dMj8+aIkguARdq7jRe3zQlmcDUfmtwTzaNvnyVWIc60ERH8MjYC5zqFph8n+49xxK73PeTRsHiwapQWvHUtU8ANSslMIkNjO19wiDuHVApqZnSpW1wIiTs6BhaX7PPLtRlJOFL0PC1xAMprjPvOvZV+v8jLpwtRPbavdAF6YmGfVjewOFDf7bSNfXBjYaz2rdDpNgTBgEApADpVMMkC4waJq4gPaUs5K6CnktpRUFe+QW1cwh5PVfxU5onSLZTM3SQnHXD12X5W96hiC+rfmzH+OYxCLFfzQ0HAgWVv2R+oR7t5vwYDo/VwgQZLbn0Pp3ljdVB2aVy0f0DwKMfobU3it0F5JLPjS7zNucZNdO1nbi31xfu5j2g2ODKbt04EcHIlSaUB6IKe1McLbjcxTnwRT1EzBGATRQVkwV8oKI0wf3X+gru/TDLR4aDKG/V4sojGP0FEezj+W1BLmyF65G6/lJY74jAEj71w3AQpZJHoXthh0Pzx1MJzIrCC+IPcWuhNKcNQs7B9sW2G3BeXHJwbTcGpHVw1gteSH1ur8a5fl/EwlPGpgZ+Bp/fgpaqdgkY54QoJ1KzazAHVOgnGRIVz6W17DPfjDmoqpdu0fbmqsMoA3YzJLo4bimjbFNQXFnIcVhufmnV/bHH3WiFU2bNNGpq6eYSHp2Iy9j9Su/5tTsS+JgGdPIyEJ2lkli+/QmZCyI/eoQoQYlQloj3oZFdWGsaWglVAi+iNLqG3WRWKeB30p8jRVhX8+PNVemK5CutC/3kdrA0T+Bty0eOTzBXEddS0Kp84iL2rFIZpKS2YS2rMciB1zwxmgzE3iv1Q6SeHwtIFe7hoL8POayq/z1j6wtl7LjqP2qTMonmk0QR2MQAkqxOorNYTI1/yGGkRRPy4XnoZDfB1la8ho5+/HB3fOvQQzJwxDf1jAkXLiAqWEm98ru4GVQbws9YSmyy6uVHCuHO2YHeK6U0TPGKhftOYxVQXEvisJaWC40nb/O/hJSefhIKW4zPOwxBrCw0lty96FoiBsI8OMuP9tdoT0WhK3V+zClWWKUi9/nTyxyxhvFz16IcggTO0f3V67/6+mtGGjrxyOQWPGKwTxpqZleq+zY2w3E7uJ0dWUTVp5Ifv7Y5XowDvq3yF1mUVAqcuiJjLJd6OitXXZphgxSePNtwplscgvTgs05Y6bmOaMjKGQbcI0Fhxndi8P3Kmc5sGxmzSM6keYihtTaNxQ8xy1+0Qc8ZpiDdPMtw0et895MimsVIl5cmXDcNwHP7o0hTUze1VDbh0H4Jvxp9LNoMpGe3XBRkvcTbYCalYrtm55qnx71sgEtWk9r3ygVj1N5UYBZccMQIz/7IX+sa2926d5f10/OSTq4TvCaVf2uY0aOeEfp9u8luABPPAKNfrBec0uflsPPFPCPeLRe52CDGUkF0HtGkzA/4J6BLYex1fUDdy0/f46mZ9mqOVRQCAwJCIYoLlpSWd5ce4JNQEvEhFBVeLUGys0nmVCPKHrVZ3OfKXZCKwpVmchaFFiFnewJMntfb1y+oCZfk4+FfRKEGqcySOkyWyT/i5HD/SYVlfw+btyVm3KAnIQc/YNRakYs+3R/YTBPukMyO2TGJhPp4uC3cnmKD6HJn5cC0EcxAEUh39N+gbBe+V0o1+yfrROOhb0lB/Ap9AoooScmjF2lCk0h/pS5b31VqUSltCUiCW6tBhCLu+FHAxjO9RWPKJ7wqsX7o02dfiX0vCP57ja+UpNBkYGoOD+D/Z9010v2S3bMvF0e4AVXxuBXbnI8rvmNeNxxbYv8XWwZ0xStT8SHhAhGE20JmUFiOZOliPBtdl6FXb7FNdAp1cNi4w4kdZ5KAEwpdKTAyJiZPy0ZqTGzk4n0oE6sU2hde/5bhnCHqwXVioT/RdOA94PxESa+ZyHHzGSRC17V1Z093NqIuv8AD+sUJOq9vMJ+tCF3d6AB+DwoJtjyb9QjiYj/ma9/Pmow5P8JBT28vwaLOvrZ0Ae9lnVFmkxES5rsSiRqmuKSPwHCny/fxOi6VyBuETcbNPFQm+Nay4AaGvY5JiCVqgfjJAEKf1GaX78zbqKmiU/vs9NfdjPo2aJBJj8GR6yWWsx9rojPnF99Sb+M5qDmHW8jnZTBnvQt3iGPjjINYAuodVTCF0SItYrhl4f+1YEobj5qcPhDu7WK+ZxD1HhwfJYZeXoTqYSIEdG9NbljSSSwmHvAmT8adCDI7dlPPue51QlCLN86hhC3GzPZDSed7PlqrsLENR7lxXXkbN4tdJlEKCSrUhODaUqAklCHPSZHGV8wVkGwFLQv3BuIRq+Osqs6v4JZoGFBqOUL5V1lhvXmLoP8Y3xG3QuiaSKuDpK7UXHyjrCwiAAagF8wlDJxctlvYPZjS8FD74kcjfh6ZG5XSGq961owVxMyqbvJVxM28E6SyJ2juJzq+l0wZbepzwp5DDlXoF8lKgorsD86ofom0lJBkqXQwNQPt+Ux5i5dh0Y56TiSRcDZd8hYp1tbBWQ4v6v1LKp/F3gqgN1Wmr5cV9NeOTa7QxJY0Id9Zaub0D0NDbi7lcUz4m/2/JUmnkK9b+rlAQx8AhhnAjVuX7+yZO9GD1WO5X1LknREy4+kT3UhTTAGVx0Hafza3Bn/6WrSGRvLGs89JtLFwX0RhiEvbZ8gaZcSXNhtHlA4BovgPQx39z6J2n85NAk+0CroaboAJfvYzc8k1QihGUiXiUbPaPK6Tfqg3hxntR9UCI+VMucAy0qbfzI+zOMEkvGYlVFiYn/JfZ6Qx8+bjmZOGmngLltiJw8u7isj0pd5Q2Ni9n2xS+bZliIZpAahOO2yyy9VKKuZZfNHwfD1w3UttgtFm/FDdI/pL8ig+07mhBlNcBL9VESAhJNa5ww/6r0MBnFWDyf14gEtmDlH0OTVE1uH5OSReNxQwFE1zd0zz6cIdlCqoe57rC8VO/dIgZ61XNYcdK3iMhTUehGQZgRMNSQk7j5Qe1S5UcbSRTfiwbmWl5Q3+IOKbIXLk9dxnZdvSqm997J6GqWvTvR4pKlq22Tg0xOYxfYYCgFtbfVF7RUryL+pTLMO4cO60oH4nCzh54xMCvzqY7bsXMpBENqv7So0O3MbDVty+sRYOXwZjMPhoj7yq9dI+4lKKAB6k1tCRCFSVSS9GGcysKBH+VnbwyImQJR44T2fHuCezXzS5BWeQWE7hScb3k0YD9yFMGiwK5ML4V4ChSSDA/SAUQqbkHTNmqq8j2XaoTZoj8t2qnFftOaPyO8QpGSvY2VwDuY7n7/T0XI5hIHAOkpG+G9LM+z41gaWkTzWw6+BYlDUwzMAgENDOX7ChBackqRcxzvsSVFZu9GiYeAK0zQ/tPGpSUPo6S+DWwbo/fx0weidof1Xf4/dTV+HQ2Zl7weGMdln4ZgAlZNXuK2heqTDof+fj0R/CqEb2HYUOERGu7pmGF+VvgzhjiYQbuikynmhgZTWytAKad8WnLcVmo9LbppJDAdldG56fw4Hpip4tJBaavcpYF00torYf7qubWO0RYLGHIfNxox576K2ZL5FWBm37M/GO4LayNotSqp9p/Hm7qZrZSVRB+A6zyyaOb7Czg+bwxjOGOy8VYhjZvGHieQv4Ba79E/It8xi9I/wd29GNJAjlESwt00E0biFvgHz6r5ao6KTkfiPfmghrWlpLbcmZUCQYsfDGIHIfrSg1KmtKhncUbDgoPf31amcHRR+tqWTyGR56AXXa9HBl4z52nmF8WInrbF3gLX4LrqEJ2Qv0OvW5Euj+g0hoDf0PH2UFaOMj+m5FSFtFTHqPAk6SS4H8RPYPfWEif9ev1MXIN7WqGpC6L1Euh+F78LZaZDS7+WUiXnBp6sr4AdUcGJbTorJmK2S+VBoPe/HmmRXaF9VEKsXX1nkgEAET3bK9khbpDm9m6Zv4VfyyeYLXrUGLBG0lz1puO2GQ/lLDhIOVwO5nWIXO3/7XwJlLffSm7JfgAgbjvbfsdwJPYmqedCCn2K0XUIB7rSbV/hhcAB8kITBsgN+06k0iWhVZCVbyleT0WKWFfBDaaZf4BEkUmbwMeziq2T2NJ7TzCWEqMUozP+pdx3GptjC7QbLKSQH4+lTcapQuClw7dU3wyCzbqbo8YCjy0sk5ZWKmmP4V4tF88ifJs8vAubi6GnH9hSwQlOMz72D1DEATEMUV6k057EtvAtL19F8xyu6em0IFjyPffCRGN68U6coBFhTgDc+2zak/zoZXZam01D3y50t4KY0BLPMGCqUwdqfyikUWwIpTUUm/y/m4b03X2NjJCIkZBxZCGAowfzJNowjg4obyEoZ/9uHctxGnQtnc06gFb1exa7CrWV8RIq2bGfQ/4HVYP4NjcKDRQiz0CUvdHSdpd9/e0BPQNCPrA4AWnqOjrtQ/EBr967xYEkBJK+DuM6iQrrmR41XfTn+1irMDm022TQwLGHnqCxyvpY2xBbsYpOzMQ00MMWwMsieGxqepGiyru8CZa1iGonj3zMzU6MgQ2mfMqleaklrrZK/vwjnqVPHQbr1OS1Dez/DvwoBmfPON+HTUYEWA2ErZM+rNHTYoHj+L7hwYfQxzexQGfjz0uJqE48n5ZXKSPzxBn32o8trh7zUiFri4udmpfS1fmzo96/0Hl4x5CQeFLm51PiB3j8+FxgBk6n5uMZTo9pNKwc+IXxPIUioLXfQ6FryiqJccPnYGbd9iB/k2vMW3C/B3WdKxsoj3LwXnqLXG00QEEd0yDfS9Y19VhXt0TkKcd7J2k3WD88gbBN9zfqswnlhZLRwg41qrYCQPE8cvlAJiVz+QfI5Hjt2RXq4zPQLovw5nOAJ8TEJQjuYsIk3NeRO4wbBrAp6uHmO0Hi8Qx1h1+j8hMPIC6C1M3Tt70IDT4kz6aSE2c7G9Jx06UGZNDy0UNIEBrpNqKH1kcL8xoefFVixZBNMik2ohK8bc5bBhldDwBY2oz8yFcGJKXe4MBe2Zotouw8nWIkQyBgtqrLXj1IS10frW61Gim3HfXgkF/OdwyUgRY1ClEnRN1XVZKzRjWjHux2VfT96vY3r3nMCeFs6SNMLzHXC51AgDLCafTysGU4e7VOvCnfW7oxQhPYBdyK2mJNm96N+I6CEGyQXfGanITaE+RgpPe0yQ5gjEg5WbyDwJ45wVhhiq40gHAJfyXouCo36o/9ot7NanmrZrSZMNSPg2mT6sd+m6mf2o4MeEmVvQcy+/J7FInBDrlkFv4S3ZdJ+Tq1iaEVJ7HT5lRYtwKRAGgs+9yBNr8uhcGFFW+EjT07tM45Lt1119YULMcUJcng1ftSQxU92s7PnsOoui318MAoMW0hzhm/ExEnbXdqIT1uvaJmhAgNu8yfp/ilD9Hp1C9Gei+vcwzCT92mkhacbfc4OW/5j9EWKlIGFa3xCKQmg9Y8z9eUtFlUrJC90UIVsgiQjeoSfIPspE+HSdLTXLa2dOhc9F6nh5M2cLNBvzqRBvgt4rYu7DhLv4qMTRlT3yhpbWvOAfYJoAcEJTkrFzYvTPO8ndotEVopinBOgj6LfTQjjhLaxYOgwjs78KcFaUOn+d7TsqhOVLtWn1Ss2qzfAeoWoYxW4o3rrSlYYYgu1HGp7S5obEvPDEosBFO0KLcKP5wr61QVFB8WV+ldnodEgFpOEUlJIToNZPtI8204JG/Pjz6OpPs1qvHxzpYmCyR628FJLwCh7rLfYwkA7a9fSRk3MaKX5DzFIcjcH/o4dsO/0HOvDSdSWyLEh7u26n3g2fDZSy0nlZFF5D4OxmK3SyxlTbTOP/ZqpehbQN3mGqZ+4Oa8SAmmNjNzsKKoj+09qdxuWyzrYv8dq12Pi92K8pCEBsb9FN0/dvlYSTcjucojaeD/aKQWqFH2NgaAwAfkuEB/dTCzbARt7jWc7xlpR7ZwAzbPqj3XZOJzJMHhNnAW1hMAuBIOv4RF6+CUaMhDpBLUYG5Bhi8P6e7kl4wa72Pl6RkvKtPsyrqmKsCic4EbtRnhGVOrL2DgdTpjgMWwWOd9wAc0y1CyPjAF5QIezgxk1Cz7uXoMfmbx1RUleeZDwYOHFGlHK9nNQx7OlTjIzzDoXQWSWxMJeCe+EXg1CaCsAeGnzbIl0UliRoJlH+9VfbwJ8JquV60l5s1G/mvx2BwOb7EKl2xgnbIcHShEOz+KU09qr55Eqs7jAprhd8uD+KYfYcLvI9kc9OJtMzunM4vt18FdYC6sUz9sZlYxME6QXWD7OInSm1H9Q1kI93p0CT1xABdcrkWvQm9Ef4h+dO/NDtFdYPfMvyLQSAyXW4eBN7LGyb0MeehCFuW2qBGgtXKBrdaJrP1SGV7vtJA4pOjuJRgr69TVhqi2/gxbLKlr+S9wGbAfV+2JrLe4kgtVJjv12FZRb3IlwswuKffhZ/BSH+9sPjHWgmkxQHELiP2Dt8hZC5Hfx8WCByE9ICpdgt2c7dxjNYMX7FEVBitcrdMVurCT81bEoCYRO5S/jI7mlx3do4A7IcMAyi7SJ7YltgJ2CvF5IZozHYtEPE2eBd8qmAuE7fihyO8zjz3hYTKSh/glRKSAdt4RbM8EX6WIoU7qzailY8s4A/poKK9DlJ1ZXur73IYONMiLqRnR3+0LRRBdYo/7XK4V/zPs5MA51ncJ+AzgBg9emgCfrmg5RQCn86VesaED+3SjbJ+MvgHozCkoYeZpQh0Iy2YRj39Yd703CCJ4Hm6sMgDF0M8RQ8447Xjmp1ypuX+M6OIoaZGj2tOVxf5J6vyc5DahO1nhaEBLRch5TyMIo1sOr2pyJSt2PgYMad5gzdhsJeGxPGB0oiiGBhJOxJnWVTsv2heJd3vU45JhU1olY33zT/US1QyOyucLj9qnYFdvH54Y1fDPC7bAOYx8E2DwD5/ajc1zofEyoz8ev9ZtWXY636oCyvy1a0ah7r4+iYMjQcGGMhSjq8+wI0rcwRyANkzknnVKlWXQUaVSXHVJJNCrhvfiOybXXLUxQzPm+06ym1DFc3X9SGM1TDvtGjf681oUNabMBGeKcSnUU/VMLSMJ7apdMfv/A80KwhThISTTv4PZ/72NmDOq5akMPnoiMkm2jemYawgV5K2kLbF1CcSvmPB4+ET/Oh3BqUenGHVEyiV7z8FmQtFj5NlBOSDrtb1HaEhHqaSyLUTPYVrle+mnIwevWqrGpdDlIKYenmroLfCLe/Py8uTk7dKY5UuOUQhvPwKX+03jAeXollrYfpZEj5OijqAlKPQiFCYsXmSsA7R9FHIsnRGJU+NiRxFea4yRchOM/zIE04VAt6QkHT68VK9NP/EzAT5XIHY77FRl0CIq2wS5wVBBddHRq0cpb3wyCpoL223GWhPd1DprHmTBO5pg2VCjBi58nyINU2Qj1KVWLtiqgKm2pleKAsJ1Br6YWrz8dXbIM1DvNZa9ZrONHaJ4wekkUBGwnoreWfkC4Wkg+KbUXB8+DIPCQzkgjxGC3lM27fdzfWP3FQ+dyCuVt7MzZCJ4qbBG2Joz09N/J4pCqs58s7zaoP0fRs9re1S5+ALCroh/hXNTI9FryJYqBLC7NaDUeJk3XP0oxpE4qNThz/0QvXkiGbB99ASPypdoYJoMQlq2Z8sGK/moQnRCaIT2T0PSIsudK+TTfErD0dno4mBZQAc9SmI5EVBQekyiahaq0EZLd0SJsWhorOkoXGiOT8fce9hUh1gv73f0cOJSf464m8KRMjAdPg6vbkVm5X/AvCCF1+un+OmXc4cpufP1ZhgaedzbISdZVAn3E3lZ4wiUvRoh3AEV3ggni7BaJfZV9vTjLM9F3XWsv9g5F7e2NX5QH7ZQzhcrjRL7wG0rFDQRNtnU2nYvg6+iD3pLTfitXVSQHz8cArl8BYI0ItwbvCKtTf2ezQA2gmSjlWbVgxY5W4CZH+R2ABdLeXS7bQnReklFyLP/JTl01Fy2wNubNX6vd6sbQmA2nWB3AaZ5y0snhqspxj0ItK0AOo5y2QOSz8+YeNzDkY2x5IwKwO0tUl7UsaFLjg2oCH0+7Jq0NW95acclNRo9pPzktjYpYqiWMDgK2WJWHWTeAtTLsnx6Wo4sZBfklfuGpbjfg+nEeISzwKNGicukYGUzjeC/DlW3rCDet5URbeP+mnuIa0LiGNPI972jybZOuF1TVAAgPeXKnoy4N0FCbtcEbiScrDXe1NmkFbBqlL1tveh8/ECRD/wUFOEmjDZmFRZJL+sDPpNhQC1Am0TLI82lirUy6dpz19JIRX6ArU9zQuM8QiNIBeunUGuRjMIJTWubIFRIHiHx3mLdVb8Us+e7aG7HiSWxg4RlBeg4WS5gOZGEcK0ljZly0LWlnFeNLhrhYjFWXkz+ui+TJBMjsw5ZyFKSAYDUisDnMNrozFV0hf+TA9AsBTEssp4PSQKwSMD/LluBQOpJrjZQ19xXX7GRROQZCL2qP3EVBeKRAbKfW7wgswHo4TlCfei6JLgM1vcWZNHgpnBWUYEsTX0Y4VHTJTnwy+HVRNY2COPLrAsyHFq99+ICzyURP+3ewR/A6LDgXWdJmiDYEWEQmVaoE23iqvzphpT0bVtjiJMEcH1Oad17ir7TahTb5T5NrbCgNTsPVCnqvK5GTm42LPJbMeH2tJDunBb6pVin76xJaKQb9t//8bkMX5dxGN7xrb1eY+cH3EhEo6as01DyRT4+c24d1g5og/2K3jTz72YSdFomtn8wVe9YhnDvhjRH5AQVQesnQ99BexFkO9Wqy/oetRYxPIRVDUbJUcdQBs3jzag6h7pR96rmy9mbtHamMcmxMhlayZOIHX7wZe9XF8vuud/k8O1B+fid6YvcOHYv3vdnkgSM4GiOydgDPBjc8zXvK5mi+Js8XiC9KIfUVGwOH3TQ+QhsXscPFaHA0alQcfiOYF5T2P7DU5FqenlZJwQ9TRfoPEHOnWaESr+mptlURZq1TGXGATt+37RHgFOTMUPzDBac+q++vlG4nS8C4vlmXHOcWp2sBuwD7Zy2aLkAcSUmico6JrRbW787Ouuo1d3DHLFZo+XABRE1aKNa0Y5fFuLTsiAuWawOqHFn1+z+S1QpW73nRD9DrmoC0oRn6Q55R4apP0udrdyeLH/NBfKmg67gCHiel7yZGqfuHy9ovQgKnZByI2y/gP7/OM5Xnp+TPLSZ7ABJYw0hRJ2v6C7sj2ekfR2+abYKrnB2ztFE/zcpxl08zaTU2PhgF66pwv0/RUQJiqn5No1mHwXWgGgjIAeJlCU0xBKG9kYkvH9mLwmRDO0v3m6PBEp2VBOXjR/6KQjg+yUDdmcBVK9wgcPway4jv4tzWZ2/J+/Sr5fNMSyu2xWAHr9pAETGPo9HkpWN8PBDQAfbU9ggova+qReH7WLlgw6pbdUHOLZdmFh8895lpOstfjsGMib0cZr8HnHp1d7yW3hK1TlqoWZPfCs0khKNCb6ZMjpiBxSZ4zi8u7GMsSKTcj6lZOCgQ+3XnfBQsNNBfOl0WK94j181sP7FBhHBD+IXFa2VGlh403uN9UAMIuD9XoqgU7oy35uDEhMJrVPLvKH1r6h3oAJCSrykJ7CXwVL+AayWEaLdefKTpv6QNdaOZ5pccqbQ3McWhKMiIyr+C5DT+7WP3nzXHMLL4/YftwdaEsD+u5OUUSw2vUgydOH1806nnIfvOlCx8BKJqc0pWWMWZNMZw38ntXe0dw944n9Yen1ZIQdiyF44ZwNmS29vZ5nMewhiq4/wckk5j6aghUFsD0UrFW2IiXeQI3jcxvYB4Sd6JGewpsbkDzM6t9vXtF3LOsixIY5s8FLmEyujqtVL0PrIySRuSf2PkoHNTefvu170B6bCLPSebVs7cZaqqFVNwM25M1a7MgkI7Zru5hfcSrw0v/fjBrYLOprlC/+YQN1uh7ENuz5+vQeE/p99q1NXXvU/YNjMW4VMxPOPgB2PNanUlwuAg/EDsX5OrgVdEb8/IfGBo7LbRm8fTXVGOYjJochlFFfhWkBSQCN6lRsyPAb73UcTtiL+fUyP1c/jfPLRsUdNpMhdtnPlM5uX4cueZEyeP3z/ygQtsVoLBhLxFRxURv+z8FPL9RAQV7kwRpQwRRfZxSwYCHxxnetEbHEzXdQpxY+cK8zvJXKzD1pt8+tFyKyupJkLJ4o3agCOynbwimf77N07zHNo1kh2flNEEiALdleK7ZJ5dzrPhfntvh0Lyv0zPyIP0TFmvovINIFQKChuK34ieqw5N6XE/DSvPrL0Nf9b9t6IzKYkdmAIK+DmsYDH8tlNffBY7QZ9JDxg917zVDTOBYOybhnaQ2BWrDCGU3trGUMDTTP1m1wFrE3yjR7dHsjQH6XSoR9Eze/lB2RIoTsXpIbrWAxX5iqeXLS9bj7MgBoEk1RVM8/X6S0/TOl02SaXNU8Tj/rjGWz0UXcLWHOFgDUiipIAKx4eoZPeYNQxyhrt0OsG9IljaqXtbpZ0iLP1mrMibT6QUBxEePNHqCzlgP+/irs0Q4A1UaeN/AakgCCt1IMT3yfH0wggWQ3+2GY5VArW/p8MPdQATBhiT1DGUYAlCvPMoZL8CMnI2dTBw8zpmQQObA04TLcyB1sawlTILBrndMP8VUSUG3CW9Pj8JPE6GdR9VSSOT2l4id6S80fXY1PEkBSUGOxSHBF7SswN1ITUIl57Np9iwX6OvQ//2boAQ7xMeodTYA3WO2ESM8rzwpq7rAjh5gyVMxdcayKYUYY+ALiPJ51SOxTzOiViBdvrDABjCuHgoiULjdoJ0JwcUVuh9Bg4aNpFRhDnPFbbXu0nU+WXcsHmJqBcIo9DUADV0kdLal7I7L0rffkCR137C4njEefmujcEzDdnAk+eT7b92n79fQf1ypVS71WjkRlPCPYbby9Bhji94D8XM9YTLlHswSEozSeZTTcw/GAtBx3Btvri76zuwJGO/otaFpQ7b+2cof15IWpFBCPrUnhMiHnRBDTWezDqdgcT4cJ//aDEWjeQ+sKMuO0BIqs2fofgdjoTH3NPmeElaxIBtFvCYbzGtL+YZYONdLgLoUQYL9+ng3aZD9oONx1CWjo0bXp0N1g+7Vk3FBXHbXvp/tX5TRKeDjX6r0rwTEnF7vduXdzatF0v4Ak3r/bmAkkQeZCl0kmc5rGLyOQ1U03M2UwXVtACBh+r/up9kH24K9l72FLm3ilUza/gta8LvS76yDQma2JdpSYL2hI307rDXz8g74swmpu4YCKxO+7KWAunyVEeamUy1FZ0549O/kI7pfXadQnEGqip5H+ehFm5DVwfIKQ6I/u/bo/W07zCew9g+wOCD4scS5OrDvohOkMz6fImu0a0GIDZHMRG2TCsp5T0ZVJQgdqYIwVGdJUyXLb54ucwBp/4L8ek8UK2qUqIVgpioVeXc7DT+CxREHBmikzM6hY1kvpU0O8XmcCkN5ftDM5P64W/bNyaNkkRpmLT3UGz/13Y930EU5NA2CKzC555e+Z0/dBuA2tU8ijI7sebb7ZA+RaADA0npkTWyCUydrLqSZCQaxxFyqGR/FoKbWzO2JRAPJJtAiDdkHQpfrGE19rwnVVrhItn296bGsLn3gJ3LZPczHed+hFpQmDTrs2vBMpiroKBm/VT5nBfvqbSI4CNVCbnUgzKLW9kUuBfcOIINyIwXVjRoMv2BlEveynt9OiEyvKp0FADwhPevZWKF/Y4cANUPKAqzW7vvlsotRnTzwx4NU144laP9eamUC2dG95xko5+C8BxjGufpG+U+7BjKpAUyfuQ/L96D21WsMBbc4iIlqS/OQyUcE4kosvNlM8U7N5WjcDpWb7SQOBcHLLqf2w8N5InBuqcGH9xyvuzy3v66elX6pQZ7yzsX0Px/LEXlSeLh3FfhhAgWJ/q4WAQRsr86SXAYAJCL8U0c637tVaxDlQKkhBxGzQHLI/TpynxJx7Ttnv8f7/8F8pLLWViqtLoIg2+MtWr6/lQxGWjRf/ltisLYYOrKdbBf0HZp5Cg2VAQuoD9YqEIQaMEpRDN+DYaprCOJyS5bL4IAtRQN+UYMwvGQlQ5ZaN9UUW0JByCm+9jHnaOKdnhq3IgaBAW/X1ruYp/UJ+TXCXzQTQwQWb76zq/OghNBt4151eNYYpIusd/mNj1ZkmgEOoLP87oAzoxGgnqoUTeOVF6XCi+f/5cOjSkA6DASI2rB8I1BsKpmQR6sHmdt57XLqU6iUVWwB3w1335JSK2pygVA4OXjEYeTyF+tmbaxjRbwa8LNCkD8yVjEgSVntMKzXzOr1nYlRQEIBKsj5VTuanzQifTN1dGWN7WUlrl4cm0WfaSlDZ0BHl6VzVKg5EAfXigD09o4v2IsR8vAOu/yHjFtqziGdKjhlxjHVO/iR9rp9RPcf9NP1Ts8iHBlcO/GfArPPB3vww2e+IMom5EoMXQX7XCzWyWmNnrFzP/RnHwHnOesSa8PqI6zrjpbZWf+ga5ZUtFcwiRn6P3dkdBFMuTGTjXhLPbtxLUfLMXPYMU1lKQBfVXxq/dqel3w1+sFvuCcmTzUNZdquMWUotSFJu4Z37viyxlq7HeymvoZiCN4KJGhZi2suUBHUdrDP0zrqFiptfINItHQ5azHkXCPwK3U1vuImtojMtePlXCD/I1SWl3UmXvDv5gAu34cdWwtu+xuQC0t4V14mLulP6RvRDUuTlyTna4RXmvIyxnTwXqlZMKZ0cPepnTGafGgcjOeZqbnB+kfHf9fGgnNagp3yEtfMjjFCnp7G+JFNpr+Lsstt0E5jowpovLInViljMQCef6knR/4t8ETJr/LtC83RV9yV4g660NQvYA6OWZJ7CtMm0csPA27TRC6XD0DQ31ORo0qLJCpihk07S3sEopIxfKYQ9L0qi6sreWNUL1Cj12EP6qSW/BTu5iPgvGw5b844zkqUknSH1fsK5mR8tSdk2y1alKtU2xRKpT84cHxdZ0Sncq0JN/O1yvWKeGreAAUuyWHO0JouJTEaFp8FC08lHB4RC2koerv7LYhgm4z+n9lfGsFvsh8x5H78a3jLXtJPMpPTTqPof7URKu4RoVZp/RmGBmctjdTfB5IOvJwAGf0bzrhR/xvCzm+3b8Gx2Ch0WHFMXnaxHmvcUGOpx1JQUqkeJ6zGDN+MYnBwaiGS3G14skVzLRSBD/QDbunPUcPYLIfPlCuJ0eKqXUBPi77WEDXED8LDow/rjNXNeN5z9CzM5JLrILV4RRMav+780Qtrx+ksNFfzT6l5McwiP8H/A171+Ck/oahxXjE871KoDQhoBOwWahsiGUF1neUrtTzDKqY1AIxYXtxwx+wOFn3jQAhGVOU55POXy751KEWPNy12zZMstHycpohpmlbEq6+rpDO9VKiwLKOrbsDs51vS4/4Yk2lu2zonhOOLqQSAlsPLmk0jq52InzBjNuYA7+xg2o2G7ln2+66iVP425hvahH44AJQS+AY4BuVhSEHwQNviF6ivMYpRtchGnQOp/GHYX0TvPuqMlxOaaCRbyuHWPpMIsaJ5HTrv5GUx+phZBrBBxRTeaB0MYcV+yspYF1B9FjYjWfEDFeI3q7B/mz7TMpeEIdeGCAwf/K513DeMHs62xJ1cJ2Le5uvFCjxx0SXkrdvo7jH+dVLngPw1mNudZaPariXITiXjMT12FD3yp9ptL32xRhm39xBhIH159ZXfsf/ivZKz41SkHPlg+WbSSBFE4/Qqm1ObCyik72qnrbAhlZFm+pqAOyCy/fgqG31Y0q5yEO+UbgYqVxCkADHnmw1+Er/S1zAipE0cMZPSDVHX2lpTDLAZZZhPkQhyoFuDEnjn983J0rrLyHblWQNaejwnQGeG/EBAHbSlf+9mdaimSj4r8MfgoPcMirSeFHKXzSPapv3+PBJ2/a210hAor+lqAJmHLe5rWTE1Gfgrda2RdzgZ6aiJbsrquYI/5pfzpUNoLBah62IJ2P1N4yKJOSVJgQWI4MgLL9MUj764YaYupENgZw7KepsON+QSQrTq43WAj39tsoScnslAyF3YV3olNuVbZiUj/i4vJ7rpR0p1AOG1VlKK42/tNaAnmZIXS3uMyclTAbL0ogj0qWb2f+YPMfNQkKlzFSXDBjdrumDBkDsyKUq+wzO8nc9+fPbVRdFxPPwx4XgI1ma+gEbt9GI+OdD9dUHZalnr0qN3fKAiDg9YmI3d+3NQuBJpOAbxwwb+Tjsa+4Y1Y6VeiEy47X4kndJ0pMzJ5WWpS6YVkNzes5c87wlsmv0hSR+iRH9Thj/3nIOV1NvFfDGwTFHPtQ3CpoQjDPQRSfis++ToaYjlMCfA+geYoqbGJx6Q8N/ab8cgXkjkxmWFBlzMs4ww181u2lBPz4YkqH6d0+YFl8SQ5q0YOa9NJCBh4aLIy0O01RrNqVRxYPdX+jLUsFy/MyfzR+o6mxDM8d76EYvAiwkd1ei1GKnLdbXdsnX33RBXtEmj6X/63vLL1rdqz1eDl8TVgQdx0cD83IHNHZQCYGBTiExQIKuYaKKqvesYep6bm+tClRgxc8VPGkTJq63cO7f9WaonHgZr/+NKl00WJgFex9XkYWJbIZSgWu2VgJKB/CdLOnKXjCvtGXJFNDLTulHnbpBloVYCCjl4uTgSQRsjGHdR1R/LGWHdP7nRRGrbKkZnJbO9HBjGpEckaIZc2JDP1H440Hs63xezB58BrwABFWN4kDDg+WOsyOser5qoiksu6r6bMcWZFCdXO9TL5K/HvTpkE3OG4EhrtiWXV+QhinBiNIgoZS6fSnNn/b4kHd3uHoZnRZ4g+LKqgzl7B/6VEOf5FJ0Pk4UjqY82QBNI7xiCP8gAr5dPOi5hA6f8ej+aBr9SwJP+8gDaBefAj1szTFQsLK+zP/GhwVmxK9a+oARqy9AS5t30RclWqLrkzAxh1MFLdUiAXG9pW04s/JG3ArIB1LE6AFF9MqoJJ5YscZ35NtUYYwWs4ARSGp4zWcf1mD8LMcwZTmSWcZd4n0/+tCnyKd54/JDSE+Q/qMq3ez04/5HfBpoKH/64d2MkbVJjOhlf8X+8PL8QA14H3pjrUT2Plylo8clUo2icD3xPDRJ9IhOV7SeQxf8fKafqbLm4ptfArPOZTMQo8GSiNkpZDZyfdPQ+PQ8aTgzNlLU45CisbOMpIdFsgubB0Qf0VHz7LqbCmpKmqQg0JVYt+ZBATdRwqj8Qo9c9MBa5Dg/5nlSXXsS7HBwSf+WgEbXYOXIhTugyibip1MTnRNYKtyA14jZw0FiZWarZLWi/zBypFhgy78BGNKdBnxV/t1py0i8ZXoRcVZRiXUu+NBMZqS2x0RjJ27GTxnkAZGzCub6SEqvkRVjMvbk3bbOyLVeAwWksCeU1V+n0vu8H5Sy8aYykEPrsQ0Q52iZYsny0jS5k7HdxVPoOYRS13Uywj3khlFWGGhg8krJQWV/hDBSXmL7vwXVFs+psG25mT+wI8e073JiD7p316/GrN1+dQTK/dgrNoTcEJv5YdfEpv4cDKC6A8YXn1WR2jX30u5O5o1e5U7FaBW1W7chOfvaueifZL8XtEj1Ba3fbo/2eEr2DGqgfGhVbxjm/jZGK0zq2pazidDae/hxfmDQDwp7FZcn8FBYKrQMsjKpH1wy5rVMTARrehFEpCmlG3bCOqE/w/9zOGAY2wvFsYsuJz99lH+X7Xyp9jVuyjh7+wwfB2RkZbT36GhaK3f2V4Sa6FbWEDZF1NONihVBHFwrzBFFXr8kTACFpDOmiOVU2PwT9OBShCIMoqeSlAamiRppJxhrNOIrgTUSsz3CpX7jZmxyXC/Cq2b77/aW1m06N3/IhpRkBtUFnUhPmWwHcjNDpEM621Lrw5uRkjaz2YXdHy4+tvNkhSg6WkoceZOI8QQjMBv+uOaB6k2tAcpeZ+Jbuqk8Fbuicze1OVj5w5NxudLNitmIkV+UB6s5Xv7RWmpu4j4uHMk77/qEhZlodzYZK6UpjmHdyp/Wdr5BG6kR9M4AyJJF6q8V1TsMC8qtDV5xQe6cBrstZ7jbnaSdNOpvfX+tKXTKcew8IKTxRw0vWWFjJocnhTYdxwpJydXb7KUSLabZXqRIcJ7ZiXNMiDv4Sq5piRxTkrBQZ3oI76vpyyv+8n3mn78rHi6bbBgIdO3rofvvkok5RsYlUFI4FJMVQB8jzXE5NKhS64gxwz8vQAvnPa0fbmMNZEh/4iJGIZ2YaWjq5WR7REs/qUBf2MDu5ASNmTmC74/8DnxKvIzIw2jKwdkNQJBRS1R1E4pOHcLqk9q3gfC5VzsrttNaIPDOeDuLUZydtcg1HJHnHou6V6bfVT5bLFBahpDd7tf83D5O0Bk7eCDe7TYPSk+rGZe7YLk+nO4RmXuvBA1pgmkcj4M0SSP9b4xv2OUZ3bStJ9lzNTfoQ0JQlI2mbgQH0uu2mI3yXuLW2Dgyg46th45n9/1g7qCMY9d8NarZFUeY6RSeF+od0Hc00URFWkLMqTIW8zAeotg/bQKH/+uia0NbnhLwC6FnIr80BY9atC2nRWLjHq8SWS+fBM7+tRoFak9gY9HXJ6fsTiJYMkv5XKTfikPI/Dj/Jg0Hkah51bXALLlowvtfPTWMFWwAWIHGhDcPuha77SjXk5lYYtJ7o5Qg8xLo74EMird81sWYYhjFaWtMzRTkaKzWjwhrBg3YOMHxY3VzlyeCGnuhX4mYSRLYPNpfVXIIxre7HPwcPQ4WqR6DVhPeNdJrcABBPEEhCh0EOplLYoAjKNp/Fs/4Sq9Bg3m6snVF3aGkZjkybTKuKh62QwKRuodqSxl2h2GkGffF3scFv9TzjscCWU8RoR2PioZ9GlNbzBWFLeT7d8J33rVfHNro2vUVBifcaRxVj0pQdJOAHNptRQGXcR50gA93iJx+dib2ZgWTfsFMxu6SKNJkF7bu6P7pcE2mZ+kZitKAifsAOIeNR6pUKgP4gkyuxbJfM0t15tDWJMPhrqDXmB7M3wWuImG0YFNPZ0ymsmarU1G/AYBS0ObC+H1GdqaWTf1sexiF47Kr+spdii2DyDhgPLP4w489+uztdJULEQSfe5Mo3BqwG8PeSeAj9ve5Fx1PoKDwGXtRju7kKBIdiyRj538J/lLgiyyVjqZafN3Iot/0+VkLNIZdAfe/Wsc5CKbeg8yfDu+k+vLDcFCcR5Wi06iVrDYT4SofWHEobSmh+mVKBqKeV8xkXMLENvvfb+HISKsE5bmDqtZMk6G9QAtO1ZPTt/Qm8B+FccqXq33mrjziYvfvGLPYZtn7ULDbUII7idY9JYj7detzwdmhu+2PwuO706xZykEU6umS/1E0+oJk6xRPAQ92J1DFWYSxo1Zk5cLwZzC6OKoSFosMK3L2VUTeegYaaOrlYD3HP7hIHAu2N72xuejP450xSjEjNNng98gX8+pUA48LgP5BG1pfizcdyZ88rE0uF07easYNq0PX6O6F4rMc/n2Glj8xIeFlQU4q6OI0E3wXfHGR8ZEAkbyF38fiN9NAKdqLtC94aSUPtqWgUHtsD3Jq2R2030tTBCvTLGjLO3istB7OO4kkqAkiAv6NsQylhUQPim7LGhtovL+pKYr6tDZ/WsHAVfsUPoC2aejq93avqnKdqtlhI3wY+qdPLxmJBK0Sp546TyR6yQ9PjR8TE7NDbrSHP3BgJsQBqIbLPh+dPDImLN79Sc+koNlSeimzb9KGIMLZbFwSuI2J2QYtvDzk3FhZASOQFsARcMSb7YQesnOpdEZDV528tcPBlfLn6BQKgtUCJ741dAsdWYXYGiBs4rBeded/rY0NqCE1zBRWt9OUAcagZgMpAxjAYQS8OK5YeZlaplqWU8WsTriGy/m7DIaKdu6MBPFGCxq5IVZgmk0anIIXeHpfmCNWjy/2CTkHNCS0+esRPrwxiHgI1y/LzY7rAQd9J7KKqeyT8roUUIswcGs/Q5GFkEx0zNoh1vvRSFjoSp+1fM5d0Ii3KcI6mPYaY0hBViEIZF11yJBu0BGYN98AGAwcj4rhGwRZTh5sdXzy97+yCVVGNtPUAgeBUUUIPK4bTzhC1AAZVhH7dwify8Lea6IlYbhiaQhOHKrdsmoUFCpyeziEw7EecJzH4cHHAawVso5PjHYbtWQoxipf3Evj2dZPyeEnOKtSSz9yTaTQMSwaky8kDox2NVqFdNGDN9m1BDw8wkntNOqKRug3aodiS4peAsCwX5eBXdFmcwt+QgpjpLsdxHWnkBlJh00sGS1jBJyNEbGrxoMqjTzXsQXd4+DCuihVVrc4JtXmI5Wp7/AX9N76XILVNlST5gofzhfkiLYdcgIObrRtXvuwG6fhR67qcnc/JQpyO4EtFhmf2Qri1bXpXTZ0N9e4xNpN1KsqITUn683rYusS9/cJHDyc8C5mUXZCNUtaV1M7/59W28icTcBEzEQPHARcYLAcEiLLlMR7OuC84ualgI6ou50T3AX05veZX0uyWckg5CF9aoqCQbkAHSNcFUqDwv4bXEERa90jpdiCqi0RBjoWR5W7uv0kGOT7UEJBNGJsYns7u3oxcgAwytFt0N39X54zaGzf4V7Buc7eeMlxTwaMQYjBS3MpzQB2DO9yYacgAL6hJbAUwqKoVfcbiXHRD4S2/Em0r3S67qA49Qea6507TiU8vesaGPUmR/rN9VzdLsu87f1JyZl2wwXNz6buto8VnCmv4fhpxuVnf6LnPJiyQuUetVOzPqAfQE19V98bHrqa1IhOUvDP0+faZJLkCjkFYmUEgOFJVzTZPD1D9LjBSFaPwfBB5J8cc8Nvj6y79sXZVe6SZxO+SyyUBSgiDx2/hhxnZMc41FKkKMS6WKmqbsnvLNHrbOcyYeZZqRsU9AJGuGcNqfiKmHHEJAod8jY7UyaRkJulHGj3WOXqsxI4sjLpZPGccOHktppIOk6fLFFqm4eqjrxwg9Oc9MbsD94kq3cObnMNfn/krmt7APaS0kudnOTjPpCQiv/Sw34jBk6wQGEObJ6kuK+Qnu8KfPr7RjlvM5tGE2jUpy5Zwsx/F2h0YC+VsQgruux242/59NoYwCY0PjqjlpmH7KMn31lHQcKXGecSxhA3w5d3KGoPfaBRUXWNfxiUqE7tNAY0TAnD9CMkWLQ4Y6QeJKEtQRGsQe26XlDges2wdLBWF7Sj1Fot4lfBagfaalhBZCMqjaXDadTegr4Ryr+xsXEb+MeGrX3PUTKi8UMtY1YjOuwHhXdlXkwxYM+9zY/UVTLHi/bRyx9IulYYAMine/vrhlhxmekSXjaJV/Tb1wwMUNVXQz+8PbVan0WWvIr3NHK6c98aZ9dLQnWdT2BF80ZszK++ApYuvyrdY1dv9tnmV9N4FaWJR9jo4ax59vtiDJxB2YHnanft/BIzM1kUQzd3Cz1OVG9ylvCf0QTVQEDo9e0btz41Z2jBVr4EoJkiAVQtOaGJ/qOa2UH4nxQVsD4zvEAM1PUnWzZ7ehA6bqcZKC/Gb1KOv8tXViZRhUH/7pGq/wWzzulhllyeqg4mfnZwlQQVdfUQrIxK37GvCIyvmnsbzjupyjcDnE1n1dZDNJItkh+pHJ9bh0TQXbcTZcIA5Ky1m9+74JLYOGrCrgbKg9C4q7/QGzKcYPMlbQFj/4QwF+McRLJZ78spZpEgRmeV56vymP698L5ni296ny7yujSlPoPxUZKIoQT9JzOhNBmpxpMRJaxYQiOlDDBr/UkiID8jNxoL16lwU/C61kWIeE0N6GvFXQvk5o/zAvXVUNY9ZTVmg0Ix+zSKsevQw1vonJUGNEIqsWzJupZ1SvzSrlnb8mCtX4Hi7XeItpI9KdOP8CR+EcAsqwlQbCV8mYe7ptQf9iYEzQq0GNRcJDi7SBPGwAiFPSFJp5WlNe/dKnG3iSypjPAympzcPiQWtphRKnc8MOylwxl2rC2pnYAPrxAcJwxcEqMh/AiQhAc5DV+HzAopGfSKU/wSp+yZe6pyFgU9bb3QuCm9iVY95VG49Xlb2H/N1ZWE3udfwGz+dSi/hikPe9sUx0uHgskAx92WDHkmuO9BClOXp2zBngnwiCT7cwWpqcBc22yBufCQ10N5mD6W/8faEeZy1WjTM+PSXsoBmPiYWOUJeMujHLJiGlN1s2g05eZGye8GgC+EAKsITE1kjqqHGPziM7GOu8as4X8X/2XRZpOEeWcdu0wQXZNW2O0XOcYz0r97I3m5q6dUtr71SlF9XngyNC1dVBaH6EUXW5tOV9UWp7sjftwPdsghgIfSI5zHnC36KdyFk48RT4pWyocpKEPvByZ07CTVh2FY0EAd6O1fcfYV7akZ9NBwmN0sZywPlHpiHAqcDk1+/jZuSYDZFvwVH/FIVTh/0TilCe7YgGYmuPPwuQxt91OABbVyOSsTJdzVLlryUnVLB6bzdtGuOWN+MxibFPlamigAnKQOWOkqLMq7j5cEF+0N1xd/RhNb0mBpZV8PP5VGkgWfZ+JKhjkQ2DlttCEMXadBwtV5vW/9vpZ1IfhOAo3IRGi4T/CUX3+FfoEiFElGx6hNtaO00XjC2o3ZyATT9fCbW8pDATbX21KZQifl01kLempTWxuJNWHDUcyly+6kSNmAEM91kmb43yL5BVQgkJww9i27epgdwH8W9XCSujn4E4JU/0Vh/fm0vA8kkGgngXnIJYPUMj0JFfZBhil2+mOm4lTe8MRE0GSpcXCXcxd69QGmtoqWA7O+abaxBGZwCGiA19FlbsH5D1O50feWa0mYElCaMg/iuIu+232hF5bi4BvY9yhLLAMptPNyUuEXMTuqtk6Brubclk1SYELuEs0fXeJfGnSTjniVEeCA2C032S9ftWuP8Cm5LECjVUueEYXuHkIOsWnpPzcdkN2JsXkuN/EiowvicRwTrrWQLrAaakeuD+mGhBGJOL7rkbwKDQX/9GoJn6Yuwt7sOqdmRuRVnqhdPtmQYrNrJme68Dy2FrFq6VxUPUOcUUjzJLHUY/9WxQiohVfeTCzzt4CewMqHSUpi8xX26ksOuXI38B7Aq3nfGUj1Fei6duaOqp8p891V5b8WEwN1B2BppqkZW703KspebjVAR9us6fDA19E5cq/cTtcNR7Dh+vZBEMbEcXIwPoTGr9ExKRg/LS3O2rcV9Mb7BCp/CTd8qGnrmhrQ0MzbEQJx3lV3AQrqT26lNZCuAOikev9xoMUCNTszJt0OEESGxxpXYAfylT20koOf9WkzipLgbVk2STptK5b4hC4pOYJfgdR+q8y15iDSaCQlE7tGSa1J2Rgbs/j4cIQhKERdhPvFXVcRAJ7UBqesJTOwoi3b0MG7ZuHbd0psg51dLw+6NDpf9WF7XUHwnxJC5Dtv33eapUL5xBVDS8InQQ9z87w6efKpbJtYpQcCejl/FqNtvU6U/VJVdU45i3FWF1tZUAt5WUJ+CsbXesYpr6oFtdnEtjQ6IH/AvLA+GJlBr+OZImUOuqkJiR8PEi+Y1l1y4+pLOQAzlpkEkJHD2HWdmLGn2mvIVexe9OLCcGBhNXM0BRe6GSx6esoPFAsJeaghWAa3InOpm5pf0ax/K6c7LOxCbdETDzx2Fo9ewqH7TMDJu7qQ54QXzA6aLheuVSyvvt1nS55fvs6nldnQJTWrINucOKq8ALUiR3ITGoqFdvLb2lorF//T4DpT2zOshyCTSuybzQH6lOPXrafe/HjK2E8puBSFnN9esOLzCCtY4pFg0cbMiFLL4f/4tah3GdFJ1e5J24dr4OSeMlNEdsVwgd9G7ec3VxOgFAfSL4kHCLrzRpeUm9N3Qbnu4QqNzVG8rR7j9ccAKbFds89oBYhiGZ7UM36HFixGuG1WmhH6KhH7jmWGlus59jxCFzXmfhrXL/1GgBjjzEYw3TPO7Jh4F1dX4CPfMkpcjYTm3l6JA3bIjzz4SolYMWpGtcET0+bGREyhSKc18fHMRD3gxJbi+k2PS7TTBAM+tXNsmvxVlRMZtzU3MXIzWW755x5gA4PrY1WULm0VU71BECxDEGZT3tW1LF8NBR9kHfAAKbAPBZqZOhOCQ44cg0feG9xoePehxfRZJmQKUO1lfJyZuXjNsme0AERGf5V9AFNKsxHZAn0vRA+9KA4NE6IJegzk8XYjk4hAbOr6s7LYL7kYf8KD1i7cjaedqvbRh2lFZydAEw19L/SuFYlEGQJQN5yzJ+beRiJOFQa6TLi9jDdbs5dci5eOvPtWM2I+1g/vYowPSxMwYtN5tNehhlf1GfhoOXcYyKG7Ttxb68suf/S9mouIxqkOZzwUEuqDbVoj/2CEmg01DSkmyr91TG62r5qI88GcQsTseAokb7yxRN3eB0tcAm2RnzgmrssfUg76acQ6ix2LZg5KVtN3m9gomPG1r1zVAmzKifJnx0i1jYL76RTl8MLYiwbYGaOVqZNyAt0jqa/zlzz+JLFetAyAbNltRlG886kCNPEO913iUw3pQ6pZ7D52sPDiY30xVew7E/xzOk7YKaBTm//t/icWZGgVolDjI0CFNTnBDOCBONiAy2jFttz8qtJiSkM1BsLcSpQjk1i74qkS/DgpFP+2WekX65duEYEqnMR/cxA/TePHI/m6pJMg6WhppxfQDcQACfGUgViN233DPTytYlBdFCuOoczH4unffLyLf9u4N4f0G1O1QYl+mDZ9nbsNACN3C/37KUnAX6nxA2pDQ+tElArvtHkh7ik6AfFSMXvJ41XbyeeaEsdKK0Jr+nf8tyMKtD2el56f28NHhfH8WA5xJ8kck5DG4Nkw4en1vrRGA4pCaSz6OR6Gf7d8awksnS8jWzRo+NQSq0HEq0Nx+8EnEy8qvijG6TYvkh+VAfX5aRB6Zm9SPh+1GXt09auD38ITNvqWcVH5410phn4NniSzApWXw97n3f1zGbSSbkhI2f8i/ET/XX+L6WsSxyKgLfoKRSgZHy53jUr4N3kb2hDm6KEXep5jbHuJtqM1m5PKAzBOesTyhikXrxdkwulamt+OrN9AAqHGq3pVk1fJ19s5VacZh4L9r/waQk2CNOz0oKa19469dCGYeQhL+HFDP9stcp8YpmNfcwYuRdUq42xLK2XXKtGr4iSu0S90AnX+Qql71peCvVg6sCLsrwGkKxV2PPs7QUE5qxIKFqWT8+MK5oIvhmKplyHX0XLvwIjXRY1Q6RI98ZnGzDGaSP63HfDRU34ryCYcTtrdQDHbmsJ688qYlXJSM2qGm0+ERZ4c213p1zIR49cqQ5+cHkuy37unjtC5n/H//x2N/4OpFFICvJyOcNZI26oJoD/LkQeRf1KHwoOr8IolQQlMpdcJ2lgGGvCownCmWEEoTsOOuHxHy6SPLZp7fCa4w1Ul3oTmxgyzHWt8H2Z8g4ye7+YLNn+vZdMChiZcMMAeoACZGsao5VGSI2fedIEfdN43WNNyf/0lhm3i+yLoinIzws1h44FJ3au0+wQXwh9jLrcFzCsoYzktRY1CygY90mbj1VyThc0LjaDCBu9oiIhyUIHJASqD+jSQGnRL0IXfFid+iNtsDlY6HjSSSBKYuDy8zAm0cvrUub+Tup21k7wHezy31d3NfhGO+FVahx6L4XGZvY2kNfMbL7W5Y1ILio4jfOZwLevUddOczrhwttqAzaNsme7m3l4aJ/ELqIm8vu/2i/9np+SbAuRjd2WnCGsSKkTkJNv9WuI7whGJ0BPesvqGxiHqSAuNccjrTFCNMnpYgHX0rRIXtpFl5CVv0TK4/i/fCUD1P6gV88A0u/kraR/EsZg1RhP/5d1MRxj3wxjbAEo2CxMGhz7jNWKlRonUOTZlI0P8KgT/ijdFgIQoca70DQ3KtQEBV50zHzV+RR91z7X5OhL6QFdtO34041ipINe+HPj6+vJ/WvH46H62DRWfj7/hXAbXwxbXGw6VRlJjKX2GixhALuHjOVINd5i5rM/UScp8Sk2iteDiw2SStqfU9ua1a35h1nSVnvZhf/2OvM5qLA9FwDzh592R7paZl9RgW/2IrNHjW5pKlhHp7VIMdOAC5k34xLylHoK3eUgY/UizEpi9TZbfxmpSbGnPe7qtLL0fltos5sAL/R3MhN5f8JbVGZeXsipKWfdeAGRzG4MCucdPPrYA53jZpUiXdRmHoDYjUh+jpI5qCcCNJU2HZg8+3TQRTpeRI2wll/XvnXdDmCL56cODCZ79rsKRT2x27qRdGHdsdDnQnwoekarMuf94/hyJBSUyP1ZLoglQGV4ZGTgYVPbyHSGUNkEPOW3WKQ2Sr0qlYiMJmtJ2HZSql6cegu2MLGvFekAqhaQYPD5HzZW6xzmtEBig8cQ02CK/6/HK5nG2EnGEwgANhKxKdK04aPRYiPjPUndoGlAVszp2sIMmo/Rn0VlpMKt/Jb8ASmZo3fHiM6Hywku/fu3xLanxhC4BGUP9CaqKTpdt8QH2ScIbE8RXU2l63H8Gheg9QWVTtuJ3T775dPFXU5tS9xNIuKkESYpdamxDY4jc2zJgm8qUgByVH4PpluOPKweF86LPkp18Of/tv3Pa01bvjnOkw55rWH1l51Ga78EfyTMmuLcfVfbaYw0JZCi4G0X3abFANimJBnOLt30jPkXLFhV6opFO9FA8L3wvt+rKJ/c4Ec4LEMZlhR0tVlKn/jqsagnwkldl2iQr1dcID+LCzVkZf89brD1FCoaLOoUuExAqFVm++YPV1UV+cWY21/SCAT+AW7oRsy/Y3e1LYT5D8+XqHI3ZHc3p0hIEDC31okyb5K4YHpFCOqDdKjeAojFCA19fQC+NSheu72yF1TPVsSulw4ENSXRkE9xZL0sSq7iHdDCGueER1SzqdWYgOl8WzD84xtb6w12I7Ecul6vNbdW9SL3Fbz6G/yOo6PpfGH6S4XDmMRg4WEZ8KuA2Q3uGjKyrX1aVb3Z+HdzDki7uO9878zLpfKCunWk5siPxTSXqdmyBDXTVPiOZeIoFX4e1Qg9dMcy7WDD3giwLnWighEVtkBFAT+aMhDvquSvNfVsIx8UKOYjhBHYTAAYX4t1x6zURlGBMeM9E2M38Ar/k5VcE1HD2mWcb2YBjcAFy5ANH7Yk2o3IecbEH+JHKUw7g/7EYzvN3f2S+LH5UI2LFf1iOvNcIwEyWWRvJqWe/JBE1kFVRTliLBmEPhjironrxHnD5Cm1Pgz0PoPsHOOX4rj7DBQPSomybJ9uT2U7B6yv0OZ3+bNiszf5qBYT5Nhl7i1QpAYEDqPI7baywzsLCGNhnfog//0NgnG/w+P+RuSudnI4OdEUFEseaFVmixzCh6Zm6zGF92r3pOKS5ko6gE8y3DVngiW2cxxEZG6oTiKya8gglM8peeteTOak80sEhZ3UcOIA/jsUJWPwB0k8PHoA9GocK3pnxDeYVil6UkGgdwlhsWKPTR15ZVG07T0obeHfuUFxD+am7x6IV8MgMMQ2kTMSvCqkmqGPPyi+1jUgR2ujoJGwkXWY9ZssPc9+20q/smLR6wiY1oGTitqhW7ULAlPWmp0IqtCxAODNZ610QR7RQKcQ84iP2g32j5YyvO7o8R4f+/jhtXslzqxZRH0bI0yfhaI9HPxz+oeQI95m6r7k0xFuhymv7xBIWJZyGfAPJWHQA37UY1V7ocFUfEu5Z+wptfu+h7eF22IwvLi1jP6G0qrWXlV7CA6XwyARYvS4gnMXE5MDfcAF9tnOPvYbNNE/tmuwF5nuv4FXZuBJH/nPBwAsHJ1d+MVV1mydF1F0Whs77ucmV09Qjuf/BstqMy+b/v/m8FSImt+BFzoGjrz6O1kYAIs/SOTv48uv+WIu/kEC/9w8LPg23MvWVivV07+pXSDANsbNA/tZTQGQi3+CC9FdBjSVw8Pj5lXVf5pROU/Z5XXGFHoVcPrlg9T3qoheFeDgrXdI56t8Ia+M/cIMSS/g1G5/s5HjSJIIyFraqMJjzEyd1v92GwCz+ILVWqkr3l6fR+VcAZFsoFdRdhbdHtS0yqa8EN7SmSWPiWGMQcE/V5XHFiJAtJ4jNFKIQt9RK6P8EgiNDZOaDt5b7TkBjYb0KSkeumFlzueabHsGB9BSTG2pDCnedmt1gFUjOtU4h01Xu51nK22y+et/JqFGWAZWJ+chh13wsMEaOJa6ixQQi8vle/MZ/WNdCXOX69uk2sheV2RmP9P6S8vc9SdtH4+Z62xa0UGCKK4v5cw+aCqbttHYef2/hvbi715fj22ItMkGfKAPQR8Whi5/oFzN96tpjoYI+Np80+uHPPyEJlu9UTF7aIyOGoanGbMmCC7yzSipQqS+FvxtAwQrLHS1BIwheEEJyMB3jCfKRatsXLUGO2CGMFx5AkBRupuVWikPJR4nw8j0kBTSESJj7jNFK9q+QdnB4hRDJ6xsX5J3xQ52WXjjwG5vju8ezNHpXbfu5EnhXRWuKf1GxCP1pERYYU2C9uA5G67H38KWpTEQqW2ZV/4L21L+CrGmEcJ8CupDsB7bL1wlFAcXJZmJbve0ppGBEhri6ZO5MzXJ+nsKxRAXBslm8rGIj+MlwyXB+r/bfkS6Eppg19wNTXa/k9GeEj0QYHZn70PMMfdOo6ylpSkr1OAk6ByzsMDnFATvv9+2HSe5y7wSrT/kFXBe4toBTowuJSK9MYQ5ss3qNalV23hkquFh0sCWRHloCS1FX6K4d0a4UQBg1JVDuRk4cQ3EQJbcrtsbn3yPHlK3tCY5DL7gQyrmVMMC9RD9DNxdnZlFjj8mAbI0/S95upR9aeCOFq2/GxqxK7D8wsQbsAhTrvFcu4397RDYPMCzI8Oup7ALD2htzmqUAmaC6t6ucvEc4d64cygbwWcsxC/h4Ejr4/51vHlYNCt7WPlu2HtrO/G6GPKz/DQJsiSWsjY54GeREXO7Wd8eQsiVNKbsNnGr/Y0bjvTEUK0beXFjYZtZ0IFrmHHgX/YzxJeD5m6rYQsVpfeR946OiH5L2Q7/zpCZgpw2DELrTOd2Kl2HRkqHDKL9zhixEsJ1A0KT+Zcu2wTWYW2T2ik3jEJPBMs/1JRd0ef1Ce+x4cv+PcwsKbElpGpfUJsDRkNF2bad8cjCrALSpAnnp67PlVlTGVXOPx8Vub1KfhaSLZjEkVUMVcyRSrgpaTm+o3zCCl7+5nebsEN0JD3E7shJU/a4+OdFTvFdNZT1ZhFThTJvdGZhu67elBQYifVOIEmy/87cmunRbczGBfaH8H1bKTEvMAaPrPeG9x3+E50onEb0X3VhZbhkug7Zqcst04KmdmLAEDsQV+T9pHfAsYe6Wd4u6Y5QaqCjjdKli65eexqfkH7wpTNnoDwqwRsc66JLJ0Dv6w/qBTnrYIsVXWPGP1InBYHDO88zuNNko1XMeEEj+ShCJM0/Edjd7rrTCOBOLHD7YmrayGfxuuqLZNCDVL90i7Bcd+A0QYF2xl5dCuCNE72dPySFl43oo0a1uCAPAkwPKcfanmVurZM2ZoA/iKeoLT/09eBjWIawlUAu4XyLGZbsvBRiGcKCsQABujppfSePv/ygf/olUyRffkMv1tazQdnBDpfn21gnlPfeHSXSMl3JlK+EH3QIwUxzJDnvbN/arAaUJiLX3K3m+ETh0txoae6NayKutvdjgxcn6soYnqC6FG3Li4TCr53sVqV8j5zpYQWnL3JTWSmYOqxI+Wmdm54GOQGpNBatHDwe3gk4pq+Kbg4IX6GLqJac/x4YTnoQn7BdRAlVShxtCC9usiiGnK0Y3yQk5AKRmijQnLnqyo5ilehA285bxwhK3gbi2puBLWISmtqO3O8EMEb9DQiJ36lCN4yoxXaF4+kBNbF92l+e1Kd+SZOVEQrHdI9xkE4sj8XtvXA0yBqoVuUERjOOO6tkR36FOeKGsJAR52dJAMOuBDJoCZ6Hn4CKf6OoXjUR2qQcaasZzk6pzwWdhrbGRV2eTy6cXibLYgJKmywkfFsMngcugnIcNP622hJOoLsGo+j5fxMSHm2LWoyJVw3t6+ZUtd4Dz093fxQ75pWnitvAXUEMP5C7kQ5vxQ8rwPo/E0KrxDjRJs30UlmM4584yfzK42DItTp6FTletC6uNkKBw66lBmb5tbAR5lXtVqnyyVaUiMr5Sy1tzEAcXdtGqctUr1U1EUGxVcbsUdYCYI39VPwwWymuM59oJPmIEyij2dCPxAaxYGFlfJ/ndnGPOimR9WYEor8ENIJlW7xgjxrI9iphe8LitJ7nr9QXF5RS4jTOm17BsTTAD/aZDRJHoC9AF44swNvBlYO+j6NJy/JOIzgjjGawk1d9bZAvQtJzkf7RsBXKRGMjR+kuWiF3C3kZci0GMhgYDHWCnvzPi2GTu9+veatb31+UfjMTJXPLPF6jIlvLRruV5agtCPNnDRnZ363IRvYkesjNvCu7OJkE5WVpho0ULCjaVjgzMq6aKgAGgsE8YVxQ0HhVR+r7G35NxMtVd74giaNyWwbKCEhGmEbJsx7VGBaPODmaS+PBvcZuXs6MW/tG2CzNFD5whObQaw6k+b4+5+/yKEqZm2bmP6NRcxy9hEiL8hvUhxHY1ChEPFpiLOr3nf+9ZHNNL8uF2WGpYTNmVzZHWapXKRlq4dSofZiNg2ZsjePJvxjsssnLSAIojJFZ0RKX8Wpi6UQjiZymnqOI++GVuJbcDApBHS1Jp6gsN/rY6X10VJyypoh6rccqygPAdLnwvvGrsJ79ASRD2kn9XS7SOA2VwnVmjuDvt+ls6ONjjPDyFiJzDDJ/2SoUeurYTP5/pK9fC8nA6pK0l5qRaZHyn/jtm7c/zKqS4OtknUSX85DG3QsroDrfSOKgDlBD4YChhPbUn0YotbuBq87ypxqBcMRlDHd4+6Et+fdtXrluUcviUuC/0g3g16QQxAUWMJ1OxgteWqUtaJpcrJd0aKGsFmphsJMZrnmp/+UVZnWcw9l5PMXkBoRD6SF1MJlzRBo7QBqTplbeL/7AJqB1fhLyzIEvSOlC84zz1xP4N2eh2pzYS1Eh8n5gi7kyWRHmtk8dCU1wOp4vUjU9Zz9gdikj4bwQrIWIaC76Uvmp/teB0ajJiP2xV54Zst9m7exVb6bKU+dXAy8q/82riWyi8pgba7YRmBpxuSF91wdEjUQA/+0nK48vGzn66YZdYa1hFxBueiQ7UIMqcgONi4bYA/PWgRFV9lulPP8leA0aqBN5SMXExpYmYQS8uJrVAqEk9wOVV1FFon2vMrAp6IT1vgRWdpNtkFAxpglpgz1pXNzZBLedgd90KFAo73ESGChjPloQupMlTjuWNBTLyXzxytRlpQo6THECOY5e8v39qkxE1XtelwVL4qmtW5IQea5hH4gOnA8TWfljDaOA3OzJAqIASi/kUT+Q/5A1d1sAMNh5z/ojweGSpmuTI0AVWmTjA+qCKuFbWviB9Xnfc6BobvtMloHxN3gtF46KU4A7K6yRw4Db27OFENT038+Z5qT634nuJa9VUkkQxqTegwcWefqmwUChz41do8GoN+Bsju5NR2a2i96llgdBDZdpz8lshP7YJTUcU1RxrtvuqDkxTEQDa87+Rzb+Vwc+th4dAapN9pqJejcmQ9Uay+1kRgMk8n3C1I/LPOdJQOv2mRogUudoyf/pye1OXCN2sQBOp3K6gWxY9KKq5ilzutgwaSmn0EAQtv2h2wogFxLFdfTw235P8biA48ldav+Xc/PSaS+sUgcUJAn6mdxM3Or5YRvoCH1nNssHdIq0GsYtXB8DEc1Av/i1eTzlf66GVdHNEDiLb+iP5th3Ye9jXNeeEsIctZT5ftTLZDcq7hFbnd66TiWbLJbSktex6UKpGBNJLCGEiAVo/zMdLLQdM4mZsr4wanwRKI32SDfzqpMxI4j1+I8NuHKsfhTx8aMV6FYMykNnSbY9pFKqEsRzT0HRuFG6+gqHWfSXgUT38fcrbZz6PbHIsZvdc3KUrBvlsW6NeeVjn7AVbRIhdlanvTDvtPIWTo7d8YZ2Wwcij/LCdLBa3sHtkWl7sEqqx5ZEbzBeUEEaeDw6vN2CGla2RVwmflsmxYTqT/p9oRaHiVcurD0vQ88f+Y8sBydCC3z5quMleL7yyNxBcGatrxtHJRGqqhHArFTbaRQaFOQlCIBceYZOs3bJUn/hweOpfSGhtLq9Cer/fUS1yHU6OlvqNaywQ9MOQXBOBoFgFeFauXclDBcGgj+NgcvYZNmbGMwn65dVbHbJuT2uWrf79Iav7jMRo3c4jcFcUitg5sAqRzFvePUTO77/plEAheFyg8ZDVUOhYqF80gwyqqrQyGKfSFB4LqV5uvgi9gg7CSFzQUmmSoSj4wndi85Bm1oWXQq4ezVrz0KnXzn0l8fWJQT9M6o54sK3QSHJsGcW5UE8HHUaM4ZpPckexM8+XbSuWU0xwFV7AVIJPxA9eb47Ni4Rf3DqjfporGO8J0AkBiOFxZ7iC8jtj3FaWAGx6Y7vVMj21t3tMvJwuqZpLWtfKHDTiURNORDwI7PCacMvpV6QhY6RRFyzgZ1FEfho4JMoEBEOtVn9NN6LtH2bXiGoEgzxljffiygyQK1BleJhf8auZTwXhaqVB4+y2UA6Q/cKlP3SAqCuz/exFUTKKC+v4jz1+1iC7JFjPaWFOHR5euS85jr2OF2hGHBoEEvLipn4ZB0tNgrwGJ2ZPEnnbgUDL2Jg9xKPOascIAFDNsY9Bg3eo1UO34aExF8TNIRWTuiomhJjG9xoMBdGKAFUEffTtxHUHVEVlryzGZhavoNt/Hs3K75HP28rdohE8Sq9ECOSFjenj3DNHhpKR86dU12N6+j651+6wxV7sCTS7KTSFNfqGY/M02dhFfPI5U0jUAsB013YO1ztcQGzMMwXwIpXn24bq6lHMMwMUYNDZ991KT7WtjDU5Qz6SiC7ndCpE+BOXuSX3QMvemwk2DceD9aRcShAoxuAHIZsS8xhZME4dFJMqwX3hMoTp4wJRO9md/UqLfF9mgFx4T0yFOVr7T7PUAi8QdX4aYR7zwA/amCul8do/ezxTUXQ01C4sCV1mlHCw78+8LDkiDS8kGls4bsxThgZHA1dC/a/KUtFPmyC3CPfMcZ1bICBRr20NDk5BNMd9XQ/eZUbsaMbfQMhLBBGGbninUs3QVSn9pVY/AS5ZeaZ5jhvEkog3Lzpg84mTI5dL69/Vec++Dx9Auv15R5zyyxhKqA6WiwWBUepUbswpeilKWfcHe2d6y4rqdDTd+8R+XAghC+1xYXl9uqj0fb1UZuDXKXKR2Q4jBmd5w3oqxlBRmMC9TpGv0O/+tw5P5sNXHt01OJw2rm/RG2vLBcVlhDNT/ihgY3NFFsgpHXLO8Nubc4123hu2qjxyzwOdg21yz5tBv1sAGo/UrTJ0Wm3ascf3+kFfn9F5Tf4k+wC4djx8wb0mLnRXbM9o1hyXrMlONJvN9jT0+DesD3200updYfioF0xyrzacQeKW3Ohh8XB0xxxXsZo7sPo+0gAI3L7m8CXu7yeJUn47dGNjRub/0AkblNeZK077vgilKJF5WiCCjjzrrbvsHyJFriFP1OfQTGXvIlwPMIMb708I/A8Bny1jKs6UIoDzoiryUCXfsKtJzCm0BFBMJRu35Wb1d5aQGhhcZ38Zdesh7oMNRq3wfGtjF1PnfS6YIF+P797lsz+lHexPcaik0Z860sZ33X/FQmNXQh0COuDgWCMpQr2R6Z8auCzl8OfvD9TUR/Y2qVL4G1AP+LIIqXOrLbWrZmMhLJAs/ME4++gU66fWxBRTSXe/WQqayurQ4BaC8gGsZptKkJCWMoe5DXW6LVxMGgPZ/guPlY8YvCVsZbjoFoavjWYqZBqshpLFwyiKFU3V7kKbZL8yPqb+faj8nH//Zzevb6za76wmeiWWyfIuoP4Qqt7GtX1R933FKYLmlAA13rNmJNRfPygxxkKOF/nTt+ItzucKFVkzncE8ClBzdA25G6gMC7C7ztEUi0IhRqKF4c+iZ/3YL8Cz9mrjRLb2uVOqqAA6Fd0vXl70p/E3PcBjR4QhUSwrRDqVgTBhp+OmFPTFfW311nFYdpV2OSGUqNqL5tLI4ZpVnXkJk93DrRzLgXYqd9IuerdReaIulCoaTQHVmclfu7MK7HqsKN0G+tlR7ja6cU3QCVwElyrOgggEb2SFyU6X7CqdzH80Q8AnKy8stH619e/b9ZuqRvIFZSCZpkChelwvKMjnCpg+3hfgpd2Rl8P5JkPBxrk6Y1p5aKdw8mUqHbDf0wDBo0QzdJVPU2OeEh+c/BjFV8zjfDSAdsJu0Dv9ii2CtA/U386p5u1Qn2958d9nQ/0TAXLAdMUDaod4HVtOUnDzNSU6QnXuuflcXxejwNqO8v5qoYq0LnKx8x1Es2oSM95+QQ5udI8v9YUp5hb7/Yxapgytp70ph0lZBXdksmwcV+jSVoqewTbjaaB8AxnS8BDP1s8QhjzBTa2X9KpzsepREe6I0ol3axeTeh1On/YfxdDsvWWa2O209Ce2oNZxfSqG4SzHH6dFNmBzMEKRG4sajMGNO8BaQJk1JK3nTdN4DkutOtpiftq7TxSXZHAK4ygNPvLWAf5qrJKh/YcrnWNlh9sgiBnXNTFKAt01dbuwkhOQ8N7pbMBp/Z+Fde/98Z6yNyAQ806RkRdYtxgcoXxQO/8ooBHBYORqQ1SMdoeTYLIHOgMAQ9U0jic2AZz/Izjk9BjIpXLsN9CjMLFNV5sS8LZKUL6Xhe9RF1FHn7GuOkKUi12I6iSF0c4+N0wceQwVUtAbZrcYaZ9DbI0XV967FvQPSAc6EE7XcRcqvcZ5Le5kMTBUykFfqgDs6BQlSS1DPmK1w5ZdqkEjViHz8J7/wC0sBDuHh7UqrVGpHHOPYIoueZN3MwmQpKLEtWTJbSOAydDbAGTnzWO+AQeehZj4f5PZXH7ycq/dHhilKH8XZZcoKh0XRnlJkbWf5XbrFTSplF59pC3uQKMdJtVgqDrbENWVUZ8FdiscVuKA4M2P4kAGQnz8WRdFBOqA5NEdEaqwYX/RKo99xM01r939o8mcq1AiAtOUZUVOYRgErrpUvzp/RYS1O6VPJtD1I2y0zXI5dzvgjWgCRrrTkhhh9YGzAp8avM0N8viGggblCe5KBmsm8Ar4Zk0ehVW5sCI4v2syAhaFg41haK5hnfiKzWOmxZPTxr/cqRV2kHSELL+eSS2n4BMSBVT+h8V55kllOAAC9uM/xMDqMiOIgFbxWsHBE3PZORhUVMMvheRyqyVsDbOU5rPviYbAeLyjBtumKGuXYiwTSJtyiPXc2kIPKl8TjxoMPeQU5pA9suYI27EIExxjtKaoPoP6pPTRHoa9sOK6gJ9CIxEWZs20XxIbjrfirT95l1FGei7yB1rrH0LFy9HdHqgPpzpQgCC4OU/UGhqX7/fobB2CI6heNo/gH3W445i00FZP+0epGrGGLhtr7v3vxnHF8lYJTFqlpY65jrdA1mLjdoS3BXBa0GqhUNeHJWEBJJ2F/W3N2yj72K8OQipN2fCJHAZmuuRfiWzZgUcuSXYjWggBXUIB9gHsae3YQ25kCj8PiO/8pIjai5gBU1QdJUPIrgr0BdwDpaNiTMt1MokExZuAHALtgDMidOdYTM3hQdRP7DbZABDRRsMq0xYiomSioVR1ohYOJ1Txv4ITmpGKdjgIJ6BbOywcZnowboa8mKmeUfVoebZGml6nE+V2n2JZRxX4PbFSDRmZVSxbL/FLWHMs2B48pFBRdEn7H16vCNgL0Jg41LGUoS3wfZm+nJMTMEG59P78taRcHVIQnGQyh+FMOQiFVbXpGWVkxEgxCT1FrmuAGxHSFOCsV2ZFbi00Y61abHDBQj7sehMnyudMHmoe/alBAGvOmRmkpAD5a5+cyrT4lyDpcgyPFW9yWQtSVCgULzLYIGU6ySwUABgqqEUxO4XkEUnSkRUeR0D8VvBCf7BE71B50QNqVqux1jqZXJKQpC3ADhGy5P9a4ipuhZHR7vxVG/ZaXukc8qmSgMJdsNwv3M3f+ItmQZl+CrFdh9zaRmBWF7J93Y1cN5OUNW/cJyw8jjTlepL/p+kMnt7QUZuBv93LhQ8abC12JsjO5bq9OPZkwopwNnImq8HFZRzaUruhbT8oBcP0IEqgKgMeRCbuk00MZ24QAUF/nn37cI6g/fDMO72IcNIJSUZChqYNu9RSZrGgoFOD1RBvntPy9iYWqSNgSvHhhpNumBe/cBBFV5RyVWwio+wkzXGZ5QqGmP96tRPHgs+I5ACV/mJBSoAO4GSsbIYv2SWItWvg4fb7xew/CjYv0bHDJ/qMpAEOPNpLIh49KboyDjDAlCQoVm1CFfGdfVfeb0RbDxrLvE8BOJtPvifepu6Yx6IpsVRSR6EKv7J5ooXhVfIh2Ns2jpBqTwUAwZ0zdkaCB5z9r/bN5XGvSNM8Fatu4W0AHljk4KHO1akfmoGdmmm//IhAZxxYlR/2rP1WzftUl7w7Onps5sSNCZOserXSVYTDrwr9jSkfOg55AOpPP3Nk5Smf+X0KxQfZnTFEQZC134WOkn1CljwPXhPMR4dLHWixsHAQDNAG2KfW/ugvHBGtrsDytxyyOj+u6w4Ujmq97zTZSscQPElHeBsUlA/w5iZnhqubozHLUal5aVTXvOhRnrZHge59UZJvhKOLCp5saFDEOFYKhJKPeu4kwXOGfBFo+ODwgNJP9XKg1Wzsx+vJvixUDLqn+gdCG4tma6zSoAbKaWm4Kwe3dRx7iklWXH0OMEQAZbLCZIBeAJb6JXH1r1SZkLDLaI3+nWs/OcjWibYlZuY5YgeiDTaStI7AbDrVLy4wd5GSLlYANLxcKD0m3MwbxJqmrNXt+R4vdz3xlBJc8eqPbkYAjzSpDvehjLZo5jAHvYwkJ4K48GS4m54NMJQCcmvcI3jC+qBUMgikclx8Bp/qRuyL+lJ38vzx4zuAeSQjrVx9yeSJUBDISiCgZIsgq5MRv57XdAagkekfSG9yTmg1ITi0cWXbplsIBwSQs82v9TGgLVQ+3VHqTxR636bn6IOm6vMrpoFAdyjUopBGHk4yB+Rk6NJrq18JSjOd2wnHY39OWcK0KrwbV+bpx8LBCkRNjccXVMLDnmWelOqSXS0OtxlMaJNB6byjCK3v1k8pL1iR6waHeCBGVyQpdB0NeRBY2d5lhNCQsKC8qyqQJ8dBeDbbCGir2Ny52cn7kni8oWYS82A3qrLx+QjBJm1bjgpkvMEqKjQWhQo1cos0k3FMh37D9CP7wlGCJEk+IltpDRQbZZl9mbxFy89M1z59SmC2Aj5Ybyg2pKIhm8FvgrznrKEKiaEFilk+sesl4KcBNtUwOGNwPjGv+POlKjFmjSDr/C7zJu701hBM0XgcAwKjsMYvIHJ1jktE7qlKgDigvBj7xTzrE4EaNXjc9bDFrmnYaLJK0PvWRz438bK8+7aJPDrgQqoJNZf9xo/EvKi34Sf0iEp5sr3SbbFTM91NYQJpVxZVgtpm5rmZJQCEsLtYTQqps2QSG9jxIN0dwFcoWdOPgU+P2ze7tI+Z4ici2x86hHS8+qtYX147VEZtbALatoLYL2OmSsqE4Fswk+/ZG2lewlykktpgdjyu9WSyZFi0EKPJMNMvmsKtxdm9KhenxPfcEZG+QXeXUFL+ARyC621ijH4bfbhvIZTJ20tXXFkZQP7jU921D/iphM3W+h85uf+xkntyUYSczfQCd6dpMBH2w98SEsj/G5bB1s56lPLpFROCOiJMyMfUx8AdvWx2F1axXGP4cQNSGykd892ZoGtCKvm1BfOD2Zf0L5QI5oxyC7ooSPG3LU55h3XgN+ZdWoo9GvQWQyIc9bDkTIUtlhP6gOqBcafi4QgRzVOrvoqDrJQg4zNqR+e1wQOWich2KgE7T7b2r5LYEC2w5qD/QfGf7BnxSRcppc8UZzogvj8xiEVP549rgJTaq+1QD89KoulJ2X8E518rBHWRUKUCeN7H+PvZeXvla/yZvi9e8yEM35ApEV/Hw80UZWFtHrBxQYPsbb68LFnQbAt5i+WMqNZa14irYpLe+kgxvEbBdfEyTbuoTLAi/u421/RatnMUeMPKhIObMSdh7GqYcxFWoESbuC8xpDCryBJ1mh7JhKRKXsENcPLM4ybWxnMcxPspgboWOeFYz/LU7VH/OKWxFKbGuCHPABfOnRnF61X+p1Wc9hGGtq1OuaeeCQ4X+zPrOqA5fvzpmNV9jIa4JEoFz6zHtBMjf0On74JM0Kohh3JZJDfrycjdVUettpKxEzLyTm00e+9ZARF4/LjpvLQFXEXiQMAt7AHOVZ5rPEp3x2YQQH9ujPAXd+BKgtT6eYF29Ibl8mHfgj15Bk4AcmKmX8D+ZUptuGMChvG+Taj5wqAUhbY+dQ1sSM4mNZ4GB7FgUaMAx+fEjuxtL9LjLvWxOLdIXi7K6SFkr6ZcTWVXoJ0xbAHccbxGN6gQpTyJMovjBPICmCcn4PgqQ+By/xul4AUCyglv81cTAKSMaeLroArs/MMVjzKiRKZFldFVGPrwHi0B/46ljt/cd9INLiFfc+qw9VlwoYvSvdwgXEb8K6OC3Z5VZ1HSd+LyLxwRiJCsD9ZluVlb0o7+5BYiji3+iuBoewl7OAahLRDf2BfEbq/OFslKW14y15tXodnvQLwI7AefvfpfOtyfMkXrsJ5hj596ww7LSGeHSdXJ3aUYAIgagLHi0IEjoNDSNnXPhIR4PGDWPw9InYJjLApr2ddOaWkZB4iEzoAuu09qCwpKSZDG1L54Xa/M3kTzCrWwmHn+IkCcchPZLc5V7U5J9hEeAYsaEyQiwD/+YLP5DRqgUXJBL1HKvrV5uxTZ7PanfoYT5yPz7J+t0XDJqTrvhRRV7X6s1grFo/MgoLr+KgX13MWgrBAMSGITalaVVDspjh39yuE8poaytw2tv7Z8vqx8izjf/kdKA3FWygU0AWnqIDgfoXfwghnXHPNRnv0G2Y0Vn5kdMdCrDvB3LKOggsXxbvKKQobJkrbRfBYDVnzDJr8sISXiZwuvgRP0r/z13UqMzxSHlPDy138qSl2tplTf0xDslTqh3nsdkUWwZuO62P07pBCPBWh0bCO9es6lvbkPL1IJdedASxK+H/d161MeeyQwpQN+fAC48JKRSs3YjN7eF1Pkw8uqmCwLeShHqMLp58EnT+cBHn8UwM2zIjc7xysdXgDuLsk6GphoYLYEaJsWeKS2b1BZuM07n3NNcGbFc1Rh9L2PwvUgs37G3ewCuz6S4hBmsw/HIqBlCoeVRlExxwrwHY616PpMosRRWZyMc3be5Xpm3NKAaPOnazNqFRBatsEQxxii4qanmFiPy4b3LvZcwuPyqXty+ds1NPlbzqSM6EcDqxR4qH1pB/xx/vXjEjGxNkz4OAo/EfoRLORHMPR3UpsdBN3iosvUPMo+l6c1FiXX26R9h6BKxjP8UAeZfWvPvKKc+fmPbeEItZFHDT3Hn79OmwkK6QVhgAYhaC02Nr06kVHtJVWXV3Jz6ZSFTgBraUcU4P/K2UmplYfMvbkWX7mYEGfU4orcERKmkd9TOsmEXSEb/tyAN/AiC/8Ac50Sp2q0/8qWf7/d4mqmv9oI+A7Y/g9DW3cwRMVQqb4lrbii6L4GEkZIorL1OonG0+apaEeVye2BrOuJzCGdBHybzh3dhLzG3qo9/oug8oeFhk/g7JpW/wtqLkFPY9VwReMPFwy9+8VPqrBste8iAk/dQwlIoLUu1qj7NwKW+Po9pyru0UoxpDQJKAEa2n9bbabOEahoWIOdCsm9YDja1z8abUQAP0nOiCfiMcE1/waYTn9GKqK/b5ANMaTCgQplE6f+kT9fEsPAa7nn9/8R77bOUKw7Po7jAwI0DjCYxVingg/RErveuQbdTr3AUrTEaSoFq7XgKRis7Aiac796c2GwWa2Wo747DjOxv66znbqiGQ01RG0ilaCWJ1Lu1jTpqKW7H36uPpk/tOIqHym7riDqYA3FYBt91vkyfHRIRZU8PYgaphVNsQeK5g4BSLhY8Q6QI0yrDz4aBql0qcYRMZ7LV2qqqELNsXZiDkbIy8F9U7lb0TopvH8ZXD6qSVPTRBhbndcghGTH1QBON5sv3PEuhblEMi/QWTgngN/F4uRaL9eqWnGgQ0j74JREwoSaTN/jDwuB0Yca2WmxJ9f+5KUoBjI86MqhzND2o5Vc8JmmeRqiTP+grqrY7tiKh2wnRAwVt+K3N8R/Lc7RlW5oDoE7oKuUzJ24A3atKcSOMLaViB7et3QWIiljSDdr5nxo+eVK0KmRGCUJmN9qqm5kMYO0IOLanj591UAHnHeHXnt6Bs45WlD07AoLdNla6Ir7F2gr6m98Gt6GBt4aDKOWo7UdgaRH24vegq7CABMjoSErcLIUxJmuP2iJ6xq328BmW1HgCTQvpiXE9ETCqxTvLFLrg24iDW8/FSVt/59ZFrGjdVZbn7mxnR7e8hLFgx2Qm5dhaZxiqjc9vvUs4m0FZEwMxjtAlrCwqZyaP71FM+0QMx3ake7mTQYxF4lwPnE5cGJp/637sZtEWAxXoqgeJFh6m1l3xuoMU/U+DHE8NwfX4hXKUaDgbm0BEWHqzItDrMvLECQ5SOwjHmoQWCfLzFaR2+a0fUs+ASH1NJTnKOnORxcXX6TVZ7kHmSZBAY00TPCKnuGwQD8REO1a+JxGbLQ66+LVcCZJ4CCX4qTI1hK4JkV07Ig6OTXqGYBwyQKSk07gTHUyH/4Vvqf0HzUJcR804X90zLqWrOrvemqzGAQIjQCNZ81+Thc26b329A0co3ydsxFcAgVqw4HybjFefgjgR8lwgyxeNNleikq8NuoAqn6/RwoxjmEEJa719Iw4CGsG214LSfFQvltRv9AZAMwvwLkEK+WBwypLdhXf3kHsp16FcUkpEm7EpXNWv59cS/jetVzQcIEch3B+RwckRJl8AxjgpnEO35SATmGcfhrJuFyEXPyoTfwnYwAoQHgGe/kCjt3r3DPmEhaTQ+rdJcuaymvhGNjc6z3byvDixfZhVMPtY3PYuu5vdZBLDBOkL3A+QCJPkjabNtG6puWBOZ+bQLmbAZPa3P9kObDe+cUAkRvDkdpDPmjwy6j9Iif6ENpIox0odTfJKhGKjRet2Rla1rhqRVey2qIGPrSG949lj/MEd4aYIQ5T1Ev2/MOZc6V0mSdVTxS8iau3QbY3kXhuDggS8U3ePapCbaIyt/cztnbF2Xrnd2T98z74Cb1i/u7hHPz7ebDYQzxqtoTJxZO0KuacZqH/Loy220Wxo+bYg6SIaWhmtcKZ8LLkibuUsyw6EWzfpnk+Nb1oLCUU1RhN2mFcAAXA4rT+lYEqGIgNgXVJ9nkNV4c24xgYDEhWCP34XI7aJRN7x1aR2Vvk0uc9AYlCSI6Ath92WIwUBJAHkAakBecHWorvgvz7id86izfKKanV4V8HQer7BKmReL0HXHvqSuvUGIfe761t37kDPN51udOGU4tv2X5Wa9oULpB3t+zq9pjOF3Y5wYa87XfYiFKPMbcGKMnjf3UuJdgoZ0JtB9lO3NWFPf8UZqXPNySmtkh3KrXM0Z/dVPV2Gb5rM5I2LXyyORazOpzoD35yFHNHuEdDcIqXXa0Fla5pahLvs1C+wUAUZkRhrT5G6csUSVX5Ae/UX0Ro2Dk6FeE55RN8FqimUK0bL3tAgy5aa54aBzKo+Ss82EtjshKuGcha/QWgW6F8H+8vojH3CyZPk8rtQCrJH6BvUvEPzTZdhlJ5vuJLbZqlF/x5wuhS+lP0Kyf2EEa0/dWR1sBh1DBfQI9eTNoS/9iGgzRKwzKaQZYj09u7wR6zF6si17iWtxKJDcqAn7VRwOrlNgt0UtLZBld5r//U6pRaDZA4HH4Wx/qLgRQGTdGpdjj90UuWlDaurXxos7a0c30b8occi5MsbppRsLZgVMmsWawbmILPmb7JgZ9AGjiNQO7hdOh6orR2gANhL0idWjeLglCyA/l0iCt5rF3ZdGW2379jFvp6ZWWinzBsXG5xnE4ElzN+yL+9EVIIY/GmHCfrv7bgeZH7ggh4zo9gIlR7IJYEqzA8mXsQ2krvdEivXgsymUvuT8ZEA0od3AXMxxyGc4rZEJT4/w0GnpllcrCkTY/wlosy9l1C2GB8AQ/Dw4AH1Zm0ZL3KvVkBvRzyCl0RJ3Zcvu019LHHsEtD2SenFYLFabc9Fe9i+QrKifX+qr59eAVmEYPlRRvJknGyaeSQzW571mQFr6YPpF16Md48f4LynVcREjdrJwsuzNAtsHGwhM6riIzOoFmA3bgt6RZXJlB6vXRbQC6rW8W+4ZUZe2van3WWu1jNbaknxkQ/GUAEYAiDzSxAZWZ7euycRLeup/Wtu73dWNBhu94WqSkeSvFB8PGOk2qsCMuWzZr5lTVkHGcii/863L+yAKVXAWyU9ZqHFNPFV1hcNjXXoumtmar6GY2r90ax711U5aBWJ722QT3tTQ5oATtWmiR30Hu/GMG9MT30Oi3bc+bnwdjSA83PGtV0TJ8akwMebHlI7V8fo21cLSowNlciaRcxctZ+0THeULcYKwVpVQhevIFbgLFKDhjPQrUD1GqywSUYZz0z/9ZMHdI3TZFkXmob0y+kTocfmzBaD74UgHxJRCUsghaSzIGGNxTtqPzkWX4PEQFp8qVhifvy1pFIr+nP/myelruNPxkbrEJH1EGmsi8soXdy0BMbAE4I7lHNDNEavGQ5cZO9SJoiHabRyMFvaUJ+dWEIZ6TDEBo+/eXOji6nDPEhfJqRduJrhyU2UiEnUa6/hZQanurXU3aWE8u6mdcDUWj/exjGPT0Vw2ThNUKSI5Zu9j8pmEIkLVEbqN9FlwjejAid72KfiMt5S+hBmwLUrMCTHUhgm/csj5rrN+rP0X8P9dgelUpM3J2x2jcKgBo1C4/BndgofN52SHZ9IVKkNYZGmpcfOvcRauG7AEXVsjCn52Q8fPwCV5pAm25xrdPlnedm+EDn4Fjy5wwNth7oVc5hVvlohU7XUKK1vkEUVi897qnBiLm96L8hB8gB0burSpvGwGB4bRfcbHLmIy9TkGC9C9OQZKgrva3xJv5+XNassrC676no/g/cW55viVenL81NRhFaSpMtNQBYMKoW2uBrwvpFZv3tma8hYxJaS2tnD3RTkKkjBTcTPa6Cc1/egWgSyEAcFsVxNDxWpLaS2cHYcqdpP+givDKgYuiTb7FQHYRWTyNzjxvXYm98DagOyi6eUhS29unFDSKrBafEEOyaDvvY9sKPSkM4P1iXPYx+6LhkV5cGuyJPkHVXJIu30ccRlpMcvUlVkIMzZ6Bwbb6FB3EJXCWo0ydj/313ZhBWGUdf9yzmGKkimY/yE441TzKrramVwC4Y9Qt1KC3YYoVVKu7L+UWRDXWNIaCKy4xxCU8oX8pfZN8MtpgM655ySPITJkVT/Fnc8mdzfdPzIout0qFFMYyrFgMz1G6AIwG96J6lsUZAaMbk+bLFJ6MWhYjEkILZpgRweDmRK7Iq3e5jWFxnQwDvUrmZIzM2ziLgNFHq9S6pJJYuvlqOpeay04ieivVYE1LNSS+odeNs8ELAMn4Jff5bSJMfRYEqzki0kpw6Fr+qsOmFGHcxWR5ZOHVWOM22RYP7CKH2p+Vjqi4vgfMTNC/+ddxdXWwMOOtYndLllh+oqf5E75rO4cw58fDd8uQ0RSWlW56JeYFBMHiwPYp5HXWH+jleF+5/uSz4n/eH2nmKRq0q1vGCPfM+5ZG0n78QmVJ5uAJHuYxBIL24TVOJWeElj2IMmBfIH2q/in2dNCrNS9omaTctpzr1u/dB4iY/Se4lni0GfTuH59KpTxF9vFhfq24yJYSwO9cdjRGoO6U0xe4J6MD3LAJCqlg9VCKwWnLoecy6u7HMoIv9QpCzg7Lrs2zGVJ7Ab4a4B5Ne07ynFPB4HOdDjZKe83JOLRddcsT3XYDujVfAev3dUC9MZHOxFLMh2hxHuGd/u6FBqvEJTeRzis1v8ZVGs44TTIdXPkxSirXjUx9l70RrjkYC1DKwp0ikn6dAow1uInEEC36zdpkmL1cKEvz3rlPcSmDPZp4zP+O3/YMJkdbMFMK2VzyT4dEaPsD1Iorz4UgSLhcr4eV8yuqg2hr6Y3DODAc2ZfoejGEHZEhJm/DN1+S3j/kys1bI9R3yJlDumyWyGfRy12aQWINV2SRt4PPoH+d5gsiEWkFcb2OyKjCYhrMmdUZrAKpbthRGzEBYseJKMKcq6S22dV30/I6SfNkijgVbxnR+edQKhxfgIsikydffBF+VH31/h7c+4ZXgyu/xnFrVF2XoGmtstvegg72Js1aKlJNxZW/D8MtMr1nv0n0tw25kMm05osiXOJW9yXOPJ2No7cVaNce2GS6/EfGvQh2NPKt5U8qNS92a1F+NHeBbZHaE1KwRVyq9wmzSKXbaW21NCPgU+7OmgDz2eFsB930XqNqqbK26Kw5GtnRbALtith+EojQNCNA/d4N64euAJ7cVnHAIyyvm4izlSwRUgH4CA/jTwTDojWG3sxILQ8uKuYggDj8ABiEqgCQ/U6c7E/dXGpODz64+L8IDLHr8AbwqqNQPyJrO3OzApPPqmobBZFh/Eg2UHl13bLY8NeGh5y0TSAa5KbrwfVhU93dlSqE4lv43ZpMUJrCwv5+HkvB19oObdV1YSALzQ7FyEp7avj78FNzKNH1V4fJSFGiDVQuIIbNlg4xcmVrDb4+79VSj7axTUaWCOrLcWkZ9CRF2JcSaoKFydSVAzxeoyTn/ynVked/vRvH3OowKVET5g3BBuRibAXLiVMx32TwUndUbh1duyeoZbVOyJGGxpHvJk7u0+KXANtmeTaEB97WrY3q14Bw8XCh1KATvyNHC6IsXrFkm1H3PdHQ9t6rvTIMSjG5cgbvR12GwgKPYUd9PeySTu69ip+75HFVq/cxYBMuYx7wz8rpYT4r3npUZ720B6WVKKuLjkmlPTB4pfYAFvRoNZrYCfD5b33AsglcQf5/mde7nnM562UlTFeroT65LpjvnAkV5HFNT+LMiRHoYQwXx33MSDhuilsnMrgnbuFBRYLZTJDrQ4SGkqtIKNehaGZ+Ad0b4RFhCCKuPPOgYGAqXwttuNP18/FhbnZSzSviIMKwiIOGpF1FaSBxap+bVgvCg8/SIINvACOCuuOgD8q8VMJDxg5q7PfcbNdLGL9gCiD1abP73mLB0+Ieu9PhextkBsTCABHL9nHDcFYnIA5Rxt2UizoaAoUftGboeRWGCeD3XqAgg6GlCiuCZdiyA8Mf8eqcM6n/71v1fs2hO4gL6QwT1T0ilHOC9M3nQi5+Rw9OUzzSTsgA3vDyNK7MMUmqnl2YoAT5kjRW3Sc9Htp/N3igwcte1LOccJw0myizdp4dfRbiMG+jWiLRj7oID+trVa8Ude3hlW8qAgalK4kUQgeuRv7HiA+5Otb0mvS+sa2lGq/cEUl8/f+KDAhLlcExwJxMXs2QdshqJ4hQ/sL0EAKA2NJ+Fqke8PxwT2sXLe2u9dkRhGja4TYFgXa7AGmDnsfpOgykSkN8OK+CM4aFjAo2gutltdydcvpIs1+O00CKOqkchKUDaD+dbVuKeV9frIO6LZILtl1dkA2n07U+61gQJ1UuBkqOHt9ZA6cDa0qjG6neIOgbfE2rsIoEJoJAdtbRVB+9WtP2P477I/Ob6uwLGKvQ3wXlkuMUu2XjGdSvZVN0UzJoIJHBnhzPoNO0BWzMuUPFJnF9r1+g0XlF1f71BbmEbF5gsC7Uhk83TL/kdnzZkmOs7qm5wfd/fQ73Cv6T2ptGoUxjXiguLZfe9niAuQuU4eoKnBOTzE8Af4dkICxwuvlacHInZ7/mdw/IMPPdlHD9KKi4MczKPAWooS/7UV2AylfCrGpPZPAl+of1QqHNV4NpMwP9beox2sxuizpWEQdadLTDRJixkMKxLMr1Q8zt9+Dz8i6zmeETpj550MOQzx3oqBrCOwDf4/OLC3CYGcnhfuwWcQWsxffARByOhx1hlHOgJ86ECYv4dVmAh31SbcVT08Hcm2YoIzVIw8l0BxZvM6CkNGKmvD8JleFRxMX8vkskAJS1AYUrK4+bUBABfdMafRKJ1yKHjNt/5MHd6Hvt0D6Bf8P6hrI+5QZMBJD+y3wBpVEVhT7tQC+gLJmNmnw2VrT9pINvyYP1bjwiS00vvXCx9w7GlLs7pDPKt8gZ57NjbiENdBsVNi9R+xCwPFpSK3aPUEvCunOAfY2bH3NdUhTaS4pW7Wvj3rCgwUD+bQS4ePpPiRbrK4XslWQlGLu1G6x1nF7rwHunNHY/d1VKML7N4OuyJyx4hu2FTQLiinGdCnkamlCgE4qSVhQoWk/ariw24TQcNIxnnJe/l2eG/iuOns7BwcJFBNG2tWARYfNiJq/I0sJ5W4l3YZCHyg4d/leDsREX1oYrHMsVl+v5P5BperqiDgLriavTVBbQ5xmvjbO7B6CcrOW66hXYhOGN5VHPFsqgPLq+aQmePfYMoFFT38YMTyhbEYM3USReNur9aBhPGp7CKqJ1Yy2PefLDxzglRgiBAt2u0+mbvzNTvAKngHx0PMDKZcRVrjQYXZGqxEoMQh02OCSw6tbH3nEQLWFlD8TwSb0EqFFeCLnrBD0h8yVWbBtuojl7MA95JDprpN5XkS+LqusQk/1ASXnlFnZmvAH8Ui2ECY3q+e+eVfLHITxece7L7nN3B7QINtTlWZu8zSV9rL9ZyS5Vp660HzfSzH1h2CzwoyEtxPw740NgDUQsltfuhCCQs04skHsBFUWpclZo0vam3fHMTj7G9040T9i//6MzpYO80Zh53BS8UmVf8wG1FtJiCGgD11PAtYnmp74AhC7De+FpoRalCFZ6BTPpijp+Igyx9k0R/IyNuRrSEnjrrlNa+KMT4WzACQdVbr7nyiemUUzKq3qnESPAlL+Jd6kCyQmfelpg5C1NyRZmcaAvv/FEP/QLHvywSBle67AScYejBTL7wFZq2bLkRHAcv12w89wzZ4x3VYOmWq/UXvpwQMtErTt1XynEMiHp1UHaV81TI4kYfhrqZ+hMFqlyC/0ibyQ0sbW6+vt2GLcsy/jqhmqIpmbjt2Je0YoTQxGNlFc97F1yDObqB8o0l8i4LkVUg12c62VV8hpN4QsZltQsBmkzQtMjzAa+b2hduIhPcDASXjR9uYSOo5zuO5+OKLcM5QJMxyxXGEhdDCc0LDdNCFbyMp1X54qtY/AcvqQVRXzWGY6EQaDr/rlTq3OalIzbMaa1coYV36fSzbJgJWNbRuFATiuoemBtrlHt5KT7NFEaUMMTdGsXNZSDiVQk44Zu11Aj5wHjtiGY5EEIntcWLt6rSsPk0uF/fprcufQov4QdT2xaYtidqlvVGWnWNvx8+zl8Myq27/jZzc32WVDpAWw3bYdpLfuMMdDPwhZQIe8gLuBjJzptRxY+jRo5UMNl6OOveASmFAdoD1k5GczHpfghMdxnzP8VT/DBpL3mBScWQtq5YkcSg118Htjoadr30ohpfdwW1o0hcnKlIH4Z5ctYb7d5X9cVNsSzyEXBy1Q3qxFJn6GPYsZZYs6xVjr+421jRNzzlskybz6eNoWsANTau/9QlGsZwLo9YqiBETp7iqTkIW5xdwNVjnL8SU0TF/uJ+osN9FvrTuk730dh+I8mv1vVKT/qyFPn1bcn4kCc80BwEb42wWkvcdLqDp1yQU5UK3euNlFHq37r5d+iyQCYfZG8rCZGSIcel05gKsxgUGksg3TKVh77lfdazJuE3ERsuX4GJuz3IYuYQX8be+PEm+3X9IWdTgYGKAKsZSBq4E1idXLVHnQ/kw3JyvOJOz0rVC/pZSqNadMguk5OXQ3399nVWpXIEQ043hfLEwsSvU2OxQZJKPk8kPN02VXCCDIBTwuG37P7C9QnI/lQtOBInXEoqIBFJ/wZyS/p0i4m4MZMZsvOG1ERK3ibYPVxP0hzrnMcSoi7A0N+pjv3USKXWsbtegOlgkZxxph5qRnLs16vze8zh5Li5nO2iZL/bM0V7eMcbYvJG5It1lSqk3HjR/Ny2POchGn6mRxDiY91PEBW7ZowzPXbNsffyNq82pCLAik2qtHYXc9c9JUEewRGSFVwRdv/8gVlIjoHUtvn+15jPDFRp2g2JWKOXznYNuIQ3wmX3kKlCrPe+fKTTNfCVU33gg7FSb30ggpYsa36bSKCSYgb8g5rCVM4HjtOGNS+Aqm4cFHD88qzIPeyc1P/N7kzKc2J5g8m5vgT0TdjSWvQbCCOE7a1UUvwrpRVd53vguj1O+rKcagr8/MCFUxgewR/1anLqJ3osFqQm1ZUMSMH2kZRO7l9/bznacFGHbPmsbTlM2vIoe/syZF+zTl2ZyJaxd/ReFbV5gLgo1+Z8Mt08PDnN56o7QOVqWe+3wlAZJv99mdEGpo/evy/aMX8JAbUmpM+B883Bi7orDyWOaNkbpTCdUSyCVDhp61dtJPoLAfNbJRXSk8mwpfQ8kfOsIsBahIlAMFrRbGgAQCn7jx+Dkvie27xewbHZEBcIuj2ejk7GgUa2OVyPXKZap7VH8ctR/fSUSea6OMW+o+loI77AWahrKYba30woefzjucng7azqvbQMLQhKrJHt24Lejuv/xdhEvg7ki9vNu09RBWuVspC9NXbwUps5+Ja1hDo3Pv6eIdHapKvR5toqSgBxyxw3tRRXP+kWH8wP2Xq2jhtvWIQqAti2xH5QfDP2ZCOg8RZ3z3j4EkRMafwBelWV7vPdmcEEFWPtSRTDxV7MBDgfd4BPJmSmYqsVUjh9qrflLM+EBYlLpTmlxTpAgLpuRnBjY/WQH41qpkTTWapRawiIb/m1e3OmqmbYdT6jg+p6uZKIR8WV2mdXT54OLJOC3CJcQZF3WlHWr483Rklivuba/dYd8U4vgADWzAIEl0yWwPtAP8/+L1uMvmsmx5Vel2jlLCMKbUAR9su7kOw9W+rIXh9dX2U3J6Jc1dXy86WNNre9YOVPs0nmr8xu3Oo1mnTZwlp2MlFXQcN5sjz2w1VHktt0Up1+cuKoAOH5GNkqZBGA2OXerlfexRWjpd6S5VnP17e5EcTTSdj0WvfrfD0Zeny99rkK1FZlrkE+e7Hu1dnui5fiD0h2TPFTE+eHXGBYacujnd7b49NRuvLoKUIOF3x3qoY2N1acifn+3jD2zj4ucfEs6pzYLIz6nhVgi1pcSxYeSNqF2NElzIImzFMEW4cAmrIzk6w4j0xiO7fcE7PIvEQbmhLS4yzG8bvAkMVfpCp3tM4Z7kz143igJZMIt5YnD6xCRxLk5oOi/Dw1eqQbi7e00n33SqsfqYGUuKkKwijL6e+4E+HyL6bh9KKp7XA+dgDJr65sh9mmYnvo30D5fwdKV84U7ioke006jUUSCZSyBt/pkIw90bUHX272IvCjTjbGGJN9Ax4jzmdzcKWmeZOQ/J+q2eEke+WnXPDHYgJvu3CjzEL+aCnwPABmSt1m2Qrd5GrN5widdARGT+2VTPtsbRcLqtGII9Kj0dmGNuQkaIJqea7NIjXJXmA6TZPp4z5Xq0ifYAut4aGKhyYY3niElUNW3KebUD77jJFMscKYnyUWudtfF7ZFib0Hr3yCByTk7RMA1mr8byjwUEqqOm67r3OUXzF3HR46cWrpTulwYes7gWK9pSNiaV9kfhnxNvdyLD8pp13+ML7131ZyW/oOP6jHix4pHfZm6zy3MKxCfxNNQDhdiEqnFEhjtKgK10BlQZCZd03dScND0suZMegD9mP9hQQKDnD+M3MC+KDU8U2e7QCD4lwt6iJw6Q4RZ/fhvfl6CQy/Ydr84548c0EeWsGiDbOfGX9878+0NfiNgOxjKs409BDNfJz2jiQQj0qVy7T5HHYO4Z+x8NK+7LZCuPlkywI/BipR0E3H5EAY6JOP6lI1I9Ck0hK9IF3hZ40SaqOba/u8kHyqGFuVhxtbO9PuybzQjoO4GFBWR3CnJSkIxFcpRw7L0FMGr1o5rj7yjoKPWG6qSdOHVCPy+wogIk+c50li8ofSyM+tJlmzDqo8whOvBp+Gu7zzXOPyCDWfR8Jd/B0sGqZQfUNI0C+OkWPDp2FiebXgdg5sVOO3BlDpCMcbkAqNskZ8w0J/jwOcm3uxu3uhtfTlJpDJkA89SnoiZ3tGpq2p1C/4iNDAX9Jr8Z5mU6NU0OZejMXrCw0tzzTStwmVFoLb/wWA3vyQmvnAXR35SSpOtmuM/TZEWGIU9obNGJhWMqD6phMcC9f0MyJFGFgVSpH6mbb5STtdN2IWopjrBc3/3BPiSWFwjk0lGlxHbmZpqq8dsewHgmARbFs8fcgT1VclozWh6YdG6A5WwpHFK/VBwiZvyXKDzyl5pkijU7IOqdSb5aOcueuLtRBah246VqMu3epPk8t5uJ7xwthUHrAgksVlwNDH411HuaJQvEO8PnFU3LEi2wqLUevjbHOUEtnM3QEbQtgFiRV+E7NDk2g5tZuga+yQaFwRorOh48ljNIbaACHrw+Uc98i4HSTWpJly7Bfe1/hQW/8YMF8Lfr1uI1b79itu6ZnmX+i+DocxbbWv+UOrM2MdYJRqi6Kc9iQKGatDast3ZJh5231olFh+RRYYkJnE8Brg78xGWRJ7tJh/uZiYNJcClFhRRvlcJ0rxD3wevfLGUx+41xMYqzAaxTa5AIuZ4hU3/8+aVXVM52cdz5GGMejLdNGHndyw1NCEhqO/NIMftNxaPzjKOFiIEhv2K/5dbMTLJWYJUkSwZ2GL1jiWSVOL09e+gmd3NeBBaTrBMN5Kr8FqGQxsRxcIVWkgHm90j9hcdP2+nW1L/B2+9RAv3cE1LNXOQFDPxiECYtS2DCLLE+ic6jxZQOE7yefeqOdItAHHN3C9HvUIrTJZCVnl/W6kRN6EKr/r8MZg9LzYGr02MByMw9DyziXPhF2sh7jGadbjzsranOZrOCmQIkMom9e/SHfaMly8RGgfVJzkjpGt1gfLfX2djNBjxHxBV9F8DDoOiI21rWcjUAiMrNuRe8up7EZc7Sm2YUowgdMFqXvanHODNq+OVy9js+ZbzFFj2mXjqjsTN4SJA98Fp8+DYYMpFLlFlpYHUXCZzGqZPaSW5rdHkKmwnWJstVUDlbC85BJas05UhX9X2Tkc0imaDVICzvqEPna89lKeSxcmfDh7ZkXJiNxMBK9UwxzmA+8vdZ304Rh+lQ2O0fHUfV+jf6IyslzZkvn9iSuXzFPWa1EZRmVrEOucrqBXPvucX6SXxWPF4LNqa4cq7AMXSDyHyYHiofnGZSJNmnw2xkK/UNEfRcOXSZuKMf1SfNeVnBQArO/NATZJh6ysxTUA/6cgpsfwYRefRgE4dgmFj4AKugpYv1jMHzqzVy9DBpFCK2WFQ7pMZYO0Qt+DhZxU/DvZJtolbr5hPzEdMlg8j5lbr/iEG3oJ7wXqDzUltI9JHCaizUYQm0Oc+cakaSF+Ts1yb5GsGDN13QCLPTJmzIQ/mlqyRYy87l4YjXviL1qqOtCMvjuq1zEMdr5EI4CYI/iGUHhoE0qyP9aYdQdr49/yIaZuATYS8gES6Tt4QbkTOpm3nV782l6QibdFYe+BxY20FSImKKjiUM6YJY09J29IjMay1MwDG6JgK57Awtrx/pqzKiwwnc8SE9iUicC/ysQJTkehseUCrVIVDNl1fMYaCsQvuBieKhVBX0O9PGUKj4llhUhr3VivAufzGrQ7+wZP9nIAAmW4S6Gss+9gu0NDn8uYfEx7AqFZHyeNtXKWeEDRlDnVoYPjklY5dvpRPzQWEq+a7IaFbqBXcOmV1MrgI32/wqYS0qwTrbv5l0A+/OFP05g79YERgKeA2qj2dvz4swEp4mlBRgb80ufSFFpdJvxEnpwFWxPcVwYSgfKjSsEbPWtKI2QntQAWmjA+HVoYoEJhCuqw0tV3xBnv0oqv4Ja309BaYWPl5wWJTixZ8Dlqu6Q2pshKcViYqP1CL3aP2683ZHUj10o4hPIxNJBG4ZkEzCKuROMh2Jvlnqlgdc357MC+uoMGzjjRtVFve0Lv4PxpP5uHWvYT+0J1XNkrzVFy7M4bljLCyHT7TjSRyenc0pPY3V4xTbG6uHH9ch9gcqnvFwymrO9mbcqM7L3ePn9I3rlfugiidCcwBURDm2RPV3kC+6w4XMcWeaCQX4I3SKr/p5WpLPCuA155koqmDQt5w6t2gGDUgZfrlmGerEa3GRuVZbd+yM3xl/+bno7GUx504dPkaK8oWeurWyIVtQRMHpTbhTjHIrfHRpH5mI+zCkmL4ESd+qyGentnuAIGlz7Nn9fnAw9pfVOTVGU6xqLQ7yAtVtWZaUxmQWFFWwyQBTD7GATeulW6LZZ/ejMJk/Mx7OhTncEO/zoBsFPxZtMR3EmfWN7R2QqFEkwg+Dek8dTi6VFtyE2ZprIMn2fNME/7RSUhFhISuomOQ5lcKmkMDqXCN74Kt6LT/5W1udRQPmQLEdday41GXNObr2uY6CVWVCnC7p7OPIkuXzRdseL1EWD2Vft2dPIFB+1F/xt3hFd7uIq9Ftafpo0vFpNX7VGekjx+S3dQ98Q6csqYqHkF+5bYVCLG0rNgCM6JJd4k/NspDCifVe9MxcHpghwbgyu8c+u9jPz2qt0wej1s1+3DGyjfuvTu+lAIKYrGgTODCJclB3NVnyy9nH8BGbJraKXnvhr6EJK7OP/wAv+TvPjnHt0EcIUHsCj4yM8oZ3IS+HWIOv5IW2eex5s3WqXf+04eqXDsM8j5RkVMcHH5sBfpDcrYZZ7HQoi9ZHKcfDqjVZCFiw8VKlxLvVMIorIIRRT3+fnqg1IhzUj3R5K91vd0qYUgRw6FjGg/VSfPjzh/7nfZIk4ruM6fFsz/OOdVG1O0TTxO7KnvqOOEkyZQU3ryHhA68t4FbTNFMfnVdhR0xfCSui7JYn1PkQmQTRnQ67EjsDd24ajBTvKwnxMwqlFIhwEApaBiCTFSz6l8FPpHsflaxw7/SwBhvMSqoJpQ3LSAJEVAyjwKkMlshgAe/6iS6ZfoCLSjWgdPX8zgf3sWQbp2qah0NbzJSQDfFDFFNueuRA4/o4+zGYX4NbHlHDMQLbHdKzfJdxLL2Ln6BXaOI0JLd9i7Je/1H/GoRNB9xXBXKvSb/H2Ut3IK7SqhpNelh2eSH+6aQjgeld8DD0hHA5ALa1r7sN+GG+BzQGaDLdZnQvO1coODvVGXxwqKnVnZO974IOOYej+ckpF7TI38ZLSBMzpWBCJXknIpdojVV/fBsu7/+i9WiadCZUVkpLx6wgTyJemxc2PsKZXuboA9kNi7y3bT5W2frnQY+X5F+yWU9VkJXYSpxKBHILFrw3jUzog5w3wPfn02p/9wr+x9FxUM6QFtfdZeHT3C5CnelOaV2UcADTI5U0bLhSio2Rla8iUMHoZ08t0xxEU/SuyP6wxAM324EsPI4wNfXmuBWmIOkRE4Jl4akDDH96/G62EMWUPWbKoCgqddrtC0taSHOiqEVKTGCuIuFRIig1qfVUkf6uFOvsTuCIXank/WOVGXCdTrtux+gWL1vLVfLZL1Z45QSxW8RM45vRgaesAjLTnvmiYJYR447MQCnWRZn3BDzFhFQvhlPwzY6DHk0iqYBknzg4TVIT3rCSXNuG7akuLxB5kz7IGiCYIm9kI+5NNtAlRdD9yaELHryEc33LZVu002bnrDROaApDo3guCqgZVhNcaBZhMpcSDtIIvu7ul4j5pvFUHGf6HCfySZm4pHfv2Ifyjs7X1LMqQeWgCYtF3jEXxcWjJaCZ4krbdAmv/TAeDI4tjrJiCHLj5hGZnumiPuK15PEalF/8V1OeFOHny/pIAf50+XzFQYzPIJJS9ieaUlBvHenEgsgX/0U1v5Sfg6KZAR4sKR5dYPr9AbQm6hB4FneiclHZ2vnK33g9aUJUSZ5v/3zCBY0sHrCjeT1yrvVovniPpCWhguqfLGNyJ6GZKGC+nh1ecNqbBMexTA3rXv10K5LMVmwmcg2UmPQO+zdCv9l87+5fBv0MY0avzOKQMJFI1JcItFZmrppEbNxWa0RYjs4CGjQk6+se83pC9ElkWMsunjdDFLz1g/L6cfs+8/KVb0slis6oRI3/IoUpVzVGt0SO6L7BIQ6Cxw4VAaSKw0V/lLmvnr3CvSVstxHLwXMy/TyoZIPueWVzD+hI4Q29HkazkwG3uZTIcKWERrHeNrFwpu09CXh905pXC1/mR6QUBpjzA2pjJLcxv6as+w8AMFMcLkrRgPtPBxe/3YaihVxkltqrwvsvKgKh2Jtg8VLghU0m7XW+yzXWVPRVt0/W/Idp8XaRzM9pp5TsD4W4Oi2L6bkcrumW492YRjnZE4HkUaHNdvVWBdorOvnxqzQlIPkFHAC+yz5QCjWG3Kan1+X5KLfL9kn9WFhjUtN10OEuux9z9lxOvsqAv+rAw2mUMkbdtD7ASxzV0QA1cMkmrr9E3O8nTgW0ThnvrB/nReuInxSUOZVA1E7YEz6ioXQtkn7x6gC/nDcTmCugTLcbMIbfz5SrND18cE/ijdiV4Dy6Pwj9d86qzVBxYqc/c7a95YKhvOzEGTQvNBoasiVg2yhkhLX1h1Qm5PcroieIwtPPu3j9C1/e9u0l/0szbnuWGF903ZJP53qY4rIanBPL6RYhYrMcaYsigLR6assgY1SaYvzhqY0YkKPP0Xe+CbIhh+IcAif4cdi0X3jLS7hXZVPiqYY8o80h/Nhrw3lc+ZBKpc/o5VfGYIFyF/zlyLBvAeY5FLvEnCUGaPW9tHWda0+/kq3k3XIJ/u37rt83he0DdRVNqD6eJUE7nB2Uc5N7VT/6Va7B0AwNj206keFOw63iEU/bC8a1Unssy+w0FL2xA77m4FfuddHyEZ2ojX3DGYnZdZbq+P2cmd8hQxqZHimojK9ozwGdgvP7iC+3psqOuTuRx8kf8X5mFtcOEfLy7/uG7wViMsrs+1ag1SaXxAmVAsWUmOmtRL9psFG+bBk8hfjo+OAamEEvmyOC5GiDu30hCNtX12rwaXG8Tc6gqEQCRyCwMR6hdKbYpjBpu4cAu2+nZ9E72kwt5IMeuPQeIugjXd9fVjqkFIsI6Ue7maLsodVcii5gixs1EUN8D66fnF9gPokN5TLK/+q9wldFAe7flkhK3Ja5NM8RhTYcz/fc+qI+dtRGI3GHxEsMGuo6dXP1/6crzD+ZCeu5BWZNpWOfAFYCVhVHnW3H4YOgtVaFvPzEhQkQp1iD1SBdGlPQjEHsihg62vzm9Y/fkWtV/CAQt/n61bJqpwEeUPu+mggwk2g7W7OMREqum8BGIQD4qg3k3KkMLQCjoK348zYUsU18PiG4Zokj1wVxBwYELnMdJj4Rv8GvcqZFDGo3EMv6Hc8BRJiHxFfBD4UMQDb7JYNtaOsQlbM8teowgWRQ19/85hnuqX7VOq+ucL64dXFBktOPfsMoaK3RA9TD1S3mSzCbpi3ogYJ4yggw1qVsLS1QXaLgUwZfGh6Hz4u/jjXQ9EAhlld7tcoMCJ2UDoMb0EXYA1sxnlHEU470AVarP8pTpKvjRwksFN7NC05PGyNspA9C5rqWPePjXhuvCNrsuX0c2HOJz/G+DBDsjx2vpNHRywYTftwvq6PsnYxpYoVVDGfm+Suwkw4rqCoEOE6NPiQbAMRWHhWtwIWm1GNpR/0Wla9G1sciZuw1qkE/d7iT3wfS+T3DaUkfdN9Lnbs8Atw8q6psp+FAmTpVIJ7Skw4lBf2zcrlzjwkH6RmccW0ouN4GPyDnChtWMQwcAdQ1Qm+ivccmhz/F9SUQSkN9kikL2l9dIcIYYSCw/gbNKTYbFQToylftcWr3HjvgKydlgYKBuE7IeSNnaf2THZGe/Nru5BuI23zYOV0IlJnFtFItyTNuxplecMY+CZNp59ue6YhupshHkM3VDGAD8b1zBAKMZr6s2WpbCdxvZ7HmOG8ihhnvW0mV7R6nxN0cwdcjHX860qFxL/Eir9KWHKLCErJJhK8szeb7AD71H/1TOxGQAk0RYCfFNxrga8LbQRVoexDmHbKO2a5J0pHTWeI4lfZ81Q79EvqMYJ5HEySqLTnG6gD9V8iju7eL+N3bsepBHt/nMey9gZaEF/HvWk1734xKp1pOU86AJyiXZ5h0k8qq2ENUcdx4tw16kV0hPZqyBpZtMDBERXKBUt+DxggxZnJksSyRvgI+JgGYlQqA/BoFYlnKH2GyrpfvWgJHNu+JXiuhAaRcIgJz46HekRfdTzpSFIn5L86R4HXZa22YjHpkcbWh+ffvMvYuT/D44p3WN9aB0J7zUscQmLprTJRbUq2O0eeHZ3GwnulWu3JbFFMO+jzJbSNcxESCQDQd5tghqmyyBeTSt3zpPA/HG+ReHqi7atYFgrYunMIFvPHvwZg232TL7fpRUtn55g1ZPfd3rCG+dNMJ07kGvn3lhr1etwIYQIL14dH0KT9p8L9057x5cmUev4UfSUV0I4Cy8cm0mXxK6oGffewo4vim5aiOdv5Jfpy+AazbSaqffzNHmmhupelBlbxWh4ffSjFdtK3RL7QfQTViFCQASR3QG8KBS31+ARAtJjtsRZvs2/IfPvW9RE8RWWKOJVqBou9GXkQ91+EbU9SxCrV+hqb0RdmxNydh+WVbBMdyNQggGj2S4fPenvyqcLzeN7/5zUfVNvCc2nlZawI4O2xBnGyUm29cZxbxtZl3TgLk2gTpaQQBZsKqtkOZs9zTajXpmuVMsD/+ihnj3a/I+LFE5tvmfLum1Ro5f7wYwN+n87bbzrTF+VgIm7/y1/TB/C4hLo/yQDPl7rpusw2Xgul2L6krsP5ySXVSZSFrBlXpa1p593yRmmZvY366wI/KZeySFkPznrCYWJ/EYVfp+cIyQ1xTiMb9Oaj1R+CKxQQb2I8w/jcCnAUq9nDYXsD0DsNs/GnsHWlN6RfJzORFZ+21kVujebvIxZ/JoeVZtlgowHRJsmxv2VF4uuecJcn/yC0WrLQFGq0Z1vSO10uESkRguBLhBW1gZ1GL8SIyPDRWd7804+PlV1v951xREU5GjnoHYJdwCnWopIrE6NywM2OUe0Ricyy/NDgAvp4kJAdT6uDxK0dl1bKYseyxs15HnuS6/yTi7RXtEmNoTddtSAZaOclHxAhIdmhM6ZdOtYymWMn6GBS2GVe8U5pu/Z4KK/r7duo2COet5+8GUwOP/qKoC7u73U4h2p0PNpDZ2NAjhVyzaS+rch4o38OB+2XfHI3zoFUsqvcdDUrvataWEVFtW6ypXk6Z+qIOvdvMhm26aoIBsAGR32FrDEylm961bQdsUlKgxfa4yAFkDQHS6OKA+yA0qkqE1tD5+rz99HfrtczGsNMu31HLv9nTOfbEVsRW9IpFKrWdUssAP2upzZ5uJo39HQn5IBAjMIVqU+yI1lAiN97L+XLRbuI/is3hpeofSJhkPHbpAmTTpm0vvcPd0D234drFzRgh5xjBmE3e0uh+89Q63bw3oJkfDs6IN0ktm3DCzPkWSUYmtR5jDB6hbigmQ42b29tfUYzSnMueFv+55TRYiHBwXxZBTHh/wl9VuVsZtFpFY9z2tNa/dcXPUphoO9LVf6VY6Vwil4ph5kvX4/Jp6sJ9X89wyRy5WxavjTI4SzDZp98Y8Uc+dFUA24TiD3t34sB7hplks5yisqINCidkejp+vYF2unhVBke+K0g922aI4WmkohPx6A1/6lCwVTwdjPgagspJECCBurZ4eHzWsS+88u9nc2WsCaVmrrk2oT3XVJbKXdZGpQsQnQKUcNDQH0ldzewk5PnJxy2/Gb3Cc21lJMiUFw3N1Nk1GuALzhW7oSf0L2PltD0OtMw7ZgmLLAAjPYR+n+q1/vgNEmPa2bvVEaJA21whj4XrlAD5z/MViv2JCLsu6oBbimsZ+Pnr1ONffS88csxKIz0fCcSI+lgwwrjpHprDunbiwoTa7azHbjA4BzrZpw/ZGmluF3VfdXxzkcGTeO6KOvsODVXwsAo4Tm4PEuvr02b4GOxphCUFCyRyoIHHau6gSGAfbPjime9Ud75mAou2wNdZ2cTgL0Je+h4oISJl+ByNdqhxf1iU3HKuCI4S9PHwEgXygi1yfciMu9YGVVhvHJGCIlG033b3UVU8CvfyJZ0Z9jVJ9I/2U0igy66F06B9atffGpFT+RfcjN8k6QK5npwYR45zOSXetxJwrqjAGqaQgg3b2XYgqentVleSzVyo2dT8B1Bl5H62KSq1WRaiUNwtWMejtQokmV/Kdq62lCmK0+7ToyquzeW9BCyQ9JxUfQ3eG3aF2ylD+MYJAYpIpuQqxz/dfuTQ516wPCPRhu5UYeC3kzUiXJbmaLhR8SkKwHjFGH6EYC7jhKdBdeXR0BGEkeYTWJp2ypSSEM9lroQfHiky/AsKYY2Hl48PUPOPZyVxL/WiV8K4/00/ejdGXOjJnmen/NMyaGsmpDJbsn1ZqCERDdFvX5IAh6D9bl2itauCAbr7LCse2PV/JuKya78GRWZ4dlIq/263rV1DslHLAmGZRlN1lUhP7xDqBVTSEqe5nQ/dkfCWErR/Kh29+1ZSq4lJ11jGgZb1kBkZJ/5sGgcbLY1e6UOZNevXrlxwWHlHOBxh2Y5Zm94kcvMu0PE/amk4ik3l9OHzqAg1F3A7ENT4z/jFthIfl8/osIAcUxO60TDj0Hb3wwXhgfpBR3hBVrudGPx9+YL2grs/CUi0rcB+fZ3kkmfZ/2hFqqLRtvrxRGjhQLzl7JHdMUYUkoXDtpsjreB9+qdmBoZ8TRUS1gvvM2n/CZR8ziG7lEnR2wBinAMJJZBeU0DuCVyU3dSFO+0BEQAUfLG+1ti1Yi85a8t3/VRKsONwJbEsp9t6Qo78XBf7TiRpoLG8q/ryUPsSCHagU9lA5MGYAOSjC9paVZuAAVgYW3qv6TvCzOlfe26m+K8ijy7j2kOUxfw46dQFc6e8gAlfELGNIGRl1SUJXEp/8M6UkSufWp5FECTDmF8gh0N+xpNVHV+9ZgACP21Xy3/ig+bStDU0AfY21BphMDLeoNfRMpUHSlCgUf49fFqHR9BdvQwk0I9QGnroDkNFSHI+b/9SQKWIV80GnyW6tMDgcHfZPNxnm+2rd+Hidzy8XhS6IyZrYgg/K/+PQPo+yRP5zYTdH0hPmz+B1YuJYk1toV0HfV3bc51CPzbV6r/2VHm0m0xb+gQ39KakprF8iNPWjcvl4G+8B0Uxd06owDEFVwmroWtdWcuitW+CJdHB1zV/6qT3WBPFQh/5Ng5M4i0FyKPRX38J/NXsr6d6W2VCyi8fdNn4wlHvQHUU+AYwex/86gJsYjoZi5NukQCpJI8Us4EnDXlTxcll+Fu+viNlo6JilvE37PePVdt68eWTzwZ1O/Ks4ORsJpCY6AYOJFyrPoR8pV7EyXFkzOWVgSjYt3mjnR3UMmmTSa1/KOyVVRAlg1usRI9cCEz5/MacdXs40vJqav02lFfYDqIJKZZOBKOvCGvERMPypqKXjVWcyfrejT55HO1W45HF1YQ+TGYFHp2xkvXXiCTDYEY91owZd3pK+4B/vmFlce8YjKEGcdjxUWz2R7INAmYkcGCwVYLdCspaLQVJFONHjGF08xOMDBaZC3nPiC4K9d1Kwu7gJrCa3mZBCNih4Oswd556klBZMEN4yoe7pytuLZ6XzNVH36FrWaJ+tHJRnyiYLQuJjCm7DyPCUiM0nVUpsuILIZvi07cutViek0Bx7EqfbMr3TCE/fmBIbELAQ3YVmVb4RZHkYAVcr6z7cx8PuWDAzslo9zE6R6nZfEYEM50q/PkWkE8DjTDkH2XC/WKmq1Mnbq2Vy/n/RZzWSoGSF9NuNka4EtxLrV6OkvpvY0KYu8Qh3XUayujg/nQLe+21uJygq4T5udkDQ50vrxmKboJN6h5J+LG1PhZlidgMckI1hTxfsjIJL7bdVcVNAVj/kSrNQvFaxI1EdaSSG7zMsTPgqUHzSB156y3T+bT+cN5XY9+M/3QpZqycZhRutc1eFuoKFDEZ0f/lapQqZf7AWrYntZhO8+0nw3mTkFNQ5xI6alAjoYhuQcJw4KXPQqLhnpi/ljeyUVu20V6bUqqkXEppbGc91IjhmbQQLf/c2B+ULICT+El30h5w3f3Loak34INIe+KYfwfDMr+bQFdYGdlfZUhZhiuTCodkbs24osPgdaTJHJ8GLnBdQlM3tUDv0K5r/Lle4xWWJO6Ff5+K64wE65CsTY1v/G2/ib4emUc1F6g7VEofhWIzzoUf6yzmWiZxYIOn8yUIINTZPg8V/Pc+xQ/a/jancq4aPxpR6qbOzpiavfYK4zpRhgHhhZyhwRZHkPGu4ccXOc8pmjeOFTb/9lW9FVQU7Qzgigjd1b7a8bVF4dpDs6cDyZT/GEixUgIfTKBf5E09wD7cZtBcaTkno6rWVUImdlMdBQnRY06E14zeSgH50BbWv41zGXLJyEbSM/X/Brd2S2p45T/Xg0u+EjN3g6C0mZA58p28+g2gGwdQSgV//mUOymXUiQIo/Z7CDnHudzPOw134uGBstwxRBiM/koiStNEBrefkJ5kjRVgXhn7PZepmCFOQs+iG3/cSkg8YdFCNpj5AG++POEZwOKOSA2UJfT0S4llOG7zI4i9Tzsam0VAzfrZiMl3ao3UgI2fQl6bk1Ua4bC0JEuy4dy4H1sbYaXQezmTiuDMQQLIp52Z8aE1xumOOnfqKkKxFgr13ZhXoeqZqvSEe7A3DEttQzqmM/g5E+rHM6EBJ97UUJD4mFVqsk4W1Isfin0fYbzl4QGVhvWWO226VUqBS8t9JuGd0DKHl3OuoVgqG1NLxqkvQz0NUE+Iqwu6szsANLijdoyjaxEbWHydVfetyhwKCbfv0xNSzJ89uy8W0aWWoSSR1ul/rhJh+W81Nqdw7vyQQG6u2U3D756II1XJd1ccSrTnNcBK8pYQyMDmYfWVRPcEqj1LQYmf6JLyLXuoyjn14PAr3NvABOoZDIKWPLjgwITj9ObUxiQm8NOHRLWdd07aI8j/nfogvfYRzSPWtJuoHMQ2xswOVRr0FwIaa7VzhNwNmZF+7WNsh5llJG2WJBPCTPeDl8+9HZq16hbnHBiM5bfUk/XzjAeEwwlgEMIVDVjvlU2/43BfGyveiFOZLa+P8XYqNDCN8wQemTTx7/XXrKzQRyr0paQObaDXUV9BcmnpGPbkXchSpd1aREqk4z2GKvGXYG6op3xUhZ4yLeofcemDtYFZjjYjEZHYGjacWvDZIsUOxBk7Jd53EYnffFwB85L57lTznYlh/VPl+Ki+m9aXpV3sGrol9Gf+GARVSqDdJdX03b0iWm5LlhIQ/i2q5YEzaARwfr9qxWfeB7gZd5zjLdKfMLTxrdp5RPX50oxb9lzH98qEtISCgm20mmvDvRvpgktTrk9071mp8o/HtM4APck1JZpOlCdEwvoPrgQMD/cWXFA7p6HExme0b+XrDH7dPqpGrOg0acXXR75Xpb8/0x1oQ5zcu/59M0qSpZqnBOH85jENRSwnjCaImyt8j00mr0NfZDspmtYiChyW98SAukCltizsc0xpiCYtgP4zssFaYm0QHnRUIiZJoKVW02jjzAEbUHChOaXLuTcO4nB4LI/42NeoOCrsnSLA3LdV8Xn7m346Iaiuxm1TNh7Dhr8uLgTyP9a2BIHSQHg2QF2tGqFC0k0bcuO/+5+HaY0MSe0w4y0HRUMN7Zb1eRZc1vHS7UwTJkwtSUbx6b7npT5JXsosiuDa5Lldo6nDrfxu6XiAHJ3svVbaYeIgTt9yWNMa1gz+W8Kqg6+I681Vl6HYOVETKtF3ZnODa4CPpomGJJGuACv50TB19xBZk9GWvPAj+KdNmKVJFZxGcraS6WDciFLIF4yRbMBIs2580BFR4flrnDTpcJlKm4NKGMhnmbJRpiE3ZMNilx/IdJxHTtAEC6PpBHH6EdeZKArbOWAACXJ2btGp7a531OoPt5ExOn2NRISZej+xYpWoHzKMzMTRzvFrCe1jBZ1QIk+51g0jiJfIKd41OZCsHx43Inhl+H2Mp9NCIpG9eGw5Vk8tBNTnFLVJ0/SqShFQLdl4gI4v3MagblhhYpxWEBHd2oEbxxmw6iMlBqwjR07CfUD6Tp2+EnZUnFQ3ySpRTx/B+o4Ylc5uuSNnlNtLlYqtkOd1HdTHwwHt0I1R1cod1fVmrFzzki+f9oKFBtk0Duy1NpetWvYltNb4J6d9g3TtXLVaDgWqMV31oShMdkydW3ZLBZ8S7im3TL9lkfnlJjKz9ZWKIOWFTbXToj/Nt3ltaQEMjzrFyXJLJDeXzai0g9xFj8E1osg//3lXGKEn3vuT7zG1N0GktTAdNPkK436EyrdiqsgiqhVRenlh8XAUIQMOydW38Grd4GO+gJ+6gyvcGC/idXzj2AlplVJeCIO4TrRyUVeRZUbiOz7Hf+bmClyaW180Cootjn3VDpTTUg32whBafeb3QYzqH1ZWzUm/Lxi/0CDgqqIdt1BNfGSCwpVccmqtZugcp4MlHnlvYfkUbjCcKYpbDrMiMYMUSQej+tvHQsB0pnCJO5WFbKQaVudWCCKLweGyoguuzEK3rO7po5dgoGGttZidSHSbEvDSJfabvPTF0rtapMYNuzxGW9UDXvwHOQzcvufiBEKzXTOLPMzLMtvTJP1kL2FdXebNxnXXxZWL78D/JvvpPdfPv1ui1lzjTXh/dBo97bnPNqkCKh4tBikpfCCfH5AMoKFRZzbCo/Vsk0waacf0Ly1NkaP7NER/Hs7S4XE1wDX1IPRXmgTSJIPCeYjYJcwR0Mu60/jCrKJXmsJYcQC6OA9Coc+l2xXmRvK5yKbhr0vHOW0rrL1CtevqwhMaBr2YLZt9KVO6cIDpx8YEOtlQvn2I5rgwhOtr0dVmxjbpN3or3flvGLwhYDmCmTzJC+BpNI0xOLF3k14HQJ/5/ZRV7aN+0Diq3cVMc+MoZNYqVmE8Av8QpjBydtl5N96nZKwbq7lxfPXwOI5/ebt8r+X70Qls3ZdU2BHs4UJ5FQ97EHM5S+ku87/aviXZVp2cv/OzUEh4sudeTHd+BW5SalVFb0iuyZ5sOCXVhRuWqnJ+6jdkJwJ/YT1ZDFSEuipBTaXEIMPvoNy/2v1XiUQhfr0v6boxySvlGs4pDC0y9WG7AVSXt8YkSlDIuV28kEpLy6HqkPkKQ7E6n1Ktpwasn5fOdmfnyQkXssGZGaZ8Fw6uPIUrIuSkxgW6twgDt7jGhSD72Xo212HPY4JYupplK4K2x4V0beTLzdubOtoezj24/w1XjIiXos68C70vAHgBxy0EpvUM2fEt/szgcN22dVFD5SvBhMWz3zt8GWNv3WopRHabYQAbK6QKsWNgvLOWFK40DTQTTCMIA5YHVG4kV9m2Hxf9cDcm5ra7wxvGcQwf02D+m7hG8nn1Tua/t4wlPEW5ILxcl1RCRnPqiOWdWLUIsAG40pU7nARwNbxQowY8b31qftC5eTUCxfDaw1ww7op5+DIN0MdhMWS6AiUybtyCtrocW/NXq7Y7yZz5AjbPdmjDYc82tpgP+Mmy43pkO16KBp+AdikWcY9CPa6UPn+f4Vxi9VHShFdlaK34fgEp0v+RendB8vfl2SoCm/l9sdcnLPAhmthBdVKUvTIVvwXMuKsqOgmVO65OGt+yP0tVrQPE8iTV30/8zFuABznyXBf1hwmg3+tK2wAuElKJjJwrgqwQtdlUEyF0w9C+3gg4js0FtKDk3bGmHD3fTKkfCne+LtEtjOfSGySDHd4U1OvcEdjMdbWnVrGe0sUII0xNkAFAfIvyygvyqgrVqQLLhdT9JxDm9njiZx+3vW+A7B+NODMGnMMwl8PeXV28Eq79WM0hLsHxEFT01zhRGgrk9kJJGiDjq6dH3fBI2RoJ24ukE8KT+miDk0dg+qTfLvk40Mg+Gi51qPjw68jJIpfNxLvZ/kim/qy11ip868HGhJafSnx/I81bGzAJ3DDdVoxmv2UUTQrKq8s7/sFRk0HLjwyQd6UxxP/5id8EuXjq7tPjgGX69pq4zyxpI2bFMYnl7zpGUXNmKuXpFNMYAs8A8OR/p4XUEak3n/88UPEB2khGypUW4fFQ3FSRaU0uhmKHa63Zi74Qcu4WD2SSxXr8vNwd14Z8yar3zhP7fqknpUIzhx9vSPtlZ3WmhzFSkWO7iKZQEDh7qXWDSyGGamRsXieA9DQ/khCWNmTXo42GfBj/1OmeW3uYBJk5eNuT+upOOzM2q4TnxJmqh/THS6zBpBi/lRTTfbDqABzr46jsdWBZ5RiYrEJlQpC+vslUup+ACR2133JzwImcSE/wB8AHz/t1g9p3DtTEEUP2hEOWK25R8vCi/IyxrRrbTO3KObTkkMKURX9RtWkGNsCsxXXScVk6TW6HQ6bNHS9BnqNjE+Ll9vwKKKdTV61bf0M/ZlGFMbBGG8HdxPwYxnAQbMcIfz0JEasGKF6yf2oFyQ8cNCRjOuKgC2553Jd06Q360jC8s1EVCstqKYD+mvFMzTWRHyLPWFwzrqqQ3eMWXaNHmCF3b/v/cayWyGfBEhc6rzMHXxeu4ud9QeEPov8pnvu0NP7aihKedCemDqva+NuO9ksBXRKBxcOxrdXqx2QG4dBnRWkIkVRot4DrH6DC1GBfuqCEY4lO9DPXMa+NXeCO8RX1B7wZ09SRyHaSwEVceDtprFf8vnqhHKepYk9xfPsgOAMfSCBQ009jmJmH1esfjakE6GVE25/+OK6az5NKQFZMWUH8Wu8DWXyR2txFbhwRKWmlpsCh8EJmnJIJuR7azX45ovk+zdFleGLQkSkOLurTK+6y9sQ3oeTN2dqKGqQTn38Hl89EY70dD4qcjGo/8wiIPHYnUG24DWlPT09CPhg+UhjuyieUap8w0It3/fsixaE2XJ4RYm5Oj7EF41TZwkTkR98+HZjsMClBdofY2qddCEW5E7QUcQuP9YCEt+z5IMFWCrXIbUe8hZBmTcGjU8tG03TOV7l5Q2XKW8JjTnUDiCmRuTR19jIsBg1QdE4XoSvV5snPF2Hb4D4IgBBJQbXpTV0FN0sYK+2tNUXFkBpbzIYcWqSbdvz/LIyVD0x2BAIe7+ZRMR/UEkAHfFj2VFGhbGJv1BrBjOloyaobuDzetpV5a54jvePwmh+0TwxKVF4YSSQP5qkncCv49T3nFe+bfBmm5UbWSgUxlO8oFGsMBNVUjxHVk5vYTsgRKtWPRjVNNSpgBrtAaGVxoTrCa2Bc9vMIuvtEdz42kJ+QHnJiWdkqersceVrG5vTeB3EyYpSKTSWdmQ/UAYMdTFyutVZ2I5Ski/E469kKZRaGijpR0FR/JaX2AXk01xYBw8u0urrsuvEBRZ6tpsTmU0byk/Txqm1pBEmeMvJaeiq3j9p+4fTdc+R+UBvQtesMNKcbwQ8ARSnUM9OdyDqvCZx+7nm0oM6rr/KiR718o40oMu3gykccPMlJY+gJLoHqs9Et4F+pp/k4pCYANtrvRDkuy3XwYlwNJmN0kp5x17DAKwlwYr5NeEg/qrbfG6hPgynkaz73dgNDpMJxnIQflhN3Y1k/KrnUXqYnfg789DlJHUU1jvNvYKhKY4Z3HPfiPLJEZXOB+9ndh+ydJwVw6oEHVpKASpJCZdQMXidV7UlwOE5uH4PU1Bo43/jqPhSNJg4NFnxjhcyFEWC+uyijHmqicKSIfE6ZYRa88y9tcoZ8tOOBJPn/Kws/AHuJ9O/gg1rFQKO0d3A3HF4ejMQUZH5RnYTk6GICHSXy87fcNgEIHmhXna3VA/iU8w6H1A/nP98FCr/aOtk4iA9Cut/uoEksGHV6mjbnfcX7yBAoLkn0azfNXv2tEcQjAGYSIe5EVvnZWdeWK3zpT/pnxF9Ws32kPbkhTpWEJ0a6yGkzo8XRIqkCQYv9ksju6jDUdpjXr+9k8w2gMbSlEXh2qxYRI5sIGhZ2VkL2hWROmr+b88Xt3R8NEDmWu9xTgrbAyZSrzgFakYVTlDS/zNpvmrbAxKwhgpC9WH8XSNgZf2U4mZWqe+BNmwdU9kznPiG9+xKqlmB5cml2tsbGsjBXdNTtxXr5FcADQ0IB3wbkIs0oSOb8HvTFq8vyngIbIfp/Ymh3z2aGcXOFppCPIfWEosst2q7SQdBCWdwoENZwVSoheAaA6lvIjFwPCFbbMfMpdYqeETSeiIL0Le93G7BZL5zkDnUfoIDF/dCgNh+zzckmE51uyN9lSuOIHAEM2CnHfITYTPvXfncP1cOzL10VeS/wyEB2ZlScYixVdD4aZCQOahOkdHtUVMQ4WfJpsQcM8XlClBZYV4hJpHCwUpzBh6tHA9ktver3PHDRCwp3eA3qiQmsFEGhl7UqnoVOnPvUOz8s9kSwZy8AWbMVO0M5hr0RMB6684pRP3ot1l9uvLVU3hAhm5iCyYS7XDf4fRHGDyC2XHehzpUkozB4wkF5SZ4XXDlda+jl5fctc0JuFlXkVw9OQdZHpI630SyXs1qE2UGS16vi6rTsBGiSn6UKVodLZupjxQquTSIxNlv7GfyblAC3dHDYsE/dUhha6GAuOtqEPmuKTlV+16p3aHsq21WSkME4licGgc9u6Ds/NOO+Z1ezvRjf0lTwe1vf1gpdP6qQ6k6cHENPib/aFiGx+2kzVPwINvO6fGF4NU750ev3l/iSXUn/YkPaSBYjP1EZ0srD5JqGu7bHnxY1657FsbIGyZM847qh6LdehvSLWEZQY1u8r1i9f/7h8/PyHxti1P/8q6YJ15Zw4xlhqZWfbccxAPmh04oGe5qtwu21+8WlEhi9cjEsw+2JJw9C8wmOJycs1Nl4ypQymw/r2QjhVQwwl54FqU+MX3mjLxR9RFJonSnP5ZUgS1XdYgFD+0Swaa+gEHd7eBqsEO1NxZITaLY+vAglk5rxJ+2Sn9axYjlDBxkhecyWarGiaN2HWQjt+UREd25fwFjNKEXDQBSdA7/AawV4JQGs5BkQNHWevpbgMyvldiVbV0C7mNhNRhvFK9olYn6IekCPLvuePgRvz1BvyiqYY5JBfVOxpcikXjUnhIiGItbvwwsOqH8Qh39I9c1jyt/4RiuW0+0ZGtcDEoWw7dE+UMbHG+RWvM6GyCuUAEfdq7T4y0K3bjL6iXig0xTcW3FyQNxXVzt4aDTxY9V2x6amIP8rjtr1Gi7M15CJG6F2uoW9SyaHtFXUQrmGKas/V4iDpJY6EWaDRGj/YEzOgU4nol8+yvGiPoEOodrQtLDwVdYAYG7LC2z9z3LGCv8mIFkCmCC1kvNuI4zwhAbJnY+yhO5RpUSIlKMqrSDe37FztuOA22Q90lBr9JL3LrvOGLF1HpndLF9UYEbI1os5LwscP7rUWEKtT8mRcshDSl6i8WWBbZ3ufZusU5fMKNlQmBqleOuUqdYpcLG/9Lpcz5CdFR/XUNIYpARbmxGD0B7I75xeFm4j8CcUOjb5QM8BX2zpCt9T7AVki4xa13GGkD2kDxLVRaACZ6uF5luumHdBDVG4wowhrnSEVdmDH2NtgTrVt2aYhokuBf+V3jCKPP+Jg6b24LD3SzX/bmeBQ3YHvDg0bbJ2XKpk9E6D6iJjKQ9p3SxbJI3obKWzx0OlCmuuvg3MvYVdvde35WOeyyKYic7pS997TH+RLcqLyqdO3T9DYmX+C2J+Qu8XeE8INWjQn74ryI8TZlV5NwhHw020WNNdk72kXsKJC3JFYB1b1QUd8+fHga4pbeaWraNYyfEQxjMyQJLEswwseRMkQMfM7auZrNk0hOADJsY6iBbv0cYDBlPkjkI6kjIm20OLaiCvHsFH2ck3JOrCrmPfvKOEouUHJ62QfwcLN6JDcLf0TRbiBFn3FUvgWxWNqITIWzWcq3+HvvoLrY2Mzgtrvp9M8VqdCIVKs3/0QbaR5N7CVzpbin/hOI3AmcEOlZsYaWTE0drjscxGJP/+FQNvycVI2emQPPDAjSxhx9oUEwSgav60CX+SzRfa5yJY9ZB0OLIvENu5uhBi0I5pwqCo2v0EytcAEeR5pbU3TW9YV7S6Upidgtl0pWBaEsd+YMgw84rW/OwaY5PHt9JDHlyN+HUwJKG14rma579/gpK5CF1+IYX1Xve9GPQ8Eadgf0QixnPwHB5Xh2nb2VUU0EzLrZv0l8FC6sKRCgmcTwNQio7aXsteKL1MiKz0PVMeb9RGhXCnQsiG7drbxXbAyvQ0vbMBEsF4PkV5uzH1Yz2vozhfVk/k54Meao4I5ZfzG0jwM3o8tEdbqttrp5DWiqpiHZJkpH7BmiLZFolFI5bqKHho0fdcJ9EzK3jgp2RkDJoYbSIAFpR17422TBex3+Pho+Uj2lqI6IezD0Zyj+WxgQFo9PGlhXpcZPJEFQ8YXvkm39zr5n9bFzKeV/cKYSXbE/EWp+5aCCaLItUSH+uxWqkreTvzRT2QlHuuCSZYmNwNMLxvEJ2+9nOpqY7hTWyau7aAgACmTtcmTgP3qHDtZ2Nf+y7TZd9NdU4MzPdC8UiKCBmbwzCHo9kKC6wL22nNxaNrRdFxNF6nANE8bjRwR44yXux8o/ap1jKFaNhjRLQiMiZ+d9s7h28bTdsDJw8SCo+tZ9FIyjfpyWonVY43suRyiJm+aJ8rrlDC48lTtM05V5iPuaQ8yo7iCO9aEw346kGQF2SZVF4/jlFC6rQYsSXSNqWHNa+O0tjjzpHvx894ndseeWS/+lBZQFZfKdfFR6LKSzhEvSdo42gWu8nlhgHl3BmAlnYTjDJVS9VfF/ymPyPFqDmAmvjuGk8+0hzgH1b7siTC3plOcafJl0LL3+JqJEx2P+PYmyhYpmcFC1TlL/IefBmKVlDuaRIedsWgIlZmrlRpUfqimg1vPe3nh4yDFv3hXciYVPZMt9c81r2GkEAu49zC8V0H45PaDdxKwj7kaOx46E+dK+dgXGfnGsklpW0omYcebCjRTzC8ppi+n52Wg0JtRfXhfeM9n9AMtwmhPzNQcEqzhHKLXbFfCPMGfTvSuPcr/X3PxQilBFbjMUKgznIxWdd+YdCeVJ8yHvB6mkHH68IUluamNjNx9mhaxzHFHFgycOLovoWc0wJn2CO3tvLwNtThzkZPqsl+4CXdfQH9DPGS9f7b/n4RQUzLzlG2cKqOD/gqxK3gVixSuUnsu004g38OkpobZ19UUMnuRr3lx1foDp7yKrpdgAWnGTinWp7HKa23bvM3mbAJw5TEIVGMfwHjpmA3faCK0781G2DUk0m6rRZBxupAaYsmmyCcllEjBKe9btarISh3xnJZ1M3ySL1ZslqCnhAcdqBf5guG5LZJ9sm0S9j4hghynEguwVwPBLqRXCuZWEcOyW0/pqSSveqs2+xZkRCXVmlXIviGCS+BrFU/hO8sd4RfFYxN7/DL7BQY7dIWoEXw++9lPwLar8EkajDFpBJY7IkaqGnecO01pPM349fV34G1UKgXzx92rvklGo0NJdH7R8net9hSW5LcrIGHqgAgyrkMK59pMTu/n7okOYwS5FhCu7YhYJ9WfPWiMvR48kQ4geKmn2eHhlW3YONlfM2SbqrUVKxdTS2v6sKAL8qlZVFG/rQsCBC+yta/oPbBi/4T3/yfEIXwLdi94uglNGjPCLZArTri6KeoYPaMsD2U83DA8vkBaKue4Lm3L3XC09xmM+GFwnCOBq0FbgW3nV0uXgKjNWwUliaek2hNpeSjBbs3cYmEbdruxOz1NbHfJeH9JgUkGxG9b0MrM8BYCK41+biYIzaggh1tgcOmCovr6MD2G4i62dOMK0L0dpt8KIPlfUqtE6v31xUl6ZcJwS9SynoIiwp1tCqxlmGdYGHMD9jgD02So7YnG7kS8yp+od5vSREHCldmPDyMEiRX1D5AThNKT4xJjuLxi+MyDgI2EcFwOenh0j2Nd2kK7YLpfALdjSD5MO4HLLczFJN95ueK+MM8Gu2R3NJCL+M5WvsqlNB4mYBW6bXxTBiJSDzoWBQ4K1ExykigRa0l3nBkz9ck6MMKIx+FOMxvS2sLAXY2DeQHtk2fhgIZ4ksBP8atYRj7IsMtQg4k1dCBur7XU6m0D+Mu0F2WU1pkpDnwn8DbvkNOBGsP7wOwi3egrokOBmljm3TlpIhBBVnV3hkVavvtbSEPZj3qIT24R6fOAzCwu3wANRnH+wOAG0IkrxvNvar/85ObhfnnHDeMTCV5NDAOGG3Srcb47aXhxvvB0hhncDG2o41//3VSdjdBe7My6PERu1HkwNtxaYRkQpD/sAMOV0xh9H3NEzDSid+n24FwlQcBZTqyEwiHratWsl215Wi0vekp6tfY6zxuaEWvsfv531QHVtSwMpLD0SsFntEp+4I+NckK9Dt+ESfQ9seHeml68YTQv8Wf+2TO38kgaNN8b1PL1NPxp3f41VJIdx1zyVJG8MLsNp55EaO7LlDcDLS/zypOUBaE1knyKmcmqvmMXoFLvJxe3Jh/NJOKs9rxrWgOmDIaQXKgRhsqesAws1+0g7POWOr0+M7yq3xvkZ0ACEGV6fpaNJwo74YNNET3Ug6796reCZ5Ycx/YHKcqs1xMsp3A4UDu0U0BYA5mZIGmefnRhB0wIbrn9DzG7f5Wy+AlycfJt3vCw6WBiEYC2cSW7sFk9LL7Q0tH9MaLt2JlDFH3W4PpGZ0hXjcqRk6vOXBKn9K/ih/WekdXpNByAKfBO4qjRCsXVnDRhia7K04ZVxIGa5nzZ9/xzN2VJHxoKu02XfcxxflgMN62BnzYpwfYRgHDQU/OfZc4v8YWBzOA8Oiw/8vTrwhRjrmSG4btqbezCsIrtsq6pdJPSkZQNpF7JhQPj3E2vrK9VU3pim0g5zWB5eBtJtpSSgvOruW7LzDxjFnasJ4szRI8KqPfyig/tQNQf6+sJne4PlZwXbvsrDSu4g2Iorq5z5G8/sJYntha49P08CbMyTW5r3SycN8Ib+ohGaJkbi3j6s8fI8wOnI9daklO3FwiJMk9YmCTcQ3fcDAGm3WBWN7ZwibRDgbzLv7A2p18Emc4Awh2Cm2upc+XvTJICBZTscKCfCLyM5pNm/A+PsYGIepUJvrpZbv2eZC6Smi3In9Klf5GH+eKYD+OG4TlfGCuS72xU2Pyuex+Gv34IVq6Lr4RXe8Oskrsv2CjV/LACDI3PBAmolHzSszUIeGy9z/cyFnhUyKV9md2FVcbiwSd9AmJNTQuljU2t78viNj6TN/KowBlxZA43nmc9FbQz62NqZZQXGK/8YIYe28NHO1NdXVC4rkYQr/tTi9Gg9iPzi1FUa+HCzdmoyIl15ieK9ut84K3+lkt6QwkfSm7CcNgbb+3R1qmy2d8Cr2s3zc61JM8f2pFcb5VMj6vY3GzEvOQ4lnNcRe2W0kBPsdKNr3zOzHxGIG5KVf40pPuFxatftzlqRJ/IOyP6cM0CvD1G15Gx0KZzLmOUelVEihiLo1ag2Q9QTXZFl+zAebM6lU/ChuxTij5qvUEqHRJe+9rFuBa7ahGt009XhthsejDvKz7rWoHP2RE4T64lahxXdiVwGAsRTN3TjxdksGrd5RhhxjafgrdDBfhKa/hAJ07w35l4X4TCt9mxklfjby1RjUqeV4JQKSVZd/BV6GMhV61yEawTDcLixLIxbbCZIHHMyizuwyu2JN794j/CfMQPFy3a83Al5753lhBOTtByQZ5Sc4VRJGmYUTe8GySwKf30jXhJbxurA7wBwAIFddxMCiO0YLNRi58awoRiOiNbKYpLgsuJo0I6F895UJdxw4pUQ7OUaPfrvCSVSoXcomI9PurpNoNwcNgAUMsW2aX7uqsH9ew3Hjtj6Vu8jFy50AQ1GB1ePhxwfVx/Eb5IHFfz/Wb0w6fVAGYa49jWsuFYzRRBPLdpXuF2WsOeCOGwdFKFYqRuIwi0CNhm+YIR4MnY9Tc8g0gH5XtrI4MOqwOoSvEvAQ4Fo6SlWcqgaXml5LZkbS79Pd2MOMo9z8+Qg/zgodlCrZfPqEuhA6PZ0VukNWE80M40qlE4nCQhMJTD5yQQsKJWbW9zRUnBaI1MCq/bu8CEUn4Lue6N0cPzqNEaK4Dc30/pxoLTn0CbelcM9GhycydYziZ4bC223LDwdh3L3fD6JNBMiexSHUp8GZq5oXFK7KiOQ8vpwbp9VxYt1Yl+Cy9bCiwhu4sAywC7YyfPINwdfOjaRSRi05PKZXdcR9Dankrlgk4E8hyeBwtReKOOSWrxNVzFl9tpqTfT8adOq4mWPiB1z0tgn7qR/lh0f6v0zFbn6GPGmrFEtYLot6E+2ojBh6m2cTJ5EHTI+VU2wIncvbXO7ZyR+1a43UygUX0Idni/DammOONgfAowVA3ApwMC39FlWwrdMvzelOW12oBju+IY86R70v9V8fksNtEw1jZRfNfaMgLufJs5ReQN7vw38XGjwf82IHl2omOqgzDD2GLWas5vnTm9fI86MtlWDt4DiZJ9yTHnpEbo8gvmzqXHXRgY56lSFoulSW8DxZhJKVT8QELSf+mvD9d5Epyly6wKKGvyDpuvgfK4Ob/TtpoKpj2gD7VE210/aeqUwesZdr2Fu/YCPR1qg618s54H2BkwhkNRcc6KtoKU7ihDdnmARdeF3Uqzn1DG+Qdka3fi6Cgd/2A1KdV73nVI0d8KM0zHFfXzvJy2j+faKwt9jleFmVY2o1+m+i0PNIqd/El2oxxetCX+mIEcYLrm/VfQbBxf+QzsxL0wrgVMH9tfZnoDoNeekjMaE1o9dr61R4il/fXp6nN8J88784naBH8LVinc5tSIDqqXpOeHkn0AOvSEpzRYdg2IRl74B2unoTbz8S7Qc0qAp1J5NMRr0/YY1rxAkYFBAYnBiGOguCU6lW6Uye7m+cajqHK5/+1+29y9Ov/ZCdue3ys/fOoa3eInQBHl+kAHXKpHBYMSa4k/Ue18iLYV28UkI8GPQuv04x8Bpa650ofmq1vSR/8QFbYLK/9HpgeXN5V9n6mMAB58NX10syKkTZzH17KbCMI3xPxEIAl1Z/8kYChsCLMfq6fLXq4HCd4DSFRSv/0u+CeOdYIYsMANjPrmix918GlAIOf5pfJ7DuZU9nYHQ1kb+NI3a9T0LAMFaPQVjMaeUwY7K41tcFwm4c9tjvg/9i6+LErRgTCPOJchtay1+wMpV3A/2doyrzkfSKbKzrdwtXmb9KHt2CXD4UD0UrVR/sGIKpzYInX1nrrSZ4PsoOABKxWiV0hh2w7GWdAIrET9MHx2TsHJo9bEzNrF5XbFkZNcYlFgFtMXj5ihiMPeALVfID7Tbn5Sne5mfp7sB+yosNIv9HasOnLcrtx+tdXyOn3vRdeMMhB9vopT8jkf/ylqHh6fwF4+nEmCsOB730qkdUQLaK++Vyx6T+I+XaCqKKHI+81nGGr4b9olEYZz+sjiDYgzN7yrMeG2rxvTs2CVlbBiTPTqM2g4KZD6BP0LrF/G9jcbsDW5AhWwGCn5aFSSFEg4of60gG8aBb6PPruCECQBFEh5KVg/G50H+0RKtQrAC9GRxS7JNrncUZlHGUaxvnV4eOnIA3BscIjgxZDdKHXGErRa86xzt0txjkMK23iZeFHfgWr2+SLdfxhIJw+Y0CyysiifupG2yzfQl9d46ZMSbJUHljhBcSxaojjI9nAypFTBffe9BQChlSfKTP7PnCrUUtukDoPVeq7nBV4roF5FfYpyMdoZ8WdooiT3RsIwmPtlF/hcerQkJX9HuyQ/RuxUmFhnLBatqzWR/Db86xb0QJaFt7ui/Blo6EhYecQB5NAwUNLStARCH2+1JSj0W7TLrNRpfFAWVbIi8TR8Z1r4hsww1ZutUFfORdQOXtvSFqDfLghifnkE4Uj2/Wi5Myz3RDVttnGHOVUqASo95EqjDl6fQXQVnbmGCTUprRBE9CeUAFTN9N4BWV0gN3b2UqOV94NOiqxoKRXxYtlH+A5TFuda2nHT/238hHJyz2Cq3YgweijnNs972BWFqyv9rfrQ1OPmDDarLcYqdq9PXcnW2I8sTHBKA/SL+VFs7vRFKxq6qRvLJKc93DWMwtunZxqFiNA6nuXHPNz89FA8rFKbi0fkfRpD2gInTlV0OJ8EzwYO5HiU0WRfDtyKhHQ4D4mtYj+cTwakNFgP83/q/RcKn3e9+YTzpIBRiLzPP8lAi7ls3qViw4/eEUoVm55voWvmkr9+Vfy1O2/4TQk0cuBb367pKk9xcfRMOkKxuty40Zb+ztRw201A7dEkSRJM6fRW47O+Y9m0u6GksaXb+pdTci5eoQrJeGgxJ4mc0qRQDB2GABvzB7ygF3Re1Btvaq1cBwXDWwIS08DfYclxtehdQHeXrb7l3z5UTWseXv23FEPLFFmrXJh8eXn2ZWDmvEbHnyuuF6fobrG6wJBp8BEwe8m9pC9ejsSaR5aH6YR5d92mvzkgUdR4yAL7ec6oZJjB98f3VgieMHrIcYH1FpvS2ETJ3TIePIssq0oVaOWlG+lqM/jrBbOAHDdyYl1LX9Ye2qyxp4uIf8vccoCtSuI+AH6M/FEcG9N171Yf/u9I07YGcMgrD/Ytjj/4sWIvHwsFaIqjgHOM0LhLRF8pmNywR3XgrnLT92J1rbvBAuzz6sPritbEQSOv+oK41BKnx3vsQOTFOPdmTUZ1AfioJJueltAZu/lYQQYMZ6Wuz86gl44nmWSuQ4mJQ7daFHpdcv0ZEulkYVfDmdeJNmC/m3Vqgakiu2UOXVpRKXb5rFcmIku0rWm48Jo6sE97QaWv732153iyqKcjyeVi6nBbqCTlQhpYfUpKmjHg8x95+m9VW3yTgBEkIX9TbE0mNGT5Yd/hwmJ5636x0I+12LiuS15xfsOhIOUM1Gzb+P/y0lMVR2pWekqFBggiUxibE0oOlYDAVs9l4j0FFtI2uoDWWkiVAHTMxA4Nux4NxwL3WC4rKuuXqpvYbWeE/kHVtu+WC+cXkkBhHLALXbDqXM5bq7ZgnWtPBR2LNH8w5r40sylCCHHRBvIjqapAitzXYQ/SHA50Vrf9ocDkkJIA5g7AJAzrrQYW8sjzLSPvHUFSGSNOke+AZ/b7e/P0vC9GXkRdawFcL3UXOfdgOcniDJppVP5lH8BM+5gxF3k+/6V0WF8klmozyF53QJ6zkpupL/hjObT6fZE6BJ51yDaPKxMWrnMQM0fNtIlgzJ01VRh4Iu4aAt0PauGpXF4NxWsYkoDbqzTo8XA0Hb3upcZHxaEvAMS3pXPV1OztPQ0qgdMLvuQ380PnYJfOfruBIPfLWj6r29oRW2WXdB9UKVYmeJM3jg9CrXyTmKewAZLKTAEgMProG+so2umPBuPe3HAIH6fcnmyj694XbE8LuMvFMDY/Nk9qETp9Aqnk0ZNIVzTeywg1YeLR/vGKm/PCVuKd2JaGbq2NBXDl1ISDfc2LIdio82vRnVuQ5VzrI/GQbwLut0hlrv68Po+rgHK5L3xj260M9L4Pwz+78JwDcGS/wneKZDT86/fjTlGFudRYZntRy6lMFu8QnGGEJLLSqx67cTFDoa/kQwUaC2rMfOEGDO6w8ezWTpXX3728OruuyAs8vJ8YDRbrBiXw1666AwLlH1MU6bF9TRdrd5EaAu3Fz/Kjirsu3zPPjhf1F15bX3tXHXPH3MbuRbOx1zfN1yeDdHGhbyp8Y3zpIaZI2W9CXkZJUBTSxQ5+lifT7aNZkdVPGYRll14PHU1dKyPw5F3YSIReQi41FutbVjl9tk4+G0TXkHbqL8NgDwnoris9Zt19Qa9WYGhbHfVqjWdZeqw+s/nSWWKBvGpxOylgFmeLBDtk+nUcIj3VG/RibgJrvGsXtQNSIeULe7EYpprtquzR0eH2YCgouw4A1ua25z99BNZRc8gzTWWPPGrtyEZttbFcBpPKQO/AalCfNENgbWouRcM3PaxK1EE39vEOv0xquk6T06M9kPet1AYaKtKOGdFMkFqWG4Qnf+nQqqGWJOJ2L5c22HXpAeO5jQ5dYpEN7njXEdueTKr/MO7HdGkYCcquOjaWpu3fr5Gy70hTh+NUjn1zh1X/sELBo6nK8yfk2iqZ3SzmuridlkVmb4BJwNcmZTzHgPtSUo3i7BpEHqT4cJDbl/wkMXOuPA7XRtI2jXe42JZ78m/CQKUMiWpu0FE7nUlgjvEHBp9T0/xpzDWXmpyvLo/32PUaiLQ6g4+ZKFXM/Sn/ytKXHvLIx4IzUF/5CcdC6K/kaBJzFaAIlBCLVJIRF/7slLIVvXP1pwH0/bxpb8OHNeJYtqBSpDm0MLnpmDoyyZLNMwL1F+sWCteuFqTSUXGXi61+dwR31dm/0FMK7T/MhtEZwqhRuD47pbU3uTGdVgCQAKzYadS2gTwNH0zIgZNoZHtmjvC4in4uXNbGUwoSV7uh8emeTkhFiE7HlosTMoViKeKV+eZhlE4ImbXAEilgxUWqpeMprNNbpLQfEEtqi+quOWpDaliMjA8FwPm5xm1kWdhkvsyms5pHio4b8CnqDOXT6ri80S18NV4VK1bu9JcZnLnYnUplor/BqSxc0Gr5gpEKPRcSq4E83MVms8iUMf2q46Lrv3VEbTaMqa+fm7dN/N66Tsjhd26dLzihCgNhy4KmKqgsXML3F//6VbGTviu+OIUlWRNcFfSO3do1P1tIUyjDw0RgE+MlO9HblbqzDi8W0XsYYDPw69g3UNMzNTVH+9tBYzSzBYyhulszcZjsF4TYhAvgRoGfGGqCv3wjmGAc+fQxYFI00SVQ23xK5VenOqnZYxqIEbuYplALoT0AhStBeGtvvta6147x8ntAm1qT5NkpqSar7EmIRJAYEeLpT5YKsoYbh5XFZL08L6bMWNBRdqUDyRVzSpuaKK5pnjxENlUyyEqmBvUAdsa/eqAJqeqngGjETpnTXFsFiOWkfLfl0jTy3cGPUEXU/jA72Rncx2VyANy9r4gGiYxusgCQgMBpn1fIJi25WlXhrcFi/imcmgKX93YvoTBlW+i09XcpXKo4BCQhPlbXZkyoPLgZPBT83HD/GNv9sB9V4+LyraWxAgpZQYTm+UpLoPVf4h2apTzZKlo1GFi2Yp9z/NG6LVRWFOqTsNcysPHHiAiXNpuY8nCCXjGm8QvF6L7UCYDCG4C2Q0fUkVzI7Ipt+/kaYD7YcrrH3EVLY4KswC/Ra9zCs6BjcC4BUtiXgHIgDnuEM3WnLKErX81ysee7rXng3zRHk8K9QfMnEswnPg1yohaIVXYcnKqkW7UeoFJQAS26jGqGSyRwO3F2/OQ3/IaszUD0ElL3IGPr21kY0TcxrjVCttzzKPUiS8wYQv7CWG6bD3e3Iuv59WSOncLScjMaFhgQHvbL6FWdLKPrWqqBvIOPNKjkvhtIYeitdTNoN+mystCMnEGiRmIb1FkzCFQp6lN1EGaq7rr/AT3JNHCoyKSzROvxbMhwV6+c6xg0GpV4YrTl1d5Zbg5jDJQnqt8msEFJOu0TKPR37XoU7pgZttzyeKCkmEvR1CSJ1DVd57PWQR9Uw1zVPkLnossOn4NKIclvLcYIps0ce6vaXunxZ92YRQfk2apkBD5bNeDrYORQuCTrOpwiGsMEQupWnkqYZIoQhUkecSAh91CyST2/OTG2n6IdSROX6vRAUa59MOr5DB7+65rdO49Jt2w2t3y2lBHmpcRLjdfJ96AtF73hDcJwLGyUDY0ZxasIAT8GDjfh8j+Q+gOCgxvtudzyR1SjxUV7Naze/Y6IrETch8FeAk3vb56ZZkoYPPXGnD4iZvlH96eJ7zNHiyJW+QL9fUk+k7WccFEp9e5TirxCZ8zxJ+0W+JJGRpVRHopTwgScK0K318J0aeIx+JUgXT/Q5LjcXefJ79pAQ9H6bsqEO5frDa+FkVNO5KPb/bJDvh63Xn2fmRVQJ4OdCTXLJizm2BEjIx7dcz99dbDFGbr5tZpyjzikyPVeM63LmTk8NoUCAiWtGcMljE1AWGjmmfn3btszPhKucMRHCWjZVtiZ474p9Vur//HW7+RpS9i6x/X6rDJ6Fp65UKH9k1m0MqVTPCmdmY5RKi8tv2SsH0GwV3G4JW7ygOJzZJ5chzRc8Lr1dmOnVfohfllQIlbxQ14rl6qFzHnkrjYPUNOHj2r9jbviHJsm9Nt/8ZgseKCnEKtJL1anjyk1Rs5r4/VA6zHnPK/nzUJvvg1hypnlkl9v9F6fJiM0Dmfall6c4kKqjwW5xow0zOaDMfy/3ACIIT2bk/Q6xPAVp/kMDruG36867m61J1dwga4MANaSe9Z5KJ60SEVNEraVdpDluXwebyVTIy41d3qsD9S6aZhDP5SfHl+MW3msVxnIon0Vy+jkQRx3qy1qXf+ui1i+W1FouDEt189yTQUq5S1adlZaL9pUq/gOtf6SH+YkSfsWp2FrWHDl/0GjPDI2YPuPqLMCy/tAmgDncn9VRCv9mBuKkj9pEP0/Qfkga+TagGWJZuJSxvxmWHy/iX0LyXZoH9Av/Dx0LFwFMIhQrL/FTuEytPgrP9akXp76Vb+iOp+WMv8TOtWmfCta3vurBU/e2w98AmyPd4+JPvg6i7UbHsK/4kKQeytnnEWwfZhloohsIxmHhi11z3gzkIToQLJ1JV4Lls7Wy57IOVDAmaP5vQHKJL3F4j0MWxAS1qxZnwQni6cbhz9gk5vpeUhWqo7W0CVWLe/Q4xYPEW/vd80h4KZ+U2Hsa/PtrneDncVJ9mpaSDokM7Q7q744i3WYnbjNDsNgcKEDr0S/ctI7qRkbXpB6jML8mGndjNzKlHGE0SZ8vLUs5oELwC16q1I31OuXibXqFel5hM8+gAQLBNVHPzd7c4mQaCWz5ImuJS2AsqFtDVHMc2jFh6U9xw7fLj/9J0FDG9yWitOyRFwIIs2LuY+cFjEDIkZr20p+xh64uDgs2mpNzHf7jEEFjBBcVYNS2+gRsR2+44d7K2u4q/ZQOEYtrKd/wZPyeOOLXdnUhbELBfZe2Fx1x1BGpg6e2U6UKDWNin0isGLHbjCIefCkwuEtyj4fYGip8tPh2cyEkjed5ONge6s0eRlCb+xpaDyGLtUhJ2jqdCRVDg7htKXbWN9/Fjh3B2F6BCqsZa5wpJZNPh7drP+mkvXlZUuZVVW3GtToay5TfZR/FP2PgyE/xBVvQMnikpZ9XbCtqW1BvKSlm3vYnKKJArb/7zuya4Zqdg4uPpfsbsoLvEalDHV5DTlfNCq6NsvRGJ2VqX+Z1IWaqYDCaF3AqTz6uzgIDC+lUbdyzHN457FHzCuLCUuPUS/ZgJZCruNpPjD2ivfb+b+fhNW9GjeXBRXjuHbMaOMVGzMp7B4Dtejsdh6e3PWAIrc5uJtZp7gNeX1T+d5pOovd3QwbZlyyFxRRwlcoVbCTmu+YiWZYnLdQza28NtZJR3GWvsqNP0NeqdJVoafdp7cTPVnOmk+jjmepZZHPRsIRNFGqYgDieqGwcLmz+Gj8PCo5YtGO0BFD82MuqyBGRCI9PEBuIYHtVCRPJ9NdAagmIVov96ihoypgZfG5aQzow2ltEVMpFODUXOuqHImcb0Xqt4mbDqihjiylkM+CXucW2E/ta5QsMuJarsNyrWuy37hPv8/sdUzLj9B+fsBUXc7jNX4UFMjz+3l0KxqQbXPRk/u4q1gEGMj+axkGa8jsOpGk4m7m+B06/aEAAeraWWVL0+uYZq85nahhu1dCNUWlg2y7jhFn3A4nzbrJCPpzR1PLSKMPDQCcQvaywN2eARtJyCL98zaBU0AYYzUHD1WY5EQd6jqNdMoYQFXATdsBZuBr0oA0QBBwQLdtRXps9o4WM/1NXxQdlcLMvP0UBAJHGSeqLV9SObsmX0WuXfQ4GGulSa/uQOmx2C96OVMlUfp2Mf8/JkMmTUpFBsO+INq+q2KCcF+7wDNAPz9jcR8cjKM00xC1kisNR6gKmVvnMxqxtCLyXvHrI6tWe39SGwTkkxUPehV7dozrvHYB1RDhZuILQCEXAS/3tsYs0dJT3j5dyBNmWdVlCLjYANOL3i/CJRzbq4mrmJSjVpcFVcKTiDLlraItjNwpnZoBst1+CUXa/oQNEKA7s3rOywLjoV3CpzSvFYjvT3pSgakSTTDPb2b9G76RE/LCr3AyXbg6WewuLaMPORYiSjKLqS5xBTTGiODj1WwArFsNlEH8XxZLyqQkrx4GEiwL9pU/YpDpIJyHC/ymL2BjwkAUxkllvVlagDAZS4h0eRRe7kZ80IjE50blE+myfpp8Y45Th0guy+89LWTlLm58P+9MQwnZW9Dncm8VZ5fq3TBo5Ly2i/ZunMtNioWoueSbqxZvMJgLv6tSHhNYyyF6oTZpfQiB2K9NgBIzJsx1FbBuoRT3ZShS/79s2lguamn8M1/hJxoq74mkMDR03uI4QxTOqaHDaQdQBBVCHzz3BU4oiOPG1vvEylQ0Mqy0CUh//QvVAlNhpeRM4eYZ1QHVOt8cM5ooKcMo5Umbocp8YBUqABOGYMvumM49zl15myq7FykFD33JJ8XCJLmWWKoP6kzWDg6zDj9ylaw5/dt42lAEJ2aCeJQdmwY3UUig1el9y6UQufTAprj4bYxb5O798ptHX1s5DZq+22H/Eq1DOpVR2K/hytzlEAGUQkNoQClvzQM8QjmIPBzljB8IUZHdv5Sljme5lClN8s+F0rtErjRPIh4AAXl/sruOjW2qaQqBnz+OmoFG+pV3+ItX5z6bxGREu16mKSO08XZpBmMPWOBYcvCZet05WwBOVglm6PbAtydO3Z+JqBhzNuz4fZCz+PpymRA0kVs+999oe0EfSSQXoxHC9DOO3eQeJy1ePSlPsjSsj8SlmhX6lWmPYNQZJzMwJ8CvVAn1miqBo29RxrjyAogKuRYY/AN9uG4P0VKMNIOqMishFASmF/R/71CMSOKQfeuQPzl5LahL+D1Ui5YgEmMl8qISz0dV1nd23vNLytxhaeglVHlhWnBrNGN8nmBswQLdXua4cfQEeOHUKdKLfFca5ifO11a0VULDGjOZRKPw5+ZNSYb0CQG/G/NN8m+0AlqhYLAtl8aKXceWWBwvPvOFJ3v+GU61WOaTlr40BBe4Ges1+j6d4VMhDCrqazwuKxCbUj4yrCl2BMYoOGciQbdZS0Z+UO2MoThgWt6bkvEtAkpK5VNKXKQaraCbOpkqfYMJJvzf1VW4tKXHn9dy5OQFf5acFNoJLaLqPW29rY9iyfnZxBgsT19F5T8bzLM8udAZWuF1Wu8Ja00rTs71KmrZtEOSaKFmG8VhcsQgZuvCf7jpeN1PyafQJzTf+UvWZZfdrYqltiLnuP0ulWEZHw+S7mN1XTXTd8DF3MweNejNfvz59t1HjeURmBz19JyAjv2obBsAaNoOCRj+jHQPamiKn5oGlJkz+ttAfR0E63Fin0dkOaXkjpk6dmf1YJjBNM1hGnFsC0uwS1x/btQrxZUIOgodn4/HB/sSKhdmrKBFnV+P7dUcQrP9N73IxUT55hYE4uV73fpzDCgCoqI+G0unMFykO0ToLhxnir3IbJMZ0BTF5TEWlNtc9rYMHe/MHZIOoumLUszGHICQM/XYK2wbjcrhHHu/FhalcDeihvjyUg4mNlczOPoxwp2YcYVtpHUgNEtwzKsXlHFQg6DUmAJfWIERtGlpsHXCyoHamHAUsgFF79KJO+APtUbWUOcECfVitUj4oFUr654NOMyatF1FwGgIcSaDmZVmrY6yUgkwibzE9lizUiJrhPw95ATlnLlEj8AxKTMZq77zvGTqS9uD3FJLSF2RTKlnRJKh/j2gnKUGwdQQn3cp68SlW34HokNTaUG+7rHLendgVuuKtX4P2eyDM0p6/s3+uPsCfViWKRRTP8XZZuInna75aEyoR7yXybdAZkSmSadX689QkG4w4tjUcq6vEs1XxpxD+/zZkvWakf3g14p9fAK7shvz5IZoysEak5JpDKX0AJLQVJfVtNZmKswkChN/bRUKZOX2qDCKhFkVQiO5gfFvOFVEq9NJJnB2eLxf+LhTj88DyRnoZWe5KXlaEhVLNxN79MZKsc5t7LrEvY6sJwyl+X1SpMOI1J1poQFTA/CyKNcNvOgOxHeGnb9x32JUivaHOJAJqDaPB5Zb0grZ/Gb8emwXns0I0YFSXh4J0hHMpWTO3aV5gU5RLOUo3+iOfNW3s+VGDo4+IO6XwwSs/j9IDVpXfr9xy/nyNApl9jJPCcP4WCgsTAUyhwM1mP0UG+Mc9jMmo6UYCF5Y2zqPiLAPEPO/EdrnRrCYxShK2+n9qlZhFdDeaGU95gWpIGcq3+PVgaJBxXrXropc1V6JPKEHFrwMKyq9qxLRIDNgT/qw+WPgv+TQs/1IhPI8avahnLfUzii3+Rot2EofHV7cbhQanRxc7N+yEKzhrrEqSVLftDWzpQQOo8WUVkDTMD4uJTtYG+D+TeOVtfDq4Sczd/iDJ04kAVvbpKrJy0QbKompnydaOWB7bUnMlPN0bij83zaGJrHhebMB7Vs9G3wBbfXZp3IU4hYgEH3erH5YGErbf2xYyP1i5d/rUqoMnUlIe0qPZ8gY51OuRvCEwq2GykxTUFAfoMYiYoeD5No+ILY16WAm7LLHe0qrH+ZspcDi+ZgIKAftXX0G6cekvvOMawtzcc9+Mee7Y8gVzoJMroBPbniHBo+PCpCKb7Gx0ymNUYYWk+2lqjm6QiXAcwqQXHzbKjgOCAET4cT9HlswvDqhCSVdIN6sIZ7dzql7lKHq4p4MuSTBS2ZOmItsnB+ydRymaJmmza0VgUwthqhVGRGA3LYRiFyRV3oMwcvY9TXtbltK2GgROssba0WP2AviSsFTSo4R+U4COdTrsXTTaPiHUAMTjl/dFg27c2uhho+LfwgWuzkIl6bIraQLuiT7t0ZLfRPAiAglYFO2IDQo09+B/bQvAwiYkvHte794tddx5AwFFOc9vOUNA1U8+7nbQD3haXNZrBbhDjLPmQ1l6Jm4FzoV1DTI7e2KmDYN59TMqzqqYwBxqe1I1tNmvAn3GcpqE+pv8dRldldUHGI9S5XhnqNZ6M5w9whU06jiGQR2ZmshX/9sCUXMAVoUWkeHVkowSkA+ENEVJpHFktAFQrrWIEetwK7y+vYmxYUpHCvhN6+HZ7P2+prlHiXnxtwrha0aTURDaMPIyXHIyx+/uKRI0sWwPJSR30DKgiEOjk6OX5+J5FTQ2MieVoLkXytja+tWVUKXSzP49/i+jzsWjYdPgWUXj741uuZcy0R/QmTK116XBq9ibaxvGnpGE4a+bZ2i+v3l2wfZKGImvUL44eB46s50sWFDtqLV8Tfdt03P+bpyaqDUB5m4L3ze2+skFfve8F1v90jiCH5ApuVHm6Te+0kFfakAyx9ul2IJZuLr/IrIVUcxwANSF+YJkAyLUuAKMB2RIg4kIrbjDPXE1DluJFRGNeOa6fxy+MS0xGL8HoKyO4YWroAXlZZY8WW42DiurTw6e7bADxDatT1Nu/WRmRfE+/aIvjSzzXHH8EhkMCNyhSc4YxXB8guA/G2DTtIe9kyDoD0a1l/UfsKAKjXoia/K75wiSQcd+D6XE2sqCYaNubF7Q7DlUlN43y28TAc5Ux2odZVaP8/E/fdVdxoCPMUIqr1WOwCQ+fxGdFqrGeN/I8imRWawideoFakZJLGvfXqlAVdTP6J2z51F86CgLTkzI0SHf6pV4Rc6mEULc4JWv8bXTwuM0O+5Q2/kEW1/YHnraxNuVsC4nmejS6SYX6Cug8NnwG7uxtNkNjf+HU42D9lA7FPz5IwoxL0t0o54TlsRowH/QVI6u/78cHwmCqXI/g7h9Kd97l6nNm4P0Z8SFFXSqcF9jCcmp8VrPnohdfvetOqn+USkaoVFenP9UREg9LQC4cAV1VLbLQzDHVUHMNhQUmbRP5EqggnIoI7yqpvSw30rA84TkEgoqQ8pboaZ4qbPw35j+uZVbOCNj57yserd7tGQ5XRxAex+yq07ceT2RV2mHNVyF94YhCLtIz6LAjCqTJ3Ym4VEnthww/iQbpZ1QrM/cQuFVmjB2H4dHFQBb9MS8QXZp1P0eRAOalN4Q36UGCp9SaZ2BXIBC8px1rUwxmpIu2Lt+jjwbP/YxN8J4k5l8ri/K81YJhqCdchuF19kpJ6sd5Tz2BeZPYJaXd0ElDOG6a7wZTBgKeNjKcxSWZn2Vwl527lxI5BL/boG021mXX7AEdv2fYFDSza3vKKesvvM3OK2afpFDfztjP/+3D/uWg8sQ8uT/+zV/R7oXL+QwtLm8EqUIEi8GcRLup5atmxv0yHlaKSSSlE2c9r02yWwWdC3GAvmpVCzDK7LsVjbpBuRFLD7sU9vz3jnla0ajUk/UEsGt144WxXwVjb3Sxo7tWrPrw3SU7fRttbLmm25Of8tRL3VcxO+iTN4ZT2Gz994ShVN+X4ibptKQ7ZN76KuEIwV5XAK7/vIwP5BvJdYE8vPRCc6TPmgmcHuceflr9kvSQZ+PCNXuO83OMdLzvb3tyZCC3u7ztOFYwOy330v612el3DtVrZklJhqy1wihdWqidMCjaBNJmeZvnWs9aK4rCERhwrIWrAXVrHlVPSXkcpaIYFgTHKU9rvsS/r23yiXh67Q0t6VLt8/sscGi3UptmDER/4reb/iITJeXDh5tVa3r5r6jt/ix/wLJP8c+OvNkDUeMEjHqDcULJcTtEXzqMPQ+wnuJeqk/aFA+lCtd97E+HYYq8e8B/dm2la2e92TFsBL4ECYPnnBGWSMeJh3s/FUmXkgTT45gUWf0+TALl9nC/b+Uem7cgZzNAjZIRNV6PK0l9K8a2du4u5Ww0KSMSPHjopNJkGujG0U0GnNebTBjdYG2W9i3kzJWHFl61odP1Z7vw9ATHRJIcy/7xQati0gDFrAd74YnhFEvcoOowiEu1NcvAppcseeWzLxLwgfWYESz9qn8m837AEMUeytBAvb+OIRVkuAgLXQYE4rkRW0ttNWnLjs9tU5HfGFkkfveraRqRAQY855GdCV6ejtifafXtkhcoI8/Gn9uQ/0PCJz9vY1eEu+Q8dlTLbmAD7Nx3i2oDrKy+8uDVE9dcJRo6qQKChafE1UaArEPuAZLGEPWfD4xJ3Lm6pEjHKyMXmOnBkIjIee/aCkkUy+2Ppdf+0j7MVBJEcmW3qqzGns9Du56TNhtqZHXqAzfZnYjici7k9aq5LA03zN5ZtChjmsXPX+4cFdHAeX1tArdk/L3ZcyxE63+GF8EiOvz3iisJZ3zjhzdNDNs9mbRE3zwbD0vqkxS+CtVW+vcPEerJpm81WhyS/RWZ5W4Mz933gYqttNfxCWLBffr56ynfj52BqDLFGqiKxdIGSOhkID/JjaPzFsLn1v10hWtIcysvdF48ApuPhRdi3SxZ5i6JpRC7FRX/fwU9ol3nFopyunW+UCTRInaLy0xDWyn2Tddsd5SUIQwAxUNtzPQcFTaGdcP4mV1SbwMeaVih7Bqbwm43S4g2WVdavWC1LtnXpnBs0LXsbtqNA/Ialv2H6+ioPonJwiGGqSY8t80NqO7jUgr1GHheqdG/U+XXkTKqCD8vvkotLnxvxl63XqIPhvIEECNXQUpdrXbtaSJWnM7T9NokENFcopUrCXattUm+n/hwKl4FwSre9+vzzjaTcFDYHul/fOkdsjJyCAluf1ldCcLAEr7CmrfZshBjA2lBuB1DHY8csVXrHWXEyNeoLmAAFlvODXUeaW8yiFoZHRuYxGSpTXYw4DKeCa+ZpKv+9iMDUh0lei7bgpHjJ7fsF2+IqMH7IAK5aBthJKHUFT+YXMQjWQHyYuJ0iSHbRGnSjpGn74u/zFHTTr/ggFbuygFIas9sBZWSb5fzYvwmDfMZ2gcYpf1LS90fts3u+mwxrW2FsidcuTor24Dr4mFb8VB6QvFH1L1zLo3SRwSqO4fbvTROo41xipEgixd0+Sw0DqX0a/WDCL6Z0vaHPRZALk3zKLtxJDm1W52oyexdaJDJwXIH6wYVCGs6wT+KbKlAbzbXz3LYvg0sLNFRlhNVbBx+2ruCyvUVIKk6NfrY4TYkotoOOWXTgJyk1BTDqeCFuPSPmvgpEt3m+XyAJFjsgDpHs925APgU1VOOKNN5UPkuOf6ZSWlKYu7tQ3t8EaoYJHtNLx1srlr1awtMq0caL/uyMYHr8zhWO6j/DLQIMX/NNsf1i6xNa4IlGTk8CETPJIfueoiqM4uaoopcJ+2XpIBrrl+vzHbavdExYSVdOOC+3vTd4ASU1y+BzqPdZrRuvIQ5H37cbYe5ZhkKp7lP2bUQ8qMDpjqkUXk9XElFpfEfvmqEwEfGJ6OIvCdUxokY6tkyLGUba9mOt4Fp5KnkTM7J4r9XUcJl47bWzmVgRSm/ImNVs+5XwsHFNUPrV+ZomsM+tCtKOEXg7X3gG82Hgi2PvWd1UUszgJbvW8wOnUMzAjAo82Gj1yPupy9HSp2yJMV6DFIq1DKe+wF+vWspAI0FmBInd9/Vlji4rWY6SNkBkkyuZF58B3QorbdLuCarH6Apf3qxxmULQnrwbeF2Rz8V24edW5+nzc+JEj9/Q8rCPXT9aIjN40cFwMHupH0FhP0oskWnFDg9p6qc/Rw+aJctEnP9hWM/wVQEbwt3Ye6sH4G8CrjjzwMYYDI2nfM0NfMg5YkeTR4Z1cdg2SDjv0jIohsMafFr/OiMzKWMeiJWJO2S3Va9xXIb16HnbKbE9V2Haq+y5Z4IVGf2V42S+WdT6mbLvZdbH+mDuMA1AuCcsCCrayDpJVIAvPE+sQwkrtAZN7tZ2PAYZ/9bNS/oQ8kss6oH7qL1dqnWB/c+Gf+htMdWI1FOtkc9fOyN4Z2M+ksV2+OvTQoM+sKPWJ76qYUsF00wkQ5tFUssEeR+6NIohpkZb9hkw7GbUrmK7qyxznjb7QHh95LTIAIkPiCCkls2v9SN9p1uNMl6fvPbUWS6MxNuXsYelA1CaoQMLh7JWgsl21QksV2vtz0l8ESyFuRGIFFghBq/p6rXiGPXLwF+hckdLFUNVmHearE2JBRW563rwPN0Q+Cn1caniflaTeUe0mMxrdT/eQFFKceQO5WrDU3QN4kLnFgXdBlS1n1i3PGPZQf9gHgfZyQGFfeWvyQuOX8TLd0iy4ee20cOsj/vmxS6PqkIG+s6YvYdJctK4zhmKcPgjydVzNP5HLmo3kJ+0BnMG5NK1Zq3ztwPd64iCcYG8YrXWuKz4WzZ0gF6I5oU/J5y0E5CUV7x13xJ3i+H02H4a1LVA9QSVVtG14KBuQad70rCWg+IqSZINZWlOgqoK6TCEnTfNaN7LmkbScPpV51FeytZqXB/IPRocnsavxFmFCrCdYyF98UQxHgYauMIhhLWrWtl2Dby4isSWH8hRZXS3NfqWOPYWeBFE+ZvRHbStnNR6bXB6gOAQkz37DLurNUfBwEB0bDJbG8HXqO3NgsCYacPYUNyJasC58TOsaU/pCio8uErH5x/9akqqvWg2PRQaDCvDLRim+GD89BrySsgRPUoFB0AooiCRdPg7d2Yb6x93VjksCKBZvZ6g404RKC+etkpl6dNfIwr/P5jFysPfPfuXP01Wdp+XNchQeTNvoILLzkf4/t0oWEm39OfNz3XUnwdNfnu4D/ZYrDvHfSETZIRfmW03zpc3EBRQ4BoRPxyTnYNpiLkq4JLqPVL+OdKiYvDTdNZWYyAagzFyfH1tQVx30l2kH25lqlWMpj4qFG48VgwTSDwYlmFMtrxdqqphnauKKZLWGwNgxcFjOEKi584GFsQAWd4s9/rPrqoItJtbgVln2vQUO2kvrCqJexSI0INP2fRXtDL9X7OCaph5pAzztLDQBdn3BE4S7m8avTG3JXp6El6KvkbeJrP/cnG0CbxflDVe+yIuRxNzrxN+fHHIiIfOXR2I2AEewxp6uxLLhKnakzUR/zcG/1UHFnOWLAX6shG1bhvHCFtu+RlVXoP60rbfUW0ZqBHxtdEpD9rl4obvTDIf587S+GJtt1N94Z7iaIwnWmlPjgUyk4TpGgjzyCpgxy+qK6l/ax+JR+dmGa87JfISsGGyhcuECl+RPtQGvlq/i7GG9hgD1lezAysxHnGG8rI2Q1Qgg5kTkIa8ECOA4eHCe3nZeHhdXEx0Xg2wNBHrq+VTupPF+JLzDe5IyTssyymUWDPQu7QvF9GTjqL7vFhy+u//r+YBAEKXHSkdmzJMARisk76fdyg3X8XB69SDIIoGhejcc01ieZ2AT5i0pgeFlxJKpK7ln4JD1AvHNFu9op4dxJzbwhQvi+rdrRLKMbBKwR9ZBdPohj6WEqjFRNBUktnz2IUrvQsgrBCeEezKteCQLJDs0iM4XDZAsbcvs+aUlNPSM3aqCXN9kiHCWmqd2sKngNKHRacYBuc9nrXQtEH4r0tFwf5W38NS9L3xDlf8khRoRVGsdcRfWWB63w4rifJszzpZP4RLEBPKfnD/sf0ywhqsFpUbX+6u6G1ac7SE0gOIJVysJUKvNMQQwr5EMmu+aUxsxWCiwKpPJQ+B2X7PF1IOultKOld6KBReiq1mu2olheTKPK2ziwvgJSeINUlT6TntzVPZ+WprNd2XsIGATBWSR/czE4WQn40GdZpXS6KvViZTklM+gaLpqO53rhWrEH8YgLgUy7PjtCP6Qe9K6LjOTtO/KWxqkH/7sBAG4ENEqtLe2L23BV0JlQVCrUf8vnHmH69C22XRBBJKC7k2Gnv+LnflP5tJtUYl/2dQURBLlHL4L3b4JA3cRCL+1uCvLnavnhb0xdAYBYt4NmjsZsSVEb8r34el4yKmNc4OHeAzcvFGxMKQ9GAc0i7xEU4BnyK4NI7pDLJvc+pTjKbbo+ZkVr0PX5gVY/F2AzdB1xY9JkTiy4sjGAEo8fCy6DP+ozmedA8k1qXRzERP1CCSACg7/0046HTREX9ohL5T+i7hlTVayfANxxLCV3QX0JW/XociEGrAjRmY7lIk5cx94v73lzni00fPH04Ey7/mQSWC/cMD7nGZPR59Hcz99TQJGh9iY89KOwA/EuKNhFX9os+x29v74y+HR4nNOZPbgXexCRLOJyLuj/NfJ7j+FdXU996eDsY5uB5FHKYLTKPYBJ/r1BLbn+CKZIt6KiY/5O7/g4y/xm6VAXVLbA8Hjo1Ko2rAQ1UtmfddhF3bCXlUCeY6QR6EwbK+i5FbVBLOXHlteCLR1Ui0jkXVWAdfmoj7X2eyKiGYrImUCLjfe71/etENDWxKQxsZ+9XcfTtYSAVlO06DhmlpNIaCMlNv0xc2VirxX4OZSIOlTPXKZiG1VIFEY7/q1YsduuA9dY7chLqWaOp/oJIiyyvx2kVBTaYgP5bGldm0zdGq1I8CfUDm/il9pbiNt/xJjpJL0S0o31DKHrzG4WHRAR/fx+/f3V6jhOnRBwuHCCxap2SEIhFKToywvieIGSf9gB5jSxn+VBVwP/WSPxAgwJ5S3tWDNxoUc80bu424ISmSo08tFNNyLY4tIA87A49WDz+5qhQDY0wq1IN+Po2MaNiWBpwl0px4sBQ62CCeGp7rQV1pIq9mSbHxRPT8JsKrWfVacGSjuevd7l9pme7jalkVgYuT6mQt+lstDZdTKp/jHjOUOa+wIwBMOUWHmbwVfNczz7a9UdCBOAoGMgMxdeNVG4tn+d/deqKaB6v6V0By5QLXAXjowJ0JaFrN0e6pGq64ts7MwzR0GiLDyLs+pDr/zl1FAG72xQx73rTDzOLF8+nUN3M/wDOiKD9eEkyTEEftQa6RWYxeEIvcKRRkI/EWsmvID7b76GIVSWcUFTAq63Me5GaBl/yScWSppvo5r0IUix2WCDdTYvlT4PWaSqTECdKsCygmLcXcUbTWgF7GN6hPx7bspzFOO8lwHEcemtkdKGx+g3qH4YvlEPDITIpvDOx4RNfYiNPvsewIQEUp6d38WzHr/ln/NmXOyBRicpc7qYKaz29Lls4yzwQIWnV0lCYS2Eev466dgmcRjpnkUwLDUsCbBcWveZ4qqkKzziQYh9STQ3VcIrq/2Z2SFg0IsorKJM9NezVUMiXkV/jofyWBqD//yrF7qxNDBCJrE6UuA/oAGkKclbCLJhXfUxKFCyi4hIjajlJd4q6FO4mea/vz+/Wn/UZvN5ZJ0wZgLnbZYsNnGXTTmmnLQLya5u+AcfqNmgzTLLELHA6FRx0oKBl+LotKuNoPKzitBjm2eHD2y+it3UwCwYMxPDTvczq3V6T0z3ZRSiA6my7hmmYiqg1dy1XMR8DYcluCn23JQvjGbGZJHB47ap7GyeZvOeOVLVHDvGYdzoZG9uLyDFtch4pDK706y0Wb/sTHSvm8RS7FSGPGR+O/jALl5F04gSWcJzHFIlUknyXPV0stIW3ZIdnNSh2u56jyHo4pNeD1kOjBmKH+dStItbGACDIpebMjSETiaR/i6J0ybHx+orQlpPZN3bnxT4ziAg41RCG77ICOsR38/PLB0aPYAZjwFLsAhPD1ErMwHQZ2etutdGVUoeTkFvYNG1jZzxXcffIThlO8VSVgCfRYZuqe3Qw4zCutomZgysl3/tJNNeHAyWnr+q1LADgqXXSxgZlCHgEVl28jtE2XAfcaaTzT2Tl7yHV/WETFK+NceE20uTgWdlMAL18N6FHMKfumFKh1jrsPR2AHM+Q3L3Yvz56E9Qevj2Rvp/+cERpbF+SJEfvhhu49AOH7g7RmCLnxNiBmFiv6YU+QNBD5z4sYzRZpiBfz/Bktdb6DXQDY5ehu6iLy9uh9Z4PX/Gk0kFMJWAouHgFAoDRzVrnpAj6muGXMQ2t/SN8Pj6QKpzYqy/8fX7a60/bc7l+jKSN9oexOyQsfomRVlW01dkMzIctsGlsJk95NxqH2vR3Y7uD3sNFk6WN9+xYxH+p+Hh7CUtBSkxx6q6gJ1nJxdsDW+d71o4CIzf8RFq+hZDJFGAgFRVq0FUQaE10vAFUqU2lJWqC4Ds7WIeifD7YCwZ30Kc0E9gWqQj4qT/gSNIjrYxKR3CkTAm35lDqM4b55UCQrIkhztsTEae5TeBw4jVFiCn3PcBZQM6rIg5nSooyEG0BSEZ+mqAkycQXHDna97j9/OvBsRcO9bPoaIBhIi6qhw5G6EUVpuqlI48wRMCSDWIwtJML36N1yAwDWOApNl/iCe3aaUzRrwkdofW3VxzCIvzuIMI2s9/tCWUiB3XBQol5ZxEmOZvO2Sf3//UxIwjA9kOuDp2TlOWXg6KJK0O/9IPhqKrswBRFfw1wgtWm3kg6wigc8HuyQfiVcABwMulVtz3V2YSwMkk2GH7kIvJWDdTqgx/9xNtpgEAH/yaT/spjzrOGe/6muzw09+eZLvhvNhbdKBD6jVkFBxTIRyPYFG4HCn2Kfa83Y/LwV45p6PK/aryqOGM+MIW4WY/WOLEulGN4HAMVliYaWZWskVip9ncuFxyMg46G3yt/AIuqzLQa6JDgJ/H1QGkhFWyS88eGLYEH14TLyLO8MmHzdfNfZ0Yv704J4RmZIA94Y316CgcHe4LNK6jRloM0pDQR2T7CaCPAyTlPOK8zASWSw36DKwGJEbrtYRDaWdZgiymU1sZtzS+ff4t32CokOauB0Ka7xsfcJBX6e9OQGJM54Yusuz7N8ybKTzuN6tCWFEJpuTbaUB9Neolxgy1RW28NEUbZVl77H5zB85/R5WWOoPr537b2u6/TkXdCg3s4ZX7HmmDgFCZxDZenu3xRThG/G/o7FHGAVK5/uKDU++NF09AOKu1m47xAgCn+0Jl2WRWG0wIx3DJWCvOvORvlhaKJFkGzz+S3a04Ss5hr/y4wdDX0wwI6Aks1akktxM+dj4XEJWuyHV6CZshWqethCrVCJAvyk89FeiOPnDioPhSC691ktBuFAKacHSxeZDHMpo5b1QIwYIRdYbjTZ0WMzlc7TMnQKKio4Ja+pThvH7wpdxTfQIQ4n0lytbG2UewEvUmC/KxncMRRq0w1HRSaVO8Hm5Syl4D2u54F2tgZDZgVJUwznZn0Fu4heSVKy9pXAkNCiHW2K73+EtDJhG1pto0H4clCf4oqAtM+JiRtK3+JIwpiy7sglDVrJlq18wsZIZHxhsH1vIKCFQjbhDyk+Zt51Vz4ASSBDugOo54H0drFY72wtusvOIc6hEsybZJ2Ra66hnvy5+2+t03mJJkmRytatQ++Wsl5EKJkdyndmV75W2ACCAxkdNbbfYZFEAfIvZBd+aXVzJnyyAZ+LiBX5bZB/8sSfPSjdq82Xu8V9WlOw5XSE5myJsQz8edRaogLg3W0BFfL0NqyRbqmsUPUnlACBnKMT1RocE3KCEQMuOUI38gloqZMTBj1WmOw7MD4tz5G5SpIjMJJqW87uAflpHMIlH0M3G1RSdC3Et37p4O5g/zixF4Rr9hl6ksb17JArlp0KbKD0eoLtLeI8/M0D4M/A+zYQ5q3l3N3kGlZPoDCgUkaTduFKfo7RP+CypgZbott0rEFgOKV/hiqpYEeOZv1aPoLUC2kpDED/bWEKnpvr/MRy1zcg8aLm2IakkUYad7l4w8U0lCX5tO/DBrIQk8KNCuLdIC6BUBBWrXp9/9N2uEtS5+sjfmZkNJOD38EjHCqK75UvwPW8A1sqWqFHAmDEe5mKH+w6dXR3QUiKyc1Ou33PVLeAzk+9u7tUxcP2KyZWzAYxL6OYXvgmBpljcqQVhCb5SF1Ca8Ew1OALWW+h24rS9cjnWszx3tYgiFwNObgO6hYhLjH8qZ196OY3mAHwxByW7NAFMbzrjOIFQwU+cVHJ1jkV4fRCXwB5sglnAdkbYegprvGllFL9u3i9efXHZP/gBBkMPjNN2GUG386RZaliY/O05X1WQHP4u8Ahm+bzCVxAcR0PYIwJanq+gs+S1iwNbV6ALWSw166gFzuMHujzewhBbWBwHXzRWUbtx07j8V2y/HT/GJuL4cI4nNRBhPSs1zokWFw4Mc1VlH4o7lM44NLHQoVgr8Zgat/C/GgDRuH3XFZfICejyAKPhg2ejnyycydxMppeIPsewxV6Ko4g/9oWEPLlvLZxdjmxqBZrx/hWngEWPId3MUmL4BwK0k/vt18v//aSQfgIoSc+8bircXSq7Lm/hRLiTVuhf0ghsr1mRfZY8JmPEhudciMD0USlvXWbhG8sWCJ4q9q+nHrBNkNCne5+RccBGzLAP1irp1uV8G+e7j2uuaSoIV5vcDPsdCF11ht7gCwUafNgyVR+IED0Sha7mlNH39DhUqJmNx3EuuxVFxYDJ6A97TvmNtdYt9zSCu/oqRX6VkG0FIGmAvTm5Y7fTrrOT2C4jAI3ENHKT5saHsonx14ybmI7wXY9LIlt/qVO3uQXR7I0FPFFxWmfRpaTnwfRMjHXR6fL58ALu+C9XOmoOymiYKs1OSxCFmLnBs2rwCzeZiKrkxVhJW+q0Zr1eSCFPjOaCgFNdqjovYmktz58XCH1MEqRzE1lJ9mChXqr4f+4Y6ILzC4IILbjEOnMae++0k0JW2ctgOhmF7gLBu0xactjbRH1HvhQNC83mZvNBs2QsaSpPN0vXc6NvNfUV47oRBAwZWUrFY6ojqnF1OgStpWJAQR+ngbbYBKN+zDe/SsekKmLsrGzTYh26MyHjMNLDZaXmwWYzA9QT8AVrzxPJYA/OHZER/M9wrJDcVbW/ri+wtOzuL9nsrCUDH6K6W3SdMuFXRAWrwwgaVXsJXniL8fpU6hnPEn40tU2J5L3KiAgCOeMujlpUMINTkBSHWVurHxkYjWI/UdyjMBcg12WpMDikovZh1IRbvrRAl8yU53074c91KOUlwieXWPVeMisM1WV5FaYiIV8Iwzugfi6qGg/Uyy3hTZAudDlnrOJvYDXwtPH0PPcWiAMCc/7uPSxUVEUcO6w1yQJwopNWhi2B8M2eIUzx9ozIcPq+0cpgQNAo3+euD39qBB3gEgkCJlZvlj2JT3BKz36ozOCyKW7tDW6kkVQzN7oUSKSCBwCXD/qKIlUOhUHW24YhbCXlpn+UiRiibi4PXaDIwzyZo8m5G/KOeCqSQ0wxJtEl9bBw1agT9GUurZJDFUnBCtRo7RQE7MOkAT0pEpQebd/zmw/LCS/3J3glH/jgZAmpBcbGPD5FWXrF4dE5BnCwTw9p9z4MPLdeeKPb6q8XRyBDIO1LzaxGvInVIGj5QjV4WyFudbYdNrMSvhxvHC3EAp8hVEPv8ugtuHRJnQZgQVhLl0Kxr7tFwg/B3UseK4OxbNg5CVNGj2v9jCJzZcqsZMeoWJ6sZOVIZP4y8nqOiLkAErbvGZLVQXa/+pJMHEvky7n53/+fQl08Ufbp6xZmOG5nr46nhWfEZTuAOtPLJXZln4XcdAWqwMktVi8TJv2ZfUrP0SU3uSav24mE6ZiTW6nPLy6FI946W384JqKGJCiK5OvrwC3GQVf3Xdw7TnSMlv9nLrg0j9Mn6D/iSW4WydeQJPlUykt1uL+rjExYPxadJrmARkaYPYYg4BJiSjayDMAXwvLRwP5rYTL3KQu+IuqnP0dSXLTz8+22i21URzf3ssDIUcCKUk4HxMvXKhIw3x2h2jWj9LKg4ImMOZwu1D/xHpA5LtgquhwYWAcsMvJXMyqzWTr2CiZo+nS+pga+p28QmKiUn5LIcRV/qJ/pyNtKRRfb7SC1rwnoIkkhcphyS8i+p9DthdEZYnZRB2ryIXW2xTgtt1U1HHOvFtqOZYwN2RfcIDK6gfO56BCEZ4MEWCj9lD5hBVQ9SW0pVnfGvfN+s0OzkYcCOJ7AtZOqIJBrfUey2pqwxZNN4Syrljwfi0u6NpZTUBmS5FdidEyTD3ERAR28DoMCbt08qnFJgC9xnpbZ2nySbut56MpfnXeGW5zHll82Pq/C1yayFhSrLNobBOVhWUIbOXvnO93jufH8uhTdXEraML5xiZcUyS51RfadVUSIBfHKh24h+XVNiNjWaREcMDU0se3itLW6xLHMXydgksySqcjgGONAVz8/clVUOyOspSjqAF/qucBxoVtgSbMjmCK4VgWKLPGnrV6qkli3bKoNLw4tgCcZdN1RVU+AybUBjg+6IrPmIgodqyV9C7+u0fobXs+DxX5HlcI+TDndCEewAEj69pymWm+zUNTNPwhh0bDT48BFvCzdTyc9tjqphvwt3pWNTt8xUBJmFbz1tyyQPhOq3AZB28dQvl1QEJnx+tgfeRiDRM5y1yNFw7dOHLXAEackB8R4MwEIlSENMH3klHUnGRXhebD26ikOAUeZhCyOdxQo2Cwrz4M2mElKFlbiKKsIaXwgAseXa32gEB/VRPYW1Z4eTFoOROQu0/s7DGhCrnbyPoplEvd768ZXkl2M46MQ1PQ/dSmt4EbkAapcBcOLA3ol67I8HwBNOZjwiS/sv8d4gGVCP05BaXDhLUslP8sxLBs+oMZlz01x5Nq9SQLlfxFVZdLYhBLy87T9nWC+jov+05Ze7NieytXvReGlreqkP/1ytEnSEC6IWis2fzt2BkT2HruZtjQWgp+nfBSthlVZDJa2nEEdGekXIZLB5bbf1bntdjxGvTyswFazltXTxga2dz4p5Z8Ba0irObnE18kGxVwYdFXMQ570Mh8LW5P54Negf+XQQgX3kL+Q/dr+DKDrDWQDnykTCW6+sGVBvxPvM/c1OLZ8GBV5j+pqSVDzjsyDeNJ22qaqUO1xJ8t+g3auTz1RJ6nNzaO+6BXm7kLdzwQhkdO+Bl+vPtBSaPrNBWVcFto6I+TmiYvfkxf67lSsmCD2F9CK9MNFnsnAbnDnKpEtZ6LCiDIk05BPhqPps3HAq3QMkLgtTXnhGHxU9nlIAizizGoio/j83TFGGVI5FKTcsrCakiWFbJ/kvvpBQC8JejMYlJMMnYEF0u22fCvN9NZtxaPfqGQvSi1Vvsyz5jrWx5UVpR2fW9e4BgpPlKS4vs77yY/qdDL2+HQo9PzywGNfGzqXMfN0cAWdt13g+9V8ow8Iy0MYphIcZDYA6USy+VTZdwKzZZ5YA08VObaMKCt1w/gKFm4LNUrYTNtOf7REVYjQBuWNXixmKAQRs9ThtZjd/vPmDVRVC32IFsD60n6Atrkf489IiKFphBwcgjW0VyS9XX4NHU2ux8DcHoSxac9Fc8TfMxIhoZ7IxFL73sdoiwe7JSGFqdq8zcM9SaLhexW/Pzic8/oWZsM+qIkjltK3xWv4ncx9flU3U86AG187tpwE01WOOBckdLFTEzI0L59nQdF+GuCrqpxLtLTHVWPghBMxsEa+zPl9FzyY315C/XzVaZ1nlThM8Yg2yv3I5Zy4rAJvhMYohKmD0Qyt82hq5KpfSReayU0fvgSr68Nd02493bYEUIZ/A7Njz7qDqSHmrtvqxXfm338rUE567vxAehOpJXnhDyAwppdPMnZUICWaiPTR9KfyMCXCJy1U7ZPxJuy6eOCSTYUmDLnll53Ar79nEP1Sfm3utYk+OvL1DFiiEGkhqO69m0jSlmzJMyrC8PjBP1U7Pl78DY92u/Phxq/D9CNnvJdsZnZOuzEhZ0tpq6YOx3KzTVcCYPoCvSGS1uPO+bvDuE97DCB3r4RknPdUECggMkxwBHlKqrO9ekla5bJqNLzgirPd13Cah0o8szmqgpdM+jWLIVxlnyi5BfAyqjTh2vQHWRfEdUv7NLs5Pg+h8z5oQ057xZPjY7XDS/MeaZ36W+VjlMo+HGyVyObok/1j0CvbfXuWdIgYB75959inWS0JIwUBtYxxM5JhZyYafU12+TbHUEshNl1cGje/x7xCY8XlveN8O2xnOLoWIXOW2riEA8zG6q5kTtrlfYOd//xFBtmO1OTk3FJytOeqVWdp0ZnfzqtAi2z3b43LNdm9aDdyWEJxQYgNSWWuUUZHNwsIEZT0y5VV48nFPoLsYDrXd0gEvspQ3A3tLbapmi0yPjKbPyedwooegRLZMAZq+gofwgkdyZSqvyZbkn/Kg8hSu2QUwO2TOb5jDXRf7hGOyy3Ni9I3kpWKqkVOcVH0+yf5oBNfeCoYuqVhJw+ZauHg4nfFx9Dq5Ob36q/kIkwcVPZ2+ZYczbphuvrJpMLN1JxSPTd3oOGBJ/aCjXD5dwGezaUgekzS9AImQBibjVJgvZPsJ3N+Kh3ypNqjFAILtdLLFHMbbR0snmqThnmxD15fCsrcRJyqtMQgkZ+V2I4OJQWzK++CgXRHfnNhnLVU+y3YOCtkofv3IoDg9+LdVhHIlWJz/ZpSjseHNXFy/Gd7AIDUTLEncgzLqB51UsSnRmzRlGFvfeQu80CXSjLBrmZouxwWhWKmbELLuf5tvDoXBfSAw7zfpfZGHd2UL0sJ2Bxc5PpwZiO1oOmyOjzeppmL999tIrzXq5UZdsk1mCM6hHlmyonoqafHMETCFGmER5RfWg9w/I+axnuzTFE49gxypgGGiGz22QGL4/ADbyWip61W8AvdEX9s+sV6z70u6BqXtFFcbGZZtF/tKmx8lBxSuWgbBM09UnS7YbDUwYy7ZQ0QRtf4BF1RVutyCo7LlwSctLxT+wfPMW0fscvgap5Br3BywAA0+bNHxphFyMdS/AsVe3HsZsEFrwR/uAXOcaJgF7XbZTzOGi7Gu2aCayzQRCslCxS0q1Nk2iHxXkPFquailkHFJ2TvEVKmW7n4KqJ3blHT5gGuCDhuMpDk6PO6tH7DJLUzBUSiFW+2Emc1c3Hu9kjlu/rHKP53fU6PORiBlSXrnb4iT68iHAihvthHGOTKs8/RPvh8w+TyP80UcnFi+X2FTLEUH/fB6KAoxV+vYfO+sq6kvbxrf+dONUc2hS62fARbDfphlqx7cMc8Hf7N+uwJSKohK08CirbKDg7kcmLFrJn2QGYHenCnViXh6NfG09b+Q4Xb7SDrjCFD0tqrYlAXyUkwQBof/2D1xrp5V2hR7jEBn3pUDh5fVEYLOo5n/XBTaFqGKyCnvmB5QTTLnaQ1yr3v5+9j1RStJ3A91eFhBBhw0CHDTaYE8vjUSj43lRO0KAOhl/vhmskajRfdhCchhVcg6ja+Qujqz4BD5vIv4dJorTQ/DGk+sOl3Fx6K/7ePiLUAH9sYQYnhat6umTwp/2iQbDKxFtCZHLpwuZ5I4mqRRAJH/gGuNlHL7JGXIBkXYZAtqrM8CIDnHEABqRH1WQ62j7Mk/c0kanYWejkPUFBadxjIEIEocRGeTSn/Uh1fmK+I9+cqHsVi3yHctfJlxaQKwbau/YivM4zC11QbrLz9W9Dg8B//I3ckkiW0aVPSgLIzWt5S8+rjO1hZaKYDR8ksmOLX0Q7O25SkBbZc2I7YshsrtqyiayZ/f5QROhtdLcvV1kUDUudDnxvwKXFDFVlBLhpyLSbWN4EZQbiCD9R1XRrFzgcZG3elfBhmmTKF5wMN7vJ6nHYoQY/9GOeZW5z1qZXTqMMHWqzazMNYxomw22lCDCOtZTl6E/P2qwtrtwx1CGzExifGJEE7kenDa83ATejwYP9L+Y5uIcIGD6NURK73QUBIWE1zXsrblliNWeRD3YmWfwbSAwBa6bxDXHO7lt+ngK7wk7EwotaZpOmaLHBXe9KJ/mhr+gASLNdHIoFe+xCU9BHAK7zr1eT+FcNJL+2OSQ2aBfHLvYYd2JYsfagk5iqaOtDyxl0lYkCJ9p0ho8VILh2kj9V5EjhBo020p3nuYpB3npnAgTnwacxBgzSi5F/8ffklDxy+8kShyvUMsbDt/mqNvJp33RxhCGo3f+OHLeyJd5ULNNeBhkfDa4KmFyGjAZYzvYRd82XHvOsznE8yVIMtfLChkLZzb4ENHSfQ8EZnSVbw7ywb7mnhguNPDQdSBU+tG70wI7GWZQ87WNHvjrIYmTVllrSwUq0WNihwMqOb5L/M63bbDNIGhthMFPdzT+IuCgbXKH0VWDd4mlVd78ZzlDqXg5RVVo1QMDQUOIfkO6pmKmUk4Tn2wjWn2fixakIAvEBe7FwgI1PV39/iljfJ7MaGOCzgffptlPFfiRue9Xt8gW3S1q+1ZbtoUQf9fnwCH/I7SwIHBgjFyolD2wa8/z9vheDknaq+2w3beHaB5j79+7D1N6lCLGvD2EJDOtaK6cEFW5iUK09KL5XdLQGX0rSL0nJFr23h+0JZPKK2EimmpgqP1J9DDCuBaO4vgpKiptwrNBucmyRGqE628LY4PL5OfG3ajpv6u5XYJDPQ4q/2OTRBu4ZSWqj1OzTD0dqKOdEow071xuY1daL23gb5flWgohPMec659IaA2t758lhdHZ7KKMbn+YpCutq2AA17BVLAUSdT3NcD3kV+JXW5jU3yVkilQYE5si32u8qMdpNlhKInmjinmFCRqNI1bdlzQknRxl8W/IC3LmEzYPxR7RMQ7dp1Oy7HAMwbHOh6suXQHwvU+UElrOwEpCGwT8h4hFG2McL8ruNZHj4Unjpi5njRyoqqADY/w2UHxIAPcDulvpyQ3wpraeRXcH25rg4maPFRDoZq4U9ppqjpU028RrstP9deogF5DG1i7gtYu7kXNYC+x3kc/2GMUbtteOzEfJ1r4NCeF+akbaGbMywPJmd5d6OMCouUaQPt4Ju4LlJe4LgwRcc6oq6kHj5QZ3PZscgWTfkQB2zNQ4mbnFOAzmv+RmhREi5PYI+V4OWvcC6G49Vf4LP1o71AYLXDsx75VC2dnTb5QziGFkdsosp/89zfJNSk3lo525DihCbj8l+yoVoFqQX+aQJWvPYvHE7bwO14j4KWIdsulUSr1Y/zyB7d0eVUJdVSezzCusm+MBd8phxeUf02eWmgtzkUlkIEei+7ivz7f+BhLVkNE8K6xMqRO5t9fvhEwahtNag5/w43CNxbhdVHaDjaQXXBnW/dyD80GgWhN9qfz3/s3VDja4wexjE77xzUTZk+b68QUpMtaz6onEyB8P1C47YVlhw0rJlZV+PLWq0V8BaGUPX8Xat43/SPOuhwave61e5h42unCcGQ3w2gewulnWBGf1kol6BauG2dxr1sSSSUiDqMQstIwNEwYwkTEHMVz6poRbGdR58Xl99U2xZcDI74ILsAbRpRyIn2DyboxuzyHOS8CzLmQtqsUImw91KHvb3x3IurgsHhvvWQGNpxEpOdjpdbTV890rEA8iwI57/+A1ewCst0pRL8uTLOBxIBPsWzRGy+gtaGzUwuuf/9gyHem6Bdk0YkO9wp3HM/IrhH145v12Ot7i1fBV/oSbTInt8gHqRb5Tsop1APOkhzOVgyZiZMb6NNDk7rculkLAt/cDuvnc3B6ywiBfTpwr0LciDTouC3lBIXOs8rjNdW9IcGekZGYSHSAmdIxwclXjgQwZs8nGbAGyWR9Efb0rdfNJKw2h41Nk89rKnrjgaLdgV0kkdmFazmHgdKgprc58x/aleSqB6Q5/oWJnUVEStllKqZ/ROsgmSK7DfqHU8wca0MYstGE9a6iNMoAyHH+9nmebVWkUgvill2gLxyh1dRtDpiYWifYIEl5jfie15dRvJG+uZznb6T1mCjv92aWnuZaR/CfXzYoxBr7LYAVJtNfMCpPZ3wQ0FL4A7m+FaCmtsToNXzZd3qPkdabkA6M0ubPlE9nkCXaApt+yHzUH9o4cSAGhwnEhjEF+XxY4M9VRC4gxtmZ5KuI7fHjvSG6cshrL+l9jj5NYXOJcgXkjGgDW6H2CH8p2pi8CX06mFVM1X8GxWumTmiujxa2RyJ+HqEogcP3neYXKfeIfQcz5tuPsoKMkGksHY/qWh9JjRMOLVqKxAupwmq6rjteILZdYblmaFgSSenXfpHDGojSwfujpnioxvoLiHFABqt7qGDuOpvFQ11BlosU2aMGECSlCJciYO0ukMkWXw9ENboW4Ca/W5UNI29SpBs3WNgJ4wSQhEUhk6HKi+BNDHLnZfS4MflWlyKxMN8vYmWfEJSYG6sV+9FKCBRBvkkWd2F/nhpDI3Z+l8nnYA+ae3JVKpNGp2xakgDXNbH17EnV68FyoXbf8uf4nWqT7kswMmopTOGYnMZxOQp/I7Umb4GXU1b/TNsOUvf/jckLfD9QAM91pMygQoDFARtCiz/i//zxIdtjWCYqdl0uP6PEgl0ME5SAfPRUO12BUgjcF9+VaD8K0B3vpBTxJZTLn7YEbd2KGCliWT+AYgD2g+LG4NKCrbKh54txJEEirC5l8Kxtya0Hcu4x6ecxNlTW/62ayyYbBrUY+3D/tzXMap1uGUQ7soOluRvNLNTqwqB35eGqFiq0Jg5r14YIw2T2PylaEJ4paQo5G6ZGdQ9xWhYNwHBLfAT2nQR+34peee9N+9BA59q0QY7XWtQ9r6Xaj81iyybGl15J4rxVgg4DPJ1C7VZIW8VXczdJvOCcW48+OMttORPF3kqiOzBkEGHT/MiN8weqzajsC6Yxp8UymhKEcyOQOvrPYxLrR/T1Wu+XvEldRd6ewivnaRTsFzPaEetqcOW9t5EE23KAYkJvvtNTRtKRAOR4+/cc9pZeySzphFMhVF2kXSjWE+9cVOMIGcxOSO167ryjRHH/tep1TsntFAddxRYsuucVpsLKxj/t2WbdHaMcT927JugtK8UvPWasukr2ujIoN2BmIUg/GNQVUYHs77CrowtWcqm5uwnyU3sklOyzJAGKbgD3AduaRCktPy+wGQ5Blp/f8KhW473fiM2uBcBAU2y+GXrHvxhwNwIWmQ6QYa9D/mskKz5wnhsJ+W+NYDPABmRnHW4/U+VSuiUBN1PbbOXGfkz+lKzP09SLG6MsmIbftprVxr4wDBM4Q1EScjMOuA0Y7cdOQAVCPQjAa97Piyd8IpaRVigWP5rdOclPwFx1tzpFYvovqJkZhQ1Xxrx6ZqvikyOvg4W0JMRm7LGd5ljf1mCDqHCF7j0MOZfhAGlUMAZTycyMHjpOxvQQPOYcww7tuIPUDNAbx2dxiRJ6OJNByTeIa8voHbvvFn127HN+0UixhXvLhkcAzq6o4GHrxSX5YI5wfeqMKTu8Iii+ZJizk/L28oNSnSekD3oNJJd+foZZOLhyCdBW+JuDvlHi5yMTcbNMxr8qoCNqYv2Sgg4JrAOII6qw+cM/GwJTP0VDqOb6BF2ZWd7A88Z2otg6JAfLYSON6QIvz/MgVH3hjydktcw0JydGobTOtKm/ND/ij/ShizsmuTSVWgndHo0t2JXPq70zVW+q53i9ebf3FZHoxiJs2BUFMNSW0seRxGlcHRk/mQJbLNzHxFYUBBpRLSnYKnkvfiRcpUMIeiFuE9RSnYijKkNkUTImCpx6+lkgig7TH77dXnWwty+pVaqYFyeQr0Bj9zq+Rg71oUsnoEDMYY6HDg4dnypMAWvb9E7QPp5/D+cQyZimM0/txy3CNCHJ4loBg+B6ZrT+sUW2Z6MVASMzPrWQqev3OWDj1LhFk706X2gpj690MxchcZ/r9R8eefrLrLBiIko44aEy98XtDT0MW5+dpnHY2fNmzLTlw7uT4TZj5QOcKhgUAuifxpcHZ4qEMralOq/Iokg27ycCSYQa8IzODgzGYVvhZnacsxAARbX6AWLdVDRNtGPoP8qjfyHNy6ntYVGaiwsyH2RS6aTXOePZq67AumfZMarKMPKWY9YsHUTlMoFwahTMV684RdbDSjH812iPiaBZ7G7wIU993CYBS2Ob1dwDnCVuOJW/uoqOJPCtd4YSpZDzTrt30ALiGk+Oeigno7RecBsU/0R+bBQnLz2wxnQMNNtR1yrMqmf85mAQDDzAaa9dzyduOJyXmNUCcovQy+aAy8cb6RMYYy2TkLwRnKRJKVhZf6fECWQkRXFEz1fOffMeXDMn4LybV2cudj+b4J1fxJbqzZOCEo+pltEzVkDWEZTsPTk8SvJFCSpLXiQeT0pwJ6zGmy/ZwpA/MwhLR5EzGGV6GNDssdFswqaG/g33Amst394BcT6T/jbMH6EP2rc5uOK7QvKGkiNeNMsfDCjSwaiRUwVRuDQQo80h0tQVFcaiZn5DcVcYO4Oobv2cIHDBHQcSJXfX6juzkoEQjw/V7Mw13VMcfAHAEidnOVVcBmph0UjpMCjtH+/AIrBoFWfuTB+TfPdfs3aIt57X45pfySX9dhMF0MrPmOUjsy2tJIoECFDnQe3EyH3rWsFEGkTrET/yA1bF7m++Mz8HY+JrkqLmqBqFjqP2KoW2QV6KjfYeSmoPPcZf9R2fF2ZDIav5jn3cK+HF7GH4ZyPn6lWpDY0LI8rPO9FPqRSqLgjxLv0WtjrkoZeoqhZsZXp4BAjIGgiy1OOVKM4abGueCJx9OIKgBLDARLVjFm7FZYyqQ0PqJFsCqLFafYrydmHkqTMD3A79BhBg7dwV2WXtbDw1IckIeSvrZQTxGMVPVWvyVMOm0GNd3T+FG9UP3+68npyiTdFaod9LWHWi0yf4I7xm5OGOsH/R9+oA4oYJP9QFSd9YRwutZHA3kxeIRdNthhvO21Fqy5FHTl4ECLqrXv+H29+71hVfhsfvuftp0Y8ahul3yJ33CoZKSBGKdJu52DgzSdl+OBSBMxxQ/dZ7yeE3eWIBq8i5rt39km6pD4i8R7+RI2S5iM3DQtFvwa5AJgx+lo6vbQJNsaeC8KCs5oDGqLnXIjizybdtxVVyCqNDMaIXEk4PgB7oS7SNyDngDENXWO8w0bfl5nAedjF84eaT17/AfAd9brXj8hDNLX21yC/uG3Imd92BeUYCS6qktaC8KNusV31FHlsNKQbwoDf3vhszhboV2dwp74kpCVf86fVKPqRBc6syh7z4zR1iasfcnTAHF6nTP7mDJpZo0YAAC9YQixkw0WpEKw/tQH5573lGkLfDLbvPlWlon4ICVUNUdCc8hX8HAdaCcAWcObqEYuG46VG4u1nEY3oVBZwM89EjV4UvkrQ5oXi25HZwyKoLMBisHpC23LAPVDGBRH2F+gcoL96BFu1XSd1qQUgAtOoz037lyy1x3QKrnbhpd1+2Az5nT2WjXH0m6x/A/8dIi8XLP0gj5pCtgirIGaLLmfh8bpelwfwmAgb400jwd4TnTm78sX6AOOdeso7FmdUYcanqRtg3u3R0+IlEqj6UI21kwyUquTIalemdus1XZbN9RePX6WH54XqD598bJAqefRDw7J8q/N3WMUHuayLmg/XchL2+eO/afy2mHrskk0tVv75o5q6ug57+aJh2jQ0eElL9rexrohF1OvIoOPAETV2xQRhVTNnPEtL/k+z/v4H6mublRjwS0LNInlEFsWC9RC7yS2Y7n4hz83fb+sR/0i2fF6aKAEJEHR3CJCASqz1N7mMqYh5U9ritYWlQvdZJP5JpSg8W8OQVyopiJNF320t5HQL0JbgDmqtHPeCz5f2ASCYXhiuIRsHnlP0HIBLqCWx2hfNUqik2qDg3TZjcbiuNpdyI7ZKTdb2yAayJnq5bHPKOGKtCpIQahPQJnKPt4Yh5fuXUr2JClEMu3MDqTZmY3/5HSr6ggD3lEMWOZF8pzjTFYVaqT/mtjK8pYX0jASfgnOwwoI35jayf54AOTCA4pR3TUprVLnQ+9eXDje8EG0IMZ/ude0uFpO4q+edQ052ZbPX7ykDB4LFaihAKp+FLhELfhOHuN+MXpUaYb6M01TPL9cT2ZvOa2TGOGn1AftQVrVF7lGbhBBY8wo8PxV13gc5zEvH0wMpmgJt6tJ19668/IxOYmwjzozcSxJyjwVO3gfTBPudj/znwi+u2T5CWOAxJ74wxIRpgZjomjwbsEAm51jg0W5Ewh4li6J4ZnzIxo0Fj2Uix43IxRnQtUmM81/HjAQ4iGNHqHSdhszDIRKI/vPSkfgUM1k1dCs2j6fk9rBnWWpDKXtdOi2gtBL6wrFvz7CHawKtLP3GsfV+lzEQ/oeRcFlQ9BXVo9qW1ns9TeRrWQHsRhr6IOsiBUR+EpfRZ95NZfs3e3DjdiA3H+dPEuobqlhDJ9hNPaxYLR69XH7PFNfNMWQ37wWMBHlPI53lDlfEZDRiyZeOYSErf1v04K2tYgtgYrFibP2463tjgbrY+Rxm8dfE008p6fJ3HPMclP8MkS/JAE92KymaVgrGJ1B8Uplo3hSdCcQ6CJrAvsmuM2ErQezzNPsYZvBdwE9ePCFaBYk/YZ/Arl7LnfOiRgVA0KmSpSR5COj4U37UJM3Uk75xX4Rsb20nHKVOKmzvvoc1yuH+7eLdNqw3NPeQTxoZGw2Hr6EdE1jzuztCXaKIIh8/9t8m8UuYunl0sJ0jkUg8tP+K/JYME0fHPqjpLYH35EeqZHy4p4P/t32M0xIbtvbEceVMtv05WS7SW9MgDK4Al1eXrLTnhAUjmtOwIKV7ikOE8si4J3i5sN6uMX7nLHhMNAids1Etwq1OQ7SSVDjkXOJTio0gJJFO44XsHh0z2Xh54b+E8SclDrl5fzZIGxOHF77ujX1FCdxll5Nz7TrREbaUGKHXd9hn5V4BJEUCv5DQ3OJSIDUYbUTogGgDeft4boiFap4F2I5MjNl+phftccK9q9/PxRCAoMrUXBAhvbZytxa3uzFkIVdAZ0RQ00gpMgg2yglT6sWjGd+YwU1tj6kBiop+BijKyeMigJiZOHem6vMp8LWlv7BnKL4EJnKbaHsB9jQAKrRqp2B7SlnBw1txrR3Bk+ZKT7ZrtVTzEqemW3U1UpVlXv1RcsA1qhE4UZ4SEF3wjMONfIHcXqsfuJU/nrQP42iA/g1/VauK95LI+xrZidqt49aqMvNTqGKH8e9tQ8g3RnP0y2k7bSjs3tgUDvbX449scJdLz3R8D+B1bbg9vepZxVD7yiu2FtsdYFIecyFbbK9GzyYBqB2hx+6rQ6Nr7F/AruvjhP8l6B0xlKcOWo2q2pveR5lIBdyw3mUWERTiYbEj9b9bnfhRm6ZNy7pcH7LbcxpD9y00zsM2RSbI/rrc83uwJHVEbAL/JhC5gu4+9Ajwqe0n/Nzqr76MDn3yQG8gfoNxtjuqoge06qgMEQwXMSeSER8nzndGV3bH3CtXuUjjcPW0b+Pwk8ENgd99WokjoBhDROMF0X/oZayqMSFU55giBo9ZlUEIYHaw+F3BgOEtN3WH+9eXcAHXr3/4mNQd0CEq4oXDAJ3Z7sH9z4z358DPSpxVpFdyZWkMNIIj6CXrBrrwsG2807JVLvFjGm3pJP9w+KkCDxxgD4212vhn35QmXmOL2K6vFt51VY5BkC9H7fo34rbSc7LhdwMAw7xY4Ark9ErurkuXZIGCPOIzGsSAd4JcmgZVMTNFzf81iQL9i2cidhWuLgVfO7BG670tA6GtFohOr5vKiFH0KsqJiZFHPlrHtyUPbw2Ra2AkxhKg3GQOKPKS93eOWJbz3NhiChomyq0Vl+LqSXak9G8zVbdfNJdlbInPUoKtF/++pwNFy0cMGo5S7iM9evYYOCoPQgflw5+BP6YmyIOEDO5gaF5MeEyZqAwjUBLnyEaLwEB7mtEhOb9TDPrjlU8KaPxjes64oGYBmcgg3Rv50tkgyD1BQz7SxIIni2VUSIjkSp/gWAolqNNcxi2/sPSTur2jGtC0z8zrplZPFSgByHDP9yB9AVA2sr2wWUvJkLA9YPAeob6LE0zHVrxAQREkc45EYo4jOhttkbjGrBdG3M59G0XZ7aqYMhUCAAFQoZkCMQcwo35NqgrAjAh2pYkyk/tzZnbiT12j5gzU9RoVXYvVl+Qag/TKzUlfmxxfR48enzlrUqbM8CD3LTPBhoekj6Q9TaAuepniGR84KpMyCFf2rgPveK8YB1nKpv5q1DMFE2rbhrkCX4FY0OGc3hbstD8HjXP79mhHLj899Io5muh8Z1UVjcRuuVy2x2Y+oGDDCKOA11nX8S3Kzg2EbzDU4Fbr636ixXbbKuHCsmlBousX6tz3F6d3gDoRmCp9+lDlWs20ATJJ1Sux+NcIyQe7WWSL4/kV1PiNRuGqbNaZ0bTaDc+ZLaRb6k7YaP5ccC3niandkqHQLD/MhjsWUv1XM7c4n/LoFe+g1K8oPDn1IYs/klyS5MWtBl2xwI/Y5Nz8xpUjg7biE439iRZEY4/fXspslBTi3/bOBsk4vwjyuRzAAwClrmaC2VJhTAOPZE0nCYRVS0o2+kSVpNMSR0ys2lmBf0yYwN4y6RO1mx8ySeScho/UmdQmulgOfdiXxY0h+103K9Ttd/lwS/pMmT9ww5znsljV0guXgfQRnhZSdDhb2OiwTJpZ2UamXBuq3WYHLiH1F4t1FsFWQRdNThtVF1NbM/dqEeDy2y+8zP+NZtEAh8GgiW0UEuw71xL7UPKTS9fndt6RL/GGcu2iV7R3XZvMJYpDVFTPZW3oUZzIDIbiRZ2Hed1PSPU3RH8fkX5+p3E2+WmuaXXOGsd0GBqYUTg2hgT2KRVp1crOfWmeU3XOFrZeTQ3QWURJgZSgFTA1xEWMiPuXL4bfT7VyLZcQiQ1HSKXblE9WsaDWXcUjp0sKcx/7qnrpy7FuP714pPmJHZZK+XIeyI8ud5myfPlfpn7F4M+VJ0aEFVgzsh7mZCG/wIAC4/hdqiiWZj17MenigSYt+0PnO98ubK6iGLPtGX6+QdCDnSbVJryudMRNdqgsasWXrxTAHoYRQhAMTyYvqwsQuW/3nvwARTOY1gRP3N6o8oQk/hTXjdMmMXeFVwPn57H+MlYZJRydPhzHGaSLUxvSITuisd2vdQ4WrErvRMgndgJksv/1vUMGFBX5GoMIvYTmBm/Tzn/tW4bFrxUOsTmdVTM2SgH+Khq+Nr0eFC5NGYvQO/YHEPK27D14ZLLuat8zzkKrbnWVpyxngqZiggqX8KL2sNLkxMIpMnAKZIb/9YtNWw6MsGf8ZmJ1Yzjs0XJUnpUhHUns5baDhftumRmhW2z/X/R4paHZuoLcWp996paOYgBcM4fM9lllid9Mej1J+9dpn3Z3EM2dWRIyrIcCyNqu4+SVE/vyv0qV1CQNJhrWmkSc+ptICK/V94VJ8REnihIbKTuLzSnOINeIfenskUtLf+uWINv9aaCUN2FygpzpRnns6lePHSCe9wb7gwzRb/A1KtelM7Lctd9MnRX2znotEgL+GJvc+W92m11nYaNf/KFC/5LIuCO/GG5dEwkOO1E6r1AMRG0wAp+6iDA1V14la0KM9gLnwMam2ErPZF70phKfoEv05K8VfITlaF/mkcNF6m2AngdYXzU6XjFAPkvGCsOA8+fXRgLXY5cIpWceWukIY5xN/zajET08s+M8zsAzGfUz6p6PBKWMKFkpmrEdtUs3W8amPVblIiTy7c4UxklLmZK5RYH5IpxETnlxU1i9+vDwtxHzHRBOGTdY0p4Kp72FbAZWbvRIjXiWMjstHsfmYZGJfqJlEFwYhRcxHXTa/dm4J4YgrHDgBd/Cn0gvaHMhZdqabpv/h9bqDWorRX4bZbbsAYIiiRL1YLfPoPU6iDAsc5pM/cmRAkkoV4x4xhR59RC1ZPbzwwf7lBsaBiCCyoU4SLJllumBDexUvH8mzUD8PdY+B7RwuiBUdnrjHIuttIAzstBCAXfqieTH8qXUM0xMSRXMB/S8wIMvFsQnj9va1CSmt2zkbNB32tbB3rfgw48Ir6zeyqtJo+0Tv97eVgLUop4QLY3nJeXKYw+pRYP+MWp3PlIR8td1uUBSRsUEONcpR7wAenOMQs1zBo17qot1WcCMBAq025S002/TtO6ZfS3viSlaZs4NdqJerAbZsSdrUY3JIWcr9bJghcNhfTKAAvknAse9y2V2TFXwAKveTT4vi3vUzv1P+z4q7Of2yVgOPZGAqqV1dP80YGnl2N7/56prVd4hYTMwI0+s/j0YRAJwiN9gEYPHVlhkq1OmfT1JSKvJe42x41cCF+rmi3nu1aQPmfoJWCujoQF09+TRC5DE0615uq42cUlho1FiaPmUX+0ROKngvvEDST43Qm+K4mGCkrazuFkxdD+sC6ub5un323sHNCyKVIAihwwHYYJkzAoMul2DF0qxfeoDqMFe2/ws44pb90+zoNQ9SZR5Pj6nhm2a7933SkYzOLPoKvehaMQvTNPyrVNyD4mSCWsyGhp+9A1qqBnFGNGGDsL6pHyST4n9NbrEFKfG1aH8LHTTJTxwPrT+i1HQpM1NwzQGJLmPMFMJVqlCJLXSAitex6+uKuwdV6ONhqP7KPYjEIS9fZleTrd9iL5eIY3nvpk8AXXz+YZTiI235Q1sG9UIwI4j/+9polvErWOJclWRCNqEmYBsgJm0X3tOR73BZFAk6MIHrHJEXJvACLyLbz0+MwhYOhILtC03odACTxuW/ccTeBReTQCF+yEBZ9KS7zn5e7rHgzcV7FPDB/X1nSZ3gp/1w0eJOwFXRlhUXm5duEIY2FIaz/b1/Ixjjgj7cSyrx35F1UlURwbu/gfpDnW4bU1KUQKZjrR5FOAVqmJX60uNJbPgVDxpnalhoHu4vJff/3yVYWz6Ceu4RIP4Ro4cCFXU1bhczWQMwiHtLUEY22VhJwoMQ63HYldzhbHVoDpBfBJrQctqpZHMGgcfMIn9xTQt9459yDoSqVnw/7A1pjxTqDLUpT/zlTLM63yfzVC7iBz5lE9XkKzwns0uyxYVgF5+Wy5My7PZrMDZ/9zrmcit7MTMjUHTovOkv2R6BjwLSMavKb3/pyw+5V1aChLv6eVOB2bRO3X3OpEsISmafuZOViQSp5P+/meuiIIHWKj9H1YhCeODoSNbNdnMM4jQen/oBZW0thBOtRrsIwVcCNhEE8rmA2J2wH9zcfKn7yVBneMHCrxpoMKP620ebfcythNOdfx3+2NiIJevjVW3ML69u0KVPqcFwupjVPH2XELrNkz0idaG8jZJ1tpkOuqcXTAdTpCH5zPd62jHmFccWlRYFR5i9vyTskkeT1H+KKkOg5V3HTNQaPfjzHe+WskSVR7V5TQJ98h9rSGItVR40vujRftB25HAGPVP7MEOuRFyQyojv1T+/0rCiTBB647fi8yU1DT498aJ6VWkUBV7KigWCg47toHY4my5LLE5apDiaI5kR6ZXdIKIB31A2LFftsAih/oaz/7PWS9iPG0ltZsZUfiLhMzUNrZ1M1vz+NCSs10cJocTkjiUJy7/mQiInSUhRpSf5f/j5QZapjSj0oyY8NUlLHNA0oZ5AK4Wsr7cmmE+GHFre/1cTwbxGbCT/qlQSi3nqoBtxzN+RXhpPxxTOCdQNpkgkufawpcJOz5HXJpBQ9sgTDdK8EYPGDgMw2e3G0q4Bfx4dbt/AusEni2rJfuZjc9lh4hcjlcjwuNH++8l+ndWpQIMMYclKPyyHrWlaz4xV4QXv+zYaNzue1e5r/XBVNtfmSkfn9TKstvwGGU7xPtRSGRsHLNCCjKHHs88ohGmeAqd2iA+8ZqYoMyhqBpjRWyImvrxkTg3AsSK+gjHENY8QqCTTW74FSj7s8FRKZ2kG3JUhtQdBAfXAzzUwMmGqKdPlxCiGxyrvkWnGMkbtW9HR+2fAZRm+pMLSTotgxb/pNcyPiqGkhK+EwMDvnMsIELfTubo8GG4sdczvU0J08I4DL/2Cxho5fn7JpVAAofyUFka81xmryr4VMpv/zVSJkK6yZBerW60kCMLellJIyHkGGPySw6hYm7bpNvwi82+GA8kEkvJlFL7g2ag5rhIl3AbAc6TDYPnW2Tc5nzXBHo9X+MbDcPh4bgCGtQoL7R7gwmwcFAi8R/N/5bDC0dXiXyuuER1U6I5bjtvM3XZ/XZkbhoN7kYJVsVOt09UMcNLGg7V4kfrIpJw8kSPP2xzwDhxZRHsveskCx2eqn7QQk8CGZsbKrQVB6CFNetpCPX0n94niRDaxHtKz9MO9xHpkvJMrVRG8dfuBYStGtumlwa+Ip5qSd/OqXPX4UApEPaQq1/CfeigD/WdX3fSe2jVf6Ow1v1NZw1l98UjzUHiV5n1RhHbeJNA5VEiZ8DollWgxm/kcwUrNYwmxFf5IzoWSuxMJSuENRnHI8pes0sUmnscpbuE9etgUynWxQ4oJ/6c/l1mUumwILA6CsM9kRb+zBfJNXq1kP9KewQfHPNtM6Q8EHtu37fX+JNyk0ZQ4mjA/iDScJqgrt9lOZxtcBL5AcVwPMoo+sTadlP/uSV/4IHzCiNEQav3K8jlVCFDiEswH2AMKNy1bn6BNhU+wNoTw8FzkgDIJr3hWAB0OMy6vs334wFxj9VwlOqMcJosowp9F8JrgXCKqc+MiWHHYlnB1NLhNuuIOMjCI/ksfEZFgBzBPfcDre8RmORsvh4A1Lpb3dJQPDDajNpjsJ8DoXAeUpVabDVerzptfrwp8PKXBnXPNsTd82TomxWH1KaLVDvpVntHg4DyhVJUzB3++zgpceAhmsjTHv+84eMW4g+psieYRp01HNFowiKVaDmUggi0cuO9IOzYcqUwGJAi4EyNhL2N9N9SG1wtnXuFNoghRZIWdY3b/S8kxaJxS0Zzg1dm83RGMK7NwytQHGxTeCw8yB3uDZYL6llQg+O12vT7AtJuBWyGgXStaIAavWFKfAx7Vsq737k+CgzLSDZ6d6FVM0/QVoowPjKyVB0on6u9Xnn74U4I904OEzkRop3aZ/VJO3OtLAJapW5IAMQE6Ie2U35S1BPm4FszBMxj+3gMvBdF4xRnYH4Q4H7YCIAvY/DoxzKJDEgk0oBRYxYM4PJLEkRZNUnHOafokkggVibc2l5t4iuQo8VKyE9owxCVvPKhntoGfkwbijc6cXqKDlSoFUEqf5d5ysVs4nxc3Q/a93BK1+lvYsMqeY1kzl02jfuQYcaJIaAxGopvSZqu/oj1fF8wiNTfQZYpmrY5pvlDIEiOySks+Jk/H8kYjq6RT5LaihZFiVj6vjNPbhgZpzA1trXpeArn6hrNJAeOUIsZ2s8x182MqxJKkqXwB8xl0zIzQfSSmRToOyTcPcl33lPmYUq9dIgpALKFytX8rhS+kDc7qMKHphoBd7GcFPcinSh/fFCr6EfyQiMtJJ3eeYGFMv+uPe2Dq6n0uTix5IxNp1AIG5/WJSM5l/FHMnfCwfdtuVFhsoyhGGmQiR70evHojtKpZ8lMm+WP9iUVGoMTiUj6vd56ErR2aWAwKgSBsDbdhd87FZ/1FKAWoVjfWZU7g2AKjYBAJISfjmn5aHa2A+XXHUFL4auFqiWLDjHQEUME4uFmyQC4Rc84YR6tKH7f8w/eKpEK3PJLMudrSDpX1dgcaiAYu660kWa18kyFS1oJ9CASsAYMscEG+SjgcS9ZakckOUKJsruMaBOSaMz+bB7MvsHkE8qN7gmHiwYUvqefZ+zQbTWXMtH69+C2RKvX5w+x5aEt7Kvha/HP/uRPDpBuqOQSpEDY5DbhNJ9Js1Ner4aiZmNfZcIpMW9izzxyBY6fcEpFJ2BSw5ibM9KQgpi/6ID/LlpFQnh+/LbCLTRgohExDQSitYMUFzwf+kaCKVJCTruIjpxFapKQGhnhFBvM5syFKYnZgQ3sezhLjKF+64GmlVtLOiETt2utBsE2iPKGls7lrCoC+NSRoMP6bmsTPn3Uebdf6YVwMPq7fP7FRqJwk7F1JKt7OZ9po0pyUmlcny43XorgndUQ4iM/r6GtK6dmuN3PwFLuE3adC1Bg1PrcQow42qLStUdap0h58abm2LbW+wyQ1VZN5C3r6yN4HtCxBzhPrwM6qWnlBsqtRpdlWCBtfSV5GMk7xVGCG62+AE3EsHZYu0FgSG4QlnQ/9zV3quIPT/yb1WOaVgV+C5Mq4rkAw7zy6hNy/wt+g+2VZz1chWi/61ntcnUm6CzwrlJSAXP/zDkdXaixr3Qtl4+e02e9fgJKBROSbm57G2quwTzjVbhNoreWL9OUZXDsLL012s0Ks78eO0Jp1pcDTCKiEqdMmprvZMAbJXpm2067yJxZnVjKUoPYzrT0CvzqktpkNwv3oKAq6mQPKUtUIzyiF9Ia7p8bfzCUUX0kOjtCOq/qrkHwYX1KaQ2lhBmejnWsiKLASpS+Pb8shSaPgnRrq50K0hNnTt/S6twZpsfNxMxpSIw604hj4OGoBGlj/1dTLEF37DDPIw7G9hhv2haqgbz9nQwFUycSROimatSvPNm9MFgLeUrEdjzJs2Y5DUM/iBL7Yh7L+VPJW45kAfs6NaleBgW6e+5sqd6/lpCb6Ggxupbcq8PaBWipciGxGZ7V0s4i8LYnvxVUdOcAAgya0bxQ7lvXGqJAanISoEBTXKv4nQSYYwuCBcq/X6z99EIczZe7VIdWp1+PmHaclN0qIf4LvVFMqotfCIrLvM6h38EXO+APU5ikNRsxs9Tp/IS3Fm572Rv/kaphA9xtw3lRoUWzs4Pjb7T4z0uQZenMsST3YmKVnVXiasGtgZpcVvweetYIaSWA5c50Ydd/982vDrL4pN3u+yk18QWqrfCJ/yB2TQBfCFJbgPiAZ0zEZh4FPGlFdfg+2myhBnBAVWz0SYyvJ96DlVNCFCDn2FZrkhs03R5xnXAdLC1lBH8Ag/xU2qmf2d4asvzXgJ4bgZJfdcAlnKQa06IYtkKJFCT7Skhot7RcjhwBOfWQhmkNK4p1wtV8yXdjBeTbxoJjJc0K83NGL1WWbnbfji+ORGGo/ak5KJDCPk3NAjVg+JyuuQYU37EA5V8hzJHK4M9KNk0uFCSnxP2gXvV7E/69LzAOfEkDRGOYop2XWSa3D/bcPLcNMlWgBDVNrSR7cMuObt64JcXl04jGDQse/Cmh5nXfjCFfhFdcSenLWBCwjeHP6noZ+8LYpZ+e4IkOkocPN96AF5juA3OhChL+tM6FDCMDuOxveSvsiJ+ZIJu9iRmfah/2wMIEv65wQfPxDtQg6xwNdiMO/w6WGaZrrIVWHh6HJI+cGTOmgq5TJH+rMZ/VBXLtKPkvfjp859FW7Nv496N30HgXSxu65dADPW/N42dKwNglbwu40yG5aSTCKfbEr2pEv92CZavfWXc/kvNhvvOvSe2u/3qtcyDYpoC6c0+/QRa/el0BtTPYjDpFX4QlQA6zk1Tzzak92HFh3mB8tlIZ2DQJvqPYzax2P4V82CjmcTFM7ytJVRS9g01dgBF2rzSvePvCmHrY9BUkFR7SrSCPGnZXaTMFG/a4lsruPYjRdKHHOyse0jY5Cr1Du4StVlldGSCa9bGRynrmQBcSpDMqXZ4WGgDdFsaGKx77NjidKREvvwgqZQAvKuhSAHwQ4/2ny3eEYeSBri3ZfyRoQP0c736vbSMMo14aQLJtouOJIUDiV4QQNIGp4znzqNZHshIUYle+abBL+kV5yYuih9MjyeJZ/RZVnf1cr3k7oLHHN6ixRBHvOsdMyDvKcIFf3XiFbfv6G9rdM6o3uK6zm1qvhMzL03kxF16Pr1YaSJm66KBekS3giqxD0G9Qpp1hslChQCPT+Qt7Ih6voGVVa8yfaUiOeJ3Hb9WhuYaUu11gS8grWuZgKWX1IVAt2uMOl5DQB3J1LgOzuYPobhUOi/+JXcHd6l38Y0rsu6w7/DqCvpOBKeR6HmCuqJ2vJDHhatZ3IW0JI+DV7deKr5ZmLYYs+i2gpoWTl2ohwG5wsRxY3roFykwBqrmjBkadWV2k4GpUv3syfvKPKD6OjNoocvBXuwwpfKconOk7cW65Js8rKYza2S0BEBkBX18jsyankJ1APoOL0sE5PrOlI34Q+4+K4d32y8aEg8o/iDSS617qCHtRQ4bWZyHbs9wIakkZ0qEeAqun7PRUBCDYAzPSwZL35xjanZTk2Sl/0ObA9HmbkpJPZSE7A1gsM7T4uPEBNPDbbsVjF4pYTRBUgAQpXCgSSuG4tDvckndkkYHp566KSLYEPYzYzWgSS9suxq0i3Cg90ZpHUHbhU/jqLGXinJ1puz6na78O32ngsPVgE9McDC/t3g1KfPrQEXaEn7gQmYDvBjUjzuIC13CC4xN3wZ/6oMnBhCFye0YMJOC2kZikQ0n3ccgEMsuJLWPGJ45VRJom6RqMb25stgVG9FvC9UESbNRqx7/ljpMUo0aK9xeBjc1eaFktaazHG/CQlwesX/yV80HErYQK5n9ySeJB1rpeA480g+yeCONdLZtRcL8o/AUS3VUtNS1iBht3wQCk0LXIXJu+xJtKyowRAV7v0z78uc4bCtAErxagEtT2bEBu+J+uc3NmKoNJE6z6eRuwOcwiqtJq+HW/HBtSEO8I/+UoIal3xwgmloTPbG7kUVuDnMx+1pB5k9z2iKXUO2+pbNxZzUkt5b2MLWdiaGEWjvw6THzShxijDPpGrc+94ov58FvFivvF1dWV7YvNLaZObmjhtVqTbpZs7GsmVslQd5cwV9tcvki5XQs/CEu7vUpsWrxunmLoOwEWIOgQUPFA9Kgs+Hz/7K7zC8mczRwgtBQAekEFcOrlXrxZtX5xx4dbEgTI0stdDUz/7AFLOKq+sjVKTMOX5k18O9/fxJgHwhMq7rdcx0mxy/GGcTgalfHKGBPe6/RN66Gpf/rPabW4KSbbDuol5gzSKjLYxAIpDtyKzSZbrEE9H4V75VaS+RmKA6q70TqnA56sG+JGL0POsD3NQMCAW3EnzPb93x0MpsER0zIa3Qaoootrcbsos1bu25Y4TduCR9rjotzyV0mlvkS5RbIc5h7GuWh0YEW4sAv9MqeF1T8J8EjC/m2BmIDHjL9YnxiTtx+5mG7RWmOKFuccGnkTVgJRlNtadZ5YXl0wAetOAE+ONF22ShWP3gPojzPy72W9pBwW4yEABjD2JIRAVHGhirc6/uBzbS1guwVxxx4OCmL/q3UsIEygf951NAvBtPcuBPCoHj+Un5C+YvlF/pVn3+/u66RJPjUBa4HoOeCJPKCKFn/I781rmYleOsRA1fvRCc/4tXH5AxqLX0eB+15A1J4t0dVXFVCkqOQ4H3chrioeHXa8yL1OoWw2lpC6YJ69VYEZ1HBMsb2KqnNDOtPSaO86KPVx0y4XtRRZCyCE7xUr2xLHyiPS6ROIL2UJfL04uBTssTsv6dMeG1/AvV18zc5zyZSruEoOBPPGnzHMeHDcBZpWo249hFZOqyygAJtH7eY2kb6SObXbAzI29TjBaPaDTDBLigGQz3Fjz4JoxF5VVkmTGfVCQc5X+bt7ErSkyzrQ3tRJ6o3WCfVElTb23YBL7MLEewhdlWPsKLp/wghrkEWw3pxJ/iJbVN9YEgsF3cV64FoFytGZXVKb1/dWn6zXmI3oBYqLoqu3/sVLV834VZgoc4hxoCF9NQgAfYZx+G+jfxzbMMm9YnWcXO8ctmLzFWrQFXPTIQUx92LrSnzgPCxmI78CWcbGjDK76lYZD6/E3JIJnAXCh3wyYc8wnOlwYeOcWniHa3xyzUkGb5T6NFQb1P78jJPzxTqN9MxC0wDj5nnfpOKN6Hqlk7YF1/JCkO3nuBZQY0kM+cSnULdou5Kymdj2KUB0NctqHq0rMAYk+XtKIzVp+mL5dbtfkQj7vfkch489G/ENQvev1QaWWVtVNjMxoSCBqMw8ssFrPfdCWCYihYhBdlU/N0XRv99xRNab9c5kxTtStIK5v1PUswFDGu00eb8ixNaiD33xChJ8Q9cbxWC1e9eETegziIhr3y/yAIvwBoqmwCcVtlnN4uEH92ZeMRhKDg9+txqtgy8saSuVA5+3I6pzVG/mB2Q/QkX0/R/WzOuNgD0QQiUyJRBCBYyWNtf2n1ONl2zMd7ElTL1NXz/o/Q0PBHXebN2hPrJC4Iu2kiO/kwJtBblXZ3AtpiDHMqDg/XebDP56+EL0ZNNO4Qwg0dNzHUFUXtMFjXS0CsElRUfk49hYtBLRmky+dEsWQ7qH05XV1tPx2sTuJmZ2XyVG2eU3/hOYD7DuxV6siOpfCJwZi9BQkbYhUbQxndDmaZ3JpvVxoCcPNS74RZ1+KO+kYrMAXThJ2Boz9K79alRuiv7w4XLnHAUMqsHdQbHVHmP7XzOPHdNz4TZa2vLSBNXmF1SR+i2+WgpNDWkhRfJYwMnwXF7Q88iXCq7nR+ZIc/fNoOJjQyRXbfDFROEOyYU80hQgH15DZe8TLp2GZE6KYobiMfdqG8Wq1tnLSocwhXNK4mwis9EIsQolGspN1e+EoCsBMjdoKKbSGGIzzmyMKNNh9J7ov2wLMeYC2VJlA8OoweaPQF2fpcYNRPROgqImwOowbD7iP0X3DOSb63TNOcRcZUz1hi7KU5l9iirxU9cYZNNXFGhwPgMVKvUqfCOD8T60AbYOpBEdaLCLGjRwG9bRj1FbDuBU70S+4e88vtQoL/1bMI7j+6GZO/eaSeWglH+G4TcK4/zogbfmT8JhwQJv+YF7xVTEp6EiwwXYab5Gk1NWEo4naDn24go+C9TU2sSpJNq+DxrmuPAr4ssHVw1a6jAY+cqstZnlO3+Na712nHfSsTG3pee+KtxqkP0zGeL7voHuHZk5aSIIqlsy00CMRv1kSxTSDOLiYvfgzzEvFr24DhMJDYrrlO9lNZ8LnSmgS9Z+EGFGAnCFFM+ur9VYLcTzJsnKtvy0BBIYWLyZiwb7R9GIrsvvFmOmDDoS86Tx2nPAfTxY/V1EXZmZC7Jx6xaSQsCSEFoCe99WvLCfTMgqCYPOgghcet9MjV/Mi5mljE9ZyEO75zgiFirZg8xRMj3dCjpcJEPIK/mArvdpRelECw2Zs83V9soRUYUh2tOyi21IQJ5eqOt0PclRpyuSmHNGbNXm8/IyMK9hC4XZ62WNitOdpdTMZsTDa/Pn/+MeIeLOlI/VQenw9R0D99gt1OIBDbWy1PygQLJEz2T5o1UytJdKhN8eHZ0A+4GAk11j0Sgya7JXjux34Oxo55IPv3nOS2keejsyIOZ3JadAVia176IXnPrxkAYtSNtHq+Yax7DGzetrm9mhaSjnZ45gHQUYrO6V5/HRY5krcAYsflPPSUgh35cnIAmMorD6ufWSyB8Zxf3d5IQSLX3m2aDS5wr/vyKkrUyf98hbh2CT9Qi88Ph7Nhrr+5D72X5/5JSWRu/GlJtPXa0yumAee5H0Ww5EOqeSb40/BRgky2B1ieGkYXxWYwWWpdORgHxFyS+Z/Gh5VYhZRer+zF1V1c0rByrY6IBGlN6P84XSi2MVBKhiMvfHcnhgi9yOuhg09cuq0O5JWtvtdKL0MvGfFkME5QTq8z3O75AxMl8NlWa2ejVzOlWMU9MLZ7QJNz9CYRJWGV41BwuMuKaBcvsiiAm17Fam3i8RMWvl3Kch5uZt9puaCxbZKqciCc0SvKFp9juICWBD6nTfU97vzEfPDsGrqCt1U0/mjoeDP9WgOYYMV01g1/GXVBewtDRe30BbJ3PpEnOvk++GNaw8iPz2yOGxh54sLYR3/xWn5OJ0C/RDLqej/QJpplWXM+/E022Yk96wbUe5K7ywahJROqzWOHv/PD3QxDlQWehYUcA2aLX3XDB8ZFp8J1EE7B5cT2HIIFmSamFZgXP1sLkS26jvoy1ksufCwHbWzwP2eJAEjepRTM3XNiDPj8u+oX9ebrLAoBb3r9b1LL59+Aq4jVLP4naK8B41tIQMeIJHqc3vOUWGIkSOCIS+tGYjwxr7PmRa1XpeoM/s1sGB3xxkmpmKO0PNawiv68psNTUhkXQTpDrXE0bMcUr0Q8+vJU65M7YyXYJiFeBNvp1u0C5UQzP28t3q/oYoJWzNz7CjSpciOf4rkwDaSxk07iFKKv0j72XQjIzUCDsDmeDPQLjYeOnsqvHRNwhPR03rhonw2Jpn/5m2Q9PFz0MGoSDpexsIYp8spumV0D1qPlIvzSjNzQ128aQLjurB+NdQ4vPNbmXZWSJ6sEVXqVa0ADQW5x76oFtxhzB6DYyE1KBnW+qFxTHuXwI4kV1CFbAz2p7LY5Oe4ZX+OIcIzcan6JVlO0DBxaQlSXyL7VSmUZn7uY8bMiQ7B+BSmW+BJ0ft7U8j+kmkwykbSUPbQyWJc4oTwyYIpPradHqtwYxZv13qmFCFgfS9FaGNbzm6L1Pzgotr99CHv6BopHNeshG0hOXSYBKhTDtDeS/6oxGfYuhANdXvPg8yiqhQE/uWqynBQ4KVNfGa++nC/1l78+2yjrlK7z/YMOAa0AiQpL1xYes1iXAOYajqFL/M/RkOXAB/f2YdwqjsBvqCto4V1k/AFWdkJTmUqjAOcbFNd9g144Uv76UtzOePn8nObp2dMCJmvNr4QKk0oHKgYQPvYA3nqe9PNnC1MKa8G6LAoPe0za+SXbdPP+vkUbpFoMkkNXYAHBAz9n5OjCpixvwZVDnwJLLX6nskh3fNrA+oQanUa/JW/jeRK6zxbb/ZcNM8QZlGWwapNFbvY0tUyMlQaJqI/a5S1hMPsnroe21nCZXY2Bjbb71bb3wVdLb1wRt/zbo1UAHCNSolZW7nCBmUe+UiIddXpiWHUMEn1p/bwzqUE+B7YxpkxpzZ6SSP5HwQRNFs06hfXn5ffdGzALWED08cGLVY6KGQ8Mge1Zm2mksWvwLonZs4xRUrAztZ9bC3f2IR89bP1FGj66T+bf4eQyG9PnrFATvM0gz5987fD3zIBdHqykCP55QZ9ZBL2KGzhO/2kYDf/c5TjFfZjtaqPHkk1tTs2j4Q0xXimIUMnexLD9FwrtS24011FYvi4H1q3SX5AwmMtdX9pnPBld6UsD0HwkjqACYYHNzqodDs0oxOTZT2jqk/HNuKgb6WHKer5QDYVIidgNyd9PxT47LctrzkrkP5sNIW8ndD+3hwnZxjipYHH8PldVJmohr5tld338+lGps+/9oWgWCoFPZwoZwwxl1ZJcb3k0KwW2qIrnsi8FPD0r5bxPVebciwVlIG8bpQsBJamZ/PqYnil2clD7KZQEQtYybmVwna8J5mLpe16CDpfqi89mzgmp8UC+fCUr2JDL5Dc3ldSrCBrfQvL6y7j/yCPliqR/FZWodf8cc+kIybsOQykbYLGnF6RUojEL5V3A0iva+bEDJTpTi0qX964iaDHV3pqMziCSu6EA4xvmgCEpfwpFFuQ1350qJLEWKHuUcShJDkE53jAzl/q/wOpRBqUmr/Swfn3mYaVmPa4sXia/nMKPov6pOUT5MN2a1dnfsTAws7txdNBKx3i/kyPZ9NsvD6iCyTz2d3frr1evQPk1A7axjxrV0eE04IUUyx9SvfVdq4AdFcFkXZ/UFyZnws/zYF5lKIgLXWBAWMuWMkToAc+YsmqvItwg48L9IB7XiVgIw7fcmSJ0l5FAxU0kPzgok+xG1UbjSRt07Q74zIRKueNP4VLgPDjfdnJ5wEQfSV6IaQO73zEupfCQnRNiQ/7bmpWZWQeJE3AALK9vLiCORjVUuXy2tXOHPEk0TDV5Itp+L6u/skHLvyby5SfCkHvfYF3PwQRn1kRLZljrGOqZY3N4IAhn0Cprix6kv32sOyJtRzGzgeJJXpwNUqO2EgAJCjvRyaVgfTCXjLF6bZTnVIa8djUh8eTIN20YmwCxHQ0tRn6ezmytgOU6LDGavGPxr6FkwSDimdO1XZZoMpiWdorvMzni+SoB5jFedsqa1GPKcdIENwI/g/wZl0IIJmh14FG/HihIyyQZ7fKXcUpddso8tm6hyg0VqC/bNuCS5qoHziLUMU42gpmkk3P0teiswpFkprEEmcP3OcOM666JA82IsdyGmih5muf+aXooQuoQh4fv6z4TC9PsRy6wZOC9VxdaKmtMaKRsZ2DUfiS/SBDk85uXbMixF0uVgA0CvvgE3xiPO2kp3c9Lm7ZZjlXkYBLHH31H6+APC5HEx3S1BRJ3p6C+w7eNa+bMOqpcpBtnV19FF660X5RCEPMfR5h8FZfKCwZK8wot1oYIAvG2O90me1of3t1rjQwQEtx/XIjhKkK2JR2/4/UpKiXn2HSE2WlBZIsVyW1xrG+0g+YHFR6iMKh5hXcciWiF2jZr64uXrlpppNg1GNtFf6qnsJ1M4KqWJJqFHahMhdbbdU9U4sG61J83VpM8dmDfwQ0oJ4j8+bUC7Itl616Rg04aDSaNbpo+RxzsR/xaEdgNzbX05Nw3pyNK8RxojLFuKD9n9UspvQNH52FEMkEfiRkGqG33Ayvuy1aHhy+jSPl8VZie3D1YVojncmVrAMOBdtdfeO1zW7d6h5x9Q5RpnM6iIcY7SHi/HV/yoB2xflI7OnhsYDNKLum58eyR/ncO00VSxCzTNjZ6GYRjYKNECDKY2Urvu2XM9Tk6WPWuBviPhImtgNPtqM+5Ik2j6xa46n/GrBP72sdDwUSRWRpn5X2AV8XKAJe5KME8xfrZByqO/Yv3sRthBTo2GWQWXqd415I5RwStTMcV2v4Y9xgHJNWo9ka+zpCyYDZyGRpD+A5Yz8APsZ8okOps0nQojr2/kOg362UjReewxVMxbHtbUiNfdA/x5NZ8qELManAIo7fIKzyTR8T4F29CCLzj1aCsCO40DfWsDoNsmjjpf8HlHXO53vo4MWJ6qB9djx2z/q9biB/cCElYHrJ+pQrVdGqslL0qH6xanaju/oX5oxN+ORnJWUjvFRMR6DWh61dvStXxCuwr2H3AUZ6EN0YxWcnvssMdObWeVHwqOWOqRfszBfVp+Hogae6vPhBFMmnhzY/SYnlzvd/PoqPX8Ch8LvCYX1BWEriS4bxxQV/HKwrZyLWozL1kl2x2A6nXKBY6ENh9HC6Ku6nsbfNgwbh5/sHNXt5ZVk0ggihg2X3PhMgYFXqHGy/DM3aZq6hrqVNVbvrAwxkTj0UoLLKJVUOJVkKKoW5vSPDkeATSgwg6DLtFNKPX2DC6qujtkHHYJnps8zfX0nqwjDTzRUTrMY+gxZsfaNuvN4XoyspjUzVwFxHUrWUZTCLKg8XuWf+29fvbUHy9bOaswUzcElIlCPvuABJyrDVOpJNOEOkEYMkInlxaJCvZT/ZHY3NRnbspaRCxGkbVbYcMrkkZTqPPkfbS4mM4gZzlZa0po0N4clKfUREbdiMqQWZJpKNaigvsAxA1qqy8cLTuaaWudgEFhmdVX+3oB+QnZaOtbfXgaok77QhMhYrPny3ObuJUBeqnN3t5U43PmrkAN+CmE+8aK3hj2XVFJyBg4RrDa4Hij6B0KeqLgKGVHHNEI0E0MpGhNwIfqN7Z3me1OFtR1tJqrUoW94ksQtc4sZU0zlkn0+WkSmABVHHVGt9xxH3kXd4fQLqj/jLxwZvmsQrhnbXY7Dr74oIixtqLXm7Qi/aUcMPYdP3z9WoiryTQyfjQId0+k8VlyYQ1JY+yRsOqcACrDxdBuxdD3ifvZPzBoTlCIGFQcCuKJC6LOw2pafzdWbGAvWRWXmH9aQwQMq06AZG8o8u7//nm9rJm1DKEAxdfAN8UO0sr0McZ1GQlN9Tx+uOR/YXQ/libOoF17R2Rzg0afShRk93ev5YROLqfq13K0853Dv+xyq+1hd7k9smk0qqKGuwxFWvaBVFV+wDqaYOmTQ7bokeVoNxyUVDluju+KY5DHCyfCPFVUtRN6PVyYYMiwfHu5IZFMgx1BDyqOpdK39FE/9h9mD6thgVyu7xeWGglzypJRNayJ6oWdd+ccR82+bBayEWW7jmMJKwBmRcmsKSxDPSS6uMCpGxjsLrTsD1lFaUUHIBevQrdJCma/wNrypkoZBzQkM9xyCauf0sVmRp0/wj3nfhkVYxDVgAUbpqAlSIyAZtyaIWDr6f4030P0WxUYmGFzoPWukyg2g1+GwZk0knh1gKfHrmY8T29Z7AoTQ5COX4wwVZZA4gL1bppmiyv+uRUc4hSkVXmekCxk+tY79tpPXoIR1CA110mY/DlA72t4lpeQOtZY3+aGRZTjj4ZoUMb79qXvJMayBS3TziSnwrQjrcYpbnFIOL47Lo+DZOyLvZKsOdR/J7euDlInYNrjghMKmmTBg15vi+YW1kgtbXQ0yj9H07N8aJMlvOnFYWsJ2DwoXaZVPhc9LPjWb3Luk9/qdgh8mMVhO4KwqO9S/SskYF+RhUOhPvPBTJyiInBkatkgkSgwrgfaD8TvIGSbwr4KNzx6XzyW4TxJ17pJYxyJIzHZKJCeqLLTKGEif4AbAR1Sx0dN4xsXFGq2RSIF6UT7Lq2AQcwLA1dTT2A2ais9XHqDRsV8p64QOYRmbeg3vJqSvjbois19h6E7hquUUpBuc5CDhCvFYaD1BJ91tQ7/Z2Dw0XpLHNyCgQFIu7lG2stTVIkGbsm5fIf1jk77ZvAM32NGKWHBwEGJyszfcPwbVvYKdrfz8oT+5wME3gNJ2rQy7GHb40rgJuSp1b2qaZ479rex00YX6yvjtwVv0IL4YwanTr0L7wcxmkDMeItZaRpuqt76TS1pprKt+ajP7bAMMbI72LGA9HG8+VyhWzGV7JJzYFR0LqDTU7ca2WlUhCGmT/6NGeB6fcURMWj+4XRDcCQlQqYbJWS5RjtoulhzHYjZp9rn2AQCaCxUJ7eLkNaXC1zAyi3aOHlSSwn1mPYNMZMsW5vTFcGX6P3536oPpGPSynLg9VOAPXKBWn+rY9hereOiwB4tv7dPmEDE0vV6654wi98bUturfwTSbGNF7AcT4MzUoH18dIciK+xDJDXBFXkidpQ2Xi90Lajt1L8LdKuuyyTz+99M45H+j17GglOWsWsT6gtnwlNkKnOutA0NiQQ18jkReWccbmesSt6HFe7N6Q7BJTyamrhJwkx0XffOdwbc1XnmyHMGAYtRTggIkH+hELcqQOGfvMGLSSnsdmssuKAE0J/J5qaOKkjpOHgx8TwF2bXa4go3Ao43+doyTkYp3z35knJXCeHSoLSDEJHdyfueIaUKCviUz9k8NQIaT0dScxr6c+oGTICimLe1GsLQ6tbfNbeE0tnFmiHj3kxOHeFwnn/SMKJPRL185IhtxwoXByjKk9r8Qc/VuiCvxDLxJ0pNXnAot24dZC5iidKnMo9kafoePNBuUuQtP5b+vyK1lj6zJzl0YMlZBepM69SyMqV2JbPp/qVpuIhMSjw6tQlY2eJmM5Cx9pIOWZOL9IvyqCFaVfa2cPaPcMjD03mitnn26cOvGPGQ/TkirCYyzUhuq1n3B+IadxgJt1jAiwxFZ+2jIgKUAvGS6wC4gbl/M5auowZzRVPQd7I8xhqIB3EUFRQwjA+PWgjReI3MK5m6DEIdUWSWYDt7f/U8CcG4YKj9L/zdh/G3sIkObUDyXc/mfeBW3daTTbxsXhKjgmMicvA50o346H8vku5uN7zpdi2LwGJSnJCH2Cx5Qq0xwA+g/PJH7n6/SOzbQnidM7mV67saayJgIgLwo8mIIBocJ0tVOrLksSYQHZnVBorHOBmGkNjQ7N34qkr4ST/1kHltwsNu1Wbuz6DxcqlTKFA3wmA1GgzXusDWrlCOwO3/niFRPsfE/xEWBp/PBm+u4CH9bdbqROl58YN2mkevR9Zk8IpMLn2QjAtNLL9dk4+7Wm6tLd5wEgO5QJLhv7tbQY1LhCzFfSUIZbos68sSCH2SFimGxpwMnLzGp1GxnPiWS2r0xsUl7GpGoMsFzIQ1JRkctE8+TfORAdwov9I1BnkchtgwAXefF6dkFXt7nVuG+lI1/Oiegs3Bz/vz7eUtTDvVHrdwMVCIFqk0M31oS70o4vYQyBt3t0tiOR4HuqcVzHvyiVFI3KyFc9Xx0VQqegsTFqE7IQgwcaDqjn8a9OA1Zbj7RkTqP+zyZjcKoyTu4xtL8Ihwu+K+raTFNfMqFPDFSCgtH+7lLZ/CbaQ7fiG6jK3vZPoUcgcdrASY2MAi3Vzu2IdG0etPAWWTcEZTCIfiUqcf8/e2cNMRuuVtMImR42/K00AqQGV8fBUCnf+O/JW8Q6/onrrUPUBSLr1jiExP0U3DAz4hE/owRygMca5jZmXEUDes1JdSUMXH6yeKc4G/YWfJQ2wvznhlMhGojZnpE2L7Y4Sl46H8q42ZGKE5GYVvE2uFWfzmD3D/HyH3fy98IkB7y5NIEba1+NqcZd8OFUkRYcKSeMue7acNumu0DSBFegadoOVa25CxcDBTZDZiSAENq+4B8un8bnHBL6i+DSOcSTtXD4qijRjsWne7oc+0i0nXLvwwHxAAM4A9a/Nsql2WM6NXqK0KO+dQQsnXnRNAvb7xbmtppX9gDlJeK1aMJUcK5dYYWAzIpWhtI9boKNKvlHmQneMrbi6ElbLTY+s+9bAsAnSK108BHeai0JFay4PYkxGUNEdC93ZPman7UCmrAXw+CRaJw6gT8blHHcRescJ7VJQNbo5XtDzHLeBLJGf5JZQCD3uIrajs0ucRowpdtpwH69dQhtGw8q4UjFvmevbPi1ZtXxpC+KXniVd5zOj8noAKT/30qhBn/RyIV5Pn1FWbFoiMZKiUK0XHjYhZQxMQOCeV/99N4iP2T9Uk5T04yOmzAoFN3kC4BcR59+BvQ2NmNcX5t5hRYK9WeYQElbm3wX1aLz6TyPMIHglVHWccSXUMPdHfTn57qbpkgXPvJArDK+M7M62kgCSuS/u/B7LKrxgWVPgcq23TQvjeCfmtw8n0eWJ2VmkH9iJUhH0q0bN1zDWwj7DvXgpQ/Z+XKaXNG4gg9j4xW5KFSNQzx4g3p5i2FYsKgyuxijT9TH3xWvnfIyBdpvt3dv2BB9xysSRAVNYeS2e5ndMweM3e5ztJHKUUWuf+I/p25FQ74I5IpjRv5rNJTVMNTy0VRcQaETps2CWufgH2AAFXa3ko4eoHpR1ei9fIC7ofNuFWU2XOP791osock1bm/ZJ6f42a/TqKh+VoLwUP0QGMRZRS0g7fcQKjEz0oCpMxI+HFpa22AdqW2WrHJWxsPgOYSxzGAVdcuDtJs2sGgZUkX6OjgR8Eq5OrcmuTCIVpGSf6Q7zrxUFMqH6mlhSQCkBmdjQYtYNx1sGRqVc8lDTv6NpBivm3G+dbIKjTEdR58yykaBOjsMdl80rkqxUi9Dq9Axzsd7HrIvsZ+gym8xUzyWps5nPQyMiuNw84WV53YKAqCXp7rfH+RGwdlQ4+vEnGX2/mfSmdn1j8Du+VnZEfpcNR0Y1/GwPlAiwC1Xy6A9qGbxZuLUEL53phkmZbHcRGmxa3blznc73D2R7TUBqvKzGgPsXVxOvgUambj8775LOw4Zh0kPPfjJlF1tL+sFdo9fsQ5euxQNj3TniqEAn01pvYGn58Q3V1SZFWktSa/ddv0S3WlIfYXUPCY9uFkwRulhYwo4OF0OoBc5onN4ILsiA2f5bJclHcdChYE2D4btwUCt0933H7yUirlFRo16vg/K6nApyyhXGYNIazya8GDMXqtKc17W+1ZGP2H3C26fbM1eFf+ZE/xCq60NJP5/tx/ikKFkcG4vPLhsd5KNOZ+hna6dfe+97p25+JLbxgH5j8mvMC+c+5nKvqcwnCVy4vY/zKxyuGu9WnVb+qrp+h6drXKYQ0Jn0baJyahDHTja6MLHCukQcSsJnUkRr7XBnko/xHf9XPrhH86Q00hguJF0T4ohH2OxofPTxaLgaP1ejygaYKGUBDst6bw0hDm3oL891bvn8LywGiCJzFbatokpEV9nE6zzZE8jL9HSJFwFnOQwFgEssvfzGuxIL5AFhhXgkfaEi7zFp5BgCJ9fR4Vq3wqhqzt3Lf45/ON+/nzaPxSME8K4RjNEnD/CIq+mrZ2rbTmq/1jTD1B9f3NQQmqWneMdLNBY34rwOJ4px74tXaMUVCFGy+UmbElSHrjq+BQtwPs+c40DND2GAVmPlNY2DrEH6Vts0PCNPJgwYi4iOn6uAhYxY2W5ZCuF4coOLW5HT8DgwE8bIq75aDDzxAAb/LWvldi5v4cruafWE9Rm4vUSxIWrVHRh4pkf84k9tSduWKlwwC3dwj/LdntUN40QcTTnxrlh1GcCP26h6OmTbMF4jrF6pjhAms7+cH26RWePBVxsM6l7llufPJZgiZmEyiS9Bn92bGCr3zoT4oYbklavH8VxCLLxRKTDkp++zLMqFPaaJl2XbB1pp+2eHZJB0Vu5Uh6r7ljyZt6zHbTpRu+ajERaxMeXRMUjtHXAtokzc/XAkjNqhSCl0ZdtYGWRJkynNBc739accfR3MxHNc4x2b4OpqsXatUFqaRDQULQN/clgHJzjg6aHSmhdrvyCB2+ZhvmaTLoukT2q98IIiMYZpDoNzv/qFp4wYZ37bFcuilnCAY21nPNIY5lY81PzDXSYwovhiOpxmVFAcshMR20qyc1SM9rzKcWVenQO9QUBgywEA+c/0OLKgMdIBG9d2/DJ+6QwLDGh9DNmNnVmjPEIvQoWxFpOlaiOSMpM6pJq0M9BuDRD1POqGOe2Df7tn2UGxdOG98XlIpllzmhNZUwS6QQufEtWt9q10DV13yPIyfiYwvPPCFGJMs3o1fgyEtqkweYDBQmNn3o6fke5yf+v3eyxgI6uVJvTKusvWIvdQM4iiIL0mTCGsVLus+IfT/K5dK9gv341f1QJnzsfFvvKsLiOYUCRUzuDNPu4Z++4ywISOL0nczqNSNrLlWKrWaEf/vs4hFhFw0WMggKcSurmOeg/krAJ5JRqdElkBT0nrUX20B8lOXipNJgGv8gCqfaBf2sgaMClo19wxwtwPWzdac2bTS2SIIot3qH+LqVGfItkixkQdKtP1GBaCUFbJulZEEko5u3A0rIJ4uXEwy1Vo0AWEBYPUkAyVeeYFQisqAbLe6dw0p44quTIKUIixL81udXBV4S3VpTziLK2TbjkiO0dXWgjJ+RY/LLBzGmhQOkBdcYh37qot0PKxz5nCALaJ1qcuRmNfvtwXiJP1PQUXxrqvFWo0fGqQnU7G226Hd4rbA6fH2CJzgdlJGVqa6k8gq43ff0QYNIgoUgS99wMx53J/Pu3zebIZy7okIo/5gUZ1Amxa8e7VIajTkGBdUhD+OsklUHBj+QI3POLL2hvJH0iS2AYRauFwZe4dxITjpStpX3t7KqYfBlNaiYlKNC1LgGDG8quWvweWb1zwF/Tuf5PLd8pZ3Khkl4+EwAuObfKWCyOeJBL9l4OdoQxikFgpaptexNSrfH45EzOZaWKGBVIIixCEuDNIqi2X8zX+ageyUos8EobWG6VQpt82LDi7WxOqmncAmRKcFTFjU879cZiVi384b60lh8Ju7G4ipt4mvQph7PMC8DiZrV7wkLKSZaBd7jjbCw1qfWY2YLLp0Nn2PQ5pgB/lHJbkCU1f85grAAqaVaEOoSj65ntEoizWl+5tsRSomEfosnH7IA/WXzaPGknCn4Z99d0gZhJrBN2JJQ8K5kOTSKcD1QmnkrB5E6HOG9xLaRzFE+bULBln0ROBehDokZd8l5iV8zorZVXQJ6nugrrwY0pTcHUynI2DD4jvHaAOjpxNZxPkdvxit8c3jte54U6jggG2zvyO1X1hZbQHNyBKtvLvO1aeX3OfgRvMM5cZQ3W9bAPEtWGzBbsZ+Z1aVnbkPRH2HUkxBULXp0Rnql3VFIqIrMjFKkn1OgnXgSZGeYJeeMPUMzDMbl1F4Sh+m9nLIibIpH3P0dwDcUuxDZ+Lwj+Lw2SxDHmEWfs3lO2x2yIc/WyaS37klhvKJu0WF+jOdv2NrA2jzRH/ERVRyoOMi5WDEtI1f/WXtK8E5Shroe8NVeWSMij7bkmEDFcgeFaARPPuK7J43u/YkDnOkq63awfD0YbQsHzEjkoXCgCnoHq5TdlQERHdpTa0uif/TeqezMCDFcUWJZMmBB0+93wo6ooEgJJez3fIAqTwX2ArI3J30BRsx7jvNDt0xWZZPy4Yu+tdgMaiztE8E16xfu+eM+o4QpIEs8+iw/SN1DyyRVgeImuOtEVHI+BOQ6kcNau1ZPph6Zilnnea938imdzSD89EY4edzBnacWVtwKRDjHcWG/MkTvjBU4gWlRp9sEhAmNhtCkAI+GGXP/t2mMbCyKyg9Y1ArlaxU8ilv8xJL9QwRHP4x2OSxr3sMpuLFZH/IbydQHy5/A7HvKhvqVaQmqKR74KTpj96zi33gVXRok3PIdKaKBqkalsmafdB7f6eK7o/v14ZLwg/DUtI6omqHFCZvX8ZTNFMr/PInapsvP5k1wuFaXNz5WDceEnmxsLhaWggC+l7zkcZLFZalDPWhfUaKP929946Ne7mKh8tF2kmvHwK5KXoAd2s3cqIfA4sVkFhH8JVGz9iD88JpkfQ+l8LdpioCpOE9FjIPLehHd/SHTasEwnnQejs2/8pqAYvFszGdLmDcO9T5Lsil9pNeoVDQHgzLjz8nLWrz3Hx3ie1A4oJHBE6pDo4laBsZNANetAB1TrEW1KSxi0sG0/plwYwlUkpyiPf0IKhdWlQ8nyIul/8uxTSqSvKiJ5N8L2PPKbDNW5btAOWzxOwX5yt1lCFc1OAHoWcVVXUpTBpZPiZlxYGsd5/SzHmgw7Y3uZdhaYEz7do7R55K9fP2bc8qk4ZX19ntnaygqckZ5XvJCc/L81tr5VvHLGmjkoFsLWoDOK4byrePf9MYsAVd7+zXDQ9C5AVV2ePgb5EnhO2lZLpHBDd36wyfdMsAghhVYMJu36eNPCyKOvsYAnrwJhyTNb110ZstjsPLxmQ9aZw8Stqp2Oz3v2v4dzRiGD+l7P7lpxKSbJcu4MnxDsi0LnXjODDC4Es2YX6lpoFtksUDQ14oFlzwZypdEX9TnmEK1pZx9+yUagSttRvmg9f1FLB0eYIbPAcvmfO+uzKKijVofJZgfPbh7Y2NxqlBMtPslwR3FnOub8CaN1SM5G/Zmq9WhZmNkKMiy4cKXFIXssOPipyz+tx6T0EVRoqGWUCROsjXPo3PjXdOJQNHxYomEKkL7QHC0uD5ZjLxh9wTYEwxNs3cQzb2eoqs92Bd2HGYKCDCTcvSp7kj596/t6tTY19LC3j5i4w+3V7CIzyRbj7/NWe2tHqXp4ox/INP2Vin+DBqcQwANyBD1MUmHtSS6CwWTNJNc4gQO07Y5LXauA5lSqVxd/ifp5HTjShU8b40aWwoo87LfQP3mSV8ICzaIq+vGwl7Q79MewJAFrBLQQ1ql0/Y41bwYsgLYrz4FkyzDGrzjOGPAN5GhSZ9M1xEYHutydT1Hy/Eos7Daaya2xA5rno1yAgeUShnA/Dfd0ZDwKZ5PciUCZDt9ugyxtwmsYc4m0Aq+lpkX1981jhuPvTtrkGV+w3iqsQxx/njEve+mu8GKErN3dW0EEXCggD0qFgYFFG0rN7YBgvJ3PN/bGtRE6emZ9qYCqWv5zUwcOtkpZIP0H0F8ZAzd5m+QHQ8OVrpFCBSoXuR3tg01ychw7qd2LEj+Ju7d7glen4HeNPZxIIMRhaJgnKn9dHgYTBdkqrd+06oXJW8hJXKro7reQux4mX8VWsJsMeqtXPPlN6SIYM2Ifzn6DrkZwDWKGT6zNBiwokKyttJlTg30DCUs5vkWi0LIlsybL3YSWgNc9LGjXw2Jmdk/cXVUTcmRLPzJm6A6jZ3FmxS6oyyAw6KjkEQVHkehCW344IB21xg2aGKui8ndG4ECABfB6blOHj1MhPaVXQnx+1f2Zi6NPd/K4wY+ETo5D1rPzA9+qZ06zTfFWlQA3kg6cJhf1lCmPYrKgbAukpG2+GCAuh7rzp2Q/5bILJD3NY5k50CIxQR4CVDAre8TyyCjRLq8L5Z6IwZ90v02N0lizcEV587TT4ytJcYfQ6VYI+KByUMnIbLukWlDZzV9vt+++L6JslJwlFiV5a9uNwNHL3tFjbAeH8CP0c8+p7EEhjwhh798hOAyYeM+nz29vgQbfhL/uwFIetGpMzzHlx1WBBBrnP8ImEnZta277JmLcFYdHiFJikst4otp4+6TfMyaeGgGCcuB6+5ic1+h0ijkVNfqZDofvl8u7FDgwvSBQLgE1afjWvlWVmp2hzkAcLrZ7T6tbXa0r9WxnKJjfWvICk9YfNGwjC9D+JLhSfyr8ryJE3figBFnG57imxzI98299Psst+ES1sMGH5gRESLOQegYW7AZYisAYbuy74jT6EtgDsv1uJC0MxQ67X5gxWSgMoZ9wlQseWxn3d8xuF+Dsn0fJZNHhkM25jD3ycnl80jidXlzt7y9grfcBdIjva7tQCPlXkiXlfYb9x8Z36U3+Hsfdx4NIuswvhVUsN3uRLMbWYOgEL7zQZS24ov8Xx/YVAJork46Gtx7agFLZHcGPtb6kz9GJMyGf+AFtAq9PiohSTIeyAdf8O5YRCEIp5N6HyFspAHM6QqK5EKAcNOzdKai2624WxD0wioyorcusCwwaBex1HTdMN+IsY37mEQuqc61r9kcuNAvFvKBjffNWhq8hEIbPHsyUR2QSgadbqOLFyLeQXYAyVMSip6gbQgK7IGIRaUpCe0vQovwlR3NXyGxkIqjaMBvwu746JRVqGl/sM6EQ1d8SKjhmkOXP0p9onrVk7THqAGCy3CZRKLGKvnrxImu7G0t3cEJfKoQK5AG2uM1OsGD2ycVWNg1KOoWDyeYabUGhRCHmyDBGSUxXMaSufhBsd1C8dRbJvokUSXKECac82QAMws992cXmvUmSmNp4lAI6Krwyf4GEwToNmflDvUntqkkQqlDI+7DCqXGZ1JD+jrxO7c9y2OHm8MGQEUqi4bBI7CkYIbe42QfZG/+8xRzdUi6tLuuMgHWGC8qxVko0EMWVFI/UXWyhWXgJ6W+Dh6iZziHRBwvxLG7NAiOMUpb9sgYLrhTPo5MVxGPC2ALEJGX5x4VfG+xr89xB/WhNDKLnxajr6aP79hJoIkLew3RqPp9UmMB92Ty/LTfqR+wEaRLIB4CoR4maJMFv2PIJ/tTq9iquo11w+jRsNIiDW5oeEyYqycc4WT9nm6U97Jqt/jWFJAY421IcKNFNzWcUrjV81t6dUf2jPrlS89+i70VqNBhYU/e5DlZF751Ma8nJE1cRtdJL1FbN/nvlW1r00jEOvhm5bMJjMRIw533sccCKcLsXXCa+nT85gpnV5g7b0x0NhEYvMDgfwobNO09wgCKdCdJPMCKQg1jS8iXLQqhDjZC2LsFRpxGQCvRsPFz6c3PVa4lNK+5cyhnPRNtJ4Nt8l10VNq5k/LmcMwtsq+Qatb0oFnTtNXmbXGUhg7xjAuO0brKTR5GxywTnsCHpbOnZaK01JPMo74NsAC6KLl3/14qX6z34aew2Q614Ak+Qk8YiTx7hY/4qVCMMGIFcoN2Blr/yA5mzyNF+KHGvVJlm802J9wyD0M8V7o6G50aaJ62+z5Bdjm44m7hzAqb+TiR/MsgIN+Z7MZPj3o65BWpgIEWUqYvb/q+FI0E9XnDOxu+yfqGwH1XdFF8+bxjEzf4nziPkayTwy9KsavJ7pLt9RvDU6RxqOLnAa4OEjYiQd5CJ73/C9GHGIlxBLTSQjKe3F2NKL4skyRKJGQo6fTWrlzV5hq8yAkYAD7A61oi+OlGJflwsWTrnI0OSPC043xxrTlaxsmY74KL0m9xDfU0bIlAQf0TkdBMEy6eloQhyZj40qDy3D8eVIEW+i5iCj9a2Ddyuk2goh03YFA2QyrnnyVYoyiNFtyr4FMSpPnKzeoWw7nPSgl/E6s/Emqyzph7O2la+kRxsOoWoxTrWRnkFLfc/jazOIXKTScJmJ2B4zgLbwpGK0aSzZGxMahF9wIoxOED9zM+hkx2h74jsly3z6aK+xGJq7ez8Jl8LOoRweGjrkx4uFq2+XomNeCgYGdbwFuXW6EBQGv3RRcoNfhGU4lG8m11vS6KU4jVkKQaY1/QFUeOb7mFx3alQFnRqRIe+6OS9cIykXkOK3HFjyI/BNtJg3PyB5//O28IkOwIGzL9Zes8glYtnpHLoFSDCfXtjfzyqPvyyNNP2lxhzCoXvZCMGc0jxuyX7q9rYbJBLkuPW5bt/1U6HyP06M9fI3XKYnFz6mmJw0LcszHyz4KqLqbdejb8Pbk3g0u4GVfWrLOnmRgYHufdl3sWciUKpAppML962js30mEVne8v3mjzeMCsAQRGqeeLhnBJKeeLesBFWOX3dZ/JbS7efehaeT9mEa+l87lr44id/yPpb7KnYKRhIhAYk6IqQzzF5vcgCc/aeZEiVHujltydyZT3mScUVuxKpyizwpAl1G7c9IuzKq2/4h1+yv/op7U7rYYrKkf1svqXguFnC3jO+s22dhgrZ9yg/pOq4MeDjq2RNEX3HzKQHgnEF+MFvAQzJHevoa6UkxtLVZd6CqNPiaazfAWtFoPR8wUUR3QKS376w6mmS6ea4po0g1cnAUm4dId+8YMaEuWkLSD7BuWCr508burppuRdzKOI1dwJJJ+BDeNIy9clKmWxmFZymSGQQAXwbzn6XHAdkcGvZ6IXA41nz7jp19k8Gol3pU83f5z8mg+TS7i0j5N2aEDwk1qlMCLizi2m34jRX0LGf+VJjXUYEgUuGMNwaf9wXDRtZ8Dno70N+/yOiLL1P8yVVB+u54MvPjHm437zWofBqdKACNSUqnWVXWoy1SpDDHehR80GhQx969s3iokhL1joa6IZAwERx4kvfLY3g2JwE/BlSc15313YieEElddyOZ9nppL2kCdXYi68H8rIF0bkN+w4Jkwu+q6DiBNSfpfq8ScSfw2OlFLNu9LPSX52xUl4vQm6gfBxvVPCU0R9+HqLCjtW3aPshCpZo5W08AOeCDtQfDg1ukF5w63hanRFYPaNcZ5dCrkBP5P7YMSB7gpXNLLtEe9yeup6jqHN7+5jHIspZF0CVnrq5WXKwb8WwYR+Z5L8cvle/NzZpta17LG+ZpQ6KoLsTaspIXYTfnRqas1GjRWMUhQ/8dQJrgD6wdg7ODWFfY2rYen36xjKUVdq4tFJMI+bK4VZGKPUAVnterVc3aGHauXOiYn9RHQbK9ysXthZKV1D88zvVmy+iuTHf+qufTOp+6cCfkwgmDnDy0+S+2agTcZbfRgIm3ppV5ZXO7GDoN6h0tdCT+5vK4I6qvYuSd4uM7zluZIFi0EXGs/t3n4/wgEi1lap+qXPZwPw9Ixtw/SNPGLKoyLQE6Ipv28YvJtTnpVEo8qN/+1b6AE6JF/zgmInBULU6R918Cq2BpPfqwJ/wfgq/HLDYPDVQfbwa6b/WtZDjxPDPFG0ahHqqR63iCoGs/C0IT43Tt3vuZkENWXtw//v5PP2E+LfKchG7fjNY/xq6UBC/Vex800chw8uuqfqtrrGOuEHDUaeEiR3wRKgihRM+D0AlPmc3uijMgLaWUbBbmS8kfEbxVMTiFEoRiELSaRIsQQ07er4LlaTJW2F/J2/j1EgD6ZzNuTgbJKbGsYlJTQxdbZrYIpBQs/rjFZQztJzF63NnrG8Kvc+kTNW+KwqzhAoGzHX5Fd6WqLpwVGA0dTp5dTVo+OoJivRGxYFAIYHXpIzxG/YLK0YIaxEKq5vfS3V46QdVdPSXltydccJSVs2SGeGNHOglr0wPrnJ+ehpvHbNPU4+jGmsu0oUcc8q/ss2gGQy1Km1A4G51SY5vxeoNHgIvHfmFSasNQyxMHUKE5C4WZE01hPQxVq7LKtPNKMPar2FhdZXvSNIagt+XXR0yZ4tqyCAGfbAKAwr5/nVR+wmPZ4oIK86DF1/b6e1sxd3CA05TaU/DtJkPWyCgQk94F9OoTouO39EL6/obDoh8iWKhG4puFC4hkic+8nljX72j/+CJ7J+tnRF3bbVTR1O9oF+f1xGrcH73w3mpHLAJtXZbfqUo2VlAdE8gbbl7tDeOy6CAcPPP3z0nMogfmsHis+BavHDanoDl7uw0DF9SQABKpSkNIEhgPU10rQbUPEp6qM8XzXKu9zkbnDYiWB1FM8PgcCXAMnuUmeXAewpVyCjR3+C51XYFi6AeJPKbKUgwWR/cczI35DXqOjBPJUaFWPLvR8oaBHpmdLBR8nwtzxAcezusnXijIr1KPR/PRsYGs/bNjdib58LGTIQtw+6VnOfI1HTicfAbz9OSKF3UONmafaSU08GATcBHJrE5He/BSN/jImzeedmjfrcLJQc3nM+rD3Ww3Nqtha4qXK1CoFWVpEkbcAgotWuR3oNmjbOO3NYHRH/ZeMvqFV36WgTf7pJ68GrSt7xt4GEr6aOjoyu1Z31+Ru2mO356+5Ay8t3KuKIfM+//IpbMoobFv/F0GFmssckMiwTkT6CdXgZ9Ah/3phEGydkUo4yx567p2Q4OGBG6DZHOJ7H0aP915lcztcv+xSDBPUubaMsyrcgndMu5ddGCRvOlGn1qLWEdnhKGwgrhXcWA/8zLqhOEyJUZ+S2D9fgPxOPVXoigIR4lxJiVh0yL1iJ0njNAD0RPPgnr8sG/6T4mkFZOzOuREeZzWfhqLD/EJtnbC8VU9Z6dHd+QiFfI+BVt/XZL3wSycTpiCSEVv12VLju3c9MdYw6o2zYREenYDzsflTBmRj+APalhVQJ+xx1m03ilRWfCf00xBgwl/b+Rz7KxhPJQk9Ml4M0AuUI0hpRzuRWgwlc6wdKw6B4fnLT6Zvar5740lM/0629Wu+sAehOLhNqmHB3QOiLb0fQn5CziG2+EkNqXNneUFIdSxotfKCrFZHdsgVzt7k91rm3EhmhuwmA/iBtyoI8koA1wWh6/2YERZIPDu1oWS5p9GRmkb8g06u2KHEQRBhFWbv5oGw0tSVosTVdtOSMaaQun9CxxSWmCgeF6UglX3bVaId+Rt6vFkakX814SIg6cp4mIIreXUk2RYIY84njUjOcgukjdxuD9IZ1GM3dyINRAhYN4KipcV13VG5SEq8S3FQWPho+nKWGuEm4rYos0gWzoKMPPqr6fLy/SPNCjel1BllhllpixMBb+rB+fbnzdW5c7AsshWDUkIFZmg1NfB2ODj0b3rsSuj99xHb98J+qwUdky32u4L1uX+sDLpTzcxABest8fiw/RipYd5JtYmsV1Sbk1knOtwy8Cw3/cqVGsLqOna7JdAe7L2r4LafRdEHMfZOvjzfP8WxAxQcM3B4pHrEfkRp3EFm5hH4f5YDzEAmOKr1kGDLKEYTSAtSVSz0vS8fd6zVeRfpV8fYmpepGpfaG/Q9rg9eTlXNB0ZwE0Gnqxh3aw5e1HwQ6TFPjyl2Aga2di7+IDTjXBtmr/d+PtO1denKnlkDl5sLhFkwqYg1V8RamSCl8OKe0qRjQ/CjUkXYrXfx7pl1rpieA2a2sP2SiZX5M/pLLSdBksXQtvotUIj0ir8ZRlDKl6xlSiuIjfyzEi6LFIDJ2bFCIXmLBxj9XLATjwcXBKu5NahSH3jcXZXS/lX1bqAXVttqDbNzLAMFXf1cdIqKpisv3YgBX2hKNneLKteX+VbackoytKHWIMkYP1cqHRGHezInxyiTJBI2GlhGQJuizC5ewaHDW0d97x5z8C83CYHEG+ALM1y3h7khay9bpfmsNiyqiwLWxjGGyjyUGCS2MYSjOhL5P3OpWph145A4sVXXGGUWo26R8iLFYnQ0wRFrDqB/eFSTPApPB29iE6Ujso3dLbZd+ZQ2scAKjFTBIKHp54lv5tqu9cuQeRzRtVNOIGmlvArgIAByEDv1mV0D3QFNynvIiiDRaEdEvmBYfC7HAZ5/igPnuG5WsgJ/8VhhoDdn/6w/1soYc54hgUA1jVhUMKgx6ntaZiiaRZWvH5SwlYT75ptngtwe/o6qvNCwI8JvRHtLdY6Bh0G63SYkIci2XdhfZPnUixpnEM9S0zlOE5GUKh/Jvud0dT6K0DXbIIAdJsLsmBgnEMocOAofXaLqqhuWdUlHKjZS45b2Ce2Ae0gRMZoTNYs1nVxjrzwQM/tNWQIl3QYR6mjWh6p+FZYEWKhISsPnS7QfAB74U5EfcoUUfucX9VYw85qHXx028K0roweTkJUtZE1oZGdGM1XQCToBNSwKKajFBdl9wwkk2ujM59zRzPeYuLpPEhp8Zm+A+AUCE0UZridAcLpsMy2BfZJSB+R591/Sz9dm3GyVaZSTY9k/iZyPIHYrHggFTXfY1sG64Zctuijd/MlNb+XPJb7jtZN1AXVnPVqIrddT0ptmL+iMh7CH7IBP2lYLCOWSUx26mhvfqQ09jgrSP/zQ1FqPotO8gZA/ETqBHh6+K79rD0tdUQ3XbcPhQGD3S8rQlcGhq54zzoc+ETIBnzN69+c9xtz4Eh413q0+MaL+a96Go5uMCMk0m8/uO/TJBppngHNoHgVv6ZfV4gFCSrQSY8oOyn1Bi1UHpJhKhBTS5emb2peo9dtcnLcSolAITM+sgWew9ZKDdvcgjGPnmVM0OBtik52giIArH49AhPVR7N/WS2KPMO2xebCPgglKzYFndNu7MzY5eVYriE5kp9HE/R4FJxdyfolitijggCMDvjo/io6OV66BompftLsn3p2og2Nakmmg6uaz2EjDf772YqUhOl0Y+Po+YUwQZ6ZZwu59p+Vz6CUPkcW2dQHJonmP+TWaLkwsBm/RDLWH4YGbPfiowuX14eu3blFPr0mxHtLcmSnETXliiGqmfbvTtzuQAkSNcBFTSzidSkBqw5bwjV5lDRkCBHhlR6oChLBJvnzKRXlZzorapLCOGLaglEAP4yEeUBwUuqbiTRx6J1saob+yaXFKBeTvRW4GZX7WoWRqReGy5c7qDZj7vn+WlnNQa/+s5oCaQuU2IkYxTVPA5mt2HUCdsYdzpmbjWmiCvxKRcPssj9fGo6wRBM+B0nrWrx10PBXQdYXJyTxM362Yni8uyZSrjzTz309dYHgj23Od/7fh70D6pbfYfoGhEiAw6bGaSnriXsdcy3OSMdgSuqciRQYVlPSnYN5AYI55OquZW+HyeIwzMnpe/iOAOzVyYuAJOeXk9p/vW4Xs9wRbJkBLgY75I+Hz+afXtNt5SDOgXVOoN88C8C1/nmsilIvG67IXsgRSnTEXSRXW8hyLCbiXEQ2addPKEMxD381iqb3Z7deJz83vpDBxDoutGWQhl/LNP1GQw7/sTliiqMwNdOStAn6inzxBCfF6HuzU26jPrRY1kJGKJSFSWqQ2rolST6t0n5Qj5e3H41NVETmmnXh5IswYDWp+bOuQ9uNeeUBTrvXfAFlc8uC++sBxXNOCobG88LJg+t+h1oaKdtl0YHjHsNjC3TOZurwaeqYcyjaVS50cio7wsY+sEulb+XKxyrnC1L696eRuFqy1lILNfNkwYNozAvTTRzah4++XLy5SRySEFfpEf0O7nVDArAvzrNAaZf8FI/W5uMJnvRMSC6anB8nfnYePtVHkZjKeSqFgWo2iQGRX4l4h4tJm3A0fZdiZvVv+G4e9tkOUFE+H9XZwRG9Z/wKp9EMaAlmBmbt37b1bm/ZQnmePRPjix9b45s87Kj4pm8rSxpCbiShhXMiuSMXzEOemh3pMWbCNX/92k5q6X5vHwcD74KWSYG+++/OMU/aV2eX9R383elmaIJl1zdFf96RLrYO6+5Oucn2ZKmjYlfBz9p5UpsVaeh1xoRpmRxMjL0rVKgHhj/hjttZ8V+n0+Ul9eyqKJnFcdfNjsal6k3/JTO6/+EFpDWQ1gllXOq64OetRD/bVbatBdFEsQOFdy9eW359Jocbo7Mp4jHvBHRSbzZK3BB/UfQOUdUWddp3Ls+eYViaUrO8IYTypLdc5jAo5S6R0IWObw99fMHMJaf9Rj20UWj+HZV94v/xCfEcJ9yEvM7qtd+vBIXvTIgLHLrWjI4r1UgtmJ9c4B/Hj1fh7vVcXsnw4W7z3F3hwC9foEB3v+wKVVh7rpAbXajMlK87X5h9pB4W14qcgkbWsu1J8gqKuBCKhprrEfuZsFBoO3LFOThDgYLwaRy7uatEPoKmwojM9pY8DqcslJ3quCFDGuUGECj5Ac6CYLlKbfcMZJmlrGs5KazxgKS/4oLNZBWzr0Bg9YwRz81QYGdqowAlG3C/gMiPoq/TaABk7+sANJ9hStVwLFEcEt/dGLDskGH8SV89Xjkv0FsvrRVouf2faTd4CcxZQSfW81I/6Pzo1U4nOvSIQjXuERVkS/BZ4+xGq8zKgrg3PKP8Tzqwy+APiozfpqOEOCUT8KFE6LadvGGNJs2FhMWkkfhsQEmZYXExYEAuqctlHZfI7E/MNdtM6a/vba8BwdD813efcHujusRZ+TkkI4ZEB5dwMzXL8T0HgkoslfoXNOSUtzv/04CmxSENhXDgknSkxz/b8fYk+UPWOgn4gh4/Krt6ipAyi8xxaEwpLtF/gDy8eHkCwrCSTPVerA4O7/10Zn8WSQ+hAaykHYjp9jpiVSmxCpZKWJyqMVN4BTmfDaMt4p8UFJSqF1gQDzXscC3NSdgQui5Df7roF6dINcFfYPv6xxeuDMATqOu1nmt5DGJbqFjM5RCGFsmUjOhTIR8P8gpCzpKCC1aPtmcq/PNi8TtRJvQPeQQ3GmDucUDSbWn2o57bBugZBcsOC06Zdlfbr9muYsfuplxBW3BiOPxr7VBKvkcHlWJoxxnAGJ86/dzKi2yL/FrcWJmmlbJRuO1adyv8rdmr9JJiJPGW8eVXdfi0rROQo0I2566elAlNxcQAx2/jm50w5Pr63SXIjlEPNfiFFGt9wXH55pumwYEiMaKot5HCXuS5YYmiuxcrErSEwKN1QArnyWTyokZDHH6giMYBf8lo0Y2MuddFjHhZhP0J3995sOEl6uJNIAVfzWygNHEDSBrBHy9qwOL4EcsxmqJi27OD1XwI5DOjI5bwaTbKmIMRLY+aKYBdRVjbRtNYjyD0zGkRQk+MHjF0UOjUFOUi98GCBi3ge8zGsD1idisZuzbgkW2fY+58hqWZOhKsN+0GwE6GYJtrtJeCTcHPPFNhxKlWowy53G35uskg7PCNQ+rRyd1VBpTKZExYTX5wguTZmDAG4acFvxLgF7bfdHMnqBavZZGuqg/xzCOK6twL+tBI3yI+Lnzdz2gtD8HNpGp3fMWBZb2By43LlbDv8k2HsILSeyG1nJjbv4+pA/QheowrEUAQxRc6LXBADDYiJE4uXmERqCWkMOBnlGYR/bEmtTLR0WcM84i8G24woIPV+D9HbQdvwTvlmPDGdWS0GRp8Iaw5PyPtqL1fnJnDyqI5iwMtzxVF1gOf9cb2a/Qpjehk7BdZ1KP6HVkzQbz3bnDJ5ka0oOaFF5UW3Eti1+kCqWQfHr8Pb8seyuXRC76JgPeRJyLKjP04kldXQRGWwsZ6CUJMjfQUuAvTDWURwwIRtA0lrgLn6pg35YSINtdXlUoOhspAtpfw5ZpO0BWWQb7JP3d3pz++z62T/jU1ZEaAgqUeAgHK2YDB6abBb+mZN+4GMpmIwmCBH1yWcty2qJ6Tj2M6OxENkMljWKfF73lPRWqdE1I8zqs0FT8Knqs/ccHhB9qmzEd358UgFwy3WWNtqReVt56SObiUMPTI1jvLX4o2oc7/9WGlgsDzg8P/Ltk7WYcMXQR2PalBcbTL28LkNcXXsZcIFp7SCfnro1EjPaBt81HtD7kIY6gZwvJAQwzcxa77ixHYfpG3uSkeXBtX5qHIsLX5vRoK9MblmLg0yZrhJisFJ2EA6i15mdpHgLfM21MtR+Dy4U1Ymp7icjmeQt/mdfGk7iayVWxq64LnjzRyXRI75CbitSxk+tpAoQfnh/dOX4l4GSX6PFJ+smJmREG6fWVvGJrn19hrG9mmRBlshreJNSOZGQEz78We6XHfE52LzACZaxVPPHDkAJz0n7j8ngP/2TnGXA9X29pbl3KTmISvKXJDxDPxLnJBnMS8itZvq+la2qgmD+fRV53LSMs6B2MDCorlp8A/ioeZbkygVCx2EJyqDw6FpiXgEQ2isbG5xaSTQwXGFX0lu14L04N8yQc3UpSGPDOigRK4eguNQvy98rGkwAv9cVlSZMNfpqQvToK77I9QaDLOD9amR34sPivFjiRbeYrIirTFRBzUOxcyu0308imPzkAp4zijYOmgOfY+LfIeP8kx2Gr2t5ifxm9ITpWPokizV9PQfDbMSWaJMYEWSlDiCw4/ZKiL1F5oYY2NyPLSSEPXha7BvfbYoqCxCDHvRRACzlIaLhf9HOcrrvsGHHefa/U1yVU9gaaKQWbbEDEWrkiCqi7ql7x6N6gi74plQQBh8mA2axVZQRxJU12nfGQPXC3kZp6tyF3ZZcmXSOaQPfWvYUNYCucxcD5767QU79DsHx66Bn9Avd7cMyDdspxU+ylHPjvGZUfhXZmaPP64cPKSE0eBQ9sjsWxikCaDnlp/WZCRuzlKx0To30XjuBtF4m2pfgCTIeCykKSMD7CISrb0sGwSWJWHBvi6hoSKfnR1kOtE2rUcncfRXo/uyHormZMpxqPC+Y/JRpiuMj4OKabe1/AqD0JwtOIcYtKsWd/WiopXGHjAZFbxPj5iEMtjR0Pgf3agzMBZqSwBCStdFCg3Reiw6d/WzwnfP0dQGV2NwQ7zIpHj5OmLz0yKxyK/S4BprVZi8LRHL/GWGwsit+8vhFf/nmuaSR/RF9gpR5EXZlzWre4WYgWh9u1v1CfpNgQ2T9LOchzRt37HMK7HkuiWdqK8rdGpuzBpF0jYX4wz+dd8j8QjrLCXTVC2m/TZRC7I3pkaCNQMIpVs5cG7QPNkOnCe5dcpSnghsNzFLozM4o6nKhbWTIEGq7rNOd5KfODSbj6MmnS6wQqtSkCXXaDgGuxvF2AO/hwAoFc13TqEyoW8onk3LdV2p388zNK87kSCKhcVRIPRPLuu+gf/zdf1zIJ0NMRms8qqNMZqt6s3OjeLS0gYp+lP4kPfFSaT7r/FMzBKsn67o9PQKREPm5sbJmLjrTPNwuearH4Fvg3GowEONZDreR+fAvwCvNH/PHMkDnRzIVuBNvNqoerSILAZk1S0qHj79DTBYLXl0i+joCka0J659b2dO0FtMXMgPPjSRVSan7LKEiKlTSeLls0cGtXB5BdGVHu/BX5d7drB/eYprKsnN5LJDXIGVtWtu7rSjSbKL5G0nzKY/q2fUXTwxMkPCwXTKae/jMJg7qsmq4ctTcaZWTXV/FmQgrxFcy+B+4H0P9vbfaY/aJ+TCmETw6ROMCTCYWnC2M3+WWxQWY6yetMOM3JyxpcDogB2eXqkpknnVskyLRvkdA9K5N3hTHmL3a8uF+ZSiBzO7Eho7HOFkq1PLLQjc6wCpI6kmP6+ad/BCsKVMewivPetDBvk4KNZnI1K9xXdE8wZK4Qh4WkDJpEu5YQu6T6Gy4TbyqKkVvloI/o/jZxbBXFb5jv/BjnZjFapgchp0+fbVL2x/ApGYkSc/FLgRe8dVARf025OBETW7xZib6+y2enrkbxpoSI138PvPqZCxmrQbyOyV8EKLTR7EHk0Z9ka9jhDhhhUtXRdzjCC5NmEc3ohTylaZ7288uwz4Cb2ZA0dMyaobZLXYGic0G+PwQAvRenf9W80z15UWnp4wNU9O7e5ujCsc2PfLFZ6sr5X/HpJPiXw5tzkvZbDOTAv7pJHSSuLsuFXCewWWuacATR/Vn9CKwebusH+JaP6NEJCz/Mq/O9YqCdgXeh8fk+tR02Ta96tvem6EPdmgJt/dRgzxEfa2+H8plc7QHwN4I95qQIXoWFRW5VGCA87BybV8immwr0YgNaL7SUk7bJD4ui+LhufVM/NQO2al1/X2onxGdNAobEWlii807EUhivXBzktk2qcBWCBoTrQ4uvbq2XSPpa65KS4V76tyGSMT6fknJfqHB5/UhjxHyNfIdrq+8yYHCm0XYYwhplJD3jAT+2U5xH0tzhMhXVreekProMk4OVhIlqURC2PKLZQit6zrGjWHBLobG7PJlip/vcx+cIwGmfJGH7+Yufh3hhTv2f3Y+slYtYhC5+GhmtEc4C+VRi1tpkdys7wBABRefGNIxXiFSUgQU6xQfm7U78Rq4JZ2Gmm0HWLnPsVOENRQMUYG3Ltgn+sbTc3o7V3AR/RvCI8jiYaOEtG5EHIqcZvhhFK3CyOBb9GZajGUF6swdXyXvqssRlhIMwpMw2n6LpTH12U/rDAo70zAkJ6GeofcF4wvQ5L4wo3hYa98wViJamb/A5MTkSr6iclMLhXbZ/uDtJd5liqW3D3yXvjB7ebvYka7UZ0xsx5QdbOtNja4bypINki0tMhNasbILfVqRM0cl5TTRKlPwOewPN1AhYeYpKKf4dsTKe/nLbPP27uh0HIQLeT9/yBS2icfrsPLL5GuWdSHOEkkvgdQimvSWxv17VrMT/bxdnNHmXm+aAbyRl2ZaQeZqpfsFvnrwpXKAgTecv2N60+kA2X9w26X+si+a3xpxmNWr3QdCrxkgaEarIR9LHMw+9xH8UeA5hDaYaWG72PWbajL0+C/ColoodtmzQY7qROQ6XgebXMGgzLsruT97zbWvG6Smfk4Fd2Q1hn0z4yUyXj2NzvIAx3m3mnIVP4FuiarH704eV4mGQYsdEtXxscyt+r/dEQvzEIQQ06JcwTHKf4qbKbxkAKEkfmryF1G5QFUsnIxLXrqv0Oge0XlsNmpxA08bTkmHWvsN5yhc844K24mKj/NmcY21g5DbXcg2WnTt3ekETVHIs98y9aPvlWpDH2vbGlPsv3vaijjpVnu5QdXeA4VgrSLFD13xXpeCBuy4vHRoKzQj12GX7RHMhyar8+sPrQuV0jO3GDq1uZCNd3NaGf2X571nIj/8641nscbVWz0IERHkFkmBU1FuaZYjBVkGEklPd9asi+COWiFc2jq81F9goHkwGxr0NeaaNcXSZBUHwN9fn76ud5+MeGil+cefv+RoNcCnUcB8L5KB2gE6t/3san7yehpUhYPsA33wSjJ4a6uAQuoLKvvDLV63KqqcMPS80tg5BiaMHci2r64ILQt7JhFW9ZfCx9Fg1eiBkvYxto9bfpOghEoR2PGthSyWM69+eDL5JCbS4DLttnLzjYobctaQd7Tothh38TcuNznNKLEzwhPvihQmtYrhWspljfc5L9soNqeJZfFjjnpCMWxXZxy/f6Ifwm3iDeP8pQaRztunYR/JBq8TXJLpL2NNCXH1SNB+cSARKkMftZS5838EpU73mrerdr9ARpm73ZvUYyDUSx9Ym8PEZk6wGYy3hbcPCcPjos0gbSLpZjYCJEXcin1gXd5StFgMSPaBuATYasVD9I9VjoQwj0HuZoR5//wUlMFvBIk4tgAje0LxsD5zGkkvCzYvBMG4iR2CseiZCeYNWqwwRPIsv7PL3SUoF7SbrnYI4mdJWhh03pECwrsKjgp5/yzDmYVlQayshQx0pNWkO2ZUiIvYf+xpSV9NgKZKISAyv56WCsJ97CtwrBYjKXSciJssPW9vbBU+d4fFN33VaR84LXlh5fauTdtgIF9DUK8Pv4xJCOrCZFuGxn5BBb2IHv+zrZrVAb5CpJhkt643k9FgakqF2dL1Z+3I12Ga7AXQLBhPlNJan7U5/1Uoovir8sQijO13UwZ4sbTgACWXNxnuNvTWFn4CAmB1cfsGNfFn+f9b5FRp0sxlOUY9pD+9XahiM3IwEBlEUPZ2Mhf//lDp35iCjKFlXI6cSNNykGzW6uRwjMXzfPNc9PzkCiUJ0Sr/lOoR4SMmXcfksqWU5U6miXi7v9oPrv699Gq3spL9vaRV48SjUqDIQa2Pm1/B/Vr/peT3TuAPDvJEP3OpSeza26aRnhXaaaeeOFSz7oZ6Q8dmvCrP6IHkrDHBY4QAI+dTx31AKImMdAbZIRTBTErT+tncGm+IMROU5kPf9Xu2mzkN6iHQ8RaYLMVkHFalC53xxct8wVlL+mZ+gIICHnfppdVwc/clJKwQ1OvGrFXwQeJalCYbMxof46HX8ArxI+9rlEJJzOJ+/dnfMHhJntSObH29ya5oBpgEOHUy2w8nubVtewBdI4czWlH4RwIPl8YjyhlAMiQIQ09Kd/tb8niexCc7EdCFhESOl3JQXyWhE+8Pmo1tEYe14K/2e1z/B6lhr56dDoCpbH5fUfvTFOJfQWEIR+KQ96tUs5htcrW1EiChNIh0RCKJd+b5Xw0oU08ASWrdzZawSoHzE7oEqy4jM1dh+zVHTzPT++Kn7THYBJ3K2BKXEYB7qj24YXT4FwwUZrZhmSAKMtdIOn8HJLECInGbS5K6KA63I04WeJ+w1XfWlsv+OmMxW3zlAwUTyisrpUt4+tfalLRQX0+tlkVAvo1wocWN8xiLuVKNpoYjQhaKlE2eEberWiVq4XzhcgjhZzULsWt18KDxcOGWx9q0wj1ugnrAu5064LStUfambKzKkkMEkLiXl6LtP/OQ3UJlCRruHDtJhJUfPK2InrkFQeVZYRvm9ou8eu+HbszJgY5NeaEnAxT0UT8YqoxpwyDhORlDyzfT/CKutuv/rVjRuHfM2eKxB7JJJEekmMpKyet99T3crzLlhnoSueIr97+NPbzOwDE0rOr3wDhYSmbmSrbsDSp59lqPUriyfMr4yy5QRnUZJUcwTg82qkVDO9c4cXt1JA9+LGbPQ6NrOSDOMBbGDY9Pl0qq8DfSv04UiqGEnm/P3ngC9R41V2r3nUyW4bKS+ep1wIOLA30dSJAH66u6Ul8xAitb1z84QDteqwKapSYIFnmQG8fuIr4yU00/0NSsiokNwa3bSckpKGItRF4yZvBIwKcZCKqTHSeSBf+ur8VAHISZ35UzQ5Se8h8p6HTvi5/0vkUpfMum4RzXu0+JjQcchTpz8XfsD3/SazIjaVvRrHbylQGoqqwE6Tqq+WFsgwxLsw2cseJ6lN2gQTcX51yQpzas6N4FiTCsRjg48Pfnry1p0I0ykAgHea59Ks/2YnT+UjwLwc4PmC0waUpAWVYtRRYQOR2yEF4ZOE56q0NBgXp80WcEEfEKxqb02//IvNBJFfy2VU6SsN/1r+ZsgrkGShgGVDDUF3+NAun+ekKDWJEaEkA5639wYI04i0UeJE2ATpjTc0FDmbE4kevRa4ohBSmVNvLRgGeRFOB2PENP3AJLqPOVPYFvdgwj+YQD8QRGwCQeVhC9VrBKCVoflP0c6vGofrqvqB9gyGSfB9MHht/WcYTVLSB5FUK1R25Q5fzp6nd7IzVk1FpB1y/6y5E47/bRJGbukfxhOHaSP4XszevNhq2T0diTve4P9ewBSQe4Um3ocEs6fZoFr8djhKgnHIC6I29sViYehUJc0azoQTVieSzOBJersv9ExUyuF/yyG+hgJp9okPpO4ZKGzcyHzxbTHSOC9X/BCr9CncnydW/AK5EBE3VtWqck3SsdoYIZyxxuVY9682NMKcb6ZYO4yyXklY/nkmehM9QXGzYYBlXeBkruj65rqxBXj3r8FjFkWlRJbBx0TH6uyn0q0pFr95TI+pe+HpkXaKqlT3qhFApN0zU1iBaiimBRmLcXSY0crH3ogc2wtkuVVyPzb3fYMWrOBjmrVmp+Ivh3t7UA3k6icCgRrwNsQLXzU/pAvsS8VsRF6wdMQ4vk9q66dPT7zRyjMFO5C6u4++Y3qq1qLWwx1wROpe09UJt7ofTeqI3fCYcClSeO6LiGfB09dVb4sSU/jArtjOm35ZOD0846vXtnVEf6xJN/qKG9fnkfiLY0ju66BRQNFslZ4Mb709O+TUTDluiY01OwS140rCoRRYi8Jkdk4pwUp8vdWU5LqeYaZB9nU6Vf+Grh9bmUXBVeHYo9D5sPlIudSbNM9Mp+BXMJcuctTxuoyRC+IPSDHTDJqwDS2Etb4X2dQywk/1MGkD20zdXet+XDJ0sTGswBE+xTbcM5cToWlF9j8y+KkrrL1hKh/6t9nCFUpb7hdaMy1vgVL1dec2zz6BgQi/k3+oy8txPafoDajXTrGPT2116fhI2O0x5FijFgL9cwPZpVZIhU51H6yf8jKLUpquhfyoGaaGaZtFx6c6UswacIGd3QTKMuGyUng+S/3ftsCFeD5Zsx//zQ6DLzpzgSCizxcxLDoMW/dFTh5FweNU20gWBCpDSY0xQ2PRzBCSvj8DuK+2puFH21U+gdfet59zTZqyI9AP/h/b0CvxcF3OXml5Tyhvhawa27GzhxTCPgFQ8QoAXjnUZGQjI4HgmJ/vqB12WRa8BoFw1NoVR9z5e8j9xr3C8XHfIeBBVNIBkpqQo+MnI70+HeBcq6PHeRXT1vyMRVAkhlpl9tiF6FXLYRQGhUoWxPyG2e32eaakbWzVeys2mpLLBwjI2TdmLmtN453KpXRX2eCvCIKqtouovBbBnycBHcExe7wKoXbB70xobl9xwcoxpw+JZTDbC6tOwUWs7uJnvtLhmxLH4qTdInct3Mf7YeCT9PEY0Fvn8qae2XOkqcSUpn8IU9avPeucMcXU7hCxlqUSbiPOq8AMlDrzxZRHiyYu91Y3biTHLU1VdbnnQbMk8U2QW/Qf80ny9zTcrGY/ngPJFPODzyxCT6XKcCz2gPARdXtncg73p/GmZyGXDqy5mBtB9sySY+L0r4Fk4AhXuV6Hwe1yrTahd1RnrO3NBYVQYfTMnhcpW3Z9lwiL6aETab0C9JOlWI2WNkvd2txn/Y4ljoCgxswhIU5tn+QfKh/c/WOvYfcS9BcvbB3cdAv5IJ01dVEFAmeE7o558lDLyoBftO+3BUUj+MjQ5Nl38xbQJC/+coGRwoL+injMm5bw+sJ/ajGg5O9MYXQDfhmA7DT7cidJtMCqTq1rbqE3JIMV56OYAggYd7d9DPzCOYnetEKeRPQByXtQ0b2FMquEdTghOYky04YO1EpsH2ViKlcQsN3iuw7ex+aqdSlQqBDWNmjNECF7/sKwBotPqA7nPlymxr+SglyFy1XCKqQUOIcOk3+pcxNOv9mMCrs37mFrnCL99g9xrXmM2H46F8lQB8xLHzg9PLUAztdjZC0xyHo6znO2SBmdxxH2RfLW3LmbMVDis1/IQjLiYriw32Wt359fmT7dg4y6GN2pRv/iZsEu3Un8rcKiQUwgBT65BXWEnQjBebKXXVRT4mzuAdpu+BxOzz06UCibe71mY84dtvgSbbMfGESOIHFJF6XOGjUAYkvxDhVYWzRY+P1T2/qYx5+qd43G4+APzpb5uQ61KF5DDnD2PWpp9CThZhjluMFDN+o7WLsaKc1GKk+UFiL1jGAbtS9Il/MGTOvWkitnTJv3hjml+nSXdYzVx2bMHYOk0bVU+4KY5S3txKUZ0d6DcrcwlyvY90C/yBsKnK2adqtnD1LlP7SbTufz4yceSp3PMeKU4Tn5MgqLzXvAV0jwRNPaMv4lAYWy8TRh8PbznG5PGFe5i9rQRu1XuKMpUmDnrufhRKOl9haV+8lk5ncGXnHi9yQdtpGrXt42JgahEdJ+JWQHZwr+tMRXk/4MK1DC2iP7Ttukl3niDc1f6om/5zgx5KQkR9FJtKZt1m8HheWZa0fS8pSYBl42Wq11s7r3qKeLQbfyY8OZLAwSmjOAS6Dk0XleJQsqst4uuk8489trUN/AT5SGxQ/2xP399BojJRqH9kMnwLQfhyPoVK1/wd9Y4/LTOZ/5UMeeCpFIOPgNdlvERUwKZkOLkz8Cw9UpBHkyvTinY6gL/F1mwqCO5PEbAYn6oL6bupjRQ/Q1pB0mXooD7jx4aMmlXPTZ03X6yLdObn+n0dHn/sBjVRSb8a+mH7Q2z8iSQBo1dvfwnaHplxwffRZr3O+7T5d0SZ7rukf5jSc+mT48pPkS7o1qcF1q+ZuVhvUT0Qo7MCveBPinUOzAsaNE5Bn8bJlDKmNgQ9/F+RAD26jetqUMzdXrhFE+1Kosb6M76g5IUvmqa5XJ4MpRPFuDEXOGKLFBb4e60EJ9czMwS70OkF+3f/GGi2rEEx/Iqq/pN2Ugsm/wONkKukNyPkEx+98MiUYJ+oWbgRV4pDpeZU1Sy39F/eesHOMSyKTb6jf/g5vVDEVA83CYlRnOnmhGbMG4b/IjBHKk0kww58fhR9YsEk0uOXwRy+l3JpjFA4KLWNU4n6DYQcQot//g/dx1a48cuCNaItj9olUH2PvnaX3rHKj/PC1qUlJcZQdC8YITyq95Ad0jc9jn5iZddo/NTXmngN2AbUr8cfqSDgb5bWzna+YZxZnn6BomjVBpFELMYpkEV7y8GotBgXInCfnWg+UpZl5Y95LxJZT2lhdKZaFMkzBYn7wVK0Bh9JQ9QJGgCDTn6HUTtIVA4vgkh3kDJeulThGI3HQI/G8dP2a/CZ2bxNOEaBHE3N1+iirHs+r/8n38iZhq2y5DRSlYLvF7CCY2iPjLj2xYVJerzgfAzUxsyQahsg0Ng/fLD8O+aJytv8JhkH31XJl5RP/8p/9JVMz0MD1m0v0315PTBwNbvNUc90D6di37JnQ+emUdjg4z4I3/UGA6/72EGXA159tnXEsFOLBVEWpHLjZF6tZnL8gbHZ+Ws8wnD+/2pqLFjjBsWZ9l4pw90vLk2pFss9fxE+ee4iVJaJuVzPUvsVqW7wVev/hx7iNvrqcTpAmvXEv9upft0O/RAF/OmUWHhm/hjHlp/1r8HtnhcG7e2IKhhs3DntL4lyHdltJ06fIepx3ZujTvivOr2Wrgo1cc5xF46rRpinfZaSzfWlZkbOvVBEulZs/TzuvTg6DjXbdBXjCxkjKOh8LnOrEBoqJ6eNdcD7R4NK+HRyBZ1/5lKmK+HP4ERFbF7epXXWDBv9MoLg1ShtIUWIacx4S8WSS6qsksRTRJAVs+Cp0uvxKUJLuVmR3JPG3DeV6QPxMIW5k538XJPZfGCxn7G383VG0nPC7ufFLAgfNCfKROawogZqMUTv32RSOdVJ8XUkNU5qPtyaNh/uqE804/4Et2rpeUhckuMauvMYKLkPxJBSJKBifXv7bT3UhDRQfDs1aMbNK1JD+azI4vy1mbVQLGOR4XclhRiY1dmrO5lqDJ/4k5esR8CWdGKrfg9DDYnM+d9BYuk4Zh9gBA20+uWQCWYaeExvn33iJkMdRGUbk2hh81GumT+IcVwHIiWAvUKVxQtooEJwjRyRAJ+g1v6diI5AekijVWJqaQFUXufbLa3rhoJitNvaxx0iUWvt80E8YuHteA7yffLsVN80L5WL1emMyCQI8YLd0YsDuZ2kfdOcKHQYvJnKz6hZcc4IXyMQ4kcwBYlrfVmYDu2XJLWgYIzjvE55OD0mZO3HmzzVzvhlMf2jVQRQ6v9tuWkiOtyhHxOZL56mJlXASfNUtJ8/KpOAfFraMHimzFWNEPkmDAg+eTzqeSE8ejsoP9ZQ6it2w+Zg/bby97+ej6RvWDbUBiv2cv3wWJQCc0MYl++xefrCy3Ns3ktywAiA0oLOD/iSuwxSnDLMmGWCADb8wDnBc2eyJu+4vPgse+RJWRex7jnXOKSYZNmRZqJOU5TDL29XXZPF6PjEmAJHVG4iPHxtFC3yokCMsRas+OOIOROxu+tA6a2TK0alx807MbRx42YXMTZ89bsHYJ8dS7oIxHlqXeAmzIQEvoLRI5D3cg723APngHOuj0THmLcKLJRZ+6ENmj1hDX8azBqZrck9ZX8a9x8dl/2Mp7nuZBaa7523RUD21o4HjgICWtacBJ1SD+JvgAV1uafamntCd4Eacqizwl/TnJVZ/LiXljKRUVairEgVoY9ZLh7NPJvuSp5i9jlSliBTu90fCyHB8U9mPnTRwPyqLWYi5e7LNRMp6ZPu7PWuLNZ0mLiamMCVs6v4iGclXWDUBtkx3DHNG0nmUx1HeIAXQBZmh1Ta3eLVN0FwxFnypMoad7nqlxemw7+aOWNdOcF0xfkiukfhKlIPmXbaZWyoPTtO5sSKRYU1EB5iIrQmYnLQ5je7Qo+ayrewCbgFkMxsG2f9PdQt3sEw6eAGEr/hHYNnGnSlHenUoQDsm0kgnX+Vp96aPaHDMBDjVQ4FyDwtmppoCa8WUUySb+tc+3P77T3Xw2wXtiLj7gkHWyiP4k2dY8/Q4CJYa44TFaZQbjt8lFt7qGURDsZ6RidWAQa39f5ZtnWZ7dHmfjqgqNVhwnJwcs5U9uzyD6qI60TWQwr46l4MnRxaFtc8xy3Q/x2gS96qC54REstPy/P+a5S9uJ/wM6+7cGa2adJbSZL8CPjODeiHKwdo5r6fwGLYn+PP9c3FVcnXkSwQTuLhh5DTNwQ+X1n6+36xN1eKOWIS5ncdstIh59iqhgLavqpWLKP5i25fVAbDir6ylwGexkMHGDjKppHTmiFL6HwrpROtL+mnnOXy4M2e92wcKTaHnsnh8RFF/46jrYnr0WdJVMMuGnNkVth7tck0oBb9OtjSHR3jfpnHJCd7tGpznoJHM/JBem6aGSx5ERz1gZ3k9VgO3+qhIgzwKCCpLH9a1epX5u0MeB/0X01RSrzpDc7+gLZAhR1Z7q1q9mat76MB5Amm33YkgNi4LtI9GUXi1ONvTN+xjBFgxzN2Yco7TUMXQpIjc7DOmZurqxqp5Nr/g39zwHWAVAR4oeUSYIhoItO/EkDlqdVxrQIwt2tAKMti9tdCmy218pP3ZeZzo9mmvdz35ZRFbreHxkR4YDtLrEIcYrrASdIf42aABx5YWzaeNs8759qGI/LvbIMlHrKFiZZXIHkpLHb8T061ps7ty9K3Jn+XiVtgg7p+o42migMGTL9F/ozo1kZPz2hMaIyvL2sgVGG95rstLu4YncOXsQBY53wZwYOFbFL1dE4PqF35rch3MJ5FgUoOAopeT5JPiQ992WuSm2r7BbMZJ3A9dmQMGwJ2EaoYbliu9Fmpo9jglrMnJnFpe2lt7tuOWUJlMJYkUZ76v1soBq5axKSYulPiWqIQYIglX6UFTdpcz9aXlLkOn0g6/mN2xwooIBqsFoVqEGc6zjqr5U97L554P5Uhhqrr6FiURN/1w8++Vx5ihWKtYgtIMhsts64EV2CwOl9+a7j5dGcObYhy3g7JcfQNinvl7QE4QGV8Ujt7QY1jHYEhAzuqMEkn5x3+aezLVAt9oI3W1Bfp0ow5y3Wcj3jBO5kRRdClK2Y2HiFc1TodC0uBIWVp1u2OJRMf2etT8HuEgWdK63ufZC7kS/+4x0G1aViFnGRx9nbTAJLb/giDzTWSyvU3dJsf2ucw1AJx2L9+AWPMwhBGuQul/+8K/vjfQLhFhRj9Frxv4lU+2vg4bjkogmZrQsqkVzctRYtGwM5VhZtp+16ULGQKi/4rfK1kS1NU5QZMxmtgpQ0AfljXqAPzF5zT+i8l4jHwE2mkklLJq0zXIp0T0IuFIqa9ngT6rrjb/fA3DSyxttNiif/IaoLWkYPQ8TwctpAlg3t2kjdVZecmz32Ekf4NLvgIHnu52RPfvhsny598/ceRluqSMoK5IHgKeSzPtdeQ3+KTwkCfvrYGP697hvlCEhIMfHSt0MKaub1emAp6Vk3jLWKxeEGwp87iFtM0+TTTrz+Xd2cDruP5GN2n1FaOm8MDAqet+utVUD27ICPxGoy0wWYm138cOqW9hiiBOOdHfZmnPWTwRM2YsjoBDmygKeadygWgOaFaaTUgs6UgBN8clwjCwR/3QANB402rlA4gaz7GEFhKywmM+oo/BxMHkrEfGGiWcv/LYNj5kGlLYPLU94AJ2DfmdQLb5bUWolnRhU8kVzMGq5/eHLC05P5gvxDb+byuO6vfJ0YSdygU/LrGyRg+d/x9B6E0ZHj3s+Dg6tWqA03/sPGEjtyvHHjR6mZTnm8zYjraYVNtEbYvwzD/Dugk/JdnD2sStG0+S8Z3jhRbyplPA1TnC9SD7tcGWI86l25J3FiQtuuls3iYf72kAs2DZGaEMwJXyBimdVOh/LUuWqQYoKFMsWVxRyqcPZXu2FAnN4zOBxrg2RjuQ4rVWNCA8vfxtOXdBhsrVuZ6s7JJF3lXOTtc6y1/r8oTvl2ZzNOPcQOHIukN6s2dDJI/77pk9szAxzNWjabvn9cQ6+eDwf7ykCdnTisdUODAd9/zL3/lpA74ADJlY0BWh1FVKzlBAZa1K7WZ82YTVcAmWFEoBe67Ng0Sd7wWA/0X1PHOBYwtVnZUyjyH83HuqmGMTGqz6hmfFhIHnEd9Sd/x4oOq7REIe/rUqjOE5OR39fqWFkAtLFvWUva1anblxSkcXi0NOT/xYDlqd52VeB0gjTuMJNdMCIqs+D1XcvjpnKxJDE+bzLrEA6qosIt42xJJ5k+rR3cSgzPuY30Q+D5yRdMy2bmfLWGEvhrEW04eMbNanx+iP96kr90HZBW4MkOB+HkjEP9Y2WNANeckL790qPJw2CfKJ1tsBPTgB7/rQmoM1jhu9dyzvCQf4dLS00jNwWhoe7MX95/ESUgWH9F+aW7zkW+7N7F4Yxhg4VIepQc2DWvOtECkFZRXVfuOD7u+QUvjDGNyz+VNlx4IChGmT47hFyTCWsWXt3ckSie/XNNoFqb8q3atbYeV6ox9BO7RhgEBrzV7RLpOs7eUb6CX7NSGkr3tH+h1tSwJ4DjKN7yVYrwnzfadpdkOBrgB/nsEpvISqZqHLF4FwR9e0sgr6tj0AGis1L5nB9wh9RBRCvvmb/rvK+EBsr7LKQlJ23RAwgCtZTce7/g1dqIHttjRh/mEwC8vDpjTg3rw7S95oO8rYgt3uvCdWGib3axi19/ZzqiQxnQzenmEDxQttHHoiAppKIhsqyr39UU6WEurNzRLdNh2AAYu59ffFFEqPG/fO6/9cntOyI7+6BxMoP4PiTog00cqNnPmdFopnhMVw+bB2S3x5pKMxKoazs7gb0oJaLRGiOYg+S/piMpjOUtEnKFEuS1tHuFBO1CKj3Fr7aUeA/ioFgkUMOejOY926T2aJfiFLimDEMmkDLQCi6Mt6ytCySh3mqQ96qKpr4R+loGZ1s0hsM00OstlbUXHo0nuFApZ04PPY30/che75IzFgRU8pyw5RnXVQZ0mlQRjxeYUeNuyvbD7CRSWVs91AvlGMQ5vR5U9MQVWUGZBdAKrAmH8af9U2k5JON0iYpS7JK8KzpohyaHRhuHX8YwN28xzuJM73FW2OhDeL6V7ifk0Axs2FrIEtgXZEwS3eH6XlYDYGnLA993XspaadrqKcPJKUsPe7uwchG7iw5vSLY5PT3AJYdtHKrVUEiUp/HQOevim+F2Xlt9TYWHcKM65Y6c7NGYYlawr6Da83wLfBz5Z1TYWWohk2akdhOY8FUnTh8eCeRmraNO2+yL4Da0nsbJx0jGsvCfssG3UeTfPj0oT/u1FzT/s/k+Q5CGOIHuOzT4xdmr8Xl+wJiKdrTti+WZ8EMyWNH7An4b69JHgs5b1+3w3Zebtd8j6QcmKDPu770H5Sbt5q2e69XYM3o4CU5zElGBWXNJQ0cK0Gsh+6xI0Tj9SbZcA/4/H3A8TWx1DzrUpiUjmviy57aL9e/6018jlvfO12NRX9daqoDBwdPjgD7oAeqHwe78URF1YuWV0SHkETfv4rwNVMSm/yNId0GciRcSGgbv3Xy4W0nUUHv8pCSgrBt2AmPwdBVdJRiFTR5DG/2rPgMZI0WltOmq3ol0XVuFwl6XuQnYDTo82SBMpPQCEsKYgyUydgygSq3C72R04yR13c+nuvi127V90u0H2PXrOOdLx8Y8nNtPD6bTk3t6QsW9KpvXrISOF0YjaTkuTFl7yqxUpzoi2/i0Qx4hucyQEmNlKE4gD0hb1a3p9KNjdzHLiokuSQCQD1+3FX3u0yH/GPTjsWjx0i6LzG71kNGxR8QJ3HOCwxbqO6lCuEDRTIjSPBkX3W7BAo0pkZhgp1FQ1as3I5jmfwieZ8xccSwhDmyDNyA2lboZpRmdg2rQnXgEYiF7I3GRwygZi4ttToL3H8XKCIk9x9w1f0Smsag8CNpAj/TlMr8TsCAKFsWvoxfMHDoVwsoAExDLg7KarZBjdhhhQNSPRhvuF+HHegD1ttfzOfgDEsvUEOCRvKMu/jZS46pwkjzTVVJkr/jZMGZVYFwJUfuePpSIg21yJgAEn3727QWW256p5B/LubgeWrSTuT/8dzkJsxr9Bh0I6Zvw/CVeoUOX2BAAzNKft5bqPX5WHS1Ac4OH8E9+2Gz3romwY/m9kSUjp00pXji4Mm4iWrbQjKIN8To1Aqk0JP00qXbNVCAFGxrJaL8AuXQQPszA/YXXz0JjWWme269yLKxCQKtLfTcmUd2uXM+gCv4gJK4fPlTHnpeHcTNuy8m2m/6qTPLh08wkasSnel689LrMgQyKY0v8PJ148Ih06BbLiwq5HTJOWpp4kvt4UXWakR/Kaum40W7EGM3+vgWO69YIN6+dMdDVbQLe4ASis6ZHHLGuQgjUtjIMuYiJQu0RN07vh/uQ4xZxboRGKjiQbbPkXD0vJ+/MYf4dGWAbkV1UZ/aqsZlV/6Tj4VYo+4hNkYdluWkOCUxp0UZNpgFe6kScxK8YCorvwENK1GvbrH/9eNUYrOgzCM7eLa6KkdPEbyxCs2MN6fqZtjPGOf253BXlHjjJPQqsctmYpdD5V5RbnhHIs6ofFNihW/O5IVrXWGM6mmlMFsCRhZejnRUNyoo9MldkpcY7hS/l7AD20Ys/p2fD7lN0bV7IbAPkIVhUie806I6QkUx40IGSZOZh+xRQ/14OGJw/mjsuCK12X5xg4GCpz9riMr0r82dUvouQDgj9QYVogf+dZYJ5P6MmnAirEPrgMSbd7rBSEqgnKVBCc0ZRVG6BmvI/Nh7nK6Vv7lvCzGe7T0dIaoPKWUBDi3fPkscJlMcdG2Co12mPpJBeAuk4grfuMlvRPsImDUHVv81VM5lNGza4iuIKxcDEm/y9mRM3KVLMPqOY9eRXuMD0++NvuxSpZEffxNh0kMlcvqC1HDIPX97WSzniSx+z6PzTe5kjw2Kv1oV0JOTcboDulryJM7rPGGqwLzp37vDD71D2JG+bzgu9FbEUsEHts2Z2npewv6DMLhKOwCSAHjFADEJpOanE/XrYeb1smX53aGnzkOSa+gsht4jXA/pxj5cLO4ixeD7jv+O//FXUsneeeWABA/9Wvxog1N350gmho8OCLZxouHrjNkmaWyBD+vYV8fWrT3w+YVu77Lv2uuZMPQj/HjIuVLYRbXrdHp0RgvBjNXiG4QDK+foxNSsca/zd3lZCSE6v1Hc/2JFGMl77djc2mWEv8jM0B67qjQufZD+D3gZlJDRDCGa2hTWyvehBryg23SYhScxGx6Nojio8Qn03Ln7sI2X65E1ASDzZqLtC77pKtxBtMotxbSUiWIo8t/kWhoVyJa/Mwz1UVNxSWBl1/KIvdaczMiUd0THj+KCfrLO/Wq8tf59YnM8MuaWyaC8cjjuhc+V8FIBeF92ZPZtSOpR26cAoJA5hzDkNEXBSCU9fNd9fQAx5SWbNx7r/x3WPiRVTbq90n8vBpajgfVBsK8LQKfYNerxR5KB479QPhtHIzfR6PBQbgZU1D1rJ5hUb6a9/fjCgxAAI7XKQGcyt81GUmwrfn4l6lvUm5+p/g25X2R45Ka7RkRkQUsDNT8lDtfaarLlUV+AYSWSQ5EJXDsgueyVRlfmIYXEhvcU1JPItrlSsTawCYPOafV6xslr5tcEUqRCeHq7zTNTJJ7k/tJvXW9PJzbicyTvIDeEQc7bpvBrWvwtUN1GycCOHpTrILMNCz8eka7uZz4Rf1/EMHaSvBj1D7F1gUSot8hMsaxDmjGQOUl1ScLVr4rcLHq0WG0H5CmKafgRWh0yw18BYcTOQ6j0CjoJPwYGfSuzb/qV4wJwMBz3z2ZKcOVHWl5k1nCKsUzzsrS4F+LbJRiqMlDN99/cloHSxPP0VjHPZg8VMqHLftBywTC3jAa4mm61f9U1fwYquXRNz2jV8IjHGYcy5vyMTi3DCKl4xQo5jDKFlwXPn40jQdJNiNwH55COnw5R93HN2llodqdWQXNBxsG3etLZhWf1znqGGm3rmMeh3o9yXalnK/uuv8Lf6wSZael2QHXh5fEWwyOyNmUKkZX2+K5HjddPoT7EWAGhv2hq55aIV5qCgaY3ArFtsn6Z6h8AIeim5L7GCuIyxOOwddncUPRAzuMblVjyENgCt1z/Sr5UgcU0y0hYeYNHRQ5s2cMDWXBml8d+CErH0lwqrZniEokvwW9JWXR+JN4cQsBSCyj6fp3ZceBIQ6Kuc4Tbzp+QPcMc1NG15vlOU0fHXyEjYjGvFfkFDyskSo+p6cI4nZ9Zc9QcTZHzNgcaUXBKUFSYJYngSe+i3JSaSFx7wme5F3ajyBuLq8Nci1a+cufpENd5ezQaIBwVkJC668mmw2gkiKZnDssr5ItrZd5NDZ22QFv0B4hHHYQoZ4rWcL+rcRRKqX/AkKzD9CpVyFlDuTSAfK6cwVPn9OI66gsumtzv63orPE58L69ix+1qXlx3VDo2g/LXaqR+3XEQTnBk7haixoHOTOEYShMhpnos4y63c6miFo6luU2UwHAy0nf3+VDMXANBJGeBuRboxKmeH6aW4NZvaCysEilOyaEN9drTSEZ1YCgf0i0ilbEp1f5Q8sk6x80oSL9EsOgq3x3rH5iUtChIO3BEZqlx5y6p7q6YMsgdN8tobCosRIeNT9/gAgwRn0bVqAhc5SKaTJGJLq4z9GFbAma4CjhJdt0zvNEwJ0Co7L88/kZ/o1wEOslgy44r8niVdaRLazQtldz/0n4esGZUKYmp9tQkn7KYPIwydTRHLwdG1zZw6eJIlVhGJkYJ8GGw1k1TV/QNgGaKXt+gTqU6LT/Mdu/2Xh9J/RUx+KHMzuyQDXT1lJBPva3FTXUlu0RS4pAamk805Sd5tgGGruBunUMcU0RQ85D2qwi9c+x3WOxVmG0CjgV7rP8aTU1EFFXIF3w4NvQ9+K+OOgJ8dGyEvjN6e6Ifh9NzMxNNhjmG5RhyuLos1VAHH+0nJafS4Z8gwJCw9VpUOq4nC4vjL2QOTDQ7ic6YuDzM8Qa8LAkXKDCiBA66ZeCxmLs+NGSEdF+oO7d2UkeftfnpgrAcQMVTd/E8YEdbgEBMsd8BXV19Wm+4ArUXXq8YWdi7AFvEAMJK025XcaUZi4h/Q6Hmji0o+OLUreurKXlpUamarmb+Q1WA3TAKJpGP0+8kdW4OYAAUmGVvkjjawKRhCxWYrTC/yBrK1WAJ8x6b/7al2Arl4LwxcXwxmz0P2HkdGigxGudxhmqfc4w6lVfhLpYwXar78jJBwAGSwOb5/Fte/eGEW4s5srs+VzmFrlUi89lZYLo8AfHziN5pKSzKc6DTpZ7ubc62H49irmnE+JxVJP4ydYTEXUNtSs+avt8h1+k4inl6z5nW7MLBClNvsaLFPmNTgpVvl5yQJ3bxm40mdE36I9+65zXPtUot4xfEmxOQ/3kDCSESEgRe9OGdgokkWiNMfGtkAyG9HycNzCYy9S8McN3jgYPplGBrt1Zz0vn52l6UepafwztdjicWGtcFFx6pJLkQnRWKKfBnNHLDbyKJtj2wHOiPX66jT5XUy3nxzrlo7RZs8n8GvTK/rf1YePdgcRJ+FYi/mT0mW9PFxGufcHRIzhXKvkKM2iH9uurcrGK5k6+9GD6ooT/P/9MzDt85GT7/pmOKoZ4Br7VwaH4InEPOhrzC4UEAdzAGxUJJy2a0/5cuQdAZWf73y2NoqG+vyJrP5B4I5U6utAWB8Lo0mioa8GHG01rOPcxHkEKd7R1vnTF7bzDb8x4iTCMknUGM1gAOIalJ8OWDLm5yVPmM2mfTo0TznQGPtvmw8LUABz5o0HnKhir7S0KSn1YoNOFfCTUeTNvmBiRMzUm006aXYQ71sNtK1bW1UzMy7/Ta1IfR+dJuPWDHf6WjtfRHRyyBjT0R4SARVRleomd/f2UxhkPebQsSXs/6OG9BreNql0SXp83SOm1dWQ+Jbgr9d8kV0xGbuFPZEq+N7R3ejDWO8pY51A2TKJeg0U1HhxKddKmNPzbn0kwGzT9tGtVpgP4Qfb6o6sfCTlQmtdrX8sptXPRqpNxKz8/Dw6LnYmFjsBTroQtNb0B6ZY+oHGrYigkPMJdokDVAa7CqVTsc/JRrI+rb/ZthR5gQ3Mw+F5lPdJv+xR5NdiGfJXBlLKpUrlPvFD7lTy5BERlN1AIku2PZw/1EOjfpInV4bADiG0JCjNx7C8glnt80Ubb9m8DkwH6lwsWNZRX8ObbsUvC0iudq/bzgkA7EY0nutVXhGXsGauknZOoG+di+0UbWnwWBIw6LM75zMz2QfDI4tOhHIGJnJWtaTkHki162YB4WTyfPFuE/7D8sgoe3AQ8xa0yyD+VeE1uCjMQBqBirBuIOcG4mA7or6K64OT10UQ7GTO546U/3RU1XC4FszcPFNDREUB7VAcxOs+qz2FZKQK/BxvLR9az8GqzrPJ/QRwMc8FgFb2hhCd2gu22bZwaL3lSj95J40SfA/D1JCFPzvyHH6VxdIoBMtCJJZAYxxX69FbJ20BTkZ/9c++8sF+KCGowSn2RXi7eqvxUhsIKMO+wMB17CeYSN/hoVVScqm88xBrn6vZab45F4Txh550OyoIQBn6VmpCnm5J4WIoJ/FHCVDF62zSVS3YkgQfbl8Y+/+iVTRZyWkVoqOiFM1grb76D+Xokd7aVwk3qKklm94e1bIvEOtWiAKKXLMgGKF9LXE1JYR3HgKxRP3muGR+ygGnNkXkvDJ856LFHXFCdzS+oh4U/xNzqRHwmAMf5OEZitok40Fftbp3in/Aa0GD4L+gQDTTCCSxghn2/R6QpspX2gDl5Xbzf64vvl2Bpcli0Pggqfn15W7M42G95igwpUx6d3a7Q4oaqJo+zi5qb0NLDPwNTi2Vuy0rT7tRiJ7Uo3XKmFEH9Kxx/xYjIgeZ+pzoGJoELu7QJqfCNx0KivU4jyqrLHgsNMd2mYjSTwd8bOGMUILCekPJy4DxnrZ08QBhkLd7JxQp5grN+z6gGue/IreZFHv2+u42ghj68U40pavmMVNKRIMGamEt0bxOBQRDsvhpxrPynElM0/BUOcorzRg3IsYpGlXffFLCpzIqgq/xycpLdMiIYswXfUWnuFo+6B47ttjRDXEVZDQk/UMKE5pX2ZrnzUOKMvm/z08smGK7EvxX3GbjJNOsarSuU83SI712mJAH+7WBGwdP7V8fL7egliIBZUvkO+GDLAp+DN/YdevKg47p0glIy7bKRreCnP510FQXpYG6IB9wzmnldqbqA5VuBklJHvhdjos+RtgxTuWeuLbuc8894hpz5ce3Mx5jh4tXyLK1ut3WLKsBL1e+9EysDl4xcqbilZyg6YqNZJ+yEet4F3xYghFbUJz+xuaK4KWNbD2KYyF0fpoG0y7xj9wpg15sx+erbfEfxIC8YnEY4e1s1MbGYZddkCRgepo3EygzidNJvfDvUUhD3rl7RqkKlQTbs/A4RVgH3vtLOO71BXEcSFl21vOf6Y/dJWzkH31pXGG0XzvfYpCXIAZYPOhTFhrb1eWqP7IJiU6CidSIDxXUVFbER+nHCRVSb/3T+yuujddueJeRNa1Yp3wmmvDIyWDr/hyHuprBXRZ7hJz5DSQ0KxDu/ubELRevB91yjui4xE0RI4S/Lha9/RMkW8HgEjg/FPGLDYWwiG71vfpiUpHYTic90SFU6E/YcDpWb8kDY6Xwz9CO+VZBu8PjfpLcPhL28vWI/IrdAMw9EdMVOut7kDwJAm7UEoWocH4yVtHnFDhNghM3YVrCvZe3E8pmJPIXnPe8Zw1HcGr2iFYND0ZAuuxo8hoD6LiqCuwDeqs5ef5yiNkJafYCE0PHbuq7Xi9I5Brj4EFVk2ceJQgjmLrP5Dbijwx6CsYNu6laUMciP+R5a8RY0nnvO7rOZGOaInn6WgQ/C4lhfWq2U3XW5FTqmmjF1pCxMhVymcsA4H5x0hARawkB0i3DRDtoPPrQqFchfeE6hd07pxGLlnIL3vgN47XFPWbIw4XJ507RSvjXxUnUzEnK5PJT21pZ4X9pXTmIb1+3MUXUwFlDRU0weGfK02uhSZoBGiTqjU2WOkEFhG+Q5YcFi9bDM2/Ffrir+zL1MLzah6IcGdvfal7LH9B7D9hlSJYzInpA6JXp7Ae8DXjocCViqKlH3/FuzRUyH+ncks232AuP4bgZMX1U/FLPo8Sn619gqpDzp0kDQz6kYPneOjYAKkoM0Qkx/Tn+gdok5P6gExFZ36wVutUbhz9vn/lT4EjvhPk5ppAc5cF776F3lf0KNchv6DwWCPVg8hMxzYrRDH3yhzmb+/BYjnQaNf1tKz8t60+oyQ+BJr7/D8bSKN279fdadmWlwN0KH0eyFI9rFrHfcdb/gDhhjrRL6I07C0DH+85FS8djwqiyK4RfGcY26tfL0aS8LdUfXEZBDTkfV0wgKVvfh5C2o6W+g6q19fYgf0HZOP9oFKRdCzGZXm7zhKFvD/F8UbRtHGpymjpG1L3StWwPBm8nG/5UzqeecXP7RK/FiFIJ8TKOvaJQayuwb4HPbOw20Ag65F4O7t7NxWBKFZmLFOgUdQ9KpKIZsJiKU4lBgv/krTwdcQJkJVV9ZOWZSeh5DSmMTGkIUdcHX7CdOQ2EXXMzenGCaQTV9lRNlOLiDjzQ3LiWVvOgcVZmCHOMzJbJjFmqTKKyGAZ9qheEeBaGATE+H4bjv+TkcWssAq5GAYtGERBWmBTGm5K8RVgKWPffCiiTVeCFJh78Jkha4pHA59TLttklXBeDjIsvh9x3k3vM3qbdWfBeYFEsffPhwyQf8uHfXvempDy5rKivmPqeRiYA9PpfistIg/yl9b4MErLZeAHn8B0Up1w6HBbPGAOPzYm4smVMGZilN3eHJinVv5GE5xwrgB+OiGuReT8hA8H6WvSv4E2Z27J+VKFMDdiOigkdNaQNnDCB3g2dRfpb7NAfDA2C4PTRCP3HgVtxsrH9D2MpuGJ8Zl2Q7s+A5XiW08mQDIoi8iNbx/FPhBHfvFA3an+PNXjY9Isb76FusLqEtcB4bup9S3Id+WxoR4fHMheItm1u49eavvuDtdGDiOt6I55DAtOFHcvb0ML5YyEBs7oqTTUM+LIKRwiMGa9eoTEd2cMXiY+tZiNd0iqDMTNTZ+Zy1f2D3JxCN1+VW8WDMxegU6eKTXXYPfeNx79ayAAc6WML3Qhtyb00vH3uzVktQqcQ1S50Ij6UMkadEIdOPP++AZBd5C9PlqRLu6vrvVSxJLQpz6faxTaKoA672ME3+NkIDYel73tqPe7ZIW2qGuav3vDEztFrn8gAV6ZOC5ZV+LH7Xi1zew7+v0nkJejFTkBQu2CayJe+f7rZIZU+Wtz0kUPOKzvKgvASV7PvP2WjLSwONKvRavAMOanh24b7OCPFpUGmRIrKyH/wAaCvsxyg0TSz0Z8B+usl4ZGMCHaQhduG0PBL7gLPH1wdIt0KWpuR2p8JeckwLKyHUdb4SDhiXEQkVV1Ayg3q5u6nAyLlq6x7k8CTYon2IxoEaomUMbBP8lh9NsatZWEWLX3knjx4ikUQn38eL4/eK9FD5Ygl05zNP1Qn2GBk+QBgJThwMzGPbn0JWwS8j9odSYY/1Tc9DQMoX3qXZgI4oo2JGKEyapomrE10iaASz6l6yNfc+NDGOJYdW0AU8yZy2CNz+VerY008cvgohcbY67j5KhnLPR3EW9BFkwTSkDfPGusbrZMD4U5SKcHFcxj4Ch8c3nTU+Jx0EiPHIeYgYkPq5h6no1w/FvV0zLOWEB8q1rqVfpyap5HS5oa6oqL5aBS+TeS0mjXMWCxMCG2IPvIzyKe0mi/pN7pmeA35HpVb22h54R39amqyne70OrJj6a8w+IZZIiR/3oXCEJ/h4G7LtMVA6sGfKRZjpq6LUdRavfyY9YCqQirtmTLi60Y2KYXHRxYuVPY1hFTYrrsEyPvweqiOFg01eA3uRzgSfNFeY/RqWU/qhWh6tcG+VpANJrQM+oY8OKr4iLDLOhAWhgabnZmxH+9RJjcrw6USuqMZZU9Wibhwk8wAgVi5hWNVgP2sB0n94YT1kbQBaZ44XCdOOAWNoM0ZGzPT8X5PE8VK4wILE/anGchELP91eMRPs2e5BqdN7KDa+eXMjr0DRvoG5C1BhVamcQpa08k4xwLMDPnfcdeHvYLXdDbmDuWoccuIZX6YqJ0a+gx44tFbIORyBSH/Zrd/w5V3RKg+UqNnUKoLkOQYOnotMvIukZ9yb6F6n2jLVdoAFt+vlP+roxHtUPAHnRSbehleYWErOqYQDhexd1N8w8/dd+UWlsVcSEb0cR2z+d+yDiOHKfBAMoUcguhJoDhxzOJ+q7XicftY2jplHTholYuW///x5wRE24m/KFojTodnlEc2NbcFnCtPgVOMk0S+rrLswaDfKQr2N64PC9gUSWqW2Zxnt6hWRTUdaY81DY8sgDSn4g5yKqpWvx10YHu93eGeHPoq8ei2Wcg9wGdcJ8nDDakGCoqddb1qMglaPQyWdjrm6IX5YyrlIkX4d8j9G1ljurIt2vdbiyWrZsHdkFCQEC0DstqbedarlYvqD7b+afqWiTsL1j3kM17naiL4duFG52g+M74e2ZIBFsECTkJraARLbwOYm9yyaAO9GsVrEW8iQKvrNXsTTT5D8n+qL65w19Wn7IogVQVm3pT5wvHLN3TbogkU92KFdoF0EZE8gbjNE1aymnkT6+AarNKrPqa1Z2Xw2eedonaH/p2usiuXrv++sjV0r3DGrrpkfeRuG3KwNKV1NQB9o765J3EFuBimNyixkCLMGaGrrgaC4s/c9tBWfCjyZDFBVgERIjpHrxhOU8CRqr35R1ho5AU1XMZyqka2u4qfklCSOJc7uUg/5wksJ5ssi3C74Wf+OhYdoxd3qDi0A12yoBpSBFomG0Bsg5fjQFL/5mqZgERE5BaDoKuecpEYlrI/CEqq+USeN5G9U10DhBltT4Q5Yf+wPrZdgTvUdEhpOfMAxHJPpFYw/TUZoZBK1YT585+vvDhnL5PqQl6z8Jyghvp30XWM3lfYsu2fUVZxNyt2lcKtpeXnSz6rwBMILgiQNaVTyXBtrZHc7x2CG7hqI9v9hRgdKy7fEpJPhWNiZuU+o63dVkC72g/zv0D70XGOY40V+/GSnZnlVVllTig/jZs3RKtrQzHCCjKhPnYJvGxo7vXgoI3vE9oKp6a17qa7kplN/0tT73gNkHPa3APzj4XZMn8knHpZPY1kav/yay0+w8Gq1y2L+kLSJmjVean1z3PG+mGFq09f4FjSMNeNzISUZOPJgW8fTaIeODGbt1kB/cZxVYLxnCqK2gT2krQ130SAJxbbR4m78nH8K1XD541s2D0+eSrASKRnHAld/0huQeh6cInWIZui7Hf5UKRR7GGGvLGuSIGW79Bh3oqfCZnTGv9R3d9DlpAPd6bfrlkImXgNI65IoXWAjvttiFhzFa4Qn9pPLdSHFXBb/gTVL4LStI6Ou4nNz05SaXjRYmEjCezolczWc8y6KOcNNtX3pDgu0bHK4XYh2Mh18zEj+4O98Am6r4dKdbILZRxi/r52Tyr3SrvggiBYlZ7ojbBX+JyUY7WOt9OR34Ngria8jwzJTnCOXo8q3OpEKzhzt9Yw/Db0F4Uo6ssejP/jYJiTegUZBBnh1gyjoZg74JYwYTAKmBeLZLJD2+MPhGGxd4wy50aYefPkfZIhmcBphRKB++KtWzsF1bKZTu3Z7n3resFeIFMyJzAJM1rhqDJ8oJJt+x613jBMxAzE7IgQzTlRiMRHLd2h5FhVkqdwFsy40OZeiO4HYUBP7nfNkhQx0Vep+FSpYPTwGPttvvLM9GVajlGcbyw2wpN18chpVa1G2npeY60W3X0FGrP8xmzbV6FPv5l9EpjqzQj+reWKrACRrUQpWF4Jej/GtYUsuE+TUx9JFo/h3i4FjpGtwYbF0cdsUkkCgq2dOGVOc1lByeKomGTBcFrteDjkTjz5MoX0GLy5giCXEBH0aeC27oqjLATFNxVtUasl/0xWkqpKQFbav/lXGh1cv0gpDeGC2El9PHKMXsXAPXmEe7TUska96zx9n0SN4djxvnc+IlmR1D3jbsbddW0gj2XovbXJk7qFm00C1jwT6L8hSkZ+UkEDAcJoRdK1c4deaNDnsv1A9rukyXNVvhwzmGsAnpC+M4r38Ikm+alW8oRKkkcUFyjajYy0DPL4sW3pPe1C45d5GVfBxhOqUP7VgdBLuNR3a6wFdv4gk8xu5wT77xQPU8XlXka6wJPmGh40vVItj+chAJ6Yd3vgYYOR6NuyjwswW5KovSZ/8Wn6UHvTqtEgxVCF9Dufy/eDoWXkKmRqyaW9xjrxUTc2YrloJLIhGhg3gLmd/vKPm1ksQX1GJlId0Z3IiIQlmKZkch4rcHg+c7K6cHFJWOBRHcJEewV+ao9TZrOqxmJ4ETSH5gUY9ePG/Lbj3/W2sBsIKQqZhCO6+/o4VjwTiOawYAMBgEw1NTKqTONwBSUYAD3g+YjnulAGrnAf/kjuWgPTJ96bzoggX2H2cGTUUo4fN6ufY5uiF+wr6sutmeUSAR1FHHBuBsxJnaD65Rd42FTExCrrEpc0uQswigP9emGFiJm3KWNfoW6AUjG8iaVYxxqNyHZaNFEly2E4lpWoaEWx11GU4u28gzwyEC3YTk149d5J5OecguaRDDsAoBGJAuwq+rUHSON2jvk/vfE17MGFhl+0lBjhcYFmcvbnt+EmSkTR2DCgXSdZoiRsMFO2kzwB71XkLGv9UKqYYAHhg3MxRedJ1z0YCQdlmzt0Du/aAIxOLW4xJn9VjXe8GImtzO7HNQhluu4b4LNOIl2qHIv13N7LRcNzhaKQY/etNdcKttk6yIPomQ/0Rc1VHpWe/UMxSi+M51avJYqtnU2QXs8hJL1rvvhbCNoRNNfdm/YhDWjL/Lx33xN05Hvom3DLn0O7JyJYwVm72V+pRlzwfHky2y99vyRx/WkM2tFNDCAoFEaQRtfdED3/A8nngboeo0Dy+9y28F7AlV8b8ClpF+rmS/hlUNq9fbQOAq1d3RaaqRIV5HVeL09tkRICycQu+5KN+iM/hwuIeAJew1e6bCd+GM4BlSwmk1WvrfOAuMlgbgOZHvVTG2A0lZJg+hw9TVUCw4BqzbAsu77QRJHFEnAr0E+Fk3fKQnPoUvu8Xq+Y9w5PQ8/ywzXeFwzkuo0f0E+0XQkOmJ43id55Z6aW6ThLGC/2T3algSuyTnb4S5xbdcmfQVzDzprtsp5MoZRmgWqjkbDtVs8vGjNeUm2mr4eeLZT3eSHOYEQi+vw6MC3ri/sgR9cyE+y7Fl3OkQNKa+0Hk6xNebY4sPhL1m+qqrETyEtQRL2veQBIbcdZp2mrmkUV+giZr2W1mFC1bDHF9TL11UP2ssVTCvCukv6jUT8+NWUJAUK3FSuOfT2QVTCd0Wsg5kz21C1NuPzllwK5cMqq9itoXqBuZMECKYLtSPSdN6ppHgAdK+7jsEEu0OK/xBFRkmicC6qNKU5uoWSG+0nBOxKDGWKHQ2gbJ98gihza4fF3pBBRk2XwPt72FbN5rETd2quw3rbGjySqcvU9up/s/+7wl9UThZb7VGG50JVHi5P7fkBzY4xHkAWmZ933bVgvjKBNDjm7qvXiz4ndA351WwR9piOzqyA8Mf+qYtioYd0qBpsOkdDpY9oZIoWZD/+mBGSZDzDt/vxQEQrhVwgJRP/LIJHZqjAXfkm8GflhvMPmaAC1w5ttl2wLUL2AsarXhxrz1NnNEd/i/Egou+1HfP/aMzD3RXxrLkAmwKYqP6BJW+e3o9Q5gMjmG+PneBVW/qPfG1oD4hZLzcSup4oexSQ+nReW6zbE+RfbroYAXe87JeAG5N4ZmQTyPwNSpSADk7LVSo9bFQIiwWL/nHJtztnOnfvD872wUIF+lPdOldxsD97xFX8dYBksQrAFAIEjR6y+DpUALKprV5cQIVhhVqmbqYPDF/i14yQEnttK0p5GEMp1UhgQEdNeZfyaqs10lijSzMnLrQQgLhMh3BRU2lhNXIWEwEVhTaP+D266QUvb//dkKzCXGNC2I6tf5HqHWHzzvOjwCKJ0IKl7LXynLEorlwfDCt2AhXfI3PZb6QsOlfvofLSEwx4fYHTF1e/LMpAoTG8RBLRGUTqMsDlj30fSIvQPavIn9LkSWktz9iOQJ/niCUspyvfl2ZPr27gRLUB9x8CrNM+VnS0WJWz+VX27Q2C0/vjD4QOPrusKzDWsRsMJVMMQB3201c+jflfYGBCKOPTVkXTZIUr7ENQLoqjda88BS6pDuhjv0Lz8y1Xb8Rsbw8xPAdk1eYjGBi59a4n38no3Hlr4jK+6AOuDpHC+SYGSKPb0Xs++bk8potv5AQci8OBfRLWLZjkFInSV0Vj8InzQvzBZ2a0pdHwvqNgLAwVJ5GKEn6+lW8nhw5/gzcP3q2351ejsrm34+Yv2KT+NCHhAiPxlk7g4R8aAUsDZ4WYmQF5R2yW2JQ4If+WWDlyv2IJIsU07aO40ggeORCC5+UGKKRNHa0YAsDGI1q0MwETwxp/G6JqEHL1ShgoY/g+cUKj5kwYdgf10N3ZgyvDnypZfco/r/Nt+V8szBU6a08XLbB9Cn5St7ZDjJtPJizSSFFwA4xBzaIwed0nAPg5OfogT2n8wGMvSCiINC6HifjoTnGkdjh++quL0hkmM2cRk/6yAm6v8TwoYwcj5GFwmhj8iPHd0ZfK/PTZVNWpYjnrztsqYF3XvyRWgQ4FrsqsvEjX2P6wtxPQl8baw5AU2+FLpdhylBekFuTV9tTNIT1LL+lNy7WcnPfowA5gQyxnoWiCuSwlFPjx8lmlaHFbTFaRQrXtC/oWG3PM08wXo/LU1AeBmPzEQRa+vwH2MqwG1zFrKsh4MD6lE8tfSNOXBRVDtM8493xkUDwspcD84athLcNZ/Pv2UUTYqgJ3UQa3oBRifhqp7PxHL1v12iyDniVx5R36uJ7xCDXY2nRowEn23MzrnGRAyr9OCKRzaQ9APmixcmIqt0ZyyL3JOmbDr5prYes4SuQMdZMJOrna0z5HoB+whvCB7ncuLk0QLUDGP6aIWjLL8nPxqz5Jpfw44SgQ25I1w0NavQNRfQ9YXcXSF6rHBswfniowgxgDZ3t3B0oZyGZ2iIQ478t6jjsNrixXujQlCectrjelOBZP1TjImCVAYoKdtieHAwstpgUmy1OUbMfxpM/pjP0XAt+O/SfoSAvQ1VJk0N4BAE4hF1HvJGEqtz4Ou2O+XlFQlQUxsIt4v7zXQ9y6Icd1ybNHGWn/uG40b/lYACPhLs2fqzFNNql6IyMN+r4p8xY2pv92ZR/TVu/opZZds4Z4TXPNw8xOQPuOXpiFb1cDmXKTI+/0OupnXS5LuMp/2JzTAcNY+D4wRKq8+Nv+4KM6ZS8qbBpe45Wx2xT8VFqXg9+ZCDaPZDlj9Gw6AiKC0u/bFdea+SfjCfADhb+ZV0cajJKZcPog/amEX44Vjdzvf2iwgt8+50pG8Iznm2lDuEvEA0QOw4qg5yXIEvOINKnnxULhNuw70nbxeaM6/epz2LnGMZ1CsQNOmEhHpubH053oizamwq4Q25Ee9KiCqc+0XtRWgx6vXVf6r5Lqvad+CkDlYEXJtq5nje2Vri/2joR3mmicCEaRnqkxHN/P1TcD93wpdUoEQGrRaF5Z/oLRENtVazMRxoAws+x2CuV9DqLxGQ0htwaCMmT5VvSMsmgssQ8JMwGqY7vZyHnAp3ev1Z3mc1KpqaCDqBYKdvpPGtAg1/jiprK+rPcMq4RVLnhe0tLlxlIrvtbFoqDFbJZfUQ6w5EpdQzZYYMD/59amBh8QbM/IiqGlE8CgrKDSmbdsrk0YFFURWREAOMgexFlj8QAKJIo9DBc07wH4okXzCCkBszL5V8esQvD6jfpVsggJYto9o0omHkYmjPL+XUQI05wGThL0ZqzEtg1pHMuUwBx/AHFewCcGB99r1XESWhU9ntu4ABNJVGcirUyNFuEz+5962m3Dncv8VgL0P8QkR2CLLA50qIJYid4KS1tKorwN4igPC5O4vwtCPDfmInTzz3YyksACgZ2RiCwOEihQRuHc4ybE797HCbq1rOhdtcRYmjvt6RRtMx/i1o0sOruROPXeqX9C3b54gvuccznWceFvU+WSa2DIvkcXKN1nlkCO5y7ymBqK2Ml357wqWOFws4vcYCUQucXe6/YH2SxOw5LTpbzcFay3t5JG115jmazuJvCqSPzNt2CLiSu8tyTLEkvq3WpHLk8zzKTHeenkuud9ClKcIwt7c4NRy5ZOoScof8Lv20TLzh3BH+9x+X/a9dtZ+6XFoJJe1xKn9+meZ8aVOvgk2uhMq/MzjoD3arhbnKfc/K0J/I6E+mMo4yKKqKh92vvVWYYTlsrKQvheritBhkysmYQwVE4V0oJ0Tdrf3R+T8FF2bgw+m+rltZgJD3l8DeRtMw00Wz1BlhvPG9nI+WMIiYnqRCxKzSXc8i40raHVAyWrabHNw7K0eFtgCl3lGs4INTswpDJewG1F4+7JP4CNIh6tijAIkrEvDymjPPOeUkgpfuGTt6npL8ox+9+LsNnMHSohFGatqxrHJ8ifC3lxe9G6GEQYp4CnMZaJ6aEjV8pOawmjkZWHfD4OOfyv6kOSoL0/NNz6creZK2FlFJFnN00JtXEq79DbpponLwgSpJ0sM6ZAWlwdG9qszKU1M1lxTxcuRmPXE7D8RiEu+4OPIV/9VSxNnc45VTNdRUj2S6D02G2ULGtfjmMY7NWlrTZIu2L1EN/TM/33AHijFmxIsxUWS+VHbu8EhVCZelexfwqv0wVr1Ia5ly9e2lHjQD0DcnDzmUD5a8VSNDRrwaG440F/X4TM1QVyFjmvjSkA/7Emv78G2RVT3rjsK4GZgpwGzDmYcuYb1kQB2MToWpIivKNE7XRZj/zCsToX53lK3YX7eis4aNw9pPzHbPhoZgtylfPV83YV6GSQ4hnda5I3zyENt2C9sUplO6I7N5DrLP44WA7dJpD0YZR5aGG8IbEHKIQ/U8etckv322ClARnFXQ75d8roOkXZJhAidhTsBCmrEpJaxsKn0EhanLsqHUEULi95cPa28bABspEu9UzIumIP47ndeDG07yKh2MVlTcEZE2f/LF8yJ1JHj3WmX59DUT62tMM6ey1mCy3f/GLYWpweR5+IVY2WM3gpfH4nHngf5Nit0pXDUkvF5veJ7GA6VNxg96ak82u1I5yvQd4+NoMo5skqAaHHIJX+cJT/U5/Qvs5xxrm3awYo187+pmTObfI6cHAxdz1MXIZD1eRL/B4fPrn9tJuzHzZzMMOnstLi7JC649eHteNlKAuuv1JjrnvC4POzbsPQdDVMjcjEA67xyPUkrOuauG+04bRvALw1/LkRmvx/BA7XPannSxybmYBpGVV/yXFsy4WHs3b4u5CdGQ/BkHcgTdVz/762WKrTtwmUYya3laqb5bRCWU27148xjeHyPaNZa1/jup3j7NdUh42KJydAvyFg+a3bJGSkyjqqaftAL+C1AP/HlqPG/Dbnol4upE+fs2suKsqt8ceERbu7jBWADtvY2f9WIuvjuymgZkUp3HFr96RgPP//HNS3v1SqQJ9RZ7A4vnGbNmlREiZytMPG/89VVSIyWJKskeg22xSWNr5+BN1AZM81kRx//XVSO1f3ZiaIsxho5pO2/+xmImg/2sD+rldmnid8GrYwpx/TjCVSg7UgN6NtNNYuRRZ/XTWdNXVa3gKWXfIjspdzOu4HTvbON9JuabRcwQPjC444dAawoO668pXdDTNcwDMG2b/v0ZXWKak/lkX5JTRQVnd7DcDxCP78JZ0M+gv2vYqXcguQRPTLZpp5X8A2htZg0B7ybtD27dWVGSTf3omR/hAUFdD2tNg/TMp7XdfiIYaTcoHIgJpjU46xN6KVPDEM2ybrjiPGbaVl0xTDaKJ6ehnIWn9numH5mpt6yP8Ou0qOX6pZZH2OlrxNdJYfruTH1NK4qVhz1Mir843mgEQrDZtPuWMGwOTcQLaYHHALXVY7aQIV4mOJVL/GWoHHR4GUFfWGHMuenjBfWetkvKnGcUGgvVLGGVAm3rXMkzjg8AnrL0evEnBvZhFiZEHa60YgRl1shZcmwlKCTyKz2PyvnWHgcoyTY/1wvbzLnopA7YFX+3Y+4RNuJEJIydY2sPs/nu7GYU/izlquub1ZrIidQedU1RC5zqUGNTyf2YLSMj57FXVaCXrV3I/6w7r6JBmCncEHyLJaIqDuvSwS3BPmNqGLFHKly0ye5wdGRlPGVU9B9t8gXt4SVm242jaj0XXjWHsuYEOcaolau/t6jdFMCGtRFnCLd0yAEXigHFhY+e8kqsyrv1sNYEzvF/se5s2LbrH8R5xAgRjP3l3Q0w4giwy4IbZnRWL/7gztr1BXnshMTW2G+Sy+cp0VLyFMS2FNtVPx7UpCIZeWkxXVJkdri9JeNGzzQnooCaMpCFSfrt9QJkGBaTB5wrmR4eL9dwjT3FSPIfIQbR07asBrWzJ1Z3KZZjJVM2YGE4ViunSLIQyaykZiYtpPm6mMA3TPCcZuzNwPJ3fqehBx+U/JGHcIjAvHeWEdpI2HcRa7/3FCQHeXJm7GCj9skyFByi2d+dU9W6xmuZq6FIsKz4fbc2tBTd2Go9KZ20DBvOhUYOHkEAMS11Bkxe5PgQT8L8E3AA5PSPEAVPKAvHYzQAZs+n24/e/fYSSAtZ9Q3SvvS4K71MCx6ZnbdBH7vYfkhbyZhN/fx5nvxvAFFKmmltu2HDkODMAjjbSFwedzKEjCktxksQDWhkMvuWM2eVsaLbuZksEPoPoriKqw332Vqnfq3UgStn451iJYr3TsXK+nCUy0ZTov5EOQeLxOjtnug8NPTyaRwE3NWYejUtHdYksNYkrGIcFESuMuNC4xrCflasRGuA6uGHtmjZTSmB3QiUuAlCUmuc8DcVF85yie07iPZTt1HftKIbH+y9ZXfYFSCSMZTa+eeysJ9Zrbz+FHnmUoqH1YxyRwgiahIzPk18cpb6Mh6r21spRP4MGvQcLip4IJxN9ylOnt/BxN+iwt8NsxcWYSjshfCh1tmi8h1G+5UjdeFZ6HGtBU+TdlkdjRlE/mr8DQrQO8F11fL4yKGcgzFlV9alGvV92usGWriqBOgbaW2dkBxRsNu/yUJiYJ6AOn1CjPu/APMj0UtgaTiCa7dDiEd4eYfskKjRklpdGZy/EPIYKL0SHp0mBS7ZMTR5BbLnCCR7K0JIA2s0JRyKsb1R1WeqKfT23BxhSN1y2M28v8FCFtMW7vodLQRG2pLpdlyJc0JbQYnB18BQm51Pod7o5Y2NZ/jMc7eVoTucLIMM5fcfGm7uZCVjQbR/43Ul/u6gGlPn1XW/gaY4Ju7y3yOfFMblDil49L5HxU+z9pT1nV6WmkZUwUBRbeJG+g/W6UrESpJMObYe1Q6+lA/t98m4HBpwNo+agCeBlfaaZSHHsyY/BiyT69LzLWIuXNFt6rK2bmzneU5yEt/UsmzOhOtDFmTsiaKTC0zA9350TY4qGfa2jDzneeGcFwGRiAhB9qE7j78B08lxIJBcfejrgBoUVAKYrwfqdoKBGjupZ701mhtyaJ6fdgkLAyRo8Ad1qQOnPr7BJ4czSEA+b+5iC8hqUkNj5+zy5EShepsenXKHvqeJc9px8aFDWEy7OmDhVQVXlsY8j83OUd+MAaxYOjHyU8wuN6jdjW/JMSxCRvr73WT7J8ULNjnQb40vvtjPuFuJBTSB4OTdTj/U32L/A/D2LM7gyBnJPtzG7gR5FA+ZkYOtRSVRsNLIrDEgntI3ZwScks/K5ZpiMNzmH+zj8KRCos0qKRL2rMOULBEyvapCsjvkrM1w4AXgs+nBTgNkaGTgt7HkOvHlthECID493ZbIUGp4NG8u+knLLDnuOx/YeATuP7EstLep0CDiJIMLBF+QmfP5Urc8kJTKTNQJbScDYpkohUut1reJjGjtjKFRUlUFfB81GA2HPMVVRwQuakZEDPpg43p7Zgn/fE69QRzGULULhcrSRBPwvAWYsu8WkRtikn3jok4BvSOMPTse+FLWPg10geYvty8ekCkYKREtzr23TNcfhvlpsNQPaxPoeEpkhw1ODEDxdjaUiPmw3ZKtqpXlGW9bgg/infJGlesi5Gp1B0pvSOreFI51D5cP6Gzil2iIup7m0iz8sARh0IJOag2OoNvG1YfIkb0G87bwyRW9RXc4s/i1BRQeFbnOolmbeY5d0XEqsQV/aoPuAV2+kbdpWE0aYmLMs5VY4Rncj8zJL3xupH+MHTDFDZmoO8R6z+3+xdX3J/rCVbRPYlBtm57oBx5iWp0DYQ20DjtL/ka1qejZ1fSeOlzkVhaOrJBG+ajYL17tYc+v3268fgIx3KPVPifdvaBI1c588HCnfpGlcMewRG+bIz3XzU2Av+qNCzjdegHCYIAN813CmUqgtIYjc+7HKr4YQoWngIqps14CaVxnh8WsMUcFKSOVT4Ksft7zfBhaYFBfRS6iYwzgGAlZ55AilwAnHKy8pL9ebP/vvczEg1XtCnwCvIaas1fOefiwLLyfd064AmcNtoFBuWbPSKuRlNBCH5uv19UnIc2H9znid19UifmRHpvW1a33B2mPMM/SzC94+zQp09Xl7UdPjXWCcFiGoLj1bIn1CCV0i/4fNUQ991kSsVVpZbu8j2HBy2wn6TSzNs6pj+CoJ18LMz8vL3ayN0DrzB5J2/qthiI8SlFOu+zJvhBLrNaUyf3iOKJV+Ecw8BcJKA0649FVO/AU3/qdbmuv8Yt8SOOqrw3J1wDUch7rVnZ79GKTy14QeDbN3Bpv1gYPk47Vov1P88qNb4f4PstduBt8qbvrmaTYOTeohpg2ZQGX71nWtInDcEutUHAwIzirp27QFEjfDotbjKPxAa92Hp32a/8DnsR8vhJw6ijCtHAeIP0GfXoS7d09kqbZXhnnpJKeobvJo5zd599UQ/FbJ/EnqisVZCKfWBNPPyM7dS/onMCTY3jwrX1vHIm285MgAJeSITxkLigHcgeALIvzn7hpoeEoSMFpPpxqeUQsfqNkBGw3BielyAXSTVJHYZWcxHgTNpXiIuXXhO3kHfVmcI7saL29jULWE85ODA0/kR9YpAqbXMHpTQAm2JaGVn74QiRSEfIcslnvzeIR6eLx8xbSqSV2sBhsZKHkno4HJvhYqPpapkkPPI+HTAKjBmyOO710KLuv9hE0U0tq6swhSt/ziqsS8rbUryRPUlfcyW0iznMYHBjwW4eGeHmd7O6NO5fUnlfXHwEnFGDgv6Qj+gjrp5c5D15ivC+OR2GhR/XZhe6HUIxfba9GKbQ4nO/Zgfh98RfIg3BbAKsXxo7lrXFugGLsLxjiQG+cokiaI2hYp775xzNnnKIDHvnHAyeQCoYlg/BeXSvlcQM6iVhBza00tdP8ifAplY6y791qKoTENlffqH7o0cqopZjX6z1C1JayIzQDuBqYoLIwILeMjTudGRF4wcFq+1d+nUIW+tCgfpzd75pVEz/jAVK9FYRVkWbaPevx4p+cac8NzyxPBv/Nf8zPsBnM4DZT7BR1P68S58jjoLl5D7Gvhp0AZmAP3dQKd8YBuPK0ZFdM99C9Jfj1Rxv3RkhNl4ODySYhVu4PQ8hGzVVcxq220ANJz6LoCKs9AQDG/KgPNL6Wx+8TabsCbLUqSsObOSMih1eR/O9lA4yVqknX3rs+6qyXFS6wk/jzys1Yu8e+qJIkJpf0BziyPN3lE2JEEMRTekKW+c+Sr/SuJccD9yfol8JG8PeKugZXTPNDO0SG4A0CqY4DIiMcW8rM8kRx6jKi+hQWIdFCKRe77gSMOhdxCPqSov65gJGhiNGqKGDXn+m1KWBxqcQlCoAua0ONPLrk1G1aLGfdzwCz0oHovSH06eqAuMrKZoxNLtibi3EWvgziSwdHoRjaFzsg2nIE3lG0xzyjPDDZ2TBXypD8ogpb8XOuAV20rxS5Rp2gMR8dyKf2aO65X7Y8IgENfSIMjPcL8pworyJjQfxAFTWlrQ8JR9mk9lQ9rGMTB1J0dh/cpce4TLIh05TCBC2nZ881qS342P6JHXHOeMBjd9BrZzfQDA72/AyTnzquwubtgtdIlbuiifGM3Ya7fEDId1ePAUW9xhsZteuKqBGdZEk1MfTWAA6RGBrU0ipIX+voEVLBHUI4lAb5KSYbbPQd3Ll81KYJiRqGUCERmu2JNoTmwiTXK0o4TLJhU1H1+RxOCZglF4a/pLqprmRpuO9mDiARJX83btv+cLsEAVWkIrAqseBKpgrYS3Dml9+Lji1z4Jlj7wKWHFpAD6SByV5F0GDiKtdGH52Cd+tgEvrnJ/kV+PXPOqGIJPxzPY7bzPShMGPsX+eDqwCvPumf0DJkdw/ivK138GDDi89UvJ+qZb0Dgn0OCAb6IF9x+EfpYQJwyZFJ/0OKxjDhwRVlgwsAKzHkszW3J242bN419IztDRr5Boxi1g+UwCb7fgh4HIlLGilM6uMRr+oIRAiAZI5na9Dy82qg3MWGbJCxfZq42P97IgwDiORG8bnKRwRtdQg+5N8fH3fy/RQgAUUUq+93pOUzasP09zzdwkvpYt5IffpU7bYIjLEA2zfjbQYp2t+2qGbM3jrkC+ZsejByDYiKCrIPKEHZNW+B/LfUJCgfdlsRpnx5xZayuLwwrZVR15CXHohKkm2wpjPO33PXmMWL5TnCewCvfxNFOAeKP5en+LyKMRSWWYeMtGPT/1ZSuVlD2314Y/bBSxv2pV5bqAAor7uZB7K/HIhZ4IryxOBvLnRdqYRKaAcYeCOuC5BW+VxNQSi1wfJs+gQJtcpal378XWC5tH8I8JnmRqKScS0Ccm7gAaEQHZwV3Z8e7jrCJIKv+PqpYVeDqSCA+7AIeFyPj3gzMeToNpDNdbCl5jTIwrAdm78uO4h4nl3/cxBwvVa89iEDXRp9QcqcckmVdlX8kytV8o0ZN7cYi9CQS4i5+D03Z2akQQ+JhxGKnQqRDd3FMpsQMBtc6Sq+P+/I7XTF1jeGV+4wY8dcGxMT6wsJU/quptzaJ7pnK+gC9YyHMQ5gSGl3TdAWo6va5h33jDUKuvJaJllhjXO4JXnATpVXsu2xYGuUC0R/qCwSx3pYSi9G72Hyu0bJ7xZCZohBhV4BL1fCR2aH3RmFoxYbzz2fPIZ2iJLTBPTG07JyRnsBmJrPiUhlMgjVcMcl+2gnpAhNi4YC3fTL3lf2xLFGTCPninp0YpwcIS7CIx7n20aW6QyALR/uanmzh+s6fyCLQkL2NebjMlgdFHRG/v4+N39yPhKo0/Iv5NjgI2qA8uteA3XGrwA5IIh+G8qsGLnQsH9M6bMm1ANSnVG5cLvzMUngdqCeTpo0JC0m63RLp+aMSBv2Zu6Q6o4APk/Pt/E+n3Si6p3JdhMRCwGAjCxUe9b+6CaHWfCywV5D1jKL1JYNdo+fzdsQ7rS5ynwHphjTSJx0f/zKKEkTmkHzlNXaDh1kTt8hVxJqtLY7MeDPM8HImVIG0ZqFO9W+2wNyueu0ToUDIjSQ+PqVT2tiJIKDsHZLGYtUEpybhdzbaWSDThmUFcSDz+uF8RHbDSuJyYvMPbY45SKvhwT5NLnJfie1S7QrwKxOO3SDZTtYzchKne364rDUOA8t7s5FYqovnQ1M9fA4D6ZUKZ7OjgjftWy0P2BoAskrpKNJZCrKQTeGr8czB8WdbMkHKUfSEAXaddy1UgvHzE4/XOzsQnQBDRXYSGqTBxEZZnK9D6z1h8u/0vBI6i1XuuQ6cQiJOngvOg5JLj89oxm0FjKQRVo8su5WuDphgU/TC4XpvOdXW82R6xPhbihMUJZxzxSB5vDx0gB1P4WuDG1vkO8MezIVzm6hv6wqZrU3c8z4zNCjnQdVXBdQV3OO0LjYlr2IZjH1CuOKLiGsIxIeW2u12fRAA5qizyeogGdEFv4OZdOkwqtVfRkTMHEUk2S0HIhZdc6DZY5LaK8U1RTreyQIS259S04tQquj3CP8nCGGXcLcpXOhf/mEqUB7J6HL6QjAMtSXTxbMWAE5nHOHkelLqIy7rBiAKsFQkHJJYLXOBBl7EIcgGEW58Imqg29i0kl0E41ogUpxcFpsaXZonMl5yGX2CYCrZjxkaVFVNcdq5b2Vq3QbYUH5io9KC1ZnRrOfBXBZibamemK44kewZLKwvPIdOYMP3aPGcvVG7N8P5/FdBuxuzPrpUthGzRUnW+JLDHmfj+MaRNdEg8GbIthXAyM3GLXkp1URtY4jQTiDqJ+X0ItA/X/6Y3hAJgjpyzo13q91RISAODq0jcXXIlBah45zcwwj07uTFWvW7SmUcjLgUQonhzQLd3krboU80wKBXRtFCQ/FJh/CK9RvUlW94w6eQnXaPVDzUmtd0kAjTp/gDXPpK51h9XFMHmb+o8O1t2fFKhRNAjl4X1zC79FstthbwM5cTgZC1kDViL5FGUyiSve8Tz6mGvb2dQugKZjKoQpdMP5yY4AIxU29e5SAtDZou+oHY2kL6VvfszeF3SUdK/1VlhoT8viohPIZozVBtIkwkj9/UweIXrL/pzjMCuXVv/NBzye6Kp1E7vHsa6lSMsVCtt7+Fh7jj4TDxZjeWST3aah8D78u1GJgbi0T3VuIhXVdQ3RA4MzB55YJi4cdxFwSKetXST/SJty8mMM3lJt/Z9B/QCeuHP+QUvRmMPkfYDZEspCfsuigAnx6heZ4/X/pBXYGZ7vKQsh/EnPZ1jbm/nU1l05emP3N0ND8v368cTwo3ZCFxh5Cu4Oe2DjNJP4RJ44fursFZ+4Snt67/L145B7nXIYKjcxQXxxEZD5vpaEPpYPenFrEzBCFqLARtmIDZp9hTrJaYcKrmoNvCwdb5swQL53/9Ck+9cN84cDuCxqHgailJgPXv4q9yApFIf9RLDhGqc59eBgqPxYrp+2jxP7Gd7J00bkYqF+UIKRuEeoPS+szrO9W3skLqP3jaq5YJXQL8jMeIRhvvS6DihzKgUFal2TAgG5GklUKjf0zDzux5k2557i51yLw0/zs1Wvkg46+gGhY3E6Sy+sZobH8IKL2bMIDFpUatowydAfvObh0r8GYxDMjmzKp9YnsvqqYdu6BcHfYEPppzC/YKgXxrfmkF6XK4Lnum8mOCqdSYN8HxRkPonfD6Luc4ON6VByWPFbg4gouSwvLMRFzbky6hZR/56RO6r/hS8Ug9L7DpGvzzGQ3Hg1phs4IS3RM9uxoc1taRpLUUGzsky/3UM3qJssHXXxpVOGRFqUwrLy/VxHwJ7bfEQXM1fDCPCSP/rOqvwYE2dNtQa9qRQrDnQORaEH/PZhfWXB2TqwJfS72eMRZc1hK6C1MurOI1DKDybVY0QAnwo+yv7jtnGBAJBnYR+iu94iLlCJZpT9yDQw/JUDkRlJqeFnMLgkaQW8mQCAnzeJp1kP3mRHx7Ni0yR4cXEHaFz38uccL0Zp8eaZ+0bsxbtBhuvrViPLYM+NyikZFK0hpLLYGULtV/YVANMCHwtt+lA2OFGandlVekAyfTeK2e8BXWpdYs/B1yIZf95ffP2mKdPuaMFDA5RgDAw4C8odWHWTYqenaPJZEUoxfnyRCKV20nFDpTN6C9DaC3KNlLv7FVzioM944li4u726xvbdb3VLswHK6A8ekWKJnbTZYH7PLbKk7QIP1At+ZWX+0vUgDgb1r+LBNeyOdQtyyUyDTfBm8WwatDG7Xmy/qYce2TitnrUN2HiREZlapTOs8/bqmtGxBGhMWB3B0jR3DDAZ7EHuvoX1CQ2WWedkgxba9EFKUBTg3k19v4O0E8QAmhG9Y6pxWlajZeXNrS1OxgJKRPlxPsrwaU0DoPs3B9Bq/KYWYrQUtzsufsW3Y1NVMZY8QX6mTd4MCFq0/Q/xixMNnJ/eRQAeLKTLz47Khfu799uW0/MKJWvJMQpXirKNT5J3kDcM2sE/Mxkmz0LZHFz3CbYnvJbqYuk8rKFn7+zCkMlb3NCHk6Xr6Ww+cRa7iGsjJWACt0pA+baRiPTbowyjEz4YP5VS8S6HY+oCYuqiZpggqPrbjfG7A8MuyRayDYrrKXusX2IjP9FIkLPmqULKDWv8TdeedijX3wjYBm87s8JDb2zLDjkv/q8WsVVJBrdiSI3TIXCdRKKTilBrNf7HpMGOnr9CA32g/CFgMVP1asmwTiZn4g/xfcbW0V1vMWOQimyh3yFWOR8jG9sn9tG3NQsvmKY+Z9IksxtaZBaK9/b0MHap2rZklgK5pemwHXOruzrHc8rdDE/zON+Idg03w2o8TT+I5MMQOEOObPYoJOclAKBHunXq6eG9WtT09HRogC3V6Tcl1Rr3oHs3vkOY12AsvSCgnImO6KES+kSvj9R+LrIKPXa3vweA6STxwjvGvNpLG6mhvA4O+EmkQwuOQ2wZmQccSV06YtlaPWVpEBnoa/jBohP7fyH6Bakgk+wK21lbF1CtutzCTXipplLfxMCse0Jcq2kfgRY6P6O8SD2CA20Qv5vU7nSYLambMbszWfVs+Ysw+L8nJGhVIr5zFQoy3nmgMuVWnZxiSyYHD6g7O7iYwdnwPrugtm0Qjowfm+eFDIxTfaxPJi6T2lXJ2/Lv4xkbUeiA8rTl5irJkoVhRWcAOhdePvcbNfRnmcf3BX+qNoRO9vQKln3coOv/WiFngHgau+OcYNU6rNIascK3VoneBNHxOdr61AeusR6KcLAywIKY/BZYnAIt2SwmyfAVL/EI695FTUCcIi5ktVhTKb6dNP+gSkv9SpHdu2cNBY1k/1GMvWuuIcawxMcxYyda1pjSiD4FBBLOq06FHNLDsRbYcXkhrfgEUoltNCZIB2+ITyKQS+87GR6ThOZDTZTsi0aCvIeTSEMDakihn5Lxp2hCc7ePnjjGecb+UE1NdYR7U9IkIm+xjCdus9tp/ITYFQaIMmUse6mNobCTul9XL6zFICxZNhZVQWjPhaPGXW8BuAF1b7mALnls43BtsibSkvHGZ6EJqWpS0/gVsK5kBDt7AwJ9cAXUsLjxXZYKFLBTSukOJYK25tiHdgEdEs49H9btwCvj4MygCP9uHdYm3XKE9ykulwjnF56IQ7D2TqmXo1haO13EY4Mn0EDZsefWCYS5YnqrDpSFl4JHKxAuRj4cXKytvcxE1UH4o330B95AlRsbT99JjNynT7viQfW0kZJMYnxORIixZzWGe0IzQifj9MWv/5+My8wMa0wjd9v55DghtheqWt9ISYaTUVzrLg8UJsHUQKMH2GY7mQ/TzwEL7EYSGe7hTHTN/W9k9Jl/RLhR/rmukNWiQWDTodU78dGDM3FrHEPfu/hAQYuAx/YbW2CVjfVx3R6VOCMhPrKoTS8TkwQrBIiGUfx+FZ7j3wjfFXuM17wVSAd3+YQwDGLKrGCHaHQqxKP0B3dnRtDojjx7JYYcX+dwx0k56UBwQVGYtrIhOELbJXCDxyyqr0T+DEDJisQaJNKYD9oqVHJ4AfEOUHloU+lbs5ra2YURl3MmmFCwaN/1otypd74p9cgcm8iWXb2Qu7oKFQ32XawE3UzxPNgr1e1Jyqp7IUBGqCJodliiGfOzw2GQGstI7FEc33MGkl5VDcZSsvvzI+s2dTD0QnU0mjEYo+sGGLN8xD2vNjD25pXsXowK2gWQoSRGxcJT1dTTojbqJUIUhW1cOAtg8O0aP7Qi6S75qA/DYWyCTeFDkGFaFw0940aUtsQEXXPYSYR5H1tSd6iOfMOuY4JjyOidLSJSUUJ1Cm2+28vz7ZLUJlW2GB5s4SbaCrUpZux/DQEWxbOCrpYz2uyH61wawL+OL8jV2bjoVLQWtDYuwW9DB/Xbtp6SmVeF0BvwniBdAHX+Xr6XfthwSapy8IKiRxT1tRWxeQvJ6eLD11ulZ9KxXrSbffaWXSGdhRpuYknZDEB20CedxydEhnp8O9dw5t5SQTCT/WLxJUyCI+1RtV3IBzXeLr04MAXZUkM4A6FKw5woL8994ZuAGKSSXjipxW/u1+hh/QxaV4Rq+l6BQJTCHhrK/LhiD0ckcsEvOA6+XksJSlQPmbwCbuiSY6eyv++t4D8BNZoB9M8gQvzGS285hqgQyT7WsyQY5S4iCzJfJaYqkOWorjSY93T/Z+lFIp32LdUFzp72wqVftcpkCbOpaBkS+GIOT6Ld21nZJ0T1BChcMRvLUl1EyOiZpdRfVmawuucmlRBdAagUORcB30PQdkONSS9yx3ckCttQnmNNlNIJpodfmXX3zIJXIp2jyMcKYv7iTbCzQ0VhCO0iHnQgEbahqz1pu9oVOaT7QSo9KbFeuh9Iyvj8z5ThwumNP+/jW25z5xmb6w3oDDmq52EEmA/o4DJe/1KOTGB0jpse2APiqa24NPzepAMx7qdWs7shJUSpvV+IidmPquvmw7gRQXSNHokK6PndOd8Tr/jx1O+peIv0hOD61RA9iVOmleM2C2sM76D9o+HKGT8O4E/CTHuxF1xt3v6Pwdr3NjOjEAqND85KFoA255KXb7bljiDn/RGFWFzxHgIrsAcFT60ahJJ+R/91iHHYvPkT3uafUL5z5dYHx3+GgWGUf3xNXqCasi30b6i10emx/rvAqspAoJI60JrcXrhHqoAFbgxRhBfaWERHcUQCjzfntE4qpm5deF+eY+RDg73IIsHMNUOJcNtev/B69woqQpupfoHh5jLhgCZvPR4fi17N/94hgMqdGgq92vQR6VtQJAIRoMMRuyVUHhfSsWHeE+QbiFQCNWgbpHnSg3FkScvl5JjSGGTDUV/qWbkcohiAgiOXqgKjo3RL2gjTQcdGSWTz9vU+ejqtxOteUhwizXxrfAro3aWdqRIkkbuvYSpSa6o/voD21AscAyaZ5j0E7aJSE+8Gx6ZJl3Gg8+Kaat2WdtDZGJsaEcFbWb16eEsmXNG6fqUscue6ckCZkbNn47+3LI0ajD3gDKuuO7QyPwDQUTullzQ/ZqoiQX1vtZUT5gHmR32RN3RrJ1QEl1f3ykyTRCbKN4RxJi18ms1ZdaW77S8aCp8OZGSxmig43+3uBC7DM+huJf7QyRFtHy2ebRYL04YoBRkE2eqda4EemZGQ08c/3M2I3AR9MMoJKQQNH1tvbYIHpCTeUotjTaDZZ3KFJgbsslZGLFZHmAlMvBL5le7dPOzLcOBWiY0kf15i8EW72IA7Kobx0PGNqHAPmF0KV1bs6ZOnG5am0lY7euXsWGO3mKU0Q2559Bp+nbmwEcPQZDq8PjFHk4CgEAF+IbeVNiRLM9+C7H5Q0DvvrZKqadaF3POnX5/q7FlXNIA1xQNN8/ltTFp/H2PwelJGTfJbw0oo0+zYABjtYaHWP13KcMXCmoA+/zpzYlP4Y138xZm+b9A9Sckr0zx1xdKmdCQl7BMSg4EQ1jg/114MjH3LMohCMG5PKSbUSNjanOtFEeIozwGTHSsSOZDKNu75zA/uzgSgCGPJG3a/3nKNXRLoNtrtMIfO75uVKprwKrdxSSgTbGvmhJnHklPL0tPlIXWKLnqPIHsARfnG0QGXqF2MSAb7o8y0hJkIfEkJOTXzK+wWzo8KSFwmRM0ds81tSlnHwP1scQfXgwG28tJWFY1DhwB8rSGkqKRJsY86B971bWLCbdfTBuYgj6GvHbFlKalGS8WuGj1TLtb05Bwe8N6Tllq8O3U4+XXzDe7MjdUoVIJU1J8P+/WF2/KjCX2jOZhMOaau9BmorD8QXd2HlvMdHKRWIWWQJ6UMpnak2MbFeb/G4TgspnD3tW6VPRC2aH412awcWJs5wMDKEpE3nVIbAkjuq8QasOEMIyZBI7e7x8/HVkRlbybMhPimh6PDaokaz4HVD4EzGgfLoIz8W27RTRvWjaVaD9ggBT8x3dgUSBBqAtb7aKO/lpyGBdt33WU/XqrusuzWeHVymtm+t9nY3TaWeTbbKkiMNpkjJ1k5XTQHTzOiQOzndDxd2+KQPMds9rP7G9ujvlAUxLqEfFgJHmVN7rvqRssAXjXQGFzYLuN07sFYPb/BQCJOkQGzsEGlP0ocrIejhfWeCl1TsavHNB2PfX0mQQCsGA6a3/KV1Zr4IQo4TYGVk25b4hu0cZ4Qr+j84Q5V1bmhUvK1XfWChepm+D0x3pFF++aBw3EessB1xnMhC4zFFxkCXg118b9Om6zu8+XWoa+Ey3xo3Vt7f1M37b7MZrgGcfbhvxUvwxcB+isLxkGxfkOEAdosRaHrlOwYYZ29g/Ukr2gkR7bUxda6vyt61cP0xlVUfKd0WBBDp9kG7oleppknNeE/rzYM39A0PDhm712WsNWknyStk3BnNWMBBdmSTr5ySyZpUbY9IQwjLdIJnVDrFlK3yC2QCsOchxlGyh4yF8McTh+xWKBLz+A8oosTLMT2e2GQK07/ur3XadjwnTkMu7NfxiCGOS8ofLSobHyaPCIRU5yLE/8oHlzkZxKt1RSSSKMJvOXCrd+8d6zv6qiaVZSqVvX5tek1upuBG0qhVc1Tw8eOkWVW4k3ydYd+YQ7QcC2QjmzUwW2jt1skvy1Jo/6id+w2K2IcL7kIBMvC1sh2FUEUPuKV6bMotGIUtZFZnteI8/4SPx6oR+3CSoS/ddyB8O8FhQUcY9FcAOEcrxiyQMv1R+z1//biiysnXAfLPMhSQ5tcJ5nlYWegsLLWdNp8iv005sIRJ6u78kCWJeoyuyRcY8wCvQ1FkZ7M2EUcfDw1dOSqt1h/l22KFdErqnEYkbdR+6+P58NOjewKU1Fkg9/dbUf7Cu92EF/+Cx6tIAfFJbOrYGfjWYxvxNru3RDYFPzv4fMXNanI2ruEwhsdi0SIqylVEqywsWkCkYFxrjqdLbcXWpd1ee0/WeVAzRkmlUjJf/owfldTkddvMDTq9gnneLhMm8WC3r6hG1MMtgi0KU7miC7amrOb6DhEBE9+i8megjs9P5L9q3H145t//T/8j/rkhOEdTDwMlYhWY8qh/qWnMnXqCdeeVEPi36CuS/nUdkNcOcu5F/MmrFcKjVOQhyEHiZb4mEK4Cz295xlnyYYh21Szkhb5obRucZ7sFSe5MfMsKX4IkDiFWVPSpclaixDP3oskHN9XTwwYU17vi+bG5dCPq8y1cLwjLDqMJ52P2a5Wm3wwCKZ/ZnffoC1KKr8CBMBhQQfTUeNOyOsqxZ9ys4tg6LY9IMnMI7OIRcDm/qD2mWU4i+az/W4tnFDJYoLBPaNckSRFIqI6L8FJXszHUDgISgVRkJbD0w4lPU3SihAhgNXiDz3DQhY9xYi4cbTQM0/fTM27P2irWhLX1JAzDydDfdzK7ej4DvxTh9r4nuswMLrruAO+8W9Qo1SMCKte9c+cNlW4RpC7LFQINv+6kPq8lnn3oiHkRp7cvy1r45APS2O3TS15FK/LKghaPOSsWq8MQtDGdRMqvjDRs+rXfaqvBrB6SdSH7PYVbythbIzgmC2tFIGLjAwyARcTU48dinJxUhcsUH5J4ZWiPbICxFCYXvFb41/b5671DRorlpaPtybNH/AXe+y/qpgOQUxOPjirvRaNFq8jcM2WtLYwJdDicxD4s9xIgTqc2ar0l1Hr+F2b5t3MMc/EpLPDktr/3zfwQMBNZifU4iA2jPMFVdpArGvU+Grb92/huzCYc867EF3MQ5b5fZFGWCnQN0ok6qc9SX264A+EXcNwS8bRCrgBk32as8w/kQeXAMoEXIm5RMUaBMazKKjWtzLEpm4nQzt8RBgxnW3mHLSvoyS8hWFe+uv0NtXlcn0OMwQ9oS43wBs43FoTYk59XujKNjxm9TV31w+fQEY/tlHo3gcy1DjYgqluUP5g0KcKdzpU60azTNd5zoHqM1GJEYmaTgUIs4FGL6F8woP6VULfAL+BDoYoSJVueA+lgeS1ThJrrUf1kBmqRANy/RG+HPqPG+g9S/25y50WFnczoH3zBfxaTHE3HrrLV/Ob3uo3Msv2uuDKO7FjHsEyMQjJlP5qAWRn7yvhTRAjZQV6k+S7+enheEzdp+6OblgBhI++Y8S5Y4F16+fvKy2FfNIdBBuvoEAerymxaQkA8I4sTLFUSdzazN3xRBO6YpZ60JgrfASAWp/Y0sfl/UjTRrUrkpTLwvdWzG8IjAqpiqJaYgn+MjowTaSdJivyekp0Fus9M145Vs3GZX/xKE/vBnzaHaqXuRPFkG0m3QzTfQfYXbGOOX472x++YYQ3ypb8AefhcBgq7a/fNMDwujYVDBQ3pJIGkhAdm3P/GjFR4VvyZz4Ba5DspgWux4FQ3qSJdB4DsPNN0+W4kSX4b9DVWlEobGTav6fCw8uvJtfNf+50OdJNl+3ncrY7olfkkWI51MLET2rda9YrjzOHHC6y1rcnHDuRJb0Dv3pFXSLxR3XrgZSwuYEivWYGpsChiYwgrJnu+kxPdwUD5n+G7RXdnmToN8raSHF9D46xL2m1sdBa9FE/DxscsurEgQWJ5XGt9rLaMxQVtpWcvgMqKaqVCR10q/pnA85o02T97dOHwLf7M/4DGTMSNzRAUQ8NIzufeEaIYEESW+B4KohdjdUfMJ9Ccw+lPSp1OMoAEgFcx83BWurLaECPZFZsnYi/6oE9MNG2wVrOYq5nDikoTJ2OPRNgg6dDuS5M+yzQnibou+nx5C0LHDq2AwXDQl7dhZ/fZ8aZmqJZ2gOkomEdRZp4bRZYgsP3GqjzGUcAaZ6WT3kUFTRS6sIqfzbdyux+xKSL8N6JOcS6N2M8HhDIAy2+Uk8lKkvjy1NuRsUL9usk82Aj301cGQisYzThsCwOBjJnrp4pTUCJlCOVr/Q889DS8n99OXv8CHc4oK0a62tu5obg5QqubfWJtMbqkh0ir4YNJqly4ElNjKEjTGBF5CzgLCycAOcJsAUtw1Hzb3y3goYTqPbBMWeQUpjCyIuFQCiwf1WoSdPmu6CBEh5QYjdds8y9ZkiL//cp0CpXmXZ0IueABMN2yy4E/Y8d+rqMKZcuXdQPOttAY2Z4oYKAn7UQHfRj07/N0aylUhy7WU/O5EOlXsGV3ES89Lw86qOcsENvashnCupvEvrhN3M5WXkDADJRz9xCb0c49Bzjmej+QTA5BAV77so+SZcLzL6wx9wEbz4CTdAfWd+BZqwuwxNJCyrP7uVK3znEm2QWBfvkrwpLt6yxaGAtMdsgykQpTFGxSCt9tXxJeGDgtuVZlWMeAaZEmi7borWYWPZvPfl2StNgIhTSYDUoLrcHZA4gbwD11r1AUtvJ+J98a/mR+8shqjg8cpTNE2GVwm/8cFNc0Y/1vfNukoDy9bnjKLRJMIeAB6iWOqPapQyfkBMldoSD66fy5Y4oOM3hNajNSNqhcEEe/N5Gs55U6eUO+Hk+SalkLmj+pqbZZwZzgUSLqFG6h/UVGz3Hx4CSQv2ziBhiXly4OdgXRtUCF6kM0uBaNDOcpm+rwLL4yk6oiXwvKKa/aMXHAJ7l/mUBkCkiLR37G0NTCv5ehZJzeFDAO7XQu959JTbTXXOvlpQdMY5CLgJKH5W7KUerrrF0Y/C0+7XJvsYGxcCjHQJbeKSfy1WygqGANp7/OfkvyOoON8OS/4RqW6xHpv33hEp8euFX0bErX6sobmms5X/JzWkMcdT/5HvRUbzz70TD0OXB5Stw9ESxdTZb7AY1jryhQ7jNJhiWF10qLksjD1I6hENqDiTFb4mlVYAZR/fiiFlb/erP8krqBdaJPq9/kTi/9L1Hlm8zjVojK0nZcuLITb/x5QDobeN+uUhM281ayabOwt7ClLhdCqpj4NvMXZzH8P+CkwIa0TDa7xfoOBBWuLRXXgAEBB4Q6vhY4o/7krkXbYBgymiWa2GA70icgdqa8zVbpqCg38oqSERrzANHhdwKRXPj/0FpjwlAKV0xgBfal+zPy11UFpd/oIbJZvtIcu23Cx99KPxKNtgJeP/fUwYOW2lImBy5TIy4llgeAnRDyNNimLpv2dx0w+iKK8zrHtaOyMAq36b45fS6cJKBsMSXEZlUq5Lzx/+ESGQWqJA2kdC2HuLqym9agdLe4zfziD9Y8I/tgsCh0LQ/GyYuRAn3wx+AMJt2JVIF6tKOWsE5glYkaVqQzbX6rhJTcW2xVhrqhtLv3BBCh7ojrqRQf8j4L1zqsuVhrsfmSr5A+KY8b1L65Z+9ju36jw3YV8Wow7PhDxoScrFhnhE+5txzuJZYxhsNHYFr6Nf/78xSfcoaMPHQd4bzcb+uqig/FCcOYwSI7/Z+hvTzOJeCTAEUjo83KyKT4vhVRJ/MfTSdmRlNE1U0O4Ykjgap1YoFGbIazQIDopavkpK03vt+O1mI9TSZg6YFJUTDygTJB+nA1I5s7OGBxtUjv8UdKVJPZCWnYCRFpi9ByQMmAt+1IElJtrRfHZ09dSFvakFbawkINnjOS+RKHBbqcyKtVDZbk30uQbHnFyl2iV0qGp0N6rpmhISMzJMs+VvZaA6FjyDKxE/ozMz19AadeJkuYmKH0+snJPXzphPEsNMO46092lHsCigzKca5kqLcBS6WZWO7mOZJjL2PtskBN3JdtUOwRGcvUw7nlR+jeiERoJeEL8YKBIe3txYi5ryVF250+m1Xjv+AIGRs6cVaZ47IPy0rKxqTOdKfjB0iMB8ch+8nUCOhpZaIjptTiDhHgGJA0pmtB8oiugDXRKAWediOJCOwNpzmqI6jRs5QEUm98cpq8V4HQcImuJdUjkLbNtkmBjDKK1zy5G1Z1I36YBQeruqNVcB+btY8dfhw/jlOFBomx6AFNLKsRa7vNIP2tGozQcqqgXqZN/I06NwOIVv4n07V06Ecodg3vOUglsh2eTMNE1dk9OAJj293UYKCYhE85ZjW46Q5CZjiCq64fYLzOeVSNKinOi9Lg1S3YOsvkChJPIIKg2Yie+3rYKHlqoDYoVE7/ZwyuDi5q4JwQL7da29D/MI98QL9JuQpn/LbIkYCfqhcIcRKawDD3nRGCOxTDOSxZXn6t9rD743zNqajvPEDpFEJHLUVJPi9yo0LB6SJTSEcX+Cn1l0osN8SKvc8zskzbU71ukRvz5rglXPuqlgSJSHCpaVRxYAlp/ZGEQTWxVUjdbKpQlftMR16gRQqMhERidknf59XmkMG5mwHd78mGBbv4KRCTGnO1PM+TBuIRQ31UH6u8uL2+U1/0JckoJzxZUi0CHt6f6fENOYqTRsPgp+eAoCM/Q9HrF/02Z6qbV3c+j3VpStDTT0IYg3aYMvz4a1cBDYgzwTARTbCnRfvCZYqea6gSm4CPeW0GVUmz0syYf7lw9wZMV+NZzrgOFR8ZQYtuxVMmVWjwpuPEpOZVKh7TONU+SZtfrhnq0dn978eMHBdzQ3Lqwnuj/C0roxYAIgYrbyD6BRel51iyNEYyKNEDj67ig+X4waSsuuK14IgPOYrrAajuWK816KHKo5xVB4AbVhsC8SuL1l4B6hq93owrZ+nOrwHQMgTX8DAvN+9KbgEcd68xVISsSoWaWnK2LH1bCAQFKpKzE1hJfZoWFU3pEmc1JMfytlp1I0KPp4dY9xRfF66qJM/eH94Fex3omxVxe/0NJe/FLMALa0peuRlnbaR2d/BCEcNS9kQGR142j11ma9YLTqcK8ZoHhwkGeMpCSmLE6eIKxgdfuj5DYXUCcYiYoZd04twjc9oxtLOtcbtqrD2Y0dIJGNg2HOM7ivcS4/rWHYkJnN0crkCbpiFmmyaw6d9HspQFyNgIseJvHGFRs8fm1nEe9wyG6WyNz92tH6y89KvoYE+7m9+LcsOl2hHIUalTIqwe5Pm80u/LUmJvkDE5Wz6KUvZYN387mLIwAdSpLyMdA7KrDlXoBjsu7AqyezfVOqw8rXwFu4/Fi+SrYp8TRIKh26gpKWWUrOOf2o5bKrZdT7YPOJCFs92dTZnWy6woBogdqUeNkhv3xEeH6LBF1GjDLcYIr7jiJsfkIofO95JrYOvUKnVtXl60AuaPc8hJHFBJsFb1XP86sFfpHCrZ9Tyj0ey6QWkV1Fv09NMNVaOYvoIduiCZgBP5AKmkaLurFIy5/ZgN1Oj5m5VU89mKEXQNgkQu42tLpcb1efwcvy98tisNDQPuwixXoinDp1hkgGxfM4HULtKZ2O4OIIq+CspR6lmzPhZD702NuermvLc+ibuR1cZa8zbr738WXmveEHZhSAMEr625WOZIGLvplZ9zjgBS4HQ7ISJvu/VrcuHh9ElhUK2v2kiU6d27zU7Qu9+b95sFrYncQmr12gJHc6TMRP8AN+L1SpdOpZZ0Xpo9aFk3RgMjCgJktlOnwIzERncao6702Ibn+tZHGHInxXMyQFg0VL9wuTCIN8QyyK33pD1ZBDWPdOoMVkANZELlvoHC5Vd9Sb1hcNpWlsB7VqDhpbgYuZLSvrWWvvy4p8xoURBCYwzByneS3+SdaD2yaCn58me6Lo8P9ctYzjfEIARi40RIwlO1bQvBOV4FpEXPpQNpZxGHaxfJ6hWkC2gExxXxDkXhG9/93w1YHN/V4kiNDL52kd7xdnIq1U+E5YviPFTB90ymuAz5JLJ0zuFmOSexnf04NBzlFwz5IhKcKiE/Fs/ZAwvvujB2dnZ75MDte9lgDSIYQuc8UTbyYLXgJrPeSXmwFM6N1JdIx8X914fvrbsnFwckamq1BluhUMkePc/otOGTov+002CVAlXM8coUiTLXOUJhGuY4TY3uG6cjUS/9aI+avzvuN+2Y9RcrSWl/rlO+sTJtmMQ233Udz8xV+DA4C8DeUQ9XW4SzNM88GY87F9QFfndQUEZVRGLCUq2199xOBrzkzFXXQ34V/w9HfRa5ma6PiNgHbm+GlJHV9qIw5YiAaashVCTka02RMePncEyNF3KAOVc9ThlUdjsY3gwaxl1pJfhUpGlEJlO3HG1YRZvuFnoBU9Jz09NrJcF3+02Q7RP16MUppTJytlkt3SzG2RCM4TcluzS+4P83nrwjc5HHkiA0bJohxL7c1SzP3OgTznx1tfb/NT+QJPcAvT08a5mfwt7cjEdu7HqxA5TRCIIbEMAgrLXKmS15bcBYQRMbQYlLGAVFmPm1dWKelfefN5gWmpzsNFqdhAB0EzUcBbRCR73/2wmGUVQYOeHOJxo96IS9WeyqoBI+vtdezR+M7yKMT1DP76f/2aVdqKORnM6mEpETo3zn4GasNEQUc8nLbo/16+L/i+yLcYauYPcf8PtV/7+msFNFU1iGUrrlsUg23lvrG67/lWeLmxmXrs1mmgmiTjPusUNF14JoLRDEgMK4o2vwjlKQl9pfmxd3Obdyg9CzsAJRpaH+eL+HSxlaapWoMASzcdib/4KJZkw7nIwSkWSHx6iodoJ4qaJfhjrQC46Y0f2UeM10Awx/0zYd+GZwiHP4sWn2xOoA+5nVRfIPjGC3yVQV6DgnxpaBifxM27BJPldoXOdZVd58LmSOq4/lqBE4RPNPZOXOh4f9ZfAVzg7TVuHJp+d9eIutkxISthSRsPpLIY35T4ICYs6nS/ozPnWYkLYLFXEV7SaVAiTGIRDQXAn6/IAjRp5WXxuBg8JYwBoiYPD8nQBzGJ0OftO19dfvezbIwULs+mJ5dwsU569Meqb2nHcVDyZywK8h1TlMdF9rhBMltdpy/bbUDbGDdkH84yD69UFi/OzU5vpnoVsxVIlgYKMvkVYvivXBnxPhZesFa7Y4MfyHw9JJOZ+OmfRbuPwy+rHnFb0o+FhVZRdKYxNRUUvylz0txQo+JQv1DjK8zrEVjWGwaTbeno9uDbUZN91R2CAXv/DGuWq3/Cm4f/+X24doPxypyM8tRfBJI0JMdUf3eso+81JABzgPjQTRsBz7BkKkd/F7AqLMwrIcj61kbSOpYlkIkEoEXYjJaAAL6V2hrKqvJW7v2OJhuUFtpCgCB5AEdL/pdMpTz0Qlr76Ue20LbdatgDDFWHWGd4kfLUbtceryEUHX2VnCasUzk1b7ayfOKUCD2QroyJ/SsxlKvXQpPLoEDN9ky32ZzkfXr+a80W5i3b6nGX2IJmJ6SKIzBverrD/b7h+AuPRybWOHDJpXmsUvmL9An911tcSNMSeXWLi5VdfxQ9MyLYOJKxVdyi5fadmFCJPMNx7oQ3ObWbLvZmv0Hv3jnH99X13TzyjTCtUrM4iwtfHsWwNeCBu5kXqOBYKLoYcdpGadZCWyHL22GoCp8wR3WJlFZV2jWUSczgboszL+09QdQX7IY5yUje5Qc7YShKJm6E8fkdIOkbpBCOhCyIs+ovfMubBaGX6XHg+LLmg2/VZK5vQl89ccEeeTjdyz4WcOKO1ZbqMD0DI+LTIrV9pVrdzuJvPfZkx1A0LMPAMQpC1ZiYiozD7JD2h5jmsPwpUaYIrj74fYggc8GyAUOtk+ULyCLhhA9QfSPuRjDO1EOaRulnT4eJUyK6ResRd/YaFIv4r5zUzAgNax/lYdR78URVuglMVwdkOmZ7Y9tSTEA2GFPzF6GFzkruRi9RCHaiK4WAL/moF1R2Jh/SaE27wMBVb3Fs11YYtCCSKFIKISy7Uk2I5mu+r8EAGjBFoiR3QNLbykKhsmFcmyr+G8JyxUxJkoehkLiVh1EvULqkjWzEbu9sDzmOKNJOab7bGFcsGurME1+JkwTQemoBCHHG/8eB2p0av40lVt78SPI7H/TRsfm2igtWzFDMQHd3x34nMbpMZAfn6gA8YdD1weOsXG5RgmXrkFasYjdL+VlL80f0AUihTEXlXZ/xX6hrIM8F1RRu0o79T5REpo/FjGXojoc6Ru3eq3mhbVqC8MkM3bp/zQUXIRgWFbYPGqV4+yvAJmyBcXercL5M7foKzIi/qRWXDrlRVtLAfR2h9zUvybmSHDpguHN0Ub2c91cEG05YGEyyPFiP5gnLEsTu8Jyzp6i7mjYm2NJvEh0dHm0Ukr9d2ymORVoxXwd9Nf+bUf5H2/ShAsQkyU6Pf1Flw7gzBEuUfrHJ2ReIu76fcrCJy24TaYWvx/k9/Byqld54LMgdBDhzLclpmwI6l6z2dqE8auC+EVDDEf40AFdv+qpeZXEtDrZFke6U+3KD3mEOddFX9/R5J24cxkrdmYtUWZ/fDPFEASYFe3MZGaGZU97lw2ZX7w/WoL87ZX0hKWOTG3b5s0w8u3HAWzTSBmv7HQ3WbhzFeHQ1JKo7v5Jm9cwt7E3XRWkdCe+5hS4uCsOUS8nJ2/8QoHgusL78NaDRdRikaJk4RJs9dAlGTFEoR8XpxZWyx5Q/R38JvZKPYu8HWlDk8PQj8MBV4XKMtfo/hUAJCTn9p+A3uQAyuwBnGblzMhejX5FncthRV1+F491Eu3h9H+6uj1jgQbfSPgX+NENu1pFrTbZY1VKj6VUHJXuUG0mxajU77NZ0lMrMCszPOd5HoPFetamIE/u7/Teg4n0aNRRQGjPHAqCbG4zM/TKsteBewru/MJLDLmW7gN6QXKdXNxZpxH4cNIUbaXbrJ4p0N7g/G0nxyMYGmacd7ZcbR7mY4fYradUKGgdzEO8hIIWJi6hmNm9S8UkByvLDY4dZmI9+SLCAb/iRDVNK83fqUO2bfb6nSMk7bSzygYz7QGiGV1OjfPFpLjVIDDhg85TrNrBMVJm2mj7Zjl/llmJIxwu2dBymuDQ5ElB+aIbncCF8qwHsWoV6G2nbg7XvUuAgogL5j9gK0Ea2H+kjqAVjFo33Kzzc4T4H8d1Fgg4QL2P2J4t5eoabuLWxTqhDIUJNs8/nD6Sqae0FaettjW4+pVeGNRXWHBDfbwGLymSouaN6xZQhpC72LxsRjarkleOo4rYG5onhX3nW8xp47PyTu/XShrM+B10Ki1woBojCNyrqx1beajss/HyOOWaTbttZUdXdcCs3ahhHMtrSjsooOW0tBeg4WR9OzuLIMjOh/cg2kj8vUcOdnSXdFQ5jy/IhSGykYyl9s5Qg14bgi3Xa6eNwkd3ktYqV4e7aKVSinPIYAikolgVacwSmgLchYCoaI7GskaqoWdf678VP9Rdokf27cGNuOD4he1VazB87p3sZrieerKq60H/eCBa/wx8sMyIWiHRwM4hKlCVBjQ80JrXJBJYJrpZrevSevUSEP9mKIGCDHlLdRT1Q/Fu6XPAX6yTiHER7Nxy92kOjvMVGeX1I1e7rEMQ6jNFHlloQ0ClyMPlOL2QxIUBGsh7sb9xiz/CXyy+VdLUNyyKOPYP54ZJhNjtObmTd6/+rfdY/0614sFMHlqIui6gsVKOg+mO+ZNARMbCgsLKH2bNbyq4/mZW9h2hTU2k3YQeTss7BJuaM6yiKZ8j2oqMPIAecYGpfevwUW5bNkXeJw6fZemXdYFw1MToiyQuMVuODRyXEnejLnmoVAZ63LcU+osDtN3qmkjU6nwmDnj0l5G6Kya3CxTLqZEjWLjhQwySCQyLSNHrMTPmIirEr3pCrrdsKn1isbSIlYhLR9jqaG2ps+xH+4l1UE3Ou84/HODsIuzTxE5GCH8fdaB0jtIslVSgyXlxeSTqClaFytYRIDCRJyJLopPO5WpTatPCthm7ojqqOe/G4IhwpMfgiNZNjnAD7o6c4yyf1rjeSZCdiMQIwD+aT6k+NG0noKs87KliAOApZXb+l1DJKI0i/azcQclnRvlr881Xml5gdRDPi1Jy+kvDg+0cIwtjSkpl41iO16NlI4TWAdNqkN2uzyRrfbd0+iFOnUm/BEOslsgOwIuTCdKlKEZ6siGwJEHy7FpSbjtOZdKGg99Z/7nN/D8WnBu4Bz8ND4qmtdQ0PjsxhRJRcmvHW+79Ddvr/dK7gmHIaD/vIuN1nyREjVrwllbQPlQPq+uR2HpokAPA9Sjip+kOXsZDnMdgXYlWhXXzRhzY9vvVXtvWoiCeIBluz+4SAhuWrBgWeIR4uGwwURUubrurPfbdPEe+7OcP53WUbOHpkDzRXRb8BfVxBS0w0pAwbYjC+NRwknMtzn0R5YmTRYAm2mkcloe95KwLVXQN/vqWMNl4BN7JND03kbz4ej4TGBBSAOZyrUN8AS1jGYXmfw2UeJlZYjz0Ws1H6Q9u8vxTiqVDXPCiAH9KkBNsMUonp0qOF/doAiPSHm5O9ELR2P3sZ+86QmPJQQmwQ112hxCdFKUrLgVKY7zH8J7DENyOYn0hG5qaMeWewHc/JMzQkoX1bYswbByaAe8aLkSwn0+HiVnH7LBf/P2zw9II7bRXRX4VYk6DY0jUBt0Mgp9qUZizo8+v8SG1ymGq5yM6FDf1vW/tUjIoa7X+URCOkiga4y7Epnm0x72ODfa/KWhmClwpD3U1ZG7sBeTnp7eKN3lcvmQLpyAjOSVpKp9VqL6KdTbj7BeBS68vyxp8qNLW8UiMmBBHf+ItbwSPyhtXC+RQ1rovK45rFFu+MdnKO8vb0dDnhJSkyq/KLMwheQqunuyicoXbMtouf6MzhAvPhPntoDhgee5zUGdOQbV7Sdi+Y1DsZORxO+k95uQLgk6fM6YM2P0ug/Mg/Fm0FSNjWaC91w7og5ew5z4AC4IW/owxfZfTs/rcyNMvE2QjJiN67qbVfnW1ENw4IFyk3V0XShwptuuAQoBi/3dNsGciO2NBBai3YHvDCSpcCtGfb0nkMhFNXFTUvFWgoZ155Bius+EfUonBmGgLlFcGe5Ib/xwIZuYIzWI/q6mTDD0zohFP6wAD5Gk6NHKP9uLGJUA26qc6qLTlvP0bbagGxWI80VVluymu1oRt8J0HisfjVHi28BOe1Hal4ZJme21heJgYZj6kMsvu4GfZi8J6frtpBbQTu3JmBMhOXUxPcyRzd64pjr/hTovbpnhvOhYmz+onYDxK18NqaTvW7MISt/xpZ2dxnMwrwL69vzXMQkIcAHP04Fn1XzzJN4rSafNNsuv8p+WRZ8DX4iFc+VMnScrj+xslig7ViF/Yu/qidqQVapZ5n16SNSmanlh4QKYOx3ilD44Dwy+4JovBA6AD8nDuTbgGJR88PxSODbP0CN038P8KtdpXqTiMFO2RGrjFFJlHKC+sxGL20if9kYcNCtfutE7evJbbvz5J5Uhn98dgNwEckDCJwacX7Titk+zH932x7K1q/wvFmd6f/5CgwQHHFVxGv4FmboyQGQeugatimPIABk413VriZUExgLGKtpxKmKstQZ3Q7W94wLJ2k+MXyWaQWFTTk87rixirM7AM9QxETYJxH0cwnEMj2Qd7w/PumMifXauqAEUzBYRsKB4dmphP2rJxnkRAkaSE0YP9fexM2jItDpZW3fant6Piw1QYJ1baC8l8jTZXX48ERhedgnzSSKWCB1k5EPOXqvgz/xma7JnAfvwNvnFa7qIHTs7cCi0RB0yM5GPPQWjikglg0T2gJOAvC/aYNY3/4s27CObMZdNtEQgDxBs97rB5xfV546MsxqD3UMC2pWv180F53q7lMFfoR5QiowjliUojqZUKg+0XG8LBc5VEIfioLGG5sUHFBzaa4pXimZqKl6Ke1jMKNR1LNrZCTSOx3xb46oMGIBT08Ai5akv/4c/sYywuyQFafKGrZaEqoMsQkxr11RXzbIHrpcw6dOg7eqVgXxePAirw0pFAPBp4vLC3rIgLQC0oMxRM7vsisOSFaTnTwgTLUMZNcXyBe3Lep7+XBwBdIUg6UgVBydmihJY6SiwXMdMHgKDlMh5S5crdU+ws98Knwst01L/TNaff2cOnY8tQ1JNqWP/wCegBGevzmXTafc4bVWkIY4VX0JuaON5UwWSItM2j9n03ZbYVuBtTWacyV+IdLB3AyY9/AMgoLADf2lYHYPZIJrwS4svCycF3F5X2hyCE9+qsY+m5VJd/tIdPJ/kWFPNjnLBv89mJFOojy6XHGhh9ctnQyp0sEqs2mbIFW8OT//hmEgg7kgKxg02dZs4y3OgvdPCRSxApKIuJfz26nVs+woeC9lcgmpcmdO5gh3NpqRrDzEJW8LHOnxUa6VCQRughz+7GnFmjqP3kvBoiDYdODJeHtKRASEub/j/6Q6M3IuoIVhqci0hDi+4ZGIthfXKHxu6rY2yALqNNrclJiJmvWAQg/2a179m9bzoekH9RvQmZ8YXvjfKf+IZ/Z8zp9ZRfNfE3xyOT/L0dGfG9kxR5iDP+hJ4NRApUQSdQxO9SGCA/Nh7RZly2pyqZ0d9DAE5JnS6B5/sl2LOohxPWbSZ4LnVnFkYN7+sHyZGBZESn6ZI6zXWCCoSM5zVOEFwcqVoLepYOjS01pdhkEsNLCKwtue+rBidV8whZA98fzcgnPqS/7GVXL+Nj6iFrrI0+4dbJ/U/4nvoScwM0ZgtGbrxCWHdtFYMfOok/wiCb676E/3M8o/sC+FNd8Mo8YplRqcyWVc0Rm3uLEsvqdg+UD8a/XHbyTWMSJitDYZWKEo2WiG1FhyY1u372RmBxN4Sm/LzHGEN0saD1riodDnF+ynyCVzPzz1QOnVnVn85olmYGcNtm0MY8ovRIn9Xj3TnIBasYczfd0Ib0Y5koz6FwajkWOZ48Xg8qz/JL9Z9N8cgPqoZ1rDxP3gKA/MqLe1iLjYAf7TCl4oJAJFiwEqerxRrt7suHak7DfyKo4AFAd5zIewaMYcyl28BQqnKfvnXfa6RnDvV0tyHz0m1A8hyJJ3QelotYRZWIo1QXsrZXRJR2zdhJRtIb2vjZckm4KcoUxE0Tbqf6aUJm982Ys1jwqM107cy1vCLU4uOnWiLl70jSa7UzvzfCVcG8M2iJzSSrmbjoZv1qphdcni6W31LHTtz0XpUtqjMGxQS1EwFuFRIWT2cIYP3K3lmelwu1XKlLOaul0O8kJLX8hzCN9QAFUkoyjO8EiWsUoH0GrD8esRMVKHLrgSSb/lhbQLm3MwZMZR40VQUNBauOOfCQpMKOcIKiooDPeLy7gKu+MryFL34PX+pY8z1C6vmKYVH4zYDdeARwt7+ay73srmk6oc/Ti+4qHR6ukMjs2AfetvcHpCQrRd1DFp3W5ZgAuSOao+FbGMRpe0Vza3F1BNsCGQ6Lc3liqf/QiIJex5CfOquhPD2ybXH5KToxkLQ0+ylq9nsqA8/xhTNy6DkF5My7D2u+sMtEbEktMOwyQNB8J88RyM/ue1hVBTgmml62AHHcTHBVUH/w7wKUGZ+IY7NDiRHP5aAaq4MNpxyC7cfcMyU8R063qX1SVuf1HROHJDnD+vferVLgArvcQJoJ1jzOaPGQl7OqAL2YHtMcD9gtlldlEHSFhWu09wYw/wuf4y2suwmQ+P+D8CGSGUNaIc94xMKHqO/86+b6mfstTk8JUshd+c7XHH2qat53cJNKhtTac5M+Ye/haxvl6h308FZ5bdR1YIZbLKjU/nn22xOqaZFgUrSdHWzVcaX0sKpWjyJLmSPNkaoSVWWIeRloJT12K+1MgL30R4kxYYdp1W+bSpUP59Y7gEeM0W9nwYEkEljjbf2+QoezNAg04QuK+fS4MTU1EKA+vPQSCTDEqx4DRUWjmLSDiPLyQOr8g2tSGb2cLJyUqa5nEGoOCOKqF/wa75ChVXOH93j59VyjU9i+H0SkNSfPbObsnDYGC2w92w09g8bUea0O9oBaoO22iwZxzpdNNSn2ygfTLLh/dh3vyDR8fs0Ri0AHjvfUJvarj9ImCaDgn3a4UGhvPgqI6YNAaJ/+Qhe2KXZVoKS5DktZkCbtcsX2dtbirr2yWLLPOj25y0AOSJ0/FiVmAzraeD7A0luKwxuoxKDa8V2M77Wd3VYuXQQ+F2CNyw5BlYiyC0JsB/0+S7Fcnmz+FEKtmwwa+GtVRbp6hjlupSjufu8RlK/TJ2sQEBZv1hryz3vU6QjnAq713vkAOVbTbjgOUDugSQBGamDETN+UiSw4N1exInHS0qwD+2msYjb9BQsep1KOL7ZZ3pDFyi0YiRvAZq19lAe72uAfETkzGYy4Cd4j6T8FfcGD/fhWwP+CJBctundR+Pzj8m8T3gglFVP40ApgrNUKZ/yjLqEwryRqusZfX95YFE1uvrKXSLqgDRKSi90FVQnmMRG/0rIgreOKdcHB+2DQFc+qxqZ6JwzIL0UfCjvs5fKMO3UbMSnZNscnan7oSaxnTMwAb00wNvB+Xg+eHanhFXti0WTcMB6f43XNjhLR8P2H47XlNe8VZZ/DWPKjS1iQWVadlLzPrQ1zCSmPuMBTXVr9ndwj//HUg3VULzRlEd8k9okpy/gZIjJrlTNCWqJcx/jDSseaz4a5LAAv2WLLBQ5aZHcY94Gw5CzuHa47PgjZthzyqXIPhCzolZD2xAEVXH6RgQGiIFfMgPfK1A1ZGdO5oN1W9J6gbRQEn18lcfOeLN/Z0CeU5PY6ylayI0kJ5sTrXdJWb0qACrI/IDnr/YLQNMllK2uvjSPTbSzgcpRFenMqpkfJsE4qMdG/EbruaI+GaXWZVbVV/pJaBf8GkgvWaIoC2uMDjTvqpAOKqe8VFnNnTXFEjGUtQTO8ZwXiVrtx6zMNoz5ScxMJqO1fUgdK+rlcFSr+OTd9BtC0kyKOLC3t0YJHoRMsPdyKFZOikYipz71rHmH+BdX8bHrvw2AhDKavI0PT0wiKT9uD1iVi32Dwbxwdzf8beQ2x1u9EupmbkvKtF3qi8x95LocHbDTz/uGytofg0SGE96DxkahiKnlt3oBPKG2aHhHSJQ8xoWUtHaBoI+wFm6dHXppV+mNmnHT3cDgkLbQJlIi7artZZ2LEYryfE39Qij2lMZJSQCFGiuoXwzwwMuZxljPzMeEoj3sEwxo3P59ei+mfMKiXAD0tP0PhE3nKxuTfjqprIWbZRJ5VZNH+BhRkcx+YFAgSY9SBtNivmp2yHDmBYcpU5m3AxBbagm9x6lhncyPJawZV0O/lxooVjt9jD/1lkgLj7lq76U8K3++QPrVULiinIOYmVgCJ25ZbQMz8ZNTFcLqgwf4Si2SL0EJ0NMDL6z6G1l3XNxR6KynLGwl0EGcVCcliwWlGjtTDy3rJfgn0IdvCRMF+nVFZxIIxYhMAGLQOFSTE4m3dDW8aWX3mRV2fqc8rVNkSvR+tB7/tmIpkYss7QiXWH/fjQEr6cnxNs2ao9U2wfiKjcX8uNxQQXXaXP70lXf1kXkdqBrixfpcAr6dGm901oRRbt0azQamKqdxlap6Qi9c0xq2VdmfBevfyVCKCYBvj+24oVdizCTYhz9u5WWnO/RBCN9UFyvCY7Sh9ZBPEId+SNU5Bu2pwRttzS8qlhNhuVH1mX5zbRzn7ulv+BWO/R1qBpqa7oKRgUSDLyzrNog9gNmnhC/zDk95OZDFT9NDbVnPntYDUCoG4PcNdxVjfgujCZrhMkn6J96xZUOMWOqlgXS46sAg5FGPP6FtSxcNtegtR161LiJWGpEl8euCYcsesr2RcT0V2O0D/Xnqxn7E3yhkKD9z59RRXHoOu39Sl93L6ceZ6DDVZO2aOT+iwU6d7hks2oDXnvQQUT5CpIIkS7+EYrbGDMms0fqIXQcodVdnpJ6dKGr64YJzTIgOqaAOBGppM2gWTx4skwsWW038q9GvCulb7hVkThzjyrE7+Hk+Sd79/ZPr7v7UkNuPwP/9mB6HiPZyMa+mTDOJnOQmiM7E6qhgzCUPkU3dRl82x+6Zx4MF+kD/+hrtJXsYZ6qX4ZV+LWOuu3l5rBWK4cN5FQtB692yDOfhY1uqu0eNaa4Q2abzST6mtgQ2U4V3T4xDLsVdblbI2dodDTfmfYqOypwWMA7X5FiT8vbPXtp0GBflNmUjwIAIVChAvi29gFU3q0hsw5U7FycJeMjWV3C/GlPEu3AhNAFqUDjmM1okPxkIlAOFS+eH8SgHQ6NitotbMIW+6TzEDhPN+7CZeKpRv9+UiO1zVz3XaT+Q+vcLvVe6WlDy2QiCLQfHV6o9LaDE5pBrL9FQO4+ZQldBE4cyw8aIxfQ332QAL3QIA7Y6inpfFqCEhtGSbZAcJILAnpuHR05IZXGS9vhqf/wpdS6GPoJ62DnFDOZFkMrVrwAjEe6UrV6MPKDDawT1Nu5rLXKAoQBX0XYA4ukDYFHgTHtm7/IwCnGTQrfsTie2VF0Pc6LXpV1wPg+OtfbhbaP6MU5lwoKaYMaahhikn9bKvoHVP+n+XQhSiZbYKzy+vIE+OKOwRr2yI81A6TMYWKKS94F2lYExNyMNP/ihaTYwLd+050llFGE8IQ6lEkphF+uuSCj287mqNXo5D0fOR5dHY1cVnDI2B546lHqk8VuQyBXdSy3Ycua7AO87SUgJ1Pm1tn804+IqKmbjVpOz4KGCEs5owvf8CCmY/+wMvfsEiP0bg9AT3seoktAjG6nn+iKaGtsqHiXysS/V4476fH1/D0ve0+bnughfQNhdmsrD03dJuznK55OIT1sX18nYEU0ffxKfGq6RyJItiD3h3ciPplZKY1GdWk/3m7B+iIeySsXarHr3kWRpwCJwfDhzP4qbPfmj+FpKYOaGWCvgVPdc8P9vstRf5Kn8vRPtga2UHILZk71EBGWOhN2ALo9u5IVU+ykk3mo9bl/2oChHvorBPz/xvcbR1vShk7MTDOSsn3UQYWjOR4UAC9R9GgntZGn4zHPwo7mRoRyU56pyqrwps/zazOdjcP4ojFzViVLnqH6wBe28m0H8iOe+G9HCq6nRqjURxSO3w1lb2MhT+FM9/0WDwoNHKQOFSBbpb+XdU5qB+awk6F1V70FD3d0Ats+gDtSWfrCD42cxCO6nW9tjq00Aj9atNH445BjE8bhIy+4vk87u5ccl/I4Ci/xSsKkoZOngUqZpq4BDn4bg0RkPzcKNRrCWMqDOjfWFLmIzOlmLg6QxRxpnSbmHMfYRrOyMSvIXgP5dVLOd/gT1VTzJvIOrLYu+VjQpgEjU8HjEVXYcHxvt2AMUSOtVGwgJgxIPbd3jdvbsuPx0yY8RAEA3+pQm3UoAtssoZ35sFrdlu5BIfAa637IVfJ7F5jBu4+myOH8rdiqYJSM5mQwBPdCkYX9xTACZW/h1ly2q9GTl+I8y7QA5kkI/g0dEllbHmiUqAth1uxE5Nt+0LwwWXHLQ8WgvBfOtNVAy80JsSYAYxAvpveryFw8AS2X91NerQXjNSO17Rlda0u6ImBtJjpwisyLtB45GvAfhQclOkktxHro16RweXj4MSj7vl1FmJguUwpG3IcvK/Gk3b1GtqQaqr6xX5FyKOCcuySfCBt79xbB5V1wR8BZUJMPMoF4n+nllKQZuaQp2k70lp2o86/WVnxyBsKyKSI7pQLRuSBnDC34zPDybY+cOzUOVsufWhBOfxkkR9Gwk+3weIo5YraVKiRDrvyR9ci7T9tEVogwdeByGmGw6/+DkP7gqVAd1hzajFcxvVceheyosrNdb3yj5me1jVRx+UHphaGdXWTKNBhYLId4mR4FfQaKI5yee1e3lUq5d7WK2E+91C5gcNszSeLGyhZdg6H9GyU65IRd2C2G/3EtbBde3JmbgtXWPMLH6YOfkMRlnoblVGij1IX2gC6eZSis1cD8iZ6GRmSYprk0CJUPFt0nTmrIU/qNF3kZ0fzn5ggHIdbhdO65gF0qgna4NLCKJfV138RrJ8JMPEY443OSlCDK9UD6H8punjrMq/FPNN68/R5fz6mCZYKBmT6SvI8OBz+QQLm2lhpo1ggn5JBkuvywk6hvC3RNzht4K3ibjttdhBbEZI3+YuZDWlZUuhuZXmS583uccHRCmsHQDqtNxTjcH6OsIaFARfWFcue2WWBZ2PE0NWeQTJjRjqgWNwzMi6PUVdVIlA4PhHRyv7ifIYUugZ0gZnV00QavYgswzepc1ENCibPraO1V+3HFhnz4GyG1J8TBW15xlLQVJSE8eFqjR0VpXQxYiVmcl7jzvHjEDmQa409nBcoVnb6LDKxOLMGlDKaCtAu9IUgYB/+bu9H8T8VcqpyZbzvsaZQKbUWFQxlTuhRuwFK3yjkULCM7sf3nljIczoreR2QpNq4AJcwFe3xd769eugmNAEJGwm0Go0PgIrKaU879IO2meRMtJhdUYGNS0UXH+DYg/DGxAS35nJ2MOX5RBsK+1r/cnQxZNgyGM+S+4ylCfiQZfM3cMY62O/QSOpsYBKhskHK5co9Q5RP5LJPut1aWXkIdHk9sEIXlGKaLn5GpcMDqOdoQuRKocooJ74lKTjHBFAP0oP6+/WL24/XueV5fWY32hJMsso+wyG9qk/Am/++skitwUXF/m7EjG/ilNzwHh6/EoT3Mk3NhYWwJLyamPqlFlAkbQ1F9qrr3Bam17tk92x9n+7QUsWmW9W2oUlDAgoIdiCE1DxEENOm45W9FsOLRKFR3+IPhv5yDtbOHn0Y/bYL2xDzy7OkLniAI0ZhmtsKZ8rxZ7EKliFhSh4s77026r6VQKV5w1TaEeFlrNVZlj+q4TPyNWlCKo2jU7jSpqT3BrsbRCpHsA/5ELOaxgUFU8dkly+4B8j3ko3t2sv4HzIRkLhuehouAZ1giEoT39rtW63RBxSV9GY/GVhBrcQEkTCvHEJhQ0qNFcyWuuaCOnrxSjiQWYGmH3gdTIV09m0nJUFFMXVHUfyUQ2Kb0idjrxq3zMgQFAXgSm23tslbqHvzXxYTOFycCxxpeknheHjnkGytNomIj89OWd5sHoRu+EhBMem/y+ptlUwJ614ihBRFUUc97hJSMYp2rtynWMNXnWS3piNKvGlKGICd+Z15pYR2lIzN/TG5fG7hBjYOpfZePFatr4rn8CmfEm2dUBAKUjnwShhxAC64eiqG0R++YNHzJ07qjDedL57oIznvlOheU4scVbd/wwIE7TVegAV8Tacft8wOvHwyw0loo+FJ+OhEwDGfDEx2HSIHbC7e5wUF6I6OmwCGQrBscmolTQ89aA1drBMKWy0Z0g4rvw7ZRrY1fuFN1/GpShTTIrB45kXfRjP6axAZX682Adr8yO/zIxRoztM1wxeiGaXWmSapJM0FAYFyTR0NMkVln3+7NjQ1s0tNVOCFbcns1mvwjbN3JfFojONdfNI6jgJCiRAsTkcj+l/IjoCDPCGG32fmeF5vJt/1xRcqIvQcf6ueinilAr7ZcmtUDOGHjxOO/KodV6E1nq64ro9UYav58mwVXtXMcm0gaVXLGrshDsSyoFAqaxFhlkZlZxi4AYA0KG5NamTFJTfMl/JrFBSk1i2LzcdDR9gcT2HE+7PKplPJVaueqqJr29+kbQb0RnKSGFGcjSO2+RcjWutM2U/a785S2LuxNDTvhMAnX9mzEXtPn0HjwBCC0aYrsCP+1x48dDG1W2seJ586mq+j05cyfC79zdeDo6uM2GjE8E7WtvHSgH7S8QHQB8XlIzfdMweh1gcgKFyWC2Oi+oKJyTQBDM6c/EJ/n0djY19qYkBlkNqhvhp74lWHEfMADmq/KHIIih5C+19BdS/fhXZE900hXzPPWfz2nS30PzyuuCgAQKugfsncWZnvmAYMawMPwwEv6j7Zna44uHLAzmeW37XBo/T3+rpzPe1+TSlX81ee3cnWXdhGuNNQN2H1KWAw636y+DKC8WLm1SjVIzmqh0zWF9EDBOATMFQ3PJCLO576oVC3+aHFlI8QbtlWNctzLHFYtAEn/QRHJVqk0TEYwwaNc6ZKtLOwLd8D8Iwme9sLngLDcThvd+GQIF3LC7wUCNnHYGpuYfZEiyai85w4rQtcS3vjiaNSXeehCgMmd9xi2UtyXrnghLfmF3jOIelLMit2nO9IZp593wJmGtbh/Arp90zfvSnxo3vzUkQ3FRAokELqPoBE+A8WIJs1jljMQL1BtPyNLzpAiKkbviQkX3EOnVmGkkY9RSMm8B/HLvblad2mF0YQfwP0lHGn/DsHd3JTobqKXYQwnXQe0afBrtFyCKQQ1z2fPnSI6PDsCLsdHwRKvZGHiyc1lW3Felg5XyPEPOxTWbjSgrmNE4+mfaOKsPoTso9qm8xEvWFC3r0bwpc6M4oMWNbI9SaKCdmkN9CysI3oRB5WKI7HUXMQS6o5a4fXxRlJttHklMmvdRG39hv0rYh58kNvjuT5HPcOqgDbuaHfme6hp0fmQzthNikstzXbY1z6HJCu8fLjip8nqVzUC3E/t35aJzpXO1NarPjR0t08mcosYalHodvcIJJT4Lf/8wVwNU/JXtxjlm+eiggq/6jPFyzwBQTnCDmjLAZynkZ1JaoVQ4Ap8gJQlajwQQY8I+W5BZP5t1czTjvlFt2E98Q74I31AI+UeXD9NPNrkttplNVpFMZmqYItj5WJQyxhl2xRsHIeYe87UDb/Z66yWHq32077G6+O2GL83S5ltOr6rIxroAgL4kFlKTbgEfFI9Zwe5BguV62cviichh8gomgI2AbiZNb2tw37Gluw6dj0ynZkYa+h8hXI6hykg53ar0ZHBATWMTlYWXpEmHiT+RiqEQfHvw9f5NXSCnaJs2AucjJ4m4ErhySsvmSB0iBphPCfN9xIkVk5574B0Cb26d4f5SoJS4vUgil4IBKDGG0N9j87T86ds3jmfzQ1IJ+rkvx6fnLdh3RC/k7mBfZjQYNaA2kGoqYFvCNVcM9jqfPip+DWpaW1n8VreCUYCZth6SetamF3X5avOqighGvpmSLGNb1PJmjfMWgbdMJiaXguirxuztCU8V3TtOigsVavbkC6per+Y/wJVsowZr2EYRSfgNCldSSjymK3fwh2tcf3vsgs98HP77TN+JUioHd6LLuTnpcunqdrDie8o+zzG8Pma66fL8LuP7csLg5yoxDzrt+G+afNxJdiEIK9tQOAskrbXW8FLHk1HeD3sQCqc2u0KySPlxPs+kStv0UX0awWmJH5I9h765hhC6i2hamr7i7K8xqK6YxgUONnw+DtV0bVVD4qw4w6cT4uFHU1HVd93FpA2RX6ErNgnxufx2jqS6aI57nTk9YfvnxoDB22HSIcLnhYno37xaL0oi9fnT/KJYhb0TRz3vcJah4ac8xFTOuQh3rXKKm+hqCJ9SovAipd11BAHSI05vsndFXYYqzjDkZ2I0KbY/SP8KsG1/eimyGBKnZ3qyatiFIRxnf1uPlin3DfLO5yT3aOfrTVhML1F97n5lx9+ciCevtHdcNkNLymQ5nzM5jiwUcQRIMNpVbDyBFdd9cKGE1qEkUaqPAGKFZZK8XaVs+3Z7O5iA9WdUtBf2GH4DAyKwZvMl87GrW7ricXqDv4wsWGVyea22Khq9H2K5y0V/v992krLF9xeizReGAkwZo4Y6MJLF2jYAuS1DEFJvyC4sTgk9hqkAmHLFLcPRSUNP8cZy58p4fzpPchoXHFiURKJpNrLBztCdWiSwLAgRQSJW0JEOIZrgPfeh5lHPxOzq49qWdwfD4OieHYSZ+SjtWlikA8EsJNzKAKWjc0EsZrj7SqYpy7ePyp+NOLZ3H8YS4f21opOGtrKA9aIGfbOHchcCA+O4hUN4HGip3xiXyXtjt/O5nenXz5Eh7DMQrR1dAGOH/OOnLRdQH/DNnI3nkvzrzxK5DM5tl2KB+so18qYUzgiYlBVQoL07rqhWgZ0M34/NZk9wf8/7Z2oLW1telgDZW8BFfoD0yzBtvpe+G6vcuT7gkpKq0YRlN8FRbrI5FHMTuJRhhiHeeCk6eafrKITEVBDi5hBq47/aJCM/dxSVX/H+/k7fDZhJmAj8Vy+b3el/Vq72ZmMpSxhHvA3MbgwMkQdk47GFEt6KDEhguXiQEnxbHpqLFR0FNXppD1zEXMQ8+P/iVWBXH8XiUj0YaUIKr03o3vw/6Vf+DLdi8xV95fR9mjfS8LR9NsY2sFQfRZCgLG6OCkCXyXMM0n6fq4RQaz+NqQhScD9rOBUkqpzTUICBx7XW0IRK17Thy9E9dtcGt70VDbZoNfo2ez9oIwgKDSMrYKZCWA5nthh4I++PA96BDbU/UxN+W9Ta/O9sxQjRQTdUynh/2SEHNz08zJ/Rkkri0V+i9DX+E/rfA3aA2CrM4FHOaKpNNupGOuLl0TMwqvMSp/vVz4ZAIEeMTFCN6e2nk2HiyOF4rjQoWTVg2lR/MvcMLk2Kk2RVcR44exjLlaAgqaFBtQ1CBEfv9vIgtL7uwgDdNmdfkWuD2LEtgI4Ubc/S0I0eJYm9kxZiH2h5MOwkVK40U+vq4V67N/SyLS99/Z+ZqZ7xzDaKUYjS9w7Wq8wKd6SqNB2M3O+lDMnnXHmCCacSL/7yCZMJGFORqaEn5IqRlDSZCkQRLnkOfykIsZqh8sAy+IhLElbShBPhN4cN/Bg+o/sGMDCoxfKi5c0vAedCfzIAAPe+tt3yJqtcRIlqqkBe+BTVAZclHW3gq3YkPYp5nFvZiKzgk/9Em2YglJ0ON/O/8IuI7A3VpXe4lcRJgGjpUlbTsMgvl7l4/sq/4tbXllywdQ7jEGvopBXTfA0uO935xA+ZR3dnR+LPQbhx/8nvzGXvO/H1g4C+NjILYPnKGUDSVFXgF+7iIfefxjTV3r7IEa1VGEXQEUvrvXg6N97c1Qnm7998+EQz7MKKXiClPVEChETVC6UxuoiaHAPq2bT389YXS2kgVxcJib2eEBjyzwbNPr6okOoREyNwnGISV0ePfbXF6z0QZZz0jifkaVs5ewQCJKe3H16Ph7Ly9sFswXG2CEV6oNMK2Fere5DCwspP6/ZemOebqz1Sey9WwW0BWpz7g7R6XMBOQd+CmzFo8ofxNPIyBT/PmKHWcKQoqdCueXS7ZA3VSRikcT9uE+1IQaOQqTRqTq3gIyH7taF0kWO6HxnhuqS2qWaS9KBeiNxR5Yo2EBMPS5u7mpWFKj6sS7OY7YdexusYV77d+MOvnUYZdwphIABtYY+cnIi6ENPGyh0d+JQWlasN1My41kl28Yv1y10D/8k200M+5xzrH9tLnK1CNz3GBnLownDp8Mj26wlBGzwZRSD9AsAXq8A4KEwyJ+l29WF0FH8V9PjDTOUS67gthFbXxibKuSGDpcLjVXbP4Uy2IzOnJgbx651Y0JwAl3Y4w+gf/rVE+LHLRJhvG7Y6DgV0aKzwjnphJydyLI4TZWlJ9Gr6Z5LX24c5D46gtWp0ZeUtPnD4bMF2jhnxWK2mv46/NwIQeYAsCGvbJbJgfM/gwdSj7fI22EDtUupCYMxhaumO/oRRAatfLfrbLkYQSKHh48cyTZaRXf+3z5Z1tXBoasbNT4YNYNPHDRTeIyjKo59DW3w7loEUICmlaEa8RML82To44t62vHmkPijfWSqEb6YyI3mDStxiiMCMt8V+dBCeXlmkDHvsa2eY0mm4GdcokkNqksDbhNXbbJrGfA/mKYWYA0RgLziW8C8qFouTu6DRWPVcq48WmvMv/+w1XLM+2stNWMhhTzoLwBRfIGYNcQz43c3UnDb9ssTStBbnmUQO8itEALoYazpBodf23FT6u8Yp03J08DQBjGdidoNSPKG1OWXwEDyvwYvRXkdiQ9QqYVqVu6/7R3n5AogAGdPB5MOKLI0ivpExBLpirNPhCvIz2Ft6jJyyXWGvWoFON2IXX1O3xZmywkQ4XLdZw1FPzRo9ajbKompJKG98nsblFj8WQxAZtdOruOfpVot7hPDdkUe29V9neT5fdkZhACc66w4k8PR6EJZvO8DXhmVLVH3jGuUGWE7Gmro5BSPtiAXg635qL4WGVyTXEYArQdPajojGiJesrE3iBm2np4nkAwi++0t0Kk9N/WTWCZzLXvgPPr1g2SRV8r0e80sRDu1oZWae93UeFrlFOvF1/+QbA/cmhzFNo0u4yu5Pp+CfYDhYux7yeOTiDedeK4Ru+b53ZvInw7N37Gnw8U0+H2wFy0JvANPRcLQKbj2kr+yLM1wDXihjm8tiIE8jiD8wyBIEB7eWECKSRdpGkMXZyf30WJQcaSJfIcKNV3Y9MAZBf/PnffmU6m51GGGY+sdlryZ/XEvBeHCkQLNymGUoUusHgpyD5J18yCKLs34LkgcOYRoudno+uhfLkPoAkP+toBhZZyR+Ed12/GFkqTIylEn60GeQsr3Sg0Jg2XdR0BxkhlWKNhPw1nkFxdJ6FcfjUDUAwjXYSdLs/hFCxmlCP55zQ7xfOw4DSXIvqTm1JbqPOoBgv45nu6dATg74gyIW8eM3MEJ7CcS1HRYhfNL83T4yw2kwyeFGBaWhorCaErjy8nJdsxaFcz0B+sAzjlhBARjAFJbazQf2h9IL06Osk3s2eSDTU0flsO9vHR9b7eGnl4BsW5D6QMMYUfEpNsxnoooFUFX2qDMoSCF9Hc+i/shU5nRvdvmx7RJWFh7eRQqFDHBk8ggyCfEBE0/p8Wh8FG7dTsosDYf6pfEmbCNIXH1+z+fKDO5tG28pZhMMrSBG/SK2ZL+Uhopm+jgy6s8zc3Wc6uhG81nua+Vpm9q0GJqfyLr/eThX+ewMvlemsUoYunLRQxLTFCvJ2zNxywSatxYsQ6qYVS2pudOBYa4T8gmoth6nABIf7T3mAOCc+H4XU2e0D2XSyhqsWXbUUQXZgeaIHJ+2jSaq9wamvikgB9hUgQXScT5xWuelbyRfxElywep2StQ4T27FIpunkW6nC9/Hmck80Z3xogZ2mS84YF8/rq35k41Bv9RhNbEnLOX4eLXc0Gdyz9z5ZzQqIU6iIUC4JP0AyzlPOYVCoxhieayb5PgFvQd7OQ5VaLrHoDuuDUDusZHyzUFNizSQqxoT951dzZVCsLbzoGLq/PcGaQSyp13izs+Pb+HxiKJembT4QrOaNy+QejES75ZjmKJJCW/hOyB1SSxkCLJxFTHsx/ke9Oij8JZLH50GAMlbACyt1AmOswtWrbhBnRJndrOpkoyessTFMdLcN/9Ytr9WPMTlIRiKjSrSJ03/kw7vk0gAHbgiqOYkDCCnxENiasE0fFO93XSSjxhE8rRBX1P88KkM5cF8w0ky5yzpXVugVN4WpA3hwn1EYxEs6e/iUH5HQu/T6js0TZLztT0UXXBedGS+PzHVNSNj3z7W2/PlAi+iICxFOSssYZWYGy7g3AQcP69IJbnj8GhPKP7lAqKQYHP1i79H+Dpl+a11fkUaBQH/7l2omjciup8Lz0BVkD29/t5QWH9UM/EqnxwidSIXo6yq6AS2VSFgvsseFBaJdvn+oehHmARRESsxQZmTHpWQH1xCadsKeZXX2V+cFAtrkUizxfEsObyftjhplmLvMBxZIEmdKo9OsafxsV7NeCe/Bm/fEMWGDP+hEqGhotd3S5fhzs+ZhwxEGN2rsaIvEtaV0I9HlTnQecuUlg9TAalHJ5XWTba3fOJuKIjxp1mWNyjIERArKMIPnYCkbkO7a7M7hpR0jw6dxqEvHCtQN+HhgTOAzJxc0ugE6hynEd4fYGq2vFeG5HfqP++QO48FMx8quuyFHVRpL3vsSNWrkhIYZ6CX+e6fFg3ZRhtEDqRRRzS26syKWs1wMelK2xpgV4BADFNtqN0uW/H0CnhA/BpBBlqXsd2M6Ipr53lJPZRjYq2s1peV9+DRjkO9JgVtzZIYcZ2z0WvMCeQuc0IZ8RmkfFskRimyi27j6lsGHcyJrvoW5CusUxMV2YWQ/qLKhnbMmP44Y4gYAA3F+VUp0zWF61XPu/T75PsoDf+S7T5f2knvg4+YgwmKeccymDqERqYrA1XvvKUaGmRueCo57bwiUnnExNoTYD8Oc5HEepluZYxp5MFPT77qDUs5Bt1KR1tPN2IzGqE/JbsNGElu7JFC8BXJMOaEQOYnBoClltQTirOFHjr1JvMGeaA+IGwJ+nNVmcFDfeKrKzgukh3DMcI8lO+Xu/PQ3yPPMEGnM2cFu/5yyM0WhS7VwDZdqmNt2N1rFTJNlJ4FNBBAxBFbtcK/ZUNDusob02oMd/mGY/JBkMLFB9fGmnhzlgrij4yJHx/LBuF8xDo5AnVDh0b17qGuRX1o8f3hqEGtxc2SlA08+WKQAvxGYNXw/kKBtyFzRTdT2k3WsIWf3TDhVYJ3uvRdjjCUIxfhO7iNbpfAObHBY6HtAF8DGi6qODigbGhAxBWuye5MQ2YUY0bz47dPloap4NnIpES/onqZ+NMNQNWtulnShrKhOmLLJjyBNAHXv18CP2RozFAetdx57LD+4Hvw31obUxuKHtyIazyl+yrcGeXd6lJ51yl6GqHb2nshVd4v6RkgfrWtGZ5jwTd6dMg78UqIHPu3FTCuEAN+a8aIifldRZkX+pjSHL4De1JqsmdJ4no8THp+8HOAaRaM1v0q1hOwyFbrvZGjDl5fCTc+SSDrwUmT2Njl/NtSoeimsJj8V4WeNDfoOuNimCsiFnGWEOhD/58nddivKKzm9gZWGw8QqmCd4lTxqTz45VasF25LBeaIwWfDrKJzUd4B5XuA3ZhUUkC1vKxnAQH02WpmYj9cQvoNWmHn8sHYabcdCP98wbVVRHC5bJB8TFVJ4QjuExev6NqoKT1wp6XWDM0MoDr40Wk5T+nzGSkmBnQ4ObVh2TtrPqVUrOCykG+AQ+BDDTOj1JMmWaKH7SRolUVCKB9mvq4mxkRvewh/2yjiohzj6vmtdejbeeCu+1k8r77k841D40Xx/IWcHEKQa5bqlm9++UovktFiuDyeKH+leRb76cemaDK6EAmUiOD8jGkedUBHTf6BMQuYrnCW1twiN1hNKU5qYvULgULc6h4NK0X8JepNL5j9VnKXwgA35dMCWG5jpYa8WmRbgz80PSkiK21Kmbu5G/GtTRo9wmZPOUcqIMGEUlclLWdwXSUm1lqHTNNe9Q31+ejIfecCUtqNJVQ6H6+G6SHS8Ntw0jefQIJmPOkDtsgLshaCaMytb3I5/3la+67FWztpvLndz4M+La1wT+5ly4T4ig/kb3qClFm3zSEcGkgGCTwss2DQk0hYRkiXyjdCSz8JnQmUr+KNO+DCDJJ4Gly5H8BrFMQ7lz3pI/7vtDDRY9o7dZTqEOHiUmhS2UvLYkVzf0VZR4Pmfzc5R/PNn/oyPKI195fFcKDv9xQfKyPKP/apJLIirEfkrultiBHQAkN+If6cq0Gvd0TLDfdZb2gWy8Ct+dTU/xDjsCv+j7esMON+W9LarAgTt1WQI10tCt+VhxR4oiNjpfyPfToVlAdm3Z5h4aPWFbl/oEk2cSjakYa/cAnfr1UmPmSm3Kt5Pb5Wr7ZH6UUSMaBC+TwziLxGjjjtdV1+5OAZN7y+1eIDcO4QQql+g7R1eTvTANvA0Aokrn1kbB5F6BbPM/tmFUfma90yafisci+6TyeTNn5s7MtgLjzSqbSBE6hpJlW5cq1BSP0v1RW8gNNTxAoyHAdfBmLmnjHHZ6Ea4001Fv81CWob9zmkUJQl1Ho3Oj+Appnojt5cioHX31adHrn1c+wXlzpgKSnYjiDAeRFFswmwQccJxCGKuRSFIgiGK71+k0ttiaoVAqqP34YwKbq/+oY/4QAuV5vAEIEBRirWRo+cBXcR62SroXqgzicBuiay1HewuVXsvmvawO/vXTgoc/B3iIbb9AP7reprB91zYeREcuutuQCQa3fGOG8xdzpiMPMjGcKJ3Zlr1AYEB3bFIBBBgcJYwZkyX+yw1TP1uD/SMrQFG7gXDyP7vwdy9XNjCi6KySr0FbBu2evQJl7yMJqMXW/myY1K8YMTpjPM+II/glE7/2PCYiTphsIruBuuxaHPQWns3yRnHr76hDsCSn6622jYx8bVnpxUpjYtLlcQq9pGpKF5g0jlnrkSh2rNFNBa25CJinLEKK5nVOB4NCm1SjdsnDkLptrB5IFCR0GIcSYSUOb01P1Do6ZFCxDTJRfxETJwyNzO2NfQ3F2hZWGrjt47LYEAPRpJq0ob3rF+ux8OFG7V+rdkEoQOSIrrRKmX+aXhM3cylVp2qaF6u83VOCFSick4NrlOMrzvAjwNXJ4MVjrgPA6mCaBMLukjf63rGlTFE9hTHtWrLu5egGLqBh/+ZMRlf79wsUWuw67Tkjcub0QaVUbBIAC6ebakgHFMt1o7bma07uorcyl61p9CbnnBVd77A6cQBN7TlaqwnkK8QmYoaLP82Z/AKwoEG3QWwh2TtQ6rg1jz7zRkf6Bj2g+2JOV6HmbJ9HTdZuHDHrm5ahYvCGfZ/C1BgcCsMQGTPHcsEbN6Tsw6GPiogyHYKP3KKM2oOisFWZuxBRBvgxIWvn8byKr5KsgT3l/lWSb2k5F+DFsHOImB0xCYIWf6IKv9bDUzOjv4nvEOHLFG56/ui/3sFe01pqgMfAhpI7/e41ywKCMdGnPMpbBpvJsnyJrSkx9KHydMfq+i35LTrM7DzKLYN+F92bs2kBPi49aiWL4KMhArOX2z4RV6I+f4Z0mSZzCnZiv8nDqSvtF0NO2qoRqLqqTdvIL62sWyrlfyFQfCGDk4zP65B6SHNZdRVTbdOFAgqWqzjXaivHKZpQsP78q6Yvwhf4s5krRQK045WW2Pogp7cVAmOx7GuFFDi4NU/TS76Lt6x0B5PbGzJX9bY3v7l5sGK18i4HqFTJ0VfEzB26TGCsZ/ECfJn35pcnRqkEnD9UJ+PXEJMRjPsTnD5BqvVffKBXntNjzbyNrlTW/uP2kHCCusXrvEDmyf492RlYU6nPdftTzOBQP1U0G7DvPS1FJURf3HTfggsKtjqykQHKwLAmNZoSpURxfduGYQetd3vsEssdL09GUr25R8Q/GhFpaX/35IEEltgAo+hJWEQiNKVDubLhbJOfoB9dyYuEiGUcvz8pQch2mCxKPMTDGoj7ymxfd2AVy/2XcC87bo4P9wEK2gbTxM4LX9/Zd1ypVHyKBwR/CcnRTE05XewnYKCNcvqu9uZ503rxVKtG4Tv4HMcYqJfamIr2x18pTOitLyXpNDLPfsxJi36gdAmMBMfBbMShnHUPw0L92HrFH7+8M/vpuQrAzAVI4V0frlX6yPUXW6lkB0lJ31IM5yiWve5uISgDIb5fWeLvv20FWUleiUVyNDUuqd2YPEIZwS30/yx/yNWuzmhyp1viua7+/krxn26W/pHnloyy/cIPBLzimvgoj/IL20Ll5HnhktLc3sPpubdp476yDsydU6mODHPo/HwfdrPW9fXKyX8eTb1o2K7nMpPYkS2OgFmIqgKlunz7/mTQTlDmV1pKMn6FhYeADh1NsMKatBqJYUruXGDvog/OorYn2k8Dz7Hv+5p1Pjghvdp4LbCOjEjSBz2xDKtd/FFlNFb5wCbnmFG3ddoytnSOas8kQbpZvlNFv/dRd7E0Y/1g0l81yPPRFUYaGxPpT3mCD7nLejBAbqJuJkr3eHrfK7xv0Lq3DYRKhrPdLt3oa8JHm/Ro2yF+7mb3JkPmJ1DgJ3l5X4vwsKLbAcWM5xCdX0KgynohzezKCtFWDPMruezWCy0NWWlLLFGDTOAREJVjgTPpq16hBwwLWGl6sdH3zUsD0A8YzjxOB4ECA2M3Pq+ZCP5AC6g7qwZoUhD5kf00G5TRTvMNyELI7R7hIrbH+H96asQwcM3+h/iQXBrx+0CsWxt2P6Se7010RCIYi5kteeGyzC3TY8p8ACECkjfyOi4mvJ+fXTOzF+cB3YIgU6xdvMUB7CPRcUWdr6sY+Kzc3z2oyhZE4qoBqmI3puKigyltA7uNNazRwTxVffuM51Z/1x+Ci6q3JYbk3PKpNfaNDe0bpsxSygbX0elPJ6T6ttGbu3Z7sh9YM7d0+EZWPesHawQyidxQxFFc3/prn54QEh3+KiNmBzZ4D5xwDFV9muy8O/ibVe1RAUf+F3QNI4h/4VGEApszbWlLYyI2WXgSP0tmNV46YrIm2FfyT29mdAYNmIzIxKc346+2cGETnyZ+F3okIUKmqSQ6uHdhDJT72yEf9MoHqkyol6JpCW1K41OpfQekyG2SimMYJKl988A6uYKnO7J1qttosRd8YryS/DwOmoIk5K5h55S/giBd/DuMKzlF3VzwbuxqFWWmwB5rzU7QvhWNBLaChI/VDK46y6VgLTEkA744Gqtvw2OjNvRU/zkvsqWDyeC+DzJdd/FpxTBUVAGFDw1oH1iZwaXPMGWqRFmb27djkmlgfbzjqZ4cGi4WnII5vxrgy8wroZNTDpWdRpIuyAMDz74fcqeifVxT6JWMmBXkNxq+vTAOF3wdUEZT6AZNxA6094MyuIrzGrzrfx4xL73sjiJl79AAYm5OY5FXpvylVO6qHlqbgzeh/hbiAmnoaAWjaYU/uAqpNnUBO01u4Mwvq32TyR/jnUpBVOFWo9TMUXupV3joZc3bedZZvs8hsHZBb1FK0LSO9Avn28bRUQ9jS9bp4PL4zgHoRliyWOE5Iep+IQMytWkgr+Ayl9A5HODVi4K2d8qBRae/4VmKGB/J0pvCtIANCvODd1kVXid6xEOXaK3rufgtb+ZxNztsWPWYhdIpoNtLOc8TDvNzVoUuk0etHMxtQXp4QkdZKHbyZIW+Ditg0Q0QI/qhxmeUozrODDdphmtKH69ek1szmvCOyZyHugNo6qmG6tfAfqkjhx4SENL6aDFUcMprulnYgDM98WudwOnq2PBRU5nzaWl2ggkwGgOVjqdKxgePm6LuW5rmmQ0fphGrw4bddyM0EfAmQK1Hc5SmCdcMfcv7UFuwK8BBTGUOmlh2ySkjx14e3DOp5buO86h/CXTOWS8VV21UdLejtX7TULjqGoQ7x//wYGdGt5D+NXxxIWRZl2WORozB23Ta0+IL77ve58tiTwMKEufNWRZNIzCbA6danMfqiyxutrBpLkmhNPkIMemytIcCTg271UnLQMo/YA5GpJDp2uBm9ul8q9satpK65XNyJFAe4ItAfsx53oPYKnJU/8QQnBCGdEFf6mVqZ35FFzQPvVc9NOdpiUMIka+XeqNCl+tSdQIGcvIKvj6HCxbSEfRw/lTgUcK067umxDgVf5GRIMAwNvG62iZNb1xT5+24l2e//9cZoD0xsUp+jDdiZHMO5jITjh8K2EGEBaKrNzlpB/sb9oZGD6naoKa/xsqqtIWj8cmHYZk0/JjsA/0+E2f552K3tP9oadWgQynymVgOyYXZojyfZ21fdnW7+vtbVOkhe+S/TcyePqIXNrM6N8dDyaXfpqg7IJv7JcApms1k6ZscCUJu2qcJb4Lu7FW+m7FiBGHDT28xSFKYsevbsEEuNBkqQIs7DMPhcRTxKxoYSSYWeX/Dw2XeXa27Ant+c1z1mfkT3qFWkvHIgLZdIJ3zLc7TcT3x1JhjkZ0dhdy69zUGYhlo/ulWp6Tb+o7bigS1p1F6v6NAGQhje5Rux3b47sN6Us+0s2HoGqz7EQND3cS1jSX3jrR6rHfGMlqIjMBVL6ubef4sl5Kb88GChzlj/v1W8rOSvjtG/4yg9jTUNaRWB3j503q0Hd3heu/UN5ShkDJi932dNy4ZrCa0ffn+WGUHOZ30DYln/KcGx+CB8mQNaG86u2CKhYUCquKXdbGyg2hVqMPNMP0CrMJtA096rTjbd6/8RdW4l1/oJ3sQE/xeey6g+Ak4FafA/7z/0FbOYhiu8tPFeIXixcS8h87TbigKKkwZRKq2pW87KII3ZwLDco/mw8OPJXcgcvgEQCMjcKvMG43++UPstTKfeX34KK5vMR6u7PMcZwAmrrgXHmJtnDS/9ayrzr5GzrsrrB4hK6XZ6wWgN7ayUq0QixKz3RUGKd410QeKIPwbyNQ6sIOa8kVKcjx+juEGCvK3X+3F06WQg1Vio1wvdCanV4zw2TndrmSAjmjJiCKFl9PRhom3JPw3Ecju+C0NaAzS9BuidUHAT0P4WSGd5gX3CsptJSMUOLqDAz7AsxnLPSM/sGmJHSrp6E7oswcGycsL0qGkGQmVYdmZfrZuDAJBVSi7Q9zGhvF+2p+fhlxBB0C6YP/FAQ/yn9H/zUyBEAOUTqqt8yRGPSlXdrLpqmsCMFQ561nT/O8wLEDK3zQMDWlD4lMLt5mIeURHfNqf04ib94HmMpiZvWNNXbwzJAQIoaYdlB2LENbrOvZgCVhHqaP2FX6E09n4y2ilWkX7k+q1EVj6Ohhi4L5VyxBX7src60RuKfBohGb8Mh+lWbhZOsdENhNyx8y1WWS/N9WP2fcQyQiI5u7qRuYpnjojUBNVrZ3zM1cAtwWBuEsCFv7xHTUSTQ7D9IhNU43Nad3I5bLpHLET/CgWOUTIzda8/sUEGAkH6Vp8d7xUnjRfCBIuTiohTMs80f3ERGPDb6pt5Bu81Wbq+CETzC63W4vEfhbpijQ5np8kQwzxOnEJhLb4bEnEKAV+1VPHs2kpswJYaHa1ZQqgYA1lZtIW/G1ULXtjcLQgrHpCTNBcasMi6qgO3Mirs31RpT9yZgxNYNB0gR1MUx/oNwL85KDqOFz+KNtnkXq/3f1vCvrPXkLR3KesJgDzky05YGsKrx0IOc7oi4h0TECoLtHcxkxlYhI5YLR9y9p/nS6LosdEui0u0sxtEiy3wdioiPpEDLCFFLUmp8k2ClnVo3lK5DXD1hArWFC2vXIiPKFEoeXMCv7MjM/+xFip2K5gdlbuQyUttfI6IPRtZCTWirZ0gEVtCyya3EDEA3OZ1VNZRHEDgGC1GLba61q2cEiCDAdAfg2q320miNtU/yX8MY3SPSXj0+uJMIwOCOUDO5YDTkL90FiQ9YeqJoMUJ00g2lr+Bl6z2PnNYYfc+Q5BpNHzi0Pyn3H/chmKL5Fbr97MQo3zHmIzrICLvWCmRDYkaeknDqkw1gY5Yikvw2NCYKVPl9esTbcv/C/pLC7sbxYJnQ5r3RA8jLiqqbbNF1qIlJc8G3pZQfFr8+1bIcfk6zgWVGHzlVdl/l6/RepXwb677MuI7twAKTpZ2HuVyTiWDEWR2uwhF/FgAfbGyHCus1EvDlmbL8IY1XnrVY1rLQhv1xXh1bIGTk9QKSzkJVfYk4Me+lIhsrYNZV1NGxJZJpR2/UKJLJRL4u6lH/iqmOfH1wqLx5InWFIXpA3yG55inAUCsiAH2elreMPqps4OMvXN1+buHl5N+vB3zzGOVAEKJRKRcziowy63r5AK6a8ayPrnlGJLcqiphtUlESXojEDprl7rBlq5b+cVco5E0VlBvgSu5Y8VWfJWCVDafBFTln6A3z8pxbvwy8LBP5HzTqcUwPRhYjlocyHt/+GQ+ckGlXBZTa7kC7TRFwUnE6OgMj8dz/J6j1gJ0vAUI5wRZ7cDJ25IDe7eAQqHdbiWIX5u/sJEe1M/UGxnG5oi63wCG9DPyK07+QCYhmP0kpV2IdZPU7IgRa8GB7zSJRiqkbWhM9qUZBaKMaUc+LucUcOFHVHU51PDJjCmqTNwFUg1FJzNP09/01u0vG43Ajl4zyRrXnExBcV1AxDLZn+1mX5CYsI3xKppBD7gI3SQIObsNw8WVvC44LT3unuyDewhsUuriVmmhKYlf4nNa2jOCpxswg/UJ9tvrQlnNRaodVzut5oRKduTFfKulSvrQUoD1xbHuSKLsGLf1zUKJkz9adFyj7885PCGX2wNy2i6A4YpmyVCdY+uqKoWPd/iif6NWs/Lj4yIBByDR8ecZpWSl6wAtW7jj05uhQBW3nrYrL2ylu+u9RqhyxJbWW64nqzGe9bh5JuzOjhngcrawZqu4CNpjvFK+9pvy7PMndybyDyVE1w083t/VtssEl8Y2seEGhGnvVGnoGcquTJ5f4WGCmsArVWCxBQQIlzUczQfaaVkT6zEdxX6EmNP0ZA6ECJKE7jQYesez926Ni9MvjzkDRYbN3sbNMAkyVkBth7IpGn73FbwrzkUS3gyRlcBLks8RAj85//KOUAhgP6fu4hmD/f7uMez+kyNiki9KBHstpfNlq4SMQcpTuN3D4hhMVtWPvKqfdcpBTcRFM3VbwvXp/uJlVzbNy9Hi1WSkvgssnmQddMDJcUypb4OYe+cU362KunI3D6dWfFdinhiSewXHFdPAicGvO28T8eD065Jk3t8NWObmxZSxUkrTIVNaFGHQVSbxgsUJrz9I5uwf2ufnaOr0E1hinLcopgx4CSTdJMzX4ApYwil88MyhNxPwyV78EiXttKklonbCNc4rUIXMzCoNBqVO633oM0OBCUCGxaIyV7FIX0txl/2exAsck0TiKityFxTr/ITWtqH6kreZwQYUV1FyOnBePSIzqMmJ8keOdCukNCD1UbS9RH4qKTg0WyIBvTrZiK4Wt8zRPVVgU+qSJ5hWZoZ3v5kFdw75PSffUM0z90mcfxS4NP9yU3pcU57gyvFE3K8Hxe+Y7ufPd6KFLcO69YkpFsRC8k8J9gApjAiZcH6C5feyKlBEu3gV3hTKlaMM2sDJgRz7q3Wv3Yz1wDeHs2Q3Gy7fG1RNosiPIYJmha8iqFIpz4ckjy645ERzizbXU49N0rBoNV4hFUGQykonX2dvTSGR8ksgBEak3unWWT//yf/Myc3Ycb6uC+U9ZfAP+zW6YG3Oo1hKcTEK3Nt04hIAKSFqKeVIzhRpGpLB+dpk4ufH2tW1uL5XItmuVlbanm1qAXXbghbINEpgl6OnnW0BkHod965L+XutjmJBnrlGQtlgDzoOYe7Fh9jZZtGe/srgKXa/zn7B/ytfF5G4KYo6Zu/Xqwp78xKibL0GEZtJSFeAwTp2E8YO2LJpWnzqRHitK3UkaQrxu8ts0UZXPGhBudl49q4EyXDSONi1gl54Ku3Xx8C993zrJJBxa7LdQ/U6LXsHjVfX15WbdYmFufViaiAUiFG8s5iF5AqucoVlpGOcj5Qmq1gTAQgf1+PFGsaM2ZLa9S8p31LPFMTamaTdaqmuMKika5l+jyyiSyLh0GjuI4NY9+E6qG1Zebx2C4QtvGn/ihWbPOPHo/B2towg9dFVLFx7QwR8/ZcQ0XdzhNGU6VMAOlUb/B5n3H0SOBwVynW1XdqWnLt4nnSw2p79SD4NjdMy15XdSkhdRhsJ+4bwVOEbl0y10jOlDbyWx1b1bS2eqoV9HqLK//f9NWpvJuHPsOyHbI0QtoRiQH0IVLtmT8wwSx2g25klexSGHG8n1/V/U7x3Z0RxfJAWaZOrrckTG/TmY1Ejvl1PhDGhDtnnA3toWe2/6Vh1sZuuoCZRi4sb5iKERMv1OtY4vjKLY6NBEn4gZ2oyQwWogizDOhAVmAuaLRSqvB+J74Jij26bOZvkR5MrZUoOPkaavGFr3RgWJisJs26t1ot4G79rbu+iFboWjQ9/PJy3z8HZGMKhavpyrcZrG6uB/GxlG5+VdMybRL7T5ViEI96gScSTKVrefXOsMT5I9jno6NwT5eRL6hBS64woAohT5nfDESmRzt9JGS6Nu1GkmuDc/QESvwcURxjCqHbwemJ7Ci1rLMFHDKiD7mnBoPiSbjXbPTJNe4xaW32Ta3e23B9/E6nAC3R/msF5fYQloTPc1nGTkw52mkRfC9Fldsakn3l4zCNh2CKskXKndjTWO6bt8nXvL1NWPGxZIJB0zB83r9z9mmXtfzgYsjOuST/lB8ZwQHy/F27vAIIQC8in2UeprRT1RbMaiXVkryakjFJcwzdrrgtCliRL5E313RIe1NYGtSq2rzPyDQQOORIPjquxNYiJJbEeAlzMmomz5ORsjzUHveFrKdZ+MOru24+8hDAmlixashR59ua+HMm7UFD5X1qdG+i748ZLziU46if2YT1bsNmICNejF5C+yDrsIi6Ha7BviKjOMBbtHM5WbWK/BZ7gA6iM8YYEr365TxJaBJlzg5vQCYckryPtNm69CUY1HgZM9fFwel31HYuZGH+Ukf2c2Iia96muqtQKymjD5eNNKt9Yw0bIcF5KI1qUztT74c36ADgoso84P5O9dqer7PfFMW9LsP7VpWsncPNNjlCkGEo0VfTLwqPNHgvytbPjqZNYrrK9O/SRGrWLqvjLqyuDNs2T5GQuzcvExoJb0oDLCgPKRkSj23IoR1a7PSRSYtCsdPUUL7BDDWhzBQj1LOKjtJ6Dd0Nqv5N/4p32vVjghJmlt2JtWwlHLhZGK3VoubGZaCMPlzBmUOiQZPYCQO1Q0fzNS6H3LtiOsCs6K9zl7niF3yZk8cBhabGiHTsSPfGtyfyWBIk6mkwsbHXpywadXmnZiEXw5tvRMmcag0q7ViJKWBt9XWVt01uhfFcjGUzX7CFlGHt405Lk1hr9y0FUpPBnhmyY7M70vEDcZQ7/01LfhlX5cOi2nFlsa26Rp3eEBnkK1GUgjTlhKoaUKVTnhBxThLmrp9wpJRowpiS83WnCNE7/+YALqB9ccUTj893GykynKG5MmbXQibgVKwZs92puX3u9oqRALi43tb8D82Mx4aoj7/1U05fF4z40V5ZPKXAGc+7KE6W2EKpEUZu8bnf8OWF6g0AeQx9/6mUEqSPJzVF4WTIbPQbqdWqhC652QLkqUFzlqD9nMbvsXD8GvDbMc/Sco0iQTc9AVUGpjLAT759iNubx04RuWtMZsGynXgYI1uLjbrIEGt9zEK+FIWy/LVMS1AXmPK6eaMO7FuP2Zq5o18IUoh9TAtwCqrjjkoTYEPUNnQFPYqCd6H3nGgH4KzjW6K4JvUM9qfMuXW+gCeRvw2/DPn73sacO35eGC4Y38UuVls/N+zBEruPKyEUWvdv7LoQlovos1nfiU9VU+WaXjTIpabZl7irnpN9fFMXHw7LIcua+faJm4SF+F8ufqQST8mXvxmRkZxNkT79jUxoF2ulKvek0c+x6BQgS9hTk5J/40a87DeRXKmv+qiD9LLjtJmPP7K9kVZGpn7TETNq7Uy4IXQvj4zqtv010EISeEFhuw0RgmPe8JWCBztNaAga2p/yakwhdpwCkxULAV0UkAnni2nmPgmKxb+PvLbAvgNuhJ9srW9gSpeeMgoMgTua+JxO4sKKG899BBBYPhOPiH/gFUeTtgxs9bokL/GN5wgsMjOYAyuMDPtNmZvAgiMH05hkaxJi4FmQsDpB+HDO9VTKPd2bohFoJQCr0FNWNlEIvU6HHRqvbQm9Ow7wUPSXmPIdjc9jfa6khYV6oIVli4Twgowd7SXQKN6afyZKMb84Itn1ZW2UuQR60rMyopgkhQXLH06098MO4XjkZSfdWXboncYoKj6ewTCQWOZWweKiF5BaNBD60cS9di9ld0CFy1trGyR+4hhyot6awLW/wSDNF2HqIk1WnvB8HFsmOYCxgyJl2AXufzRKz6yZr4NZ4e0d0ii/AA/32bghL3sawMhw+rEgkSHWcqKuJ6KIajsqQCaij1N8yH4xitHSRaPwk7jyxlmWXFjERXzCv4Lv0lgHM3YnANNbZh8OhNd95sQ9VJczGT7HL7StUn3TenDZcAN5S4NdC7DoCxM9nd1/mZ319DBGi6yrnzizcQZEZpY4OLUQZ819nM9fk0TLWeJTVMKtwr24Oc6K2SZq3qpPcjIoLkGYJJTbX2n+fzFbJtJ6sA1ojDe1H4NpcvUkHGutzTWIkN2n5M+r9LP/NMaqsKLucEhpWQ3kKSV3B0S1HW8WyIKlbqQamm0ZdtaC+JEPByvQcrtr/tr0bQsYk/F4NsUCSMm0aGyDTFzGt46hbkN26i98Gvv8ByfxhZ1vFh7wNRksTq6SLSa74QPcthT4sk+XP/GsCUA1Pa6yr8Oyzi55MUT4n6V2bvYBpJkVgbLdW7aMJeo7C2Utnbn3t5g171GHyBhRoISuOncOGw78VuJnYrzNTpOkL4h0J7LJg1dYicC6LjoEqStuymh6X/svACyBx0d0k1TBYuB+HR1h7IZPMrezoBre1/sVggESVPn4hegdaUf1AmJvNCwey2pdZ/uD/gB8zrk96GRDx971XvOi9WxeK7v5WjcMFf8SRMZZQKXVW9rDkKIqK+PtMEEu4ixcst70JjeA88oSrSEHUa+WymoY8X6NMHWF4kdUS9lSvg9sWL8PrKmqR74BszqecL231/3nBOGnuBGYBquSoxRNA2TS8GKVjYreEuF/tqap97XEkg6PbIQC7W6k/KLfH4HO6d6SLub/m9COQEsVXKqEvCLxJdW9y+Mdl5Rf1ELvDybNO00yn8L5TJVLnFPl1h0FOJpn6A6TKgmCR+nscSYwCl1PKVoX50xMOYYldrDpxIpM3fn3icfKdEGa1EsZuZ1/8dlvnjdE8dvYy6hz/z+e5J0FYIgcbnUvCaHIwKrh431lCiOSfUEgZPgx+IOt54PLISsJ05LPC53GInrPrRZvEUASVub8ZkT4o+N4kInmLc10ENcRRHt2OECdsz+3e3VCQ5W0RvOEg7NRu2GZx1qFqSj/kivp/j1nQlzciF4q/UniCAkaFW4dBzqAbz9IYuiLmUHVWhdHD6Couw0jqxAFuoBMG05nGpXmWcJ4kckwbZkzltEYbCpPSVv9HeTupb5eE6V7Y9IdySH3qyOdAPuzN7uJru6r2Rkpss7F11fQEw+K/ucZt7DKvntCnba5qTk6KvFtbGYPJtzipsVzcdQRbQ524bcu8Byc8Z3AGSLBI0iFWiTeRODEATh5zsvmuridiuoduhRvBjfFYfi8iQ45Ym9I0NVZepsu/Utn8fWy/+I5OZUzhgwfGOMitzTRi2jKGxzZu8UPSvPAA0OM9Mq1cDFW8nJiadw4OoCM0lrKeqmTS6V9GF8UXNxvQBjiYZxWhoTfAbNCSS4cSIDgWtrHyeUtJ7HvUiidY4djV3vTsoLz7y7vm1mMGwEx9ozVbo3x6ulya1EY2anl7KuSGlvTBs4kyUUeC/LizwvlvpsPqpj8eZg/WfNPrPeHgXFI/MKmA4G+fOSf+5cILpkq/BVc2DwSuSASwYlbdAWeLJQV5ED2zTH5K358NzDkt/NaQ501JNDZLOKuxlwojZb0yl8XvtE6OO611DzSHfLnS+5hUzZDqjnNor0BermA16ij2WiQOEpsuUkPxsNKiHqXdpR4NLD6jk5xutj0OoDWPYBGoRFA1kSInpt+BtSW60hICrVx2jdRiUxHLfrmoNvAC2uST6/mI4OIJD9SFUGwdUARYSbHr7mrvGh27pJoeuuLS8TqRVAL94qYVDfcQO0TAhDXuTmeCI0BebK5SyaWpMIU9HR06y53ifg/ajzapOE3c7fEw/ItneozC47kiNJ3pNwCfCh6wgjiOJDhdGqmF83u2qtjFrV7F4QCkFL3vyYWwUEfzrsIEiOW7vWk6dhTjhfPWVkMAbffO3/hNjxb+tje/lSj92Jf/Kp01DR1lOb1yjnoncLEfmyUdtKyUPVKqoMVLDACd2S1EaQ9uBaueYM6UHTG9Z+TlxWD/plX5yx0WYtGCUDghxOJ4HzlPLfPcPxkW7+7cZcpnUzvNDcn3MbAT7vIQufbVlEmgBxO+vL6Q8tCLP8dTt1k7xDK2ZwjonoCuZWP+Hf6V7x3swJ/Py9OGYLv/13Kt3kHJRK+hccVO0tUlH+P06E+0muUvBBR7E4sYMecZkL/RiIw6pd9agAPviZCmw7TDcVyk9t69Bipg8LNSPvhwHIeUpVa9cdwazcYQdv0m9isKmBtW70WbfGFJc7Qe1TTJsd5POjixu/UqPGof2oJ479kk4hGEXFr1sUUGc2BWpJphhaYUnPqyuEGLYSJrM2N1nFiHAGCoMEdcFGnR5GzYGBfuwnz20PHv/EEi96ATboplrZUcuwJ8bvvhoK7yiNqLCty9FzsYJMSQq92zP8AH7EbTKiwi81b5O9hjzSZccHfjSfsOPKnAE48Ob7+UN2YFvQe265zW6E6HUi0gxBxrC7Mk8Hx0ICOgO2GydTWc3HCIMngqQuFHYnVI6hvAzcPuSbjH9epCr08dO5k1sRVMY5wVkRnhFeh3LRasVTLq6/h7+P9zpNauDiMWRBw1xSulRHSCeV2r7f+lexE/HssfkSiljpWMTcQk/aeM1B7UwTxwB8CHDEm9F0zlksNinsCzShmXrDYUCnOoELNc3xmjUuz1HdAy2B/NsoR8Bt9muz+kKg4gIdunjQIIRU1vaf/B7y/KcPTRWsJX3ptRA0R0EYOJCPCoLypy9IjqpyyRh5xuJkMMLxCXsOrEPZopGPU/K01VKWt/ooto2V/aJID/y1h2NgxsilUvQroSGUPLLQcvazW/EZGv3vwpejkiVysF6rvqWSrWSV/FuWVepjS18qFdh40BFAiyMwnRjSp4p8iF/ICon5TPDY4f61YOhRAIPnvtY2nRv23ZicKKS1F0kWzb+SM0mSzOU5pPs20J5JcUkAF+yezeUXDvS68zdfEw4xLpDaX8R86p3kFFRXPPMQ4AN2rTy2fXwUaUADJ+/wIg4VR0GLjRAbX8wvGlCHQ7Arax2uyXSU64QdReAuaPE5hsXT/SM5e+asBQwsIwHLKVxD3yLQuxX4crR0sA0a6N+KiDNLpgtjWrD/5HkgGkbWnsmxKFMkGlSCEMpQ7rCC5LzX2ed3crLSMNkM7o5GrvwwImNZdxGVn0DoQkNLZA9awpU8Ok1o7v+5lCDzIItRFJ1IU/Ig46K76IDqBKP6CRQceq9HCh0a0mSq/TTvWn5yY7j8yJOLeoHC2tX+bXyNgl9O6WnjVeYlbq8pj+LT8yRy7LuyB7VkkQjyYAeMHPyz3V5PkGeANVy2DSDX1wAaIxW4UA/ChSyheDihGzYCWBdBOV0BWHnfVobAqmbX9/5su7eApuqHolKTY3YhAJyCQ4u2TIm7gN4hSmn1wm3HL2mv8G/+kSyh2xXy8H0loHdPQ6aq5O8vcn7l6lo/JH8GzIjmppB7qPGUZOjYiHnG64ckPxDDgHkfdVaVa57Exw85r9bYfSeyGtgYTHyOJC/in/WcagrRSTa3O0QNe0HypIrcWLNLYVccikrBN3VfsE4+4NQQ90eoIr4i+DUbB27GVI5UcS+o3gxjVp7Wzf+PiBXKzDn4ykv46wJZcPn6u+Ok+JkAZG99cdlJU8rEeGifj461Pv3njZ71qnMWZUA4MJRVW/bA4jScLGbfiR1DftoGpBmfRwvERAjNvcAb7WMl2ZUzoePXKgz2sZq2qZavsspivmbxNJYTuuFBaQD/nlxlYLj9D/ydCJM5Ros9Wotg4RtKH5s8QrrKqNfyVH60slIp6E+ymEqtFaxxiu2LHtYZe257tHGQjlgV0syde5DNo3GWYJr11ObEd3jvLIBNY5q52LsT2HlJOM2nnt5sl5Ao4yHSfbf5ajWhKQQeNYZHGPMA5hnQczNntcxho9QTcQAx34Yqnd80e+SYKlAkbWitABJHzx0EOC1L3FV9MtNc4E8/1/qE27v+oT695DciekszLU7PHCuq7sJg+se2pCwS4/BAiN1XzR0mTgSLPG9TD8e+JRmTwYK+NTbfwhsGm52ojfsoEUZzXjO5b4OypVX8hGO2UxHT3hVQ6ZGJTsOJEk8aq9sVn1UqBLhCF1UYJoGUTAMcwkSk3stqThNg/RmVW6BloAWSzFS4XkqDpFD0LDHlBTynuSLxv0cx19kCSrhiF7rkeLzV6/mYDplIxnQFh4+me2khNLPajftc+JN1Pio0cmuhnAIFB1RAiARPdEs20pZ+bphrKobiienX4wu9XjmL3FmJyO8wiV0hNcYtwtnUligHBMWCib6y3GY5j7wM5zvOo1y8UvNauh9zYSovLwqM9K+0/UTszmGduZTSSnSczny84zZscaNcP7I/C/QLSVGKLZXs3UBtLssaVjqi0Dgy3Q6RYPs7DwR/U/EGpcJZeXmzomKMaET1yHGpJrAwkqw1QMe/zkYmLwZqvghcrgd4ynrRJ4ey4gDuNUtqPnWB7MIhXErRQR2QjhN7jkW0SAAot9DG6mXgF9JySniWX2b8XtWul+zJDkZlhCTEmcGxHCuyatM4bR5jvjEXI5f5shT5MZ4tiHwN3ljqPiLbIyJ0kZ1llYKTJAlKAZxDSh/V1j4dpUEpv2974eKkhMP5dSqJLNFz/iYHcRyjycWPYEUS/fCDdzHib6WvndodUL9NFMBt+krrwsjyW3i8192k2LR0zqsDRrMXHzz+j5n+cta7B0phLXGTy4IStYRn6KAjdJGzmSd0q0oAhpsvhfTCE68zND3Mjh7drmnjs6qSiwctyr30Fu2KPz9ukYyXpCIXQ71lRjFqUSsYq9au3sp6jMxDoV3RwTbZeVAQtUZ73irn7CwFNRfdOLx8qlcX388y1M6geVeQRSApnWsboBJcGkA/iv7ofZIKL9SnAuejuKFMRQgpwAucwoAgupN8wC0T3hKOmDNIx530DbZn2BuS87DhaThH82ttbZuBaSEAPwVqj04BPfZ2blbvDQA1eedQzwybjLJglz/heUSGBL/jlDkoI0qZP95qusJOyFXvAsUvJ2PGuUWMuF4AscxCNd5eNnxS6kSqFGrmFsc+GTGMJZ9hni3wKjS4gPHrQhDkCV+hq6bpQuC8zYmQNtNEZhwd4K/bFK8WyJkgViXXrYRNV07x9ywhdVtYgNS8HzEMAT4lhJxekH7xs7LetpxWODKP1mit5QbV+4c23zeh7dWEZxmriVz6ktN5vg5Z0T/UONll3YrrovDZ1n3KjAbHr/sTPs6RYfv6M/pwEihyIsgLcQqoBhnUBI6aF5c+ZK4RQED5i8i8DcDRxv5qR2k52DENgV6OpxMsZRH349CDPHZON9/OBEzUNT8Big1isZweXkMIVyLsCcvB1HO6AGq4DKInhRaszcsNS2+9vmB2LBvOen0l6yqyHGuCW1KZ5XgQjlUeJUfN+hfanSLJhkFT7AaokAeKSd5dZmi+9AGcYUe953zlYNupwPJuu8ys6n1or7WdlYTblc7VbYevtNMNykAQbs+v57AA39EVbZELz6xIcib85EEN8yb5HHgMZpUeQEgb86LeKsM+ui4oZtj2pmUUTB2atr5fupA0cHcMRAacI62YCe0yUCWUF7X3r4rUifa/q092E/EM9Bj1kQr39c3Qj5v55mgYatHQJS/IORTK/uMYp0WqcDIXWe9M8t1ShRHz5nJ3xKqjuw0YtwBj1CNBvB5GpEECi065HCxugjOnMJegM8IdUoyF1eG1qtw/BF9hilWca0dqnLu4a8VZT05lV1Hjd1qNeMayAovaOyjlDAORpKCObvrFn8k/9TVIQdmOK5NwAueWRkgNkuVPAgRye7rpwdXyWtMAA98yqN/vio8ZUZ2IODW0Fslt6fqypAKEjfPh/KtLxP7r8MNz7/Pr9IcIgtgGLjbIKMG5umtJF+ZpA1fQpdtRWjWzB4qGlvoA6Q5tiInAROvnU5Jy0InAS2ICmo7sEuc9Hc+Y58mliGn4RU20XRXaMTlvzAdBN8fqDsH5mqokUxArDk3gVK0JbQVvVWReqKsVow5iRt1Ag+raQudezXZG6IcuJrZviKmNQpX3BaDsJbEX2zoVOiRS04ecjL1/1ZbTIFYo3+i8bsJEmoNqJQRLBjwtS0jj/FgKcFyNvl8zdRB2ODHiPbC/KIVtTncSFjhP62Ny4TIjzgrDKpNnIyDdKFg5Rs5R6BaZaejMjFY0Jl9i1oo8xXvGcyYrGQi1d83PMaie47tYrQW9JeKl/K3tM+Y/O9gfXgzYRqHGBc5eouhUosN3BdiUxmblKi08pBixsVTmRdegElnNyNHQEQhvEzGQCj9Pn5gzNeGYR8fPwboZ8dlHnA/fKRTKOP9EDoa3q05DW+/rdXgprQzyY/9CIwYTuZNRQRFb1Lrh1m0qQhL8Fo8m2sAqvBLuRCKk9F1eyY5aZRn0KM+ZwmbfTTdzwAfidoLEioFuWc01uStydoyNymH5DO3P2A7/AH/D3Hlf9iZh4FxB7xwTjMZ30f0hZMBM4csg10EA0GYoZ4+/hzDu51kChyhP9JjdEkTHEcnJKyn9Ywels1t4jPAeMpRW1gaNISHaMP41MdzkNdfhvJiEtxJNrlg9P/Th7RTueKNskA8x+dmINc7J7ik6CPzRh9m1tdt7U4oLuo9XeGxY3viXxN6eVjOm4DFzGBpTqDofyCH7QiDJhMkEprI19joCyHcP40od+rlEcf6Lac3xd5gctszAQj8ZJYSyWjiKpioEpBtWwMOQTk8+S+OFQioMDsCF0riU9CVedsZ6hB17skJe78zLmHW9GfEptiOArAobtKWuvmpvIxPLNcPLmiIDd++5n+bkE70Eeo5uxY+qGlqIHuhlqhw6P8I1GDY7FUiry/uZ05GeCOtiXMi/qEgI4eBUes6j2AKTQLhV50WyCGDn+YurlXI7wqA51x0fOKSh/J2gehrUB335qvWVeDLi8nzDdHcknTYjx7uoSgvtpxTyhfojS0jEDnzVPIcysfzEkMxYfYUYOeCFayGh+2Hn2tVfqy+6liXWH0mcmO1L92D1xStm4ckaLQKvsqDGSBKCCxuvPmKP5PpFZxlJ23cDusIzB9ysSI1ZsUBWsKCyOCSaBimuEq+x2iQ6iHNfNQMdSwEXcnOAWZsC55ZDnf39545O6EDMHDWNQcGLkyjlVa0M+Uc/ibjnVWp0eJdhAxf7cmqWNicFEoR2Ueu5BhxnIhemytpuk0Kc266endL0WOv99dm6Hzj3x/Bfvpj0vE31CJtkX1voel+4C+Wb5FVH+5MPvwZNpAia97uwajRpn9Gd7XjyyyWC86Plu8DWk7u3BExvnzmYISQPO5yuOngRNP3gtqEV0/0eiaxT/R83Irp6VLIQ9YrlPlT8buGLpuMHXfbtyAepqCerUY7D+dwAaMy4C2z1vVuQuzlOFfRkKMcuh4FpUFzy3Iui811JjsQoGU1AXs3Zgsn+Nu1ELeiO0rbVcWTr1AXy0IJVpW2ixBirfvA8q4i94lXBtR1k3wiXapLJ0oxhcsbkrDx3ztxe2vQWDcr7R0li/cYlfffMn1fR/hP1AXvZRjOQcJkGCXvFTojG3bvD+mGX13JBFYSswjYAYmDYyXJ1zoJuAS5/Fxl2rlUppHMuUsu8BHplsfGUA/HgURX8SlcNCLDJnEUhxV37Z5RnLauMScGGxv3Ja0zOb/QuBnKK13RhLNB9x7dfyonUMJv/AR6EJ5EeUfBdrdmBfWWwcRGXO4C5J+HrbiEfTWvgIaTfu5sTet2eiD/xPzf7Nx90oX/iRJIlSvspC2zgErLrodkx/cfAXz/tzJxoMQOJT80XOSZZUtwhk3DeCcTt4BUyiWPnvFpK06Ss5gIBe2yzIu+xWyojhpYCXXhbVVeCBJhaww+74vzunRINKwu3yG4PjPN6DFImRg6mbT5/JAlkREMqSnHnXgRWetuKcI0uOAtUnW24KMJ7BsRYbj95Qn4b7EG/eiMVFsMRKtrNClafL1xUiuMmMFXmxW6Ad+WBlrj660KUCA74gyGnNCp0CtyqkWwwnLGsxYXjl0FchUQmEDv6CJJkzcWY/M8WD+H5eDeXYe8C9Y7anNtp/PCDb/18W6vrGoYSpfzLjPAgh/9+29uiLAdltZKEjUrplvanwPS4QCgTF7TFWMdF+ZonFaD2t4z5yWIYwG4+kxpL7dJlsQNBZiTdU++3Sp6mVsNS4gcEZfdSFkzKFygT7noswlfyhv4IOZyMJcvvpDjALzq+RVJu9RNdJrSBbjdxXqF7+GdDn7TQg0TomnKWkplYSO2AIvRRfvGbXgK0Ndgyo9XwFmCksjAMoeKQBEkdyqLDHb5FuL6pXanV8Y8ziBkmH3WG8zl0fLzxIpttSQnDmC0LxyCNS6PSc2LqWg6pw3/Hm6bW2hLNnSx/hm155F/QLPbhcgqCNh1anwGBa4MWMtxtSGo/BeRIo3JmrFgKilJ2hREy5LqUXVWJBJX3l62erEQ92xIwWADTF1ER/ddMnxu5IGsZ5Jyf01WDZun9Famk7SAt7aUTsNVFKqBHXYjaIeQSlnbngdn1Eh2pyqg6POWDj1ctYOLPvKzk7JifoEsx2fgBOqoaYCqQ4GIFhGC2j86tDjLJlOZ2TRLflgMewnhIWyUW3y1LGsNkzbwwB1/uJoStiDhGgLWTlGDzQhPZAJN+9LJiqM9wHsZ2pVd9uLBy6fSnwRAF97TE+cR3Q+FxvX7AwBGmst9LbrerejX6Ea465vMT804p1fuhPK04gbFQO0yWTif0CSsbMBZ093e4pkcycD6eq7RhwAhetGJo4MenVYXY/dXG4nO7o/gV4PQIoeiJ2BlTJdTJRclcpTp+Gy0hFXJsilOTG0Th7+w+Eve+cO1hvWzelQvibMnsYzqR4BJxvGhKZH6tYgmtNUPbq8RwzxgAvNrJim8p/T5Xd4LkAdpe8U1CUSQJdnVZGtAAJmS7+4c0SG+onMYs1LGnTwbN1AM4GURs4UOUmXaW18U2Z/EyYqOpfmW5J8Fqz7bHpfagLqT4zr7NK/Df6gxTopc8X18CrdWoWvWpCataNkV+YGD0rdeOfKrKV1FdlT8iZqad9nFYp8LgOWf1sTcAJMBwZM0DgP2WnqLSROGFE+aSmrL6EOLDZirBjyCoQEmttjLpK0lhuBWzY3eEwd3leRJ/pW2rZDsst98d0D/is/JECNroprpG0yULCXbZhHcORcIlwySU8ZzJ7o0CHFlBQr7v1LoRwpyR9J7nnbhn6Z0XQQA7+Vz+EmyZCWifBaUylJ2jJIWvSGJYgQ8+LKLRR/piSJAZ0Cph89YTAdk+4i5M54aDc2zJR+CTIaLh/uCDxEe1Bu4BNelsfmmLX1r84p/JiN+LOKtYEy2WjbdgCE9NF9Zp7zr6oqJ4lQY0CTIEFNVvXHKcUM9C+rHzk6OvZ0xPCM/maZ4FbOdesRW51nGasSx8l3/VOJhhNUBWeIRiiYjLF02iP8fUoXCzpZ6QY8RcWRevVN9xY6hnQg+ruEpl/wiWLhbBtcXUe8WjzNaLVhLGS2P/q7CFL6VB8TkJFGFCP9oK2o2M+yrWhZ9OJihPlOdqxshVXuUrhMTa5JVlPk7mPQH6Vmfky5J+dw49XEQKjLKMeQtdx6VQmQpIy/CravxGkTaCBjmp34SWTnrUHy+r95X1I8K3XKnhg2IMZCZGLHWSPq1lQH8tUBJqM/jG0ANODcjGqx8joJwwyAkF+3EHiKwuaR/VWLmD14g8xPRo3FINjj6vWUFeaI23gAI4JQJ/t0dySYjrXOkY8gQKp5LP3SBV2HeFw/0LMUsjuzoCnt5tWglGWf2ysZPpjkTdsRRnT1KmNREbbFyKRnwc9g86bPS077XIlocTv0dwWwy7VXxNzW5QVj5Hikv5VsHZqzeGgszVGkuKBuCqK2K6QhiON/HqxB9+dXIJ9h3u5boT643Zd21rA9aQO1rF5jGi57uwAgm05FFD6vpVuxTFLiF2GweTNgd9fI8NKQImmHqQUJ9oM9xofe+zFT70SbiZRUsh+fdXtxS4EHBKW4qqhCOC69CRmqNVIcYK87FIoKjoCsHNuDfzQLg11z6vrBkvfENtvNuk6eTt26W2g9uBqnLPKj6uFyxpjOlBCtGE/y1SsfGe2ozwkLFtCSFBCQNhqRumU3JZNJmt7es36kYIN3Wz1ns+JAHDXo+YKxCCWOX17Yfd4BRobT6q99T0Ihirievn+fsZ6uONC8KzR066Jv7Vf4/ZH3oa6KpU9pyqhWvl3yad7sQlZL5wsfTChVrsQht3Y+asdC1+xd4xiz3KXaFXM0yjVjd8LnM5kDjg+R+PVxIxa/z1En60uMRchozWEMcA2AWwADjOhZDcPd9PvS1LIM4ZjfN+uKUXtL2oDNX4kBd3aUXQwP2sONYLftdP8UDG68Seuag2D/6cj68ROJ1aZb+bLwFdre76EKpgbWBjXdqmZ5u0G63XV5+jq+0B++r5bdEq8BjvvY6aLzOMNgSngWMdiBlY9rZ5NNw1AYSWVPHUozBGQFjf9edqlIf04BtzDeKeOflczLBN4SFEN/4mx/20Kg+9PtUV2qa1xg7OSRPEGDytTlHPEjF7JGWTbGirCmAZ4WAWGXcVcbJ9S0/eTG6JNmWnqFE0nryVJbsiDtTCZL/HdPAHnQs8IHW3fw2n8WUKZtPAAeWmbsuUCnDqduswAy8GsU+/OKg8RZ7L0wCdhyfuJbRqJDe5iQIjIyCKksf5TdZVbGm6i3rBBRKgamfKtZsFpPFFeZderFmMXnJGbOm4eA3MN0XSZWJZPRHquhjFRE7LlUAyrkZmGVhQTheakAK28c/WGS+1cpbgmMWeWpxBlZQhJ01G0R4W9odeGny9eUaqhcTnObgbty8/fiPvzdRDWeE7iYy+CvAGaxCuPv8kG2lZss9akitIqYFEYFNaxXFlbTG/xeZvXTK3aNW/PUuoLWVxeSM2qsWKoM9eP9Ekl2/+ZtxYmNTI4Of8/Cii8lLLHChMu8mndQpFB4h9XYy01jc+lB6f9HNUXh5RKj2elHN8XGfwEcGJKtrJls5DSzHIZehqUcmPo0y+qX0rrKHdpK+J0veynFOu3hYNfQ8xfZW8+wcGCLCF2GkWqKG0aO+h7Nyn3wfJ2GEIF03cjTOKyiAyChyFa+Hw+EPzEEcARILg2Bsv8YK0il6q+rsdjoqWhUWKBROcxU+jRMWefONl1EEhJ1KQit6Z5T/R88ouns8LTGEInJv+U95mXdT92JAS1jRnkSBNoV7eMJVCnLMgSg/X4MQeqcxtQsKQudB5jhXig8LvPd10XH/huh3Ptyw/Cl382MTxV/vcb5i143Km0zaGErDTKPOQYo6B+3d8tTLuOxntMeHWwXutE9gUi1RC1eWWw2eMd4ScsYaKV0DJOQm0ZyBFTGEfbkIXTbDj9uD8hdGsZrU1yYJ26cSjLA8/ihHdKZ+qXfnDYJtKG08FUM8PwY0YRSg/et+OLbom3F61uOzSdHw2grxEQK2Y/wNqjxOtpSfxT2f3J7TdpmmhhmJVDlXPaZIQTMkkreJKYGaO5/KQVCY3RBL8OEPMiOjpQIdPhwSjvdwKXLMH5Nm1DcMO2ZGUPhnKv+10NeZf5Cl9pHqqo9PgfEirRd4gWxZgy2F7fJHgzJfzO+i4Y/e3v6NmIVH+jF1HZVT/24ln7IZwfu/B/X5+czJJCa1LU6oYOE8ld3EBb6ZxfbkcKZHhOXQ94VcDnGz0GO0M9JXjC8rFDptA1OS6/IxVcVYXZLDv0vcFHxQADsiKSWr+jSbiubKv/Gu6f1MzORcxIKaBTb19BBFoVtZ6tsE74ePBnNDtgV1mxrNAyWAaZFOlqTiAe/0Kw8/2EHbW5QEoI/q2xIn5GB7sfBgNS1YDDeT6Q5F3kVxmwUsqRME+u2YKsiqpf7hJmpoXZi0lHtmN+3vZuHnQqRr3COkBqY4rTLtS3oZRy2FdNU6AAAjZFva0W6xuql4tQYxLg5SobSg5LMyicxsisur/Aea7yhY/lkUEqb2YEn6mGs1A6VHH6ijQD9aTtvfv8IF2kCpgKMgPC6wpccs9yK/pTnb1hmGrGSZ8peE8n0opOmI/NN4tPYRmOR8+TIC6hFZJhUY8mLlxgF3IGsrQsUULhXxGhpaJfGWllKlwikYevxMYIlMWxFuv0XFVh1YLHgyK+Ae+6bl4TfCb7Tli82mh6Ea4ILvYw73YM4pj/ope0oB+iXaZK8R24MEUhXklMswz86ufjBDMp/LZcER8F3cQ1AABFmln8A8E+8Z9RKIaf/CsTpkf8Jt12tdCb0UNcicxsXAWoFMg0VVIaNMCr6LyzgLFh3tX+hq6W/Al8i2ENZu0rp2sxEVSvMNpI5JSXWTxopJIWBhAVpbY2YDauv0jTTC1i692TmQwx6n8LWjQRubBy+49Uqj/Se8iiya5fTg6PcQWuytUcjPjuOKCbrOJjMs9uepMNrYULqi4ToYJsvvhJP5EbgxKUoBYDfQFXKZ0vSpUvAs1V5ArM6gKeCIJPjxLP/t2oi8JLlTkE+p8KDHTC9ZpysSF4mFyjlzqWk1jkHTDVZQUplHVStOLSmhrQXdUYVIJHEPC/OhJ+1nvEz02niShDnumI8seseUBlItuOsLY1eS+UBbDYxdkQcE8VLBsHxTup8CuzWzu+525Uo62qn7RWLaG1M4wT/PWTJQgaIs5I+NWiQArvw6BzbIiFS21V60iGmqYQ564UXOuimO42z16UbdxvkTgPPhnQCmTsb7fO0VObCYs+eMaFxnu0+0BC3pIucygBVwkztxwrHjzSkgJrg2Bf3jQhwP+Ne2SIgInMHzetmy25QiktrhCt2u0QG0Og5KIZwKZ/6t9QHdzukGavLjID2WdZDlx8j3nhRtgMKBJnD5zuHfiJ0Wfati3mXfSTF9sleyYdzxfGhw6FXAIRDVYxVNiFcRx1TGz1AE/loQgJQx87GNR9RyCmpkdAuRstR90ud3tRTKN+qKGXqH/J8+ixyyHyIASCoTRChRItxtojdbRwVzPHmKzr8ifMcdbnEXJfTsH+kH2CsZ6VxsW80sxJVRURa/MsYX+pbMZppmSNqIHfQ55euYzB6DetCxOg84WXWaAmecl6m71BB3Ra7Rb3fdpQmlRvBwSk68I7yecN+2LBSDunZOLI9c7uOcTRFA6EoezEsP3fqxX9J4JmKOY70XHaSptQiAK7SVdcCt/uo4BY98AA/hcpfjiSs8ZJTF+jUsvBo0Hz0NqCST/3Id3lOs25PQ8nKwpY9KOoZgSxNizAoPuCudt6afcSYE5xAcBklM8vxDwBwpTqkqNyJphiIn0KscKMftpKQWLy9PbT+p74CQdgKV/u6+d7msduI6UPoo+Oo+8wsjSYGkI4BNf9Xuau6gpXp7TSgaxivqnpaQ3s9Je/b3/B0L1il4CW1cB1l+7n9+YUh/+m4BwmbeJIsUpdD84AIiwxczhNKxF6na1L4sdXH0msmbNtp8MFM5FkBETyBZgefiRCNPLhQ4P73Nt3k3ifvlYz1gHeoEx+6Fnq1BWaaP/aSODAKzIxS8+fDO7E6G5YMwaokLhd56mHYeQ8SVuzHa41N/4Pp92fMHLEHUlif5qRfFhLBZABpkKAtMUz9sUSPDtDk879endiNijAu/zyB5bCoOZPguMlZj+/1PgHxHL8oxdc7JLy4TWUnL8szPyKu1y9qM++SHid5VP88tQmKz0EPnTwKljakfxoRCMHxHnjYr1N7ZjHUGI9ASqCn3oDQ2ZTOqt31k40yP0TxW8HESk+luXSBLSvbKPZFFdyWvxmsgr91nc/TSVvrLLjuLNEC6/wfYbEEAnlvzCxa9DAJV27V3cKdlQy0my0c+GFfdKFWPS32a8pwJWuY2EuNkHRSVpRZv4C2zh8YK9vZuNn/J9ZY+Uf2FwwnagTvmdNH1hdoWiySWvIxwZkODvhVfHqdu1yqZDfR/CDdAWLkQaI1aXUfA6jmljbkTQ7Yg4m1Oid4y8WK6olnpSWaOCFNJ7L97d21nSDgzcWJubbs9scgjw2cx0i8K+6dFbYzeLshCgm1rIExjGLc1hiwZ1L43Mi82YnZYgRKKHIKUKYBfC7PkTHryBlR8EW+VcA5dIhE1aZxOOpDcbXfJ6xty+A/ch7SLC/zMgZhU6EspQGQ0fiEj/K8J1S20mU5kYEVWMVAcKShNpSB8vev/hvO2ER3um+LTAIuyiCX7fo6t1VFPxYkIpbmypoL4Eq1PzhUg83/5eTix9/CIVAc4c4Lv7ogrhmMsgyvTpP+1h1VEvQtv0rdG8SxbLcIPZTmPT5uRY86vEs30NG1/ZXqj1P/iDgb+f0aUScWfH1HzhZNtDIIOk52kSGurl9P4Kr5g6eCHVp97Ox1IIrQKKlFZoGS/es0bnEjefSxt0aA2KZeo/y3MUBX2gx1pROAyIhSc4saMl/mRoL7S1jPScsgpWYU1B4ih9E55zDsn1JCbk2RZNSOkmqEdshHnLDNqEMUUbgWKq8Rv4gyf2/qkGHzNoT7JH2mg5XxkK76koSImdlgGtIpkItJ0C2yfNdVcXNxUTJ8kO4lgxx6knJCC2BQzj1bvIL/3KH+G0AuIX3Oqypj/N+uLaEyjPxGO5Qs9xP16itpoRC8dsqcf0AYAdsVyXx6HcOb8VDOHMfNG3fdCZ8C0DjUTlfuDTkAcn9Y1vDQ1Df4zGwQUTL7xUMN2RHLSVUUWpZ8QKSeDuuxCqCMQFYU+QX7eQBuvBIIvEbHrrOAwLypCXqL0i1+3tS7U5SKu83krciwukyJEv8zlIvyGeRwYChQJZxxj8vrBJU6U+WqfesrflPAnUdQyfoxwNRY8xdUSlQcbdy7dpfr0RyKt+iCPLxqEGHcefBkgpFi9Q9xC5lhOYCJLGL072QDXWN2vqFOgwBPhPtDz+0XgVpLL2ytUCj+rkFJ3d7yrz4XQYDN9r+GY45VaXVo7P16nCR3GJWGD/lUEP5bU6kTUdS0KVTzoQRUXuwrGlzfaZ6zBQTU7AbmHz30VgNuzMJOamGnNlvcJ/dCg8q+hFz7MYjiL48VGHsC0MTIwE0LtuOnRSxq1Hc6X6dNOmxMeBJ+L92/mrmQp9xp5N9pOfRF8nk0awhFrYrysD4i4oqL/DjYl74mi/u/pVHLIzcjgWeg1KvNkirGjUlIeAYrNltoaaJx9zizBMtBJ+WjX8SZ1Irk16CEgatnpBt5A8xzx8UrdvsHKNk9pGtk4iqM2+qnSTNnFoS+IsDK3LYL3aPjY+wUNv4Cu+j0Ce0XGNLE425gXn8YTMdACAK6aaKzTncSl2fpARsRjLQHjKMPUPdsMX4M16EoYAUmSuX0lcxd60IxLpzuR0DRIVO9WAc7jiiXCz3bkRNX4nwuXGuJ14hoHxA3eAdPMXyeK3WzjtvhH33/wMDyMk8mqkXODdPmMn2Atx5b+ppu1itRGR7z7eFtZgJZ5Xq1jKqNQxsQdf+BMSFeffes9X2nR7c/kOcORTSTZerLckIcaIj66SnMYmRSRloUmnHBHTiLbPPEiMeG194y+xLQvbUNAUx8ftv6i2r913ja/QYDj/B1XVtgllZEXKxsHK6tpQDuPPDOV5ekVl55htuvLxG5BTYjQNhuxgogZxd+BG+nZqiOoZGBGd3QZNiP5YiASXfLup2ONUqu4H9f/vVQjRKaMDQwcLh1bAzHQEopZ8ZSqby08lKp4xiqx74bJAFEvKqUPf3R9W425t3VsNvVEbe9YW7GGGvAmL+yml9IrLqrhnJJ/I1ajrlWQ3wD543BVlJnYmlBf46Fgb9uVGWm+zXAW9+ft+Ey/zXUjsaa5PcyHg2xsPOgBW1sE+1/fQ0xM2q3Ft8bxdShAWRiKpcp/slZ1kZkWl4buFKpb8Vj75Uh+Wgttv+Yc/2NNVYqGpkTgYkESegpeVfQaLK0tgwOKAlH9KmG4/1co+ZxuGXNUHnr5eH3HboYGKhXW1OuNCTkHudVaDSFwdHVSyQCnjR34WhRwLQZjMFboet8+ORVBhYdenPWXlXQ+YBzCYJdArduwrqfloDblA+lrgENvIq8cIT1ofDMkcQJ6Jnvd4BGFOttgKChQyysA0USmdj8uLXtuR6cQwppTPNlgvdiXUAFMIxUQTyWlYoGRX4sF63nXRvaf3ATbbEU5nJEFRoPhO2ZXO4lXpfh160E0QSOXdQE+N4HEskfr1P9YwG598LiuWjEg0tSsLLTka325GYRMyog6BTBmfUVSZW/kjHGJmfT3U1kj57jKvJ/xhlVeucTiQ/M4NSk/ZRQHF4B53C2aYlm3LmjenOFae2yQN5IlkujU9wv5UakfP6t9bsRXxPw13t8EoxlPcGACsHMsp7+PHyI20+F3fkwC6lwd02+DaPy2vH6/nBNfD/Vs3O64iUVKfBfZ5EtQjYjCtD/N7lVyWEZOBB04ijrfupepGUC7Zw5JYQ7hFMlSfI7tdLalgfpQs95Q8wpLvpCxw+jw4ZIlGtwQEA0EbuaJ3R9BDMnLQsNoSUI1dcEQ4iLpK+4UaiH/4dU5wZyuaisuwh7Kt0gJ7FGunDlJKoxCdcFCsyspkNIf0sSFYrnnpUq9kELa9UdgeeSY5ZbrgqAsoWVIHlnsdRiUR1gN++sPKZ9jPzGtXEueDyhUkxbr/7oNJLUUF1xXar6fbqPbCONVdUQaTUKQZer712JDh2GCYTrh3lcAEbBb/XCtOSgDaE8iqoUeYbDmKFxtbLx6q4kH60E5Zvuce1aEtZj3yi5Yk4FXmdSy6DmsL9ygMFrrVPRclDtikhOsw9QaksF7EIV6TTKFtFdnkSSrQCyXrb96LPLwHraBN1sPmI6mLWY25WABcyCy3umo+gyPM60vRzBYs8TOrgMzNCMvTHwNX2uAI0G5PgvwkZL074LrXHopwJB5IBfnWHb0Op6JpGeJkQ71/J8H75Ae03dU20LgrzF6DOvjMHBUD4QFPzYgq+93NElpat565YTwr1IEBfhem2nPNquyrZawRWGWS1SqLrRLCA67JuV0z4YAK77U9aTQQINPjt74pDiurpKZn0yeR/3lM2TYsbMBEqq3mOffc47rPNbAul4xuc/VhzCEtLEy8tWPDasQRvgyOs1WagAN553YQTpIEXrxL/4aYKbyiCGnvx6hwddvwu82CLn4WIexa77sRG0DTpTBV+AhLv+sUam4S+6BmANk+du/2YUNP6JGXeDINTTw1nDs55iNaDpGZ2zSSpD6gOmoS4OXjToC8mlvoitKrLi5amce3sRwZ7eGwIQr0mDNDvqpKrYI37xq6SjDyWJ7cU+3tjIora4gVQJydFiFvTDEhtHAH32Bb4aR3/stoEIXYhv8o/ny95ngzXWvue2k1s+Um3PDQIPu4plLeiIe4OwDdQh/S72bl51LIiL+xk6WbrEhg6pwP93hY9wxf+PubS3UQM8jFZ5IOBSo1kDZ/wffWL6kvFI8NDugxogX1BskZXJxxEqCv3bSH114/cdgOTXc96Ug44pGhZmzHUUHAPvDUQA+JdTWMorEmJcp/j6oHKxACQl3s9/Q3Q1RPI0u+aK15qaBHPsyjC3jdGWWt7cD29/WnKcrYnQrSEtaW2iicG3veq5dkPvO8CiSR6jLilrXhBhYQk0oHv2BbritzyS5vjGpR6b3+jkyTOA0SGJumw2KLRsMh+Pkt0J8gdU4QtiSEZx1mPqegYUi8cRo1Ldr2vbjRYb3xzISF68omkWymDKcOkANpFNmPHqHNmDi6V6rDUHY3oY7U1bBVHVR+GYV+vkEIRwHPixMjXb6GvagWLrp/6eTC+HXhlB3Kip8dd8bPFehdf30hkHhZbgvLY+fuh7yE0CGrkBjNb8Bd3fHxV0jFDQuDrTan1qs5xJiDx1Nqg5QOycLZM3y04I5LayCtggBZkD1FPb94Z2NczodjO3qkvSvbdhnwnKvPgLTBEwFvOHMHoqOFgqUEryZ7QqxYGs+A71ryGcqOdVDaW0sAVvYnrBR4hCUR/8zREQal0lhDymJ5/siayM+oVqJAcdHsau6mKDy/+874xLg5rNU96Kwi1NMkRECz8aiCDDX1wwKcj/4Hfw06Spwz+rdXzFDWF9OhzND4OA4QgUsKgGdHzPnPRta4OEuTiz5+fONY8c328yLOAWzGHYO7uKZGXTXt0B0VBIoQ2I4gZhaJ+5jOxFcJCQkF1h3xFlHIUcKLkXhZsGmjf0xwUA33AFFOYdxJPPolVZ5BBWtj7LrV7Poae8NmExHbiBEQ6gW94XTacOvxkIbiFZqAvuJTWV8njcVQ8JJVjnYRd2/U1HdxQeqJxutIKCoPdYIyV5T/aLjVfq67J9oBawgMwn5rPQvuWb64MP7I3yNXqOdSIVZ7tsnNPYVkfI09AolYYyoXPCsaQ0LGx/6/32Lbetib7FbAMbGIB/ad6s1uzhqaGR3pCUm+BkEqT69ImYb3h+74+2l5EZsSo9o2fTTmV4UP9YbAGUlUT9EJMDfRq3YtYT7w7/iAQcDQokNAUqgFKQyTGLdQ0iVkLynJC3q1Tff2/y3igR7ZgHZsWcSy4h63ACvhG7iqRP0jROgvOghwMFIx8iJ/1G1pIkIcAZfo2mO5d5TSAp5bwb59/8ITE03jORTKunpY1Q6vzItcw146Wdf5nlfZvdS9Ef2HVFLCT069VzLPlj92xzTxKVq3/kkfLDp17y7KiD8col25iE400LOJNUrSaC/yjXqTmXG3IIozWMGpzrG3SN/zrbw0ZgfigvDN/GqF3NNyQfWYmE43krepA+MCDow83DqX1pg0m+kcGrEx7ozcjD5RwgtK73/rEQhQkp5B0c7LCyfFWBRebSYJVPUsEnH9X0KIlefUsoo/cZt9Ye6MhhdRh3brBNr5Clx/tbqcJr4eNd9FDDStmZiwyXOJpGj0JM+md4Hs42iTkmRS/0D5Y6w3EZajPLGnb66WLeKHtbZVGTPnT0LTR3XaAfwFvWSn9P0KEUJzDTy8QOhdBYE7m5uWPg0K+2bCU43LrQ/HEzlfN0hyGJKBkAtePkJx9azZRJhdQcqtkQCL4zJs5dM8i1sfAOW7dgQIvGcZTP1KAXydfbEHUDewa7+wLxnuptOKqwut+s9YmZspagoULEpdMhtcV5CP7LuXD9L+nE/3gtrvIVwm1nK8U+Q0/95iDAGtVMuib+Cr7Y3LA1KkK6Kvz40UU4uFKuccp2MLNVgZ8NGCQevjyd67V3OOdzDrAqtyi4nXIxy0Z6V3y6WatNFy1DGtKWi7JjuG+fu9X4Su988oC+6XactsVW0h+t8MEmilLW3NemkagUdr276/AlV7jBtOac2S8ucUf/ZnbxV8Y/SHmj5C/JS9oowcn19ofFndOOMqKe6aAu2FyA4sgfb4/CBBGItnHe2MBlA40VWf/qVRT0CQUzCqBd/W95TVgAyB+tyQqyTG54N+MLepezdyRXOU0yVf2WZfuymHRucPpZJ5dBMAm6PHSi5Y+2hOHqEbU3P2rKmrSjZ4blg5v0NGxrRTGArpcRIMd1+nzLbdtkNxR56xzTdu+NN8MrQH4LoHCPcOpKVjre1EHqlXEdsxHEw6vAwK5FulHsheswKG7rqgfIflunrRIJQfuyj4xMp6o1KLEVqDikaffNhwtEBiNexNkXllLDNMxstzKiYFJCQCH0VZ79WvwVS1JOFgHGnNjUwPrKqyeHN4e8PT+9QqXmEPU1XWgjMsercGJY3n0kGHKCCrmCbNRLmCqvvBRU2VRMZtlrCdBgkuee4SL8vQR+tcHU0dDqnmWyVbMT8T/6sizJRtFv2wJUbGJPEa0NDS2tcr4LHdAUKjUdd5UhcNEM5QfVY0jGKkr+CupOLBHcL1DiykMeABImmMFSPN/wOIpPdriUP5wTBfM9DS94Z20EG44rA0otT1E3DgwuLWQJfJCynJW8/L0zffWMOowWXbLNvCDM7rSrY/564fQzQwaq7RAeJrpiZzGhN3zmL55lrQrViYC0bcGEi4MLFajeWBMB9lcgWGXRDDY1mO8hB479nwz9AIyQ95gZnZrCf20wmlJC8GdF4ety4Oz1YmzE6kGZo5bygJp0z7e59Piwjr/EnbGmrZzWC+bfxrfG6bxZs5Z7QklephjeiiUDCPJnVo4InwqSf9nA21iNNtlLID4uxvwGcGwl9QNLKd6nO0BFmFvzrpOgqjTCCArLnJEasdE816bGyKFgyT+N39LqWWa30E2PrbM5A/USbUBcvzRCGWmLu219yB1HNTS9gQNAvUiZ9rWv8lQuFw4SB8FH1r2kLB2YihhAMTc1/Uhx9T45nhv9PeGlKobGwvdcY3tIwNDqM0PeGohKE0nNFO0qm0hZLYZOa3ECiG7DokjGqSbK3OtMLkX02UJtufiRcS9wyLza4YIOhIYtq1GOd63K6or/fy+lhx0Nl8ZwliqpvyudPyCDah3Wno6ImAEpOIxrC2g4T+hS7dkSDPZPAvTTquasld877fnZPcZ3b5OKbWzK8xmtm6VUWZvhP97exgvkQvyF9R8gkAp/mdFI+FWuvffpRS+oOYMA6kdrWBVZHbL9pv6FjiEUmf4YC7wwP76K6Wn38y0U3MuEUDWkjqIwWxtI4KyK9HOHEk7CZWKfX7EOzKmiQsJmYgRhi2ezjuqkXKQ3O7h+QuN+bpqHO2LD/QEvQW9hMyy1rBUft/mo53G2TyF1tVCwlHBJH8fALwUVDfsBvI9IcxCIrY5WhWvnDEz2jyrwXpHDLs13O/TNMQ7c8J9X60IGe/kdnQR2k9NUnycBtTC3FKS8sg1pzbAft+p+vDjUZ4Veu1gdctNcBG7Ikkzh5BMCJ4PglPjVpsGc9l8d+ZfMoD10itPySY3jZjOBPHvEscp5hNvODSRRlH6yy+7lB8h5YedQadtiAfvIYIAQD0GIfygMlxaaoXdwbJI2B7KVU/xz1A1AXZaWTGF74WcO0AZKo0kvpa8mmgL6/g0bCJwo1gfXH5JXCykfC7ws243ud4UNfky6KDpHXLIuSw/I/5RLqsyBpEgh1wKPeegif+wlQQyqMvE4CZPYZ7hDproNdGZUbtYKkrKAcoweb9OAbyIp1kN4BjE9n96lKmB98OLjeulYLif3glRZQwFy52/aQ0yI98dwf+cq/YNyQUrabaSTHpByMphrSWl6bJcH3Gw73h/eTyDc94l2kzkjuIV3qkorNJ1Vg11Z/mwptPvisxyI0kfDzHsoIoecaAeQwGeqSiKBC1vbQT1jL89b5ZfD2ezn3gwCKVQR9YPXzf/nmn4GKz4ZF+7hYJ2g8+YKtDl77w/Bx8D1sUn6l2ZXDJYykjOfoOH3FTABrSCNiLofVf4JsEgh7DiguWnlKIeRbhKdxQnOCP5mMd66yMfwcCgVSIGWWft3XF8D+owIGETG2v0cIBhl9bTp/Di007MrcQCVfmCHFi2vmjA/3PeM0MnUp+cNnuIf61Qoj5vZ6JJ8dqhMXkdHqXGRyAuTkupECEAfzankU9fhWMvjEWR6wRwQtY+F2TRNTAubQAFJVHA9nDnHa9yzBneLyckq/qbmPTsXsXJKo5N4VyXcJhX9Cuyf2E+RgQudyph7AF0+xEiDj7ulHb3znbeg2TpNq2/igztOiuKELQpTEFnf88kLgnOj1+iwm64UsStfgFvK//crqTRe8lWhFVOADoxT97DmlXQz9dUvEiw7awFE/e002x0WovJYtRkyvh6ep78LpRe1J9V5Ww2GP+A0RQdBpZ9vEdGvF3AWH+pUx1TuGkeH9B13NP5cgDIo7PTiAb2E+D115IJZvqlCZ+VxP1VrgHLqIlQDjTyctNn2Y97Mql6QnRcwsNshrzR9Yxd7PbYWY+uhZZPWSJZ/ksWD6uEDO2fXlgjLPCZCsmiHM5M6QgMldDTAR6iC9B3uJ+V/Q1TiaATEs2rgm5TdeS+Q6HLCsMtBUsgE0thdM5MiHiyOf7IHRIfO0p/IRcXJQGmaHAnadzqWYp+FWO5DnHxXY9PDzvS2xoy3esJdylIpVXFsod+z5FSo7c2D5QHTO/vKl1h8Aoko/5kjazfqZnmigUWdlfujPu/BjQqPl6Zn7YlUwoqFfjMxYI4lC43gMq9LQYn5QQrk1P7dAKNdKatKdQx7UgeSmsbmyUHf96w9o2/HBAOMey7KgV2V4R++lEXnRqlPFeGzRHn+ODNB/0moW2rL8qCGosl/hWXgw6DtrtfyK9RgEmlotnUj4T/Qmvb+bKBqkPZFdjG3MDQOLqCBv8O2rkgHQN68SxtlEWrJNlJkJRmxtqpCy4qao6wTUHzUCpkeSG4GewQKRQmSPWd4J/eG1XCwPdJyPJE9x95LpdAAWSMCyPyLu/tsueDGcXfjB02+Zg51zeXwsG/KIfpYq+OjLJHjiGCXpL9TuEHzkNyKlsLELNh7QCQmmYnfoKJoC6q5EA3SD8ohIP+dztYncWc4RbbVD2HdLCTpp8bsqO+Ed8kf4e9JgrOlyKfh9wtcdkYPpIbMK43aD3JJWniGCrkBpIGyyTq35hjQm1mUSzdIylkEqXIlzEXJS38NuPFpuYoRycVBtOaYfzxIJG17RcBbBQGFv4YwBH1UezBVgp+JQ0W8/syMKgboi8O6LQHB6DbN/q0561gXK3RxbGkMyGu2myGiaE+blvHTgcYqG+HsMuymhzzBUI59ARaAABZIcT1pRxa/H/IHyqhXPvjPNLLpcfgI/g20bEk1XAVw5+xrQOdf9eFRAFlkcUOfxVzSviiJlBHSsyvZDUIneD93Nxx77wv9zcgAXXG00F/IS7JltdoUoqfv8BRJA1yu52lnyoYFdeqhaDKpIzMVC5goBu6Q1xAFXxMVlk+zTk74cZYNSuaZDzW8+LupwMwy01KOfjHkF+EySoeX+wgnJqiwKFyRazL0Z5sGqGQ4XUdDzBkhRxZHzygLUDoTg9YC+xH8UyyEGWodg1xlAaj204MMrD/oX8Jnu1nuqgcSF5182/HWymvNMxHcXdRSlE3MdNPkWAubyKvhU0EUWIgCWyXyeb+G6s6mk9iEZBE698UMIBQGFwpmUAPj4AQxMZ9dn0RIaaei1KnR+LjpjxSNVLyX6b10hXuIRgXutJodsiIe1Nf99rSq0pVIjMItcqXsHNVagYx/LDyKc4707p0c7kdbZU6vE2DpDVdPzZxyQZV/1zDooumefZnK+NlqvyAaTaXSpd40k4SHbN16yrA3jBYzU84CgNrnHaCcERyhK9jhRGRTdAcnInYMHAwFWf51iPuRyDn064ijP4etV0OekanEhRgzkSkKB1xyrqr1/7dh+A7BKOz2CSiR47QnABFd4KRFdfsPx9pX+MegZXezgPbFk4CrpQpwMlMb0444AU7afDDWad8XkILAy1Chc+AoXsYq8J/G9siLgtyOWQPq5hIbbe8osCXeSDtjGV8KcYIqJ9WH73gMg7INAqbbosPR+L+NGYFHWpoG0exdnqP/kvl08RijSCGox7eeagv5wgbY1eDrDb0diR2BKc6hvX5O/T0C/agP+i39w2sjFADmV9OLPKcR74L+NNvBkL7CsALkkgfap+bQ2iLiGjcnHz1Y9vnrOLWJpaGEAV+/c+KgUG80YfGmqfpiGxHW0aqV5ylsKd5Omlg2LQ9AdzLooq7Ja0kpqizcRwlxu1EgS/jOnF5CWfHpS4LcQ6O+Rbmxmv2AzXFYWZaZEyer6fUHVpVBMHZJ7eakE58eWTd48fHUXdrQSWNwuUrU4kVB+HB9Oygy0DJCL0OMvSWEZZBN6AQAG8337DLQDYEHPvDYShMYBxbptu9nez+aFcdgdp+634ocLNFMp9gP4nxpfUGxKtj3mbDf2rN2EaGW+LZ+lR2aoC+edAYLKBMO0UHBrvhKQUNoMqtA0Qivs3O2JJU7Z5KaCc3/GU/zE/0JrUPjsqYTn3bwAGVbACy0wFHCnI51sGfk3yUkLBrOUOXpNnCkbTxSYuItcDsC1uK/pmgHu+KABTefUHfst6VRcgtzQBoFeWLiahYXazPjXAe1T/C5G4xxIHZdX+GjjJ1yJSKfZ//owKyqQW46yFreiV4jV1TfJlFBCptHrhJzPObnSSs8kg2d5W3pahQ36/mnEp6UXffqkXLO8LEdj1l4Qq4beWyE8WMUyRK6cPt5qvTTYrxE89YHYktTGLnhy1NV7LmU209fxoo9O0PN52t+wbcOvkcBNeQm1LpWrQ7nkmQ7gtOVRb4mvB0l7+HHxzMmXKdSmQng902cWB1T1aYuA8KVpfZOEXdHxm9IiGq5sVkXGs2WGSMLfPhVA4QIjf3nRnsogcqh74zSt2CR2pCMas0QRF/rNyvJC6tLc/vtwsCWaS5vOkjDsxvaWu9KzSTxoQvbTla4P9q/gbXV1l+7NwJBZkzOb8ojmKJfl/Zb4bm83jINMTZbQPLfMEGTXmtC30/K4zR/y/rbED/KK4P9hbmV1YMmH7qbYBpss9BPPzdHKlinOvyo2i+8KSYHZWpJfILdaG8E3Vg/6WI2QZTpHqS8oRQRZbTveyl0P6PYcj4cGlS816T6uOBuUwEbFg8fYmQUJFeZnFtvSLq4JzABRwn2HLnE7yV7l5fyz2UNYgJ4Tl3Z1t5unAmoMi2nwdaFJ7U8CuD+mCfNcetGEz+DJXvxUTydK1OG+gZBD7GKJyjhvIcpQ15NUYFyqT5gwSuf+v6Ba2j9UQEq0Uyhnd+88RPqV2mmyXfj4/aLivOn/wPMz3v4/KgcasgW67efM1JmzhnhpMO6eXC9baxyxJ5L+ofpfLmtTZ1ZqnRtBqgUmMgBnQj4HWq9eph6uRGISPWrlCQA5slHA6cj9l8VYzZinl3hfP1+L6yeEoEUTiIDFokPlM1ZrNg4lEmi2VfkcUPBm0b7aIA+AydnSwPvktWi0PuGr9vBYVE1mjkaTp9KPR0s5TWXxSWqZ36EN6A2+zbBqBHrgX8r8g9+ldMMVSVL1PHVNt3CI/qauHjQzQV0rJSGxrd1CAFbL66mw4b4iOkFY9HVOovIPIgCwIft4d9+Rv1Q3Fi/e2UUD7uHqnLbNU7Not8MFtJ7a/R5hPYLyeHQWBeEb8r9jAh6P7R9gNC0NiQxXzVJmSih56PBr+XqsG1yT60RjkDnQTgpFH+bHkr8zUd/vmI8uhEt53H8nHXGkSGNa3ckMs+s3AW2/+EYxZaF3DS8rfi6e00PS2iTCxDd/ADzz5QrxwYsJzdKUo+6JTYjqaUZyYDqbMiI0MxDPtycDjuoZjvsp749+V3Ri7xHdZ6nDyPToVKteafjiz5NviFPCM9K0z52zD0b7aFlvbfHGd23uV+gXNrmoCPV9mVoJe6Iu21nC9SjbJtWq4LvF6oSCx4c7V2IWzbUgRMN1NTvYgdDLv13w2npqTRJhbi1TuKQEAM1QkVZ6DeYGzLvGI6tXUajkBvRtqm8EkMKdS8ne88EskI/lMyQtfwJcYnLmHgUDzbGGZ2y+o0MUdDN+9E+hAxtH+j7Bo0xnYNV0YXlwhrNOVBM98uiwBzrVV6wuXTImDXnoFY0URdH3tAaf9rw7jx8Q4CwE0dMPgDt60p6Hp413NbJvM8FnOvV/kEVrT9hubKX+l5f1FrNuXAbS+DIKwBup4LNsV2o+po/lgGAA+S34I7gxGnop7uUW+KHrF8fdw6R6QOXnzO1RxVGzL5AfYEvvYHxUw5Zt53+CDNZ56XQYTu45eRgvuNxdTzORdCfVJJ6lXi+MOWGhIgAsFzuiJbnKnWMDUngmXuQkfx44Eh/k8/FnXeEWOpICVvg70Y//9Xb/HrhFALoOL/lT1pnQojuB9IgxteMHzn3hdBZy3/qHRnEYPahuFbaAf1xPdk+bLgQAiTdxdUfe2XtlIdhSrmNhvWbd9mR9wOVeV31FglJquRZ2kE1XtBrtlL2j9eL9UG1wLwJD3UIwa0VNCHnjxv2wwsMU9vQ8RdwhqAIlIhWJO5ejGmEGS99bJYB5fLqoJR1ILcQV5geIbSwv/gerdgWkjGb3WWMSsk9EF4qKrgQfjVV4HQEpQLEU1IiZ2uCuaoxBBYzqxxl4Q0OLXbHTVsF7bdhX00Eiq3xJaodt7ISRCbAVvtJehKnCTWu3mWi7B0A+M7LFnD0hHjU5jNEdBCCAfhi6piMu1wQSDN4L7OqmrUJxKMYpppF6O1NnzB33cdtLReAjOm0QvlOyiyoXKRr8DsAMZ2stChB+dpiAVsk8ZieaVQTMMEbbsZBPrnR6kr8b4xZnrqkPgajJzhZ1sGl77kmwZIaCZgfva9oNquqhX03EOI+prJqK0nUeysYPBU2aKgioAIkNbXvlFaAHRC3qn8kGUTfVCZc6pVptDYPgyBrMxU/Es50eHm7hAuuM7jy2JhcSm2R9Gw/fzvd8jTW14HBYPHNkncRGx/Z6wVMlXh/ykSKXePm2jlH+Ae81sn0RBbjqprvRqRnFGo2kizHHkbXj6cabtiRbhgVcg+SWAiKiEfl+yHcjp1c5NgSCmf+5dxdDCO7G0oM850i7Z6MM9ecJy2H2VxZvY6hNZ01oUCIEyh2TLjFkLDLLWERRjjykIlrhabuaKZkFCJCCAEqaDurtw2w9rqdYtVtBjyERx4Pq3VN3LwWhq6wu2naUt1iAuo8Zqm0PlzdALy3NPRRL5RZIWfiK8W3OIp/41g87AgGONvDIsVQYg+3PJDO28J/5B8PGHCx1NlL/1n7laFpfzj1oE7/00uZMKtoP9t4hZ8eSVRufCPtxdxUhHGw+Cu/nPWuc9MYEQ5fn5gD0/qJJ2inrOplhW+n8qtgMIGanekGPqU1U/vmZzPBqYhJOVTFiveoAQhPeUDo0J7kBLfDPvm9G+t3+OGOmSwDHPRIygfX/res//3XIKm6E5gigtSFyhV0HWfzxuG6agqqripRjq424CPvLEyw+zgvDICvOMc0v7y26vJ/LheMmIAoE4gcDDHwEvdswTfi5ElT4hv6GqZ37O6Tgu36kAEZLR6cHOR92dLyvQL9WsNCHuvPgvjsi+2EB9cUmiVFnJwwDZgLcv7VYfqZlQ9+fU5tYWm/ksyhTHJkKIRBGp60wyCw8XDARBhKYvPNWAPKfh3np4ydQ8o5065zGA+wQwfxSxiYrdqPRkp3jNK4UtAs8tTSO3UQXl0sVKjIhFZT7rmbQK1FMaatio3t6FsysG0D3O9QUm17BgOQDADVSOYXFpBH3w842Fsn8g4TWoq9r82tKmY9t0/jzrvttUscYc+iC/BQwQWN6vVGfWTFIbNzTJ54UYjy805q8+zvA4xEWx6imEEc2QgfHkrMHMsGDG56uAhE7ySGkKvO+MoPLea6r7fxYCoR33Jg1LDVsFYYsYOyTT8mATIiQbP3/zjtloY1H31IjQvVhsip6mMjJcomj+ypAuD6LFZQjE6lApH+sOdQVOXs/8q6tk4bfWPNnyW0mdzL3bapHz1XIBrh007PUwRzhQiMmEEkSN5PsmWIVvDXt7KpuH4rNelaR70W6uOtI3Gm5XSFtfvHtYxafGyIzDXT6Ern1O2rvqIubduIcC+TiCs/bOUTl1GGCj4MBOVK82ekVWlkOeFVHG9Pkj/wov2mhG/UdJFmvC7/IDBho/9haWt0QHhuBIktW90dlrPphVeN58NCZxPx1DAUvFQlno0isNrTTiTZNks8xxp3p7TcaG9me/llv3hguo1YLuPoPA/Z8LeOyxRr1ORsNMcCtK0uxdz/kvqPs7buBo1zHwg+Pr0R4ng7U7DxTMNoY4aSPec9gAngV7mZS1pnti2NY6IUC2zmDLA2nMAXQVlFhe8a+o8/KPAia6/DPAFdvC4Y8L424LvhDjlQheRhP7lSfm51FNCVwYyEn/OBylUI8D4SaMiMNnWagXvZbC1dfN9H60itNqw8m9LqGek0KfVK7yeOC664LDQaUnUcdKs0yKWgrNnBIqEd6ru/EUVvlgr8qbckHqyay7tAe/5+6v+AGzhrPrWYpEsBBwmrXxmIE5+zeG5zhCNZEThj84Rsn9AX/AKKpy/lm8NttRwQa4Hs91vbhTFogxr32lPo8IIMdu0LOL8MEtuIpgsofxlzTAc7j1uvsqfPVa9EDrWsT5x5PI9mwVQGBTpVc7vtwPg0tnta2ZVDm22BXAFatd+xoWQaS3GiOh6k2a2kVPXNQTEBD6cfBRa+IctiA1RevTAeGjQ2ZNNbFjzWtRcmVsxnMS5g5MNBEP4D9XQ5ScAB2wljJnqcZE1YIPSJhYkiQODL0VIvoo73QH2aHHbv0xBkKR5qxP2HJ4+Vl7hC3SOtbB1ttQyO1liXwM3PqLJ9X+yo8JrgeggScjcb1iTkC8J3/X3JSVIEb6lYxERoDv9pbbfZHIbUBMTRBaD/kYACLTRFNEu/TzGIEnqz2q72mitrGazMQI/J7jV4/lCwPxt17UqEz+1XTBMCYUq+ql56v+KQV4a9+QcVrETAk0sEhjoN7G4kqa4pijexaIorPQt6n+GdpxH4M31/Z+jJ3oYmZw7VsRsqJR2n4pdaUhGxRbK3GTdhE94NlXHL589PgRgFW/momcQyE04eY4xhCaggD9AGl3WKyUB31oeUUQKXkhNcor1jXsOkwQD+zd1qzhY5e+YpTrjbquNrhhpAamfBdj+J9tvzDtWsCIcddllytEtdzmSHsj/fHCTu7+KMTNKhq2H47xyOjq9XQ4dL7OlNHB2y7RUGEknnfQavfxpCEGQzRNXmnd93ndy6MS2UllWKdYlJ6VqVQJC4M9TA/0yLP7/Toht0DL3qgI3DXObYIr0lh6pxopERlh6aRq+kFcsRYuSy4qrotSD4hzBRiEDubqjRXrf7XDlcVAJIumzd9LZdtAoVgYnrumbklQM8CfcyYsNKuvWok0fU/qRBFA36B0n+Kjc26Qg6u5lst6/olfZICZHXUKu0HZqsCFzOBafGfrcVOQ7S3vBTBsujdyXvpXmHF19DQ2U7LqbdbqVnLvFlqrnWrlRJDCyKLatR8rK+vrythTiTJXwOER4wezyqUMT4pHuwysGwqzYd7KLFEKkDFqmt+I/LSlg41XvDH2bB5KKU/kK6f3sh18mYi1EvYVCl7GFsvbHTOJe2mv+26UZj9qyMMQGVBAX3OW28waDUBwSfjR4Z46Yx3ULO6ro7IA79XepmylFov/ZhJfH5VdGTD9sQh6Q3GCyut2s4mCGvrdJsxsOxrghGBESE4gA5ichV9Ejw2ed/zEoorPaG9QkbSnaUTgL0K3aKXHu2U0RFxZ3uXnqegaJrEt38wm001p5c54XExJTuGUcDLSRV7L+zn+x9X+feb6PzieO6DpKL41SWndZ+NT8gnyxRIefghBIMviNtUNMaErIDgvi0IgFSIzb/i7cEZytw/3zfziFhVLHuCD8sXQuzGBZBOzknSLUbVfc81ul1TViO5qyx1BvUD2Sob428z8adAKjorEQMNu6mTR+nJ/vuWVKkC8qvNxrY2/IVaPPDQLTQqalajYudilK4Pq39kqtNme/4QTV077EhuhmDDg0/cxaxDef1++HPoJbKmG3E8cUEXwaVM0KI88byL72tMAGjULh38rivDUAOY1alUo4Xy36XOJhH8MxZgheTXsqVtwJZ123h8l0m9D3sY3skriaaPN9DHb8x0c2CZTRut4sLR7Ejy+K47ChUrX28X+OS1jWck+QH0Sl9/sgUJbVbcDLoqGZK0LxMKjChRL69Lnz2cS816Ul3v5SSb77RlBha4qKR+MlLbwsjRp5jrjQnDbiz+es8/xEeXZU4EuiUizK6Tz5FJL7RITdtImIKsbGgmL+oG6uWFd0m0HB4RfrfO0p//CCp2XJM2cJ/2sCrFTQ7blzBFDoOIjyqcZLBMRY/AKhwsQDSp73rBcAC3L/1GvXSDNRPpPoBN0CJBuPBHuEZK3k+yYepAoC3JYk1ycKPb3EEzKI4DHguYDAKr3t6SSn8QRkbVLUpDfgf0X7UNuah3sRP53pWDYl//ePZvsQD14iOvDEtXcDj6McSv1F0pMS5/rm/RXGVrXpEq8i//kHgF57JcvkK/UXh5xbgScHDlzZrGvPu8dXC4e/duCnHrthghstfyjGUcKRR0AjjBTA4a0orEqzcFtoUZ2VUG7yaB0trNAukd9Mw+R8bpCF5KIPrQfzclq5d7WW5LPsPcTuaOmxXzmAToVq6ZeX48iAMqdTCUpWVnRnVSeUPQ0fqAFoRasppcO8p4TWGdmUZQHfHscO65bfp2W/t0a27tnVGTzRyJ66+A2sBPAHdpkzg7blkWVXyS0mI4vQ9WJ9kWQebc6vPpISCtBp6FwkvoLIs+bql0z1sfA7nPqPJ3tPztUIaU8y3EDLnYd/qjvL5PgOuzR61xj31G14OukOAiRl1LxZ4MmOYBkpGTVziCYywgNJhCCTWG80D1LPggGiddGd77QPwUlSLhM0HoT5jEiPJfxWIikksvHqq6sIlt/ZWpB1e353hjzffE95pFVvrjE5abH44B3YgXti4odW45MyzA0dSmOkRESyleCMk1RF9rQ93ithBkiAP0u/2jIBGbxteHpZ59v960RBEKTPAglZpA1EjEi7Bz85sA+IfRW8jVrKuPGrdahfnMBcSoD2+nmrbchDIi6DhzsLwsIGQh471p9AmsiXUtk4QS8PbcqDl97mLzuKEMOt8bm8cA/wipRYFk63EwG3xY2nAAnxku/laSerIIe+7EX19r9tO/s+jfHGXMn5s+9U8E3iiv1Mt1DhNMlIyKKTcKxspF1NhKBFD0b1RNbn9BvnHiQdpkO6UXiaQMG6W3lrR9b3eBHp+vWKpGAzorgqAHQAFTPrF1WIgx73e/+AaG/btXyLvO4tGb+9v9RvJ37q8oGSOypz4QdOsKsqYYxkeCFRpzM3cIeS/WA35PooSqQUkCxskMpCPUVCXEZzTgkmcpwaaCW1uGFu2GCOo/WpVWMQgkzWZpJ55oytGmlDWTEg4PQR8E/SriF44sYkxYaMxcbMV9BVL+rM/aBWe5JDKoj3SPKGVC1PDVYejDbnbsDaYKmuR3YvIDyFtlPyBweuLIwKc3fYoocU58wuep9TD3wq41FhCklL7ezxw7iIQSBr0GZ6Nrkk8tExBhI8ZjNWGriBnUjdy5FcQ/6vwQzG/j7/MpWolnFSyLaD6szFjDSyjm4pEgwxtMRRTd7429QXcDuatWsx3ErhrYrLAUIgLIQWwjj8KOs5brTQg+hsLCRD+cc9kYRtF06fHvbxmLkxnNj3YKsRTEgJWYfX/kkZ3kZiv+rIby1OxD1/k+vdMQPSGf8opcviKwnGDh29RWC77XvzI5NV771/GER7nkcgnntMx4ffQ8pF6vKvWwRno6B3uZ9MhX6kIHT0wzn+TdfeexzD2zT2+t5S3uWkez6qJo1H8l54bIYIBDazSK0oxraHrw53A+UEgF6hM1Rr0ffxsKLVcf4YhxxL3T3hCU8WG5vyhpSTc20w5VGFwJTS/SS76QcW+ZHxgIeeC2eL3uKIYGnom8doaC2D755d8JjV1sIP0E2NV2LYhdLec/bOW9YpS6RWuw84MwyJCqtx9zufkRr6bWA0qQYDj8Te7/hWK+OWnBLH6LbhuxzqtF0VVH8J3vKSyl+aQYqIUKlQNVC3+bQzqD7IJUWRHQV42uTa5bQR5Z+A6DtRu8C4uWawSolukz8rA3/kPheCndkU6X5ms6MWa8WnRHYlVlVQKml9JsjJY2asD4P8fpzCy//Y4uVUheDpvdSYBKzS7Bh/km1qvk+Gs5RHqw+/T+bJ0uHq2Pa5WqA7HSB2LrIiBzjDIYrZJJejsRvsbwgK3/4njIzp26C80PbpvpYCn2U7VmmxOX+DM2Srp3qhb/f583yPLV12yAkgZMBmjeKZiSX/EK73ftPulCYO7wsp3PNw9ZmoplW9EXKIVUTyw2J+vt2QbQgxA+75WQ49BIVE351X8a2t6qQq/Xytc/s3y+JTlTyDSw8IDfPLt09FwLCQBUJhBmtc5JVgSndIhPs1ra0oXmM2d9xF8ldS/AUU+BoWcERzwTHCwfhn05ogA3Fpz5wJFjK7l9iPLgQZe9KlZ6mvyVSdW5AN5PgXUC8BxQ6yx5NmCqO5M44Z4TXPvb+qXULMbNb/ys+ZMBSpa+yReS2eJFvoVRh6TdoDgBgWuUW2GGfEeuJEXeYwQg8P2BE0JUAzATeGMZulLuMetF21NATh0f5Uo/LNFWWC7BAWRgfsdXY5OnwKTUHBm6BYApbzrZsQPMbMn9W9ANQsZxlSlu8hCL1AJkR+wDyUIICT5NGH8jhrmhrgNrYs6wzb32tz8lElSIlE3JCOVgxMuO2WCTBCR00tIbQp3CeOpaLgZ4g5F8UjBY1j+3JyMzioZ1h3RsecQ3fieBLyn5pES4qxVdArbgQ+NYOyQyW0EpGZ25+QZfpjKkDAVQD3Ub/0xg54EbdjQTw7Nb5cJbCHaNf5M7kZH8DXqdVzLpo30cMsWs8YWXwViE1cs0iYypsQ+cubeijpNjB8h4B/eS8lq0nKI/rerboRK2U4QmUXR5VKmn0BTEv/6oNNHvDfViMstDg3mnufmaGl1vosTFGMp5loFl7/wYs+mTvaYm13eu1eDnN/T/stgDrQ9CsmtBRJSzfwk7rMFOMmGEyv8fbDdCvPERYbtluBaCWfKakauOkOnkH+PF5DGBliGNVWazIMGWuIpyCLZ1GR4S63Q/BxWlXVp83ebYdi3cbN2qiLVDdcs1DykN+vhXwjtdtRgchykuqex0c+OHeunyNyYHbN9KsV9zu8NhhfchU2TNUeW9zuqAKtzEyg/40MRWa58bSwBDWl6LM+wc55lwigPjIZ6pGzIN2Nu2gygtjyLpyXV/g+xx2oz1U1ZYTOd90oCmFoWeKzbKGzfLbnUcc0Pk/vWmASt6etzVw0rQ6QSLJwB4kcGLcxkkcrtex0HdyQnRgbaIFfPCq2+qGHuAr1zNCWKrNKuCOGsf0d02JJsT6hUtNS29iHNgbYkfNri9YqIUe3GXuMfgAdibgvGhbbtuVRHt5L/SvuEdtbLToiBbvIt1LN3DcCKC4B0bASLjfdF5jjn30iuIdYSIkmEo/r5apjob4/GO89EEBbFJHtCy5jyomFNNHDLdWAEEsPtg/B4u+nJobAUnVI+FRPxAxMnm6JilTgcNGp8knM0TUPq0ois9dLzCRi2i2MWOCCLZxYesSrUipcDBczGoMyMUeBxDYb5aiZyFPrBpFULRj2hwfa6UGhCN1paks6Dk/WpjhLenKpNO8l3kIHoOVzU+nN1PQgUUS22FaJck49/3dDIrSjcwvg/5wAQRKkAYxX3lS1e3dVh7AMoHaRqp3flEHgKYBtWkFYWJltqciFn2nqvD7aAT4dn/M9stVnmFEs50gf/iKHVRQh0tRtd65rR4Eri9WRCKgJYAF2kNX4y6VKa2JWlhKfug7eU/X3QobUfWmUJGqxyeLluP5x0NofbOG2Wmuet8lVkddCqbLTqPdcVR/wKUAO2qgqjbwRvvUyjGZwut0a5NcvSKjjPVZ5iDV6kQY00PDr64kQigMUW48opBUPphrcjvkADPQKwmIg1WpmWUaCiriPBcl767Z98W6xaAworxHzy5hXZCGVOZQ30FYE5BX4YRjAxCNt41c4sA2WQUKN1Lab4df2Setc6T1BF2Ikc+ggwxtxuqEH3BFHLc2FPnw2oYATh4AzwJlwz9ahlXJDOE85PPJPnabIBrd2ls+LBIKnmegXUQuSE+BP6PZrofIJnYw/H4P3HMDKuQ+EWr9pouCKfQu7bDAnlS3+wejkdFIEorPAja3cGwlTP91Y0ylcXKoCCKKn9F4QQxMMKHKB14NwRl+qktlKw8J4lgZgA3gDyVtgFKRKbA+7dkGj3cQasGBOkX+inaQ0CbW4BJYPp4fUvWewJ/bt9l3aYTfWmJZX6J3xq/c657U9L5tJL6IzNgODhHxGM4jGLdlQErHD+GTKEpqdLDZqQqSRM4bXQ25NwgCpdWlIauEJpqobSe1Y/woeN9id7pJIUtOSVE23/iQX5dg1nvmUbBJZ6NfU+3bG6JmlD7JT/TUwCirHqTSveE5PzyyKo5nN36Prwh3JEKkyX7cECbyfRnDq/dyLzqmpNrZcGyd0N7U350qP4GFja+d+OfQ9LucHhKO/jq3Aqf6rL8z5CgxeKpXTEemwkdKzIszv+yjJuYyT4eLKEcEVnNypDc0Yqkjc6bHRMOWwuv6pjQt5otuJuQoEr9OaV/jO1y6xHbtljdk78Fzqif3UFZC7MtNRmTxUADK5fibimQsWMegU43vYIjg3FnbMDYiiNM6QjhImxK8qbAhK/Bydt8Bz+LjFy8Tl3ckYJdB5v2Ve8KTZd76Jiqih7rgcTUZ9PB5FwjZgh+og/VjN0rMigOE867RSCBUKgVieyLSBpRC+zz1uSJk3PsEWCfJRLfBhARdYQAtbG+LyYK2RlpdXbgqWg2SvJaFvXDdHi8QzRuUqiV7DPug+EwkCR/QVUKvDkWjtHpLbjXYfrotb5VmBqEV8uklB9JL2XFu384mu47Ij+Y9YPhh7ugjdf+sURMVsuLnkKeWvMVfKAgMiTSXhrFYNfO/hoYPDonIjBkWdNuVai2OqleFmMpFy8AosQ1jgKOUimoCIACG0CdF/Vdwn+9Y6fwY6bpKfuBrssJfmH9zWxe2ow8LpwqTlgJv7895rthRVirQFKAhsi4d8/IgVzRfyOFNEptldl2FIykUs9rXuVulE9WEUFBshiKw4XnVKfrk6cCvWkqYVlb2eXfDnub9PKMF2Fp6GcU6oYhu/EvsB88fiC7Ik7TIh0Ee6aDVheoAF86YMtF8ca7Yafib9Pat1VCjBldGxy3Z2+phFy7/BJn/9UX+coVfqCTLFBjiIoFyIU/YCDlOHemXMi5V/5HxHNJP/MCVH+vcpqZ/I26rkVEbdweiOb29UG5J85COCGLXp+i8ozRo79+zXmgNz4zrOsjQnox5vAJZcdNDcnJTye+R8fE7+ehH+r/CYwQ3qOn+1WbKaljQfm+uZFTzqEjPUDimfIqTQ62tP98F8WpC8xzNpTE5Oxu+wpEFaq9roFV+zCba/lxkxPRJdhtuj/rlhTP2m+nfqM8lhN9YpDC/fpp82xlhoo8sv8/BSEiUlERU1fzEJUU2kR97kQCZEpiEmZyV2dZm/9Z6teZaL/eYEtYPF0pJTTPzMlCH6GHRS0XE61qPVpetpcnIecWrebGUPzabMvEZIPI+4p1Az3Fa80ve2OAHUWwSsOJtKV8556xqdyvPjOcDRZVllLXdtSb/92XIESGsjHCWf98D4L4eQB09F0VM4cH50OLIFh3y65f6hb7XKqMni3Pw3W43ZS6vNPXzOyNUpgz27G/3C2jTACfftMx8UaRJiJy0e89pUcpsg7G/xyAooE5RJzSTN1iIypNnMe3RtjOB4lnQlnILZ4YNSfD39JAuTh/5kkD/nLJNE1pCLm6KViYIoMyaTCpUByHeB5nEcy5Oq4dLnueHTg3vWRZL6mj3DfKaQcyxR98akLXrgowPNeGSWULKqF/ylWYpQNWDpF+Q3TLjGaNl7ZW/jJw9kjvOR6F5GzSIsYrreoFhE0v+y3PuIyWJumYlaJHZ/SeykSk+P7v/o4ODUxPAp2blcCLWfJWGM7+UBWRdi3Z66kLZ4j3Wowt8raeScElAYbeMasFa6wsUel7RHjuzkWW8V449jNx5gm2NCgkUJ/BjijG1TiaH2B3atjkdUY+s/LuUNFd8NGKoVHqz9yvRVGsWUAvK8k7JVj7Wx+z2tqz3kRwvanb/v63rl5qQ0oUP7Ba6Ou9C4twzFdf9gVWKT2WFfodcEhITPK0KRWZid0X2AthBOdBhUPUyxQWPIQRsiFiXwlAz/21Ut8pjilZ4N02jFgfhNRodLqj3uj0MSWASkq6Z/dgqv2RsWeqlidPOBmf4yC2jgfnRcOnnkAOXVo68ri68EB7HHxkNCsD/debiUqJkqQW8CNhKmCfaATQs553LWQWJWXAJM2aD+Ke5vxI/HM4lFTQTdxmt8cuHsYFhV+yacpiqogV0pF0s4rPq+Ya/TKiPiqsyhR57TsH/dB7i0Gp4FqXoUkS2KWmRDlnA9YVtl1xAyJh5j88CtwPh9QknXMs9cpyb/ZLXv/CBnlfbTQqsxubxZHRABOkrDVPgnAZEf3wQSHSJButPBF4VBEY9zvIBBgGo33C7QjAHKFyqWRyyRanDWPQTw3qgPAi5R4x5XzjxZPC0atvlTLVxjQkx1W5fw+lKN85WSO3msOXEY+9JMIBOpBXqfmhcJiPH4BWK9dxPjFWx+H8MXmv9QK11Ejdb5ea2x8WUTs+KR3vv8SOD/CJWYoSj7drscrzwnVTSXY1Z+Yp003bziee963H9qM3OLKv5Kmg1OTQHGQxJYFXYoiviStLn73L8YplzUUxSODQiGgKEh7MLub3TeCIVAaN+w1ADLQcFiuXR1mbnW8h4TopracDbKm/XkSy+W0+CVAujWXEgtDc+APqVZIKfZrW5EDXOTI0ZzQTPxOA96hYMoKR0OkiITbHCGJVx92JkgUveuBWaFgJzDiRGtrr/qkBtbkAMsxXajCWTSdXqw0T85QgNbVwmfPVjNj+pivhKY47quNxWfgB5ZopGMHQe7DpcL5ShQ0pGZR//LqWRlv9oGOxFGobYenX2Vxq+pMH3p5k3CTGcnSJGVNqflLMPavEz4O7zKSPoUDSFP+DLoYARY/9s695itIAKUSsJz7ia+AiAgwDuf4D85gu1ZR+jq4+eeITxW5HquF8dWL28F7bO9U5oNQo8kF1fCu3TnfcLjKED02KEzH37VVZqImC37VvW0j9vh11rQsFlXSs5wONeQLy97ynrtQU/HEo0MyLPXQpuaHG6BYWkAs+RcXf68SoSXDJANH/CEXDO451gqYyuQHcWWzi3KfKp+jJAgZ7XMS1rY1+kVgi6HsxJD72APsJnxxbEtMiyZT5zWH6AXhUwP43M5Zu0cNQ1pnK+qSCQ0VVdBX9mmN/T0rkgzcQoY8HSZO1LkVHiwAEkSgxXjJgx7mmR2WJA/hppWiZdkHZ5OgJM60tOCN8hXRlvtXpT6FvPp5remYxMIb6Rgyr6iI2GTsjjrL8iKXSysaT/WI7Zm4/Y3qFJBUUmeFLJKHDzo6ec8k38P2AeipeettjAxU9Tgxsxth6IQTFAhYm8WlQIT4qwo0Rftfxk0cNSNVCMxEzJVyuDBjvsZnGAltHkbUR8Z6N3MGZGYur9zjmC3CgZSk1JmcGEOmTYcZTODtVnKCD4mVJuTHNpvkL8DqNyKMvvXoYBDLEkQIx5ubDNYkZ85njFJnTIhFMToDGg7ja6VFIWm3z9Za0NaSLBs/zFETE5NQv2b0uPp2p1BYjfdIYSzDSWrFS9wTNCsMoChj9IIf+8ktcC1QlAmnueiNde/N0zGRZY3LcrG9rhDCcqYfLTeQCx2IXSAGD8wOrt/pg7Qi4h9OMptMXt0DadwmfJcNTL/B8xJPSl4scFldVtoKh9rPQ1tgqkXZS2yhb+5t2ycbaA7ez+xJCPJUgfCTbOT3AYIEGl+tbG22tintK5ymIvSYDDXIOt2nBRXVGXocCAC12lDEiwBufoMxjvGmkxj5uFcz6seMLm16wpcw2muyip5f7hgnPDUQ2F+BRUxg76SAJls/88B3Prqh3+j9RaA7elUexhStMyZq/ewCO9uUMtM556cb2yC1XPhSZA8zKeJHUOBsrlqM42Oa81qd48/wjrEp3oxMhIpiP4eQOZPuQcSgKpZfikJlXfzKtsQD4WP9Czc+BScolgtQE4WrsUChVPB1hHgeOvv+gskVzfBvZpMEAnKtRkn2nYZJocnYtYQlp7i21d91/2TnkUOyF6JQ9ofrDZ7bEh39W9mHVIBzj/8+2/HUHhctKRsS5r6+IcGze+BD61pod4QiUeTySnghieZS5WvPSwhSeFH7VHy50XoAaUQOqZMG/mQVqZKfyvI1MwKeslLix8ghH2pufEkcdTniRqkZJNNdvWIlXL0ROXsTp8BT8UzT1nPihnoafYCC+Rs9GoETROBReLYuMm8Gsg8ec3SjPis9y9ZlmjVvTSHZqEeIuwOV5RrNYL8DZi4Ybe5i/nbBvhnkDXaNIDKRe2mjTKozYb/9zrOSeYfAgitcmS53VFUqZ3P5FtLJtTTkvcQEQxGas1Asg7kTgufvUaSLCKNe/I8DqiDyLZ4LISCplpAa5WSeNoNDKWl3fEAosTtBwuHoOcZZSOp+KPX69z623AtjxQmzK0VorUdSNTk+CwZ5gBjlSnVFWszBAIzplx/97+JxD2OduXRRnMM+pP73PtncsoXnPbVxBXwHWejD/CqL/clboF1GNGzydarKxUG4s5CZfyDBKN0klNDCm+SAIxxgJ59LZzJFnWQbopvj6jqPry9BVdzJYig24TL4dL2EI9TI/6UspCamY/mqXV8vnENIu7tL8Pr9Ppkn0E4Qp8d+gY4FPQFK3QcH/UN1NovbgJOhcO/+gzRtOhdPossEprSrsdMh5FeZrzg+gGefaZZMhQs++KINFXRVsYcMqxyR1ipX27ymGCg86F4mYtolPOgi9D9Vv1NIkJ1rb6AyRSgsa0YOLIDY8rQ7fW8jfmTo13XOn3Vw2wwcp9nU6UlKEJn7Ts8TRxomsvuJFxIqisfjQf15JQTsMp72cqGL2JVnFecymYgKljN6msVhZzlzlOr5QGiwCu2O31XdQVfg25WdMgw3CsOzulk1R/N1hsWSkUJKAV0MIOxQmhIrHdfKzfS+BhDtoFIfSO1n8Uy0JiT48PjVQcre7GTkg5uZ2ptM26OSWrB2c2STrkEtfG+SkdHQdlTcKpx2l/rqwyHKnBfvgqv586Bypzj4nxlxNN7zhMjU8jdEc9kYe1jlgPReC/ITIO2ygiIhZVu0PJgaFC0v4mvcU46X+3vEtUuyHvCNm8T+7p5Xn0SD09dBju0qQu8a8o+ZsSL0Yz6W3r6t4ipZmuGfcE8VLsmdkkg/wewYiAksFyLEt7dodxrZJ3yZRse79ohBu5vyz65gWyrL4DCwQgdC+u+nGDIIuMP/2N6DUfHZ63BiV5bFYpr7Sq55YG9lgS+li7xOnolNNoBy9/vpMbbigDL1QWWRpGmRT7abaRRFeDXCmKy96A5mSodyAnzHlH+gfjxOahty00ry7RujrS6Gw94wVXix9PREFCS0kHM29JIC2PnBLpoqUlQTYws7M/PFAo0MbFKYjcva4rs7pOWbSRvb5I62HwUJ3BWp1DhBTFCwlAZ77UlO5wdjSxV1efps/wzlVxR739zJErvtzHbAErVEISIOscnZ+iATYD95UUGzFotsn81HQduMOWxAkh7oMfGVMYVFt4/ivwk4JDs25LDFoc0bYev2mjfQUobfW5aFd+6Hb/kOrek6JD/cnt2/38grPzAXC6vzAXQnXpvCqeyV70p9w7lsdwu41M7e5Zx0WXQ/Rho139tcfjzD2306rvFJ5LnazgEaoBfa1XQ6OWFO0mg9MeOPdArYzIqkypc5j+v0M0ikol56RqlZ+6PGvLNMY53NRVQlsQ4YLnqQTQnP/5kEUqo7V8mfVp5E48ZKyCJJL5kgj8Ih9I+lR0jbx6RRwYRImqpkuDbkV8WWAkc4lH3SpCCEx2BNRosRnhi4Qe12fVA4FJ9Vyo8D8pLNHwciU6cZDNx0g7mh0TP/H12Ild5FTmpB1oMpBU0Jgtv+vcD9TpxFQ8ktJNq+aEDdgkqwhZy4WDUiqXonkkAWwulqtpdy0E387EontxRhWTrkKs5GM+Hh13fLjlHPQ352ZkKxVhK2q24ESA6CNPNt4c3vnsWoM3yqJkzITm2n/wvAu0auOxtwB5sb7yfWw0ZQO4yXCXmSQwZQ0GtBisFo/1KCKzx+3yWiCeluYzwRSIjqlhhFH4DZBVIw2hN/ZsvZxU3PejS/MDMkeGp9egAhCV7U1QbMil5+8j9vLpzWruXF9mVNRGnF0raAGPS6LYvO3XHe3A2s/70GNiSqohQnMRKrPotMi1SZbsVAlVgACbExO2o4nGmBqWso0TYn4IvWfphc9xpzIzzuTUceJ1fsyp8cROg7sW6bgTrsS/rw3Ow/7EpU/OfEOrCn0EAnaVW+ngC20hSOYVmVNn0mvwtU4Fg40cvc+oyFoxF1W8az9URchAFmpNjLhrT4E4+ruYkyMlUtkrHC5KVk2VmvMVngggVQGzradJm1uT5IfQnRpBxU96Cs1hiSWuueFRbFLwmTFcU0kkAPjIiaIT+3N9xiUq2Pq8VIPB+ZrepdlipjJCPiGMkccBdjoWz+jERjVmyDDxyGvozwNMvDOnt7n2bubmPixm8X1iiUNPOtJyq3xEhTKkZNp24GAZlXJJx8swxpa51UXN0IWoZZus26HZgWM2SAXC9HDj7wDp9AxfO+4GCMvTcq1J/Q9ZnXF79YobEo22hFMO2WHDs4G3N7GSS/K7C6vujc5RKDmjSeRPICCByakZKobQgSpq+SwrNmsGvKXkt71Mo+79DdVnEyqS3FGr1l9zCHj/Cci7J7h5dsQAVGBzNgGpqOF5Yr306eCa1TMYejt2euh0lDszHWziB5IpFIndYhrL1OPg4RG3v2H7I2/nnB6NTBL+AVjMmt4KAeYyXrrQN5jAhEMJFw+/ltVMRUY/GKOCBAyEN4eF1vb3wyiltjLACwgeslI/DkqDOXxwP2VcOvbpBADkr3BothrOQSb7FolnC/PwsLmhPPXgrXDR/jxYVycdy5IzkaOyzg8kBbT+iOXR2gu/P5zq4S9I2RKvZhH+P0Ugb5E/0gw3vUAzj8SnNsmgS2ROuN7sz/BlckKHTJiyzTDOXF/GAD36poGHmdrTF52GxOG+Y/kaMV4+rATuiuh+kg5P6nkUE1N9MR1orIYIbQlkTu7qTy9Pk7YDSzXzWgFsOQY0E10Wyec+M2inB6XZfXZK8sj+8hiGYw3pjFmQmn9E5LyqGXxKnV9Zx1SLNmFrVx6hvH1RMSakJLxT8+oWRm8QFiBmKprnw4uTM4MQ+phhLOXVOL3SdOJDmzo+MfHGGVcycs8dGeu2qpLmB6JIJycgP4RgZ+gJ4fb4cMD1toQsVERNd+C4LuFnArzFr4TGrqtUcf9qqSggYTbzcFdJjjiRfKx8PHMkLMD0Af3DfJWFsZJw8QG/TRyMASQY4O1uARAmlWzJT87qQi7jX1YOGaLGzQuogtTmo97zq9NTMCcPPeQEs8sdbJ89KvqSqQQlSxYZMTQ6oCZVvbFe+mTwjXRQ5l1K7jTOd0k1g/b/gfHr+v9dTDAITX1iFCT7L8ys0RwwnmQgNZ881EsDFKtf88VSWqTFXlDHz/L0X1fHRfl9zXJ6tRTTDRWlOL8I/OgVnGkCtUC351tst0+XCMsR9n9+wEeIwdRPOP6K3fnYTFLfQ2SO9cRmsHZazgqQBLWfa6KugwPbv4szD6oigodWW1UU1x0HllyqWLUYTUmolWw/86+FskPiP2BiI8Mmsrq7bqnnFhdhWWVW5QtZ4prwViFBGC8WqqBJCqKdkt8hh0wV4UKt6bS30vlqEdTdZ2lnJ9DpM/SM/AgPW9lfy2G0u7OTMjg7Pht3soFxy3o017O31/6DZnb4h/Bv9ODVd1iSQGuWsSAhrKYwgElEbDqc2fz0VLjtG9n11MXQi/aJq1LPpfDsvuUVlSqVG5+7zsBAVNFbvMfzVNqSNsbxbAQDIDWnpv5pZVIEAOqSUSeboIBsIewQ6tsdu6ngY2CluWSivqPv8Hq0S3VdCL8QYq/IHOTwuvyG7kf0E2OYKPmJQTaVM+mIe6iv31+TMh4IeEnsay8ZfSzd04cH6le1Tbx14dS7XcE0sBSvXZ2L84U75qSmxwDzGMID9qJSv1JbcuPfCGlI7SvotGfXTWeoKxejppSKBvuTd8FNKrlFBFVvqYYn6UScyuk8O/lRjziRlQGUhrnwiHW8CH7UM07r3Is9IKt7hsV62AqOo4r9d+Ox26AV5kUN6XNBFJ9IaSc7f6rro2o15K9+ojq2bHWXkul/6SzCDU94Qe7n62qSmISE4ji+v9E6jXPyp5oBxThBkIK1XV4GgSQaegjCnudHcKpPf/4VQpas5zx3QIpbFH38zfnWyQhN+3us4q/aR+iPstIQMpBOcsngLQcNcwC/858irkHxuFjinVHeMy8pMKLYblJGy6C8cfFwNIitTYvUGsz4D8EPyoqu4YtaPMXoSxPFMOT6LL+NxLanWGMq4GatxF6Two+3TEkoa1QplcS/LWPyIoK8E/M3HpACFovpWFX4YWnG4awJPC2ube4jJSS/fEe72N33D7l/rdy1gB4lXzn++KZPE6NgRHRhjFHPQgb2vL9fK76noE4yqO/+Ml+i06516d9MW7J8wi+gpap6itqHgxnBKW62qI3lC0bktSyXtl5vTiohQL5km+O/UEoL1sEkOnQWyjH7yBN9Xg7rEUid6hIjJRZ3NX6tpshlrZsR/MTgLBISoHzEkUPV+dFRWNh+8B3NVK0td68e0A9DiWuPxE2TlU8Tb0kAOC9rZOWCzeGdPRcKGrz/dEQ/tjKmALBXh0Zo0o4GZ8hechu7txCdPZ+kTjbew4YTIjUyWe725kOBljXXvco+k4CTqWV4LgglJ5CcuI5g90H5LLwafbzKrGKLMQBCl6xSP4cD0BbmqviDnHdvVgxr3Ch02+e0qSEBwYaHS+xLg5OCUArVvyMXGrYU+NHr/R+OMDGnK9jtdC3iBXiMKb+wcddvn+2TUi/leVhiRgrxoFphXQYJji/RQBdDhsanBuIErtQchllHVe3UVgIzMO5ypFIozO94TQQpbXi+Qfaj0lOPb3lfKuH57/yK8gEqtk86BB2EFzc/4XXKTjRRqjMuTh9L6chtH++Dbaoz5uKRqW5FH9TOS4v+67PsRVwOc+ZQ0yErllGqvO/Fxf1GaQX5xUwrN7rabxVNgOMgwvun4gEaEa+vTMDW9rQYmFg5iwFRku0nnncRjWoVT7HdnPMGi9SYmbh9BJZwcxkz6N5CUXHsExddXpMiGorxdzsQGdYpRYulW2nccn+z3n5vVJ1qiBckt3dAAtmYNyVFkPztwZDE+vjYsERGN1bTfoyAwyz5kISf/W8UfxopWj32sj8WsZkesi71v57NoXcyfimkQhUXkJEtG+Aw7D8mv/trZ4vqgaCRcr3WDA+rjS2z4XbSyogX/Ae9CHtVQ8c288Wvt69RCnyh1lWMuFWkEC+5OgIbCB12EN5tmt07yc+fGtkbkc+RhjgHts25PlsbQUfTyqZbZJUJGmvcvojLr07BvqPZj7gRWUFKDAfVvI5Q6IAANBBF4M0S85t2FfFxmvYNWkPcxgl5Oa8YNxRVb7mwDeMVUGOyR3pMJcD+ufTnbMjv3ClfLTsitdx6yI/cgfVz4FHHOW4WJWOUVYWAbxCqASTuniyCz1O7v66QgYYMXTMzg3xw0A3TSBIxT1njTZFWN4XcM+eg35GOkAGrQVqDOMMBYg16XUZubopaQf2M+WKURH3lvaHEgKaUlwTPeNBTn5i3DjoduVzu41HtIas22v2RhSrNGabQVXFzr0/C8o0jRSl6AQdokMILs4SVhhy09xkfMVHu+5wIovfGToSgI7Oh5UEeSU21JuUV0oQFjZAYlQSD1OX/0vAkFXWXkEUFM1o8suWJI/8K0m3hvs0UdcJ5Xk/TiiSFVi1pT5I2yFRrEPwnexzfet7iC5iN5FlqvaIK2aBj3xMyBkNmnFZL8cyptLGm3UMQZ6vLRt/heGYpTmFrYm3XeoM7Mfh9EsBTCMFWVoevLPLoRPILJNu9B1GI/G5wQW1LEgecnE80ZOWMpm76nq7MdCZyvL+kI4Q8/CPBYic2pP8aS4naxztKfRZbWZwu0Gu5Nbel8013wgzOZQSt8LLx4FUZshxh7Mk1xF1N2kibvUL9cjjeRDbMBMLBFPHbdkNQxDbr0ragTIyDeHGZmHCxHmiI6ImVBwNgqiGBwFvIIJSrZ6g2UYE3DVSTNOAQehWMknnamY2Huy6pnzNAlnnC7BTaMfxQ9RICf7E9IPMU6F9rvcC8IzOQ9u2zV7hndF8Rud6dxyt3TaZomXa2fmrrTJJ5p5f3CWcXbrBv6qAgBrzgVy+oW5qafHjK/b22TBUzMURzV1ztQ5X43hEaCK2xjStj6RvzsfpnH6pne24doiVLtGMVvrApXEKlRMsLpm0vYjwDsKU6K8z+Vcti6otvgLw/4h7qiZA/hmbQHqjoMsjL9XwEaeA/kGJqf0nws1HhTWmY34sCWI60kJVdo4qIWSBvcfbNxNHj28FoRCODEFnqyYLAuqnSS4w7s5kbmRhgOglqAVkrgw1HLb7Ehm7zumYaQIX/omDxi/BYVF1QrC7Z3TkjbkU2Cz6nazhNbRcMZ36SlAIhw96HaJTuZGenfdP9ypF18w0huQh8r6dbaRxbPKvSh2SnBDmOwaHWMEBU7OMd99yQiQhPc+aZ+L5Xn3vwemk6iNnicxIE89Q4oEkqRznBW7U2ZJgZ5ZUEXxEeCKKknIoseGG9xhO8mtullDUZfvq6EJJB/ojfh+rxy4wFm30V80AINKKr2c88DiX3npB++1iJUAmY/uhLymvrih6zJowmOYip65YWNzRTCHiteng/rbpar/04peXkK6thBUkLabLveDkVQKRzpMRbprqGqs7xFPHGqH3HNObDytgg0YE5TGkmVKGyn6UdpKeg0Ue6hP+C08goPxOhgfr3jalZi/P/0IF7GJM5KcGPnIXO94CqTXWouax0v+PoHCUaOAD/G5CFxiZpHyQKrB1DVpOGDmkD1Er66raz+pWSlLJ3fYQ7bGALerghiV5AMk10YnVQyt0s/dORKAQ/h6N12HjvXNVeIzz4M7vgBjaZgn2W/DQtmdn85Cnff472qpOhn4z9RKwY0iw3oQuDMTBgOZ4h1+a6u8NAdCtTIY3Hvx0IQzaivablFp4tnmi8WD7sHBFK/c37H1k+OYDhHkij861M1QPy7jrMRYdtvMojoyDJdgVzJ7MgSqX9WaRiJSMBOh3T7HC783OyEg7KNK8DX+VXgOrtgcQLxYfGEJ7uA5zHm7JKyB6qDF3juQf9Kt1gCgvCu9vqLQpNBAW4H30h6wGMvp+mn7QKjDIyzITH1iKTd9gSyx+tyubTBL6oBuS2RVoTvN35KRIKygU2g2OVgosikbsFv1pfK+/xNMkWIIm28WqRRXt3EYYfEK00CQd8RWUf+BhW/H0jhktXAbs/tEqvog9+Waa016buXylnydvh2Tgk8hC7M0KTYUw28iSNMy96iG8FaUd0inAlOmeq4p+GoMwfQQiLFL9QbXJVPbh83yeH72sjXjlTX8qu3A/t8WZjx6r4Gb1nNbiHwpUrHU/mrYcsY7X88vTA6dI/6LnrAN3ORbYIb0BWSJmkxPlIMrfgr7+hHM2qRlyo3OxhsI0X/QN6FBg2r1D9yqPMkdoQxqNliRYSAru9oKLggf6V75AiNHw0bGEBz4BSO630LPL/G1mQicKKcAgV5H90r+1UbKOdIj1cJ8lRwj7rRLuCOVDNB3aA5MB4KULo13lXpBBnQGAPzUtKTxIpMjJlMdE1NmORojQ6ERwuWo7PNL0Fb/BmfODOPa3CHe0XC7XXpQxCeqi1ZbnAzVdQk+q6K7LIQ6tFErSRHaG2uU2o5YKBWTuUMZ4Mg8mA4icxE3y0xPmwEtI9oNbrSSKHxSi7oCz7nIW76n8dYVyukmVa2UAXWCfHgxyVpnX3FvQXWxxtyiIQQayLzjtghuv57jqGRoSn1u3xbNemd9EDYn1zeLsy53fQvnFYTKmxTypLqbkqdPjUzbYAvDCNg6EbMIbWEgTu6l83TZ7RJwmcUKT/odzLkMaoEiVjHBKWLCF9X3H86L20QQbDnBMaPKSfQrMxpDB8qmh1VI1khhMNV1zEdg7PcIzB8Bj3gIODOTBtSvPwriCq1C7J/+FOjWeTTRoC7DxiqlNcklG/bs8PaDepe0bAIF/FIP9Ay+hvn2X0Bz6/PBluSW83S6HexA35sJyF6jv2aM89HYHTG0yZgK1rrmpuROynL+8+XoqPFYf0/GfL//THpbfZMZR7lg4V6lVTsYs6+NZqOE1YepdiiWYH+EW9GiG0GA8g4qyvX7FbATjJaOowiQJfz+agMhuq6dZHtDvCkrZ659otRhggOHor03NyO1SVlekxwONN3Tmw1KOqGGu3p7bI6MjCni6A8XLXQsdZpyDY5n4a/UYkEIz9y/0NyW2Dkks6lUgywf2kQZDLGTuqoxWCK30ZxZ5TLc+3K2+RvQGPwKLJzuAbbD1JasfdEb5azODNVpVYGs5G5lLA1kz+SvXFe9dFga9D4r2IUtPD2ZxIw+1ppRgD2Ctlfng8VdN4NScx+uk+zlbk5mtwfWYfAlbPTJzi4CUiIIqkdrMc3PCQZYotE1LlXHBBhrQbU8KhjJjfVC7UFrNQRznMa+RZDX0xc4h6+h9q4ebfBNoTZdG3NelNAdCA6JZKt2ppMjAWtb+QpDMggDeLKqoolQyM6eWgz374cJCCfa09IegNvHVdwZHShJaAklI0XXjaegRg2o2m2DisFlDs3xs41lUamhb5ejcr7bV0MyLrqTToGNTMj4d1mM1XLyMX01iAdyTzgpVsRRPlhmwilfeZk8cbRfKLpHzchmz/CIq2VcVdfpGkyK4ncuIMmiTRB9rixgj3jpahiSGpgT0baHjH1xn7AHrbqDMpYNjNFxSQo2gam3kV3EUGmaHDSZeoh78YX1mJ9oWqVKFmCSb7ByptcnV+pgOx4cIYM54IUWRVyvcqn8PlGjbbeTgU4RR8yJgQJimu3KT1BEJ6Jg0HLAK4bMksfO7qvR3E4z+97xjHysIX4K/KKAKEWISsQ+vSdVOxXiohCwxxL6WD4EQIsEQoYmDNE+ygTzjQLbSu0Ve2NkcHDC5dDwau5ts2WeGCpgQdyM33kPUGD/rLYVEYKR1H585HMFA1stapPHNDyyiW+W+fTXqyu4Ed+S+vv3Vzutg+VDeVBb8ZWwUkINB/AqagsgAMg2MJ1QrmjhLcjfS/2H436aAUR1B8+qJgVhRzxKEgrljqLItq009pOzZpkMsGN2L5IkqLkBEw7cwqacZ/AoThnAlVgTlX9TtBrpFJf4erLTEfmIYSDkNL6U5SdirhZxjm3MSXZRHsPWW/DvunL2XdS+MN85ZF7ZzXf8hgK+zDYjQOFbEKPvJoceeLxUTOeELCSM9qcR5PCOnnd2fXwRbm9QyhVrS5w41zpSHxrkQG1w/XBIv1J1NzKVmLrEkz8x7XKKu/qNTVuD/6c44azw16mXu/kQczetlVZYveCxC+dIkVgwGx0Ekc/GHAQxmiVM41ePDw7RirggHelbU9Nqcv1tj41ETNDwoKzmQmq59djt6k+BfTWMV/f29UlqYPQzJItMwenv98WJWAnmFFuqWxlMQN/UjmWUXVDxOhxXWNk1AYL2wgP7DGJViBv5o1GkxIwOF3vysimqy1Fh+dtbJm0QEqRUMOAvhCASSxYHcrOStc+iD/fqTKzOt2TaGbgAZA7MKaPzxVLVEup1+05CzGNcXPv4sOijKCxsueWSAxl9erL4TaUzMWTKghlEHgSfF8bO+jZXGorcAE48EvJMsbhfyWxR+j6YhLlCYhNiBgqwHf5OuqAsweEai9gUOqccqzcHd3V4yOl8Ufbmn0JBnHm7p9irN6INzLzaOuhfkZxXyyTzduUlZkQG7Omu74XP6KLTFREq4T8Dk/hT1m6RAprS+NdwPgELtIqnny276rWpp6Jq9aDwnQDMbfox3goyAahjNZ5l+1ZngHC5MKhUWWNSG7XdCTjvM31FRGBAXcdVrjLKKYGlf0d4oDiyvShevY5rFGYmIWLkBEA1dEKGXEEWtaPzGB82c/Mh0IWFkDIhPYGbIhAL4oevz10pg6shLowtIft0LM2K4wQnnC9ZmINYJ3C6L67ddVg2w6raEaC7ibcTLSm93lTnPA3qGQqac8Lw6OIra2yX3OOpByITS6AuRjABAqy2LokobYxA7XnSat9d0/wNdoTHNZ55Vz1vnsVcfApOOLlQhyHqaKqaofE39Rykj8K6ACC3uyKi3s0kC9W+Ng0r76vTzvA57wF3DB0h/FPHOp++zirqizg2v86Mx8mIU3EAEMGzXNEXg7t8P+esdXC4UDpbPze2DBEX+I+AKqgOs1/OH1vwx1LnH0cB9IY2Fv70d68YMsD7SL924b058eV3LlttkgiHf/RRXsI5jMZGh4i/SHwkomvayhqu03/i/RC6o//Jm1xTSfPM0PuXglrakvtaOr3y3uKwbMUBmyV9VNArFzM5JL+MRcOwhpPQX782j/np5fsRH5t0+gLam/DYyjYelrq02Afi6fH+9iGcYZ/K43+hMak5Lxk1RDVqRiHVni7/1rxydgL4Iqxd5mj4dNUVR3dLFQU28prVRgXyvy9qVAxzMFj1PzvjIeRAFhc1/npro+mW9YEr9AOpFUTjUnZjVmt/ZAfV/op4yjxxG6ikbESrvIMeIrgkRzuRTFIpYQYSZIEN1QIfb1FPCxFa73PXiPAMkMxL1iLbWvCOPSTfEgNkVkzU0SggSR2jZ2CtfZCR530sk4ZOfanzLdL3BUM1EvxzwU8WW69++tCZEZhoF+Q8zYYL9j7SLL5d3ImTUtG93KTEQSNHWE/cXMNyDbG2dUdicM8zMjlcqUCtGFA25AbQkNR9OsAchATD89IfnUwZruRxvKHepL+hI1cuznPlVY87DtT+ajtPHt6QfHeKHQjvel68sqpKjqIeTQuVjOfI9Zd84k1CFx6CVyXFiv9cduaLOeY4opKr9lPoihJzpyE3sSmL4rk3hav025G5wjcqSq7iuKyDyWw+VYsycFaBvjQ7SijM/vESTj4Zj4/vXo8PUMzQZkQqMvXYrdrH2qoj8GZIEwPAS0SPry+qrPIdc/qo+BYNwvvtLF0KxVed66Z33Bqvtbpq7nZks36Ec+86QOF/0/bjblg0PYNRyaKVxiCoIPjDuqsTIZAFYlIf8Ni/nW8QQNr8tONaap326llepKZ4m6urTzZZsr8G316msqxLQU+gFjND/U79/VbSc7TNOS5VTqCm4NOmUlDpMREYAf1WgVudTSA+7trSGzqJl8y2H3YIngDqItIjB4He1krBKMMwMlmuYJTwhwQv3FrScK5N1gJEbF8UnD4cu/Mf3t6BQzpdSACc5h5lBMvwj3aN25ueB9v591iyU/1OKdtJ8O8pEoSzJTkWxLtufcb9r/76iN45Sy/XEi6sjddzYpd0g+O0prnIWnLkOvhPgVO5l5TW/2JEH/MFumUSbFrpPn4pyFpf47jXEQRrQO7JoD/qfkpUoGh8Ot5WDhkWi3oH6LePuMriIWyMiiamuntvBzaq6nKQTPG5bUIkSUvnq/TgfNL/LM/7bhFWhAEvuOa3VJSRuFbqUDdLTCc1K63XwafqANPEpJJGfdEpRBpzBujyPVWE8iUiYLOG/111wNuXXWEqhUthvBD0VmBmNph2PJiZ5XsxO+OeCupjLMz3E+Bz2E0zGNEn1BCkU6JWFinRpDlgQEOdCFx/N9HR3AXn1Sq5y6qBywyWkoHkB6MUsh1rMPyr05ipLUSPdc90r2kmgQna5kIGVnT+4SfcZ4R9RDY3lugITk0uxMbHlrBrHJsYWBkvFQohwv1WGX9TPskeZaKLR5kiCkTwR6MaW13kxugaaOkMk+s1nsRK7PiLgsEj3NF1L0L/CNA4Kig/RArBjDNvx+zLt49C4CkQ9IPG1+KewOB0gJBllz174OlHba8qppyYMCLpcrg/tERBvhvQGLxLeGev7/hoGRvb1DXBg5kuaACuLw8C1ytamvN27JNv/e/e+yC3PLhBqqXUGXuNqCsLeOfW04QeTLAkA6Z1xEEp0vVaE0XvRqg/lOW4QdEeF2YQm10ZAjLZ5KYSdf4HThh53U9sGFlkX7XOCP/dNKfJNzlys7dwErZA30nGeGv7a3ZmDmk7rmLeuXEdus0ZqkHVpN5Hmhs1j9BQDS+YBvbJVrtcUna57Qe2bPnhQdNWYykwYGVxUBjXcmeZoCImnYTvVZCrBXea2g5M5GMTmBeEUcGZlCRpP1MJhMm4I1wSvfGZfw+zLb52Yng6f1imKkbs5s3NXZwezg5HxoutCFE66uaZKbDvxi3npjMeENxmMtuwkWoYIpEqUHKMrYVIh5DAhpqvQDoz5oO8WFc+Viudelfe8D5uPV+G+yNwdwmH4ev7/u1xwVJfF37GYgY3pPbVvDH8y7X9ZE45mSP6PIPYJ/Xl7kXli3OWuHpWPACwm4jKaQihz8t8pJk4rZwBabJNvhSle1MksIzp0nfq07+JC+gQthyEpVCwALwCPGsUUfV0EdSJM579G77L3CGTZYMZGQB32ewNIvSr0vGo3heHegQR8Ah+s4uDo/wHSPKo9DanQ9iFsFJX1vAHnYaodMMLNuaTXKq9Zrj5LuD+j1E7PXd03gvXUGyRXUiUkV41/yBpqtyd8iVZpvtYbDELC3sKikUdGK70wADrIgpIRQZZ9ANM77jbhPgpHh4Z42W4m1xaOkC5ui698ZaLvS7Yu3SR5eglLZAq4BeSd5nbOUdM577dbbP5kLU28niGpH05li00ja7MBf8R5rqacngeRLniaG/COfvsDn9F1bHzS1bOAkpstfP4Yq05Ca1GljOaxXX6d9+Ph4MVESf4Xo+Lma0a2TSOznU0AEu+DbAkxi0VpgDK+swNGYFUnNPoI3Dq1w+AGlDVE1i6qAl0gtZSeRr4zDcUx6CAuG7Jr3VoJfuYQyfIHCeUEVqbXDsh7i4CLbsEJ8D3jb6sZl1JXbLoXzNEDmre23aHk4YL+AfdWGDdsetcUxJm4WotvKg5T8WVl8XtKpNaK8CLHJhahl0ZnyeNVdjcm0UriWyjNRAhdH2mfgBePZF/QVl/EIBDQHAYlXzF8Sa/JRrxJIG43tF8Ug1fdARkygQ7GEGfkpwaCegTJsCKsowMrHhpTTGGNJgqZs8rJfek48XRdgavswFvp7qs/vYrpVfUx/aGLBGGZ1rVQeu2aWfedvQahzxBlDXS2MYm6iKiH8jp+UWhFV1UvSJNTlD+mFAHXEt8kMkSqeXcY9O+WjXZGWOo1MNw6DZMw9K50hcw1DKQuw3T/P6yEbAIDw11cXrbt3YqObUrfsFmyAti2lLeoJBA6qbOo+zvJWpT30Ny2FRk8K9fhO3gv+JXVkTKwoGNcbkd6QwV5JTQwEkGc5JU2CV8ZYX8GXpF/g4qyCVXKKcNPww88npNAU1zWL1Rk3srlzDzWTLOkwbn1Kl/KWQHE5SVj0lwVOIlXbDs3s8FYy7GlcFsvl1ceCvDIBxXGCyL4JVAVO8f+rYDQjlwBWDXf7Twal+iVJidMd+B3FMb6YfTXISTl9FW6vFe9cB9Pk/BQh368mtPB96Yvi/PXqx8n0Ydnuj9mSri5Q1st2ppV0FU5+LxBfX0i8h4ySKUb+8ea6sXg49yJUxaoyPWSTzRvr23B9myJi8XuY0WxoeWruB1VcOZzy5ABQ3iCfE2Qjc5y7HZDM5R/BcTyObFtQgdWnJhjPu2Kp4pngYdGSJB9/UtPpCisnoZCScWYK1hZUCzpsKpz3tmJHV3D6w6eiJ0JoHRUMNdCkYDkQjJtkK6WumUfRmmq9QjH0uT05NwmiBmmryyB4SF61/jPdd2GNNy8v+m/Idg+AlKDtU1BMsVvzT91IQsvjhe2H2dbFDe96RRpeGkgIQF6f+rzbxw3KUxWMLkvBoJr0K9wZYT6b8S+3pypkm8IjERvk08QtiPkv3BHfo/kzWsMSy3fKivCVBKH8OF32aXjDdXuz437RjqzYLlL5TwVIHEVxJg9oIPwbb6QKDwDP1yPu9OZFzrrluo8BeJ8lL5Q4ml/3V4EvhFh8x+ShxWXo1ga3jq/zmXq5LN99g312JP47hcDMdQ/BxGVJacpxKk/dskX8ZRKvjcoayXk1mJ36e6icAPLke2n2xUKc76jTnQZjV6vPEsEV2mCAJqoaseLjPkrwzzwHmfKY8CtSvs8QMk249/IsrKNzOh6MsTdSiUcLRpdjqVQVPebGvZh7NtPdgh/XTQP/+wsvUE7rOgC7ajuGmaHk+wCCr5OpHOdVVpNl7EoZBTuCk0lvrCiObsVjXEwJGr9pa5qsXOUFonKuH62gZ2flXgWrIGIlNlpTXHmBjV7s26PZPVPWAL05iD651fMwC1Gi9EWzTNXUCHgPBoRNcOMItMYq2wXdH8CQ+iqI0JdIgU1qyb7bUVs2Cfpis799UhPjJbcEzcfygCCucfSobJaVbBunsdZIUJ/kttBdkBNK6vz4i9SHx+UwojIYXWcyn1rH39/F8muB60uwwwbwt+W+1FLY+WhaNdzZslL9mSLhzFlxQkphyo6Ck6LgXJAF2O6zHTfsMlvOklhxCxqfuhHZUxanztASvVHTZyTWevFaVXkZ6m1r/sZkbdVol7/IWr1DMGez5sumFPeNHdXcEBWCzgerftO6wr1865jCKM9cnv8cSSCE5jgJ2LNS46fGM2mBaI1NOOyD0PiC3E0OcXJ+Xrldc+h29ni51vW+/I+F7JmUM+nOU0rKKPP/M5S1Ku95r0XgM7/YONCCYYeDNnzMUMU5qZI9b2dtJkdLTUYl1jr3QSsE+EMK89luH5u4pyosZz2jEu0ouMWnRfiN8idKAQCdJPYbGxpUSVd4oPvBlLhJzX4wavsHYNnctihyaE7stxi1TYU8QroEMzzlnMrF/e25295XyyWr+DAxbEjEtIkgtsGGay6/8nvboP85F0YPY1MJqF6IZUGtaWfYSJfBFyOTN5s5Fz2k5h+1qMy7MRAvQKve3+d8/RxMP4zADCjKSw/iH8G7YyyJNoNkDm1XBSFR8G34YKebU11wBL9eW05PJ/4PcqEOVIEbeXL2dynrFTHrdi5wPJ1lL5YPHUQeuac0O7XjM9TO3uA1tzzY0vXpvVOIabq+BEJAzLNf4q0DVbCpeViTdSx/zVDjIUNIxDSxNTy5dr4tweROG7aZUQWS6hJsRIW/zICSwA0xkrjY5knhQy7pwSQqd+TMcv4vkKvADu0Qczlp7hSNDbPIN5qJCifynIvP4Qq5FVzkHS93LafIPahtnfmi+wcbVPWgJi28YgIE73Rbjf6w4xQ83suGKZJ8CvwFoxIRLDYH2l70tPJQkOJuX//WLQ2e65kzg8q/gEKj6JLtRzktjXrsn/dkHQZB/MHZ9mSaQgU4hFU70453qlXDLZnDxudiRKDHtGnEGCAEGCTrNGnuHHXWmwidriZx0Ti8Em4SMd8YWOjwIi+545c7bm0w9e15JtCuCacgZOiA8nWEI/uRgC4eIc4HFgs7EGyr3Tj6/Yq3fFsc/PXmL3gGVocuWo5m/CeeAnj86VXneTzOw3V6JYAJHorSStvvESLiDCq6RSczM0oMouv2tNkfi5C5h7twaVtBqTRPfG9VhgJf6fEscn7txMX0E5xbc8ha1hzeod1pwKAEKEC0DmlNDiXlei09VONhJxytij15uvzoeKQJoDGRruPptPOomNIFAcYEs640NA7BDlMV3YbIogQdGuRjqpTu2NkC/jUglsO2XREuA8Soie4XXVvwQIEq1YI93Y3KLiNk7pJdt8WTxOjJZrFeWry7BSPdSSuPLet60b/ZRZaotICb/SFk0nHRHly/4Ew5aNXTnl83aeuuV76BXR0bWkSfrJ2S1uqYzv1Sbm1w4SAktDWgwxTMw+/c8JNuwJX9/sYeQNxx/SMPBEjuiJbVYwOI0bQo/aR4bKeXG8+mnJ+9+n/WLExoZB6U6RZhJrqCjnzOEC6oTiQNua9E+ZC7hYDaw7FQDhrGwJqJ3zf9YHEQszVdkkOpDNW6zSVl1mOBWgQvvCxGl/v1JuyIfBZ6QT9MQVwa8zqvxvdRGCU0Bs/bdulWBxOXFBOQ0iuWAiDRY7VdyTDS1A5b38qT074QK/dpKco2+KfvoF6Ge5mGPrloT647ukH8WGTDUq9pJfwD2jc/kNxzHHRejfu2Ah7h4Q9y0MiUXlR18jjm7rGsZAyttliW81E6bAW1SK8rsNIruglY/iTiZH6x+Zh9k7FQz/pgTBS0KTlH4j/1+LFWkR+H2fvjDVfRMY4Wf0vZaRXxG+hTCzjQzYn/dtU9O7a+3WDXpqm4dIw5MeRzMM9Wqd51dE0PfGmnYUJfrnEF53KsKyoqYEb3SY/SYRkVVO7drQT35CkuyuB/dcm3K8/nOuDRYNw5OKvR3E/EqL1wVg4BsNRe1N71ncLCg/hW8chdm+R4VVYVRbMIEuub9MvjNKh83YdnThOBOu588dnAuWfgGQw8f6WaPXw7Ktgk/TIc63Rbz/ZvsJL2uqKn2tgQMaZpf7S77pFmsrZxDCund0Y0wRQSvlBXjMKzsBhGZoxTzR6KA/Rq4SjtUg1CxMnfVoosZA5t25420+qXGQxZSx4XDgaFRPodc5NKQ3l0OTu2uA8zAvEaSsuLtYivhb/LAckjbotfh5v3b8B3dcHygxVRdBGDT01OdeYj8w+pJo/9V6tsc+JOSoaVaDYcyd96hibwU5Mozx7aWJycYuks3olTMlgxZpiv4RZikVmcMgbn1DdCyR7HMtjv3KgPOF0FxmN/7ZDGr77Vu7tFBJMRyYL3sM1ugXrAZz49mD2vmjuRb7Gi4+arPD+vv/6qMcpvP+j90Q2PcRnKCbYAb2jPbRCMuEP5BqvgsQpqd7ZAZ2/mq/MAt/+9irxLz9WOfOHion3sNzE592q8ScurFR1akTn9U5nep7jnZE4xr5zoWebx30J2ATo8LCS0DExHR/jsdV6gTQety6d988LVA1++7XG+iHubxeh2LHL7oOV/sH/IwySh2fnju/vJAKpgmOIV4zh1j11+Hw3OSgwmwoLHSALttTb24aA8FISy9rZpAR3EV1F8PKFFMJQbyr7Euwlv1y4wEolvNVCgL8EPi15zCW1oH9ztKSlzaJvAfYMR+uyMgWHghjIcRq1w70oIsKd/yLyPnYePxBW+ZWicwY8eUP7NEBy3qqGlFPlYntd4Pj/AaIB8uwxROJqGhA/GkfR5qtToClRNo5mZLpHyi1lGD9A33m/md+Drber1DIbNBght7gPaWrG3IZoDp571puzmBs3ycYMT55zN3mYITcmLHSdW1XWtK+DiCqZs65tqnqMFz9OflsiprIlQqNn5IY1iAXsTNuR+oOSmvMZSm24uI449lOLq366Hu982IOaqJmLj9XE5IxfFu3Fbmx3nYEpzWXjijfx48BctD8nPM2QCisGZu6ldDJLI65p5zH1AR/uYkENTSnHH1iIDjWLXt5ivIfOl23TP/dyGE770jra99AYpoE3iT7t4xZDGvaKO+pit31791IZ8MpSdtO6z6FsoWCs6N3c1CoSogIblmxovhPL3vdJJjRmdqn4I0tifUpXOBAcgeIdFgF72H7ZplUFnqRLnmx6BfGsJqaOwJCZsgO9BsSWkqbl19THkXm4xfpS4k9j49PA2kuVfVaV95u375BUO8isyGwp+TUFWo4FvF2h0PRUMWe0N/c4ezolvrd6wu9Atx4oS1SSLxKxAuO0exx01jti+OUpYcZ+BYnIi45xFkc2554miQgeYKGiQsBn12HFvAkVG2do55zbDqpcfbt6XwPW7a6NdfrWcTXx995FfKrY5QLPhjGOcmYMmYkPz+hpNkhl9v/MJ0kdvdueBKhtkYzbfygUJgzI0uUqXWS96LWR/EsU8H72xkRfcqmKSbMWaQyefdeo2Ve9kdJTrsBceM51z+4U316msBuMYuRKifPOrBZZ/vdQPvvZLqHnXF/Id4yhpbX5c8M5aQbEM88CMofTvpstbLV5JCbj223GsTvXS3G7XtN1pbfggg+97XtHh4dEZlN+P2Ggs0KOpMdgQpj76XyURlwiy4Mv9zJm2aMZStjmJFQmtSnn1HSr7TxQfYzrs5/cSuCkD5/uDerwKnVjR99xEcKzHrPt9dF8f0/9RQBK6li2VidWts+8cpcJgRfSBMFuLJuTnmEAS53VrTR4COn0ARhcxKhDzLJgkBpnHD1D8k9B0Pmyt9BMyxfz/hMW7D4auS5iHKpC87mGWU5e0PV63HiL1VptF7WtAbCxVIno9ZlOUsFQLF+u2uxawE1u1QQ/H66vLbKx0cEuplwy5bWz4cRgWYMsxsspGoFBGoPxnQczQx8/640CFJWBnyj1auMh8Xvve5ucgix7EiybWT/ObtjUtcsAq8ILtNBxSoJ+D6l38/QrRHMmrqIattLhJGy/7UmEdlGP0PezrJNtnKvA6xiSr2iD7M3iEKKHUQgnFbcTAgjFrZ68MJJ13VpFOQPLXlaw3QbRc+WK2DeyM3wW+Hbl53KG7EbRx8VisZp811/oNB4urqLYWGiQkVezpjt271scEZDq3bpqM0GRQnRMG6qugcaJryNVr9zKUQKcfzxk2f+znSTLIBO1tPpuFS/yRFc6eDxPMy1KpmmGexq1shNBkB0AtikJHL9NhTnw6aKtNUh6/Mo2Kl8Nn3WOTMqiPIQ3GOw++iPSbzPWfy59SR9zSBdJ6LIRldiz0JsoG0uFNjfXhU5KpwXZq15dQDRBFRfIpie94KPZUABKo6Azg7Z6ZtUYOgpeRKZYGNdzDj+7CdTXhtrnaBtl+lCe4HQlpJCuH5ifAJqrtJvEZ5LcicpigFHiaT7AI5pRIRKLHzlAk4S0e7iywARi0KqrMwmLqLDE2qDXIfRGl8yS1TTAkxVSpJA2971hvsnYpK6Dj8DqSwvWPJQb/16ig2L7IaEE48Q/b2wMqVMZTn/G8mXLc9yY4hzHsl8h721X8z+8IcgfCeSp5agu2ZvHFRdILnJcrOQy1k/Er00liZZHECY6DP7q1nL3bO6qDfFPUM303KU0W/tiVkT3YhvkVA7WJDusHXGoZzodN56SBFpuwI/u/1KETdGDhyV5z4mGdHb73tIXz5+YN30heLnc/Hs2rYKbOQIlDBU/xpbqlJ91UCV/1dMujHYNB27TZZo+wSFL5twRAZR577/MXGlY3Bto9tgencNSxJPrkNPp4eFbHCOF5ToE8kpaC2bGy8kVuQbevETToohkySMXlaeOAC/AgmndvarbFMY+0M04touIkmlGY6TtUYYHpNLFkJtSGRBQcaLScGqI4HpHhmBb02JRaDlMUgW3lOow/4vALuZ2MZgG/W6ltXNS/izG5zt+hCI9OGJVHuvF6qgkIILcUKoJQn0Ux4M8qPHksoOknlygLiLr5gmwgJe6MYzONYAknhX7JJC2FTvBqrXNiNKqd8GOX0+h+xxBFXCM0UpD1ko6lRwCLLWHIMObsHmODm2IYXx19UjkjkNvyKzQkB8MLkhvylEMkEm5JK0D0vKdEPSdUfZyTZLvoLIDgz7q5kBUp6pQEiXQ4sZW6fdx3GqLiHlj7nYGNCuq3sHsfcmjFT1RZsAaQPZxBotIdQ7lTCH6yC9pV2lFqCZoOLAlC1no1Z04TNH19MN9kbGPls1Stde9efYdhxcTLKULUfvB7CtmJtDopp3NWQ8K7YSzhNgnm2VycAYJzWRxr4Uv4Xc9PkpJiWmolmRNB9nXxMinnUzbYEIAcHYeFAhRBh8mKOybcSbWWEnOMrqDRGSzNDYwL3uhsJtm2IJhrfIc7gg+YqzFyM2iTIj5fdjb9J0N2e/Kxa4wnHNI6DmTG/Z3/UJ9bG14ydAbLrJhzuOaSfGd5jh73/gltlUx86Xf/gD7iBR2n0xbTT8uyggnCRXWIamJq6LEDN6peI/yskdWq1zBhrsWZsYLvPD5BzbCyPVE85RXNjKIUPB8y7P77a9fl5QAGit5Xwy8HPNJ/mMNCt2H45yhp/eh5uL8M3LHUxnNyUWOoYJ5Q9WJnm7Ydm/vuEhe+vMsZGHdstBRA+75S293/gDaWaDkejqTNgkJGUPNmfcYbRkAGTJHET7ByMQ51YbcFO3Thd/nhsrvfTS7V/QEg8WKxVdKI0/lCimUFNpnl6Bf/v0pARIoka6wuKTR1/Wj/bwB9acsrGzsm2WbwlJWL8Na8PCdeSGsXMBsNY9+S73ayhTvMYP/dI2bQqC1sRr/dRvTGc7SzLfn/6CQegrKh5C7cWewpE/rsVi7NZtN4KSRn+hZ6Hxvc1/8CNtH4ZOXvnbb+sOFK76PS/3byoiY7Kc6ua/+B5WBYvClPSNazfbIeRc9aGLzK7cURRgHeRIhPO6aNATkRxtuhNKWfD677znt4XsVo2Mv+zpoO9CTp/usQi4VK+D9+iwat6sqTRvMkfURAoJ+E/X6ajNMLKeeMSl/7HkRvsuF7RzPuC07BkRhoSXHcKPZYq0PkrzBL0G3DbDx7cIdXBItSwzqtntKc6xN3LSc4c5U9xjLMehLFcFZBrIcqgSkj0o7hOsiItusPz5ls2DPvUTIe4p3soUDANvOSUl3XN7iact3TAMP6UkJg+bqI2c1iew/mu74SU1g06ztOKCZUFa1gBPUHj0hyqtE0o+0MAUkRYejPhGq7tOlw04sG7s3P3D3dlWJBcdPLshfSXth/ICNYp1ntKl5rY0jyBSfK5LHTO0VF+YFJl49EHIMgS8fUOJ+U4yMbHApqJwSBe5bS2Uh9GmZva3zcRw5oCuCLGGKx+cLtjWnv+UeeK2KRl5Vi7QFgRa5fi/yWihKpeY35sxOWyWKNLfl2TYzByTfToAwum8o4c4+Boq0zV0YK3dKApf0zJUuWjhTfp5ncMQXjkMHH0arRLpe8dkklvWbMhkKgbbGXbPCV2K1Kb3ivKhLK3qVb1Dy72cSh2yGb2Gm4UxGlDx1tuWKPs74qYRU82oGrA9+ad2mUQCIDi3PlAO4iWLTZ9OaSDOkLdyumpuOJeqLtWNrAg7IXrytQKOw8VggDYX8qjI0q3hWBH2uKMi8Qhy1aHst65TammBdGAtQLk5OaQ3W8yKnBT/rzz+0a637RI51jL116jBwstX+01BslIew9gFP4jfn/8LVEnQ9aMHNrOFxup+2ZX3EM8FzY43CYnY7zREVwZWSDjFNgt+pwMX96+eEsmH5Nkpp8WO48KaxoYhZk64dgqZybLURNsvFIeTW+vpLqcsqmm1FDOzeGGimm7RFGnKUiwI35vZEl+t3eBa+JqE+U+BoteGvRG/VGq3g2hYak+BPIv2p63CD4MGSt0S2m9hnfP19LunJzATj8fJk0vtABUMNAA3WeJBIbb3+CwwCYvnAiKDQMe7h0VCT4iKvM/digzvN+v08QO9KoJ4E7TWXdB0ZZwzACtfrFWVf/16qhCXMYTSDlaSH/U/uv5LXFioQI0Ynq8F5zOXgmY4yvkYskCdMmp3z2iEY6H5s+T6rnnB1Yh8gKWswF71ysXwJWPDFOlpYXcxekLeCmX6zHQ05a9XNLdxjqzSESyR3/7RRUHlQSwlxjZkp5uOH2vKWTqDEmKd4TBs4erfshw4wudfxeo/qWVQ4D7c51T/d+C/5IgUoYX2ZbJ25Y//9CrlOdpwTTD9b2ESE6nLQNEYl4gVTV6x2evmlewZYGQjdw8rUV6qj5mSm2Z2w1o/aLLVyzcBTw3lHVAPt2yLuvmG+z2vElyTSmPlzS9xSd4N3sKNvUaBg5RKeOwp5iWb6FjF22ysdorR6MKuAzNIPl1ujHwjVSfaCu71AlAkgLuNssdxqdrX39fcKFWhNH9C9gmYeIP4rvvpgmJEXDPIH+9F1/tEeLJd4wS2gNjVkpyrk3DodkyXYyiqAIV4W06LKOWH05hMBmgwHbHAVMKmnVMEZkfxuRvaMz4P2BZ9dRxEfH7pkTTA0dfXUEEIdFEo+0hZuHd8uQ8nSJOxlJtukeJwRbV0i0Dp74+5LKnMaaWUbVDl2m11KMSmk/G2Rd4bO2WeQpAVvClv1EDUARHPwjahAtfi5CLRAESVsSH0aRY5EcNVHRamQVN06AsAWK0XEAxVLjdpeO43NCbFmKQrK9ogGPkYWYV+GKCsRZZnMW+CfJs/gx280fQH6Tkbz++JPzhUX3a4Phkhuyq3LGRPSJd00Kb47yaNhJgn8nGxxPS1UOhMhn4a5RlKGc08xcdZZaaASciErqI+JMh6xHf/XyDvCdSpnLodiROGRo5gWoHIvTDh3igyw1fSjJPbinDP2XYI2AQg1GtPg5XGkbpVMo6esMQMcg/gugwF0ro9TT4BNkFt4UAbyrwxgYmFprbn4L4sczDqmAHqp658emev/7YMIhjoP7dj5ERtAMesHIGnAIdDVu1lxWUC/gn+9Or0sKICUjU5RexEvgqVBUPdRvqzZbO74wGsbYiGkajBETEotvyYANd6z5r9EV0yYry3QUQUbsU8DrDsYdZ+gp+YMuP9ftM8SnTH46Ai8xqlK+MpMD/62X1qvCDw9TENNQHMh0S3UhnVxxlD3kgky85cH9PeSsaS+GjBpTXHZqxsUNe5QB7QusM9TiuUCo3qY18HnKmY2FJkyrP+FtKlBR0l2P1qMa18RNFbABfI72P5qilHWzlnx+kI6Ewk3tpw6yp1phj3jpEky8EKSAgtBDxm03thNgWzdOPOOPAFtIul2W4wT/DmJXMbH2Ib3rklWDQ+aa/0vPNmfVYL3+wRBHHUJ/X6EmXZj6O1UItXZkV5AATRajYLHm0HgmKCPycS2qempBS6fT8zu3kLlUj3Rlc+ilNceMaj+O5sCnyQwWA1tJ6dT6YkVcnnpzAQtA/5EGmUvBtyh270wPJs1zQxU1U2C3huUd2TX5Fcx2xClbCdn4ljEJ97u0h0UWcQ0lF6gBxO8WWkgwAgI8ZGaWKvAtCNzUntv9Lg38lpYEYcHABixzS2PSmvkepx5Wf6gDySyhBobLGcpRtY0U9CRcXmxE1IkAIGSCCph8rC9AtaDVdR1+tn5zjlpAnIHo8URxr25cdyJBn9JfKOtNbAvJx6da1mAsyHVd4na5qODi3LmII/AJJ84kxQm7ZPURw7m7mreUcGu6gZrP++rBqk72g9JaGdYqleqo/afazs8qdn1ltCO1Yi2HPS6nVkQhDMHyXv8UC+TCWLupVJrqACEvHOu3A+/IHRzVSqH2lWALxp/iFXEA0vI4ZMmH7zYejKRpQAo51dRcwSLmMNmTvHrqxKBRub1/q8pk8ArMgYQudMvMCISRc3JrBLUaXNvQsMJCDOFC57VrBBSrRv8IjG3yQ/TFTBIYq3NTNCHsM+RK5AxxL60Sx/3cvP/W8k4CyZTmgmCWcJPcb33YaL3z6wGTzBLvd1FPX1IGR5gWNG2qu7lxuhDj3YvhM/P0fPm7da1XBY3iRsP5+iAM5OpbYPUvhrkCxslKDNaboeyKIiH4tQYyNTeHJhsA4uPKusffesbIrT23f+4l+kMJxfqgeQdYsVAfKwBH9vWP8Qi3irHq4zVI17NbC2fjkgtRK9BO70XtbPZ94w+ogwv6jd3C9tEJAiJ1j0MdauOvdNN8UFqw97OJ0alXtPepJDCl23bTbUl/FEYF0gznc4TZ8LB1BsEHJFzo67F4XvmeLNT+NgVq9Z91RASHPGaNz4ebainfS97FK5/PDE67AhbNubjj+ULQYG7lK+B4I4awp74ak6n37Vy6R/7Q1Vjyo53iwAu2VA/zNZZsvlRspmkI+0QFBeXMoYExvzAB5qo0Dx8wq+h681OP3uRIcPZlD/tgRhxV9r8fITPWgMW1h8l2F8U3RJuvz+9j1zSeOHJmXpJQq94tFNTo+6w924zU9WyWj2srAbu55grGVmcFCYSYvoO4IHcJBivaud2BkpHr8KOD4+IsjxYWK0gyWjmlxYTToVctd0kdrTGRKOBErW3thfrm0hr0KUDeAicM2H+gcav0gz/kqwmu2aHMNY3F4+V7rzHxgz+3si/hVeD4GiRDtHl8r4gZAMZDYHenbeV9hMQ+O9BNwkNeXKCzq4j6Wzyco+rDGrlj+UXuTkGPXH5/6QiGWRkShY1qvbSzPT4NtgXF7WAhTYQ7mdeKNpHEXyk5WvLbf97CNxb6SDDGjM7OsuSyrRcCexu1YJDEdwUTVdNbtG7OmiSvuDj59RPpjtrPpIvm6prL/zWkkDXWf7jkykjytL1zUlRRL0wuxumCb61muBkRyENZbDFtRjzvJ+JLvTej95lTj5lMNeDtR1sCeqDh2r1SR1n0aZacEwWUCRRoIONZTMnnCxqPu1TFySyMkB2NXjNDcExgYfQONivgcW1GOuY93O1KZ2P13x3DNdmGkvvHoH1AjEJevaTPUuk7KgKj+0yqKcPwZX53O1gnvRfXVJKoYnSYUBuqLi9UG4FMFirCm9G/5G6Fr1+BdsHpzxW7+cxqsZK732cSt4be7sDqrOaSS35VJrUBpdsGxYAkC0fkhBzNV8GoQw3I95oOKPpxc+VB2Pco3JUWv5m/z7tGU2TuSo7DI31tngzTDt8DTqYZgrbHjTO0XuXUS2tWjATdTMTkybB0pPQq2eV972va4I7rmKn0IgeQ/G2YSuYkS2KBTQDukLbCbQDOMasayQSamxVhLXERv4x3KvDbanqvdW0F8ATN7VVO3/CRyVSov0gIGJi7v9ARQUxwvCyuoE9HmmJZsxsC7/ePYy/J4VjwTHLjaciRUznhtLKe/MBm8SmKv/JnbZfUS6ErKGl7X2s3A6W04rwJKLvsAxH+mVBVQfFb+zKUM4N7RuslAfTxqrc7LYlf9WaoPIH4g70rzfnXg9auNEpM69edwVJTCABf0uYOhNwTffPsRpsTV18mKUw9g9YEtZCz81oGyU8KJ9E6WSzcRLtH8sv25m7Vw11k3GNw7xGyWhIyXJXIWXyykzJQ9dK6586Kn+It1PJ20d5hCqcd+ZDJ9/1LeZKmt2H0lTPaY/UDL2cyIVQHokinQM02kYSfY730VbbQD4gFsxiGQSKEJO+A2Q81TmVxjqIF5J/KCCVX8SgNjw4KY/Z7JTk1/poV8CIwUJoZmRKWvqjFUNnyxX1XaJXHBp76fBzYQaGmyhJS5K4JFK13Z+ZvcyNheQprPUi2tyMF6WPnFRZrqC6DCF2YwhjQSNt7qyGowf37gtjKuIKnANcN5crnDkV9BcQstmp2Gr+vcrbR5CHKSHeEo+hK8SIpuEUoCkbO8xZPBmLv5jL7uWCa8agCfRd9dkdhrEgQHgaH/Tkkfn8TXHpKdV82Py9Jqp4wLIU6/BqkBcLTYk+qLJC2ctJamZ18uuguBSnnaWmy1dVP1p2ueemynvuVf77m8hsGpadrD4EPiNaS1cwaOKgkp3byulQP/5cA2BFRBdmGzFOzOHWstnPbcg+wPqR0BsOZIoqBIEddGRLI9ZRnSwzvs3hnhc/pSOsaVtpISRfmGhmfjTMcjsjPX7RqrOhhIQhjCRDYwHZUvy2X3JOyB0elt+g01MRAL2snVdQXnKAlKdg0LlfC4sIWT89TybpBVrXTQndoKaNeiGWgm1pH3OlJqP1u/zqPy9Dhzw4EgXm+e+MfM4Ln9Ro0WyXlAXWsnsrtSMomdqSaiWXZ3I0zlmqhAK/Qr56tE7e7svk7rahU8vsL86DaUTmQBKPl5CJBPYb55oVJA3xcZuyL1gqDHa9X/7dV2tKwRR52CJ4EujxvWTtZspK30pl+Gr5zKzbxKBZYULGDeq1Oi2R3Lpx3PPm/qKCxgowwIGEMS4BOZSTjsxMKMy+jbCR8o4sOwlNPAuuuZ6Jb35xMrU81xmP1gRuMZ4KzmKKumUi0psonz7Bt+YH4U56MgI+QhPwfrzwNhTXTSHhJP5Hkv8PumIgnIOxR6BpwbrTelyKXNTv1OspprECmbk4fs/ywg2tInxPXiy8OHPsGB3R4M1ZR4LnRIXBVTqkqsEEZS8POJQ/3niSsb/DYu7cWeA1k+HRDdhB9mMpUjFI/UIlI/M0jKpxo5gYd5pLo+oK03r4y3kVoHp364Yi7LjaLa0oNx5yBTwhh5TPxIHatFcHdqmV6+w6GhUt0pr+zs//JsGKOHvKgj4Lx8b+epUHeGrt/o69c+Jkfe2qQT4LEB72qyhMrc6PfD1gf1C3ypsY7nSHCP1jJQc2jW3ZKtI1xFM3zw3xzRhZMA4BTpTs4x1zo5FVHyW58XkkK3Kdc1JfkXyhqb4yoFpePDPU5xAG/oeicNoSL/mIzkizOBt1exgL92y6IIxUs1/sm9vqjUciz5xEZL0kZHoLXph888Lh/TlbPpiOsdHSk+EfQWWhd1tIrUcK2h8/p3HalAHLzXZ3j6LMkeO/9ImByiIrdW2hB0hqNCE7F3Hi8ILmDVwbD64KkIoshbewK0NyIAn27DTAa5n7mVAdA5zwY+Sb3eo0uEqxogv4bOuJrcUhhp7aIvkLK5h2EZuTo+YjRRNC0N2sSHCQqeddhMb8YrKww/4tGnzPB+VKsHCYFgrJnlpcVDMY1/tvTNFsk7IfRpR7YRF+mUcCiMhZTYUZtj3Bie7NnfSJtnNWLMVp2jDo96X7R9ujwf2TVfzJwDSjuO27qgYZwkNwu710xJsgPzB4YUhFsffRsKfrvLo04eUsPUPWtZ77pHJOBYO8ulRpgWtJTMHvfAg6E4kvAwBxu6rgY0afaSC1UrE0K275ce3UT8mYNVO0rMEFYjG6Ez9CkzeUEk4I8ecL8dejzDy2jI5Ax6leEA67LNlGo+2i2F3oxBbXIOE6oQjwkCtZQu+7pgVVfGux5AhihhXAw5pVI4gSiTaIfrPANLBOmiX19hCbz8yfu2EPzVPd9sOnVi6ihgRbAK0YYs0tB6Uff6lV1MVzViROFpKQBc2ZeHelhjESukjFoN4tdmEOi+ubgkvWG3j60DaDlJEVQWr/IM51UhGjj688i0A79l75brCneGfCeM29ES3tUJCwobC/+CJe+7AD+FXv29naxp8GYcTmyoig1LPGUBfYrYkMSqrpN+RAUHuebhP/2clOWzoFmKLlmppvKBgL0Rub9tbMjIuD6/4zQLl3iKW3ke9KP7AzwQdgXHqGSnjJ1Ws2w3tLXsKNMdn1E2kWi/b4ViegpiWAcWQY5QW/E5nhkSKgnHFmsAE9PsUF7NH3sHbFYnaERuHTXjJAmxAgK+eoUlcmGmmIRLjNAyBirafxjg+6LRTc1ptl2oRMZ+1g2+sRx5T8HSkFvF1E2FaCTtFHY51pqRz3iN0YFVLZpOq4McLc6pFO3ILMK0J9QGVbsW8Diads4LtRWKZ3R2CubiQj9sCtH6b65Pw4Xq2CoXxeJvr2P+qMBpgOpjj3qwA4mUmnoRGCgGVp19kJgcwEkniL5xb/yOxQ7krSY8uR8QWupC4SFmgeSVYrlqQP2+5cBIVAbIDsrtWFPn68VV9Z92MfPitm+YuACmeTsrOzGfmw4MdHBTYuXNC5sR6Hag5o1dpjKs/WHljkpi2t2B+lCBXDDkDXY8K22Ow1mruSht95RiEl0EuZy8IPX1I9prgESJi0YEE49s0rZoFYkdfKzSgC2p32vt/HU1pfXXIDK9dGBX/ffFguI9OG8fqyD1hZZ4zMiBGdoDt8Jl+pHS6fwwoGAMC2dPcv2RklP6WGurn7MYMPRCuOcXoDR64zLmlaHmOiVwXuoyrB9Q1sE01p6b2BjCaHusQAwc8zfcUx5csf4tPhyBTIGklTiYZPCoOoojyQ9+4s2gY7To4ZvdcXLNGcvoxNRC7kx1AqLlhTw43MoLEiaXP+3QIWEZjXnL/PoMmwW0giHwx+7Jl7QKzW14dg0OLKOzIpoyu+wXz5R0S7oQaz4r6fSOX7aseQOOlXptXVdgNJFu6p1yEG72q59tnv6dn0k/xvC8LXjHsSwZqIa0dmw8KVVcv9u1Rv2YC8II7nHddHCPWGTdf1Io6AoyzdUz5y3ulNjj9uAY5hH8Y4o51ylQuqfwivr6UVhHZhM4rZqYdSvkrN9V5M+OHgUx08z6RCm8+GUP3IUs0it8uqmD4dk0Be6MkmNekdC16zylat92exjTgJVMi4IzbgfDEn7T8hCcFnW7eOTU6xssiA64edh8z2MZs1B6bBdPT/zxpDW1NzfKzC1NjuobjcTHCVARie9gT7dpbqRIhiXMPrBH7dUgO/eSmFMlnihnYeX2jPdDcXzdqEYAHCehmnSoyDbFo/XaWw8ME6GWaGPWmKCH/RKGBSjAnS9UHdJ0vausPDEfH9KkNgveVgB3RjKky1P95FgoNmr1NZBWYgva58KI/HRPlaBkBoiudYPd65Tv7a9TuXSaHdaHYA4tnOVGE2w7vnm4Ix774w6iVuaYk9jfjtVq/8sA10t6aS171EpdEWfm4j9sqFYY39h8hOngqKpOKLElae/S1p2V3F8EaRBRBXvRo955F+2sohY0a+XdNg8aD+pzzxnTbejGTmO8Y4Gjw0HCu3nFHoYmSjFjYHT436DXVoJmslKEkKgA/WrkyA2guEWuuLLkFpIUU6AKAxCf4cyeVyQJi25F0wFowrXvcU1LFLX57fknjMmM3PS2QoXHwacr1+Jw16FqV2u+ExCrT/4zM9L0lq3pVWOeu+75E5A+VEbmUFI0Ti5zWR98dRNbQkGCpcHh/EZslOPWsdcWA9yyH38GJLhl3G/KP4BxkkLQaMurXDCjEsTTCeg2rWhLTv8izXQ7pyZmxuR2XLzUrdPdtRa34rF7HPzzc5iYe90MHsp7rNC8XMtFlCcVe2H3L+CxQVWslKQXpAVPFpnFhl3YweIqADAfylAcE7zHExdTHTz8nCivTvOAWVQY1jERaXkf6I7Ixp8SBKuE4EonV4iZxRt+L7C5F/4+RT065cgAVOOXE3LHPGIutIZ+DzmmioHpYieKx4zi5uemvKxkd66gmd0EgIvFsXxLflS1R+h2ZECMoK/a4DuAZxhEDU2YnsY2IwFa65xAwRgk4U0ybceIjd+aqifaPri3SbUozmpHC36DCuTMOe4JJ4gXOtl0HOdOFBalBXwx6WPw5562k21sN+534xgZj0Ragc2drNrGolxzNIHlLRCg4p8CyOYVe5jo6riaCkpICpwGGXtlUiA+6B8OhRuRuySPBTIyaEITHq9twr7t4V4lmgDYwXyqRPPGk2neQCtcPUsEKyovR3grXznJDoD9vmhHTfpPIHL0Uk29KHjrmZxDfI4X4SHdGM9z6Sp3p40eomHNv6HOtUahszGGc+wp/EH3E0m3Itxg+FHXetspbBgH5xI+zqQQriR4H+fdR2mxG/8z/UHrpmL4JTDb4xm9oNw0JJxWbPJ6pL0JwETFVaGfqH41hmZiLHvuEdwKGyNXq2MuADaMflaEAMe0yTQnKZYxC+OVwbRCFj8oabBK/dxsCXkuT+CVssEhanpzIzKy+cTf/PsLZESimFd/erDA5HKDekg5TktKyPous0AYCiBo9XtquCM76QWtQ60xt43sVdzoBuYiOxfBkcfrYIoWmXBiA3w6T3fh79uRwjaqLN1nDjfJKQ8HNwvfMBjmImTRozJXKTPKFT94cRfRby790fwEyyYcUeREP/pyV+vvDI0c9hVk0pIArDAuYIPp1VPf2xEGYLNVxwb347XEV2Oxk7bSJFOo6xiNoX/NE65R9YUtEGaW3X+ZkjTjrU3Yw+x3swpt482Xd0hFsfpaGEU8xXkG17eOJx6vdLNkCesjzNMMq3jIUD2IzJlO0IScIm/mXnQQ0cB+TOLBxwnkyiEqigbMflmvv+hkhyJ+aVkC1Y7nbwuTKxJM9QvuWisqbUj+URSroMeh/yRZzqZLN3hzp2fScw2O5E+z0o9q1kXBvT+LXUqHL1PloUfygWfNUyaitEyCR8D0DvY/BEBSZxoph4UfV/TIsNui4RCS6MKwwUOzdR5x1eUtFeZOwAZXsw6dz0FDdqIEsxlaJ3UtiuRiiRFDH/S7g31rq4lDlntK4GW/1FH49UaWTU3Shd3QDvXl6AIwHGh74yIe6eAff2k0OAKgWdPrdT/ptKI/EkPSO82bx12TUY8NMc24oI4PDUoYsCZ5hwDbynPC9FDRuQhb5SIriIanhRhDWsUjiFqoq7+10KLlaWu3EgRjg3NIMDAuvR7TRosp6XWM6IYe+rxd3kX587M6UEpic8ZqwSSRfietvlBjzHTPUZFrjAQPYXC1385AOeQvhB2wvZBQYT8WYq37FDd1I9lcUAAfd/f8gFBlZFl6QUdUwtVgHUjyi4mRn77AhEYFfdATQGDFedQk6XQMru/+QPc4ZBn6+U8iA8boTrTztapl6CS7SFnz1DP7JXTAK55VLOJtNUyOs5XDJ65/n/xEcb98nME9yvUM8WQpHx4SLb3CDoFsaqMWRAAq5/zK1PxxnKFL6qJ8RYNzPKxyGk7fuXPLTDjWAYSRD1lF7ovCWiiEyzOgkhAOOo++xnGuW6G56SzksG08R1UuWbcnT3Z8+m8q5eqStZpZoBPNMU5j95i/jtuRipq7fsTA3/ft+DswT+5176leK44geMjZbDTAr2yieakMHW2TjGz/NjqhKCUwG3hd81LE6K/p3Qzyn2jxBmyl0bZyvkoxPQ8rEkcicTw5VEVY/P2EoTWCYcMEJ/nDJo96auEEoi6Fuq61oRpe8ZlQHCyGQidEublpftY+3vq9YxSgiauzmX+kzfYha+d95Yap+laTz4V/IeaY0B230h2hVCNh6NaNEQ4Z6NCAdv2OZO/5bP2/81Mzk1URK7OLBKuPbLly1/S5lBHfUJjnwO2DazCbA5Pq5BxKc5FjWzNGGPAsrY62C0ayjILqitDo3x9YwwdED19tzDTeHzzhHue+Y/diyEMVVGVcwfJGFZn/2xEEE9gftRpufkETr2oXNIzt2eEXTO65ZovqwNjMTgrhYvSXWcnS2eQc8VaP+vv8oFKi1GosfxUEfEXJqarQFWxSlPtPfMLpHeM/h0QGOgAIDi0y48atfaQF+DPXjzpMAfETL78r3WvzLWrKkpNN2BTNb461oCesp35P+R+n0UdRORF6Uj9Z8K6SH6xZ0GLBMvvYVw+/4LLVolh4Ryl/vyhei9vNg3950QIm/h3FxKMKDce6FyPjktWsfX0isXS6UV0J/N4YCJCQ8uVncFpO42kPSgqSQXtQpNl3vSuhznJ0xABykUjPoJ5TV1w/WOiPcf8GTvAiSfuCjhPQvXGMkxIk8ksVYQ5qLQVxgH50TxiGAdJF80BfbDLu2W+GrGfuBiGlPJkFeS2lJ3YKq8JTJk2+ZaMETy1dKzJ2hwhicsS+8HLCGwQpeN5+q9IU0ar+dXpNwFoDrMdncChqyHYPa2cU3dU2G3H/XE9uXskBCAzL8djnNIiuo/sDq5bsAg9j8UezzkbHZ/akauGwiEXsZPlz0vSd4yqgki8V+xBm/xelUPbVvouvE2Zh41xLUbXQg8AychDgGxmJxG2pw1gWrblBmoL5IKSePifu9JV7e5gP+IZiNTx6Xy42cUGHT61NTNSo74VzbilR46Dpt+SQUMLL1ws0qxu9NMNbeOyasG8UrIzk+Kaj5Xi1h7YeD4KM25+VYeYNiyAVVnU51AD6/oDSX0BzUtyKuyQAjZxjwIv6PsxS/OIRsQWbbJECdrdy2Bf6oClarWTFTm+a6dmm9HVldW5KzWea0d5ClBt+b6fNi2a+BA8Sx4oXR4CvHPmUk5ZLpXELjknMwgDDKhqriYNttKpSLlIFq+cA8duxl2DZaADt9Cj+TtwN3VviDM6Y8HwmLH03AdEJo3+IRMb6/yJINWTQ1FavShkh5I0xPUb63NJkiALz3YUTFkp/lusJ0Y6RTsgyE6oU9JleVmY2N/HPoNaf6hhr+TDB5GDcWdwkmaotqnfRXj1buSBkIkVNfY0UW6t+hyjXx+oyyZY9JSOoe8X0vAAg/1t9cXI5cy6i4ZZwEVb50n8BajkmYE2eJ0wGoXHqTymHgHQGMWG/0wKIC9qi6u/STyoCaBCtQycDyoqUmhIVFVPZz8kcEfQQzdgAzJgfBCGlepnOzbwv9dkEvXrVNqxYSVE2+9rCuTwF3mhD7t8i/h4cnzumInIblAjgFIAbiUZieC4gv76L/zEZri48WoIqJr5LnUTBdy2TjgsfNKMWCRUxAc5vkqeXLFXDFCYDMaAb/Okih0Y5jmSoVHB0sPgMloir5KfXzHIuSk0sVrimSZL0+3IFTKK3wpvOMmQF02C+rzZwZ3m40fPhcFWoMII4a7Gh9zzbpv+1pztbL9RNA3P3wrSl9wyydTULpxAlsZLJMJY2zEcXKywiD4/0VwMW9UBAOSrVGBkrWsf1dnU8FxlVnvvNs5hWYrDZR38rzABKshVxKmjwsrIfLQXqNaynGkbUCHW0L05mrCrqSTIgckdMKnDiM7qSqePO/QW3duEzZIs3KgMRlGIbmoRmzLJ1BP/wZkwimG9uf1BApbnenFBOJ4HAX+5Ic+zu2bmuGFyEjdW2AOedeyf7LIJPJkFe+0g9IP5MozfN75+LpLVOrW/VjEdcDyXbHxOnKPONOk1wfmtUUzqNM3kWWhoGkJeYTZuPzzMFMqSzzbvi/Tu7SRgrFYSLcDdUlMtHzut4s2ozkU7ZOKon7Drh2cX51a86PdGzDcsu986MxYfnJEqF5qK0ecPJwTp6082nlUtgg1FYbQof/Z7qN8jrihl37IsHfgUnccIIKSKrul3YF74CTRGimVjw2cb+FSvAomRDnLb87it2fzgc8KJcHwxL05QjjrZY2jv7xEh5T+So4jl+eyN7x+0TulukX9cB36PjcmE+nx3yb4RdUroWy5tkTyCZwm2RaCuezY9kIUbm6cu1vz3GTs5ckQnHCUCSiO1I/q5krQp5kJdXulWKXVsodqLVYVWL7UB7oW35VL1yK/ZYv2hnO0KIglouV7kVaaEoiT59vDhyS7xfWrs0y1cnzAfM4PPj47RM7lkOp6pG7HOStiuUOG8Rc/XU+tlLUGiwPvjWBiyCKFHUDSiR2UtFvpwEXLGBJM562fIrcX+AuS4TyIco3jM906PM1AITNKpRQp98f4F+YA/8QbjjVvaWgRRfBmZsBqW8v/L1jKQYk9nBh6YwDFY5omj55iHxUGDC7+92uWsQF+CbapzJDYljN9Q5Ncs4KlynfNTYTHWvlskkpyqEDpNPIaUbPRIQAmIdkVHPUzMtv4PkrA+19ZnNmOkTv3QWIKaV2mV6Mo+HuIGMuuyBRKYptiPHXGVQihIohth/plTR69j5+HYrZYuggtRzFLYBrWHS82NgHMwuefROa3L7HLHu51zDe22STg9lH5Dm97UZqUZPyVx65JgB0XXD30EcdvS3bvGpzgtJrUx1bpdJJRtCCO+VoGJeU85dc4dD6A5Mwmd+NoEjdLRJIIE1leRlbvYI2UzwQyvvic+Lx30ZCKJ2m1A7m3tziCaeX3NA5kd7jaQS9833BE1pSuF8rkHg2lRzMmX+5nXYZkNsbDqb9AbAI17ooDNRpso8O35MTgUpv575FlzKBBz3n67OXkKvnKk/oqN0x5ge30oLmxWKwzQaQrRsijqdyhhCENuD9WDS1jmpn18gjwyG1OTZNYqFynhfGUw6KKGSEdL7mby4UERe4/OyV5wfwgc0Fx9qam6U7b9g0/kEB6d0Bts+RxwF6HyCqqARoHgTj3bEJkKqAr+7ZZfkCjyFsifO4pHxbg10W0g4l5iTvXdsM8KgkSFPN3ppxGtrVaY4ijQ8Of9EW5awV10Khu2JJuh1I+rzmIDO+AjT+guw6fuHzrFk3+5Krm98QAb0uIKNZIdRBotRSbms5mOTtpU4DKRM2pcLoeP55ibSqE1wv8vOBDzlWCq4bbG65vCpPFd0pPx2ZM9ambx4NgW2/mNrWV85tNvFQUCoWi6fV+F3sK0tttJKBoI5Aatkl/zfuF1fah5G+H2ioFkepmoWXYlTxpe4aYK+7jLdPzD3NFP8zF/WYPk9BpTynArO6pdQkUeEUc/MqY/YD6fqTNDUHjblHdUhsOQT0OIPj6v8eMA5d0gMgOPHpQkTko1i354MaRu+eeswR1ZMfMy2oATrWBn64t5PzMuDDjRHahOAv0rHsGVfhHeqVdbr/BH4hd39tsVYoBW37nTB6ASj7pp9ko3hKgN4SbEgYqm1Ey2sbQIlgm3zyaTDhkyvfwdfIphALfrc9mTCrFSCQ0uvH3SvTAhRq8E09weqZ4hyg59pPQJMq0xgxUDZCm5HzRtFEnBNU4LrenGi4SlY3yiMPYYEWhesGbjsJNQmeMn0+UAUCCrmZ4HX8pTMWf5KtxkHvdeCN4JvutCq6jM0/dS+IvYqgSXPzNzPBx8D5i527PlHgBxEbiHoKjyYeOM8RR0+YuQaOxV5uEwcjRLSlkmykd6yGnWhikWpIPfuLHgmwIZNk4NAO8Hf9ZakwbkSguJWoYDFSoUtAdaxu6e0FT4/4By5iAGGHn8+QSfA4RN4K8u1CExBcQmmL4FG0lti4hvFGKi3xnusLgwry+hZkt/m8fkfpMBI08qf6HQSIp0/l73rjwGc8KnGxG3aDoNcA/oeLcWmtKLsIXGzpcE3eC0mDLH6M+M6/uioyBsZQgnvX6AqQ4nfIneopDY/nAvh3H0A+AQHyt2ZlWG0kNG6Zsn6nxc201TC3cho7X1kQbCW8bqsfBRGuS65hS7NnucJ+cRQcMskU/UCJ8jeFgWhGTuYKWPDDIZnFG6OuUx5nzjziwuL6+hpFh88hajl6IubHzLqQ1tbf9zzvgDE+ZDWbHCmCF8Frys/urK0LZzIpuflRKM9NDB/HIS53O+0by+T7EhTZVxLJv8NCbhSgEos9zGcRlIajaFGMl4Zce9KkkxrylHO6gsTA4KJxCtwJvdA6prZY/h6Un2ITWJh8/o5DZPWbzEIJk5ie08ntIm9s943M7u1z3UpoQxlYOEtGhialWcbPLhArqozw7DqKgtS/byOXmdSluXUHnNqQD/wbMCMvrNL9hby1JFfMFhojYjh3uxoTJlAhFSW0iXGhJSG0sVLVutL/zHg9KnF+l2g5REWHLb0z5DV470YaRMNM7zlKKPfSWdqXxHXHASOtpobJswsOAkSsI2UoPoD7ZrhvH2b+EzhTj7Ph3qlvC/z8Ta4cb/J9cId3JM7t3EgpjMrfj8Ytlu/7QeXMp2LKU114pi7PSUpgESL+OFa22ZUd5VxlmwX2GKZTPuzAUP/osZGWParT03HHrW31dYRBh+kRwmJpqMLw+t0qiwrcLCiqaczZ5O5csBcjol7sZ6d8JW0qpKfKpuNZlvlYgsr5pqZMeNREaEGPvk8R02yxO0FLCFKgu15eH3Vlsl9S/inbrRMQQWJcxfE+0taFvFfAolcZRpwgSToTwrx6LeRb+pNvwPmFWQjEF/xWRlOKFdeqWB75L3hGypbCe/k5ph8AKz+oMHJbYafd6qks64+lHL4lO159Y58fIeNz6ZOzl6iLNyqE/urHywdIeJCyDoLgucjAuhHWlwbSH2uy8JIfSs1cN3Xx5SgN8DUYoUmSpfd9P6OnU2vAM9hheXu4RGaCO5Cp96PR3NABqBLMNqc2Z9BOb4rV01Cp9B/mPPPN+6ZNPh6uZW4qhcVztLmi8EErI91EwmDv3+ToLZDo95ESxABKX/RbIhrpWTSFXMSGZ+PjJrFjYA7M/i7Ww+rZ/MBsFHARnFZeJY0cWiWI0uCsD0p0NQ+ZCf2/9Ugk0Q4xvtmQ7dK1HZzO0GvT9z1nyJJk6FUTXiXEyIRKGDd7+0+6jIEvo6Q5cZlCpN8TaQ5SyfJ9JvvDOLvmzP5V8PZVwQHxzM75ATQSF2jE1Kje3zSOhI6SWB6ZfIKg2oue2PDi1wf0vdXcqf5z967dJyLrzC3JipFbKeUtjD/u4KmNy7k21mBPOQ7L4tFMrsXqgGB+OS5CTW1Ynvms1LMLv/WJ2izjjcwbofueFQA9PHq6yWauVw6oK33fI+gmrj5qxeZqUuuERdIbPXnXK7Tg2J/ptLjrZ7nM8EukC1V9L+FOoA4jkmAoMyPBgd1gRUiGn8FBJUrhrlDOxd9Tpk1h6hXmdDNsUFDI1vpcU84UEuCryWuqe1YdlIkkc0ePrQ+1AKSQLJGHtUVMx1hhyyybq9YKzvLUNagyYZ1zAmzKaSdya/yjpIpZ5D1TpOTFS3G43fl4D/HWgNoN0kAVjRbLGI8zZSCOozRFOvHtg/o+bi2K8hZMV8AI40EKw9ZPhjOb7rPjaBJ0gzGn3Ck0d03H77X6PPfhQBgrvBQFY7O9ZwH6noMaN1sXZE/+FWK95Zdkipx3QLNp4ji5sV5yaz6BgbBtIEl0cSkE3DXhWJbwfim3Q1WE1qZ8Ok1FEAuf5NgdfDDgmJeoB8ul8xxEuBDeaKgywNfv/4FcPBYs49L68Ur3USBEnuCJ7qEvJncwyJaD0to5mABfX7tYrpLeN30x3moeTNXbmMhiBxWHUICzPYLIApXhJ4xd5IUwZ/MtgaVq/9feYKL42sN2DJXr2tsaglS0LDWGCu96sDTxX3RNsqcj9CymXhw1ctOxRQIrXAJNB/d3+EeG49LHAhjbZkQhoPRFoJmhD7XP+oseQknUf7OLNsK7u21PhZTgE+AyVJZ8nR22ip7xujhwQXpUVFpVkIANnLsEviLziRC+ihFZ39DLDlw3c5l6xJ21lTsIIz84DiyP0cM4LF+cXLRWr4hr77T02MQMRuJhd0UVNnXe4TZMXkBdV9GaRD7rXMlJrR4+synXkcOcTqLaq4QikDelHiW3sgT4JkJ1tZI4OPztj/PVLXkKT4PQt2gYNXZn31O8Sks77daYvDVVHqUV8nh0YlKgtmktNv6FNz9T4rItO2FlW6qMn4wkR/AJ6+NSaun6IaYMQP4l0z43PQbU8jYFzNW+PQ3C2QlC4zyUMXARY9c8zm5JySqX3zeaaJ7z1J+x0S2hyjKpCIW/im5Cu4aRTf9DeBgPVTLWpQEChpLC7OGhYTI3JvSDxHYPBnKO/T9ZQScF++L4U3sd/5O1sQdHXldxuNbWQe02icSKCtjDp6J4t+6E8y6K86oNQQa4G1pb9ady5EX87Z5rJIFcmErJ/nDJkQMAj6nYo8icbdEGsJ65tCI2nDOptUvDcJtxo4/zz2tDs9RuX3/JfDeBLxrf+GOfGKF1V9i/IG3/9/VuIwfPHk0o4fcViW1dzyEs/PoIQrXS4RHnXboTIeYYACC6inNG2e1ITrT68dCh/xQwm4/NFgdTpyADiS0j0d8SUYi2IYCPAgKwJ77/eVmLOyfFW3oAHEI+ZIG8a8Qp7BknHV2TZ3nyYtDc6SCl1GKAk/skjbkVkLH130Ur3d/idro5wzsH5PHX8so61cWAq6m0Lr9AF8/I5Pu4QHn9iM8Pw7E+bqyKa/pXBs+aseN4su3bFmPk5I7H1EGa+ak53gOv0rBOTsW+rUr6NHtRY6vR+Vmu05jJrReFyUH4M++z/Wz3DsN6G41ArUH1UeHdSjozPPrcnt+b+HLFry+Pv3+fw/HRH1vrRHRs2nR3eQqzL+iCz+WY7vD24EKBBhLIUA1pbgh/GV5jg/fdTrroyrfbY8ibqQPInFx6UGjob/5qVdYKhWGLfuQCz9OCdNBtsCHTAF+SgWrYNqF8EWDkBUs7IMTq6nx8s7gA1T2tS5dim82YrQYcW4pDu2JxsjrQlrqDbP1EQWUOHDDSWYXsGH5oBaGZF7QxtmHXQ1h7vyOnGHl6s7gJ2iVN/cj4phYFzZTItQiTqbgwjYah+bHEus3PyXRSdaIyAI0KMJQKjldu4IGuprD0o+RXg5iG4XFE5Kb0E/EgnH8iHW1QxbLWRZB/0k1kZyPRDt/W84jCdE01F6mZIqLh9NVI9lfhJY2xUSyPIs7EVTgJ+pQbwxHZInC4YkExt4ejtiikhNWJBMRcUBqIGNT423lhyXBd9E6v1uqQwWa6oJIs8/ntXCMv5r3q8K3EMOhahRdQumHGcDXzWV1uThst6PO3+HPRmX9Z3LKRfc/yWdDEDJ4aDTd52ehQZ1vZ5TtRH+rtfrzizm5ZjhL+KnJ+z74093qG+8+Y5SnQ1efx/jZIuQ5l3NnkLbPtYT4ycRcE8Sacq6XSzsupoN8LQjUTpPrVHUnKXxcBjw2yyPr8NcoCJL5ZXys7Ks/ztICM9OvFbcjCN/8rolZnTWgrqwN//pmf83kc8VqTMhVWWQNDE2VCMrY6bVGcKCCfB6x8/c2RlpwmDJNvxYEWx3sNIzvh0oGAR/3VtYZSyHiyIE3RQG3ubafjv+O8A3cXxuAiuHxgOhb8p5E5BOyTmNUj66crRmhSwlX5JII5GUd1gmdWWM0XfvAKWaeCyh/9LMn8A2q3KGmCZplDQdLp7iP5UgHc8VPYCkGM6JOZUIC1Cu07dWeVieyjg41bJQepV7VbWyqe83xbNPFZ6rvcGR3AGt/uGoD9VnJWWQsykJO+fHOAQYTBsvHCfevv0o9K+xGXJwkhlLlnw0USpzqq+XBretHQ7bl4hYoUwfdFvpiD90RMTfH7X2dtL3+vyHC/g8Xk9vq+/ho28LNKhQQCH81cpkpg8JiUCJjz7Pn+lnLTE1h5MpKVzv3GiYvmcUtqgOZGMZHHJMw79thyWklzVYZIyN/EwxMTnCYP/LqMzstkLfuRDjDa3NTPn2MyP6dRabNYvIB4qkaOXJbr2LVuhZYFzqIJ91inDigG4R8o7cj3aC8bytMCax5qR1Ad/X+z8lCNCTOtLJ4pyKa6LWl2kseuNV6cI5QvbQUNu4MAw1QGGYyp5drSM7QLdqZbC5FjUJGzub0YeWO5D0GVLxRdRt2ws55stcRFmmqJ3CjwxKue76DMu2CvhydSHvQfdXEJmd0mcwgqAltRYsfKJ8vxMUrGw1qsLWN3Rd6Yzacq+WRrS6Phcx1tl5hp+VgcBX+nDMlrK9v3U2XeHy1ynlvnCgvrbBHwSoGk+PGyg8JM2ENkLo41lQuHTzLwcg0NU3Ix7aIp1tHTPrhQDGP7giT/5M8XK/5UgtV/OFmaWaW5ZV9ixPeOLKw4Rb9ktapxb1j0xeY+/JNxyxyf6g/EBAXK6eci2s5Zru/PPNEdb2hNZ2Q73azuG62NyJZgqbTsjE3CW1xyr34kxaN/bf7PeSXiX57yFHIJ5IfTOwSCDxUUiKtEcz/+5uRc7zhniBFN4Ap4CIXdqdrZNdOV5qOxdVQtv3cviL/0LRZn4RKpO9zrq3iQW7TzxgSgxcuNTsSsduaOwyfDtnLZLqulPWPq0SyX+hqIpp+dbN6EBFWK1pP8FbKKMtnNQxJhrdaOrWatbmAyUx+d/sDvk0OOXi3AuBc7D1GJp2pA1WW+TnXlaxGgB4nxxCPCVkR7OMzimBDQe4Ob4vznBKb18eD8f/pJlLSvXdfLRu5Eq/2EtPxy9KJCiPRChSraBA1ZKz8d8YD+uElHeBR6UPS2FhxPfn+VjZTi52Q+u46rYq1tEBuOVTDjN3uRfku2DIwLn4SQCrkNfE6hs/Nqjdq4rm6N0q1nFVRzP0vXD+8BEbLUHg4a4P9P2B/hSmCm7tc/nztPU52RzbR61hBwj4DbjsGpT5VGHeL2MSzvfxkZLO/HficQ56lOfo8vhqMx+5zmzJjGt1S6gQEwQGFkiWGKKQ3K7DqqafHUHJTfI3YjxQkGk4o1yYpwdoaW009uzWulI+rxz9PB66EdEk9Lkdr/cy/n0Naowpx009yk7Dp085WGcbfr5P0MPhVYcEtdgFr9jmR1amXuNGPwmUX/6dkkvYdu9tb8Ip2v1nCy/MLGpvxH3T0bWpH0AuqsUX2D8yhh3THGIRWfgM0eXwUZ+CkTSdkiCz5xPAJ9EOkCStwM8fOYKy+OX+jqdRvT5EaLdj4IN9pwyzkHk/ZuC9NtQvHfef5Jhcjrejr/6ZwxKFNO+knPvqStCG9rwxj1AD4JvYdy5Lde3Q+Q+G3tM4Xu2O63c7qUnKmn8x1Tx0SXnc44JJEUlym8nTQ/MtAt3Hb/kzf+C7tDsOQZ2lpcke7nY7zthCdxph/p0h+lx2mAc8QijCV26I/UulKqGUdqlDAUNy1NRbt/mDRLooOv4EoqNKKD6ivhgq0v72+q6BrbaPEk9XkuP7KeHHEmKuibjH95VsthrushEb3uxUzG8uRnDdkyiePCkgUokJMZwvr0ZoJfaFDIJVj+ogIPYFTgZT6wIAT7QMcgNCGfVMndgfYoK288KTTNyR/L+lqqAoXZAydFkjR2AbTieUIYzMMu1nKNpjD8wymeX/QAbFeAFBLA1ug1QgQ5x1Qlrbqo8a68oolXvgOyDEkYicqTtKQTSZsRnaw1RmGJoDD+GfVnOzHvM89ibvJZ4sjLIpJNrp2rIFcrGmuvJyTp+3YhoRMgOIA8B0SoIKNvYNOc7cRuCLLX1vPM9S1IMcE2qX5Fk3vkhxH6EXEt4aXqCo75J89hrcqn6Ra/zNewLeV7Qzu/vup9QT2LG0g+yNbs2dApoPjVbqEbo+XFaCKI4QRz7RfBYH7V4UtP2vzdmugAVEAsuZ6JcthtkMloiEyxc6E3essw1vCwSUFvTirUU52ZY/SZVlIKSZsjmUF8nbzPzqEta1OQi0UqYcf4c4m8kDi+Ezkzcc/sMXJ/WwNoLDrgJRpbXiIeURe600c1S9Oz5OV67nFXRFh9g3SQdqmGl5ajEMpc131u4Hr0K087UYUTrfughq/HCy51BjusTV4IRtWtxznU51i5IF9Cf6ACiwakNVoFUbzkGr2qt3LIa31+4jbswTMvbnHVziaCyQVyTuHZyddMN5jW8zKDC+pjGqgSkzv7wFYW7nlbx1GR7NwssqqlTNr/HXzkOHenyC/xblBzuT3f7UFz54DUbGynwgK0kF/bUixxEgr2x0vzlWxG+FJzfI6a0FzYLgqTxNhsmdoFPAMcVXzTBAPOsKr4VzMMCh82i9lDiBfOtHc1e93FgIwMjriKPWkgQn4f9fwBxqEJXCfjMQ8OzjMPv46jvcRSPsRJ2CRVd+h1QwNlX6HQ2mZdf8PT5+hc47GF4B5Au14fYwDHwR3oK1ngRkhOugvV3PDBCuIR504k0N0rm0inoe6NGbgJTRDpjbhqSrh7dDgoKbmjZDAoKGH/pEAFRyDItqQ0ITODADgtwGvSjLTbhGUPGuCIIH4K/XLu8MaijZg6f26E+PH7aFWXVLORuxJ8IYad7tn2Ui/gd6Z3I12KdUXaHN4O0YoDHyvyxq0O2RbDk8MUCwRJzpfzndK6l4JqrTV/2vJjeRercKo2bGNBcNUVao/yFJEecEOB4S+LE543adN1BDnO7mwq/ynxPjGJl1meN5zOQ18933WtJkikzBN6FIUN6a+rM7RBslDJivTtrkHH4LWYvIyxfyfwkWYvgy60t5zxJj2WwiO1j3D5CUnT7jqphPdyB649ply+uWWS+itKs82MZQzGWZjRM7KQZCfE3T6tI3C4p0uI5RdYsGKn4abkr2AQrCCQVMZiIYQYC/nEc2K+lR6mcn8JdfQuk7GpxItlgEZ0d8oJikBzgPqGfjcCjcogwJFGv6MmN5hSV4pQHz+FdYo2FykGj9yJmKoDLhPJYnA4I1j07LGSsTucljUUT7baFsX5/emF61u7Ng8IkrSbF7xNa8FfKq0busx5Z+RxpwxaXzxyd5MLn38mDSXJ5LsfhaSyikCHZ20sxSLW4N20VP8abckrV5f9mtCVQzXOBX73ng66nO9aSLyheizFCAW2vK5aQLiY7ji4ZWLGHjCiDoWnQSvmzU/pokD5oJt//L9/53oQmcdCkfi8pojikEb+tr7vC/7nqCLefhH7ibE3ks8ycwgl9BaQ4JfRAldn8UJ5QXPjPqFMM3Bcredln0Y23/eDyalsY5dY9DY9c3TEkmuYSmzt16xrZXAkugxi2mE8AprN6y6/CGIb3PhBoHaurMM/g+cE4hgm1J3aI0q9pFJyW8RJzNg6GtlwPnsMxruRolvRHxRr5OZL3BQhvmMAT5tmYpi9zX/NJiJS2kzJZKCQmbUFzLfQ41ZrDx9x4VIZ4LWlA/iX03JugB+G98HP58KTO4vA6Ai0OxSIlfMICTwZ11K+I8oyZE2CPDbVqxsIUFB2H6xwb+XwUkcZZQKKbsYIkFg3nqfVIa2cvigOs6pvNTjJocxqHGtye0PtYELfkzkHJ/4xPEqfCzsg3YqYX5W0gB4JKndTfFOVFWux/9oF/+ENALbkY05w/APt15E8y9tLjJsBuGAbBnQo18c6k5wUnvZI2D9uO4QBlDVocMJdpo2RKQWwuSj9ckIq1ab1LrDpdZcz6fJsr8ZIOZfMTRxgGloPP0jGrLMCqWFLHfOyuYyOF0HNKTBHroDRU6LKSbABI7OZRZokKrMGQATaqv3xW92XJXS5ee32aKv58pZJLCaAuww+IO97uZ6BSor7ZsH62Ev/Fp+M9sIzrwVEONlQUUcqxMwFgkhxVxiCAuZbgKdlu/ZdCRkFtYIid0/1tYcJBckFK1UngL3zztcXgvDC5tkr5M8QyelJL2GWZrzRoIpiBiTj/ibNQSZ0tWPBITt60NtWlEiE9WpeRJTX+IosuBuxf/4vl8qD77i1aOpCHw17FiQxcs6ZS4VTPVgQxk4ME/cQS21Zfmy6+/1Ej+HGSwi+dmmjfJgPS+HOC+me8IM/403R3U5Sp4H8nSx8ij2DMFxjKvwIEQWIMno3wKwDpANjz7MCkPNnosNWOVfIZkIQFj5A+gi8/ISrmduECLLkgjuHBUFF11veqyiFJgcKDKWOXXIYnsWpvCELbj9pD/58bnlDkJdUz6GCIkMRmAdg7FX+Vdfq6d+wcO3263DJFu0yfi+n7/NTuKJ2ohn+aByFOYFpzmyF/SSa/gfvzXTfaDWZ87RXBDE9T9+kk1lzZE/sptbO/wTWqeTQhc0xeZTH/9VP5bczx92iwt95YlphoudQvrKUqltF5EDs7jyUoXSI5papGRQqEkP4FQVBKp+enR/cJUFuGhpRvXVyQKWFV4QnB3jJvwh9vPIe3PZ0D5frFxXGVXLeJhVIt7S1LwHG3aTjCRSFHJf9mFGt//e8jWzzN5ycaQR7IJ+Zgv8iS03fe+eACicRseDtJTBfc93jFqoxHYufQcC0UWhUeh86Ydl93z+N1zTIdT7d/bI0HsKsvmfHFIuKBbh1WJww0DjOYorzjCEO0nUnDyr2I9sOHx1C2rdObZHtunxDy771DwWSJO+tHffPjSyRZJ2m+OGShkwP9DkfDcdPqLT3cVJ+0hL/i+OhlWHZWrV0sSqwMvPFnGJ/YgO8por6dfXNoPC4wAJpKO8H7lzzgASXCfAin6nFLSb8XEPBLZbENA+zFziRoTn2dGMAaQvIWGFDQCL2GwjrfnYGEVcPwMzIzSJIjs09gqZ8AcyGeD2q4GHp5QdcQQ5S/QXNpyIbjuwTcAYQetgFkffYMoTlDabPjkiqtclBm7SYWACquIqBl5G7hsKVOUQ0nSRiPhkFVRv2UdXoAnSp6uUtz3dL2E1yV6XYvO9T1rR2zkVAjQGyow7Uj2LN7ZWe4r0hSEjtqPJCuMWvb1BQ8ssgfVrn/wFSEnjNk7yf+4bscR4oZkOO+w3hY+EByOlGjBIxx1LSJcvLAQu4N3NbA/nsqWIBQI948YJxmpREV0KWDMPfnodD2p6jVpxJ371Fe3UVdj2pSjmm2OJA1SRKHjRdn+pJ+AhuuqZMzz9VYvToKvZbITs/9v5hA8ZGy7gS0V+GwiA7CS26KaPcDhgYpDXzkoR2lBYqwUVmFSUAADpStIz1JZl4CsN32Az+J/lmU4csTy9lFSCxoumV/nGCjRus+fdkOq1ao3aJL2a/RUozOhqBRKIe41RE9ea7Dh3v20XBFbNcFpGCgIZiU5wa3xfygIQYVrclNmNuJe2m3C2ltTn7Ek8Cb4Fc3yeLho5ucYAEnbRMM85rFfcZ9UlbbF99YinmJXmbvkCDpo2TkDndqiDIHiF4ki+KkdoJ2qKo/foeMVYY2tSxIZ49dMuUQaC5WgK11J/mBV0P4RSUvbN5wVsP5X/sQylJlSgCOtlLyV++9ilXlnwJWCoQT+cDZyLttUklzgqz9+DYM4Ja3dLl0b8TXyU8rvUZ28u5fqnHogbf/zN937Vc0U25LnkMULqJLKJsZUmx3dkemcKM7z4zw5jNBVWOgZ8xXq2b1pCk8L8dLFdb6Zz6YLVsPPDvT8ct0aEXRtjJ6P8+d082s1PiCrVLcJYCNHCQOHUxYxEB8gtaMcggW2TGDOfn4BWzzqkuJGbm2zMbCXP0U95sX+pZs5hr1FYYtbM3NZ8T04En47tgqP2hdrLugiXITtdJ+ZiYBAl6PDsgQxFTTS0+3ydBudYCzwQmhE0GCtUzMaN2o4eA9R0mK5fm15ccQHZFWBJ5XJwJhn/tCjVpsrmOW0iummCB8EGTWCwkrqinHR9+zoCJWIpp1w95agfYjHJpSOg6xykJY/hLp7v3N7gjmzbhF8kH2ZPIT19B4afj16+zyMEM0AfMbpBF7nwafwj0ojW9Tmo398V+X9+c8xZh4tkxKRrsans3l5vucOS9bKlNc4wAlMZYh2pxFd9mjeiXpAkScDV1GWLpR6R0+FEsF9R0NeEVKvGcVdlz1cNOnopCkbJeM4m4OIXdcH1UzbCv2GDqZkDWjOXoEJ7/JNWvgv1lyK1pXiKpdiT5M/hUAXwca/u2gSQjmCzCYy6Yv93iYw02y25woL/WrHmDF4snilWfMT1uNyw7meugtzZb86TgmlD3MrYChM+MRVU4kM33mQ1FGkR9fKcohd2Qk9YcC4/Qyzop/aD8tmr7TnZC6NX9izZWDqpCa3MDrzC7/A10Fx8mqq3GQiaNbiel7ZwmKo8aN0m2sr7XdrCaxlu9LLclWrryJa+DIa7/FviVa+S7XhTPcFKOTTKt+jOhLf4ivQpQfrOCzO7oUnc0E2noZhIFPXNfj9nJyVnM1dN4CQ7ZXU2RyiOZ4XsANAvXuW0tf2bglJ1QySr92EikwnLsEboP1qibhDgLuFiQPwvrKFnV15MsCP20oeb+hrXupFuFKr+9TbgCvkGlgRVzpEPs5dXtI1lA0KTZXaVLZl3vqya+1mgvebdM+jEUPEPUDdfWPBopX2L4nYqdkYSBnRK2ZSam0MMQO3OH1omKpaeQnQNi10y/+EnqgtMLMfObV0S0dhlO9rFumf+h08ej1tqVudk/6NBE/ynNQAmF2rFCRGi1K1IXGbKIxyEjAu6+WuW/dw0fWhQ08MVESc54+IaQbV3MvyOLaCKl66LS9J5kRIj+6UgXKUp9IckkWkLj9jwrBI/o4zKdDNJMxzk2fsBkH9zAUrTzpALz1I1uCUUgc6JynGSAmdghOAOoC+RhG20PT7IgktJHnaR28m1OJtluogHjc8H1NUCTJ2Y++tJCsgqAqOi48F/VNPoXd8CSSQ4jSunT2/mli5jCnWOmcoYBRf3xLP1M6wbAeCbnpzkRYOjH2Zi+NLN5rtRE9MFzvVFJdiFmj8ZXTnIvUQUJBrZWExqwOLhW2w/zdKXAMJx/t5jeGYVhAcuyhvlQwQOzPjQaDbzGAUb/0jxbFKtGh35pSyEUc5AjWm2BgIEXg6xfwji1y9NnljM6H7QfZXKmttjusMnw/XlGd63ynX+lS+ey4vhPEGeZSWVdiNee94HB7nCnmU3P+bawOciIl91vLlLoPzFcVrXCq9bh7KuINJJn/X4jD3Kl9HFQZeLnBa1GgXBvQoQBdX5btTOx1zk7jHz5i/IHAQKbjKRGGF6XsYVP1TWrOaAxGm8sHJTfL5aD4AACDYc5y+PBJpV1vnT6hoBrqLMU8FB/OEEYNVNBME7RCEy23uZnXcJjQP/yr43ae39xXP72uMvJYZ7wIfEft2fKvr3SWaetPCmFEJbif2PtGICiWEZ5SZXp5bdBsMwQpPvpdupmSPEtEHVG+lHPJysJD34kqknmydYfENvSuHmIreAg5vr2KWs0//ohSdWGzpB6ci51aAY75dxhPWX6c1GIW2vAZvBGUXfqKkD5mxXKQ37NfBFGxXI3NCbZAWkmRQeq52Uoyk+nKnz+mrxe1Ev0KdaNqfeqs19o9HnW00d7Lvpe6AqOkuTGcrocUw9f55kFQsFEEbaKFIH3EYb1xTxIQ7I0pPUi2B+Wzkcbx5aXXESfU2c77UDomDlSPx5pvH6CN4H1BCAV4xHZv+kZ07cSO16xGk/cq73/MaRG/jpPQez11eLaUcEgoBN6Wy3fqINIsLV2wKhIb/nyFd+Y/1bBuhBtRiXrTjuOOEBEc6QUhITLbq+RVWtQQvNA31fE+peWnDckanhzZITvvtZzM4B7ud2gx3sxiOvaGWfIpi8Vu95YVTEkQ0NtgRvmEdCX1Z7F3dNQ/U+YbI6Knlcastkoh1lbDYmuApnYx69Oi1u05FAg40R/yB5yRRdCSDwS8ooz72TK8+9LTaa2AhKOjh4/+v4VyseiGIgOSqIe8W+YV/s8Pnead0HbH28s6ob3qiY1RZc7Hd75PVDIZmdZkzs8pWHHTD4TY/81qoe7PT++SayF68d4UWYq0VyvVKZGBiLsa65uWEg2FEWOhzaYfxCZxNSl0/yGpcJTBIaIdRUlw1z1XFWEpFMP3YH0aVrHBNLImDmRngOXBZ+gzGVVBLPb+QC0IDbyPlBMgs3gUMcC5vs4lB1V3mRgqXzLny5UhUtvjzA0Rc+38oIp0taHwcTooAFCPnlfanS0K8AgwpySMm9QYdnSbX9ToEo2t/jq0OQc8thT4Yu+Vwu0RBXn4gNko3qaUgkIbtuJoHr+hmpWgxR+mMnfiRwvR+UWDmsDLeWhia+iuTlr+QKD0ZbmDkGcWrEdpSZmjo0HqDaA5y68u/UGNhzc22QqlmCJS1QpMZfH5O9/WYgL5ithFAeq7o0wHsJZ3++v1xi8k7BEjt+boKyifSRAO0Lc3glAskAC8EbnTD1bP1DCqO48WrMVwrOKaO6d14jEVuX7E8p1ex9yO25MtNhU9Zb9ymDOGuXrwtON70fsEyEel21ElEyuGPFFB9ARYg0DQhoEHF9CWoOY7+X8do/cv+5adtn+lmooCH9C2f/p3d2L8xDRNMWj0nWeVDidqKPs8ZQ8LV3+twGy6D2rN7aQJcF7Yw1ZaBLp0UCP7wuFX5X6ZHXmMpRKlhUiVizpzqFAVlSTp/I35YJ2o2BIUCYEXIUfOw0WbMX6zBVSFV+GJnmqCBi6hmUr0v85UNEqW4vAHXqbcaI3Mnrvw0NcJXEzJ87F+2WOktJnGriT92l1+Ag9aopXiVhTrJUfrpazC4H7kt8efUVXUUSvqq2KpVX4Xv5MSRcq5wNXHMKeBV17Q9R2T8nYVVu711fknDafN2ZCNpBX3Vevtr+5LISM4u5RkwjbdRYs8FMCyW427lFQu76JckTaqotESc8S2MPVshLuXlFGhI39c7FmmrE2nkUvXXsM+wZoOjF2aCj7t9NF+PP69AG+fqd0zsZ+cfe8/0eL1QxUyeVDScL+67/+6wj1NGTijgzBxzOdpoaVDbjF5brPL4IRaCE0X5pWEDrL+4EgBfjjFb8xWFHsGbh1g2mPPTENO0YNemnsf3PFwg5wBTCMjc9JTDwUZYdspM8gfraYN6Y/j4BnGvrlLy8GSbnddxIPaHV0nSZ2zRDJVJZiw8jQIrMIM5tvHq5Xd3DfGT7qgUB5EnrLyuw/QOEm3rHGPc21YSk+fMiLrjidKs8oE5V7oaYBXqaJH2KSIv0LGZuAF2yG4Mi4iCUNqlOkKUUEC2av3yAHIDAEZjGt0jcNAFkzTYFw2OmWH8S0awYgg7ikrTBSdlBf4okxvTmP4ovqnpwAS53WZEOQMBtt5A4ubc5WU1hzAU4YtK7nynaDVM0OcApIpaFtxG0nE7JsewpFLftalhRM2fl15jcKdI1iGDiB6rVOK8d2DUiJuMvvwwSZ3MDX4bK9MUH7q4ZkY9U+8S7Pyc4t3IG7qEISiMe7nm6NbtSXJnu+Kv0D7S9ctKYWPPfebFON5RhVMCuY2eAyEje5eo1r3trFuAMbb3P4JBi5FG32RbTnWeue6USaFN3LCOfnml0XXc7FS6Ie/WOQH8Z06xvdH3mIzcDz+IW26jFFKL89vzVghRpbHgNW5POFu7Nxl4QWUNVaaaVOooZOjm5AkRLkifj3fw6k0rskmSMyLNDjquyAs7UIIXAJN7JUin0SDNBkwTuzKByiKXpUit3eQeVbNSwqAkkP6/toosF/zPteAi72EY4NgMTgRQtWVz4Iu1tx1jP+sZDfc++ILaVBfahDzCYdWaici2qSoRhR1maavcqzG+n569uyEm0S95eH8kvacKSck4sVybaUcgbD8pBjjVLxj+y5p4MogEyaECbGLe8voCjpjggadu+OaT/ufaJG+rEsdfU5VDbYcQYlzhn4lD6kCDgtpbUSmG5JEYjbgN2bPST2Qt0mj7nI3JH7zBAz5gH2kqqv/6W3NCFWMOKr2RuD9aSVj259brMIxCEH8e11Frmq3/19u9uD8RPui2HO8i3jCky9bku034QQ392SyZcAjVWwm1E2k/Q86lcVmlcmiJLLUpsJHQsuSSHXVpN66FvNny2CQ3jQSCdWpde+O07Wkdt7kfbhb3U9BLZLP8FcbCOCFHh+neczjzp6FFRTAxmk26IkxfQRYaC+FdQPO1485z49Hm8n5j7uCCgCQH5RryAK8M8SsP0USZPY5tTzJiYgocwE/y4crmsLsnO8DbRhIh0k2lcL72AEBbDk2HfsN2YPc2waVK721Zny1l0o/DsksfklhztJaBWqJxHFz1lfTmTuNkTUk5+F8S29zApbYRUMug4a1c6rHnhK1m3gjuH9XZxpF4uxaGWhi8kFtU2Ifck2b9RE4jshWrXINF2irfyWaElj4Pw6uuEj7qsfQPCd+fV6Qx5oLjmqGMHLyQ47XzoHLkCRiwaBscfyx7YOITPe1JJfiJBWr+QbUrX6pPfXbwvL5I8HFhFthBSHj+DE4qaP1gEKthk3GRtzGxPlC2zCbW7t7DBQwlvnLHvx7ToGmm6fs9bGr55s6CwZ9v0YOlAMzWelzYg/3+ssGbZtiQjy1os49DjmyW5AwdArbL8dKHoCXk/2scIR4fPrQL3/o2uYKHzlShUngzpaZwN+IeVcZ7J7U+NUl6xllfFvyTAgOm1dROK+8Jt0U0E9aGYaN5DP4L315auy1TR9lW9jsk5fuHO2Dk9ETjhnriQguowXgDDSyEVAnOrVYN3sVBp2GfUXaKENtz49qm9BpGz2WUAREIjPwyOzMDXajBTNk4paIhqgbt5eo2ixX0DR+da91xR6wHk+3iCY6pJAZBjEpaPrw6XcXli4beLGSvAMr0cJJkE5qyEu06FAMddGL01D2bq9UeYi/hodv/YgUbDxZvxwpwgCuSLkaT0H67MJN2mVE+uIXnsPkZR1o0BbKWwRZdKQcZHXnQKtMCCuFzSQw+N+6eO7q89kh9LgmIaQ8YHmEbtxmlz7beg8f13UC5lURkA5BeQ75F1FSXuEM2Wbx9TMuWqFsTLPzS60aqHkRjGyvATiX1OLb3pOKUHTmpvgJts8FnxXGNSQMFAl+kt2A/JYm58PCqB6nOX+WmfekKJmBodQnatGmlrR7L2zEOsdYUchQpJ6cNGKp+Eqznf222wQZGGlVkvXdcDzSYVNE63DQ7T9KCDTdMDW1SScplevLO8hzcs4Ua3MD47QV41BGhJMK4rOEFp/NfCb0SbPaKaX+YfTqQGfnA8RSMfFHrX2HKyM3+ql38AbBfDFAWFZRh7eCRaSFwMUb9T+HY4QswTDCA7+T6fM/iKpwTZsYXJGAjV9n8DjYjw3PzXXS7JkdyFN1ZK9B4T+lgb9YKo1XcIVD2Lm8cng92zaRa7XjqfDQmzGeWlDsEnVGb89Th+J1ti698S/fdnd25KW4YvnsDb29Iw6twHVfxT2XoERVQY1bcL6dLjKnrTIjn+DlMssZrO4D487yV9V6tTiYYwOlT08cKLUpf1D2IGZck3xbg+E8kePuPBbDE2SrFRUOZ7cCpJe5TMDxdeFFO1cMQkxaHaNf0Fh4hj+01ZTpPrVwcmSl92X98Ny19FCupMwnzmGyS3vEkDQIKYu+zPvMs1m7dT3vxbfyNGN7pdoHKgBe1+h87H3iLZg1Z2x8N40lRVANpCSDDee6q6PreoMTF/lBqxdVtPYheKSt5uRHDk4il/SNNW8UmHofpmrB/UOgmlyq3kg7INXfF1K3T42MexXAzU/nRQKXbvyjHJ5L4SpT0e238tfVWrcztMY7nTkHqrHu34nIFDfUgxJH3xogP8vAvOVJAc4FGukupnCawJR8H2M1KrcrYVpvGRWFHOjv955kI9B0Idb7zzZrLZdxUVpxlZlPNiVVAFIdVsDDNLtX0PhFNh+jmZCDGvL36yyCJze9BENWbxRVcyPTHbAF9twFbaBqTCF4y7Pe+WHRgNlc70b+TfCqhbDBkE5mq8N/Ifif+C5FfEZiDXkHDTPk0DU8Uf6XJnyxocEw0Fo5X9Bhu94J0JPeDOH8Pxfiggi2n8m+DH0s2/ebPeFmy9G/qdjxs4++WJT/rFPTOrbixtXiVvLQ5ecBAGP+TXnVLrSvFnKC21rtevrij7a8HK7AJCEo82lsK4epz0kWhx6nbVmS37DlC1VElVrfq6AM8XChX97fpo82drZplHe9aTVGhsrRTKlx/ZMmpfI3BTTkxIOwvAEJ+JjRe7tlrYdh0EKfu0s+PdZYFtmgP4CTEYn4exoc41JXdfi4mJJiV9iuhR157EOHxRBeBpPUqj6HZkBiOVhC5JNNK7wEaYAG6IYYFwvE7SZqGyypyeOlj0bsjC7o01G7iE4ItrBeNjEw5ofoicgnb/uvw3Td0OnAGsX4LD902PmOLEnxtuL8bidiMBK4wZuWfo757JJR0pQHgf2k0deoIFuyAuB+ZsYGZZbiH6w+2zx09SLB6gfQJ/5akStHYyoh2KN+lPmZYGnZBSuP839jli0fe60NWWV5qR0REBAT4kPn+8/ivKCzNgGPYYsW82H0yaffalxbF52IfWlHc4PsWXRmLgYeq14VabVvNFBSpID/BC8uNkbAUUbRQaWhQvc5fXuQWMgs3fuK4iufNRKQWFJHYkZpdPaH+tzYGaA8ckBuicElPl+ueR5VFXe3OZm8HAS2yQVa7OCjHKalsApfMnlmwTHbhkwf9Gxa9fAQocDzMEvzP/I7Cv9L95jHk8GiBJoytY0nYTdUZen88ULC6oQWsxX8GQ+zxh/ebvEy7fScoOKRjcYL+v9y/2UelBpdE015MEHqiHfgOklSsdKI/qADOilvA6XZqKGe3T0u+bVtnyZiHkOoOlSTL+znDV2/K+h2tRqUtFmszB/h4mVcfSX3Da1UM3hyE1joK7hHuX1Y+InEot00amFCe40kn34ozXQqsm5PMFFXTrc9es9ZAYQAiVRDDNj4WdorFxP/TWv55JEI7WdGMmetuJlGNjZXTeyTga3x3SiyJnRjBXVriMIAEuUy4M34JAH7ZBP1tK4d7x64XAKVt+8Yx0Nq/ENBqu6io6LU9MzGZVPBzRk0QQRhUJPVvJpRR1+LlcwiBopd+Yc9JHlscp4y+AJKUFDMJMKBfqAWLInKPnKtDZ84yf6wBsCwNUcTcAqAYFfsI8A2I2Zazwbp3l8zXJ6dUgsv3cAHyNNrT0s5sMCI2h+ZVDw6el67iRtx+vDEdy7gDTHAxj26QO9UoAsvEq9gjLBMN7b3qG2Et8kjgtV/bJURqQ0MPMJgycB0FkTkjVhmn+5hKDrnqtqjwW39u2xoPx+++mV5wdz4AN3+ZabW70Jd5nmn50YvrDbC773YjCdIP8IKAdNAJFmsJ/8P/UbLEa53j8PVbOZ7FgO8MJn9ZYcL1LIAzez93UVkHRkJ+pphoP0F0wY2xULCZfaiBwqlNZ0xLb2ynlFQGmolLN9dZR6qZa31u2JdQrWA8jLkXy7H1mB1lP5x3bujwzPB4gUDp7rnQ71yTm1AexO0ptRsASt+BqkJpZF3buv5jtJZ676JsFpnvz6q1nP4gbNVoeMLkyH17vZ706LWhFygvU/bef7arBiYsAHhEfbrbyKLgW7dueFRq+T7W0dvsDlqW9O8SRXDynJY9aImEa8DfKBVvbY+3TnjdrJnCLFNoFbLZ1saMOGV6lxYCWuK1gCTW35S0VWh32qKDo4a4MvQexb9cKSU7Q3EKnmao1xmCYlwhzHWmVxnlXrNIKvs09wztTwkU3u40A3IdehLg94M5eauo05Xbx6XsYW1fKxn92JL3xZQy1W4xZsTXSqOoqhM3b8te783fVu5pNZH55BREz9sEMiox+QaUfSh9ubj43z3m7ql6eTRx9xhqAKws6iA3OTD9CCkwuttDfQbtmfsG+1+ifl3OXTtmLkhFEyFK6Euv6FMGAzwb8bSN6TvnQW5eq/QNDe3dstNjCG7klNttZfeHp5mHs8JklsYz9UIKdUg8IcVPQ6iKvaljAcNje+GOH6SnUXPDWGpumUlPI7K6iqgg0Zdj/3gAzErY3KZ7zSUcENH0eg9rT4PVH++CW7FOJK0OsOv5n8ry8H9Tq62JEvScXXeLGsD1h/sJP0+919u+jKfSTl5bf4SRjg00D4286JsrhzhCfYDyGZUmkvtvPFMiX3o0qvlOeFTOJkiGc56ftTFv6+N1q/69LRsxLjWJgekFoeoz8WQbrnhUrCYhyHDibZ/k58gELQvaqaxVBs0KvFXRFFgqU6Uw5NmX6IRDkWw9uCr9jcgtET/+Lq8Q6AuykoOg/n7k1JaB4/z0vKnexcCoW502KB3MGry6ur8odbTcI1FrhmYgdppLTQHBcIrvcpF16ObAnbFiohzc5TsxumTzUEH7Of8Fef4nDn4VQ9W8kuDHqq1PpSXM04jUhNQogFE+8StUPPm+UfZXi93icP5G/ZHM1MgQaAPz6OGQ7GP77JAfQiKFhlmoxHzGQK4weKyxBRdwQtlb2z1lePSkvBZcBekfq7LBdLpjvVPmOZ+K56JSRjUFg8RZKr8SnRHDi4q+NH9DkpiJuitKdxSuMz8t4Tyxy2pTnSOHFETjEVXbSC/YMDQpv4jAd3D4dm580RstoGrarTodDHWLlLmSZZrOWNnUv5C7uJ+26VP2pmPOX+eDQv6wZZBiiyLK5zmxXN05iToMGLFUmxVoSIViBzCvd+xgb3SiTPTVpo84Sg3ATusUAvjjZmAjjThn3fHTV+2s9koBshTFSKipNaL5fQBVNfoEtV6FWJVuGdQVFvPB773341sh6/HNt+oDgvPtDd0+x5euegh9ovOiZn2/4RF8cQ7C1vWD8vFXGHBL32gSHx7m+bvJtXPCIC+k2mAWoNaV1oiDmcmDYbcVomjN6ws95UcE1RzRpUSputkE6iDnK5vNsxNHh6kOs75R6ermT6huiHMAkhFcq/SgSvI7Ivt0xEXMQqxV/Cw1UpO2V2y5yz3ZiVdOtQA1IYjbR56viyXkLHCeHhe7ES9mynv9DZPd17RRJTYUDG2UxVTrKKPzteTHhNj5AyY8lQkZ1rXGhTaomkbpkCqNrhRpyZskfQKdFY1LMsSC+cD/Yudt6R7KMwNs+URmFOv7wvpUHZ5qT++TVtEgEBLALczP8BPLm2z+kgSpZAqYSlzLQ/h5h0lNXWRaoYH9ZMr41QPOOdGm9+UFI8X/MM+3TDbeHXxs+9iiKwmqP2/zVcQXQrUBgPhMIVlvddWNPqVD3RmQ7H8I8s/l3sVAOk3Q8YqA8zAeS/r6QykSUxLaWoyqAN4P4Zh4h2qARRr3OoW/R05ebmdl3PydtoGFjTnXst0Unl9nygvkNQxNfMV0mECHU6wACU2X+WoVRMiKt6tIytbR58vlfktuEYYreFKp+4TXVb1llhUwppieRz6d7rAqpGI8C0Lo7KId+/FZAnFG31IG1mhonZO9Qkm8/nNVaRzm8DiP30bmrDjVcLN6/EB2gFDYP/BiWGa1B13Ayv4CAFeUhMqzA+FLJtRlBtZgD5Nhu9QzwqjQRqhFAJnPhhRyn5ZqbnOwIZMSjUeSyhuYL5JY6LCbWHPnaxz4dHA5O7hTTc1eUiTr3BqRY1rx9Izq5lFjyg1cbIiTeQWDHZjeGbO6AXZ15i2aKMdr1xVy3Q81CDFJimgAhw2hCbcNjrMbDwG1xLhH401SiIbHf27s9InfLTXyyQKeNf514X2MJfWQtYbW+aMWvE9s+PhQDIE6IThJTi6DZN0owCLsPZ4HHyscmsiKvXGmSMIU7ETtJezRj74st/DDNJUTqRF3DNt4vyQ0dr2Cm5rFuV+O0FTgGxVN0z/UVJwl2SQpkfBXEZGHk32w10/MeAiaFML7OT1VfqKzjxQ/Af+5UZeZiyLBM9ehDyckNSuBmzKv1IbRma3a9kecad7X+GRJ4ktEDMyE/TaQZnK+Os75kknNvMfTu6afJi+z2pSRBO4yFbJ8nEY8GCFwuX/96ohK/wQ+UqDEwQy+WMIeyraBttf6O35HacsQY1FvdHH/7j35J0WW1YgUBtjvGd8mvW0CXkT/K3xwwLbC1NCzpbLxDpa3xIcEivWtH7PFNvqKIpIREeVL1WC3hv9gALEjJeabfzmJFo3ZrgZ4Cx2AWoQCaQdPBsEQ5JA1Ixy+le7QoBvr+k/Gc7+iBnGniSfWxqBk5zrDfQlh+I7hZlzt8/06k4PrDvIxBQrtmKfZa3XxKoEQb6p5FW7ItdwEjiqFVcTVb4aqT+FuaYxsv8USxLfruV8t+hoGM1D/O4N0MSAc4P/mS4IXl5+k+R8K989NuEnGpDUR89+WMpO2FqJqJFu5v6PusYWaLVCpz3lg0c6vPzlzj2zAlfZ3d5gHuxChzbbCHBdiSRhs54/UGOI7bjm64jNhIw+OoAaqhRnunpx/g1YZ9RZ/Sx3cRkJM5RMarklbTcn43l+IBMyugSUGQ4bNtosMugXaEEa0QjTXJMmdyeWzsvmM7F60MYxfQDEyPaMYKDK3ouZJAe7v7tt5Yeo8Xrkb3mTOVGcaHd2n5MT37B//GZw47dL4UYe58hMGGgZSmThBBddzEaihZlfvdHxd+Fxy2wKOdD52HFVVe5wyYNKuXlV0LdgBiU2Z0oadyA+z+DO4IJxo+tjOg1boZTmUxu16asBxz5BR8qh4Dw2cooQmYxeMWbURy/+kkA6rjrNj9G+MeS0KSC+U6/JMgxN14gtCOKgBFAObewBy1foRMm6mJZkDsOupV7NWiGrH7j72oOUg/45r2UNFWbkFH2klB77znjISHQsVZ/lCvBHts0cawC8WR67DLNQE4vq6U3LOIvEZkOhAQ2oNJJWMvP0QihxdSwh2KUUPdL5OQPfIIv8MBAJKxTlip7qgsUS3Ld7CYFarlyHQj3mkTrfs3tudK8J7LNHZTfYDLHkn7+ucZFAGp1weXi88oHaGK/du+aJKwQXXS08EL+dybn9ii7RvWZeiKUkqwu6VgeViR/WeVQlR72G6O4A4LdSgbsr89/vTBseXAK4rdYBRntJt8KGJac0mr0QRMhegtq+UTGUyDFy5sqj6nn3C/xWfpsQ3SiwpMhK3fs4e9H1f8vexaDjZHNmcx2AzAWo8OBAitFAa+qWIhptaVufOwj60oG4xtDoDbRpwtjK97jGNSrnwdUy8q2gMw82mQ4bwVJM2bwot+aGSaxCKXYPi6w+ClVFrN5duaL8teAkqH3hFr+CHBXhNPdSjh/sDfk4PAw4wqV4FHPLvgRuo3ngdteF0ro3lxeBkKKDQD09Sk/tXVe9qz3a40DKbzyevI9xTW6W1lKP92h67ALmuIn9jC4xdb2dUWiAHbvv7a2pgZHi9oAMB+1qFbr2vh/on0P0woCbOVrcGX5sSGi6xdsc3nV4/c2ko1niFl4lJ5TY3NJFN1dg5j09Ie8VM/0fplnXYUE+QvxoOyNo2zLS7f+R3dKAM5qpAq9UFRtCPFLZKYzzOf+0RpIAobrZWSyX4lIKmNV2ZK8g4Q8o5pkHgzDFxYXIVXoEHSKl6Wo8auad8oMOVmbkwhfzzFWwIz1ql9sodO2UgTDbL6Nxlv10WUvLRtGOWwnciH+vBiUqqpWIo/tz85OabZlXuoKnH4MNlbXARWWe8jEBiaQJOZskrkM7ajkOZ9FGCJBayPWY+O20WCff2F0CmA+QxhpCajStqwyd5egZEJYk/iyWltcy/SRgcJ2VWBXUiO1+Y/lgzXxNOOZPno+9Tab08PfcQXzFRMFD3ZSIBxXuUg+QosgT/l7v25xXmyKBOgHZwPNBTkyUGx4aC5ZwdzyNKIq7t3oxKrKADxS1ZcmiHcl1E15noIecpuTjTr6ciZpuWO+R0AUOAkJ1ml7DQt/U+hdFxCDNlVEUPtiJtuPnB07JeMZ+cHT9s1HowjsBwuDdaOAjcYpqn2FteboTtkwnnpLYBujGhVhQWUbqTuVPywqIU5dVpXlCd8zkQ0NyiNQKLinuzl0xG5DgPNhqkcRUve6TWYEle41I7eVJUPvFeSWl6/SpiwJNsGFSoLVJipFtewDgZTffPMlkTCDNYSjb/KdVGLmwYUF81uuE84KxZGzxp2Ly62Uje21gpUDYIctCM3lHBvwDpSgqULpvcHlLy6WGLf+mY1uF+j6p/FBUlMnIbeufh1/lfnfWxU2e5MUJXMKYC46ktB25lSz2oLKHR+FG6xmck/IiEmTw9rnY7I1yNxRxyBT17HocNykOhmfAAL2h2bKmxlCW9ntz2tbJuk+xQqoPU/p5WT0m3gU4f1l7M13c+AsmjCqLls6Wna9WRgHKxRfy1IbpUp/Ar8vgqE4wKxsKfqnwUs+36P+0JiqLRUvxp9xT54OJBTP5ZBgg9JXNeSKpvSFg9pN36o/RacwCzd7z6A6A+PvU0/9VynNM8GyahwodJz9f+ElSC8OkRR9boMsI/fJ15oU09ZGOjbVcW+tlU6NBI6prBz3WUtXFWiUyf2xlSRWrnQ+rFNx0gdekf5Kmp7cmIB1NDp1qEpmGhK8AtBYzRi71dt2AaQgJaABumNML3Z9gRGJ4mFs7ZRQBSVnqwNX7XZNd7dlpPDVVzB2ZmEzxbcDqlPPaOBJEKfiiUcYKbKMje6hPkWeN71du9Lw+9UXu7MDJN670uLGy6iH9nDgnLGr/PopcPo1N3fS0rN9Z1Jt3Wida3/AXo46ajfoSVJGNnJtX6QTuUp4lx7fdqk19lx1KKAaKn1aF3uAy8Y2RD/IA3ovtwl9cSb7M4my61m+rY06tfnnOLKJ1FhVaG32JMiI0WjC876jaNhGvqfDkwSP7ZlgMA48pXMcxDd/YGVeTvGNA+yD3U8FGl8h10rXBHMGnpe3xoXrreI5dZzle0THxIGJiDh1+pDt1vAx0bs9KrFgkIDzcDCFaQVUD3nBBaivdP1VwMwetvfji5ZKmMTg2hYWwrMYxda9zraR+kBj2bclLw3hBYYwEPy18p5ecWzlWg8Akn3srZ6jteLBmYIkgID89CxoP+K+IHNhpTIAT5aVITTOTU9B7XEENnnDnAcvdzcalhZNZcOQ7fcAbv3833HPU0TT7csZ6fVk9+/XIbO8JyhgmVWlA2Lr2nuFJSR5aK2bqFe6Nm8QWv6lS0nYYTIQYxhlyeuRleOyr8pLPNopS6m60dFF8wFA2QlDKd0+V7zoFN+Oq9h823yF/2TAkUrsdGW1VaTJthUxmCEfP1jCBcHLYMy2KibYzkIYWiN7WtTANIuKLDCA2YB+NhO6WaunCJ5tGLZuBNLBILfuZIIyAJzs/URWw9ymkWfUCKxYpqEra3AlC9cMCw6i/Vg14+Cs/bYu5lhQ56bbq/AcQQzIqs/J66c4wFa4CuMi9wJAMp+gR6Tt5rk/Er4dhOvFQAdCsmTwEPzMxLCv4/dwAlTNioe/sHfxgkuxH/MTO9v82ECsYHxPbLA9Z+VM1WWMIX5tsRN1b189do5BMozZ+HHNUiZ1cn1C0uOuZjqHUTaCNDPkiGbbUpnOfOPtKbSyG8Flv5VLmHQeZy/INb2MSBbYe8LqPPkukGR3BeR/BDE7+0WPLHArlTd98NCQh3YsaZZ5rSwDsZjxbDldpadbRiXhbbSEPZbt7KbBB9S4tLSDCH4lq/zNLMXZQy3+ygTF8erBNcC6v9oPuyrzK319sG2y839mlk/mAz8KPGEP9fBXDxSJcBsEN0VDmbhJG0ySg08Fm+nMaTwnbfszfEBeERmloK6HFue+XE5jQuWbhSC2xf2IRu+oHzuzSytsDe/1vV56KtTXqgicozeBE6P+sZSMXwxmD5Y8yu3P9N8vRyQWdBe3/i4VTEbLVxaDdXW3LOZKrZvQ4hq0EPTfARAA78zO1MQjgLu0X5hdjvNmqgnLS7Ame/Mg7bss9KLhqEUPCN7WhrkkJt+7YUcT9Zy4cBDMaQeN0ER2mJ/PKkqj8AepJgrSBUn4mAeAY0B5VQFk/OrveUl5B5BER2J/C1BUQHB+m1auMdgxw+R79kxyXsv27HCjvV+2takR1pAhx5bE22qgBRAl9qctnYv9NRHRmxqI+TBTK99DBh8yey8n1k9/SweWqIy8MDMz/UjG3T8a0UZHVvmf8sPFqX5LWIBPYPUqDnRSHJOoMgydpA6WuBbeHST87SkG1AJ0MqOm3YHCIkGS4oGt7z9eAf7W4EBmDYKHt72U6baOOhnwwpoi5z02TwD3wlcdtRxdqqTHsAunxQoHq18oVsPsye5EK1jX4ynS5yVxD0XwmjNddkA/krLg5l/R1mTzrGEtK1qOEtqiXZxMTbPVbhkMq0bnKt/xeLllr1wgq6ggM6zEFDf5LtSVeRyvdWQ4rFW+f/iwg+sVu2UqcN2ggPynOb3dCz6PdvTIEjLaaQ07OVczhLIWYLOg1LneKdwZz2jw8Zl4QTH9x7GDlvWvrhhJRtjewFrOSkfi9oOOPp/lY8F2v0LnvM+8HGtnpiJ2KMbG4L0Y6l+3YiOMnTfPIK5OAYyhXY+7JpuUKeTSnn4S22GkCdT1RSgIQkqRVuz5ExrV5Koi7LcdHDiLDlrV/ahas/Job4feLk0nD90Orniel6cUhhnhSby/IyyUPoYGeUr4wyDBL25/ui8xWRC82QWcBhhWP4z0wccOCz9TuUEcbSkXS3I0cnv+kQR6nG8hkhrn6utTSbV5eiR01HkTVVPhrQTrT0YcSUq9Kz/jB09DN1dRYaBSnYnjfYwwe1ls3JSq/933zEUBj//uESY6k0k+JFr3n7ywrlo5NnWyQEsLaxJXkVh96r/hgSXUoT5ri3VzOdDdIpYaAF3ep4cxdEKnT6KXISzwSa5Wr4p8PvOHvprN3FlzylTKhrZUpu9fpsuPL3H3ZzxjlFd1Xb1ggcFAdDPjoQ/nDyo/y1So54+gsAQZXUpOPD83SS2pLVQjCH0QoHO/agB26/+d1+jrnj3sPajlcz3h9nKGUGNpLk6qxYhSLgPTw93dAZaHsiFiHMuaFF0Tg0ABQV4v2OOgO8nfeGlCx0wJMseLSyhaGQwXnqnXyusY88XxmCyGZKp6X3CGbVcCOuhXEeijqGtBqLxZsOQdQW2q84uFkCZNcyJ9h0OiAUNq/yhOL/FqgAE/is9aK3E4B9i5MQlxoyiNE604jEu+50KnrHERLxVMlvwaHlsUQ/xuMNvluOceo5Rh8dXerw5ZsZ9sNpHG0g3/qaWIYcM3D8baczURG8LMIr+2Kjwlh5fLxnkJf34Fe8QpgrEfYKOa7grVpqEW774uphlIPGZdE/lRTBKH1gIqIiN9kQBn5BDD4/5QJkHFZoPBSllYMpT2Ml+oJWtN0Rvdhgw9WDNJpY2ZcWKlXCoMuWOP6L0Nh0Wf2r6KMTZ6vV59/1wixD/MnvUZoUvlqriVz6j2NLuKfl3BBMQrmzcXAiv60FbKtOuwg3r+Pm2uPPfFXJM/o7yu8IoR4GBnZ4JUufsyIvAWtdX4USBhdJhmoiq9bvTLxYSrVLhFF66RfFAU8Gm7OnrFqe8fq/2nLNA8r/iDqYcoEVo990N5dK8LXxYu+p2ESPZWlsn9e3hJ+Os0aTF+9AZ/k2J8HqeD00Pq+guUekzdx2vm5jKLRXtKu0Rqs2RGi2ItbgG1G14pmHsUpKGvC2XOd2L0tXAwh4tVCjVUUdzlVkijLrzUtsIroHO3fGMHixmoFXUiUihfXXhD3HBbBC2pn93wXKU7g0FJr6tWF+azQew1hpIKXP8QHkAbX2qBYTm4xnpbaLLIjAZkhShGz68oBI2qF6hDs8PkU8ORunPhflvKtDXCJAPi5muA3JOjDiJzGurJhmB5KPt1tYILW7SQ6lvYY4kZUIiTcMlKr3dPGIENEZIMsBSQwzRsawUsAlI33KMwCYaiAMR3q7rwPz+cz3DuX9p5MEfuu1lgY3JvGrmyyQG3RXX7pC0lBKigyFLVo0I0We5+Xa+xQ0uZ9imlMWwGJxHv5M7Fp5Ua7KWLK7MFLEvEPYdfVTLC9V5a1Ahr1l5UOnavcN+SphmCb+2coAr4EN6nj6lMFWcue80kMCTIR13+JOPKtUAiV7jJul0RTP3omgUSaNGYbTeruMIMAmT7Ag21hH7T9mIo1WSwWO7c3Z7q3kAxiMDAJFRJATvGgR3jtluxIOoB1ThPRPYQAY6/JyY36hQS7fz77Zm9uBpGmv+BAQDNmT29SCNg1reWqo9JVzaPaX+dgWtEfx7A50lAE0AnQQ3t3L3Ct5PgUcHxxqt6UOjk1AaUBdRd7qcx92WK3W/2R77Y/n2++2Gv8h40Z5yrefDOgJ2YNODYHYQvK6hAou3QIQavuWMRfvM6Xf2VQ0gk7zVmycXCxmJ6JMfLd3L7gTfV0NX5ngAKooU1BhvyYNbMkNYxQiTsMAmvrEy88tY3g9ia7KOap47rn9Voo0W+hG0YiSjSSOX4s02ph6wE1+UF3rjeDEucyRPICwvHvTTleuPHnq6TFUdfwtme6aPyZKnKVpNsYf5L3f0HLHwRA4/TTTLXWUDiFS2USQvckdw9opuQmZ6ZF8dXGCamQHTOH6ju6rcZ0Ps1ZBVmmddcg+krU9Z9b7pFrSEQtum/q4tQbpNwKegF9vE6osRbuM6sBXLKvVKZLZOR+M/br/7Mh6Cqn3uAMjmrvnsT7rQnC3iUUS9wdYFr6XPbGwuLdudNKuF020qOFeo5sSfAu02XHCbzPIEcwb69dXBpgclZowQ5AmenVGeW3hQlEKrnzCuVEaOf25Gm8VZ/E7BRFtwBtrvsChr3L9aePeicuhf2z/ZaEiiqTvpS0fMI6ZcMJurxyByfdbZ63A22hP7M5aTPQoLBs/EmHEXPwmbMiif0UAbi+TEzTgVjyqHipB3gbPJhL7FnD5Uuuk72f8/Egbyk3ONCe646+KK16+Fh2aYsBeqfAqsnpr9PYcrkq13TW3iDHTvbCtOWSaTUWm8KTwE34bDV2bUsCRrTUE5LQcbdZMwxb0kp1C7gMr8jaL5MWXmLBXqbL8/N3rFI4P2xNq0LUZ9NGBHQgpkAjyVmnqkiiiBEC8P+mcw4hXV+iLAUpQUuAQS1/avE433kRz9AsG7L8+F1WsmbN5T3EGA2CVLp8tlOb1n/f1ixu0/ZQIpGOhJp/lR8l4XqTDe+0fu1cU11W7ix7oPVLaJ0P8Xe07G0WMB8n9tzxFzvyEpDy6XoVSROlW9nijbMeAN1CU60qzgCJ6yDd4M7TTxbJ2f9aW6ncQZW3NWamScLQRyys61TEk2WXm/cGCqVNqPpdGM5eJxXATXVYt1no4WLn6YZqDVJxxweOgxXbi8M6gLX3gdZogFO8UZj27x//SWJjJ77v7dK6HDKBQKPzYHbkgu3maE5gc1dQlVPR2vTHDKibWRd3qBqOyAJ9+20+3/cF46/8myJtIrP4Tveu7CuTWCJ9XB+BP8283BujofrYVhuh7y8qiCrFO1PUvKuAl76qyi0qUaP7bHkVF9bi6Hl5j6MU6RxgzNSf8yFBLGKElXROibxzXxrpxquk8fTtVMNDCrXa94MWYPJHB80qT+RC2avoSZBeFSCRDXquu9n6G4wcOklDDH3jmyjat8vZONTeZPhXtkNXDvx9vosoCz4qeeEkckrESC2PSNE2vKU66lmw7/0ocw3kt+WT0mIprykjaUqnvsbZza6GLsq1b3g+VdMq0x4aXo9tWYkgwIxdJY2BvVvldj/fqoKXIzwvp5JQTwzueQl0M3AYh1sf6a8vgPjo10d3FaXjduJaotuqkQ9PfbBYGiENSzcv+0nMKXLY5FwjdnMXTi5nMLgsGkQObh/oLQqNRpYeYoKp5VN+j2xGiaqzImHKxIeS/dRS8Mg6M0rHOat/RVk2p/5VS7PSY2Ulk+3ZF3SeDt3q2UaY6cXrZgt1AOAcUC/Mh/j18f7r0dGRSQRQZtf9x5O37E7w6YEALX4Bss48D9mHMsG8RtKEJWIF0o9+98/ANH8rjRvc/7VLx2o9b17pWsbwUzh1vqzl25lWy4hc2K/NDFKOFUsjVnUxkx19OYLmoFLTbHfMdJBFWJ3cR6dUf0XGYb1VSgWNbfEG6Yy4RJNj8mfFJbWy7Od3c3wzVUho6AeA1I7mGwIiCpxda756YeSCHng5KRMHvMxxtP276e/2Wu/XqGUlakLoG7sG70Q9oUdG21s1Yo3llOGYlP3BDYydexCTgQjkh+tCSbnHJ9atZyrbZVdRZyNj4qZRZTbw0o54uuhN8vEulxF+gXFlOenx89WOyMsvYHwwg107rWpvzwQsC6Aubo6KlSRflSTo4kDyntudJi0qoxw4hNgVeopN5ZOeJE4C7Cu0Tvo8AZ4nPXEdyw3WWMN74q888g52KmNCjCOWN612DEGTCZyMZQmB2LKTJTei5+e260M3f8HVj5nqVOhe2yYo9gvpdDhYfw4KXYiWoGOZ+O4OQuYd1/rFiQ0hzDqHDOUICjHaXbM5xbylqUkKCzspdx0kkzc7U7EXKyXVhdkk4DFP7wp8fmKVUQYKWirP8osFusiInbzj0pqTc9BF2NBa590vP8+yPBjtweg1jdKmJP8mhXE1czUJTfJbbWAW2imCD23b7CFXO++HkqtA4Si3c6sZRPi7slJuq3XRJGvup+GnAtuR11P6bURDl7HV0cuXV7c6Z1j306ZmOsNOOHiNTxFER2Kz9UHFoI33PXoHiOs55rntMHm/knOLE1fJS63BOPkl1tGAwizvrcFQYPoZ0kfD5m+CvTbAJbpEQJn9oCk263YpvO7FwX7T0UgeCC8uMMfXCJWNGpfwOz+up9gkUzCXJeAyvSOp4zIrQXlGuJ6zlbXlyxOV9NN0tIQ8y/NMMVkRsUcH4Fz5vq77j7O+A84Mzd/U3YacC74GBX8c5jhc3j2Zsgucn/Pp+4S0EPm+Ni9rX3CSnipLeT7IYb4B4gP/aMKQdariaogX2/rZwLm4/4NEK5sBTCaQhEz3WjMU/EVROdqlM0RDjj1Hi6ViqL8cbXlETO0KlGxVKpBPjpX9Mh2E1Pweb9yxAoTiiwJqtB0Lp0T4RXhx8mzZi8+I+9/K7tQz3gsVjvlXDUa1w8rQW7DJuCqHRwhroZizDDLRFq6Pz9sERHabOT12n10NtRbJR8Y1CZsSrGFeiAtzcEt/7NnUBQo1TEnXKTu7dYqMELhyt+Qw6aRlYlaxZ9BiJPYhx4BHH6M+C+6E8ZFIXhLxs3xwRvy8mtiFpJ1Rr16OPruzDMQAehZcBd4LwfbKjILK9N/oPwQGLboCU4vCFIl13Rd6fZr9xu3wLp1HOZ7DtJY/PVetrcPJij1xGd6aFL8tCkJ7pX7hrZoDl1e9OaLcDnq75o+7d133khvH21+Vq9wpBXbwCIM5x3f9c3/TtRXQnp29eYPhmojLdTwLRbFkTlR8roJDnzIV6NLsool+P2Nu+VVe99W4Y5gp8VJ+T3mktvuIvWwtbqJQ3HR/ZmJbtBqz8V9C1arm+yOHlhVueGEN+8/TQi6dJaRM/ZPfW7IpzUlW3e5jSYxiJiiR4hWoGxIgyrv6y9N0mWZK2YBNjVxnBUm+L4qTqbQZsO12F8CDCLRcxyQSvs/BW63p/+LadqDJR2zWoSfrT/w9eL9kYX6ftt/mdBz562gkdFbNxMDCMmekl/rxc3oaXSSjAbwSD2c9J9LPLj9clX7yjk48WokyN1chl6qerhAuEZqtBoZfx0XsQckRTD5PlU7BfxTCkZQuxYLF9zNDzhnfn6JZW6SqWdWDkdYiYM+cyhDwTyw3PeI8czf3EwbnyBk6KNynwI8INQ3Hp3TyqtCi7SOYn3ijA7TTNGf0qCm0ZTWzfcjlQcb6VKXdca4B6qIZM5RWwFAf8VESAfCyqcQ7MgprVl9Eq2SlTomhCy4+IWo48G57Mggacvef+tBTrZ12kbZpgH/dduO7BV4vX/zdktyJfwHZzz4bj1k2XwGddnJaW8vftW14XtWPWqlwEEnMZ1szWQ9+KPZ4WATYRQXMACMm5kts5kuplNCild/lYBxu9u04oRI40EH/SitfvSXezrN7oxLlLiyehai4prWyRxVEdIcd7xAkFGmyVK2pRRlaQN1ZHDH+IqKoEVq4/FPbq4L2LNlRWBkMx9Y6ykoZ7ZfbFGD3L/tO5yY2lRAukjLSk4viPIYkkrImAyAMw15ajo0PjNoKz3yn8b/zpi2beei4afFpIwaQdJXZaJP1+hR1uNs2sQS917HpvQdRIrHAhpbCxKnBvSl7sRKCkHexkNinUjrjssOi84pbibh4+fZ4h5zDxxWjJ5jdPQojdqRBcFjywN5fVLLikLfSWivb/O1H5nv8UVFxpSV5wazZd83jRzJ4NsEn8hQNtBu24zWX54mS1nQL4RZ/ttKgaYAzaTpCXLhOKSZdzfytRcknlnUpS6bMdgEMBoiiF5pxqzpoqEOxJOtBUHEJCv6oKtpaozX9+XA93XVMGg0zBPyb+9itW5RPY2HUMjqfal3yazvTAL5SeN05u0cYJFiVItcfc/D8+H7A7yfxCCMaDwPElksniO70Cq/FGpqibsXxAS+BgdygaiBP1Z+7rbPfwlipxLTbBiRoOyEAVWL+HNPf8BYAUqq6cxskj4YbQx/o9xSxnOt1eSnu0OF0e8wn0rvAVXsyYybgBosxxCHIx9k7twXx36NmosCPoGK5O3sG37z/jk9oeVGhC3bYYQsIXKu4wyhOuKoO5MM8w0mHKJbOXI9QsK8ZJsO8d+K07H1OaZMA6e2QxleELOPDCfBsrwPXILO3/m8inex3isFP0PBSO+SN+xpRqSz8wsJVAsKLsmoadqyGrWPIfnnWnxB8S3OEeVPuTiOaobX8qXaYjaoVMak1f+59clzJSaryzDLVRyBRdRW0YbM0INEaoZNsBGcNRPewggp6GzhjolGT6qvJOsQJuFMSPy2RFjZypvXEJqYvNL7HEhTb3/Aub+W+JKwfexaNpoVFrFHfXaHaxi3MdOs8ZK/qUvV8TQu5ewaeqss9SwbjQRrMQHoB7brfW/d1eBZNulOXUZ8rgl8Lal7L85iJrb296m0U6oiCKSm1gfBF6ATqm42En7MBvY4UWpnpdHxp+loXkfZ4BMwWQhazhaF55gLgHmt2nqiwUAbT0SkReCA1U310yOu1FNlfiTmC+KKpi7SEDX96Fwc5JBbUz1cZZfd3xS3+eJz0LX/Jm/7xB0tb55f60ZmPaDVQ41V1vxCzTouOCwcGqK6HA27P106DteihCSwXnAnyImKwe+9ne67teFxSOSN3IZ5VEhIi3SV1LYhlUV7/dKBkaI82Hg4KyY8wCR4tSZLM7MPge0YfOyrD3gw3YlxVcpKV4ts4O+iu7+9AVLGm9chTEUqjTPY+SbqQPlECQTO1WuWL0yzDsDOGJJEDFcuWTieyRWgYVqgRrJiWwdMFs8cWqdYmzP65itj/n3/GSVT9B+OzMtIX0Q2/WEIpVVMAF5BeCDjlxZtL3Wn89HEi46KJuYf9tSLuao7VYkl+69Pr7L2vriWYU53q6mRzoEW56qfCQaZusr2G/QRDHKpRbLZTN+vYPJe10wgvxG9trbtcEKDbRvWnrF+RW+3HBB50xg7zLVRBxjcZxRu8qN1gfm23oH4Rxkvuy4uuJIqbddL6VZlWtxV4NOm/PPcLKUmQNGUq9/3g/h/wJcAF9GrDnkH1snSBboBe+YtQMMClPs2peVLiRkBsZKJEd9sEZY93w4HlnzuuY7Tx6824vjLk5XnH1Z+He0z4kqii1kmrZcSAYFW9PZ3fJFu/ILZeff8NssPy/cDO4LKKGYUgnKmPYQZF6RPBzHCvhD7m1sH8iEI3/hZ9BpWC6uUlyrfKOEufZ5rGgennP4XYktLFBWjVKnu7ZgQOpgrduosTmPz/zzcqKSSEdTYr5bb9N1NUhvGB2I6juqshj5B7b4BZpjrCt5VXQ1XlFCEljczPbPc0w3uq5DGaFybN2+P1XBT8YMUfnWL2CLo3nMRi7ntI6eMh3BudgzFqdHiPukq2Cl9OUwZM56R1cnrMkcXaxUtUDKMX8XJ4PMYAT5Xzkd8lCNfIO6AeySI9L8bF/3pFxCC4+v2Ij3Z+V9AmzLwX6ecJuyeaX7Bz9Pdp5AMMvzxT+2EvXAuVVd6wU6+Ggd3VfyvW0FReRMRI76RFs+U9idHjPrLcVVVQOUxsu4gVNGYPADsltyokVxeyJGNuGt7hg8iJNV72p7JXHfBBC+rE92wMtCESm+1jwwjK5ufKSryiK94Q1OKFAABvQdzxy5PmXq3SG4bcbTUm1D6FaCf1tiN3cNTeIwcBphzpTL0mv79sbGojwsRMQAGyP0pPF5L4PPs10bIB0v7kwEBLvH5rOABGl+MRCvbVnIcs4/0pp6YbueBxBbJEUl9cP/M2NBP7cXgrbHxbUUbGw4xWYgBzVg5miBe2EUjB8+U2b+Y9y4LScdTINn753Y2taikzAdtbNGdaCwlzWvB5ZaUrWj1+SGlIX1mi8zO8aEGKF1sE0wTgcJHknW+6TKggcdzyBK/+TTWkx5etAVKSwmlTqdEzhMYuxuCmtSnxX3Ie/HsA4GfjOHjeAIpun/hJ9Y9B+a68XOWL851KP5iDv56E0KFitAk6HuYqD3DOZBGkK2S1Hk3tG/RqUxK66Qgh9K15zST/Ui0qJ6d5xGLxSSrtPczkhhmacYXM1VmG4JQ9XbRy+LRfUbM041FZwb8345BnLUzR4DjdyIIcpvCmxs1NXZc0YdBbUqKzIALRDy/iWUTEq75QG47iQ+UHWCFXJyasbdQq+Pk+ziy9GVJHuPXnUlisHVSS2i1EQ2yJDKkNnKUMdKSeEVIKIycZnmCP8+De51/5vgm9CXTafGgz9ZTMLUDnS+6ySAyU/S24IDmgrNzEEJxjT00/SB5XEO7RmkSaTc9Tv1jcnbTGUGRF6ihDhVW8HQDSXra04m0u7V8FD89RWXtWaetc1Gsrk8uav4S9zRgjNZZJzTR533ovMbgvXbJ4MkWDFDam1OexgHYQegRJMeKvUJ2CZNf+zvt5ROF5uErvRg07xKmeo8fhyqSz2Byihj3cvgDLL1HMTMmn+iTDgMRYT6bJ+UblVluE7A3GuV72Ohpb8cDW51vfUFT1opV/Sipgz7DcdY83zmHDAM6/++w/2/tWF1/rfdNk9kwsr05wPvq2mVkRoA4Cu7XBaFxR6wURQoe9d5n8EscmQn1lvyFv+5JycIPMUv6NFbZ9/3cjol36FiX7cQN70jxZ+YJ9p1dbKN8Iz4Wch+Q84JOg4FdqLlug7F64jABiYoRqNdG6AnIOsVsEinCSDcn+3T/yYEXtMyj8PyEBEFddposWsllUZBgO9sYFmeL8fUAatG9XxFn5A96OnxGRcq1YvoRLZzDZDZ/6lk11Dt9FwUsg8OnOGXIdyjjP2spzooNwFXEMEReMNQl8+TLQkfd2CB6tBrHU20LcziutWfJPgURHJ7rq7fUvEifhXrV8bGZCWUtwKB7OL18N8V4Q6BnKKyG78MbmOZpBBnHt4apMPnvg+42LtDKX6jk1srCesi4NZtsm2kBslgo04zie+nl5OiIwIGAM+Uq7VyP9p+nPzqKQ6elWUcwGqCfZa7OqFwwnUML7W+W2XCnRsuA6O/dJ5oqvSPmFjlh8QQpg8g7g7P19JbuePUZ6c3Qt/qzI/u2eRykykE1Pulj7fpmXPyVaj7EeZwTiohOZYJbtRZfHD4jzxW+dOKcouBQqt8n7tZF/hTM2rV3zA/lCYdr97EH+/GVRBIjwruYkp2Yhgrijia1ep2+7EeLUau5rDUeWKDU2tEddaP2dWQz5z7KGzYUHM1nQn9hC/0J/wfUA71Itziex7599H96ybP92u08MLkcDdt/bLZRCg6UoC5RfWSZhQk8sE6/WYSz28R5+9VWcM6G1N+AxunCF2+UZ95+TfjIQlJpglN8zgDQxIK55wMWMmQSZl1DAOjkYssWJbOnsnG9mMCsVsO13AW7RrmkozZmOBGkejcSi9y3L5EiBypkBaqylK/excnf7QEZBTyJeuWvE22t70uiEUiHcCLmSLKKO32Z7JxWYegaUg5IpDQnIEJNRUGpqOx2ToMZmVqAmypJhDNIfQKFE8NTjO7OsleBmpWPEEf+6sa1sQdg0rNUc+uKdH9Q8+PGwpyChYjmlVxfaNvM/hoO1SsImwSKrNiDEwoQft5NIIpuZZnlIStH4nJxHfEzUGvAc6lglcObPDEU3qCKPsolIWTtKrmL4BERRalBji5EdBHFxPQH/MEli2kirADvgBtrISL7XrxBpEitRu8hhi4vPQXKPcOr+pDnSaffL4QLwxdvKHwSR+bp/ODi3dvrQb3UVAtZJt298pvSHcVsE7LI4kilnSmkOygTH+sTw6shA+StRkomL2yHsxf1votL3wTGF/+1+L+5bl7tDZrTCH4KitfLLdZ1ZlyC9+kKmfsvLk/YR7WPvipAQwZ+nSKIq2CRVStgGSWYOc22qeq+W4hF6Cv+mLR9urv4D4Gv9NGiV52ssJDk18esi95wIcCZFf9JDyatW/YjPXCnQ0tJSfG+KTAjwMK/P1UHMB6SnY2nSOn7F7wguprlofUH/OmMyx8WVrv38aAcSkfB1scZLUm+q+nOejRRNM1RtTEujunBXt51VTUmm5t3oNjmUI2eL+OT3MUvNqLljZUhGIzAJT16Qm7DkXldi4gyDdNF7jPbCqmCC/esTMJEDb6sTPHiYLvnGgm4f3S3vy+nFEIFiLoIucRL0m3TAoCd6T/iwXAeBWP5fy8gzXXuKzBfTsfU68jCNwDEYf3wdScCJYtYT+0Kp/nmUZu4wyha8FfGEH+CDlDU9bItXO73A5ebc5HCpLd9pYnX2OpOiRlnjKY80/kX0L02ghmco5mAkd4Qv6mmyCYfaGxLpw9gcxEIzy/ClExaZZX4MOCqzoRqvJ4Lpe4DfniH+ImPkd4x6VIJGW4B44ke/Y92N4dky232D9EaVhHp86Y4Mm1GPsibBxBn7euK2m+x39AYrxgo+wDx5Uvbf7VUeHifZ3f918ripro82VCmMATPNozdNVcLu/qtYhhvq7l3/avcVx2Qbc0bw8r3gBtlm5qHzBB1XsrUzVhmCC+N8qX+M3jIerT3lzit1KCaLggzyJxeiN040IiCf875jpEaHU4ZsBncUIL+Yqe0c7p52+/ZGrvw6wW1VUriav0oTWPgKV3PeqDUsTKNz0f6GjxMiX2AZ3ePau/EK+uCNrgWcpIlWPsRwsO1teHjN7BGZs2ReAYPmsTsUjzlVf9TZ7qC8okjqDx8gI7Wb/36yRQyQDu0Du+v5mNFG+7M0HZZ+HRDQf46VIwtQCns6DrQO3yK++NUhhbZFZ69I1iTB6zB3AAyoba/ggT2fKZeVSO8oB+3pOJ/zDj+tQA3lqCXvHtkpsH7d12cVJQA2Tt06BBuNGwYUTXARoV0vTbNoaE4nRR3sfC1ZiWljETB+G51oiRfmNh1PIrj07fZ62w8wSLEcQxfxPNuD2+7vy1pXdGS/zH7bS7l3+EnqW5a1RvowFiWIQj2hS6ejRHXnM8WLA1OALLQ+Y5fyVm4eGoLeBtqXVMrDXjaNXwiv6G7SPGZ5LrdnsoIagk2YEqjshC87gAUocQ+SJsLHzI7c2UUXWPFoucPrKx7pnHMaKHHm074QNU76SPsXGU25Bl7hHqz8wnnptm2P1ugat4DByzcTnrwMKbKshzXnmuat4rqAiY8oY6LMKXIJdVblKIW0Q5NMQdij7drOcoOyPEIxCxcROMLNxQC3bwHI5o5qdqtRGUtYnJ8pxNDL9++5TKUKsDxVsoLMZ5XSm9eqCBXcMTDEQpDtWwXGJF1xl3Fnz7qfPYNkOwh7+rFAPaEGXK/wwoi4HKZ0v7oeDKlGT0SxTTnG1QME+BVHTEn9h2W6ByQZnECZ2b0eGr37awltc7zBXKGhXEDHa2kGj3RCGjc/ZrdubTh0CG7uqSyGabTsF+U1ZhOCh0f9HKa3pCV+F2bU2YDRABlROJcOghOOZHv0NloyvnjsD5q62pQjQ6Pp2I8gFTQ9kUQWaxCURBFJmJQQ5XnlmMIIvatSqZvxME46q5OOYQrFHtOOB4AGiPbCXrQeb5Utrqi5+iwGoGyEQ35hWWiUO1PA3gsCSP2xZp7CsSlRR1lNUjKIzVsiMgfKSAb0IeYZrnzxa31SYDylWsnRvGcbqETXA5O7m5wnSWaleMEbbEGTpk/n+mNiD8cSV8UayWCLMtb2KlXvdj3etzMCgcDSgIbSyha35Mzf6gFUjqmrkiNH640gn+Mrzcz7+zEhq7YzSyWAoRphRD6sNOkUVdcvmDYqQPdjJoF68G8W0T1Vaed7zsow19LXZMcuDJSgTWxFrXOzaBy4+LuOQhO5kofvxh/phza14naT9yXFT56dKAxrB+RN9yem6BdCDRDzuENGRk4WhnbzNw5b4/ewFjmJ55E+LzvZNgvLrPFfzfpJHpMH+aX4h6pKJKcqpYU2u+P5ZyM6zQLx2FkKhShJfglzk6Oeo2M+Rjtl8eGHmSp+hjsUYelfO/xZTO+7VTvWzXAy3im8e1YizILTjwhGC5E1SwcUK4tDWKN2lOhCdrw/ivwccFWR6nFgZOEWjyZib2HDb+IMyVX0SvSDeq8mGNxkbra+dcDffbQLd6F1LAS1f0DDpBBPxFD+8sx1kYZfS8IY6R6tU4igHyMPuBMni9pofIyvl6P5xqSVgvgo3H2zfRP1z/E7kXKa1Zxw2S91iUctkMWMfZi2WYtIeHSDjNeo7dPgYmyvi9m4xxoXiRngcUnPIHRfq9fPzFd/iS4mN5sJj7jTGuDVFoccAdCSLDJejxiRwdLmLLlf6h887uCqgEwuZPOwTlGZs2vmQbjr8KYEVbswRShUMxbxGZgLgyqWH1i1usiAXTJcSoV7cAS20mOZ7cl1Yqbgw7L3xBRgt15YU2r0E5PtJw54Sg2CiTLBqk7eroL4gXeGk6NLBakDMdC3z+jm9AjCGWPbzvhJlEBrTKAKDBQxJk0/lyZhXT5MpqS4mrXi4fHJlOIIsk/YeuDxkvixxng4GSn/Y1f8bsmPQyz+B6NVBdpIQ/4FGE7dblEyPHS3R6fO4+oeOA50h7TRAA0ketaYLCGruHja7oKAj/4DmSsMSgG4jC0YQLJFqEa2kxP/SKiVRX+4I3PSz5H348IprUcJYUguLUZCUfrdotEMALVUIfz/0DMYsmEdW4WJ+XQq/NCSY9COUKBy1NPMoUfpcDtoYNZdrZ/hVYjwmuoCjMh8Thg40riRwQWz2Vh14dPiFCaE28Bfd9b6ZYrIPIPfOE5InKMHa4J9utohqBt2KuDpBfSP6Bd/a6S0F7OPIjaAl1JIz64my+1RcMxOqg2qd9xkBhoCHru0NrTIUxrJXy7j7Cfx2Pe1k3gl/VRnEkHbJX4U53DMNLDfUuStFlgJ7qk1cPbOD5TriMZFawy2qUMIJyo+DDL3LxGdAFr9URkl+L1aXEH9optBoqI/QZlw/yrP8WGXm7aElFfYMRfv7sGH1045yA/KmeJ+Ahcqth2GamTrHadrYQwlUKPZKEw3XGbbyF4YhtNcyauMMERRoe27nQZHScJPYmk4BnCd5qtloqbBGZ0tJgozsHhHHXAf3u4m7fV1anJUwqm8xp4nhN3J5+ri/ET9It2bHRW6ABULJ/RlhWFJyahHI7egwqLoA37z4457TSN+uly3SFkl40z9nVeaHijZeG6TtqkrBf2Seko1qTKwjT8Qc6j4Fg6MgVVJS/84ZCG6jrK1w4JyhC7yW7ilw8FoPROTR3VJTRmwEX/l09nU4psFKrrrGkNjCHmJTYR5nOePSgVi8o58ER4pxMZ0exreKfONfD4IMLK9InkdYBCYXwqlO9e92vO9VTjMoSqXgPLQK93MK5GYz3mEmFRud0ecqN1LPZIAVqczqoXYnnF4QlqjbD+nUZMrXvPxcNOS4Nfy14eGSnShWkEq3FKH/RKI02Z8hm+nfOe3y3gcLt3OFGKYDrSdgJtG56P19axYKJCxstcaPKixy9B23Zc3SVe6WhZfvYamYMX1tYOG0m7j6kobD01UFdEOF2mQooooWQIRxF/GhZ13WERR23arw8HVDi4gCgJfP7vh10h/mZ/6SZ6gnSZDOhs3BHFZtuqEvkD+GU8EgyGXdpsC8rpW1qs0rF9d9oMLTi6NzR49QEzIlK4feWWPQk/+eDREwRLtnexBmx4mx+TlplhZ7Lw4op3UvkLgaKAqVmGqx9CAv3cKsL2R4oseDEDC4sB/19TTLz/C0daHYZbdR8lAYigpOIsKzIRSycvefqBw7iHy/FF7QtAu0aeT4AcOggNMs5zo32dechCF39Pcxobp1uaJWdZBAxCj2FTFqx4DL3d/fESOHjkMd5DH1TK3kdi6xDlCkHStC4N2kgz187+Y/VZW0pZQqERpw2ZZpAMzVeDdN0NJ8Lme1pPrYeSHIl+SqCu/GiLt+IWEpRgYfJrS4X7JRYYtTfW0ZdJES4r+8gW5AoMB4fp+64YnvPf9nBBiLLf6Y/spiPMeZp2BWdCLtJS6kqPjYcPNWXFSUgA0My7O+Q+HajXwXFM+khTH4YwTOC6zZc3qMk096Q7BkYyF4ytd+6tinKslJZBHUTdAFPo+HdeOm78fbIflRAW/7t0w2kPAtZXSwzjSRc+gjIv2zmsU8W1nfDyFeR0okGvwM5EXkIrdKfxGiAzOr+SqeVZ6Zzhx6ECLrg7aPEMFg9HpCGdSkpKU4QmVqa6bUcF/t0g7P/4eTezKfzMwuW38PYQkzuo31xDdQ8qoXzZLmvHlUyk6TfqB1E56g+tMyqh8Cl0VcumWwnOeVLa2gGSYPF+j63RLmQEMoU53sLFdRJjG/cPXgHswT5PLcHpvXV/v1BxoZGyRek18koc5SgfrueS/aMrNPQLuToEP1/amjP5jbZ1NZfeVSR8XPl7QkIBOsllrqHDzozgv1fOUOnYCDHfcfxKO9AYO8AsmOsD6BettYvNJypren8eSP79z2PoNPGE79mqGpFycHntNDH085ohCXlxxW2V2VTXRoLbAP0YSRt/Rgh88X8Aof3jCVW+8zAlKTJeEBdV7YEvo7YHlZsGdGCI47apuooH6nlJ6+D9+KLv7HjDCLu0hytB1fEPdWMczqYH6mJwrfBO2PwQWie+xGrSv9sSWsGlu9HS6ltD+b2OiUwux35DlFWVN0nQKM/4fov+FOUUxYNh/utH3HMVl7PG18aMX/dXpKb58WvJx10N0FQVA4F/XLIHlbubGTWpCw/WJsLr6gRlZcjP86aYePUjJ45o5aNgyp9t9zP1LVdJ9fM+SLHK9QaMC+RGYRtO1seXVky/3mjR7l7PMajyFLY+GfjJUGdXqhLunR1XIsOlJ0rTdSyVmt0AYpuw8vVpw45UmgSBC4GZpL+79tEFQBzYpMRBkrHmIVHDF5FjZiojgfUK+0JFWJyD4NbaRy7ad8GZqP/pP/GoNoPnpbOVd7ckXkG2P2M/212A7ihelrboP4TxcFKKKyvSrxi+VKKzqDwHnlEV1yUYK4nCn4t6mTCEkgDu2+Vnxta8imRkiJ7F7i+t2hFFSnJYOfMEkM72APLCZmjKW+ZmfMjl67tcRV0FP/aO98bLE3UXPTrlnJCFIDwzj+dggjCo9wGPBD3vkAPPNSPVDmuemnz+mzUtWbAer7D5cppx8b/vv8cVn5I46wtiZrUjeTjgxMoB5M/JfsHAPhf9SdtxLpgEpHEw6VvqDT4ZM825gfUmIicmHAh6fzm2qqAb9/ZOA94EmMrITiu9SUyrEPmydfxqZ39e2QMp0ZW2VKDnGAFHMYON+jndDcIqb7dJF9SNMLOJxHaJM6O6oxYxFzgaU07fAmPxHjUwlUTV1iUPxIkfmiNuxR171QP/Hg/5s/9yJSdpXUtAw29sjN0KtpB2GXV7qJgAdy4wlDCWUSdZ68h/v2rp0IK0Gut1ivA04EwA30YADT9aBGNxpLRF7Ek3ob2FmNFbfTTT4WgN3wm/Af9DsirNTWu6PGNKJ7WdXdnLTWp1C+kfY5jGW7b7cTuY4meayCoiCyb8pS8CVAmhUzaWaCNDU/ObSRfDGdxbxc0ff+nHFfjYNWjg8jBVBjGQExLPgfknKxCoDbYR/0zM59Wp5OS+aA1AlNXnuK9Gb7h2ukb3k0pGLL/FVZp8Q13xwaVGnIc5FOgj9jFa9/3WZRNTjO9RG+/y6wiQC+tcM1LWD13CDPtFtDV6hRHwDBMBxyeWrpz/eLBc88oOwG4bfZo/SGiQYcnLDyljaveevqb6WxUFP+MiJY0GsmPyxFiRTNCu6TV86ZHNsiU6dx5fY7uSj4/7dchMsdDsGuPtztTYAm1gbjKUrjIppVA+kcDBA0qcXEKdCTN8PL46wCCASe80ERRCZPLwypzTNimtNHzG8hIxaC/jZRn8DffPhVbht2YL7IQtSMO3IJoODuI1b28tb74AyEhslaRRJI+Auc2/T/G6yVdGU74Of9M3mfUDb00VXKwB1k2kmHg1UV/2EZI0Ij+7vcVHa9iTAFGjBz5zJBCqRg2ONP1jJ8C3IUGQYqdOW5HVWdtOw4bRfd/grD0WES7REtaa0bk6c9eOYM6OsgnFua4gl0XhvAge6UNax69o5r8GbVfZMZEy+nzYLqOv7WPcXSYmsrCn7TLm3yhqDE8Z4xShdvJsXSym00oADMYj2XFOzpnSqzlGRl4BdWHWjnXnQKi2GqcSIgyYDDSM+sgOwVxP3WTCBhDQPyXG16fVSNPjA6mGsOsCfv3S5XUNFUSNEvkjH2myCLYl8voGvIPz/emLZzQE3QBrk3yVqVGiconRvmn/zLJj05ZeT5piIOboOXdenO4D4t7NgHfezyga2Sa2/ziVYeanZ73s9uycZ9M1vbCXQc7t2Th13yj2RcGCYfqkItmdTh4OwLG0rQmFesMEIg7rU85YgEc7CCQ6Waq33nfxGnVAPaQttL61cRUH6M3hT3gk1DnMLzrpvJm3l9RDAKWEFPkdXl8U8OamawtsdKXTEu+FBBkfM9W1p8DDh+7gU2Pm3gMxXTD+luYl6AHR027teMPs4wBxwsIFWk0FtR4lG+net+f0z0gYswc4eKqSaAWFWg9W6v7UDBqTB8hoy5nWPXIEPIJaHndC0sPJUzWYczf3oFuWxFD6ZRJzmKCW2aJqwVy15Tm1T+72vzodllVSruuAWCNvqeuf/PFHKqad0U1hqeIsX9cABEcXG85J/fDMZqj18XN2j1EwWTCW921iwLovylF4XaXY9gY4FlxaFmdT1p0rVVw3rgUKUSNe6dugpzkcl+fIUgcEL/pPom4UrNiCBp8gGyIT4RJd8YVVjkwxdZzH+ESKtlDa8aEZ8nr0oc26WwASxf0t8DgJin+ZAk/TlEaIkylUIJK4Q8JbipVSZWicE0q4EpCXAl7iYleuWgZsx+e3ysxp1i+eiy7SDS9ha/TmjDjotFpSuesOX+YA0AHhN8ls+rNIXh+GPskCes0G14R/tkxcwlCKC7HvxGdJfRpJ6ywxErizGEAxulpNPT2bpfd1+kG1DSjfugDu7Nl4RwWpQvwgiMSuqK9StTdo76yeQNH7j5gluGDJf5hm9G81QgThTWoBPsXZHpS60F7+hp8lrvSwofd49/DYHeNXdQ1XibBXd6mZw1uvtoQfCNWx7yeMkQmWLIoUR1yZqB8ddpUKAAXqxwBkdYqBMgPF0iDqFCnw2CSZW8ILaN0wYG/bUTEIhwMFfbQLS+iZheEWV43nRkzN72KsWgOunPC8vV+VwnBrn4eXlIv2RG9xiJfeDrR3KFpmTIf44ikgbPayKwdy0GC4NB767HwBX42/o1eO7Vvwcj9qkn/Xgq3b1hG4KxrJiTMaBkbfZvvL0P0rL1gVFUHIqWw70uTRndbb0BIi0CQAG74BjRc4pb1jb9ZyMrtA5jenOo+sJm+0rpUNzFOYO26eEec+SGif9Vdeob5SNHeIN80p914ic32Tse/1rG+q3/7ReB0p9vmTocshtvRCnl9Ec9r+faKlH07pkxKmSYsvf3pwft2N1kH92A9TGst0C4KaHrWwgA9GGTFNbCl3aPvDjChXxgybkOZr4aAowYRih6PfBcJA3UyyYHBth0oJQzSre6Cfxm2sfhCkCSy7m4FbKC0Clq4opLZOJq+ctctqgq7BkG/VQtjYnzr1qVFmIE3o1jPta40vPvu9w85CSBpD07F1vi90TTTVQqlcerK7iBK2nr6DTZ81P0hBvQxFfeOa33DKYjJ0XRSZooS3CySKEuhl5tLfWwkK8IFn83nHav5BHsw3jqgk4z5hYa1D+rUpRKLF7z5BVi13jthp7eyCDlKru3l/c/CmvWDNsGHv24Sf6oh7+FvSWYt5jYySC7CQZl+L+GjRfqWCFMFeZGFKWw91uf447MOX94rHlg/Hok1dmupuDelr5Ho3NqvoiwVPpRcLWoQf87AD8qiWgF5k2lSc4j5ZhUuGgfZUDfkIfLk6DGvx2EwbKPtuORywKlGpbkMyfe/Qf8M64N6n8mITSvWVHb9lvzBVWHebqFGTxZm8wR2eCsj17BKq0Ukl8xYhcEpgFUOC4y6OibD9pDI2Gik+Ahn75OQ5r8tZgGp0AefKP9dXq0q9x2tgsbHz5BoA4vrN1InnYHtHxNwUN6wGxNPfvnRsXqQbLR+Xj2WWAHHA5J12BZZdQm4EPg1FX36OBZNw++zSWc8+Qs/cZINq93mZUnKCsMQG6yeR5qzTLgLOl+cIFmUZs2yNyp6LBq3Vp7y7u6bAgRKZ7y4xGuZt/yAwpBFb1nf4PVt34mdbKwwhrwGGCoRq89LEqtYt4lhI0CZKKR+IJuJjsFP2XpzCUvJyP65OYrLDrqmi92xwAQ26WILPRGjcGBLaDj057BwzMNJZj0bLN/ZaDU2LgRru9BKJMcxdN/QsOFnu/SfSqibpfS0hZ5P2GrOXarBvWRm8z+TqbO+fvGgUq8fIqC5vl7F6t/uIx3uIu2erw7qLNBcR5XkaKTApLq6L5dUNBXTUUSPTVoxB775EsZ1dmsyzPsuGz5TqDMcQZpMVFeI6UmfHqpGrrH9fHIMZYxADp8HEJxAKPSYDV0hUE9BMiRRjweO5bE/ODBfFpFVF22+VMo1IDmYOkfE+jCOhPS3O4bGjFvj8kzYRxgKpeBt7yTz72hMALNVRu5yELXaxCLVikV54foTbuOPCfls4sgGTwvc9UFtwXKRbDAJWdg/DXycbQuB/b3uBMR052pt2ZnxTt1vcVHXS1tHw6aqXt0MKBgfKMFs1oWhVpqX4Rkx0sCP0NkT1xxn6zg+M5fZg6h1vY+gNIGWH9eIq6uYiwa1z9Mh/xdH4TP/6ALwfcMTaDZ1EnkU6UwozSsHljHhh2oQOqx49fs8sf3/umscKIeQM46tyvXx01kCZ/a4PcJbuexKovDQv2Y6f2zpaWqjCYiOqaomR9e/rOXHI86ILfwScSLR/4f4ZUVmvoHYQkVV+pFnhA6mIwRGwepjLDOocJPdyIeqLb7mbTKK/+biQFvhyrAVraqf7iQ110A+6ag3fRTIU2T7koIePy8b12lZcPI6FmaEYY1EZfXG5ROEQZk7pbVy5iavKsiKyZ2Xq7K8CeBVKkCTN+bn3Gpq3hDfe3XlxtusHr/bndHB/8/gmmdYoOxC7JjiXcFtEvK3UkQkLkdnUkcTJdJ93fTU/haiN++Y3zvF1/Qn7pkRvcQrdOzTew9N3Np5QSjil6R2VlKk2lV3uulKWraG/7CbzhhMf1jySWJwp6eA7NMdTaX7U7dejkltt21SK15BN/4Su6IntCwGQ1vzv1XyLDSFxAzYqGa6JOO/jEofzJ4j0nkxj5QjyHYBNtCOCBKLCXR4UBEAgYLWgJycppGPY9relEsK5E2SkE7EHvnXq5SfzZlAcRep2eK0i11jVaSFvk5t4+g8z4fUfu5DlblD9fijqRoBXk9aczVGZvzEtwPb5YqpKV3XF7y+3vh6XJQ9gcUEKZSUL/blXnfNp/LNTp/QLj69YVBMPurSSrb/n6P223UoGHE/Dz/vnc0fdDyyg8tVPdy4vZdK6XGr6qzQKB9TluonFaMVYBBvhNjW7TlVFA3+CoIAHUAvL8Ms7Y7mkHhjq4cD5RjdSWFzIu+S1XR2deREK8143fzauAEyBkoAz7g4KaPW/zIJ6GPCnuAw0625NWs7yRdME896af2YoDoMZWU5bzOMk1gozt4PDp3+8ap/p9NX4d6a9i3odIIFihvjTbisg0RORhphmpwZ7aOEWr8rUDUYjJ/k35I85Kt3VkIf/DfikcjT2uiWQ7kFoWhhYPzTmcM+4D0cNQmrvG3VlK/06z9Y6/t+lmATeGa5tRGRbcJK+bZpIM4vzuOCByFrz5Ya8wVUXBZTeClLeGWZiqZ2v6hzkNq7Xhj6crZj+b27jBO+cH53CAzAO9CEz1yllTJNU0v8zrTJje1JSVxqFPNLzKY4RgEWG3PqZiJ/xwfNlIpQ0MYKTBOqUlg6U6dvXjB2e8fpCMhKC4850/3dilN1ENgzDs41iE3v0YIfmIWXFmGsQdt+47rhn4HSEJfKjZKMfImfiVpBhM4eCu/Sw7xrqxWVKCKQS/+OTddzCvzxjXI4OwqwzoBZZMenjphBnC+qlcm+8wCn5Rp7R39My2vrIj69YK+epYj2r1J4U53qUnuTjWV6lBB6dlKgJ0LDc+gkoFjoZJDdSiv6KSskbDfiLJmD9hNKkMUNrpB5UxcdnVhsrfhiesjeTtgBlvio8Qp3CEZ8coGu8M0bzfNomcbPHy5LCUchtIntJRt7uUatMLJ7lemoB5zT+wRYkJcZx2F1XwhF2muUnyUH27H+EH0ALgeMd41inXTEbkthicqSSd0v6aIwHmQt7y37IFTlKqsJLII1wRmCu+hBetIZlgf2ooahcDU6sUqpzwpeQjp1owdOGkLSeHUu4qJ/q1UO4N4pw3PuXcwdJlt53irh0O81wyQKK1qWLynGH3JE+7VD+d7dNFjXV2CzStOcBPaDbGIJTdJpjiQquvZJFYIyNV4yzTy9auG2x4SHtFDgjmA2GQ+lKNjb1NtYyXv23NvM2nCbQ8eq7H31wCI4GjOkdd3bjGjN9FSdo2oHhAiO5yL4EYxeMF8Wy1qHWkOXXPp0tLuNe3qPSssKamPoeEqeGfY9cxXq6n3E7C+DKaX9EqmjOUCIMcyCIfbMj9LWwKB6V2UHb020bt+olYOnRDGc8llH3k8X+xmrAAN1FMPCQGB2o9gg50wBAz/y6m/V946uAqZEQNzATtSg+ya536bBXI3+rTnAzJu3Ix6b65R0abd/AIzn2yW6Mz/7Iy/jMoqpEDaehoSFOgWcdgaNgbX7lxdK3XkICyjzrLZ6hY+M0G6gBY8o+JfabLoBnkl30yK9iGAMpR/Dd1+0A0rhrqc6D1ipGy0mO7udXMg4ppQ/ZVjOV5+UmSTT293yDP0FlRe+Bgw0UupKOMVCMQzvVJ/PNqghnMNL3FzCVekqwhM2+v9Pi/AvLApJYW8dKimV9eqfKXWR5rCsdhatprg//bTAIIDLqvbRnhdoMm4A5ev/EgGMuWHxbnN3mJyoAJFFPTwXBwtsNmnxChGeOsbtj+/Xp85r936hWGvhQ/9YghgSHXs0xbNuiJBX6rIV83ZJFEu5rsgQzF0aFSRVpN35TLZbNwV2W7rYAQO3j3fLkH90ft067xevtQlAITjZRhab7NtrhmLBMC+nGJgMxgcOoD27COdgzDSLWqsvQ1gmuyQsSoqQyjlbgf8Xk5kMSCqbWTLDBEJJtNtjW32jLsP/Bvk6vVoxXeENiqWVr6osjUe82r1LmjVg3S+LbqSlqfy2updxqRaqhrJApPC7WFJza7jTwXk32YT5mhZDMRx/LOPkgtU+fQbmIKLYyZqHV1VAxl084Rfp3awCddBhY5FdFaRU3HhdgeIpguRsy6s+Y8tRHW2dEjwahFzasKwhZZe1KInzDu4oZb2sbSsSW6dCfXJXl21D6cRYNx1UCfBPIvLNXDwmBKMRz9L/mkuPieXxURcSo3SnCvKPQRa44XXD85lJc/eEoH6sFuARlb64Is7/+ZcZqupMPsufhGisTGDKqBjnlWlHYjhmDM4MH6ycB03b1Q9jkII1vqa+XXZVLSGKRrw1nIHICKqaK4wPlUMntxXnZ+8K5m7YxVG62WsCoBqfPzNEsVXzzjUANmIi7Kv0HIOE/V1IiDBg7KZpffvJLW0hB6IQpRBx1tWaCDGiZsoqVrxONNs0SLPTWqnqz9KXuMe2jAv8FtfbvxvzC1032KuPE+MVQpAZbcdftFSNJceJIP8uftIuaGVAUOPwQKu+EC43sP7XslsIZH1Lw8fP7nnCUpmSQTiDh8du73I+nK3knuY2aXu0cBMePNn1oA801Ji4gxPFGkoPequef+o/z14kE8Y+0UG9slbAXrVkj5wf9qdHAMm7z+a0uZBFdST6rv248o0W+ZZ7g2n4rkLCusC88eEZB7o41SluO8XWUKvnYnA/nQ4G7hCdKMrJLBGUJDp9uVKJacrb3icn/Zq6w5InpoXCU7Ynbo2Qs7Kl5/duudzby9MOfygN/QMWuLNzizcTytmrQ0Z5ll7irIeCa4nB6h0VZP7MazBi3c3impLOBEwz1h9ggXMC9Zumj4Bo3netnM8+qktUo9pkZgw9ZgHP2lFPmJITWdu1K+Fp3turTFt1Wj1MTF3mWTmhKz1Y33+y3g9uEudOVd2f4OIQSSRGMOPcLj7opIwnIs7wkMVum2aFVgOcVWF3jA5kv2aEjkIAmdfePPhHHkVwL9N7mLin9aqIK9nYY676/KAVSMFMphHrZ64Zct/g6qeFwyPFHfuJJC6djmmNsY5oX3/l8w0xdwYAwpxU3mu8Mfvbm62fKAGcV7hAYIitDWsdqq8LBTbnsUFtvDIHkMXjyEMO2FXNXv8uZQpgn1sQGrvvHOA3MIazTP9C69n8RltFWtPjHroHkoPIhrOH32spTNlgS4T4nV8m76XUyS6u5hp0lhLwYNQehrNuTkVlw6obVwxQ4nYFyMUJ8yD1wIU0KP9Rkm+eq9XdrFG0pcEXs1iRrRTiCX13Xm0w4/8arKLomMclyBAFxb7rxi34RvKri0LupajBFkqAZzmjHillCf0lHNxBy6SKIh8gdBN0eRWPSzu9Ot71CynCld+fsCM83Alb+bQpuLx+8UO4bi/UlyNw4fIFOJOtwSid7SojXYz3MfEo2RRjXtiznIEkVv202lGBr+94KK6NQZd0fLxoon8CUYwuPQDHA+GwzdmHZfAi8q5s8VR2HxMjRHqr+swf5FwLdv1i2r7G5SrMqATVVMD7vJ+kWKsp13lWF2apkOQmFghGq3Gw9ttrONVRauqReAXxKh8KXvsE23MlzWLmyQo0de65Wy9UvDnxjahDudya1snEUMr8xpogy2dQx86W3H+/qkQBtt0kWVOHfhNlz8bu0OqYjpP36S5MNG4qx3C16YmJXTNCFAZTmJslhQ+rGzJbdXoJokzeoDscBCWyYBcOmFp2RFUFYF3236a/wxG6X7OqDxZ4VOOeoAru2xHaSZoLHeI74gEKejUd3KTp8I6Kr7LTQr9U4IbNjm0YLhcVDG7CBdA1gVgA+P5rhIY1mxyreNlkF5l4zt4scqRALcS42LyTXxfIooqAwtOhMrliEsB+ddFfjRmSCKZYrvLxd+Ok80Kko/ScjLoiZNDxkYRsbEL9o4XMtmXqYUKhVPCO8Wy0hvsmJ5I1pQfhKsU17h5m0/HYFo4sX5hoeVKEiCIZVzgYsaldiV7ub3JJnZxWutSLDAgwx53UmehsUs2GHvjFc56Ddmqmk0uoqJapMrKYVffglB8ZHAFbhZ0jaUABn10XL71Ig7vFKf3jiVUA4UenB1XvcRiywcdxkqhPFWh8yaWGT3I6RNRwCeuYRrY6IVVMzFNrEvSPjqMENkD1T8OJ5x+YTEFgsQxhZmTRlqSayJqxjwSREJh+s7YKmXMjo2br1hBb/J1znlBnIlnIlLe1MZdONybXDWmcg24fZ261i7S1ChJja0TtzQ1NGKuZ2FpQEO+N4kMgRU6Or0tOfVfcybPuqHYGS17FiiMHEB+YP9DZFFqUw22Y1ZQud4F+J9hZnbBtIzy61s3g4BSEDoY5TZfsPj8D1HnZ6WGtA0Rr/UtOQjDhYlPOPZF6qZNtRgDSChV2PfviPd0vM1QNpdd2hkuztAqT6joy1kcYUXaZAzfEu+CUoM+dazo08O2EpSGOCI5yBhaB2sQxQ6bkwb33SYoVcz76UeqCieAO9vOG5MVd/Lh6IzmZIt7drZIz5Ikmiv3RtI7O2enF5OW0vUokiicIyFqXpml3HJc0Lpo9ON46PA9RYiP4qSaN4jTCnC5ihji2fpcSYZZdSe/4fN695CyiiZasKAP/3EvZQzjgVEczvBworzUC6vkb8o5Sdr3TlfEZcmL2pCaWD5l0hhuuzwZxgRbow8BwAOgKgMTn5PfuXVkG2zvwvSwMLoLDDEOcS8AYPoQTK41KhpsCGPINbkCaEuM3kjG/Z28yTJKi721Z/8Z+Ln+Cfqzh/MzQgXG6GwDTcSxQ1uHLhQhcDjVJoYhcvnI5IoKPD+l+35A95yRvuFhZtYRvw7AaO0lNXg5RnF91OUerSLQeoREop1sxjLzUxRUqjUHHtq4UUJpmMgI5T1QepBwYeH6kpOBT0ea3j83L0UWZOVrNzwfCmzxpFQEbqqPJ2Rs8x3np/WySU2/kyOesCpIfaX7w2c4h72BIVVAvT912Cjf5bwV/iAiMDXaIe+gnj82sJEisEKz9Wgze+OL4QuvfnaI9FXl3R8ob48KoBZLRFfyDRRoywtG38nfDbaidtoXPAYMSe6zwAZgsXRfK2bW0/n7EUzWMGwXmzhDt3zLK6ZSGobs5jUgxMYfTYkqK7Ntvsk7jdEHGYVNlmfjDIJMUz9z/WIGdDEe/GLY8q6PeYJ0V8kEg9TnIkk9kkAH9FyF0Y+faL/hYVZNd3E3242WYtHZPxD0if9NgeY3EuuLxYDdzIlnWP4d4ZXu/tT7xjSrlmQ7sHT8sUtftQWUKUnXFBCY6MMAUlD9X+MrLzLhhQ2gz2tDZowrKN5blIvbniyecIYY+ktbr/wrlt35oXFYHdr9lwqK8/KHyQ3XA5gC3tcCzvqL/Mp4lf4O/KHn4/LVyfjolCKdqsv0QiGzeQsMSMwPjYNsDuLMhYpyXhi/AN5qqF7Vx8Z9z0RnUybTMZpGPpb8angcsvanS+E9HNZqpLfxhnn3l2khqU23/6tuvccTGnT2mF8/v/EPg6MiLm3hdlrXVFEPD0uN1Xdhbt7zbgupdkeek6JxOG3Tmjx1s5YYLbB/qbsxuj2WrQygday8MD3LjBX6aWL69gxBzoHSyk2zZr7+uQi5JXVG8c3uy658sEO+oiKw+9JEh6eqCVLP/s7g0mr/QMXHPl2lPmZfuhydfqZnuc86nqtlSfWg64nMdMwAAupWasFzdbkKgj3B2n1xDTuMZziOu6NHuOhwM0SqwIeTFMDe+Cue74Ldu7/ssbkoXP81esIk8TIuRkbPbAI39awWlSJH0UvISFmhjLxQNoYnb9P8OTXlhKXAnQ45uVK1F1QT0WW4moyfEuCyUvt+124bQOD2HtlOgtGNZSkxGUkk3JqnbKMQX/FJ2A8q8QI8D8tpMv/+ZysNlFRkAOiK7TB+0OInvdn7Ydwkgizv+3eXCxbaYTACEd4Z8JIaS8py4uwJpKcFM8K4gdXK6jMZklR7c5N8vlmJR4sy6Hv9nl2J0FAYv7qyUSAJLAbKLi37LYMjYDnUguMkJLUQRK8gd4uYRV/Ag+cXrYqClLkn9aHOXU8XGjj2+Rs6ecU0iLpR1UgQUGN7W2wi70SW6H/sUcLA3M4P8lDUwlASnNyFV6NjP6jlFbIKJ8sheP8NPFMqnKtEkoeIFTPpzKhPSfq00jq2TL/PpzHJe09WVv1n6pyCrAg0BoTIQHXIgtkn7cRKh4f0GGBWpkZdjlwVgl03uJ9QTfMZhEPN7X6ihhvkaPJI+FEO3MY7hAhbYaqJllujczCKobEMyhuBOaxT35/zAxhSkF8HrPXezx9sMkiK1WU0GnFZUEwtD/6+1NHhNMXw5jGBZ/vOkcA8HCB8mfp2GCObXsljf/SJLzVps0H/RuH0Jx6n+ZJcQETTBIb4gdZk/4nOv7EpiqOxTx8u0qZdhY7rtMlejQUOsWvy3H2x4Ex4PQi4fOoDCkIAvWx2nyj2WzKEqBjkHtAaQu4TrBgcDyVtbzdxfVpdcaL53Zepqj/WP9yAe1TTJpFN3vrfuK2kS7d/j5Yyo9r4GI4mNfavOhGkMWkx6fdelDeIRTd+uXzWfOkW+z0cGD6YFWgc01s/sLaB+xvQCMOofjzVgQzOu9F7yqG3hf/TsQcsw4T9FvK/XS6VACfR7N2o4K7kdu2TNOKftmltUHFFUga8/PibqajcoGB9WI+tb4Qtqp/pRl4X4hNmFRqT8KqKQqQ9RnvdA3XOCAcDzQDoWpXjppLsYmbcoJcyoW2bNOM9rnLfwlFLoyScRLRQdyo8+py2wzzHxXw5TvbPzDSjI55qqkv9aQsBV8ww7MrATJAeQejt6L3Wx2ldYYOmj7RCLXpCSKyxyRineigMVDHS+XCnhMVhgDZhHlnB/fS6tgDvCnsGNqCQthnjZJ9ekPh+GE46IXd68B9WVjscPIj+iQyTkhYnThYAzNKmCepn72iHiM49/JF6R57fowTbe5ZPAI99s55+0c2w0mJGjn73mO/EJFa6ZZ1juz0hWereFGW4DjzrYvD3exM/EWOfP06G87fu+yzYafImZ+4YpC+SJ/l8LJeY1SBlkadT00HPYT3LkAyZtlChYK+hra71Vete9IPgezoOix7U9boz3aLJDXiOQot+XKm1OlTgxuHJkyezfTVOKdeJubNIRnLxscPKbXYr2jTMrawK44uUfPzWL7xTtDe4jFvXHgo2xiYCQ/IWYCKDq5B0S9mzjjSrJcpjzPbSNmYdlnjJskTem+2QzgBJk71o220983qb90iTNETkJgIpzJveV+cey7ANDHaZVbxBkWezjLjw+CmIJJSXQgUaAjzoQCBeCsOn096RgKzegsrwBtKXg47o1O5Nni8W4lXgZdNY+FIE9vakMsGi7VJA+H3tDncki0RKGRX/NLPXnntOIQR4LuM7aQ3O34hO0XbwDSTf+Mizvf0fLIX2tXxxHX2i6kGsFQ8W4mw7QzZ28xug+bR//4cevmjNHdllhUOsc7q7VVGCL/y4zMkJDV/FOKzqKKiCedW+KQ0fqQvy0buPYHcn/OLfo3YeJWsotJyEF6Y19QxqU3R6EIpppoy4aifGMqNVoSw7aT6NMwu4wTdMio9PEKisO7JFzN1qpKnSsUBtZpY/TvzkBP1tGahOPiXcWfGHnMFV62jw7XbkuyChEKSE6xQwOrgmcSYIxBzgp3IxHqqxyCXg6eGnNlkn99feWbKOgds4A5+UOYHMd6ZA0gkgqYgRc4AXR/VWyrln6QiQzqJrPlu8v7PkYLPxUKBBkyIVy7m3I3Q8B2XEHyz1H0cwrvKkNEUq1jh/t05h57iHCCQvV2SBF+X6Sei2j7uN1ZGQGbmGW3W5DxgkStdkmkApn2O952Lhmzz+C7oqOBmxrOYW+LTr7fk/GY6MrIG9kVyTpjK4wr1OD90+7D+nfNTutT/U9x4CHUw7AySkRt8kaxD0LJcKhfIy5qgY06SOEZh/K1av1ORTTs8MCdxL4NH7sZm+xTPmyOikL6M5r7OvGjVKFGBDbPyy9H201+vVgPX6QqHZMTh30h2iz/qnmjR/icA5kSrbEnPIvp7WD6VBHs1VahC3k319ONbWdl4YKyX/RErNC7RqCjbchPbG+saq1zfKc+jqg4uDXmQUFp1va6keVUl+mtOyyoO8DxNICHiZ3A2/4BGxTS11wipsVPlKJG0FuShHE41s5kr2+Zgk+ALG7ZIZyVT+FQ9HSyQgMYY69ZMWyLV59WSyGNMKdqgXWTSFVwL/2au79D8DZ155VpwR5efUSi7Y9QtiXenarumW2K7oKtKaCe8vJGSFoA4s2oSU4ClEdOhCyUtPz09mBYr6Qet0zWqVE1txaDRPUkaune9by5D0psIhVPD4bnULzuthXAWGkobbMF5Gld3F9WwqLNilvvZSRCLnnXQCoyHnQZVMeW7N1X1NkGDi3lJyT9j7uezPEhOsFLEZF3RwXZJP+ngviaFtV3TPqmlxj3Ds7NqGbSNfaLyMUFD7BrRDRR12N7Z+CPPJMEnxNZmlnmT2RdvdIa/P5NmIASNQlTaGUjpbxl2IKsVovLcNIGB5x445uL63p/+AfLZ3KwlBCzx6P6FAPjZwoAat1XwaaJirq8zs2AC9vEJdK2+eD2keZ5ETSv6ZP//ZMlTY46Es+aiYpFenJFTIq5ZDJTN8RljNI8S3oIIVC4oYXwbw0OpiUSYj02KCBb8L/Pbidphjj1+oIqqyltPzOIrZGpVINQDSTzjB0Vwoq+h3omx2mrg0kYwcuDcxEls6LyUzat2JS2XOZOprr8JAyRds+L/7Z5WYUXwcExKOHHmxcUx/NmUqpht9BgOiY0SY63RXt+VZQKybkTFciGqJSz4xm3KpAu76DjkrpN0Gk25RvQDhM4UYoAh3C4um20QIZVBneWPF85JgDSoCo46Tql27jdkVBD4HyBuFQg+Cjzy6RfPsxMSUfDqbKibB6G1teMDYtP15jAgfQleE9IONA2E8WshofwPxcb+6KnoFUGwlsIu1BucLfQgDzba22WPWXBbmbrrozBlQOO6TPWO0Zk20VoEdLvppYjc8jON0bxViGULeH4T2fcVtib2pA4FDqIftdUGXmBLpKbwKQyxTTSLXNIwk6soP4hp90oHtHTLdac3CBZEBraOE08a/an/ZNCgl9mMQW7mtaqAfm9IXzZOIKhwJ9C8p9hGtSh47a1zaabQJUyFBFCbKIJdYEGxdLJn8DJQECCRljddbTRMWRzjhwbGS/AWOI32KS8KZOHL3B+FbeAsSxxoTmhr1GF9NYHrRpFiE3bxvp66ruikChDrES4FDtgIlvPnl8juXneIFjMAwYyYmZIlp7zKVVpGVjg2+Q926g8RnBWNPGP9S/1R7ZVlBGfTa6ZladDnSGdL61oFWQOLX2vFrMUP6f268irC1/J+Wysd+xtifzCx4ScNgt68OgrAI5k/I+JbA3Do/Ff+j+2p7A1G+/ex0I2IhrY0DWPJZkZ1pgvwkELCLe1H+U/X4eKojmHovdiGHKqdvE3iqMxAgChIwA1mOGjzwlYhb76VrdhwVQnhWyidwwPlgF/XXc3Pu5SqA6O+LU4R0u0UEqKkm6iVcLdUpreOdqgtoj+vOQBvy2LfLrQEYXi5r+8bSxOYli0ay6IWmlE2U+oJr2N9mrw04dfXKmlrCGOYc+PPELz/prSmxRZEW2wi4fFoqFqADH5uAJPIpfsPxDoihP8ZGGNoVzb4VYmqsN3RqClMdG7gVkzRJEHxDFqNzx8V64YqLsFfwAVc3Z7Vo2qHNXyFmCt2PucC9YfQAS10cop4n0RQr1x57MGZO6bfZCLDhDp20ZuScB0tv+YHAihIbuA73us1byabGPZfjzVpvUy3iCzpVa7MxIDMQNmiWYtF0nz4Kp5oxEp3szBO5BjJKVWZzfVkuFhlvaZJ+t/+uOMbEZbZEYL2JbWs3VZ22+x/jnoDpjPd6Q1vpL0BX9lV/R7cFWfc4iL0L3YNr2amzhHADiCvat11Klsi9WRzc7DEZlhHkKwtnPutQ7DzuxNpSIFcdfBCXr7AmhK7eoJHlLSa9B2eoTu92NjzRVIK2r4egNqsc14hTMA/KoY/DIHCU4FCTYpzz/UKn8TRD6c86M74JXfG/dTeo2XRpEK+PCKGWpaNHcLQAFQH/+/mhz0cjb8fLDZa903a8ipAHor4J1iv5pPMIGmnWPZCEhhhpZFUp1WTiLMmIC7M1mdFbCc7zITvysbL4jp2KF1QbYFpbSzT51EMutH0ux2/MpXSLrpv6VfiJJyt0A1wkKf7tNAD0vnIf9uV40gzvMcxc9aVLSl8celygEpqDVs2X3ajsQADs6NX52iMrASm2qeYgh73GCbLl23IkeGuWnaJ2UiTFjfeOWkLgrKmZq1IEHB075HLBe/7rLme15gKvzee+yduRe28QdLmSsPqmh7kEbBc/F1AHkHWlHEy1XyH0t9CGVkzbXQfbumQO37+eM3v8loRXOzPZtw/QaBfPfdL99P1vxIiegtzkNPTZIVzZAXrhx/G2l7U7q/lRHk9FPQshVljrPfpwZ+LmIS+aRNqGSfBsyQoUqCzXD74UHq5urUuWVqPj0de8S8MYPuO0Vz4EGO8mRSwUd3t9xWSz8Ep8lw9kVazaN8OD1auIlkDl4okO+TQq0IOjGxAAqlMyzTmQSG7lO/lUKTN/A7m6y8kcJPomtH/YiAznJ8vUp0AP7Ba/HMfNwb9ByLu7g9P0wakRkH1/gCMszAcDfqNF6tC3ojPLqmb3rJwq1wY3S20O8iJZpH6WtpFtiapFXLDoU1D+Zeoprof8m4ebHO4KUS6hfcSEDeHEIqusaBo/BfH7b606Q8xLqSSNJrwrO8h7VQWaIp52y6cDdIrWbtm+cbVVB5orKlpQ8pz72Y/x33o3Cz/VFPa/8scTLBUpF6SNcu4OpRo3hneiioH2mdSZec8HI9yCoGO8eFsnmb+hdve46LL7K/1WR7CBUN0WoQ65WCrHEp6C7Paf/CaOcANoQRSjM0PvXzvc1KiARNOoebLMBIbaKE9ydHBdtQcbWIrSySPM6888n7AFMsPx/5SF14NQNEx2Km9JxS6g9ud9bTKQd0yiE2LZ+bQOtySNRtmF25ubcXvYHMXNqDwjKJd63abf0b+elocPX5US7LfMnU5FP57DxtHzm3Hjdu30MCu74zsy4IXD21kipsBalb0AFci//3H/ltjWaK0msVNrqaliGmmP50oIq5vKqd7aW8alcVf3WInI3B7O6L/Axu/OtIVteDbhBRrAwPgS/SO+VfcZ+5LlaDh6tpNERo0/WkbE+jOAYpaW083Bjp9Pa6nsS+I9D7HMt3aD2EkTTjbg8ZJRPhJnJxXM0mZg31btm9YJ04+UT1EWpRjhoLU8K+dJ59X6xZoo6IJyoMcDyhE4vSn95Do0YgSvP3gBXA5oq8A/g+ywZzVneYHA8EoynE2Ct2PKM/0rbZ4pTPKblzV7HgrLvybkR8Ru1FKm+1QiAy5B7dy8E9On1+Zg948re3YcYZk8DPQ6nUsek+fnk0keKoHI3kCkGrAc43zm6AYEKjfkt4IxO0Zub7tv3bUYNkN8L4RBHZH99wIDWtGGJLu7v60eOOBLLaazq6rHCGkeQy+gXH0s4jipLVS/b5ASS9Hk2khB91nY0c3c+H7Cvt8SIWf8kuZ+U9xBgzmKXQmc7IHmyReYVAv+h9q0RpFARUiUZfPgSmklMfAjMQN4ROyFgJeIySdCjmrd3YJ//52WPgxf3Xwg6Cu3Z/Lf/0oK99TaKoHU8ArD8oxTqeZmp+iypCf3Wt4OhQjEE5sEQRWXctmivweqHs3MpgLxbrf1XVCNpyIYOLJzvyHdtumfH0KBwqYsAVvyy3QTS3J94jqA4bnl67mqQEmpf9OjF85AxJ19pGYC21C7COLt0GX/ML7Qxxeht+zvpmr+LHZRmMR9EhmeMyWXzgmfq+Ei2PGIcHr7BRbzUwsIHi7L298rLNxxBtc0Y0cr8uUYuntAwrlY7bLWKEdGgl8FoGMJlGSp/J7KA/fkHkMgsne67X3yj5pS1tlWa25cBWzP1zIZcEfSZnv1tTmQ+5m/f88jF17zyRiLUAARrhpbG3zci/P0P7CD/LmfHGRFDEEDFiQk+DBA9UAUE6uXE4bU6LSOgqu60IxMlXVIiGIZSHGTYbkJSTIlnYgNe0zbnlKAws6LlpcLhZ1J1M5AZ+JZFv9obi652jQeJEVKSYJ1p+bhm9iuMuCPbO3zmSzYeoqwQs4TEXbyy3QfpJS6RiDTkxy07VqtdYiycHkUyam1G+T86JdUnaR7gvQtJornHRfI14rPAQdtkV76qJLL+PiEw6cyrUgpx8aGUmWVEoSLkTQSWM/OtRjoICb8+W1SPNX5mS9JRCrdiq6F+dWbzfhKXxz+2W1ic2U7RqSgRbzZG7FDpCcHvtZVQKYhmbyIuY6DE+66Ux0i3CTzlNEip/h5H6xSzh/BaEb9+IZ0IEagNTaRAsNyiYxSq4GfGakXvSKo+VFwEHqzLNuL8ip5e4tIyA9enWdCNR/bXkfRsS1QMJNrQLXSMI0AItTwl1ngEQAVVzQjTMRORC9qO/II24c7a+VIOd0uU9BfrXNEsrMtAXhBAa9QpKW+uIxdMpVeCllWk+rJB4jnfPysN/Bg47aWTqSwDx6wG/4Iy2h/QRyor8BT8uko7YiiWdNXbx68asZZXaU99HoQzoFPFf8PCsbyRndANvu9/Bw0Qq1IYfLOOxPA0vN6yn6gW/6k/bUJaRo3f5m/jMvxXc6p+dqjjUs2hoTwpPJLGcOJwayG5527CilknDnUrBtq6McdW+Dr7GydVR3K+na+kFolbfFTz5LnOUEnl1kRWJe3z1iGPuoh46Rk3of+tvN3qQMJ3AiloqzeFX8Ze7cOvbwAT2ogNUwBfQsQIC90iYGWrhTvgAHhrse5v65YBbuj7EGCaa/2v9znw7pNEpUVmawjnftWuaHvukOHCVNlDnj0JK5pzuvpmrVoyI7rPzXNdipospD7BwLKoXTeog8FA28F97bK9n/ZvuPAlAnhPD2Oduc+VYroSAFi+B1sCOjOQSBvqji30t42XQdekr1o2qoXjxWtSmrdyH5lmLWooucwC5qg6VBi7j2hFwRs/igeIQ704D1NGe5uCbcRFBDrU44c+K4KjV4j9gjSfL7umxhqQYkOJGh4NZArSDLc2ukcXCkyKMQKmwnIbpS15rONQ8GoMtNqPatdqAwl8j6Rx61tXRGxRBj5nG0aupxBOkgWlstuH0SWFxqpL31tqA8vrU0VJvH/FSV81BgNYL6s/C/VT409UtcRYH9wOxr3T7Yv2dde63Qacm9nruVpmeVUxpyLC7YnFqpDfKtokJCLVjvQf7mkHpqWy9mIC+mIHBuftTiuXZfqSGQYOqg3ubTmiXnmZ1LsUsoysvbF+IectN9IbdTlkvPSBwsOe757T6m4+uE9pg0LUlCrHC+8dE+l0DIKHTOdFCK6qss1GIm3ILFp1WJVqK7M9jKoN6Wqc8xa2FDIyD6M+EJyJJARgAIZzm9/A9SuUf9J7A8/zGoEUX9lupscqZw3HE7M46HnkW98jTZb6V3qR1lpHslHfrD/JCz+EaGAetH1t+5bDsrOvRLHXIfqbL+jPxbWzEtMHbqRS508XlCeFXRPEkrthtmeyY6jrn5x12KQ6m7XCTbyTQ0jHFpRuje9R43mbE7+S8BFGR7bZCKfdldQmFfPCuBUfezc0CC5KLbkJg0JwVgN284/0SoSOpbmxA9aMdXiRVXSER4vypklde/Dn3CelUssLX9ZUj7SF5PpBxzRHqni0n7JM+m2Ldf3sMOxLBEVKCPzYLM8CRwJ+nbqJ8asF56k2TS/Qwi6SxbVmvJ1l/t/YxAb42n+lxwDuvH+BI4/DPXhvAtb+ZyHRTYMDPit7tr9aHQxlQ/CHd3FKkTx3+NB+/EBNhqtgCiEBd4eyTYGHeSQRP2s1vrGP45yUTheRTYLU1NO5+PPPj1v7wa0CHewdb0BSeoJ+CmEU40kX4MkmiprrKn2LQzDuDzgnOYlxWiUo/8SS1CDYNrIBMMr9KooaLQaTBs9t9e5rRn70zvACr39/prORtqWO9D+JOtODDTzajgnsVPFQBsQ+gTOV0nOO8Bvu3yj3P68x2KhPF8RSWIZNvmc9J2eRO1WKXipDNT1Vb7cTjdMymlwBVnKQACCnsKtXIrGOf6upJwbS/ywevenZSFfkPU+YlKMbXAnIwtczX2Zf+Y1sZ6K3wf8CFlEhCAqhJeRm4aIapfB1FbIjnGWHGVUe2i1XxeILe99AlQUN8354qnukMf8IrPgr4NIHWqyf7zRBdw4KfJ3mwBj2yU6ouzXabb0jVWwUYi87/Pnlyqqp0PH1GyQnnMoihzZAS/PI8LJnoDqnz3r9P2yJ2i4fbveM4+bMrin5c6TUOs9ds5vwQ3iwtgoMB5ZwHwF/sLhB5XPZqN1Spg4QGBFsDNJl/LTiHJGfB9BRCY8l6Z/lL5s0zV5MVeqWeh9MA3uyJBzCghKd5TC2RgLLBIM+Is0e2MlcbhIMloy0AGH/M71Rs9+ENXD6e4VfIQQmgLIRVdFSIwARO+EsncvoPeVZY9utB5PmNenVhE5vC12htUZG3/nqCm/h1Zc/o/ZQS7gojrryEq0YaQ7EHbaStUuaBXnz0OeRZS4fEXejW6vBZ6JCrY8G4o4SufpBl+NFU3TsdrWTbBtvidLip5kcTqqYxnFH9sMCIIjA5r+i+q5xTLIBBdIZojphrDOcGzLfJerPqiXaEPlTylWN/XJy4l52zsnLYhmeaTlXzPNV76Mj3ctbhyYKvEBGQg0p+rR/Rl/iYzPzYIjy0K0uYMHMSzs/r0U8MfFH9Gqk/iJ+hw/oz8dR7NEfgZQJ1PMNiLvqF+v1PPQ65KZGub25i9nQHPym6G59wyS9zYVO7HK9mwMDL3QG8Om1C6UxEqE1FFmbjns16DJD90kxECFDfvaIsMImRvtvdzzkUZpNs/DrXjyFTbH7vWDbpWCB1uP/oKaBYsgvfVvQ0K1RUVYL6CGPS1ExCnnmqBhpn9juDwBkQxstEMwOqJq73Ge81wmtlewW4BY0YEcCbPafKW7lrpPiHwvm1pNr/KkHRxsIpIfJXKwZElRGjbkyIyICnuXLbzfuawrBQoN3Oc/5x7N/+TsmlglLM4V+A8ys34yxZXFq2xdswAAYSg/5kw2jup/ZWgcWCYfbWsVcOVOJq0XV7dLNoSIoDkL/LC3kDXQodUEqsdZEaInqybO4I9+KcGyYkAVdH/Np4FqBoIPGzj/afksoZ8i+s7M+BwnKo2NK3Hg2hPXnwU4GuSvDU4tRRF00Zc+wY+0Xci7ck81/GqX+jB37YFyL747868uy2ghgg5exqZ1h0FFZh0eSLLQQCEoyQ4DOIyC8OKyszadFh+xdfelDpOCKqkR87mQSnqigXLZu9GVo6XDsiS6hQBg7BBYzC0AuFZs9Kxow23rCiRIZGUEAE1KxjVYkPeXPBPvAJTo/FSHuvUF0LK6SJ3YfMCcayPYh1EG4EZWqkGnT/ZJlF/9T2bNDWWEnsY6hD2p7xbyZzpWD3CiFpNze91xUFm3Ob67R1gy1f97iH3V0laFocyPYDq13V418HkdpDUwE38KA8r/EQDlFzfJx5jOazxFkmvKRqAkhtjO1u+mSAiWTSlh9qKcwxBdmKn3Z9QjCa3naGl6qly4mSweM0D+dXl1uqN9swuvQPGMwH0c0MIBs6KSUxVYS3OSW++irOmrNWfl6MJrw2RWe/DWfBAZDvKQ07hkq13bZG4bn7LVJyTfK38+itVqDGjMvSWrYA8PNDdsvjWV8CMaiFkD1jcSC7nOQV6OapQ0/LI8q+SS7wFVjPga1kScexVTDFoN75LSBkEIVkg1cyoxwbMzCY2T7Wwz42aqo0ZIbD0uYXLF3NW5Zg0BKVLPxmtpQpPNYzyOpx9qIth+lCb7qH8K+OvAYkVNxX99K8L5zLMdnIoXg5gnbZqUrZ69nkbd8tuhWaRHfGJmyEdrR4TJpH/UB0VAcEvIefEN4jvvCKpzRedMVYLeZDsJIN+OkQGqsnkF/gQ43tbjlG/yJdkP2SA/KX4bFSR6hK7BuHS79vEIB/KM4vm5TaE6TNEi/L4EEINMlBK1rK4LtdBrkzMp5aMcz62OEwTpXzOvo+6wa/tDSnLfHJk5qk0qsDNoFuY2v6kf34M9LKahJtcy7l1LP0SyXYLncu8SbrPDvIvQQoxbNU3BZXFdrTn2ZtkLDrhzs7/Es3U9GCgfwgFWMLDWqiAPYKQfwErqmWxCjmleqIirCvVLiTgHSMJttxqJmrdnzJpC+JhiUJD1iu5z19xv8VjNdyh2Mugltv5G1xhwrSv1jzQfwslc2vs1XhHiYRy09nsNCsVoTQPc5mIkjKu8LABAtlpbXiR7kCNw4+jU25jSFgLun9MD6F5+waN3RfJ0ZGalOXZcKOP+fx4SWgpAHAeM1oRCTzRfpEwhTpWhDfVbBah553a4pLEKK5Kb45muSkj8fQlKaO9gGTDJrVlvIclIs4hUbwGfTYGosrOjfrTi9qqvO4XEBtsdTClGzPZnD0AW2YO2BO4Ke6BHgnS2R3gX5+vl3H7NIOXrrkH6hV1domAuGlWetoD17jPv0RAKVdyeIzKwxsjr5Fa1M/169DsgKm4F8VcddMhb0nL+fLIfOQAUHsjRJ4vI1TGrvWefL8GRKiQJJNo4A/YBw1RRUl88jaQPHIQbsKcTnMgYeRNxVFCGuMD+bUjTBc8Q68IwPbBYe96bti/SKl9cyIkZFg/4Yg/xbmxNq/49X7ta/V60Ll+toR8275FeykYJWcyUnSiCemG6KdRjvLgthZkUq0tcKfqwYF48Cb+m9bcfDWeqaXKUbL7gB1XhbdhzgJsEjUT2I4Kj9bbsTYmr0z+tzCOhpp4Z/2AR/YJPYub/GACRh3YuYVqvkmOJUp2xZ4A7v4pomgGPeGCQAiUyxoMrTY05EYd8OfXyLd26CGUFD4QEnbAe9+FRHJG4uRKmreTghHezx+LiUZZUcFhBza5COtgcgdKiDb3Ffl4yg0DX7DViKDm+EEfsdcgsaujY6vtbD0nNBvac/jk+gVU7VsjbvPv4Sw+KaqdCSHFil3YnSqpg3zkFJ2LBITHIhfVw5t4eOijUw3tSY5x4gaYQwW2MzU23thUMgDfAwo549snPlax3fka2vnVYz+TY7ef6KcTfdMxWSOOqjlnnuzFE6oxSN/3gdPIdfEBxoWsoOalrjF8mfM6HRLEvdm3aZTm6mELLE6INOYUQUowSEZW8We5fcQBHKHmsCVCutrGmYmzmaax4E8E/Od1Ru3IT+g3soetdYHU9J29q9MNT2XoUfTn1HU37xbHXdVpNMf+iKw6QTvNTusrpCryOefmzw+zju4lwnU1lKmUakD5lNY25FyzE9m22wDRnmWLf8z78fzH8Fon9OyhKMZy/6pkJ0pJAJs8PxgKygK77xIlWj3j754nmYdi7RQL1p9C7VOmaK08nfnffahgItAwyjuxKAsOhz4rZ9JBDKEz30/3DQBuyIpffO8HAsN+99kkeVE+XzmrSj1Wjh20EmQP+2Ua1tP9nRQUeLfk6euYDe0voZDGHcKsJ7MEga5w1T7dWV5m0iaBOE65EX+JL1tTHt6ioEWLnQvFBwxQv/WI7Q7vmoaKBiK+BaM7c8Y3Tg9usUkP49l9MTz5PzI4gy/W8X8KL9MmBsfRou6xewVu+uAipG+7Z7gXn1/rSeGcNO4Pir1+U31YPsjrI+TwJMhAWr4x4XrahXz5ZzIlYe7L4rFTa1RDhXDO98JcSj7l2fuLyGOohuvlubYPcTsxnr+d9BE9nsjcb3g1HgPuX0Itk8fY9UkKKjEyGup/E8WZ9W/wnRKu1usoe5lDNqeXQBz1Mmlb0B/+MdCddPtsW8TZr0uisFOBk0i1AhlvjkQWoJlYOCrJiEQufupb1JBg6qEv2cv4DzQ5kBkzXo/M34CA3EpLIk6OmsVH3d3XZYzgSB48pjcXKO8TzzQuukOdQArxmktU2Ke6+Rz5/jI2gmh3wqX/9BFk7gefVojfb72T47IGL2MQpJrhBE67YoBdpqtz/8g6CfDjyxubbMLfgCZICrk1TmNGhklsZlBTbuesXsWJr/GhyYNxBg9oGUtP/6Za8kPwgNmJpy5SNGLS76khhhmog7mCJL/GNDG+bNj60eAy8CB6A78kjitAGCDrhRnymhfXEKEXczK+LWIc68NWl7xQR8bTUWo0PD1QDnSTP3+Vc2FqfhSBQBnyCLc1wVlr/fetnIoTRdsEKGQsltTn3a1C9+RlAR7Tn1Odpx/eGQ7zS7QUawzZgFiX08OqMc1G3r1qinKIQrzrH3/MM1iIzZOgg686SGP5pY+tV08BCFFfg5AHzbjBFJ0Yg2tUtVABWO/bKcYYoS7fztdi+1Mf4utmYNlU920qeTZ8ejy/TuxMayTBV37kSzif41u3r7rj0nSZGHdDpovDWCjeV/uRZ4hkCHGxxm1/r4bcOW/rdm0UckknWGkYpRckq3xXKxm6PKlsqRvB2qy8J6nyatnZ+5+hvplq+1vghaMkVJZyQqZt6mYvYPqT9dUBHWXj60cUCtoNJdf4FRIOkLqRT4DUlybkUhLWrv3IYYy0thNvXN1W+gp4fuJMMM0TDBwmw4WBd4BUsJkr+RTjqrlf7iRCTB0G9o5+DndbQFvB9wbTrpGw7j8eoJ02SQEp7A8tSj56HCwsMSUaov8eexwvDf+lkH4nt6oJsRXJGNYsjZ8bNyN5EQ28LD7ITkQ2WPE8K8srDxjRT5o6yllTynpx75F58ILz0z9PEjaMg/ETyCT7rpVKzNai0z5S+jJqdRTylZcRM9TqxR3pR7Igu2Wm3biVzqhw+gEz8+l0pzLz9jJsvgjf+fn6Hq5UUNRuU5SEI0okS7EUw1fHClgin8GywRFIITb1cLh1Yy8p2Lld8XxQx7j21WntyovBfkfj/SAZBNxMOdwvVz6KZRKNfj8L4sxPmivClTv71XhAKT151qVt2NCy04SzoXi23bvMGaTgT6ZAJnS4EZ8pyo18cFZvl1wtovEC+oQjQ1C5FtesG4VVWm4XnhaBv/ByJG/K+rm6wJNWe2WNZmVZ/6M/W+z+k7hTLW9XV/AfiLDhxbgwL9DdjstowvAfgK2yzl5mbvhZoxeWyysTFBb7cbnq10AXgrT4DR2mFScMPIQJcKrAFkHn3Ce705P/qGJFOqHBvx9uLfpk6sF7muobo4WZxQ+OWlNk9pxKA2a4oj66YZBazgqtj+9eNWavhvpwM2+yPW1YAmvk99I8pRSUr/IWX9vt9d+wkPjGFbCAkL6kMh6h8rcxPWI5t8tz0iIDxWCCKgA5gpNWRFeY5U4a2RLNF2nVP37p2KfBrf5aC+EUZ2gg59cOzvbbu1JfAHmGgUSj6UaGqvTCm4beTCGTRhJuj514j6h91Ax0PY177wBudaR8EvzXtGAeXacyAu99R0fksWDXzuqDcHcEgCAaXVxRe6HY7TEir7ZHMEldyP5HJQs4zgDN4/f9rID3FOb8eK01Y+SBxB4jMNH5mhr0Glq6Rbex2kpeakJNSK3clhyJ20frHaPFckMNZDgAJCDNGYpnrhLkpLjGuaK4/mg61jULj6CEwLTBzDJdwRfVuYz5fL/tOeQiL7hORaAMvSTX6O2GBonYklwauZOErH2vNrS83fgm2GCwSKR6ElPdeVn2wOqyNZy8d3Gd7rBK27iyBHfvn9hE1ajTB0BOju9YKKxqqc16nr8zBkcfI1s+DCB0aSJNtUS4WOqDzrqL/BnRsCv1QB3KuOVg4Ee0NxdjihQFGrdO+BPTNz8x5c6B3ZO8WjmkYxuJDK6hsPrW0CftaZ7VVS61C+7HkjoeLIQBCmUHIdYOpXQjdw3jqNoZf2OvoREOSmc8Ecgnpb8vLTO1U3zt9mVkxFtJkTNRl29vY/azhgKORecWkyDCd6u3Hw5QG2XCVT0gv6BCajA2aMJd3HCBMXMVNqb9DoD7DIR6KP5XUI1vCVeDqO/xw9Xkn/X9xAlSczzd0fAUlvSF1JyfkJ7UqNmeIvfG8MVOrAVBQUeLw4MYswV9NIdObhCoDknfodRDKSNb1oaYNgn8HOLI2/oxkfLE0Hb+ki+rLqE3eThgBMI8KQITysPHXMVEhkeoPQ029TLYVbhMsrmz9H7VhsCiJb4vFHIY95ngAKTzFPciJGfs0ELoMylox7z1gNCU8JdtAslVnCqdoTOqUZ08ZqoqqCKutl0mpOkrm8RUeWPZtxpr/XrY/U0+Lq7Yw2Ea+ZQAEfrBMKixgLjH3u+NCiTH/V8w6a8j7wbvUYZVp25uLfElEQ+eCk5RZr4lxhgU+DDwwPfwi7LIYpUTdzeD96etoehqcJ5RvH35iGlj62wzJK5x60CNh8ygxg1Ow6GyPFTPK8IsyEER5ssn3DDQTz5uKg4s385yYEEtS2dBUCAeaz4KC11tEMiWXJx5QzbGc6wx4OHQW/j1FWD9SoKkkpceYAnWUU/RaL+B13fgoZi8n51VxPzn4UkfJl5ISwN9qIeJwHp1EvKPNgEKEj/A4aviCXZ8A6OA6D1DcLIXvMBN15SfnqwubOE+ADaC+eouimSScJb4uM1j9XnuPxlmszIIdGf/NNyZTZyNLJI6EgBYclxikkg5fpSfQz3YzTv/L96LG2kpP38GR/bsw/tcYpLIlJMoK4oP4UpGNWQwlj/9ESGCjkK/vRu1w3Xr5Qs1SS3N4p86Bj5diGqIJyxsTAnT5qSkq2Wr6Cyx1mgPCIKONTGtjPXT3bKH8PxO8tM3JlqOlqLxWMuCgNNRqczfwkAORrBquwYxoJb2N7Ebc+HCMgf1heDJiHeNrh1U3TKNdw0KoRXbxhrwFDaZwmC3ky4Bmq/CW50SlChFw6QBnpy1KUt+vENIownET1P9U2ns0H1projZKymjdNlisOvkcQXfRnwtDCO3NehFv7tq1r6a5hNNJCs6WCWoO1iWhL51+9MbIF/90x+nyOOXMQMPSm+eOXVb94ZZrQ/h0H1zyZ+0M0bMFm35hl+FWzuaMYN3T9JTOTJPVNwCUojQpZvNUe5BMDzrfjv4chefdJtNg4bqfh5cgIIXuhvLsvMh3Gs1bzkDhV/rAKY19ZMt3ktZLBSIELfJTZa0uoRn9CjOHCLhKs9iLW2iFP4LHNA09zMGED3ykfVAtUiqP7y/nip16Y2ZupR89J2EzCBbW4J2dAph02c8/DpJ24sV0tRbPyLniAANFuFv6UF73WSDpQG33Ry2inO9C2pRByNcLhEZXBCcjeLbQDVxcnKcfM0dmAgtshcfeHiWbB3tm1oUMOhEPXnL4Q9nZPeb6sqqijnRSbN84znBSlMGf55uLzofFyZLmxyI5T8ZkqjQUVQhE60/Haxn5rp+wK47zCGsVYijb6L0bZ2sYroPhXh9hUn5MbtZY/YnNRCakTDq4Oy9G8vyzK/b13UTw+gtQtbsWmHIPbWnJLaY8t/+F+jbNUVgtENopVRM+3C5+pkzNzDG1Yln9xfQMjUNkvg80fweICjzP+HraD+l3idP/qotX6333DCOa2l0TykjqwOzqfZaX0ZKb2vN4d0BD4HaH3Y9PnuXCQZdLRQm6DjEfGu1ZEFVS0WXmFMu7BB7l1q5E6bEyjd53h6Hn5T11LpGybwY5cPwJ4mim2ZflMpU7cV9I8NIE7zSwTST0JQm6WvWVhAViIc9tsKMPyVEv++DSoxrGANkIzqSxjlalaXJIEwHFBth/9qsRzXz3bhPcxGGIBI8Nk2VF4PTufcVuLOEg5vEOZg7dClZBnoqhVUfj8pkRtWTbRo8+pWiBwdf5wSprYOXB1Lmvo9IlbcyZHs1J7J9wfiGTrR+DODTQzP7OjgkYFhcbSwqCOOqdEk9SyHDvalV76BM9i7/7d5PvwEq6RKdQYQ5QTfyvSpkLuxkRdtRDD6m+OKO1NxyBlWjEL6VWjG9HqFdvqI5xjql7w/ZPehhhkPAEHxEBiyqkLAh8Y2zOqkwdxag+9vQQ4vOHTjEJlSGic+wOWMKkRxpml3bRB0V6a/T0rG0B36B+T753Mae5JXcMOvCrx5/FT/UVHOZm0VXOQaM0CLZueaPWROPNgzjpUNbB7FQX/a+zAPz8uKHgB/C8+krVFcCuclU+e0PsGrwZXhOKQXpEgOHPKOE8dk2rZlQGGdThds3lGHFzSrH1QEE0wobh73TXK3jiGcJ2gXNKesdnksvJJi+zWvUAvM7qHGOHq+26yTsp0dik+bUaDe1D6wGUxEn7XqF07C88zi66wgnX6HBvRLKm7KN3qaXcbCrgWhzwaz+tGT/fQ2MnrqGR6+kXwrE65idLLi4kQLhb5vW1uHSNU+QjyqXuW5PT+BjRtssni+5C68KTvdkSOJTbS5eXE+kFrdeIWWbJztYBbNHjTAmOfRMtnPGmTMo+Z525N6C6jsuVcY72y3X6+dljKq1AALgYfE+J2mBbJYnIPRUuva5wqhblDLv+Od3JHw+Rj4GWuCPO2vP3opXqjbrQ0ogikrIgn9Bq7lrwFu+E6M8L3Ec7PAcWauFw5WBpMWi+8cEkUJme51Q5Bas5D+HQyhu5W9hkkW1rA+55/rV0oNH/vTZZFJajkWM19qe1oq+2VAQKP3RVnE5mSrsPQMtbvIOCx/DWcpPS9Nh5Ci/Kjn+Hcqhmdnpsu9CI6uwQwfmfdjOx2r7f5yb0bt+ULmP1FWx3z0XxBZPI4Kz/cHvh7Am4YJqkajWU/CqZq8CQUjcY+5IgeIgMPckr1EmVf/3OPkwwxJQkq2mRvD0qTdtZM6AnDLt2WF0yr4LZO0+g86FBlBVnWNIHPnP8rJ3R0c791P72hFo5BDP9suhzVW5MbfqoF3Sqj5ECQ9aKUYK84cb02xtzOBAGsVYppFzfVTnIy1InpNqy5VWCqfLYQhK5KQq733d43dySCuR/0JbfPCLV/KmmKwajIwBiVFJMKjrUWeH5gsmoN1T3u7DAAkLw/+cnO67xgWmWksQRv5UrpY88HdcPsAcYhlNgMqNMtH6jgeXeOEYBh7EQHhXUD3SXF6Q6IAgWjXVpndJIoZU4IHh4ZuX1kSoXBIrU9Xx+At9lwOcdIBC7KCvkDOm7/eNE60FPduNLdSU7egG89SPnX+G8yeSUl3x6SPKC92OI7I57cR2RLWwNqZNIHRJZmiE6OYpdxYr9fT9tUfWCTvKkAof1Cij/jnSH8zMsztF7DOOGG2GIbYSCJGIfQn/WujeCmt3qEBRVIE0iNThMuIU1O/48pXoEuPgVldkKKsBKzsaZ5ALkLL7J4oDyYi9zSz51+W4fJYRrFFgMaVpOSm6zvGGlR+kibIilihrgJFPL4mK6Q9caNMpb+W58C1mIKgcXIQcVBeCtuVimQ+pb0UC/BKRi2eoN70cxDInap6fRdWDsfpF/8ROUD31ME/ELUDuNN0d2kTK4ffNExrcLVqQu5iof+/Dalb6BhCmYXqznfnQVcbbiEueGDNs83c8YPMLVcP/iqet5YohDN1FpoTMK3niYYPep5ZWfVdWCSStRUocBEFoPR1WYU4VaZJMwtQ5iewze00zBEWgx9MsNAr4iWDnyrrR5QrSBEb/2Luu66RuOEKZoIL2/UA7+cmzR+5n+MhVpnDY+vd4YOJS8fZox68n7YiFeUi11yMTtb+QFljYRbxD2JMGSOewpz79rkPqN9bwfYRgeI3y2nBIGdr/Ile2eKOdWDXb4JZFpK40nUYr54KK4fwR+OW56PKTmPMZtOpA5N+UqKlnMHM9AFdgXX5veiXjC9du43dbvXuMnph4fGkN39PuxVNASa4O7z8hFl4RKHnrZvUKwiObiXes+X0iHlqCmVbpeuOfsxbtC7UyxSCCXUSBZ2H/IdWOECMNvCpE9IsZo9R1NijHHBtKK0YoZUdNz0VRmMYhbYQSosQeBf4wEKB/JGs5DVNXWIpEcmvZk1TOkeI6UBsydTUhyjM4sryYSv36rxOaSSxqm9ka/uYqsc6b/RJIoZdyrqV16FCgLzcho8dCtp/IT3Mv/nsACw2VXwUVya/xh+ckC8voBWYrZjNyj0yt22CXXemGWY6ezKr8l9gU2xS8D00akroBJ+Q5XpDmDmXPSlzkWEyEptbjNvOyN1mOzS6Ul7vD+4TUBSkt8hbxAn8phZM4jcEf+NuIriAx5IIY25MJJmFr9Xlz0lmpWLet0ZXSx9NzPeb1OcfmWsR5Rwm+zTSCLbrKLJLRGnbPw7Z5jCqM5dSzKrv3tid1dUJTLYbCE+ZZ2mNwJCu2JUzUI4sJClB2xrPLoJSItixw8bt/5nnLEO7WobYTxDBfRBX8ePogd5Jujg6ENQHk+Zh0AITj1TetRBiTWvgbVEp6ICr4Zudg3tjT7orWaiBB01W2Se9yX9Dosr6+m/yahOPPLy65zfl+G2TE+3lCNEHGk6BTQoDHpM7YRK7bj9DQdDmpb7Zk5ui/adVd0G694jlwUL1Q1T5R64j1SrKnBTjqnfKsDNPwydNjv56mhMuGNJV5+BiO+Zde6/w5QVBNFNT9dDdVoJAUlMKbMR/LP6sPgE/VcW1lmFxmgngRfbc1Y5ipm5lYVp9ZIttAq8P4Ytaxt1Ayx2duQdysIhLHbRb1ymd0329FTRdd1LT4Xyjd3tR7TMiJqdXJJMu9E9659FZp3GTZuuXK0mVfYmPRBneCrP9XgXxVfQxD5JMEfuYHI1NKpURhkOmnT32Qd3mm5js0neOLysupTTAW5Y2AT4jd49ye4VGPN6CtEzkbuXq0QMNYYBhb+JGfPX3RbIiA1X7TeZdZL64KnnoPLeyJ6sEI/4hYocYNfKtlw5KADAmwIhx0TaoB807DG5s+LSjknweMfywK0i6YqClldgdgZUEsl8kQHNYInw0dJ6sizzHYATygzYQ1pB566IUsI8aBtg7/epc1UNwxvpDFOevLTyLhuJbyBtIpmXcmEwJozgfXZH1GFDivdcGGTYFBG8MTeJmVcSRe8ZNFJbF8eYqI5skC2rWcV8TnODFEDN3jx5JajEqxwhmt32PReWPOS2xJzdRXF170sanFcr5vqHdBAxx1v8hYTYhHlBQ8G5o2UPqh6nqlqZFQdSk349AOH6n3xM8grzpmIQLCopssK3GaEUdqRo2czaN41VlTxs4RkPW2PMPATPhhGMm4obnEXBjqfYkgmqe2z6pCH0nzLu4g+o85BYEDAYaZsEMS6yNW+JANpDRFzYLOjYXfCSqSjGd7bBJpv9DrZvAh9lyAjHvIpvU6MR28J5PhMzm45BgdA+6jPxDH780zninQSuMCSLxAZgzPKGUhewroJIr/SUuULMlhRv9Eyt18yjt+/Gw4XCmkYtY4bDbgId/xGnE85rz5BmhVK0CsMk29rXBfHAOctiJ/bsTE2kvvTuJwtdLuIDUY0ZmbfgjMQkwSmATX9UYZz4tIKEEcYjQdnTh1wakHjG1PD4GgB5r3LYK1L45ii+XVHymsS6l69LmHPWbJTjaLUprTtQZfmOeiWJ5+aTpq9MPs0FI3oyN7W7WUGEYb8eLUPlplc8Q4yXplxbsOuQIoJ5Y2hY/qXiI8ztCx5w7O7ZKEG3XUVgU/L1IkFMAQuKACKyOO8iHya+qBlMJyJbB4gH9vs2TVNo9JHUZzEJ4cdP0C1rDZlaww1GApAGNF6JXg8omWEbNpg6tyqzvmnR/MqJCaPvR6fXHfTfprleWQkuPuE5fIB50DDA7LLalfDWzDizx/NHh57W0WxNeksXUOaSviZPxgdUYbk3o92dG3qWS/4J4g54I2+wI6UB6qo9TmRnllYv+FQJBFOqE+tA0gpMIv/ygLLBpfSuS73coqdTnbqQdwxmtHEjFg3p9QaZRZtia4txJuMaRFPz00kJQSoH6QMQ6d4XmFK4x32XgwSKkPNnbz2cuohECSW1nH5Lxx7gRRBkc3jjnXNUHyRgrAhnXihaVRu/pmNUwzmpOMaPXojiXizoSC4V8aIKiXDgaczdgT70TTo+yNt9XNmJTesfEoCcys/F//wcqAKAO7IIpRNRNWhFWGg461FeES9/ZNPEPfpgIMMLScJss7fHwLSx7iDJRJBgdM1To//rKjuyussYeLLIEO/FQOQORN3wXlF9UTG0LVlgLFC7unQR1RSMMT3dUmAJXrMHCqAyxigxcHUW1tH60lG7BhExsUbCusH2ND5oa7JZoUx2Wt5EOC7Ct5oY2If/PcO4NseBfBs0Nl0LINjlpmQgcbh6RdcUQWChtW0qBdWr/uHgo0ZYkv13RQgbGL5kiFc8uaxM4LQRRVOnIES3WruqmINxKDCVzC650HBqhZLWwmUYNE4oGnUsBNE21upnchHQS/lwil5mldmXUhdY3pqnl/K+A1tZYHV4ElrTxoIDSsMJNwJPpTvxylkbo8Usxq4VlznfpwTXKVRstLWLHIpPslsl51MWuj7HGjLjYrmymb69GxR8BQUrmgcLd7NJ3TxnedG+udyqn1H25svLbrh3Mh4L2MkGQOyniSp2q/AOyA5KMhCY6Amgd5lpsRr6CtditdzMw3tz8ZCcu9+iEdK3nG0lPuP6IoaBer/EYM6XOxT3Sep7nXVKv876DrONKh8V3I9P6DYM9SPQBDN5EJ1fiFPGo5jtI3pAsB75HFr0MXHODkE3xIBZZcOBQlqACfOpbdJJACM6OyzkwKcopmM6Qgtv70rn60LWSYaWpNU0zaUBvpXfK/NiBMY+2N5wdG8wG28z+d8VZ/8jxND6G50kYgnKwSiijgY6V2G6H6kxjmD5yxSHtZhnI7IDbOmDJoqV5/tc3x9teAT+lPxwO7YfRHHzcgjnuwBiWdFSxWXPHUt0RU+8jmIs1W5o7/o/L8z7vOg7xWSfBeBCCFkmbbplH7V6B/ih+FsA7cyfK2cE6o1lTLi4cPWNFIKHBJ8axvxD9Y5OSMFMbTH/9c9YVwAd18jirr9H3UHFLLbTjlmhB5tS/vTwHBxmL2OFXDQNPbRRPCahw5O+ERmrfwqKok91hmNdMRt1FlcQ88CQBTfkWiRVQhSppMMiz9A8TOYy9m5Kp7ccOGB570+OrsH8Nyuj1TxitPbQ1vCXn7hzy1JKJCcmXk3SnxyKqo7svKXAz57+95zZSZ9i3eiu/VWDncm+gzf7gGKVUYPiw3KRf/N26X32sGb3/Vv7SH960mBZzKqZtJrolKTsMTZzrZ91lu+fVXJxAuYldnjt3T7s+UlK8HvWWfqKCXP3D9ODbRGfcGeRZUQVGFpeUqO735zlPZMynzIugEpbEq3jyGeMJf3tb+j+3SNwEyme1kVaIfnK4EtH64aQTxT18lULaKXgzZlHlHw0tlS89vxGx2b2aBg7c7ExRGqu2WsgCI3FWSL/s61fcNfIlm07Wo2IsaWQ3kS+ZlQMU+YWgPnskcdA+0BZTa6AcKTR3a4rI9AyGhqRqDylmbSHXsv7I2dK79idezCHZe8OXZS3hzPVuU8By63trFRMaMQOzXJ5MnaDi5d7MRnoDPemzCJR41HMhLi8U8DUajfUmZ2D06Xml03oDK6LS2gVPYf/Lus4rb+iVTv/MuQYr7/97FzWP6nhglDgCHtGIEP3gAHj1buUaxxhWvJi4hfgLyLP63lwC/QkNnC6rOfZWuLcD4XkbCNUg0mAbe0f1SNG8wI3FJos7pBCCmg1rPMi0A6+JQq+jmjl6G2jBzNwJ0Z6ySudt3e9hK3BS0oN6BDMX2gfyG8Y3UlbZTuIVYcU8ApR8b988v11W9zq9qw13DRgaj+A1UQ5q5nYEw/eBdYpvj+/+l+g1YVBtnZz4Bl8SjyQqOaA/KwN00tfCug54BNbrYM2+D8RbXauq8w7p4vNgVnphv+hsGn8OugxNZhIndIvops4MwJyj6a/ZxrhM6VPOub0EHjmImBL36AkrbhX/C5uR3dgzVjFARQzwo1hgiS5jsMTIB5oIl9qkdPsY1x0CK6oIgvUMzt2hHa99pK4Cau1KtEvMqq0WO+MrFEqth8PdXoZh6S6kE99LiJp04iISaj24nXree3iXhoJcoBKJtD83fZZFFo1mC3TahagtoNF4KtlZQS0q0K6gEdBSIhoMdhD3Utxt+xeArdK3Lgss1wofFkNEkwax/5WJsZmV/i5+3KJ/jcKq32y8wSCaBs8U1aGOiKg1Igb2swtAi/4bBWm7o2eMgHEL3+6O2d6/Ogn/f9VB2erp2IYcF1Zw+Um41GJnJ10Q1f83HC1LqdjdgRqqrGC1Y0CXIRiK3F/XiTC5b/a9qKKsmLyVbtu0EBVjNS1Sx12Uwb5T7PapycRhy9vZnIveeHTmq2nuPttEnlkfsZwBD+CDPki34MGZwyllX+Fm1CgmfVOPNHdQHD9xr2w1u86R/paLVgXHXVIc06C1K46ILW7QQ59TgF1ymgkQ7SEgxxFxaxXuNSkfghtIPgMx4vQJov5uRF4ti2pJVJUzEpbegR/nsKlJgruBy/WwWhTvRsw1YgszpF1T4mYuFdsaAjaQayjmFDFuUO5qPflILg2/AC9HRy5r4a7k7EECY3tP/I4DoYwY0TP0EywRpz8nJh0OV4hly3DHj+KEhaX06vzBigqy4eWhvi7EoPxW4jt2Xe3Rw2yekn1XDZtmWZ+wgC4ftMKnJjOE2vF4I0plkNDdVBAHSWpwD1oUwiB53XDxraZMawHu7/QA8OvBpIGOMqheHDaCxW2JW0q8fWmM5nOJk01a+ykTf7NWdRYZAFHCTEuvpggesvmGfOAj04GuVwEGtqKRlxf7/+2PvI8LQPs57DHZc6AM9SQGNKIKsOhrXmJVPTZY3+RYMK5PkTqSZB5ksvnFVFQuwrGK1vVv7FiGr87evuHkl+l7hvN+CEXUB0606t9GZJmrxVXlvTWom5uhU3pDAEamlOH+KSARGwM6K5kG32NIuCKwk4TqRhvzO3IFSuL+sQFRoRqCik93Sdn9OsKNVaSE/GxTx+LQRNNqdWfmNdPxnof791XdyFl2YH54LhcajfQDeozboZclhXlIvKTH8KM8M2DFYjwqnyuk/NSRWAyjPVd0WukSybu+JNPVdpv21TgxWxa5GT/E7YDGaqmdkDU1/inEaznkS1BBWq8invgb8jXiu4eLg4Ryq3eFFrg2kqa1KI7w8AzG0Cr0LEqlicEDjpIiqp/Qo3uvmvpkvjMUsmHOKch21aWjFCY5Sc/0T5Xe3IF283RCjfoWRnJDGyDcevl3FKfzq1oE7sXkHuMK/5kXr6qdnIW5aTO0458HnIJ3cByOA1L7CPcAZxz0WY2IvSnSIv73FyIxgtBjwu8WOgTXMoeZh9rqNECpsV0wd0eN6957Sh0RUgV+Eb3slxRlvavkyPFIOczrLz12C2YXOoriQqXi5mnpqHSgx71IjditHG46XDN0cGprVIWJEYNgphLy+2I76V4+P7pCDDQPJP13qM5we5G05msaAkb26jrTGpxY/aNCBj0ZE2MkBQ2wO8DMcqJ1TdOECddJGLNdmeSVOfUJj8iwzZYWBMm6CL+gwVjqTQsP7H6vSU0PYht/D/bBtbXJM8b2fmm2CmvKFWqyY639IfVVgsI16ThZOac1PKqQRg5CgPH7z8ParmECHtYFi61D5SqE3ak5iSpEuHko4ZrzLFdK/oXTD2lCN4yKqLd9qUC1I/DaRTiC4VAeeHqFzGcu3x+746MjyEu0Qnpv54EXqUb1q+bWoMI3tODBHcOlH4EZxUO4oWLq2iN7HoOj7QMW5eFBLa7qy/b0Y8Pp2VxVkeSzBSSVrXzXadg8uLK1K3jT/nKiQsy66Tt2XYwF/YN/ZXPlI7Lwm1TLnqXaQPIo3DmvCFCq29Vq2ZRG++UEU910XIhPKUlAPYLOviZW1kU2Kyq8QOM75ML2pg0UHZOHalzxrp7IFp3Gptwe9topq8NMIEHtwDloI1kdW8JcbDdCkv5msE4e6lhgJhoYr3K1/44pcAjW0FwJn9ui5uAzF3tv6DiOcSVNJPoO5i95qT3qK3pI84YS6bKVwTBTWHC5bW69zMPEszC8FsbouCR0+o1CdqtYpgRHwW7fpBetJaJuVwsEbz2WFrWFdWUS4rWbLmDtAZawn7ni1P+E6hafMVP76/PgXEMqvIGHRFcyt8JO/njG7K86YWjbhpeC/L65Mqfcj+iTawPxWZfMO4oryswWQ1c0tOs35GzP2J2wZUG6w5+l5mmHGDeliHugrOSaY+4GI6iFet+TTZlfbZptG+hsaACa2VVbyOhyQMUFD2K5MgcvYVbtMA80KuZDR8G2hsMubUZsmUM9/Wy82oyS2iXFE8OpBSLn8qwpWtJxQ2ZiMGBNmp9oHZbxYxplFX/3Fy50DVZTZqCSh2yrgVYyCSC60EJtrVHmUD+ZCcNc5Vewxa2NawPSbwKia0XCh3eqU+0pdEW3A43BMlYJ+WE7gvC7S+onl3Fd1jzx14zOv/Al/mAXJb1CwWZQK1VOwHHHhSfGaNZ0RKbKP4CQWHqXBG6VT7ADuxkvCtsolR82FwyrFSxeQc6Ze6XUchBR1IQDPs2L+sdwK/CsbhBsAtXburERowYTkfnyKG8vjkHgV0ixvfa5lK92VEqz+8nSeBocNA0TyIORAN4dECENzW7BsFiRs/M8L8vQqnEsb6X1CJhlP48zE0lEFoEKeTFqPh+SzqiuKOnekNQnRu/uGSY1mcS6OShjXrx9r0rRhFU5BAJarGbxYNwmM0958OlQ+oyWDv7Ypm7HzKdWc+TMlPZanoLY4Th1etr79pFVJpy3mG7J4dVGFTJDG1fGtVwG3nNs37ulguMldYG0uDbQvS23hzwWRAya2/TnPj2Dk3Ns7MESb3LYUiCFVejt5wKcT+hhjWslRHFx28/qYoE1JvQvjWk59p9DMwuggHtn+AhDWnXgP2T5qlZ0iqAOf2vh7jG3k6RSuBPe7SR2IT+R9/ZOzsSfomf3Y63sY480Cq+A8HWi8kpT12tbR3P4ILVvOiz3mvDQAWOXeXE6UsXxNKlTy1okNUMU08NVTA3vCrdQo044zON4y6ALLLkScvZqPTe9oUVyMlz9w6Of1oYYQyqNCCSP933CIAR7o64gSr2nhc7D61TBR4OFh9v85VrR585XG3zRwvrSwMRAXiYa1v89EqDQH8C5svk5DJp2QTgUq8N2sjaHskQRqdgg2p1Vmbh60Qf9vqd+w1X4lDm0DzSUu+MH5XJvKajjIl6jkWQpdRnqjRbtbyWGhkEJgCeJu5zVmSG+AvsKo+VzFSqkgp2dQeX6ihhES3o2XWavgrKwsbkF8s0Ps5p2uoQrCZovlRTfeTB4faZy35FiYiS8bRQFRfFtUGJkVE5VC2YVateSLqg4wIaPk1jCLRmJLWvrtCquCZ3gTbUQAUy2UCJTnNI3reHHhPL5q3V6VZqwgLIbr4oQOwo8LJjjhFH3bZVLkrRiCWPCINt01jXGb/xkHc7AVy576vCVaGqi2W3CECB7XQ4bpPzMWEb9e2doRhrx1yjAFLPv/OqT6AHZV6gmvxSmKNhaPN6U+2+nUuNoYh0MN+B+Qz8sR8sEQBM4meXYKft4pYfcRwdYkNsIeHiPkOF/vNf9MYvwdLyYa05KRHHx9MkMQ2Dv+RsRkLxpr6HICVF2K/kNsTvq8gm/MJR9x/CE9WNisoSV44ai/u7hb2wX7GFLABTQ/rc7pq2u+N9cyrbZnVI2MUdYGaWongTFy9ewuwS9ALWAeCgLdkOR4BMKnoY4y9Hh5hEL5T4v6I7CaXFii2Ggird7pQzhAnGeiQ31FNJA+yXhvSwo1njPFanzPfM2a1nGP80cG8f+qb/U+7DCqch1+1QPgKXWOOKKUtsbajgP+HRI1ak/cKYgBNTggtjM0fr/EAsyWIovOuZbpXQV1lfXKce7YN5+FPCrW+ilvr+dj3UiaD1g0l+0xZb7CaE1AmLPP9WX5b+4MWdohSQ9KX3GwFiqTtJ9bz1931yfhewQ0gY7BSa6AgvH/E8gvx9Ku3pcWZLTW6o7bfl6tYdL7CRYVHpi61BjjHxHthFon5KYfhDWfYxmuPib7fkleMpsNk5DOtQSfLT1JTqY3jiwWxbP/ZkQZ1K56LrOf0DzG0vzVChQhMnrRHtcjGrHH7ptV+r2AS7110ruUo+ECaSWZTZcsoPtPQKcKdF1opSPFFa+9Pqh5jzpAju7yYFJX++nDOvvF4zSVnVH6dW5sThZfxC6Ps3yLWarziQnsUx+K8fV21tif/ezKsTrr9v1Hs8Nsdb0Y6NurJ70NHst6AvwHfGVTIcIotvHTU64S9euY+vdUz0/Q+8WiMYnN7fBmBZaNo8tA7oK5Eop/IJoCQf5XArWPryD5nY62GJaiUu5z+RFXvUsGm6ILiFZWpcqzCNTPb71O8IV99s5pebsGiRrMeELmtArKxFH02OlFSbTZGJ6EIHZvkK+qFZOpEMa45q0SItNJdM2FvF+K72OPzzxRPV20et8kbIOfykYm9iwAHMVEZroU1RmqcxufMSzsOWXXLq1WzZQpQBgAwTop0/iURsTv67y232NacCB86d62RT0OT9zv7KB6TSOsof2D8ncTPS1WTVgqSvz5OTkJ09l0B7aLW1Z1wjd4kVhhLHRfJoaq9Hez15mSVYbTsIsXaWXXEjXoqoVla9IKVtIWe41QWME2Gl8ypiZ2HMujWPQ1/sFigCV5X9DMRwgsnYGq4MgaNcjPkPE7BKHzPdV/GXsLhAc1EBG27/gDQSIFTtc0gTy/kZzhdZ7cnKHqVniVFOi1hi49Zh+gWViLfxKQRiTMMkzznOTwkR+fkoyjIviHGamxY1hustkoVLH0xzqsB8e3cHzajfRArgnQOhbS1tCj+I9tyEnRMZRUKwTsNnABRBn51d+uLtgf1Z0zDgUcGkv8VNK+d7uxFy6SrwgAUSTKh0DUoocPPwUA4SKt1ta0uk41GlfYLYiH6iXSwev/NZALr/q8A2mCnEB7s3JvcE183wJdan/4S/cMCjZU3rjF11xXm3em/7b335mJc9Uy/qMey2YXf+DJ4b7gpmRhnA53fmj+zzH1TL9wWDgE9suFncj8HREwBZ6NYjk75y42jFsh3cY550rb3PF2rHxXq76n6NGAzMyGNm/aTsYemKrHcuiHE/jTp8hKyfjFM/2svRVeuRO9tjRHzarST5kSUd2z2z0Wp6X7k73aX+9//F5CGclz18GutKYuAL8aCxjTUWhAbAjLLmAOb5/PmB+LMDiBneBDR1uyRei9ohjCy0nYSopwDE1LXYJ7SBuU1hprAWywP4uwByg13kIUiOirJo5uVl0cT4ZqHAo5+rjaAfjt9evRv4TvguUM6cN32xxjTopcmYMZwhKpMsfzYN4JPPQUoCwM1SexssJt59jM0MR+eiUtffM3s4R1xxZHxGwe46dXyJetdL4hoQuK9xzaaGo/OpsrJDUXyb5VIvSfazxrj6B4+JWE2OECa/EktX3WcRihJHlsbdX1bpce/7do3UnmDAU0rS6/Gjjtkco1GRkojjkOuOZ1Z83jN4kg2zORJCipwG/nqp5ppxXrgppKjVk4ebfLYD/X7Bg/Y3Mw2UCKJDE60Z9NYGgmLo04hRqDcIQoYniKfi/63C9r5Q5o7C3yWqeN4MXP3MRUP+/8RhphBlNiGf2yoyJlbqqr8gHvRd6ewyXw9dw5hrphK2r68SAxPD4lJylvDeq509Fmzitau+BJMB21Tpx5X4CkXKSt3EfxrC+YYA4QlR1SyubWJhHv973F1oXuAs497UokxHdq37c1O8QBjqG0uUPqne/ySFXLCbKieOPDLodlPglfOWpcjARsP3bxDOLVb2PgCixfzFHzXAbv7A9tLGupmBXk1IgUT8FJ8MorjLvTZjt44mxhpTxJHv8JZOXpn+M+rNlRyXOQkSuE/fxUZ4kXntcoypWWozzpLs3mjexPfQ+lq8hSkAxD7lKUiFCnW5FcqTOMO232IpdsyKCS2/Do8eMmkLsGvdDHS5++vs96gloERtSf+pLSHoijVHtWfA0cT/oVRLgh2Ae3mzUYv14WzplPfwdBYf57aweHAy46fiLb4O+5fpbrkNE5eKNJqeyWZJf7lBaqqzXocN0MsEI91v8Zb3LuS+IRgn6U5bRJ3eIHpv8EcRJKSCuGoWgli9K6tDfPzvoJ991xFVZOUOY/7xOseHwY6FxbKHDCoy5baNmKoZCrfTSaI8yi4eEJh5s1fi57NyHbSUgEoanOp9aXq8vNXAcSwtU3JosGrp7yQvuc73XYENVBIYi1BhI9UzlLHdh3poLDW5uDbCJ+HMFPaVv1HRJas75EnI3rtFpLKnkuN1AwIsQ5F7gervzGrkZtIadMKkSgQEGtFXSOvB/Jl6p+GLrGyunX7h4l6zmM7PNvFzwWatSnTWzcf/UwvbCp/Rlh1Cds4ctL7f8Peyycuwd+UVmZSD4Shvhh1I7ziCmhjCa0p2f1YTp3xmIZ79RMe/3wwmDhROlnFvPB7ibFCUMijtCPH+++N+1Z+hpA863HLDfCtWby6+epQzogtOnBAcEdbGWxX2q8U3Ih84i4BJoYgk+Q6LDdNmFRzp257Q65F0y+KG1xRrze1VPFpURQ7/wg0ZfbSUbQkL2U2IG5zhQxIr4jXMrJx4muvEvU28aZ0+kkYOawcoBwg156wV+FBvHh0NjnwlHxUDGGzH5on0lNW0dePUEDDOXY9ABrs+eYcwas3K3XSSpJ81xYvYbInisVzRluE+n2ya5eXyHo64d1WcHb7mPgUDaAqdgBFsdEWmsui+gdzT+GNudYfaBbRpONsL1kRqAKDDUYVHSNsHmQKEG7PUR4rMEd4OiPDog1YNLFwolePQoyIrb1BQYyw4QKXiORc76/1revSOn251MMdNBxOF5wi8roekAbxib8WCLTkalSKrZGKkZ13SmcKQ2rNI3RKws52m3yoH6dDpBRFSTOpHLFiSxczBvYyhoUWg6yo2Sp0qCC3Nwq4NMudQXPt2QYZwDzM5NZIx07X9EZPT8LGylMCyldJ16GetUZZgR5OBdbYnLNukwtrvwI7nOKyn6znfGUP3Ig5/IPEjtZFQpVZTH0HW5uN8Bk3+WKYOKvTXU88lUp5Ls3OxJ7Eo5agYcNZBRQplviyN24+N2fyVFSR1O4t5KtwwnhrIFbRgR3jlKtJqhx7IhhCxFBbLx/rqpU1BkV6IB5iZ1GqYxDk80WpC5eRy0VaSMYpnIcYFOALtWeaxRWmurino5zues2qn7Chihfz0j+vEdIimI49kvGCeNHqcHt3kzTJtYOla+HX9t0mrYBPo1fugbkR7JCPIafwsTweavnuvr+MzgC6jr4+vHly5fknRt5Fe3xvS/X0GkyFXI3wRx0BqQa5GJ11kdv/X0BNa4DhLDuK74IMd/dOC+z/mWR+tG/jd7JgT1027q0leyGpTWB/LhDura/K5XyrzRyZzBdLU40kVMGtvYNjR5LeOpxs0vVP3mW8+6QhD6WbBzZeCV07NKLDyagL7e/qjUbEpFEhlObLjpLUaNzlp+qDuXwtGuGMgptgv8mOJyJGqTl1nouYV1hx+nLhW+yUN3lKLp3eTsx6w7JNpOjpdRsTsmD04oEaMWtEI/u9LOFhZWg6Y1DEOD57a6PE75wAxJrM4Wd8dEst4n1KaV9RI00gVrXGMNZjDY0Mn+CYtnNF86OUFA5KZPHAG3AgoXX0DB4jgz+d2B/mtPJD85wa/LRwDMyZ33U7IzAS1Q9cE78OGsVfIaz292xSDsWtC3sd4ScewrGhKR5hg73sJ3JwSBFzOj2vwFfAQE/DazpMA8ZKQkl/JWtbOwoh/9wtxCWAADTkEfnVqWGuxWwjfMSU+nuO2giTCGKcFH0p8Oadu12Ol47pqItWrAqt+saUuB6IB5/kGQO9/aMFCHu+mnhMjov2JX6jqLtyPgipTMvFgafTg3woyEooqJGdWaiA83pAxNKi9yWuKKI32XDJry3o1xwAD9eJdVLZkWaqwztjRgjc/HdwXZtWUWmvVDifZgHn28oWVUAHWgenXeP8cF+Mr9v2vCYm5TbgCNIkL0bnFfURXN3HGLTFMAsR7Lx4r0KHhB9poMLYHMn6dkoadb/7oqwhdULCo2C3QimggxpIoSrylHTNmyTTDEoHH/yMT8AF86A0EogF6WRTdDAw5e9IjKGlL/ifrxTGzMPv3O7wf1FAZGZlSRympyClVKrqKf3A8r7anAm+wkPbcXJ8Japeub4AqDDTicRTOBAgVZjiMYhx00W1u3YONO7zq+d1uvH3h9s5KnXJe7jLQuD+HIKX356JRE33BqIqY+4yIlZlRpnMasP2I2DzKwwxAz0jGTfZvMwBjLWqgzcLSDrcm/D3UeB9wxpwRPPiQmuA873bkY4jPoUH7YP1CqF+PQNeWJT78SjdOfnKmG9JM+Xuy4nc9bskbdREJXdAk6UH50hIK8pT3uD/ayi4TEAGW2afNhr9kbyzMEnYFJeACBSF0CNHDvMqQXTDwyv0NA9eiZjE1Qf5aBltWrZX6zQdGH0j/G/GYQSl0qBo+HUZRPmqpkXP7IrQwIPuTyohAvPM0Ttj6L0KKOe0PnTi7+Z6pfj+0XYBGVAtbfKNRaxe0oiF1VYVCAnsZzCzM2Y1QP0crwZkzILRJWVsukfKuXAI2/VQ9RQIKNgCavDEU83W69nBsZiP4WT1Hr8l+Mporfa9Ueg/ANYnhyqPJNNshmgthM8wSm2qd+7C8lV1iMdUyJyoLDU9WqZPzUgcXGwNgo/6q2IbL4Y8qmZ+JJM+im7QJ48a3tTzfXm6c9zw5WAZXhieMTHL8hVcN0rmUpbikWEzHLW+W0QgVx3oAk9zE5KagHUbDFrxB9ITW5DEHiYOWvY7PXznXlf6hIvWtW/IDNV/UBKf6cGR9fazQegcTSjIUbw3tGnsBzdmr/oUF3GmdQs94n9GpWiKHxgzHN4Jj1N5rJpgz8/TTsRECMKfzKSBEk1kw2tKbCz/gerSFNgFhD5MTSQlxe3DpQB0V0sk6OB35tosKG2cMnD0xPENTafgZt8jyqXg4KYbMabF0m2Z/SzraaWlA52wr5y18MJy3ExEs8Fs+DKBTE95cO6HzXHOmTGFRovgIhErgctWdgDPjhCSNkOFu96qRv5gjxEcXpUp9A3/U5R/LWDiNjTrxgcLj9yZKfviIjHx1jNecPmzj1bepEUeSw0PfG0VZpuMcXLVyc8sCMXZJzrJAWNa2berFZUiaIIZtmtb7KpZiRgOfE5Zo3NsJXrDWjjJ8fC3Qrjz9QFCkhBcqLIRBRnphVI8fLtPJytcz76xBIOrLi8Kh0pNeTQdCSjGRa7uDfiW5OhvhYplmw8RPrCN9tQQ/LRFBxhd7r0ujcW6D8KsDgulTs358+AwVYye7ph+kvmz/6HJd5RfRlT4C90XypzhZ/x45l5VMRf7gOrO+4tiZ35DL9F1mWXjJg9NTyiHxONM+xnE/l4etSC0VWdibqHWAkKnkMXRGeodH+mhpI4jDKwV2hvOkiz7kyxJvSb8CT5uYo0D3P0QklGuwqueKxyu5OAn4GTYiDxCFqjuKy0kytF5X443GuPKvJ4mYqH6HgEg0FwvMwoMYXJ/snHIzv/xY94znCHQxjAZI+wF07dwws80J18umILy/Wt59GsKnZvNVDW/npcAXpF/VWXhaMJEILpf1dayfw6yE59zjgsey4h09DyBmk8IXXkkLG/d5kLGow70uifokFMCEqPRqAygJHEsinJ2z2qr1XwbmQspm0Isnl7qTWjBxca3LDhekG5hqiRiK/yy8JUOyoQ6UffUUGNeCk7jwe2Ue6Wouuw6m9XFb5SzgIPdjfMEV1qgqDCTfwrs+Vj+8v+oEok8YGz+PW7o9A4S09X6zgOkbt2+vFi2cEHwPaE/nnbOZ1A6fn1aIviDK4LRJJb/zmY/ilWPj9VWQ9VmVq0Jxt6z1YazaXVRtN7n/nDNXIfKPzDEUqmQWCjryOCP8LhGZ5N6gAzol30qK6i6m1+aRdgI/5z9FB/Ruz5en+c1AGe9D9Ju/KYsC5E3ouSIAI1e/qSEpx+03HGxiQH8vz304baICo3xr46+Bc8y2CndKTRKqWpZSM291f+sYP900aFvQ6LkdZLNNP0APcF/vE/LPQ2fQmC8roOQW+F+3bHOudCxHyiDnkCDDP+DsrqdoQVn+zIfcSUMPW2AZkV3S0038CUa6zAmA9nmyj+Qi7emiBKzx7H1Y5/XA6grFuTgnXtnixnQpLHrvDoV9EPTLRcDx3t9mKhXZrHT5sSWmHE0ptwqrdkHtFCPbmewhTeflhau5XE8AJd1rMrMDrCx9qqD0+cXwkz0eNQdxFt0L2OsB979sZ74/Dmke0aion1SXbOo/kocgAGE7aHvvjWtI0fJcVv1jw/12vjDmbmAvCN4B32m/ixiyO86GG0770k4gMU9skxmpP/7+2YipfKIEQ/X0u8VkAEB0gA5cV9J4Q7FWYBUhnYtWUgcdkFEeZHp7DDOsvy74WBBcRIXNYOyJ+35zylSs0CZik/NMAAYtWiycumYF89wmIBYXPSKlKELZhKw9q9k7TqsJeu8piI42UycK8/4Wabl07Aefdjq6BAF8nhr3eOjb++12QkD4xH171dfSws9QInE37TWbtMV7lU/aSYFQsCYRxBaIqwY12txgmdvynQJotGx6sqPCRKOJOHifb7Sc1UGoUujsU5ejOV3VAZUVRJ3yrVb7SnO9MN5DQsFAE52WIZwjZVIVVRJAo65ugbMbjl4quQ4sf6Zm7pHMnDknCbaGHKthU8nboTVyXSrC13NVoSHjMKYlc3mzjSmcdf4OkQJX8NXtlgyfT3hqxlMpDm4xk5KnXQmzwL1Xvin7Nlm0mX6jQubqNgq66OVYwG35rm8GLicCI/lcM7Sk9kNWvcoPlRFjJtqpgcn2Q47PKqRnNCtmXbmx5NtQ9Hozo22g3/zFN47cK/dQmHQ+QNRdW5TMxkh2NvZFsFuQFd7Le8XdiN8hbUrjwfA4/DaQq6plIHcrCCisV23FJXJ+YGeDYUsRuueN6YXu8ViDbZyewpwD4T7DbJu34ahi8tdugz0wdKblDy32aNlbk0ZHCtwQ4hf1IL1fvtBNbohMk8n3JRDgHLuS8upriU4C8E+4398p0CE80Q/BHT6/CG4kaRBWwVzdob+vM/MqFMhECBOI4JWPkuiSn/08TsYYGtmU16yD8BJHiEndBEL65WFIyQ8bH7fBvf1WYdtnX4Kt0Q5fYwhVB+Gur/w69/j12Xhad/G/FEepi4XgLiY3U435NttQwclbF6MVb9uEGGkjx3P7VM6JsPfI1vX0CCNBy+GEe5CYlM+HlB2gQrrDGgVdCEPtjAMk9YHlFhOvOF6XrdzvQuvcHfN+gOF6a6QwCQG5xz7g5RaLKBqoGY0351Alb/ca0Vmf6U06CFO92JbWgJq4tKp48VVJN9iDVE1uqtDkTfK7Iv2FuKvipkvtC8pRkADXWeygjyoxUtDK2C/lPw4dzktblBiiFL+VHSQzx0jV7Y9AIRHfNaTGpqKg+rovpW5MS4bdTugmZZ+A4Ck0O2u/ff7ClOTcroykFw1nlyJWo+HikejOxyGMZrmlLG4kXYdASCwawPvRiayTMVWNMM7IbIzGnTa8AnvPkPB6J6h4NFNphb0m3tB468RVgTwqSnB4Sp1uE3laR/uncn8qMbA6J8UMOSbNfs8Qo9dGbc/CNQ/B3HSfkpxu6gD8r4VD7WeetRZKOAQZFBEbJ+p41B2wGtOKecfdNZio0CeIPcJlvR6ft+u8QLq+4n6aHra++ngk/AS+XToLGUB77I7Gb1xW3OhCKnoRK7RkZDHCUn5SmqJuM43OL8bTo2WulrHLFCbg/D1y5B3H+dUgp/BpLBafpv6Dpo+Ld382HuXyxmaVn8bGcpYDi1/3n5GPwOmuyTEwBTljxjhXNpgRfP0f+wJWXNWZ8pHJzj3iTmIBZeufBcel12ZSTkj7PjZOh9Ggv6JP3bdS7aJeZhY8tddh7DC/ekG7WF2bc35r2e+UPM+psFE0b4tGdnpYyrLWV7bHiWBMYgw7P55RqyXtbdRA4iFyD///8LtwK8UFtrhWxeOSTu56+8e1oLo6OR1/Mjy2vH7ZNqhTrxrB9CvBopNJR76iMnOG+Kniiagd6M8TluZdOHClQuuaCtSKiaky3dKRcr0R95pLWdDv6wiCRcAY/QLbwOBrDC54W+3WYuhCDU/JYxVSHz5rdLFgH6k36c+y6IDV4ss71AnoKt+FnG0ZsL5D5X4cNCndWwJOb8/KeQ4ih1BD9kADRuHlClwIH8q7dbBWk7LdoHoRvSIi5iKUglUaukcqvOpwyilimsQMj+EPAs+bnxzLNybo+Td1ROKd1jfnGxun1YmSSkEIzKkGwG/E/MQzVM7AFTc6+m1UhiPELdJuA42RpWfpmUH/ea28Vm8Uz1fb6BWRu8sP3uTTWwNY7UjcXeg/+djXlRic8PGR87/ZevAMYoaYH7y9elMWhLsmNv6jZl2+wg3YJRTaAlaSt+KSd4ZKRpgPmfz44v8UGF69OFjOroCC5hMhGACnxPy4oxP6UxNAQF5a1+vZLqM7WBebqNPyguR2stmIUzP11D2i12LoEKTAZDU8kUJrvdsrb04F4lqALASAkLFCgDpqX/xzMORQhYCvBYDzF6PMwL8TfxVZ8asAqUrFkNPlv0DMJErBP/RGJbEw0Gd/Q0gC6goAT0CaDT+tbFRYeisJ7luGx+BEmvKwPhwZ2PdQUodGx+g07pZQEluSSosdUs7EcDNG5dUzxKQ6BzKsEfSX7kwKjMwX0M6eBgVPWKuUfMRrsnyCf6Y3xB95X9wDXBKf2fiMq8mZy/U7/VJUwTSpOBI67b6Xiek97XopLupAJWkGfxgiVJ3VfH+zURpzO1qT6/8C1OxCNNO5l4QkXEbhF5N7jTM3G/+2tVOcz7GIffZE0ejwmMhRDjwLwmSGGHzxM5oveN3ztYGX7pZ0Vj3g27Uckg1+SaDzwxZc3Ne/f/XYgWHyyAmom2+4N/+Iw+Fbxu1w+3LqpMFMZZrBkA8kkysDNI1oqPR16pPcsmua5rsR+ykRRLLMWOFTSV5n2VMW5Y792cgb2hckKBe+SXQOKF27GmDDudajbuh48kNzHkmMYs0liUOmHOazMrk+KhUKl03UYasK8qFBS0S0XEyMps283DrGvWPPrJ4pKVpJId7D94JAMiffxBnFvv5GUssSDQ2jtQTU/vmTKBpo/50fB4ShsULuVDhS3Sf4130psx9tc0DxWAom1caJlfcI4VJFuSjLTsAs868xa6Gg30pN1vuMGrfiVPNRQ3OchaiOc8E1g+4qRcTZMBOkgIEE5BqjFHiBtCIDfx6clId4GmRpFPieGjiV1jUv6I+2HbWni7pfFYwNCVbjxHsN8vsNwquNHSD9pXJwa4ZBxk3XZiZafDo+AyJeWjdZdV4TdHZ94d/VrBv1uml/XFclK1D37J03HuHvSN+wWZ0CupOY6jxw795eKThxUdvQNmTGTfWjCUabGetlq5I8LHn6dvbcx5l/re2oiV5RGx3znurEtq1yyaT62oaspCGudDh2bUpoltwMtnDbuu118ZY6ScZJzCyXa3X++vU5+AKyNeJsv4OI3D5zHjrLUbRLAgSOhq9OrG5/2KoSst1TwsMUkaaWXvWzr4V8jIYfDlvLAUHt1nYRqr0hg2B7gdG0zeTT+v4Jcc4qP6XIc2TkHUNAkO7n1+GIIkddbVQ/uStw1Z5ePDQi1kMVBPIgMoseMD5vh0ruzAO+3x25t5ikI/E/D+msDE9m2rbE8FQdmBEJHFRMyGfowDp8PLE+8zCxtl/ghuSePfON3FuzgFD/0zQi/0Z3pbW+sUH5JEcO2+P3L1HmtNl2D01O4eQZiXv9TkMskLIg9b1o1I1By5cVr9vls9sVoT5y1Cim//o1dwS1k1R9SdlJpI6YAy2K4HsFcsudKxAFFQFxXr15xR9B6ViAadCZ0edxeChV6YF3uS7bI9PA28M5Ehso/5QN7gAmiFGcahxq/9uxNdu6wp1CgTpyojAcTMxjivS1Z6L1HltBnU0vnvHWQnlrMAGa49hnMWm7uNzfzQdUPn06MwGpGwy8ZqjgoCuIwZWQm1Gz9vfPF9GcybzGEqE2jJzzrIR/C7DPg2eoD/MHjnKkDVvULDvn4irdS5puNpyZ+dk1wpr19n7xuM6TOV201OC6USYl0qeQn9p0+/TrMua7VF9J4TXydcRDU8xvRWgBPXXV96fqXiRmoiUdPg9qVlTV79yKs1OeJU9NsinYqT61hJBVcp1WcnZCVwbjGiw4y/YV0GlZ7JEUELA4Dscpm3dxA9xoVZBvxxqOYVkW5Qxf+8a9h2qHV6CtICjAr/WOd1UajqrEQOxepmLrbucTPOwlOt+044KRKibs6RwEkTswEbCoul2AACoPRnoJpWYEL2v5qAdkSliS6lPPRtAtui22BlNmdKCSh9oprUzuyVZoO0RljkAC7jYilyRAPUvTeEqppA/XpmKPbw7duwe58N4Gew+sdw7mNqk0DrH9VIbzqqD4rMIb+O+JkilNY9OGRUBxnnWQtXWvGQcGjQ9W5y8oPNyNyvIgiD2pi5KqozX3yvSaUBJhBbnPBC7i9uABKZifMh9QiMQ3iB0Hx9RLXBSkKwTyqyx7w7+EH+KyUhjvfXL2OTbjLgX/oIsKYOhLoeAotFU8o5L8zYWRbdXWM+WlKNx6qQyUpgrCIHeD2DBUzPu/LKMVMKXEHkFKRrTUzI3WuWAj4+hcssn5GgKRA4ajSmvD+nM8braOmhVB6/+VdyUgPXGX6BSKepivnpfDBNWJiewWgjKcmxYiYic1zR8w1H7Efq91966atAIIeWlkQXk5YocVlFn1dpzYZlI1vkvOmBje4q1qeuq/dAvAmc88xHpE1yurlmQqxTOpe1RPktaFheN6lWJxxhU5nFx/rRmzxTiLNjmPeGpGrZv5orSeN2sNjhyM1dXYmIT15X7nky+I7zks+Si0bGlG4b6PuLjbJZT7iyGiJmYGAONb0gzhYqECUfIoX6Z0kg9t+x4O06PYi9pOQRwd6kre1reW6TTSjNgqAbzWsqnfKPa6ZYL4TgXjQ5fgWATS6SWZO44kxJymbEigy/MJ5chgvoXvZwjKULk65M1NIemavjUZZ6g1xfmm9UmEbXb/6jsfUNXBRZ7CxhbpuZWQtg1fpAnHjdgrXDb6hso18dU4Hcyx2kJH1EYmvbch90UGQLCkAoqJeTEBi3lkf6BHwb6lXLr8fyZ4yFrWHadNlt68D/ca35RRTZQtO9tQQSAUjEP5RQScWFsi8L/E5c4VaoSTjQhxvG/8YeyL8NxPFs5+0ah+NBLKhnki7h6Gg34Brx5Xlpw8slj5BxaK0Y6wyj7ctYRhgRsm8EzCpESxVh0Ui8yxWK2uujJziwGeKQN8iFj1xd6J9J228vp2kEcvxXdneuNrSzssFPaVdpRnGxr/3FKlOmJSDPG4GX0Y1SZGRYnhKGJP201Ei8ecbgEHcvQzlhbbIwzE4hk2iyLiZf9ScQxjy1IoregsI+QqaGyeJd0k1ltSFMUKSMhnzpgVniySnjZFglTD8Z7Ten5DLC3ThC+fxKsk/SzOnZZA54p2iaYPLcYv0Zsx562aShfFUxyo8x5aOUEmt4NZ8uwsE5EuLtSMQPzk/6oakBVQqO5iLonupZbu6NggkLtq76zmWEQ+JB41l4zNUjwsm/1+RJAuIgvnSm+sm2Hr9KIMXUrMyjCLaTKmPLeYhUvi/EzNfJrbUdQFkssAJPVHbBWUfkK9XNk1zcVIbyt9icuaJZ9wLdqUY5hApYUUvZ6ft6ZALd+EKEPrl0qpr5kr/wQXwV26o2vnS4hWqLrV1xcmryRqoqCOpU4xu42KPGng++n0xmVPWsQ19G0X4UnfTUf3OaPHsFEQTTMVzrpHR791/TU1IizM5ixSVQp2TFmIFshvzBtVtJS/RTEKi2F7ljOVZrE1Tw3SKTrJk8QWbMrzQ0TqNXgWVT+kuoyYASGp9AP7G8u+ac2pTg8+AJFNUvSnbKBXyK/HTNfWlbgMRsdiYvJdUE5Rd9HZwZA5quryW8f9p9zzjcrSMojNMddZmd6ftAR++p1ZSOZL94KDkDSIQZkDkTu1x6YzdM81nJTNaXwadMTNPZU0fnZVPThtxUde2+8MN1/Xi/dUSMVaXOcXfKxXZ3vSQzM9O6KOj/pW2Crsw/Hrw3wyKlkrD/E4jRvaxrXoJv3OpNeUlRKEgKGmtog+psN1VMMyL6Rne2wigyP4hNi9QWZU6GiHRW+epFBjKrOplAoyo18vmQ+Cg0c4tCciSz6xzJaVxvdNBVB7Yj75NmUmMM55zlJQK9XEgxhpPtVt0WgG7Cy3q04PPCPg75W22LjYjdmfZq4IyBB5CQRlkxA2D4c6p01hMiS3sA5NEcJ6dNz21DM9c0qMoETtu+st7f9odtGRSY6sX1uX5/LFjwlvTnYK3X7wgTuzHQaAe/MxHLqt+mvvNniAojseODtvecPCP1+XlOX8Z2UqwRZmODJB6WLffHv8qkAY5xnYZip7B60TB+yJroiYEoUGQnYrwIBUiSz2G0PWm1tjEkEjIj6tPPYk7Gi+3JV2VHV93BAz9ecZQdYwaKgdDoCKMu9C3hRvKxp5nPf1+sof6CX0SUsvu/4CliLTUSpqXeKAJ7QRNr9gOHChf5faPqedFNdvLffL6a04LNn2VncHQbgNKv0h4iObnHlYjShybxLSYh8FAmHqUIiNwTWb9Kail5CsrCEppx22yq2WXRLYD2eJ/WExNn6X41zRRXf6LX8YoT97f9TZWFQzo8/BBpnWGRq8TinwiFzWkUwV2ZG2cHdPNJC2O3rNNl8i0uQYSqbR16YPmbDRklpJxRw77pscuE1Cm7CNsCIKKtpQsHZagWTiF8+CtEWhDO9ZXzlHdGTlV8LXyCncOMzf8clbrSTXK7TPF2fgjK8GfiVaNudcuWyDaZnV4VgZb+EVcRj1Zhh7/54hBqz8EQBqHLL06U8aNe1YtJAlkMloxTXnxp/iJbglF2hO3SeqlubW+NQvyOzYgZP9zjH1rHpq4gKrujhbb+sWyEnJ2ca7w98kjFbP8RGkQrEG5QCFS6wCDxRA4ISquNbidb+WY5IQco2g9qnlglqV9X/yqZ2SKNs3J8uUbxToD/WTBUClg2Ai9mb/mckFkoOAlM3ktb45PKjBMgEJt34ltJGf7Yh/Ya18j646AtDVUloMCjmpEI4v+81v3zTjhfHgWpQZLTrgSEtquJnLnSEsvkL4tLzLcWxfwA0Nz1gr/1ZbeSqrx3szy9wIaiQs4BLNQEP7EtYOdGF3091wrYeaJSLRc1/yDPt7graG6jHkISjJa8ueQYIVUzZ5LK/i07C9R15f3pqJBNnUvFWMvXBexbB/yMuEbPsjGH8mhrdN/2HwHzU8ZhInaG/EvqPvlCeMpjwNn8U1O9sDljTHjIJFo8R8T4EyT+Mb4lG/M0WUUMhfJMZpjMB0XBIy+SQknR3Wvzl+4IecQYce8QPgxJCMdfAdNpxfSpFyjKtWfHC9oX0vYn49dFNvu0Ns1N28Q69aPzHx9hFtLiHQN8lhnp4IE73MRmESWcNvts5q3x6AlHZ8j7TYBxpDUCFIT//153qasxT8iA6dxAm52dFb5M+APCdXdoFqhwfZjY8OYo0+7XvszoXgwDvNoqgJKbKHI2fPVVJlrtFBm4kDwdqCJ6TKECRfUoKprVEFtdoFf+dzobcdFwSX+Qnbt1kGScsR2u6grwu2DWCAj46kSCP6PhhRR2QqP7psGiYnac6WV2KcVVZuR9yO8kdXo79gv+sjy2lq+Lv+U1FDgyeuinFk0XpmEBPD191jYOq1gYXdLOjJRb7uOhlxDqXzvNXAhHzOimdDHX4Z958urKkiiATx3U2eBCKmr4779zidXMaFKWg7EZtJ5Dq9EmncKiQq8Ue79vBqJGjZ2UY9Tx1AHXNNpjAUx0bMy8MfAmd5Qs6sYfzbXws6cPrVGisM1bghkC0IEtrg3CZmMWWz4IanydhyrrNc3pCPN5fSvsb11xIc/nVXG/hDTgQzZ17QfM8mu+PMPjyYJ1UupfnxHOEotYoE6GPmRn0Zt0nJ0lUZ1JpP4YdtWdl1XS0/z9R5bnnmRdXKzXpR5N9Mv+I0IkWq5c5zaP8WOA76fBhyypUr7aq5U7Mn9Sl7IiqlguP32b76QT0IDQDCGBktUO0Q3sIJIMa4gZVb6fA/q6KPQae0Urj13MKJlOm+wvVsfHo5Vizw9GskOg2ADG1r2BaeHLuF+At0gJFmA8067LnS45gFFJwYbbGH4ZIlOwBUkWVutfSXcSngyqzEX9HS7qgQ5e65op/8QlSvwPntUihdDTNUp3UOuiKiWIgiq6EhClZZNsYjux83L+SQv/tvLgQH7qsX1YXi9cj+530ZMwmI0CMp8v8+xRrXVLTEDJOiqal9CPw7Fc//Eby47IesHIxvUFqKOEpYvYRXvrlI1VkUKSJ0Ql40HbwC9AihNR4sCXnnxKMji72iDrXfavvIfLKzecZ5yC2orzs/iCjWvoRodSG/xpv/Q2aX7c0VlDwYyiHgIw8d9WVY8L4OzX0SVenKIuOhw4DDZKIamzNG4yKzru63xjXwJjcVrAXji2i9Or52VJh/+89kvkEdqR6fDZ39dqPBKbkREI9KcKikXdGaRS9ITQbe8XZxKWl0ue901DQJkH75gV1xpPKk4eAflpfgtpKGf0IbAO/UjyCYXS2W3ZG6wlgl8fMHLvgkOFMeSnsORkSqzhYXovnQua1/bAWLxEPW/80zxLNublHjOD5iRxx2XSVZGby3UgeciQwf/LU2KIxpgDNxTn0JT76vwQVSllHKifZ6JFHXqCd6SyYlAEookuUHO8yvP9wEXOpCRuzaUQ7zPTyRW5BleZ+MiObWATzG9A8PI0TWmoqI/w1gXvh4dBx4a+0wTS2OiFW+3mfDmyQu3Yp2/7F78GppBSAmofxb4ILQjRg6zOMGcoRKvBir7ZRWrquDZRAHoa8yei8sHXft2SIEg7bnV045Y4THrgz/GayqkRwBo3B8M1T+ZkQAMdLQ0jmkZ0wJIrQZmLxOukkKbmjIxJDumrzcXS4HyvSLLojO5rj12BupUZWIe6t4tzXZvNq5w+5wzBbrBOPlUCaNX0l/QSoyLwpmPm4+EdZOrm+xWblTXSPDSagypPk9qwmsA7Hv6hKsdJ9NcBiOBL9BeCQSomuqD0Ag/AihZhkQsp7vOtQJBHlbkyoPsEb/XFpqskIbLOH+xpv+HPeqM2n+MRLoQYgk/WTqeieZfsuMIbY9xShz/kZSA5D+nhznkONerhBiLWOfEUAJ6wOR7NH+y4HuX4gd6xzaX953rHZSKVrb1IM25+/ah4PYzHvVCenvIg14mldg1bDuSdZheWduMwSzfAn+X3R1H8QcsjkbLDdwS6OAeO4NKONvp6YHl9tFQSNo+4YTARv6bdNIA57xqAdz92Y228dmCL+wVNoVpY6XjM5Tuz8gS7ii3yBEKme0RiNQgs10jeCoEzp51JXl2pEJ4ELNJ6Yh1heShSUq59p+HA1F9XZwr6DdEsVH3IH/IHcRw726zq360ROa21tY0LMEbduOqtM8DeHImDUV2JtiFcU/l/o/oJQSXZw0nIkyN3ugigM493jkx//BlD9YBeg03ESxJGGaJEEXGHn8xd0E8gnSb85yn+Y2qcJ+kgziItq91NkVDHeQks5UQSblVZOiQAdom0xJWGEsymdptOiCX6u9QjwUKuwNnOO+Ldbu445IDLlZ3sK7yAdj42d0S6FCHbDk+Eagz0fY6xdypIuAjT+/16xEdbQVTAHEgOneNuooAsLpH2nVgRb9oVTawjVU14E6qMvxII7RtHYcR4/fB//C/OyKYYuFPEIgIsVt/2FsX+JXyYH7x7xKa52+hcyDV8iBosqwu7UkLHaiZCnXNjkzQ8yulowgDi5YMx3oGz7vMlaT3t8uPVZP+1VjERbytHCVr5Q9MCF+UowvOX73fclvwuCNBaOQ88XEJCu1H6A/FfWQjPlATi0X0NvOr4FzRyiUfW/fz1oEW6D/NEBufdYyWIoltZN1YMk7GmsX/+zlwWFxqICFwqUxDYaWl81NpPD3IJszRQoTudW4jqBS/HxJp0/ZTJUGbcPX+KZVKo+6pK2K/bwLDYfzn4q50yAr/ct9E2jEd7puHzZhh2qv9eHPwX1etihxzRVXSgu1opN82Wx9Zlh2sfbOSbqals+03gjQih3hXCf1h7t3esE3I5xkGKe2QAekf/Ul8bAMKXDn9KO0/WHO25DDuKCfZ+cZPt8jlmrMGDoBZh3gCuOwnBAaUXtjvxsuEuzCm1XiFalRB2+y9gQE5KpqGPNetFH3Mw6R23kt09UEph0jTRpsD+6MNu5LUf0yKfATLxzl0uDZOKPsT6Nz4+r5Vfy5uljH82wMy9B5Uqbt+yBWS6Q27Lr+4JMiU9LdmlzaxoSR04jEGkv2awqv+TrtbRkMmmT1MtT+YmQIa5WO3yeiCcQH3RDnQJj3mFqylkQTtVP3BNbAms7AK7co7nmoS6KVm2rO2xom/KNdtv3f1fEUipqJDNPTTrV6ZcW0daW6f6IcyGFPX99OpMCsa1GXoctHOdXiIuXh6vsDKHoWZPUJpsDsw82c1VwPSwR+Q822OB/yGpvemA+2tZ9qokyEtXWUSM3PySS5dGVjkNKIKfNIpYY+5PICBS1bjsmt9U0PgPOLNUxo5Ppqr1qJk9S6Hjbopk8N/CYHt1g/c85kBFmmUYu0CuqeVUXcbAyxZ944tMAFBFg0xHTyonquWFin5S8CJEMouLE25nu/eOe+I0iXDh9kJQi/d2RW5Co9HE2/iyPku1NwzCfkxvul5/opVJ4FoDV2ritOGYy/y/+/ux64x5Y9KBBfMJYGwwnV3NgXF8Tft63TXPIFho/ru/7LkSK5gD5z4a3ZbqHnneQoPPOMxJpDU4RN/CLMsMWofGD1fIUoWgL/sFNm3ualntL+gheTBbHzwv0rNz0xQCk04PHxfnpqHRaQ/0i3+bcKbDeD+x2+HbHN8X3ebjatnbK0iO6McqD633VI3vbHAqSgUoDesNJHnEqwoQ0Vutn4f1Y6eoPDA2aoROTEWlsE3oGVAtHgKO5qax3O/qdC9xmbNVsvGWi1LBxfsHk5VhgChwU/KiWo3Few+3/o+5U1Qc/h/tWPV2ykGXx1kUPMYTV/T7fC/q9ymu7tWRnC+ElT7ifDHERCZpt/Iul/ud8LuiwKK0ImKZo92vhA6xSBIFS3r79/eJpSXUvsqcBmMv0WZt2Yw6Sd9toHdvqEHa32LWTAbaH8sCoKxL5xnvKFhbjTKzwkoUoBKNd7fjDo10HloIg8iOjYWlGlHm35ZM9T9rU+7E8BWnqWebOQ43/LqnxP1jl/dfojj4G32zGotI2HcmfaM3GPVTlAYEL5SAyeO16tD8a+L244U5KX2hccPtnIkshI1c4wraGUaNOG8FQpgZnroghVQiJwG/QgiSQfCzLQNpst9jO3n8w8MTS3vLli/8lIr8+vRLRxdax0PYkoTsjkL6mzH8qvRGG5vwSxRThZ8pikVWnwUOL3KcNRgFEmZ3GAe+GUW4DOVzTI3HBfZGxy+5RuYlChXC9Gq1bHZE7jbKKunqBZzkLGEJLJcPCnHi/1UCVEuOXI3x6luC4W9xNqghiOcorzRpg2GDqJIjogZK//o+TsCYIEGqtN97i3JvanYPNuAZ4rtg+XbflNd9Ps+IxggsLoiprHHkREmNkC60/GVMwerpeKFBGWtFt4AfbJbwODhMJj9tveSW6W0kJ+TwHUKBwOrhoZQsuVI4DTZLMnIT8yZ53iMMbQOO9XLlKvO0jnXgHB5NOJrNLEBYYepx8tsf9cMtDR/pt9d13SIBVN/m9CVgtvWODj7dOxH+89gi0Vsj+kMKHgnCM5DlEt4jQaMAUj/hAuUWJ8AxbxkVS6zODGH7w3U6VTGQDLMKb6UpLXHI8yXtFDGC29BXNzwj+WUmQozA++JS/CgVJac/nDz3Sac0Sy9K+hK1/2sv428oLguWT0+UcPPVqhtPIPSdyetgt0Jxi9D2q8WuooKpnF7IzESMnAyQcZ3NsEZo6cQTQEs0vBkUxckY5LaWVXnRDp39KvacEkJC5BqqFd3Kef6nTcc9DkgASTQ0urpzwk0epKp4qVfOzuo6IneCWSOhvBKBGtXjpIVupPCMAwOfid48KvGFRvooYU7Wc4E3MVS8K5k8PIXYdlqD0ARgtMPUPr3Sb8FYEFcd8qPhU2Z69vU/2+37g/BFjP2FbmyHYheM+IQXIk09f6cWPFr2K5Gt2p2vL7MC8toBhBIQh5jc1jZQx09TGduUrIfqv8Y+YLal1KaZSk1bq71eYm/hY18UZR8aHpDlzyhBIr4HSffuakyWmcudJ8swg5rFPx98SdK8N4MgvJ7S7u7FX2Y5hHnyII5Xxl50kaAayWdNesfQvx8MAnRmM8zlZ98cBcs2xFjWy6B+siKo3ncE/+ZK3qFCZ714nk32PHFqjN1qiHvabPhCfYlDBHIngqayCwJIQHc2y+DXtHaP8jcLhcJ/M9Qy2wKrghvRv9U0EkseADdrlU9GQKGG72mDB0FRW0tFE+xp8gDN86Zx2mE1IFLntaI2NN1R5K6O6Ur4Jd6WuP70MrjnXESbthPAXZNDeu5BNNthuk/7eehnk9FmN9/qGvVMh6CSf+IKO3xt/mUYKx7C1I0qsdZQ3JZRD8ID/nXw4sYS0kZV5YrA7g4PPsuz0wUyuEJyMQsIFrZLyIPfmUBOmsxHDTK3sp/caUaZY9zn7Kr1Hja4oYeCh90jlZmw39H2DFQrgDtQUd6W0G7IINOCwQ04Ut5O9nijxdqlSjxXJMYDgswiQ53oFpfh818VJp2u1xc3FObwljBkHGTeeoQKAcm0ls1mi89fi0gQASjrvNYYZ4j2gErd+qwJLV3nss8pyRV1cM7yfobMZOQBVteD2I4IJv6XCMHaFOpUiivQ0fjrjMbAW0ysMCse6Gc0m1Dk+ddY9FWljkrgnFqRFWqHfv1vwBzzIgPdZbTRLsWxZS9N9d/UHSzTEmBmV3PGAK25WgYQKH0h9GmDPdeIstExtRAWDYx9Q70W+g2e1DXqEYMvlM6SlCbbdqG49CfWU3OhbPSJQAAbG3HOkJAJ9tvxY23ePafdTjzkQDN/5kCYIGSmCNhRjSc8TLjuyrSWNiJdDSTHmKCC3hsGMs3lvHMmcoHKo9PBkOwvAd2eBcY28eCLQGLVRtcEin9cvdNaWkLVh/WTq4XE+iUyDujJBP47XPeFQ+BwE3cfqU4Fu+9VzmQks1vtZZx4Fz58adYF+rZLoaw1v8xQ+r1OGEQujn/tyHtn/b0kNX1zgiOFrvSijlOZAmvlVfwmNdIDaTfs7AG14bgskAnbEBHPW0W3yxNoLgdtJGNYvSTw6kdxct8MxXnrZKxtLeqSBk7/ZJ3uELuEfhgzrekdCGHGPeHDTQkFuwa46wkVAOsAAjTfXvhg8A8Crr8B/lXxGjGDrzQz9/jnx8e3Fqn1rG8IFg5LvB3s9yvXUjNCddld5dk/bqW7CR6+K4fQONlLkTfjlPaoGr5T+R8t8xwVHonfCN6sTa6+eMmMlfprdXlqtgKs5lqSOe+/T9mRiHx1NfgN8nHI7OxSHkaF/UuBWlyVQblnYZs8tgzd6UuhNVGGbCoUdLF5YJSR9Fk48rJM3QiV26pJB2i0UzsaZuaQ3z8uUR7VVNZehmV3WfYsxubNcZfEhrJQTWxGB+x0++8Tt7YNkZHRqZpA6xJAxI/21nmgxQfxoitGvj9Iy4OFlSDRR7iqqk9HUZE/jIv6Y1CxyXJqH3kXCVMuB3ILMNapz/HHGpjmPIugfLVSNqTOjzQcSlcb3CFeeL3x4xfGNsbb4vJTXfaWVoKrImiZHBvAypmpObnyM76zDZso76hSnwZSZBr3XjOKoGUFXqgLBXsAnXLpZtYC16Q5F+zdqS6y80fPxQJNvcWG+YtdVNl8Pmu37T2vrcC5dlMu4qBBqWiuqU1Melck0SRgigrXWIe/Pztc5EF6zhyUjWc0MTjt+hGGe1NRpB/gFDnCLzsdGkDt1w4RShG0fWkhPUMwTDiK+yyBP4vbrn3TXyOtBSSTc8ykJ/K5oYdkWskhG9t54SaDdy9Hbabj3h18IuaSo98xqV+fPbawkr647qjwkW+yn313b+AXwuJVvODfk63PpVPVLLueOJ76svsQU98ipQE6jawOXLzK0aSTcldJnjiTWwCp4EtK0I4x0x38cskbUR48/eSsPr0aApdc3Bl+pdndHuu0bSDbiPowVKMVautDC/iinAhRdZS0tSisvaf/rXijB79eK0rVoLMa7PELzuV9bDe0Jv0UIT00TWLYFvDKt/nY0WCM4QUbsNEmoab57AzFOFj63WxUEe8H5DP2JMavH4XwnrFqxM2vkPf8c0jIEjn0J1kRQJ65UkaNKEY0zbESxBIsZgK1htSM0wmMI4tOaODbAMbnWcTNnKIZKSmFK5wpQZf+uTzWIxNBDzw6JljHJREZMYNtcxVwWvAm9hnjDaebDcB7QFy9S4outfx4O2D7VHOLjSFAaNvspss2qhy/9KHYtSh0ezJNfbcvSxSL2V+Fv9utq/RebuscvrPVWJhJkigg9HdWjfVsmGvOUk3MPQlmlxnguoM+HXSWyUUlarVtl5pu0Z0tzflG1JxRu35M6MQq3HUHPUDNPiF+CQ/2zJLXSAEwOJR02Wxh27YagTO6QJT1LV6eFnhMMEhZglpj5IPoLzg0gIklpu+NR6Xejtekdc8SvsQyfVY3f/knwmLZ7e8OStt1bbFI7PYY9/P0KRtX58V5u6VVTMrnK3++JAH9s9EZym7RDZ8+TNKR1Nd1+eGZXGSscf7HxmDRQCCPjRf3q6QLnXG7pkxBNKJv0oZCzY+AWXmdl49AtlWXU+xicKgozt3YAYCRuqnmNx1HUEBTbrOrCy9uGzJdNKkUBnuEZn6nnJqx1GbLh8eRAa5BZUtNZ/yMlgv5vetu30SKmMtlOlh7mA+qSNbYn6rYjYXzU181+tr97mx98xuHFXhfnULGkufppTVJlz3t40DNiunbMr2B+rCJ1v1y0ZYK0Q7Gm18hKQ2I1pKq0u1wN2Hm1JJHEHa4traicnveV0BkqVUBXFnKskP8kC4uActqZbZNktnWmoUao2PdJfAtiyvwuurAOERchKzQ8vvCEJP15XlHAl7bZ8dH3tlFg93lZgvnv2C4uBLbcGk0ABhBlt4Q6Sb4F8tpfXNKDs+DvZc24+Z5W/kl1yRoKIqiXt1fzQfjLOw0KpSjkXTH71TLIytASphZzILGAFf79mSbKs6ZPykuG4cov6ioakEJ45XpDRu4Mb/p0U5DND5t37P/sPPc2jsVyLuipsZVpijS9zk7LpnQTwM/fGjnyT3xpvGF2aMeKiqzZRzgLV5kRpfl/XDIJreKCmkILh8A7Jq+8SOcj062H1BNESnutJ1auTvrLIcRGSH3M2W8d7d2w46vppg23AoVkPawvkYspRnVs4ItE7WNGOjge1ACXsK0rH6SE7rBOZx+aQVxAiJVZfLtUCkN2UZEoLpLePf+tZv80CuXZBLjw9IWLlQ4z+BPZjPDO3VICzXpx+cQ21ddG4/Ne7DwUdYK5BVmcTNtGjZIzaLFWD8qCyBqN7Hh0Vl39BVxr1AV8kkhbnX3EEpg53ORzZ5d+5lic3dq3Luuqrb7PxuIY3uqcqzcDu+I4MSlj+jam/6d971iH7wh7QVNN5svuZyyFqwNbCBPxX9plaAJgP/iUch+N6lVIkGf+CW9/SPtWQKFmA2j7LgAs9oVTS2628e0CMrvn1OcInCjXoF5ggFRMMUIYIxjHNB01JoZl+EyXe3M1c4tSkSx5wY6V1y/P7YCIs7TTSNirci+hhmnUadY9JBGBQhc+USLqmXjaS3oHxUUoX1Ic3Sf7BLIpiSgv2ic8SEChTpxMOoNCLxilitlEa0h4yYIgQiz0KeMezxr1ORPyq7xc62iGTzubcNiefIa+s8VEaxkP2hGi/NgtXxHjpnupdhVnNoPoetfNpC/UeVXrapOm8lcULTPHL6yxCPw9u2oxp8Gqbbb9g+0vPVp5uyfqbi/f/cDJzhdit0zK8NoBXd/y0xPsAr6ynUj3b7SjyycguCnLCx0rCrPu6KFJ0xJOvB/cCwZmyMgzH1b6PTK/oSebDpp0vvO9F4WNvgtn4iJVvNVq+7Ck7X/BGZuvkc7NQr8w2rNfJaBNtSlvqGgcvbJZ93omZaDB9yMqYtWKpkz9yGJysRGvNJKfMeO796uQ1DaOeM2zcG4S7zYjZ37aDox9c8nyFGgHleCAP98WRAj7BmD7XPnR2mDHqZssrQFrxFGZh1kr+U/pESFdr9NaX5Al3mVpU1d8KhfLZLRkUokazz97YgZq6daIUAU8dqQ8jQRlPsDEQuKD0lo3JXlDeJJZ1rBXiCgCl/3VFof5N8KIfKs+uDoGKVd1RPfFt8V0a2lw0Z6ujDJ64E9jE3QCtBrH5M9ofyxMylKcq2r4uPRC23PTnYUDHFJqSno7v79VxcJVVB8pliUI5ktsYfJ8/0i2cmPXDGcg5LPG9wI1i1lgSEo3L0ZB8N8KJ8ie5s/bbrIs1zS7xzH0FIXMo45JQh24zsfZE3YM1vsQpugmwyQcM9UmqLoKp+GTsHkIZGiMfcYL7K+mpCIBCs6qVWtsVgn9MlWKTaEW7NigxRlcQgp4mzQGcimuoUngMX7uQPNC3AuAwAHEuz1YkUQ3VyUCZhd8ISSneD5jxC91YAB3uF26tjH0Iu4CFKHxoltiYxZhy86S+Lrg+QAAXLF2wmpohs7lNIgTth9yI9+NwzKkuafuZlXvFYwoYaMRS3Z7xtr4GVvPjceL9BYbH1bV66gr3A5XOrlTf3SKnqG9Sr899W32Le40Es64UVf/RnO1q8yy/ep/WZNKQIMXhhKCOz8SMs2AC3dzJ3h/bdHLyTX1khsl5I1vn12X/gGh9oexN3AU4y5cEDR5KontQg3ktGk+xqwELl51KisaKOdvpSw+DSmYBuvLOSLg5GPA5sgFp0L9kVJ0w6zisAjdcB9kDXFQtVfVgB19jiaUnbvsUh8U1+T7hSAYzPtC32UXvniVMkfi9NjL+JsfzrFIhoCieg8EW+CIPnlfCJRjKzjLLEhbnfojRDa4mrjBTQIP1CPHvnIsJLMEFs23JkMsM7+DXrshn4nDnZqPGT7sSM8jchSBoMXJFfiU8rBABjBoHLcBvrB8zyZr5e3JboBt1g0L2oEyY+HjygB27pOYqFevDjlFXhCVEsqaSXS50FYBJ1dQg6tCE17K6WGJSMKUDZIgjAh+5plPqcl6juVZzdbd9Fk7Lj19fxFLT+wTH5D5cVFHYHt6QMGYSeL74hmUK1z05mcEY8eCV7QHElhx9XVSvp1p2rj9zG5j998mkBj2gOBBOaVSKFc1VleKYGS0rpmsENsMdFvjp+O4cC+ceP49Vefc6wkpcsh+zMQ/roV+e225fjpR/NMi8F6uUZhfiWDwT6jGhnfJtNpJK9DU80cD8ePsQLP7Gl34zAPb1habSMu6nanOhin+/ENt+lGcepLU6uXmAEGzhqIdbBcpiWDQGyn6FtTINX0yyQKTpLkCjLk+5QXlypGAfPhwjx+qJdnXoSUm3Np65QKuzR7MMBp5F6yrnZytCGDZZx1dsIa0M12oNlAb6a8d5SGB+Ht8Thq8nkrznBZR9dxksBlMuL1Nhp5rwRmd7lyR4qgdtmQM1DAzgI9Tj9lJ34S4nDWlcw8oIr9LvE7oMfSIQrQEetLRXGLRZmMa7kynpf0qMVBHU57hfvffsSP7d/Ja5qt+SVxaeSzSqYrqB7bAxnJkOk4MpWM+GrRADa5IFla3rLLuovqgEQ2uUryxl2ugUatAUK1tGiCqCBg7SfSsiSj68vqnPvlrW7F23yhr4fXHxp6AxP048NX2tcmxiS5Mn6o0FkydCG4dm+EwUWWjhpeNUixdtU5eSlYZpV3zkUw5GQbn5duviNIncrloUslBWiR1vrs0rp7SonlrBrA5gC+Hks/Fs2Ja59kCKDl9BDt2D2gSyVzGeR4rSGJ4+yIHMvZmvbIbaKo8b9niR9CgI8lPia7mpY3bob8c08GB/pBjXEbAfKrLg3jmNZ6RovZ53sQ7vr2etWpAu3HPFlX7Uc1WuIV8OIhNhsBddUjQFOXcE84OL20oemWX4Mj6wiGKjMU4kp595HOqw7DJnpEHUVyvVzeLBEwAEXHDbxnSb6chtwGyONWIabCEXfJyA47KrCy8szZR9nRZXH0c9HR3ZmUO4/VobuzIh7oKsHJeCG5a+FiL0NiLhmQwtPdpAJ/z2drIP8iyQe9RmX5oBrZXbTJHBiDeer0n6Jq6hX0dT+PEfBpNDZcghCdZv0e0GdOph5/Me0pV2OyQKN/08h+meKurtA8ZZ8+xJeGFI9vA7kEa6XAGif0b14an92IQzT36egM1oM0/bAm5kacxpWzpMUCwWrPKSeDsK7xwFHWn9tZ+B7Our8j/OfwAohklz3CMGlH+E/e9nvHjrUCoAcYw+GdaW/+Wm8YLlc02zS22kaWH26U5kDkxTIjU2MWUiLpzlcejSzWzeCpALXn1fOW/3PqUsJbihnqxwrEYPJuIlhy5VKO5XrYGqk73FALMBZnjtSUJWy3gXqx51tSCZWocRBv0awTR6owtvlBMHp512Itdq4eClgpvegTrLPFG5gjMEPXd4KCmO/ltj4FnGISNnmu/iDqBeNOH+dVvpaOeHWyd5Cjh9cwZ1E9uR6Xy5zv3rJDfk8XwvOAcRhDspd/ZQuqegLkPJiUNpeMOae1WNJzxJaDgJYSfyvTgM7lN8fY8qvHjW3OZs4/vLB7hCAdceKesGV4M5/NH24LV1hCnvjDluim5Mw7CxikFOUMRbzUacJXrpI6GJEmEjNLOnLCVmrgSslSIj/AXn5Vh7rNMWliy0+7CT7tP1kClylNEW46gGEYBQ/iNryjZJcpoHsjya+D4oTnRDEP7dqGt0I0X1oPJYprAd3A3DK6Qgb5GjGQpdbU9Q3aMTxYRJGwBMOpRbBiOmNc6cp1tif9BAXSDv3/bBJ7J/XL1YcsufTeJOkwd/r5TAA+dPbQQGEVxBI9LD4S9BJd2+wN+2J2vBjzEZ4a0+Evx7/zDTcUpHSeHLuHG8xa5qBEaPgCSM64EztOgaQVtOeoISoL71Y0ewfZIObJx4EwbI4vz9PBpA9V6xUcHmnKFXz+t78DQI5d3FNYIHbAx+C52n+jTmLmyjIvqHKqQqb+86UUdnqhNDUtqDDC+6m0w08ZHxmjnkPkonIEp7R4OaOQXSIyDNOTf3VVK9tBHYv3gVsAhiX0CfNlOz+7RqTiXLVRQI9tocvpINgFVNOXb+EMsYRoNHlcaecZUmQdC/pFQzGvLa9uJDVaDWUiE4PeMXxkpz5ZtVoyfZYyfGFWHfXxz8+zFBEqbQlm2HqHo3v0Gq62DIhNyqG53r7WlFAW7W8koj7JyEE5P1M3s29sOHw6MEbtLslLa/TibadTqy8Zk7+bk1wHAAGKibgaBXkgVDqSAUD90fF7RB7CHc0Aea4JKOWHH95VMskK8qqMf/jL8aCdEimtH+2O6ejbjV3T+b6hFbjRwGHioAZlFtj5/M4atoe3MjuLFcTIANgonZHaqpdUCbCx0CipH8VMtAjoWRINkUDB0LoMC5ccNkPBl70068Iu4HtbrxEjG8RXMHuQrsiWNL0bQ9rEOHYoBDWvqtymzgdzHrQE19OfcFJW9aymmnvZHKSpg9AgDG/lNyxqSLmRm8Aqdz3mSPZwxTgXef869E3ZuLNi0UsmLciASlBr6bb4+J7t1Yqy/ENEe8tqOkMD56uuDxjUVIZtTVD+La++1Ou/KIeCMEi85a798cE052kbjBfIFDJZidL68iMm1DO08mWz4UyOF6nW9mT60g0gw3alb3i5dfKYWG9ULGdpJbm8qq3OfTxC4hzTtw24CPr1RxgOJ4a/mRWg+nZY4TPMMVq1FubSNMOwuTk/jmI8a9nR6oO3NqKq7EF+F/Y/mmXLYzl8+206KSsuweeQjejHpgdUc6p3BWbq6FVXE6zq/vvnwvpBZbYh2bioAcd5RcPPZ6CHCaGBojNV/QxtQiHq3q6IQE1WympMHNDJvQaqv/Kagb9WHZOn2pDD/9QJLf2VLjHr1yyMLDqVTfDZUQRLrCK4hnRsCGl6ATNrS0L+qOCNpo4wJqnOdhG/kAfS8uc7diFY1fBD77F3+n+3dbAX81Vu6VXO8HQpQ4xlicv8vSl5Bi62u/7qzjPKNzBYjfl7TRocLL8zD+0rjEJzAYlLVJV4g9nUqn8xT6FN0rwI1PSUbHCEwzZkAmL5fZ1RsEvSWm5/f/+wdDFUcmX/QDuqUgMrKaAsRyTOuumKA6CRS6DW0plIxcg1063Fj5NlhQgv81rVIDWbF5jTKvoRlnRmGtNjv8HGGgzmc56Ec6AP2ZKd/HM/wfB02B/tn3vA3VqKH3FYszjNbc4Qn71xk0e9yvujBUssHXLdgDBvN+2OYcF2U2KluaW0Je+dsykOjSBYHPMVtmgLEFvDe/OduUcr+McA5Ff4Nj0shHNGAP2l1xaF1M6FGPLGfiHrK7DRCzECyAn9xRk2Pv1lmjJAzt+dKFsuVuGRRhlUr2mrVKNyMOdDY0kwhLhgd5N6YunOh7bbu1UBRfoi7ZpJN5vLTXQP56BCf9psV0NtBlkf0pzEENvCX5e7m6eazBcaKjvruZmtI7UpM8EcCea1IB0yJAOfAXjgan+NdAz3I3Mv7pSyqls0JbtuA7TaNfuOj6YMJYSn63FU/AaLb8+p7wWmyL+y2YDC3IacGNXqhEp7DEsq8G9yfy/1HQ+NB9XgBS+PIdcek+sBGzKE00h7OfBtBeP1ugr3Z3T0V3RmBXHXBsAV92P48pgkrvd7679/hKu2R1IK7evlyGUdoP1DvRT+6jrgdW3pRfGNwDS57/2x5+8q0AtwrwhP/EpQ3DLctOSVHRWI8QjHdp1ZxPAXrxjdT/gr36ZWuB10+Z5TrBqg+nUnxnLSlySr0LMGbYf6Rxv16Rl6Cix4hKg71NbxjikMSCRNvUB1LgGnGaR8JvJs6c5gxQ0GuZKS0e0sVBcr+sgV4pQ0CS/U+kIRIn0JrNgD3FOlWanN7x5jc906fVdBRlRQ3yKsnA83fK5hk0ZTI7zXAlZYw1B+FgjUg50OSm1gUFezZr6EPhySUhWWPkq13F1fzfKeUH6R/AtqYPm87U+HsVGwzybI8SdWDhewTnGfBIrw7YPeTvyrkxJoplT7LkR6/Riov2o+fHs7uEEVJrXybdx5B+/aRvVyFeTuSgq9RghJM6YkKZSL2T/UUGoIj+5Ujv7N4Mz2I/0bwOF8mYw1pOJzcX9+hc+8S0t6qjhJlZmmoVladWkQ5CQHEXEKFhYAZ/NQybRnFryTk/mroMcPzgGbw26SqB23kIvGgB5r7H+ezEwf6xwOyeDpPHb45zxg3WsyMeiMFuZDV64VY5Y1dpCwTgkiEhWi4aZznuo3b0lwxTaoM3xWYtLc9ApATX/aQvXhaebwYuy4hKyALWW2Ztic8IzE+OWu2/9c4hbxjCBsEL9opx9hqj7KVr2fT38V6iqnXq1aoUebyE74sUCdu7rw99NyfVD08RtOhInI/Qg1DlIWN1jaqz99Ds7OpfjgfzMl7G6SN0dnwHdb7MDOtFsCT7EZMIh6XYB+QC6YebkLMtTV/Pp5E/9bF7tv5nEZ2mxdrOk/HW6Z2VUojaRhdD66FMcPksaAqzUL29IG32cGepfRO8c79G41nllKctfAPXTTOCC5wrJdOQOkV91zQ6Aihh6usZqK70vGtMJmoSxICDtF2E5nplmFHx2TB1tj837d9qL7KEAtOoYgvvOYvynsmLuAzUcjFQ8Kq35GfknNIhqfGZ3MgTPP+yZhS/6G+1d74cBHB0dx2qmrJoLla5hT1UgMOU9uJkjQKnsmHqgu1sC4KY/n/K6RxgSJ2cozJY3bvOAcE4kuFkgvdDHKlMvNpfXmsL6FpnSFT3x3ie/F7Nv4Pb1vQy+Rzfe+bBLB2s8wLjbd218hbEaki7fnwZ4BhsDuaagIIFc32epOiieO6MTqJWr7PjZ8RHfijEPsPR3JDsf2l1cpHEpK0Anz0bIIs30zFlN9PC8uKaqY8Qr3UQmcXiCCHjzBYGFX2XtlKAZflBF5FvepwzOfd2nfiUPAkC2QKfkUQk1tF5qly1kXmNtVzHaJl+wI+UewopZyhQzPuqT3mJhhC+8Yr7kGVn9CG7r+pI0WvIfO91jhduHMiMVCE59qcVSl2Xmx90MHwqN4hZmdX7cDIAf431prLX+XilJbVLaeGgbA/akahk43iPOn81fliWRWixPixN+kSUjnfIEGzmRN0b9aut6Kwinz+Ey7v6fHoryWAAtUyM4ktjbi2A5yDmaTQYiwWKIkZcp0bAANqdS1BtoIwxlKIrxWUbzIOr33t2ZnW5KVBhZKi30lOdyg/dXF1w+sLiJvlI8/TBmqKgwUzrpOWtkFe7OuHMWpmoSVljo4ubCfds+aIVSTi++giXEJKCBTareDGmds+/bCrhc7z9pznNUnIaO4GQpW+sXes7MJ+uFM2QKb+9soSxxR0ZJ7sfqndn8NUIaOlF3fco2OfTDfeTCMVJjEELdkPDXUz7YQM1dK1oOQRsTqw1PZRsZbEl7Emdt9DkwpcbrQTkA3dSUE4F7XZ1UCoHVoyIbv5ZaCQXVsENuhUiDRxF1+Lg4KjRG2jqV0ERD8t7o/OWhMUAL9gcwCzMUYy4kHtsuQLSxYGJpyw1rx06A3f30ekwI6nlpGe7brHgJScq+RbOhm38UyLlAIejaHP4/9PwvTxVup4+qAfWsoYYsz8d96A/WrBM1ohzqAGa2yxTGKairEISgdEGG6kyRUQ4eppBmFS0NNn1A17Tmcn6d18yyZxXeyFcE/8neXJtwguLdk6ZdJ3O3GeVBxk2Itt8iJ6aXgG7XSB5lvNwZGd2rbdfkvRLAS5zSOKLmLieoXyvnWANqTXJawo8aLpchgGqlXI061zk3TN852ciuIEdOXmBlZOyvEFD/qf8fIwKfzzcHkvprnsmR5jCXnL4kX2VCsuifXIF+e5b8aPuXbb8FTx0O6Vjd7n2N8VE5lPyhs2EUsXpevzShttu7H0dFX6zSe0YCVR/A7xII8hy//AB78vmzKbRvEbfNT35tJCBN5NaH0oxTBRwwm1jtUYkbbn0FPyHiX+hAnaWlGM9StLXFrX4mh4iBgrwkQwVLl9DR67qJpPIYmF+K61dZVG51AKKTCQupKtUVooT+3h7bsAiVCt6L/HpfdnG/FYVjZGOWEdudYlSDiLfD/QuOJFLjE8VrRE6Ppqu821fCJ5Hi+l50ye6IFsI1aafzq1qRnwQHNsIErCqVXAmJA3ENT1Y3f3srT4sWL2JRiEdUHgwRLzA9ULHNMnJhWdY0sDDbLOA80F9Fo7ZX/lGDZJkw1q+nLYTtn2AlHqADhZ8im6xtTUXu9OFC51dUuCOl/Alnd710xXK4wFQCTq0sEPdzFPcN4E60lK3ECWZJ2mp5fuuw3prznZz+KoJvIOKg9jIt9hnEUqK9EVX0MGow95rBpJlkK13yj4Sz35P9aQdX3FGyg5HYSvMQBL34ynQitxBKqFb9jFt7/oXsFJYmfPxhsQglLGfRMYi0SDhMwetZQA3b1EuQwgc4d2QZGaW4AiANtBL9cDWVSsovvlaVhMVkcWG8fBGxXu22XcvgqKp4wYZwCMmiDg9lYmwDNrfO3WIQM/PFhPGZ1S6+LnTc/UvJZEIvDZ9pZYHHRMmL7geTKPN89GSWmEjnxYNgZn+BoAlJbBKZDjU4C4Ind6DK+DUsS7RMCaCTFzF7zcrXpyCPuKEgIyExOPE+uogXGNND4tgqrVlZGZDSPYtFuXGxSHSMvZaqZrqFewrAHloTMTvbo3a2z8QtDvtN6S5/Dsc1r/Bot/JxqpE9QAqPeZ88zHhDIM8thGDaxIVnhgf955aaSIJBa8y7vqto1/pbjzVvNkfEFDInMfDJuocd+Kx95z5JPxyP+XjsTkqFsTVjfEPN8dUcq07ggOJ90E7cxXgeeJisqN/CZUC4TDKxCnluVKM0QbjZ+ngBkQGKwg3xV6xP2WnsigsE/ItX9RbjMyZLP+jwXeS2QFKP4o7nGZQTMWc8l6wjH2BgGmUGZ+6+TiMT/wF3i7igV9Jq4qBm5z9kPQJ6/qQPT9LpsNhb46jw4mnlRepheNzcbRiaLt4eP0uSmqyh/hEOgxBlKQBDUqkgEtPJDCOWZ7RHLHVkZJlG4VjEmKTva68kW/fhHglzZnTB+t79Jqap/zTGOfp9oawgk2/hgur2Dkuu4zWmfnH6zUlGBTYn0xz3Vg6/T3g4HQioY9kCSkH1vHdpoC5/fW2I8bB09JEkDZQVhZffi6m2Q+E5/gaX1OUjbNqi8Ma1f8L08Gc79sC06UKrxmIK/vVENiAhTQyJtMQorSePl4jkm6I3jI7RjHaUJVzmeX2gTkjwkSceW8n8bKahHm2dshu2IhppWwIAT27me/zgmIknmhahaZL6dG7waQ4Xy9VmOZqtocMnTCoBe0uhyJIzV/8o/N1iSOvYfTX7wyme2B8mb8kyFQWbJvq+TnwJOYml+6+1A09xzsWEXtfn0RSZUprbqj7L3276tKpCbnfil3OIPFr0WywPKxUdvv9tnfu6UTS5LSGLE8A4Uro8IX0/7ebGK00sEzRML6/aMCWEN2GRdknobkYj0/Eycj7XUGLBm5rUcNabRxa/XAyP3TyrYw1KSLE2cs1AXOEXlJVoieUD1fnlDGqh+nj+4bOTNnweNrHK9ugd12FREb4+5aFp7hC+AtONEN8i+lQeScmP9Ggv6NG4DMIa0SivcfGA3SShOJwPOn4LVpV6Lf9haJLThFvtRrZjP8IpxW1OzMH798d98oUdydqu57DHdI/HbnYrJS7JKIu//eTkW79qcuK+mTUuuCS3ah8dv7BsVum0ekqFPlPUH0mf4mJQ+qRt1x5y/EupqLyCe2bgpCJdXsKmMrTcnKeUrRuW71hTbbvDDtXRCQPqoF5ncXgS7IKHIxwozdgs+Ar+XTRhDg7/SY3qNfCKg8HeXYI0ioF2Jn4yIph2O+NWnfdKYZeHFaR1srG47DNQt+cbVUCd9xLiSqZnReoHOptkg74RMXqutxYwSQ0A8YfimRgjEMlE/kPxq3hcile0qRsm4DRtnlN8cbuducBGp0UujOHIkOXYOG9u07ALIqdtRx2WNRDy4gZ2LFjOd+gJZ9KVR6wfYMo0gN0tAhrjpPzawWt1ZPci8Mb+5BLSqne8v92oYJf3WbQUhWyRs75o1DpmBvEOd0918WyoD6hEVMmYGOwxahAUG5Z4t8yoAeDEl6d3Ds+o42Z7oGi333JqqTPzm6SGs0XfDw2xriKivYtjFar6FtCc2GPxVAo66lV1y6RoRT7XjT3HXkibbrOilyfPH+lNycBZd3OvKsONxebuqeWkffAPg+IzF6eWNWw6SpKoXh/5j/e33QpzzLJoMhARM+C9N21D00BkIXbOtEAMxkC+OW49I9r5Kwb/nLnodYWBEb9J5sKLCb382xpOrsXmxzseq8izKkd0rPT9M4YIdD4w3kiRuO9AQmW1Eil74uKZxkExP2qxCilVm20H+Sp8twYPS/9VJbt1CT80z404o7nQOpWeVWA1RJTYz3KDh6n2JjQxIreBOeaB5No4velxygCiQczMq8iRq19xms6lPlXxkgOy0dGCjm8Cu67bq6Fyu+3Y2DbeoKGE8+2+ppThh2v6lFWe4MVE3yZZ/0ww++lDdb5Q2T36EoNvOrytmKi2NcbdfkzZuXKOEhQdm0WmMSDp9T9K/p32h/s5SbLcC6/03ujDX2RO+uUDK7FWvhFgBFSgfKcVLqWNhtzLKc6pEfBbcNPEc/zgikEkIO66elfNZYIeepgtLTDEwecWifmMU1y9Gts0sK5SoCSXOICLWwP2O/ly7TaAtKlEPVeXRgKx2z80ZkdR0yMgQSSyTmDb8a9grWjLXntbqdTMw3HLTzG18oOJIkGFD6U0z2tRKIONRMTM5UOiR+AplPnt47R/LgMWu+aay/mr+LZrMBEqqebYoAF2LzRyQmjE5uCd37nKIvR6t20e5gk6YnQbnJW9s9Vb+T/6rgYttzokvOyDEBTlYT3sIk1iuUyy/c6R2+xc3R7cc4MSD2ftTHZ6OI4tnzMSmh/LMkwsyz2Da93Z2t+snXiZSGzEf3IxqtynqdQKld8zUu/NR3CMhlXP3y2k5yaXFB30+ddRmW093kMZtGWSBp0E9hfXntu4L3lRJoNu4bmCFq6mM7yaryrtsuW6MGPtE6b/WxcDvXpGh01XY25YD86s3aq8+1Nc0BUUEbcMJ3/gL4oe5hD5BGzqcvMOlqL42n/cN+GOvtyYz9wElFmVXEoBYvdkOQz50q0QS8R0RDfaizDXeIBfNsARMcKPojF8p47RXoWS9fk4KA8HIhiCPQS0By9X8MuWtBmK9rOXHJINVZbcw7qW62yknvf8S519T5ZiHOv7EdZl3kMQ9crsUY2LdHibheqUuXIqVefUl4KhRp3tym7IJjj1FsmHS76t62M1ESyZX6dtXyiypp54FhwShueaBKZ5GeaIsi/QHnvjoAzLociNtpzsqkE8GeKsBuudyEgozE7aaLHNWZEwSw/ihFbUHXhPsPitwFOzlByFOCi0kBfWTJDDdHRHlkKuP1x60FNNyBtwrDcLnCfaWmqPPDDBunGPV2Lc74qz2gJJn6JFTlNe7Di+Zp0Pk6R4rninjmUr73cvSp/YH0rUd7a0qKDLhhKfdIK6TgMUMnMJBLXCwrHw95WvoRjcbRDaIcTq9eqyTDTYCnCV00EnjBCZt5GGgq2CqfRx3i9UbJ7sC33l0YZyra8NjG/Uu3iyu1+oLfk7/1pu/7VVuc1DMWcWe6NhDi+QLw9T9pw/v1RfsNxw7YocjyQD2gJoJ7jLrc1jZksopoBg15q6i8cYmBeuQrzjzurciT6GmnRAtK9trwvNuMHwK36pWDMp3umR6292STGfBLb0zNsu7YAewMXGLBZPBSYkIZmAX8gmM03oqhZ+/vERokT+bn/JxrBIugTJ9X4tzLEo8xDHHAOtb8L0C6ZV9RUBBEwM4KEnUfCRMd4QeAAuWF+WfBy45fASqbbapSt3RupFHR1HJnbTCRV1GoZyj7H1H5Px+OGbxn60ZZwIKrUa5dGmJQUxTMpkTX1lRJaKPq3lcoYy9F5R+1RwNqZM81V3rzcbfcJirNtqjJencrg1f9Mm6fCkxWzRhjcviJkUZzd5ecryAM/jGuJkU6l+DWhwYznfkpWnYcPc+36joLc6l9smW+Ht2aBZHq5yjoWXUQ1f9ql8g14UBa60vGCb9ku/ToFNv/eRB2aTYw19N16NnanHLoTtMgr13gNsXkyRIfEMqQwqQsNUKfHqJ6ztitvbAbcHLpSkKOLJAKHsiXkNr0A8wv/DrxeHU1ATDHf07FT+6E1ACLofR0lPqYPQyEDTBb81i4W74tXggyO+Sv8pkCR5bIS7Gpp08NuybZYUNmSTccqenw0mWf5zMNgTy59Q3scfJpAWhzsZAP9+ugDhxiVO48qwDSUwoflPDbUVFsNtd4Llo8CMZ6iHZJgUMPGUh0+a6vTiBg3LtUB3LeCnw5zHoAOfHPASnhvwIjlQjQ/gvE5sEWpn2Imom2BMoA7B5eirbngS3bTzChmTGzddvvEo78kNrwNHF53YYoWR7NgH9MKuIflD53pgzGopNeSp1v0c9ltFgobIwCGnGR+I5gu/BbqSkXbRXYCboyjYWYcYr/MXiuCNjN8RPtZU0jmdc9c0iI5IIdtIbQPnb1P7CBAdvnHDWVneCZjxGDyRN8g4SZ67ziJzgYEVinIqZmaqgkN0tg9h2D3YtvBHFPs4QoB6MErPNtS003Pud/UjnBT7AG+MNBd9gXtxusgnUwujAI5epYbv4krK9MWfrrEEsDGO3ln4RwejqaRZa3QrJKHXurT5OWFedNX+hQGUdovOlm4yIXxui+fgaxVSjVVlylLycKv70CJzMo6XHgdJWnhLTA5cmRDbgHJXvav71A9L47sncIuwDxI/9r6PLodQhuRNVwSznyA24nywKRcw6Ud7o+HB6NEBs0xo3KZALBUDohlhu2160wUWspblS81CAmobk8PfM+Ma4fFtc4c3692+paKtP2Q6RQRNsbV3Z96EsITdPLBmtJElTi5WqL01m6iupLCrAlL1laFVLAWRvE/Ufp6j0syjX07jgncvlySkYlDDP0/vZfeQOswONLxl9g5xKnFbweM6QdeyoJhTw568VwJ9cTOQUaYMFYTy4vJRV157s4O1IIfBlYZCe5MQOqeEUqpTrsP+rRJTx8nzfrlMA4Q7gjRcJ+kgoDzqrzmkfVZ7yvW4kv8AdP8ktEVfmx5t2jAC42t4vSq3i0BMPokf9PytewHFX6KzSV67y0ZhMcrBRvR0lpi90QfS4ZsvXnPaLKEddUkmOVsD3ILZHdWb1e+Pk8UpyUPcCNWghaPOnkmlLPOH3nxoeLpdKqygLLj1yp5Ero31RCm7sVbGb18CeHJU2GeqOn1L+AL8+utZrDMX0d5f+VYYauFiIXg/an0bqS5dVvnkHuVFLQopCGp6TUz5danAzety6kX2yO6P9mMpTTmm94STVTHoVdwffWzMXtWrGpNzpp1uxF2TgYoly1sQVDzNNbgxl9GfXM15LXHWmT6gMmzP9AkJac0rDuTaOPsfw9tpkG9g0rZAOysDaN8ipsA0kDuS8Lg0zrjPfA4VaLVVBIa/dcQGh/f+Urb3kQk2pvic75k+nzhJJywgyoDuqqeiixlDsV2OT1SJMSuYyoZWNZbTlzrSID1vUSbsUoqTwJfzLucrq3j+1fTTCwzrGQxoYaWF3nzw+pHe/VK9C7QLxDIG7laTf7BMLYUOiKEyDZ+a3HiuKyQyzYh4PBys+5DKcQhwNu7BVmL7rKA+s9QgYyJHPlkvmuzY35LKeUyK5shzDv5/PpPN/daI1uUpduuOQbsYRIxDsmK0J8A5Ua4RuZEvLPS/sVhVo4sgwjkuGkgQPqGI04qycdlLWrfQhFtmEjssGPZmuKBuz7FMkmkFh+Fi1gwgiCy+0f3LhQCc0L2ILrEno+V/kWHoCIuOkbGikgrwM3DnExv5pT19RHafLsIAnd+oo7A6wnck89qZ+NqQ9C05Zxys/gycvgBIVdvUuIQIhb3azHq5b3OsEyJfuPVglJKKzo5GuolPHEgfV2h2W1d3/TjA7HDXrSA0z4KQ1pJNnusLXzuDFHFlGPtrdoBJ5xQ/M7hnDQlpWV6osaXF3QCgmsmdk77sZhcl8Nue4ptG6KyfvsJLQwBsLGwJt9gjkrA4uITOedNEnLDjiZQBT3l03I3M9LzL21p/9ZMAcS4EUZmTQJLcVJ3s5p1lPDcf3Rba+WYl76Tyc772ZeFssxxhEYz4Ex5LgdRxcago71viAp29gdVM9ZS1AkuvHp7PMPODYCTOgExARxgtTKJNXxd+8RlEO7oqqtDdYhHNjtZKrWBD2nTB4TYadxHpy5HRV6mGxyHIvo1rZ8oPqMKjE3MpDhtbQbGdhGUhxHDlCBnJjsftsbkbT6Ob/+L9CoU0q0AXBK/I80GKktyj8SPa99NhgNr96jGceyGKeHthO5y5FC27OJTk7MklOBHTzZ0FAlk53GL7OD3OoXjDZiTFqqXSTDXdQFEvUjQbjUNk4e2Z9xMYCMv5gzRK43Kva3gLTV7R621dxMXJAsFwQpbHYZcgw1gRYT7WxGBnxuXu+g9HvK9l8qQvhzQ2gmiHqUB/uWGIpqc2huqW3yvMPeGsLJXpiZ8/o33VbAa/f/yAVW1JZhoV7LIxTKn+NxiStBUu2cZ90P1/9jXsh/rzNoctTDmGk75QZZPcd+ugsdCjA8nfrJ8YsbSeRhINNORVZ53PB/65nN96/GJeGQFLz+spuOdbZscUXe0sNdI7wl6v4Z0mT6K8HpzK+SNCIpkzTr8ytoYEBQTO5aAdmKaj/TCR/KAqZEX/PIW8TlZboMIP8vI6FOyJEPSGJcgAKV1ldAzjXd+exkKl1LcsuUvezlxtYonIekKejKXov/ByEjKN2nIJJjGWLyiRe8J2RJ7u9+4FHXQnBoDtsefdZ3H8Lx9vpgWDF0jjsjPCFr5/G0tvzyaWapVL8vmLcp6ltH+491Si0JbDZOjNOj/2o/pu8w7qroizFUp5gMmZAsfzzEVwrWKWQUiNNAa0BkDsmuxDL22IXFxRt/TUkvVuY5TOQtlAAKw6k76+1QIVQwikvMDSlIi3WsKFt8A6CW5iOLtbGzAIRfhuYB59c2IalL8ULpSPE9DnX0JcUKfjhhIOxDbG6qU5Zy7RCHHCrr+782P2qZaOfNUW4Rzt2QMjZhopBtmDfMCiAOxhtD9+712NYO/qUcSdBnA22RcNDJkEQRj3WvZPGXqPeHnSTAITvzYCzSjKAi/hwZZJibFqpB/BVsCl5YPRRqT9RzEXOlmfdzCWmgOOp71G3VRw/IiGSFjruF4NdxyntdJ3K042jaWsQ3xYCH92e519bFDKkmK864ron+by0vxD9ceI04GWUOvA+K7vaP0S7Z86zAzmyREMGxULGq9f0cOAkTreDjOzGb+I9YbMukuFRZUrVEZjlyjv+QYyXJ/Y7Vj+HhY9ZHMthY7hukZI+El7+DkleyB7uwmXsa13vSQMBD+x3/0+JRrxHYBnGm5JsxYwyzG+jKVRX0T6KDoLq3l95BRpcxJ+Xc0NYwFXAeF4OEpLyYPI0baXFIr14Ob2BynPHis5e4qv75HEQH8+mC5fTkKRKW6IHNww8pZcdXM7R41D3wg2HVWutLlXTzzZxZd3yHsmW1+Te80mWjFocFqIjNyYkGN6/e0U7+YCrrXmikzLFHHBd6JqqWUG5FHT20LTAsOQ+WBxrr8lh4TbcAXjUXAX2rZcsZ7njOXEFDkLRhLVlvS7O2o28MFKSZzsVlCp0S3UxuBNlNlrZe8ygDs6Tf2WKoJyeMu7br0h6njN0khJbDje/lJFGpu2NQpZ0HFAl0irOC6Uan7hwuf63w1r/nal942oogUcV26u0E1OgizzN1QXBeM7gue66I7FdoGx3uHOsJC62lnOZpcUFqPYbDK78uOo88zPvs7GydRU0ST9uBrytZpSA8N24lj3ACg3S0nA5WwSrI5vlAkyZfAetzVWgFeT+MdoFH8GpT6KEsuCDZDri17pw5zathJmEF6xx6pRIWmpeZi75g5fl2C7sXUCX9iKHsN2Hoh/AmRzUAwjJMWWuULLemTDKfqjU+8p2EdshrhgU41XI/XcZo3PfICMhQ9V/jUNAZymrcpgpfgacB9hLp5lQas39QTAcndvexhtwTtvWEkXrR1VLSIQVDQI5SZF/0eTxBO2l6mzSX7BNeR1j5vsaHAqGX29dvxy/6YKLc0bB4kruiGo0TsWVmmaDGIIvmaI2lNos3cJLkiWmTWMPDmuNjPCKt2C6wZW2vfiyFyCFmW762WdBmLSzsz2gkaptRr9bzf9pGlT79bPxwAMofPE4wY9ZE+n9PHAbHYyy2zqcvhcazQtZ43YcrmqNsGFKCTYjMiaz352sMAgArQHQzNd7IajdRNBVPTSMrts2jXT4rr5VgLtdtjWzuFSHelnNkozO0SS7utrLvsZqXIyUBPMLhrndEvb/em50X76LuMbH4GPpvVdPzw2t+YHN43yL6WsW6CwmdHvrRvlfYznrVyEZlyYrdfkQA7UWEAQ6LI/+hgs0QVDDDbbRZR7sQ7LiF4LDjt6doxvnTONfUSuJPpoQctd5pHUYd3qLEGDI3MTdrVk3/H9QaUZ4/6nQu0cSoLKQaEwhBBmvhkRdBSnP3eFjwRl1uI2GamA6Yqn455y/aImVGgd9hFXYQeJc9BXnXaXpBgb084YWylj7j6JqkBPJPqmTz/BhCBeCBerN1UABLbEJWbRcY82ZGB0icJipGYdcbugCkBQLGlF2ZCoMBBF9p1eZ6w7xdhGBh6NKpws7BoLLQ7EJjoLm4sfz75M9czKMOGMxJAJK1YAQKUAqgpNsDeoGsfpcR/SXUukwgcFY7BThsrn5kkDH6WEuqmSyNGB83F75BvwqkDZhf7BuLbpsMvU4ixwctr+++6NUZln804JQA8sY4K8RirnCcBsN21Usy75fSVlFSPHcmwOXwrSA+XniKucJ7t/1ulCnakl/Y31tvnYGkXpJoPXt+cWSmt1xpkGLy6ePrBSRVrgWxfJ2SFsUv/GDk3mD+7PRj8810Vz3aXESmXnwdgCLMlHveyon3U30H/jKHFysn8Cc51Ubt0PEl9L7ilPZ5tmptrTCyCvcpXrJb/of1XzwrzXxMxBBsHtV82YNh/5Lochdl+PFNRaqMQbagUp8gHIBqsr0L97VpOeFZLQlUMmGnmngFzWO5heyNsK+MA1KSdWUn6tcmRlLdoY0AF9CZ3D5YiPDY9vZmxbCvjHKopNHB/YoaucRPuBngeJRGzQtLJePRj8Cf9qL/uJ4g3SUpan7M367lKb5SvPoLQGoJ+9XsVyv2a70E9nd91p/6W2P5zSnAbzjnE+JJa/g0r2PVpQiYLWLJPJ97kIsSw6ALJg3e0NbyYeZpPgtFX6vSp0nLH/VldxWAcSkmVu7d6M9yh70KwpfcGDYoHXozHoTKq+qzYSXwCS73c8O0oMjkNNzPJJ6LeDl0tGTq1swiBWBLRu/oD91Wxp5lRvYCdXaZZU6CaJpu6TxBJGjhFbTdOqxLp9A5M8O9PCKE/d6BCBmBjkiE1bwTREIsvClXSGAufgWeURH6oCC1Q8C/36Cp+CMBwh58F47ix3vrWbLoUEavmuVghcGXENwKFHKcL+Lfg9vKJV15x55u89R0/uJIu+mVS8IuiiQgbsLia3lsOJtwem0d+a2dUJBcuUiOfLQltem4p9pRpOlskQWI5i/b5ASGfc7oY0CA8dyO+wAH9qg1xH32zxuLbQedhykp5VaHHEdF4JpY5c2RMHnIr1COS3tHuVHtG+Da/bbmHsJbpXgwjdavVs/nol5/MNKw6PkAavxmiWuqkjYRqNvm+jNuVETq6lKKnoHRxfhcflJCIYljEeS4PrN/vPQ+JGhxhrmAb6vBqH8FWbYes6+c7i1aF2x0yrdM+/qYTV8ZohzKKOUYBbxWNJZOMtna/vWNxnp/qmUVyGAPoghXR8fcZLhruulnolHhPPciRnnntoAB8qaM5asucSCti9oJh9xfgWT+Q9HPWQSdYOcPTQRYPDy6sv3G9f6evnQjpazBtbLZhU2U+pNYM+wVv0+0jBaRkpCthaK8lQS59O2adaC72rOlNe/gPfjjYSz4hYzzs1NYHL9rPKMh3kY2v7nnJJAKismXitUzd63LEFsCUVg0IdavNpGu2yF4lf7IqZLq/GTh7NIekq2t7+Cf2mep9rFazlhdg9Gxr3LEJsQIl+EKc9j/sRZ2F8vPmqYDXWAF7XcfdhlLtRG+5vxJm2Y2UtHp9HVACk4ucipjENKoRtWdhRAI3wTDob4lz7lE5CZrojKwtOt0R1m3PbtH/g9ZMn4rzCGrqvZ1O2DSRRcSaVUR0XMuWUubOQy7KKHg/ujUEUgm1VaRdIlf9OXEYrKVViITCYMtWXacOyCQIOmRwD8Sw1LaBpy5CBl9mrY8nQK8Yfwbfw8M/6yTPInKNppxXlYCl8uJvrvg/x9tWWHnlYo9oOnIvPbbptFOy+aP7UR+lpfL1bpy+6P2DhXQQDOu3kagCNXzQYFyPnXKF6rLifLbJDKrpBwOgGbUd7o3OlSlKutipZG6aYehnrCU0BxjDSI0SuFs4QqvIdztzD4cRxVUUYaCumR28GsEw6MlBrGqkLm4LYbYw1xVlmA/a84tWibloJwEBJ9dsg1oO35ZUwJQomSRjjG9PjONHIOpv+cqAmk+EqWbPlTirys+5eUI4vPUZB7Z/0xDX4NrCuEyIIa6/xzIyk2PKtXyAJtMPOx4Zz87q+32it492uKRvPlo6Yj/JSm23W1CAvwNtsIKhrBWDjhZMhY1n10jckQJwJON1mvOOFItVsk8wS5n4qjydD3sSj/O/JCTRl7lGWxBJ1SQc4620ddpuehg6DXcxU8Rs/4Pn/WVNwf/4iSCbahUIqdh9iCyHpQKK6TmSfAAwcKinX3aaF0voEo/hcBB5mElI+TkNf2gSVGIgJOc9p5sVls+eSyo+8YqilOMcp6H6UdG+EuZwDUpS/8kCy6Ya568pkaTLGnp6FusiDlMtGwUo/NDhDnROjHS/5E9jk8nLeGlOuyl6XnI526enEXjw9dkEDuDB3mfB3MtN+HT6eaTMFFr9BMUAl7OakwAtWgCkfW3oWV/4Rwt0IukaeH+QXzzJ0YpF2s8r1p6ndIXSxN0EYdLLydwRKabzpAwf23BYRi0nzWh3Ji6GKzb+oqkHHynB77Kvv7RL5VYi9YlxUqw9uWnxEaAP2FHQ5USjwtLqL3UKDX19s7rJMSmpZ7iwrn9rqMk0lmhpexD06nYJqYnVHwhVxBIfVvSt5VjRIZa7B/pFbLM055+/hLhkBa+Y4Gy3YOHB7eJ0z5M2Evm6EP3W52nYzNsJjiiSBVzU3wUplTnwIzYq2zy3IsnsyvndodK2vsBQsJ3O4RbToOLe+1io/Uq4PEpdbEXbe6dIGmKzU2R0lZ4BPNBq+r4XRn5E8iIeTa56tSwn52d8T4F50KRjSdava1EAGIhYIktCocPNpJpgEINmTruCHHfH13uc17WIYmCBC0nN4IZ+y1CHoSJtSkfGVVIU7Ct7UGE1Uxzpek0aPkfVNgVAnM/aF8y9GOnq0QejaEcnNBqq4GU1MiaHXy+TMSiiGsOFg/XyY9fgx0ay6PQTz6yL9SzQcVUhVRmCB2QJg/lJV1RQl5+r0SH8WVgdgh75AFznw6Qz41XjIW9W/8wYk7y17qgduYivmD95hawVljPYhtbKMKMTAvy1nNmYA3MCXC06V1MF/6BlJEiUq2GiPTb2F0TdM2+g8GVaE0ekcQRmBjTqab3cXwB66UzT7+s3g45hPLIM+VZOlciRc1SMg8/10IW+TyvPK1Tpe9LeeFl8Jiw+QEh9SbTStYD4NLfC5Yt4VEnqWmBXjLkdqR3T6bnlUBsoH+qWhHnLKN2M2XNlGxZNJoVGDSM8droUTFm6KngMjF6FCpk7WX4B0esavV3eZOgHe7yBX0iemy5LsKddERY9NYWl1bgqwdXPvJY+uTF6QvGOuvOSliwIn0t9OOd/bNKtqBobCsb9OKz8KhJA9Y2/f6XmzAEiLmD7qgphZXAFG7BLSWIsSEq7JIuV7aL1WDAxlIayDHyaW3z5d9lT8i5+PaoqcOUc9NIuDouHBtcNrXhDWGqtv2yba2zpG7FtrDKr2+aRBlz1XFCgbV4FCnPZeiEWxBp+J4MHIIj1LcIAwi6YWubSWLSWSaDF0b9QUSkxbsmLrmhsI5lSuIB8DMbdM6PpEtt+x3XeKYMhxaqN70i8t2sEDtACrIA49Hg4nkM8rRlLyN6pYzWACGmfluvYBlxyiMTm6199fowXxnIZDZSoQYB6+lG/MOyPKsNNVI4iMu5GU8qLZ3i+/dhCya/xbn7Nmbh3Q8l/hUzi+6gTtuCtkdJA5mEyQCWYGR7rdFNxk0Vub2LrW2lkGCWb6zLCyRkwJqTq3DRZe9SG7Wku2U2f+i1S1LUDr/q4mmbYjP4T2AM4+6gExROubWKDKINmYdIcO4G+DuClOZTqbxiyn228IbA/Y6GKhTIfs3e1xzurKAqDTP1Ai5D51/DIta5mCqBPbEmco41iVKaVCEoqypsB4MRhCSHxU9gu2NvBYCTBRfwvA5qclTKir61OyaofrkbT+nF/xd/fMjr2aVYHtbjd7Y8F7T4+24IGpnVGzT5P0ZSf+73HSPxhkX4YfvYXjQGyWfZQyPYegkR+ZsxBUbIYlhZM2k8vxfnPv4R63vAdd+erY2q5+Y7O3Rt1Px7/9oRksxEsWoILj6KI13LLqWtKN1hbXLisjGmsiG56E/HCQ/yas8ZtMRvrkSK/Grwyy71FePNzHjYArV4soaJDMumTRZOpb18r/sK+ShmCMqxjj+1H5RvlBr41TJztfscjmad3i1ptqA1JiMRxxBCdKFaZsDTEdoP2IgV/2VRuR2SGCpIIL6sP1H0MDIIKdFn2DM96aw7cm1P0D7iD7QIGNaAVmVBFf7IhfapdZEZEhMxk5bxJyxSqE1W21mtQkHhRv2ZQf+Rd4DCZEIBcZU8PIYDKiLGnKXd3JEx1A1boYRpMh2pM1zG5Xe2IX+BJY+IclWoLYHLzSPlyPhguiygqLR7HH6RL9FeUDcde4djUEjq3PYm80Qk30y5PPm9EfjmmkCI+XyWPM+VnL8ocuPW33I8r/rt7wP2sJzyOX72RQzIfCuaJK8K3yH9WGn0D+9bHVbc+bWCWmNDzWPGh/Z/3wssBzyTtLE++PIgl+QbGrfM5CdH33IbISh3Zp7MkGUH7z6H2ZQN6QF3XyTwNZ7tLRKLvnhTW8xHJZNBtHuElBBJjyb1Qhpia484rGcBkx/PfYpBnSe8bewHsAKqIE3ILJJtJFIe/Db7wJsMZF1cU8A6ojdk03iHmMmqzDrf7d/qli4+e5EjsKvy4PcdkfNGVvMQqnPbpj2LsomhKgGdAbQ1yHuANnYX+AnCS/onaeQNINKF3MRwZ2rqRkOZp7WcwSV9BkXJgq0aOQ5cAPQkpotCzWICStW2BH68u3GRLwoPox7Q1gUMvGrHf2e5ZtNSAwHcJg/mF+YV546hPLYj0UQ8D7qLb5ATC/W+McIrjh571Btx8EmauawyAEOZTkyRpHRA5zU6kdnkigK1sVn+hVbo/pFgCqJWHK5Vzwu+0m4/O9wB11o+QZXOUEJS+uMfFvR3piqb0KUXIDZYXcSN3wkchHakaAXPrbRqkWl4taW5uyJBVuAuAoLW5VZ+tfejDHg3acQjiSTdoSlZuegsUAIYfZyUWO7mlyqhUXBDXHDT7UFjg0KAK2QkBiodl6qWhOK78kisz03T8W48SNhlCl+6O0L6prw2joVXuwXw/FixNsgN8hRVpy5V5MeKCgFybni9lJKN3lzTCasLCRcJpfwu0va2nuHlSgxyfvw+ilvQ+Z5MkUCkNFDPFxgKacQd732FirKAb/VY4jqbKtkGjz+Y+EYe4XsEGwPLVj8GNIDVFEFXm0MnHyFqy9DFmUCEHFg3hmW3PNe38pknja0F6j5mMaiJ4QfSIJ00tlV0E6u35rJBvzoz3gohQAGkkESaEVA2aIM6/fsXv/9mOfNTQPc2UI1ABqLAKzMWJHV9Q1+2kNn2O8QyghE59JLraiD7/q3ZzT6SyNeiuRERMLWVjM+vEYGJvmYunfkLcYcT8c6UFRDEu47i01TGS/D+VKV1/sfCUDeZKvhGqHNHdlmtLZqZR7rNbqyLxIBzGVnzBrADlZRI1ub4y9BPIJxVMN8f/cqSBlRXMJfNOyDZ+LikZe07u8g8G/v4b7lHbQ4nzVMvXYdjGeWtDGTOoefYOaohH6isbgGR9sd4ksOhx4pHY3S95txy8HlMyQ2MI9LV4JWE1wXSeTQYgUWIKjgv7Ul6GNd32EoI4Nldt8QLm50I7CtJRcf4P0+3uKDbJW0o7DIFbuC3C6kAU0RCxeX/zR1vvp6MYuyiDEubbbyb0yvGk1mR7wBYQmKC7weKiKsotuk5RCkKh58BNkXdB1YAmxeZ/rrFZ7p+KVeUnsOmiz/AmvVx/7CGEEr5ANgDo5iZ00zcu3DHa42F6TQB0wK017mg4hZdm3HeplwIfaiz2euQ34XJLlx1uUlMtxNydRSjF2X0LACNVXsJ6zs28MyFDm9Bl65V6MdJ1T0G0PgGElkB417OlLi1hjbK910WzMd7UeH2mj79mNGKHoEKYyCFztjpoDPSnXvZKxFupqDkB35ySC2M7Zjpx8kqNB9gi/kBcXeDnz7aTtWu2IPrW6nNEbj84WQuid+tDehgJz6oBdD7x80l/b8afv3Rpo7xCreNqKAwWpdFXaJ/YhAM164gIhA7hOe68jAVLos4jSCDL0oZJz/oU9CZzNUma2nuXmkHM1j4wl1TWUYJXgtj7fe457zdwYjkuyYwijcvLGZslqcw/JUSDnz4n6FX5oPxR6beAHGEMAMQAaSJwi1gvpeqMlBKs2hOU+3qwV9sza3xOOb9hJcneEvzkY7pokx82WDvRPyGgD5V6topU8COAaobEQo4C/zjmQOX1s8/sEkbR9BTOr380K2m/aHoBY+yKQhSSp0Jxc/tItoP8396Bq/X0gq0rSvwYuX/BSxgIrm7JgA9ZcgpLZz1IcOhMfKN5Zg2akfN+/zm8GqZVgoLmsO3Bl7b+s1VqnmMVc6irl3ozK5C0Pt31jXVojspXF2BqUpvTXChw6aFe65guU7zT4kBpWuEEp9DYRyRcGKm0dWY73vb+uRbsW5cJ3bJXPfK7kzL0xt8d9TBb2kzGmjRPZiA5WBHLD/4qCoqs0Tp3fV1RzJ8EtA//Qj2sVKgqXpm9sGneEjvdm5YXP/Af+SJJtcaAWuXcQKrKJ3mesVg5C/lG3/Og3wIM88pxuZZv+nxlx68fez6JDXZgYHt8He97b3WpswsVrN3mQ7nsghlud/Da5xy+zYWMFeIE1eWD+PTybDeCY/zpFU+EiRCPmLWmt6VtkVk21QQP+1AKbyFgPobDk0xOJbt44i+9eUYAQP9PI/7CdZhU9xgtAzOX59YEHgyMv83WPppxtNpPsIqm57/C81gjkCT5vvXXR+9qxkOBmg2AqRxALUl5dBcORBobVHFvT8yGLgLKWOFBFShCDvK5G16nfak4bh51qK/nho/hcPMg+YHnRW4VVzoHLDVbv7zEsGnKPQObRJS3Zzn8aB0SLuotQwd05BTdzXadUszfJcfLlzS7SI9wJ9ShV5QdRNMVd74oMJWA9/ULc0YCrOtqXcjnLCmsLJukbxp+wSL3Oy4sMaRJcjifGMCDX9B0NniVZu/gkqroZx1Xtm81pyHRiUEv+JkVItY/lh8YdABwsEgDrU5SEAoL4cacU10iMNIOk/+byt1gz9pmVlafmUE1xNsW/mEhnDCv1RhVzBr2/i67H/wWu3x4sQazWLYqUlGm8MUGLxg+viw7mN3iyiBtKL6UZCOr3UMTrI2vHgdUNXefObWNgR8c4KaO9iVBQDV6xJXkzlH6wu+opNkyMXmzKIGoz9j76XYamSNNJ6StH1ny8FXrufn9RsqTW+x28EpXgMFQc7IbA2qn3sOwFnpOte3Yw5FTd3RLZcCT4pZoyM9CyOghxilff++I1YNQHaPGkfBsYsRotvdmAOC2GcAvQ6k2EVS4ZwEFv1oY6honpMIiXUmCi7/gaY8NIy4C0i4BqKKRjiV8C2Akc6Txnx61bCPATmAdpwXJejIGyIw9Voin21VLxiLgMXT6UQNhBQCf8aT26Uj00579UVxvkRG6cBPLUHWIqiQd7bb603yYguSP4ew4OoYgayTDugzYpmkVRwGFC6f/WJ3EwQBIiANmtusfKGQJfYPUMZxGUM6KXCaKbuEGFbLKYmAwi9tx9Zn7Kji/wJ8y7F0QCHESK5bKnTgi844/KVdbdz+wz+LB/vbj20x78NFNjiHGrT7oJsU5M+LH5kcZ3ETHORwcPdR/+hCbVJ+S80mVUWwclJOD1AAuSqMs/59C51D7Y/2SzzRS7Jya32BqQt+3ugsWGtbl3sBHvRabUncnNMFv7btOcz2Q6R/y9CyZplv15Varqaiw9dx6eWzyBX3yU2FVZwL8w9NFbKyK/2D5kZnITvjzCqT/y6FBbkwPaz/aAGOBo8pfqizQcGxiA2G7oU+WF4/QL7UrTYuKV4RbLUxoWteHgpoXqdW2MaMyfIt93OpSsD8G1rXakUWlEBQQfx5VAe2xplX7s3rvujCpn1uykNgOlZUuTvBllbIHI9uMB2KeJY1xbqLWBT8YGaXXwUjrt8Kc0NM4/oKRBFIriIpUgo2sP/mZu3pmyR1/nuwCYIiGrKu0P60D0x7lnmmozhb40kNPWB0wHCkk6YaxndHoefSMtpCWeobtgmQNfpjE/waW9lz2epngzsav6tqtVmxVzPJ2HoZsNs9nTXSWl1Ccg57PwEhX3oPmgbUCaz3Xq6D5ZdcOY/dntY1V5OpQ+4hqYsVAUo4yuWvccE/KVfrAz/H4Xg7f0OeJODfKc0a8wvEwC8JlfmBfME0zCpldmBzsMDZgIVmDPdwGYRgma/uDUei14oNeYd8wzaFRE44XHyqjFyYLAktB+VPqp1danLq2NZEgGB4EJNDr3fRgb5VRMc4jvtHhzOScs2z8Ib87bBYDEAmoVW0/Ftj/DqLiAhulTG8dXI8C7E2KbJYkEbHNjPdmxnDoGRCDZIi7q6N7CTSdRN0b/FShXp0LGMkX9Ac10fbjEnbX0ot3I1U071o9ysGDaZu9eIZKhU9OYXcjADEoql4dj426ZCFxBTuVw4f2Q0FPK5jwZpwt0P48cBHQWJwL1wPBcAy7bp32qwCBd2nJI+BLc73DibpXU1o4x1Bjd7xkFOW8iW1wKImjf7ujszfShQ5jNu+qAaUtpOb4IP2/xhIaIGqS0Nb6lxEyRFkl0eUUT7q+QqLoqZcnr+mQuw1stjAOzGM4najZw4jmLRN9nGz6NHs+4rllM89JviRN80Eyp9A+RxUoo1XezKK78F0QxX3vFUm/rX0xlAynt5EoNWc8VyN7Z6hARfJSu1w72MufKzJaozu16OwZmfGKluwu4JhrPG/HEdUSOyOzmiZsW6l3CoC2U/D67azry0kilsmmrsavDrbxesN7SwCHtAvLrl3YD8mKAGnx83OYz58IKnXQhtYW/rivv+hcJKpbHFFugDalOknK9ZG0Z9iyXJZ1uel1+/BXRUzTseeryGTN9FYzoNx1vxiXMYAnI0ib1sfEYPauZJgAJMXkuisNNjvMD5FPmyBfX+keVQ50snT3uVrXZrmxR0an515dkPwBYL9pebgiYtS1d/GIn5rExgT5BppMfEENuOoDX4rD+/cL6jfKjGFOo7WfBS+t/dtt+/JRQwNA+XRDVZCY2JHVsRi3ch7zzibgfhvWoN/C0bWxC26C5nCxQPgDlsdEwJIA2O05syW46FBN2hYEiKz6jTY5eyL36sMr58PIHBK2zkIzUloVjmixM8zPOwY0fOOZAkxMWtIeHGhYgeCMod1f2YuP5Nt81rupsD9BF6l36tBOvwke4gv/3kJ2A5yz1XraQl4sekVtWGl7QN/xQX1eKmBQxjKULtiOJRNPPc42PbwOLaL2mSFkWl0Jfjm3nZ/r7Ngzo95NnG7GNQianCtx5wpEYmeq/QrfV+UTkDmmocyG6Qj4vba/Idvw3Fut9YPN9jcLXDNYE6N5dv9Uqz/U/Ab7Mxih5QcbtzSyird2tUPZ383OxpiGIAPGMtRVx3zBtn61LLCEDxV47dn37iUuRjO64+PNdZhjCGEG29xWKwweL6j0Uvc5WzwgkED6kGEZH5jRrGGThc9ya/+pVx6HSzg0SAm1GyzfDF8Qr2paCqaOedd+IBiIFfgpEt/571dKaYHgeRXTI/heXJLd4CFN+gO6kg5Y0IBWfwPHfUqSQpRG+J/ByE1IoHTj6fgPBtRqYRjb3Cj17LezNDaJNXVLELVSFcVLW0A92Syrt7SFvsmMueNxN3svb4Wp1sfMoj4ELHVq1lHPUWmIn94vOoAMLmmzAxaXxtPV/m+5VT6QYk6Z029F5nMD2+ljScHNTt4mQTp3+9JkissGlcLuGvAhcNM0PM4KrhG+StZl0Fa5/0H903xskCZxRyLb8yk3mfsiKxioDChWm3oj51b0Dn0l8yYNU1rH9aXS2ZxpCSmDYkX1i5lAThzSII8xbnBNI3clYq8Uhlgpm6FdwWSytu3ebPx3nYSayj+8dGkk4sptuvRKScDXVdRbYHrEibojRP6GVotJOn+AeGronPBXA1q7Mg/XPLuf41OTKYjwMyG0DILZvuYV33yXC49UPu43Jb7RDWsCNNm2hakiW9Gr6AlbFgtx9+ZtAtXTXIsMeJQl6UvHjKg9yd5hliAN2gLktAHerJK1a1x4ZaRoMhHMCMELwxjr1xLWY3dKLW/xOKq6mjXETYOd/wQjop20s+E8ViNNosnyTZrRx+7ETNgc5OCDyehSxTY83I47NQoNQBvazJW87iBX12QrXadMk5jekFRKNKjpGU4CwNY/bC04nzeigNaPUiaQYdhpNy7RXjRIBKWtKI77syc3/E2dcAV6QO75YqkL9xV3UuSCBSNM46tapcXyxRRT7vPoaIvWGVt41wIKL6izPXNZxxbWCOgGkG1zLs1hapPadsFBJOs2+HYT5yrUYWsiOoafX4/Mgew2Yb3d1MaAs7ssnYqbWGCl/b2L8tgjpKfBOO2uA/+6bsVmZ2VV7okxwHx05vu7WIqhpDRWuZ+2I7BuokuB3r5Do+YYNECYg6jbsah4COtX+SULftT8y7pQpZJ9kU7fs2q/HCI6MKCNISBHnydVX92Z5PjqZYJWIGV0i5YfvqPGyrjpmSFKTT4ixulBLGrVm+UA5CNVMronIBtstUUWpSILgyV0Tah65ZxvxaqzoOUxWIkSGsprYPPeYhhSJnvxx0dRZDB8Lpqbx3CJN8BpGy5yNusPT3sYavM0DpYr1yEKDoLN3jRs04Dq8+ZiCjWEPE8x3tX9Qgqy+MHq+16IDDCHfi7oYoLKMOnfNRWn/J+JyN340m+FR82B0G2FOW3MoPKqsSx1Mblk1UTpD1Nw6RVvh6VmBXy9isAsacJrouV/91vLrwGf+GUooBQC5VCRLKVjGvVQy8YybMlGYvVFR6fA/Q52ryGqhv+J8e57d8XBg1NlJrsZUKJQxG3jN5eSK0y3yvMDXcwXzexR8UMzEH7WPKOg+gABQEZKqgx5vmDrz2cikP+K8R/Y4loepB7C702W6fLGi5+44ZqZGHwtrI+8l9flSToIMa4oXturPAgW199uCQh2pfc5wh0QaV87tHBDd7GmFVvkHY94uAQ+YrmDVDhhCTHCHOsO17pYG41ZNYrrP5fhyxhAXFfmi+hNEu5rokAbTu+uu3O5zPXO9i+pjXiatHPX9xd2+SOt9xHNCG9+veVAbqtyT6vToPHAtGbqJ7jRR/42tWmGWy5AQHbyXvWqzKvjSacwOUnAtKLe4U+NdXujuyuV5b8Pc/iyHNfOtKNw6CQaiJLk6WMkJZedpoLuFTUSzgzoPSN2gYvjM+HYugOXqoh9gXI9724v/JlxmbdqBC0zeAxfvsZcpuUICavBW4sgXxIPF+JFZD5bIeZx0TymSZn2ahuHLZknnWJyps/s3I3OY922t7GHvvuO2H4qbfEg6O6IHYZrQpU3qlhPafb0YojTMfuBWDz/ZtuozPrwmjw6pDdy4+dXPVbUzAcvwx/5LgRLGbfwUVCyVU7OnMTsxJgyfT+idv7fAEwg0dGGvuCNIAdg+CFxDeExbAvWlTi8MsWSHzVYkbYFw+5o+9iScEUlH1C2YAyd9kvhwqXk7yzO0zm7okk+w5IYqw3sdAMFHXk5MpWab0ZHPyx4He+5m/Tn9XTVLiNq11oFac25fwC6L+BKu1PYmDlJu1cwuaTl00iCoYL6kqMOnDJK0OIyolvUbGtxRTapc9ayol7l3mxGCZVYBR7VobFXIC0GQNgcESypQtOKVrwdxIWtSXuWUMX0JZPtatPHS5QBC0j533wXhJ4EL8nqV6xqsuGG+qPGjEV3vEn/gSX08z6+MEFhfO5J78QvS4YwxsO/1k3fktIIS7LALh7UZTUL3Q8yMryegDJNyrVlY+jvvAv189cdOmEZI/HFBlivXT2HNPwQ4BkJlm9CyJ3ftXRDnPsyHRW0opYQEYI0z+Pbfd/J+g4zm2HZjif5jkikXCUfIHtvIOUwkJ+h7sDFdHTGSfA3ncDKUrgBsuSfmdFrq2Evt+S54RWYxHfiLaGTrpE+C6TNaPc12VY1V5gjNQUrslDV/D/bBSUNtjSsL784WrmkW5AWB8+dNw4KFVoinfeuYnFnkXXI61XelOhG5d7ScapIPDxxv0QoMzL5VYIvKR2g/XvNq8OyIYIf5o79WiI2/GeEjx572gBy+wuK3dfaq4Yp6ZZKWPoyccJdoWag2xLqm/NilRY+dW6g+OZcIEc3Nz7jd3gkNzdWuvcnrgmLQP+Dl1MgVwQ+K+X6cDTta25hwgPLoHP/nJnUVmy4S1pEZmQiEbU6Kjkuccw/6MZIohLJhM9530G5I6PmNTqoalRFGt5wYqtChd47DXebFeoJ+6eSD9bS2lnOH+clDHeBl5ftMjYXML/0ftophHOmULGYKF3IOtNYuV1RdnfZDFct6YntVXi5ZHPoNGwxPiaWB+W/xhM9uaKTSHFGW9y6fILdWq2/2JqhAEl1KzSrpHe5A9J8zfCrC1W64dp2Ooru4gF86IHUtjIeP1VvhqyDnGmqx9HkJXEdhXId1B/aIzK7/rvCBujN8QE6ItVu3QSLjTwBxSoV8wAsicXgoDFZmDbh/B3h1qF7IPn++yBmKeccVf2ztk6QZklxU2l8C8Lyi6teo1tMiwghmcrt+1GnPyiR8IoyZnz3aN22+XSE3V/eGTcPBOilE3qoU0eJxaMxWOchZxOlqNFQvpU8YW+h1hjzK7TfEZUbp/cusizi1mquFmka9HjjWR3S35pg8PlVFLwH32WQzvgoH1iY94F5LKYjUZeGJdrkV8fFVT7NljZj0pZyDA8Pd3CBQ62MmapNBaXXtixnPOqK7gse01lumyQOz9YzWe48e+Q4xvp8BKdL0EYRFYCJB63JCum8ow3SRKIwy8DG+XTWj1O9c/p1YLjkJvFaU5dpKrzUKHYTmEvouv+qFe9f96PJHHHD3uuyp/9F5AvNoLMfWLE3xS0uGCqmntyxc6266aCUQyomRkk8MqsE9aTeKxW4su0ODUNVpDki7lL0x2QAplL0R1AMEc0MNxuyIqkleiWLKey9hUAVc+Jhe2qLgedKPlcCv6XG8hYOXWagieE+J+fYwHX9MovuhRql3RtKwPnZitzwheX8MJMv5nfWjcY/24ORTsSwiP5bIvWNJqKtlP+aYFf8fRE01bRRIweakZBDHC1OxUByx8mUhLFCWhyfs5HWAXkBOL+dnJuMG/ArfsiMxR6bCwAN1fFgWlfbiHwVnawCyVExcj06xee79irX+qWQovFhztKL5xmFtArtjkEdTTAL6FajeuhuPfmrENtRgx1pYs4RjCDe5+inIpgRupHvQ+zuRJyi79FSMEp7QFj9rj6d6zd1RscKUtuQcU3nKGB3w+IWh8txRTr9aq2DKC6QyTqQ9EO5pt+6/MJVjKx+lAcvYgQ2zTE5hAlhfDTTnZvqU/efOHLsKNmgEtrBmBPq8rCa80lttDmWTWdGWNpiwiEi7rnpwR3cE+Z9TdGFsRFgUpFgGGm+okQLqQL7Rpp904SWDFZ0XH9oHqR9PtPHFLODa3rkubynsSWp74ElOIDZA6JBRwhdrQNvA+ahXMnr2guJfxybuQf4KNlagbfh7UquBaefbizhb4vkz/tT4Ndwux1ePN2LOqh/rKiyz1ymcv5rR8yp5G5HZz+HLllshL59iKiTTCUBcReki5lhvAI7JCiEK/xYJYpQGuxEV2Tt4H409YzHeMwI+tnIKYcwKVrtRCGku1xqqToKobzKRjsZiQ3tkOFgH9Tdt4Dmqs8wucmyPR6m+Q1liO7BF2lwf9zknLZk+M1HxDxjLMtxU3fPXjYc+Me5RqZrJiXyRDlfAPNcyKQVECob52RBX27mDMbC92yIYS08lRs51gHV3NsyCR5p5GxBhLRKq0q9KL7O5OBfGCN8Kmd2jS8+BJE1RLj0mGJqXXgoCrLRwoa6HF0koBGMbq6vvodcb0eRIzNiSKuG4pV+CoY6oFFxKJisVJlw4Capl6AV/6uhbwg+JhB+/HLT4OXAs8Y1aJx87oi8atyAElL26kh2OGDuW6XZVeYOkrMcpFnMPvuYMEZQYl4D9+HRmqXUo5U2Dj5xeDue4HuObF3jLCwK+6vRD94tWDsrR6A7wfRK8aiI1OCuRzxFff0rbYP8IQ3s5vBD8s4cnf9zOdkWMV07uQU4fAyWcehDR8+hco59+mg+ROVjZArARqd8FXP+9wkMYPizGlzVL7h3CBc2Ih5o4RRCCkFcjMg10XvNuvzOxTJfMfwTsAUk3uNVv0hSZJ6DWr8gYFOfeZpqLS+V2JFJEva3rsE1rLifcZZ2KzcFbi6DVKwdyhnHeDFAQ+pmHWtN5VahPl1iZch7hUQ3DT7o4PFtEer5LAXMksk9FRoddJgIKKMKwxYGKXaBbiAzIx/qcshhnNRZJH1IRbVP2yMZ7kEiPGtrY98BNpDBIz98O81t7FhvAsxiZxsalZKRkuBQ/pWJ/RFNOiOjaA/Y+t3lcPl7yglh+Tv/kJk9bwGZ6f/CVr6tXuU9rts2rQjnlufL/AAgx64ApSBigm/UaCwa4ZvkguFiQJo97W9oMoOHiWPjA0dFwhOQ8NoU7PwUB2tHo692QYiwJKO99QMCs9i/rCneevtuZWtBRLu0z623rZDkJOrPHXVpFuckifgxp7scyFVxSirRv4qRDU6B9I6k8lTnz4KcMmeiMV7tOP4eesnFTN/rwMQIb2Q5sYhbDxACKClNr/BgwF5K5tQv87asmK7AMztDPkgUuS1DWdIIR06UjUsxxPC77ifdUO+x31kHztEzJKW7cV8kTdggQaCltTAEfY1mIFMltMRk3YozmnyjCXe6HpjTXcdT03DeARETJ/c33ur4SAxMVNde7LGsW9EdBupRASMTBAKScqiWZGipcYxjJWNYPxTgCNMqq6i2pol6bx8+ufQ+fCSM29X1RYYTADibuktuy6DK8BXkSlz/l1vwdguaRtBpH8ja766TT2aMiaDxYzaL5KdMFQV93TD6I6jniVp9VbTpADNGzXABUshftuR1zZnzUYBnp8+QskHHcod1dhhTXwTbFwkOfEGTYnuQnD1HawapFNzVMppYSkvfy5yZkJwchrBFHV6ybM0K3toSDkJgqrxPdhf4ksmGVvO7giixkvQoHroG8HmIUH2BSCLSxMaRvP87euAUjQ6yMwQd3p3Bb4DVnSfwGg6Q85t7Dfka++/+AUcckl2+erDaKtZeJxyUBMgTfp0sYa0JVi7F0XNbf87cS3qqzypII4SLzswen4IKTve52fsIKBKjRZmeGd8fU+gGiMtgbZVnKHt6UKSmSXoNV9l+K4toSxu3tRnOb0RTXuNyCacst5EOJuYeXDUrW2VhRVNe6Sj+dYQzIDTpUxH8AQbhPauizJB4aIM6AERi1MwKId4kT9VxdBmgWwwLCT1bDVbAy9i5W5/giQZ0TratYrgUPlzHpwouvEFOHzD79qjvJ0BWjWe+F3LurKNQh/dVvqAUYWSRaCHqGXai09RJi4pVdSLZyCrSOvaLS9bTzHu80n8gA5F51oDKhr71hCUYsu6q//+nrF9NJMwnnwGn4X8LErIGoAWIT8aC7QK3DvyP1sJlhTVXyR4zNBFHDq7xTHir/hVi32ST21+HEwLhDwHSNGcNzZv950mNfpX1WsMmAfU/K8QLhaQnPmT8FBzAMtKAOalWiIoFvPK1rrCCONYHzIeX5Hiwzm7ZSuZDi5xZbdoFfMT9QZ4Hni+U/7q3nqcl30qEIad69Jkj9vDJCyDWw8CBxDKxMEB8P2BTc9VmwTkDSC6YLzA3n4N4BRkONAOpNuA0QEJl5l6MsvHT3omQAK/M4GIcWaRcHOWbfh5cQjnx2IjxHYykjDryQje1Hf9cTfIRfOfzs62Ta5Hbvu2/YZ4PnQosRkKAW7GBSZmYlpLbrb6e1FXH52NE6N9Rq1aIRHEMYxgEtGUCQC1aSyetYQAU2hhDrs37OruynG22WjW3Clx1MGzEtI7gWbM+wXVHaMjHjTPObNW6PRn6z+NYIHQ1dbBDRtrvVEtOsu4+u6xSMhMCX0GBtkIYb062sZzGDIipp2SnF7Nqz18zgKrou56PDGtqy7qgcUyl08WPhPLqndD40j1mh3O6Xj3sRWNzAbTHbUQhup/OKvxO4mnkc/Zb+tv7mX5I9OlGzqX5ks21FkMIjg81sBuChN6nXtaNDlZlxHXfO9WGR2rcvIHd8lxfqIYF/kJA5OB+7JnoE1WFiwYDhM0uvSKUx2X55+X7QqvL5bWEJw9pgEDvNNmBTUAevR70o13TMA9EBb/PM98jSb0SXM2oL/g0PxnWiTkbLazJtEBKFtWd6o7LnQH1oCJ0VwNVLxwdd1fcZmJ5j3oX/awUi/nbx4d+7s0AldI2ZaOwmky2wNlmw9hFmk7A+/ti0Lo5UfR4XKMtWEtHz16MdBvKUbBVbdoUIRq/Y7sdjWZRi61MxHzkCDVTuDvFUtKVd+Tb2xNM4JSgSzrV+MqOPWGYVQxgYO3qmwuqVMST7bgf2K+ku09hLfXHTTlcv9bgPmL1PquaeQGJAlzVTDDbXCRb3z5xOrQ2CAC0qTSBTxfqpBD7IOva0Qrf4sBVEl9IuVMMdmvT0YPbRsECKO6SPg1y2wuRWERVtCckn5IAPdFAdv/5IY7+WO9giLRONAK6s1yOh/mUe73Zkd0HE+r6P5Mj9vUTA9ZNGlJ7QrBmtY8v3P+tTV/SmU9Na/+QZVC+sycabezNULZDcyV9yAzxuHNnHmZfGcqlxyaRnf7jz2eKzH5ofKnaaa5Ciuc6kqTEt9LJ8a5uUFHjK9S53qBKrSelekp3PPngWG+jHTUq7ja4AxL8S8Bpnue+bSlciwktlhMo/RMRmQ47zOSH6kDTUwK+p1J0I4ft+xBSIGZW3GUsiRtXZLXHepuEkNve4DMYTx8isHoO7hfzVOjxjEXXDWjIj9JgmQz2X/rqwL+MdZj7ygjb6mkdmeasWsY18lgLXMuR6mOG9E7kQ/xBdbTpiUflGpHcW5rFZKXT6iDDSNN/pBMirrrif1mr9lYfWMt0G7PGjoRYf9dzkTRHuI+Dc57e/i9gsD14PgE779D17FDQKvS01MV/W4kZRxMivP49pcIELkXbPpV7lrXbnBr9FgHKsqM9PN2GaSw5exlEyAAwlkpJ19IkL2/8SFPufNnYF27AhQifHWSv+ECyEhM18EvtfWr2KWmPk6sxPf5ElvjlNoIJBYAcwnxQRE757QGow/LcjCpNJ89eSsPi2T2OWBZCFvKFdTKqSIE/BYG9Mxx2gT0JvsMB76l11YtCNUFlNiKd4/8XasUESLNlkrqO4hkUPJNp2oft1AWZUMxnXFNBcrRbB6oMzl3JEqjzvDCkLMps1EIyX/KTd4Ag8FfgD346HzvZaZLEd0+LT1h2z1NhmFUMr8dFbz6L1wnc0C1EnBnVfCpwRE1xKsUvzlU5i7YZHOUNriU5RdVA++XSKMWY55Wf4/q239kqNKQ0WxWT56jX4EnSJQNMxHQ+e7h9+4gRFVwApGdpBknd7V5AUaqY7ikmStUSUuCBvL+yFrbN/0K/6g8IOK0KobnAXjpvX3q44ZNSQelMBDXJ4Qg7sOP+ZA6f8J8SpnsGxJN9cRYW4hLqQildZsoBHsgwVs/90GYUZ3MwJ+7gWTIRb2np1KlBXhs5cUmEjllytCyT5lf8YsRAO3tP/3jttrJZ4O7StLX4vHXvpbQWag2+3Gt69yE9Y4QQ+8+tAT/kijUHcDxR3Sz0RKGalHZeJcoGrxuctMnv454tR05ZwwMGI4y9aLOGmfhZmf203SDa/WdIe4GQgPQedYGSGwEx0MLdUY9g/h5mPWPf178cRYSRkvg0FStnZfr25j4kZAGA29srRA0E/aRGSDGFDT7Xw4NGza8JKuhX+utvOPTt9viRZ+etutQwKMnli6FMxM801Sq7LIKwVrYSFof+Otb3w0iB4YZ5aRfJTRTOTmpRufvauM86IJqW+hgu6EKinwEyxMTREodH54FdbbEGH35t8bex3n+fcExOfjNCQVO3nMXD1UpYkShmLCgyRVdZhrHs1QD5mqaBPwgaqH4kCzANqvnUUl8A97sapCBACORdvH2Y89yG79mnopYosYkgb8yYzgEaZIxPxtByNKV4TIYjdwSLIsvy+S+FU9oo6/HkoHuIbHyxIwuUoNW0WjxoavgOqDvbF7EI+mj/yvYjeXKFxtjnzVnwBn45etaO6vm2+2EQZfp/izNIbYU2uF5A9k61LrP5q3XBvAPZacs84qalhaezOyfUdYQJaSNHIUbS90kldhzRJUl4cOJS3/g3DaBwWQcavEzRguf4hd5FWYLluEoPvObPAR6vdHcay5M3ktqpyNqS+9XStu4urvRDGMUmOJylIYMB43hEniET/hsa47B7fQcE6bbnttveb/+BngVKTx6JIUuhLWadicVI9wzbFd/CZ51S74CWNGomlCF19eVD1oN7zKaSnhvHwHyC9ZvGhb2ooZPoPIQNiXme0wR3zidLUwvwLuCVocC3e9dKVbUHdbwExc+7NYd0f8n/cTHPvaTTVC8c9Eb2CsjohnenlHrDGcwt3J2HKAQ/nJ1J/QwLjfCj0Vy5IwhnOkoFYCsds21kNAwD0tZga/55faJyAJZ1RTolwqVEPlI1ow2nA06UJlJIlaLk607oZ5eEManWaRVQ4BXXAfj9Usy+hkyazhy+ZwYq2d4DIx4FeVcU7i2hPBDIVvtvXvWqJ2pVj71GNq87BDVE/IQhRYo6yW5nYciXKzI2pb1djBf10q4goDEkvZWrKjhHuwrp+K/W5gFXSDTkOFI/F7QDEUQWh0TdRHEt8cj8WYYoKOyJvNv1p1X1vPkU0d0/jpe+74/tFB5xSvv8jX0oEwzJ8JpfLMKGQm7RJ1LWnLC7csjfLjKxT4614YbgaZPPNcSK/MoC980momqn8HaW17RSz6Ivtat+BV+y9uHa86q1lDjpeGDil1AQtvwfFTTBwyfH2Xklk2+x32FUH/ihLteTBnHvQJRDUQE1l3WWUIRgIyq4x4Z1gUQfq3PH0G+bCau7Jt7A4vBBEQdoMi+NrF1Em5IC7OdhWCsYKOScmK3LrVcfTQXtNwsY2b2tAcvXO0xTZk9RHHMHOGniwUG0yM3StXYwX2UVq2GfnUu0BIZAMQBln84pm11hFKCB8c/FU9kMyfIchLpoE8ciTxAZTTn/ERXgZXAmUQgfsHD2whlnRaUoYeXGfXNOmcymiJdwNhtK7K+m6a7DV3G2Ixp+UPFRv5Z3pYKvcURkFYUGSnOrOMs/SWB9oa8FHnsnocLejL84v7hnxD7GnPKUtBHrP3J6AvlZLXqq1fQRlK0VAomnhlBjIT2lXaoMGygZsKOI5jDAzdsebhCMKfG1nPhwPfyPPus5bnJWEVUgyp0AljhK2SIwaogIkfMzeraoTS8aZF/f2eaDPOWWSw/38YytvHeFrtgQp8dgfyudJvLbjHwHfNwigMyHtGMJAR4s28bOyPlQFkja3dVQTd5+VqLvW6EME3+TP3NZGtTKUcKvPn0OCeCvINEQr0cHr3g4WUxgqvAHn+XYLJpG6UOyhYH2UT77ZB35S0dld+OVSUVgPdHQNPRUrL747PnhaVNWrmyAaueBTQctWHHCnsy+exmyMgXpzCsjhAzHeLop39QJZpaPDnf+tqnYGHe4l45/+GboZcy+f8FJcZz/vlhxniw/tJwvzvKsZ7nsMHbxbkBtSY6D537J3jDkorx+4Ka5Hw4Uz0QzAasEX8nq0JvGEuUxNfAbrW8qSATT/pa+2POF0yKuz45a/DbHA+Qifez3nwWRmJBR63akusUFz6sMIKVWpq4uBK3SSaW59m4H7WN3rZLmJbPFsRO0tCMg8zOGDt8lOAsLLXn2GVKStt0enXU0QqXvKs36dO7hx7eVuTYitdGDPkJwGvFgpAfwjC6XaYU4upaAKtg3JfIiflyYgwTh8wWE2ZAD/V2fHfGWhn3QIDyfDbtEeM6q4fUk3Bb/c2bF3ypnqC1MQBRRAp1um/dEK22qRs3msciRN/4HDDWWa4z9sRKtjMVdgLzP20ppmbBEcTGz1hjTX9wlyFznvfUB+VBTxZp1oGul5601fBUf279pY1sLcXwmBCbShxdNX5STRdZgDJjRtX0HKno/CeGxPREtZuAQRGcmTwQ0j5GtS8mYtdNp7rJBv6ddhdiCZbo5/sZDNntIvPM0+GH/Hq85wC4id8mUF/Sf6hM+AJSabUgPPmrWe5j8wwVWGMma9Eu8fdnCciR3TK49mw17ucc0dymeHI0s0i8e+NbEhJHjJVbqR2W1yKlngbT1yetr3S36DIiyh2gP64AYxXgceM0IMxqa6WcuAsAzHpe0BdY29+co9as+XqlJH5tlcDWXHnS/0sMaurk3zbFAHTZJyjTTUeamuNCsHbENdkXXVd6sCemTWJ3Ro8HlB2CL/63Fb03Kzov+vMhYHj8o3E32f9zWcngBSah4VaTV3/XN5Ytyin2pfohlnfHcKepisBnYbfhX/UvD0B521kdcysv3DgJ6qD/U4PfOo4QGKyYO5C7ZYuMCOIMGhFW5GDoHzr9Q+X/9ps45tbBY6HZyelJDKqg+Xb/Om1xkgk2kcOQBNALN+XkCcmjXr4xttU44NWQ2U+nn12+z4PCEsoFXJ1AtmDzfWo9KobqL83kMqK7tsyoNl5FAkYJd+TWKyZGkqRdD5eig0MHDaJx1trpurLSE0EP6fsyBa6przK6b1BeAWzQffyqx0A1KmqjosKAChTLWc4uc37GP3544VRH/ByHQ7D2rPH3ZITGtaTuYOZgR66E840QOhZ/bs8zo9fhuNTVK4QXU0FpOuzDkXdRdV0m/3seJpd+nkbd/CQDTK20MA1VgOAd+lLAdO8tpgHXj7/tQ9Kz/G9r7kKcocPcT+BSnyyZHCScv+9iELZyFeEVqyUWJzqw1vwJbeTbwL6s8CP0Li6p6BZKH9ZlatzUL8dPF2rM8bPreo6v1N0LIazEbCfyaHkVlSQv/KBRgMr74iFQpxhngbLruLh/HhLa1ldOpBS/FKSRvKJ03T40Iqv/+6VegfIFTsJcN2ubxCiYwJjVgX7753x1Iq/CyzHg8902Api3myaCgCA8z50eLDUvxwfQmJzz5mQKjA9aOHOF64uFCuuaZyOWImsRZPXRG5atmX7cUv8gayzfUMLpk+jhddHDSspHgrafXlpvl5Re/PVZyQDQ6bWmh5bQe2mDbrd1BxUHqzQvB0C9OW4BGYre+Zmnte0Q0UhXTVJM1Vq69AE3K+EEJkcMmumYpEujNNXKxSfhXhavmLhqCyLnKPaFtmkDt1YX6TtWHCBc+rxSy5MWXgwuOi7XDsV+F+gYRLxoHI1f6pCagiaQj8K7k3cyKSIfhDIlENMt7YmuOP9EdIbYhgNK4GyHdk4M7ttRukcyXG6I67K3pXVciUr4ZbZoLBG1d/o9kwEFB4NV+mc9DZqn9RX7tDfvaPFz+7s/fphKbDnUNIje8xSQPF9tPFtxXc6jMQgs0WGeLvkXLievpVprTeaa57HRST/RatVm34zFRoIwVs3myd13Xy5f16LFbkVT4+Kq/bj+rHO2w9DuKBDyvaOyxD7rdNq5yPhirP93dmma9J4/N0O0WWzOsgu2CdohJHQn7q+VFVLeRzmX6VDVHdmj7t98BH9Mdqek+uD9aGCpY/RmsBv8pZHCoUdMToLL4pLaeu6Y4DNtESUsAZRnIKaLNSX2oqWqIoQnMYTtp3OIWbkWXTlL2rRCigkAlMHTCaVYneuUXEI8Ov+K2jtG+QFQbP6E52Z+xXZEHd6/3FhNa3GgbKiTaMdZGCFMvbkUV0yK+M042Sd6vOQXw3Z6t8yzQhf2lV6Wfv8pjhxzh8ug03HsFl8sgYGYmwkjRrQ9nQh9e/FUWU338M0Clpwz3UWPhE7Wjcge6Ro+/4JdkSv0Duj4zJGCmY+Z+GlceF4en6kji/4qCWwq6qFJNhzjqqg4h6d60QeyjKl4UUc+MH3sN51+i8vC3PLxvHk8TzfYw7BU3i7saHEy8QbftuIuwRKmR2dLWh5i7aVztlvyJUeVk+d0lnxGRSx5PPMuGA2uiKM4gz3BU1UH7ZoaTbsAlCRL/Rf0C8Th1OuvOYaKrxf8VJC5CjeQjWQwz89+eUBKSOnbxrChZZuHDHl3dKc1iFyYCFFjAWheKMG5Qz823ObQdFEtZLQS7fQNfHKNeDrR22R8gp59d+ItLs3VvjF/dausvL3cYQRgwNGzqk2y0NjDw2UQuTtZnLnhwbJ903+qQeuOIIDzTXSn1FK5sYnPHPwj7EECHaou6AHlGqa84JL5uxHKHXvnsJS3Y9h7cgXLhUbvgk+TpGo0BWoygwtMDWw01jSFiOpm3C47Ed7gjblrUz5ovLt/HrKWIUzxh1LYKunhXEweo9YWwTZBSVeM8M9vEXSQ/F2lwL4PVjjVvTquxqlGucGNmTcCv7pNIVtSMwh95FObpVacoibJx3aFjP4p/pbIrG+q3Y8nSven4YFZVQNTvFdhh92mBGuu0rz5SajzbtBgRZe82Ei0yKKsejVsWWw36Q8yLI84zVEt425QaHXZCgJr/tiRMCd8y1pncjYdHNYR7+z15DUbOpbkzf2VPQKy2YzzJkzHohpZviYE70uJm9/p41TBOC/rW7vvGnzciza3/WkH2Pm+yv8oLuTeEmcAmV2XAPExfmWnzKo6s1BKsbRsdjlJeV/Z1g87JgC/gFg/+DsmRcIm//5dk2MLU+XsnUBv3JBoNSGK/azj0kBftDY7aRXAEdARrabpIWJRiZR01GjGDNMk1B7OgRde3IwGnrf5E4aqJGuitAKzdRAYJKHLbf/rHjwqt3/20IY3XYd65WgnLH+0mxvJiIHLCXGrJ6/FH6iakcHwj8232HGgtNaziZpJIR1mo95rSq0NlHL7s9Ie9iqqWT4qc4+5ESf7V2wIILOk9rSHW4MfmfNn6uZW1lqsblxvnPJdbclRjC3ebTpR3ALKwkCe5MJVSmYY93YU8TJqxc/r65asXgEezbz6CGQxa9y+R3nk0q9saFx4qinPyBWlUChUaQolucpcvCTqtR5otx93doKp31uzDmRobF6VQMU2LvkdAI11JbSzu9XQMzk14cVrpUuD8x8/ztwNifbT0a936qZioR+3FsrELwsbUxoslh479qvaaSqlmqfc7fIgwOIG/LipiYgAMffyGotOMtzn4NWLV9ms0d/JH244yGRNyZJebhyQvyHmjdOBqjyv6gqAEK7HnxaTiFKmZ17fz0/mIVv+9IxImiE5468ZU/YeJgZaw4s3g7WgAjIFWKDB7rOiP30qgTfZ3ZBU4IyaYjnLLfQOp21xI0iaUsesvnUYKFiqjajaWojHDsRJBSyw5w4LzJjeFgv+uebjQUBDuQyd+oWCvyLBWPVDsTIFCxR623hABEvLbxIzzK9dX6M177OI2tvYAFssEfHFgx6UfEr37xEtctCvy45UQJG+LaKGGf6OjjgTU06eMggmpJgjxhdQEbWTbySgwm3aIdQeR/N+etLbcv7b0F4a7iEEC9zOO1/fi05/JbMPumGPsNYFJfP8CNwSGWnkqiKDbZVKz8lHd7ExUa4P4628EE4U3euKik4dqadDb5Uv5PJYsG64Pb/mhYprwQXeFVWpTEMndexerjUtmEHCWnf63+phMno7Rc8TM8NVL70g6lqyK/ZHtTZBxeBvkGQWMI3lmdWZzIvc5Gusxj77Xss9GjOz1sKGU01Q3IHlhXUpbFd6D8JilxhDDwjU+KzXqNVkOaIHLmvJ2fKLy9iOSWca611Ncg6psW+uaDZhm5x7Vc6CSh/ii8tZD9I/6kmX4WtipB0ENETkKkkQIXPQEfapKl/TzydkC7VVhPaCLyt0mzU5eUQjIR5o/oPMDi+BmvStH2z9n14YReycnTywX0cwbS9a/ykapKoN9suShWffpEdh8qFyZCnvYACgaimQMee7owzdntcVWzzF1RXLiQ42ws5lyMZS6xXx46EuNEs2Uw5EhZ7Bf4x2UbX9Qgjcg4aaBnNLO6qS7i8qCp6BDrSQNNGsmre7Hc1ZIxT2NWGqSciyMS3aJl0eYJxvQyCXYKxOjivQXr2UTYHLRVXtFF4ryS+dFK55aTae0VKFkKX0R7Pr/DYITR9aCuQmr/sWhtBqMbt0GeGQNlHpzgrc10eJ2Hh1GwJFoOqbGALXpMrjqLIDuLDCN80XKHr3muzimtgfkwlAb9ZdJrxe4Y7IPYRKx3tGNuWbIQt1oa6hYCCZZbDKQMZdzc+JMMv34SQ9WTVubp4Vm3WK+i13cvwtaHmFtam0D/RGQbheAglAw4gBCo2EuDjrGQvkVKsPXwMgWMNbniR41x8Ht70BuuhfQHZyO7XHmFpuD6l2+fjxBAnBpDsKPw2FciSo53huJCNVnEcqul0RSJpzUHfb65018ujX0liiq8/zRwGLlf0Na3tysJL+xrUDI3p6cpTJmcCEGNgL5DnS+cdUabtHgPZ9U44ZFTjDQHJ724swA+a3cDG7SyG/s7ET2RikT0glItbihZQwTee6BqpjKVLzS29QY6Y+vsuX/RX5MBN3b3+z7z+NV312PS1hVppkwYgjxJK1mn6Rgdohf6ouV/ysEB1zYFz3bbDft1/YPCNXknDMl9sFp3FwIwgRtK5dB1mmMBzSZAEHqZTjITaJK8mw1lwEpd3QmOYZXjzST7trfsCs8BEFckaWgHNA+6BHfd1ipFoEzCMuPMHrX/vlzzyyr3/N6Ua2Z8nwLW5ih826EBqbUEBP3bbHwZgwL7sqgVKtcakANKvU1Vif7DIHIQWHO8N7/5B2UwrdWy4NxOLX3H9GVCrmOJIg6Z4O3RhMGxk17+iMm3Qs1G1aR8vDKdNp5S6EtFAkDiiaKE+5q8eVd9BkugATHEiXNaSqLOGO+ctqQZTtZQRtoQMdVQ/LZSNwxMZF1b1zuXLh2cjMx5q11sWN2yYwme27YOCKx8o2saEh0uEFCfDDdo0QDkHp+2zUDlbxyw0fpVl8nFODylpjF6lmo4NDehD9Ko6CBkzaTbvsz4khrb/LUbgbmYEdy2KZKi3ftFmf8JUoH9+nPoczbaf5YJJJPlIgdCzA0BESKt++1GmolJIwzgId/d2zKRKLONp9pQVRY7gZAcphc2jZP74NbpgdPNj7ykLMi4RQluVfnHRB4C6Hvb/wHCcgNldI7EaMxfP46lsD41Qx5SgD3DYWVex+TB8UPnSQycvjZ0s9AkuZNU8Wvg7oKSmlN44ky3L4pDkHe4bGIhTHGccPR9k/TJQ2L9xW6uo2+fMyBLKYoQI+MIHjT91DAZjmlii5b99xdZgDEmIfst1MhzucPFOGz4Tt4reH/44j5RjSXQTUFNN0Cg73AfHQFW0Bc4mKz5UH/aFRBhE1c0gFC8t9DiD12zbhN2qC+qHyi/a5VmgZrLOwKTL4JhKVONwxnsL3V+mQV+w3KDxwe5U7wRGG4Aqg8BOJ1N1R1U4F2yAX0Qcs19x6zJWwQjqq3LQT4eCEwzBHu4P+q0gEy4JB8LK2bVzknlSIISScibp89hjfxi0wC6G0ERvAHlAsBKK3NeWmLdz9a2fNuF6NxMRBvBvsNqbmnvLv2b2kEH+IutWl0QeRhiQKw1vLeJiXSpmvQnTTLriqwzlRFuHsVCMeCDbBGH5l5ugRmyAigshInLFI34n9h17ZhHgxdW+M3VBXID7i8mZAALsQDrmt4kP8pCOmPXeXVZ/fNpI1shUgiRXyCf2y4migtjbcjBIdZ9BHAREYAFVXMJYmSjz232TXDKi1keILdczm2AM8dUA4ds2PoB6Grondu4cPHs1Rj6qPDMKMgDveCGzEKRnfRXZIjh9EDOfgc7d6SrAPhOzdzwuQgzjBXoAV7tcyaHThxxFBoOdM9PeBGtOpG0xe+vqhd+wYR5JOGd659gkUlCNCQYz5q2l7b3fodCKjPrFiQSb3uS9nDLFvSswdtIjIQic5K176d9KKzOeiCk+B5JntLfFoYcYqlPsr1ZdeF/7IBVroodSMk20pmnZCezK6tjizU8zsnSpOKInwfhLLaIeJhyYumshGyjAyHTPMr92EHZMbPihVpd63qCfJuuPotHrCZ1zKQNnfRdDkOvKYTDwSF+kIx1L5QJ3A3XVlZ0BvlnUG1bkBAXQK3gm811UY917SY2NzJnn6cgRTiiErjpg/093QMEJK5JfAwpm66eGHPfQxDCWLNBJ2M9+1tzHcJV5TSnscCmlYOLQXrpzITTKQsDJCxqWnwwS03r8A8ZrWxk5a30rj1yrpLFoQr6hiPZ2/F9VpMybaaD+y0lBMrP7nJOi/nJtzAK9ms0MzMyjtcivFGK6gSmgA+4QL39HyHRs8sq8FEWlPqR7OpZcPoOiSEFO2Y1gAWZMTMJcoq0Fem2SVNeR5g2KlX74BXQulhcdyLmaVCXBhKFBoMKU3UMnZ7Mk7DhjLER+nPXtOSu6hCkGEEHmDM8zktRUreZPuiHy3SyfYJ43Jf8DuR1RZ1hK5fDfvbj22E/6axt1ZzSEvjYet+Ax0hR86rCP3Ufe9pfKvU8oyGn9h7uqCekedHI7BQBTB7SPjz4K2AjPInLd4/ZUVlbWAO5nqyTxQ8UThkF44bGvroVD8OpsDQxEGfudx0eS6AahCIJAl7EcAM6JWDcDBkMnzzrOPd0YkkocjRv3UATNnX33rrqxa2/wCMKo1gu7P4OdZ2vqTIPgpt0PcQS0Bxmd8lEGEVGp1+D3leAdAfT6d0+NuubacXVeWH5dfluoOeBAUPcaOUQCmurd3ZiH+FjiukFLYXl1GLx0B/Yell6br5E7fJXg8OrFHHzHOod/IfG/h/WzOz0h1pVCkPuqn7ldt4/GbYHLtiVrc2xigjQy2jf3h22NkgGpSO8A05bw74yEXRwU8VAID8D+PrONNqhl5+rhoKuJ265gX/3c7VmpuS9q3mPZpYjd8B27V2N4ys+X2T1YDdHPvyjORSTM8SPZo7EblN8Es6sAbjWewm2kyKbT5+JILEXT3IJL1P0hzaB1nb2igXsLvBIV+7tiQsdcg3+PtQp+iT3QHsn+Hm7P1P0zSZ7Vo/LrvdbiFLCVdOQ/Qyex7Mx6PCujmXYMSmv+jkqApJJdF1KzAUBU4I6EGfInqoj+to5WOo+bu7Lq+igCeE2o3t1VzD9YFa+Qm1kEjAfrAPIq2E27m4sY3FI4xo3aiTj7IwBcwYmO1Ry9Y+ZssM1mXYOM6yfvtJyJYBKdpUXWts0tf3qxX2t6QzrnTZPa13pnbTIJvbOPPOba/psk2KWuKoSoeNskO4Ba87532vwObUGYwZss8mBJ398JuYhju458Zk2nhtT3c2D1U9eUZhQgHl2OS1V30m1iAJ6KOtSOexZs3r25Nki/GqEMCS+q2waiOYZowuWWT+F2Yp6B1nkixo3TvDrYe41dx1BspJSIqaNjA/4KjbuNkiLq2l0TBbgjFH2zp/hbnZaqTIKFOAujd+C0BOOvgA41xhYklt/sYDDLLuJaH5sy2vnZsf8nApDZw/Eedaez/lSTX184jzMXD6/XTGorXHgUPffDo5/PhbABtbwoEpBO7acvp9pn+T9ACuxF6tixrFP/aYGw4SCDa3nes/IDL1jkR7qlTuNieLV142bKAlHMpGl150e2QCo/GdXbRoQKO1r5uFLhg1I1rCxCkPYkeaKgS7fYactjle17YSMQXqGS+CXZ6nqUBx7o4rcoLTASnBxk/ZLRTDqmVUHVsAaPN91RksRqmsmUFwEYlCs7yo7JL5vD8DIZvcVBlT72DgqGu32Pbx2y+0uIim29KGd8CYIEnF4DvoYunU5oi97idOvuuYknWFFpqev0bZhlR8uxBjZbSbRyer4C1Wv3e2F8GYULihF9jDwB3U2dsqB/zk8cjLUkAnVLgkt7aOYBDL8lCNYqEWF1b0ApG+D5OBquRIldadKjgRFtZfzi/4vKTuLX18r1zfv8Symw3KQ5ZoC8RH+Pkl2XoCvAmMyzEOucPV+meTeQxoZ4BHaVP/VJBbwjnabLDymrAb8sHFiJroKVWgD9hVsAY+dTFhq1XQ992tooDFeD5wob6wIXFGGtmEDD5mT64X8yA5noL3dskx7DsJk0w4vZ4NwtFyWakekA3H9WD+eB7SeMRRQt48/Q5hDdl81yb8yGOZ+cVdoU3f8eOsw6KXH7aNQRMGNMSUW63+INTwJI3fkRZFjUY8NipPuDHQ2qppwE3jom5GCg0NCtIj2sOQ3tdopkZzB2Sn8kfiEDh8ceRzoIWvcpIHytcCT+3u+7EaE4uZ6tY7jvxNV3+OBE967IoDSrH38BXHef6JR9jFJQsm/vbI4Tl+trygIRFVxeHgnuKIL9fq5Y5QN6CKd34kdeAUPJ9FD3742WdtSDLtn5PaLO51FhwOk/VmN3VU1wEXGUQ5AUM7GiT0arBYP8r24mCPUwDC0p7izn7a4xiJeovWqcCq94b1chvqcqaTXEx5qZEjvdUKEYBEF9CqynHlpP0aUvVHl2jkDuLm56BPixVridNjpt5Zq4r+RrAR/JLcKP4A5ceX7rPCUtrU3/rNr7LCQE9F37HYGWs6wUr8HxTJFkkP3hdWE5q3GDJ+J+kn7g0aNEaNqILhLDDkbtnosxgP5QZA/80SjbqQoQvr70UM7rmMtivsQHixAPcc30FhupAEiZAa97Lgs7hispAcGxHR35+b/hJQraGhBDqmjR7S8s/meBlap1RvD6ChAcIF6xbDgJ47aZvzBIWuuyYEUro12WICUx8UjTDOkDj4pR/1kyn/9gekibqoki8myvYrYGfslj3arseMsR2m+tiAdxganQV2NTkQiwUJWuEnxiL8ArdYmLmxWVcYESAiQj7X1gKxu3sWbtn3qDKfTM5WcFML1sy4vLZmJgiGgIJ0Qr/l0lNdhCWLDv/bppVLUVZK3rLDbMBImu+Ft4NoGxFff9SBOop+afmWiGWn5uHx0x16mzwhJEYaHa3317oj8C21oAwQEk2lF+NodCQ4Pyon5+1A+cBHG3CoPpiUAsIezoTvSEzW0FC1Zmh+86PrO8RZ/Eyl5oZQ6vw6UsKJgdKbtKZy1Wkdxwm1Xsh+MFOW9eEtLglqJgBsJj9caqRrxYi9/9zGnpHjsZ3tBpNnMA7NMRYm8iAtqeoG14deM+IJlFP6qQrToVVRFh5nYoe5m5dkeCGG6R27BUurqEt37wrxOMjML+uIY6SieAC0J1mnAFSUCj3373/HQGHSwIzUK2MWe0mFx1SuFKSBJJLiAUjnHyDYYelpTtLmp/4qVrwnpfuWo7Fk3llBvVXJZCKh2u7hTyex9mS0DcE6qVzvJ1hcsv409vzcR7IcFEII5DnCePRCKUhrd1QfbXsHDI4f4t68slhMcslaOMoSGCs/1vmYSCm8U84NmeD1b+RDEbpI+GtArl57uEXE+gPm0zLOnwjTQtOVLKSfZ0tT/nzUzc0NVV/EQ0uLUSiVpz7YH2GUSs1oUUYzDUAwS2CoED75CFzXSbVNkDbDTXYXHs0PnHhrre5pRTys+2e4KzHkX66qP4caoeGMwBo4GKSOrHzZq/p1IEE3j949pTdWSebP2Dns/lb1jph6gixDrm4CGwJwCo3SfHQPugZpVAbufu++PlQeaUB/Lv6/tu9cxBVT0OT1PpgW7ak8xX0fQS32HohSRzEcqr0sOUx1KOQ4RvfRA9UAn1Hawo20TJ6PqR6iUtN4bah1QucxEdvzxfxKQmvSFIY2cMGNmMZl8f4mV+tHgYCVOLt8lkgN041gJvgLg76SxpT3DdERDakPa9HphBh8jWnY1s5uGdGpGkBkKcxMHunnT5XREAnT39xgk02rX3RmtHnEXJHfNqNI2wlczYUlwA1vlUgP7DbGy95dyJqBXbnyQaazuoA/k1E4jpsUQti6zum1sLNh7M2GTo+s2fZNKlVlA4lmZyuAcR3xUuJ/lX3adsvKIpCr+CUXLCf9vL8jswrH+c1U5GVphUw26cRUEKM3J0Zt76MTxcUZvFcNzcMF11Qr4BujL3T0YPNs3vYZt5z0eTgJsSjy2sq6oBOmq0KesovO/RGHWGT2o7TCImAY02VLmuobBZz7dQdF/y2QGa3T2I15+hrIoYYezP+EdFbHprUtwW6ZZ9wewRpxLILc+HT2G5fnefQSKzgnhZS0fb6kr8I8fEMh2JpJt7DBFr73UkB8tWQyhqM30MssEEV/uwkrYWCr3OujhdDn5eJOMnjfLZfO1WrLbIC6rrOQ75DXPYysyxW4MhEdueDc9G3sT8zuP/07Pu6l0tgFc9mdmicHWNIcHmXv+4MHO2RAg6OAygJy1GhHurSh6pl/VuhYRZ2QenKeYTxAD1tfPkCdoSfI/lESkUmW/0rdLtT17KVUcBySbe7drC170NWONbbQJau0KYzR6BzJqfot3GnqWocJf8Yq1McjBSqa6kp3K29Oqfip8bY5LVRbq2M2d51HfOwNIdDwCzjoUhqggyBonfiqZmlplHMmdpgn1IZht2GZU1MaH8FjZ2+0sd2Y2UMt6LKBXQHP84dyUfFbcquO833HxaIFST+Ix0MC/a5qIauSCVHB0cPee51hyE0yqRUIKfBiJS227SMScv93ISgAIBUctOS5RoXEGPNo/yNarEeRh0G5NI15YQJ8jsw5jz/RxaCkEhHRqlnMyaL+hiCkz83Go4nsXXWn99TnNyBm5i/8GI8BDu/kN8QpXQ4zD6LtKtZx8ms9ntp7FZpnm+4BH6AcuwrgMtbdX4V6bBWBCjRL4H6EUO+yXD2xpfWX/vOlBv2ksCOL+4jRsgma6wExzVeqh5EYUm4o+fYYy/9ibUyrecCkuQYP1I3iI9qFmRoiBrjehcygUUnLz5GeNfFdka+gWVPtC5+jr2OMlpFWB90Q5j8dV1I+nFqOfnZCrOwBjeS2/hke+/ALIplevsmXmaBXqvcNaicaGMgEMFJms4ujcUcTJVXJ5UfjZUpPgIh5DDt+DXCvYW6sgHfwHUIOAXgQySFgFMZyXs6fNci7hiQLrfTAwWqqRjl9bc/koEmGcauuOJrdqXi6AHKVWm7emY+3ElCI7xAvIwMd4dt9UbvIN0cCN0D96uTM6zlFirL6H0EG0xNr6DH+LlVWKK5WJnMflfq1OrYlBrjW7H12S313+p1iMlL1OQiiOUXLekjNs7+S2CK09keyYZ8U86I/2wQ9+uaI18YRm6QiuRp6RyoYf0AqP+cSie7Me/Rrx2ERcHog7++u2SDdXoFxRzU1Iz+tTKlw+A0vtRQYZr//pKgNu2lCPLoEvZApuclontqXSJVsYYMxtWoWOM67iB1ZjWTXcTJQVazv297PXOd/VqBafe7IQQ2bt0dDcodecDr50rbGQm8HpVMdvjoFgPwAPZkSz+yyQsFKanITv+oi2cYW/FHlb+kbyvgDKZ9uuTpNdi8ad9NJwnqGTRH5CPK0i65er30+xAVMPBME23o+DfWzgG40ErI/sBX7JiodTcR4Nk5BgnoEN201srpTn395hnLgrNV15EUv1okiS5kV+oIXDUFdA+K5Vq3aj6muLI+xmOjyR1DUru9MIB2IAEBh107gtUripoAYenfNvYzoqvq0F30FaITOh+1In4+1EgPKBRbOW6K6DzK877yLJjT5A62GckUiZqCuZXFKt3XFB7xCMfWxPx6lksevfkA5Zu2fP6mPaQkvDYz3A285LUFBUIQpOqceJzwwFho0qnmbVtFnOBi8xz4zL6Ezxxnx0l2T6Soz9tViKQyPYjYhJBWoccqyUhlHBxLZ7+AAgYQwCyUUTEsWE6qoo+aFSJN4x4wR1ac77P61O5Z8Wi6IrhzwMJTgIqG5gs/YrnwlBIrcOnA6ERwXkp6cvtiR2PD2nfNKXG93z8HVqmwj7HmbeLrB7rcJJY4meHpO0KoujjM+fOzaSmNCia7iuqT6vGBENxaD2BjIJTv0wj7HCHjcWCtq58UgsDUdhQqgAO9F64pE2mZbWNFGY+hfl9BC4+QlxBG8tdu0e7eg7r51EdN08fqbpizHVyxM41RFf1vrAFTreUMy587npTFWylpAR7mcgFAMXMlNpF46cJPuvP/K3TSu9Dvyv7gqFGvk8I8iIL/PMrC+heTFxxTqagdXMRtFeJirfzuTmUHSFtt/34rza/oIBheOJTKvzHhgU4xN4OVz6mhKMVGJG4GBCHhKRmuOOPDsd5+IzkBNgjIiwvrZHVIdbyWGfZIyqQbaHmg3aqcU0DOm7PtmqMN+dJLFPRiqkIZcEJhMN/jsuHQdQRZLQ6a8N1PqnqpPPQzAbCgYQ13n1x578Ci5zxaSPodPNf5lyc4powXIvYPcsFazrzwRmv5g1VtH2NzzLMUll+fMCmHDZfqT62Nr3OZhR/FfQHZcZ0ZoihnxpbfXjq+jQscHQAuxD+Q+q7HKUs0x4M5m5luxbYCxUL+L8JcNM8JeMiudEKMym0ZR7LRB0bruRZqzwkymCecSurDAJOEDFrlw1/kPAThYMclCkTKlCY3/26QV0cKlXJlfD6jV4tuhqXISDsNHpbnvlGpvhvmbW314Um6JGRUd7mh+Wtpu+VQ3jBSDaYJ4KS47cm+ehHderCFuPU4e+8VA7Tg7UR2KybTWnRI9kIkd7iizYKsX/ofIepYzj62sKPl4mxobTooeX3/Gv/oWjKvnkGmxgpRb5CWiaAgYKcr66oobIarzIa9Xy6tPIaZcxg2yCfO4dl6wACqBgW5b6vrptK3E6dQbM3RqFW0NkmeO4wm/r6+MzUthvdb7xF4oZ1/plTY+jqDsezvoLEfkp5YdoylNUKGDnhIukSPQZlQnxSfVx0FlD7QuazbihXaCIfeOcOLwEvKSH9vRDRDxtzQ0VF6ju/EuXstKAO1PDLtZ1gZFZJi24VycJ2/l4sI04orZ1wyf2Z6tFLA/61tCNcNa+J4YaeNwfI3wTOYGBkwd9QkffXznQkUg46jgb27l0PezVtwvNpSrz4WhQtJv2irQwR4YvSmYiMISmr+NG9PKNKGbb5Hr+2WL1v8KUiIqLWTBD5/XkW7S3+nKUrIShPO6hwnDZhEsqyLjgwlYZUsrAjd9vlA6Q9B9dhAKcU4YZINw+uw4EfBTOAZA+FDsxSzPWgUvHSMC6sK0xaKy6zmMDghKeXwO9U79W9vPPOz40DYLCKALgkzILZ/rxjfozKNTwHgZXpLEwCwmJByT9Om9xAEa6NPiGH3nJdzV4l/DRMyY/XtK6LwMrUEBhc+fa1cv+16t7Vwkmx6NcwIWNdscAhKkRDAdH8doR2Isycab6uLAKN9+zMhiUMnb66YBxSzegOvy+onhoRbCPfEF0WIFwurDVSROVLLnGm3NHSkdAlync1ORc5fs4QZult/vtgSoBVeqNnVczeusEXMsqLfAod6X+K8OkImg/g7NnPScfW2q6+5Ca8XvFxpirgxxH2hCbpVfBc5k3j9h2Y5l4MBM2/WaiKxX8D3Cb7rPBQl01cpR7/WtNyY7ofxwhjyrBwB9SV0swdc0MjsXSApYibtppp/R2Ff3O9slgTb8gtauUTmqQuuvi0yGcz5AwCba2A2rBmymq2d3UPOyT6OwfSp6hfUW+vmlwvDY6+p8fFEMuXBeO2TRaWQaDaMP1diIfwyZJV7d0oJ0/C2JIfSozbmxy0+1IlbeK94I9s4I5jjFqOsL08l7zSKbUN5e1t55IROK3SPWvC9twJeafdqGpck/k7GbiF4hVwG89q/hDY5Bk0Fmcx2HJjRDDKueIIuLTJRHqY6E1XqzORJ/uXVxc+5tAzYveuCL0eWC7CQC/mPyMeKVgGXzUpinJNnW9PMdNmZSuM1ZzS+80MfokmhQa2RI18vwCwJxnKZW9JPOb+Q9H+GAW+Yd8rDvzE6bO40iEewFzWgqCbu52ekvS3N4Qv5whaAvrvw/9N2NtbrZXLFlkbj7gRn0lUb4ON00Fxz5qpzlDktU0Xx/b9xncohI/vNqN3prU+FM+YNEhA6mXkIv9g8xOwSW0HQeupgMa1jO3fPFSnlJGQMXVKo11pFJlQxPtgFCFShramUjHt6zyBni8CZlk0q2El62dxGloEPQfWzBmjGtECe6NcJ+vGHmBqlx/5irvursHf9lTLmjyzX2oMd1ncrN2s/cmDpjnXumpIwoEsxIeP+OUQUUjJ1a9ICjzlZBZVpZ6e9ZitpYWvhv4JFVdihR9bAQEhQLatKa/FH2FWvJJ/HtVcMrCgl6LnMmzULwDFDJ4D/dwgL1PWuc+/PsTwDg9by/VmvbbTRbY5Be+dSaAzNmBf1C3LMDlB6LzIBri/TA8hd3/1I9Q15Tum/pTVLK7/gLRtVOGEJBSq2aOE05AMoUzcuGcnGS0XnGZNY5Eibd9GwnGoG6Tmm3f0bCGxsxwNHnE899u1PCkDsg6aMv5sAo3/MmnEhTkdTB8dLlmCb3MLYMImFpPFhM+slt2vi+v1uC0baQH/UByvxB75hzmJ17S8BxoZE8Mp3nqkU7vp0lzFD+KgOsb70Ylh8g4Rr9ixCQVXUWW4TDPu6Ze+7wIBZ2ruLwKO7jEQuACEoyO8Rhe58VMWoIIlzpt2zjuibeMJN0hltH02O7OkoaH/jY4eqEg5TDT+RqZ287gcNp+RgcsoIwRFc83xnvMt8FmB//YKmA1O99qcXmQ6kzwL7ea000qJQw85hI2oUU3xs4gSEOS8TaHiHJHPFHil1uGCqn0iyki7VZ0S0qAyY82QIYrHSXem6IZEKV1euWLkjE9O70vzEWINvCNXn1NR1mJu0/UjTTwskA6zYN2d4X8Xg0bAIiLkqMtDEb666HVV9R2J2nhkdmjx7oJZ8w+PfSnJUgPjsJflJ+bzSGvDf91Cd+Z+J6NmI2meF5oATdE6cdf876nBmlA4Rx9HzyPGrLJXYeP6khfMHQ8IPqogAwSjP0qfrRPVP+UtqYRKxpo2goK/7v75NP5QdMqmXKW4FiPyF8LBujUHYy5Bjj5wL35rYmSFI3B+3wILv2PRaRDEMkqiofspEtnHx5qIMWoVM2pHcMnzlQJ34QKxii0vY2m7IJvpfEi3wxTmHYJO2UQb8/fbNZgDJA8dsFdN9D9O4puLtmLc77vM1H30JmyDZbc5fJjpTjmN5xN5XAwJdrP1zAaQWgIh73gO5jzwqyfgSzl3lmrrmhZJAAZH0LpRyQ1Plxh79z1cJDcP0lfih6aAB56V/Kt3aoaxblr4TF1RJPhdvhmXU/GKSl/zwOwGajaj/9w6K5PDAyRAqGnHrZsor1mBVxk7p0R6oJ33MJYmwXpZDuc/cABJpGHjdq1y58FfrKNjxyNnwvmtbhwiJ54amFvKlYnj/00OiYrHPFNhQKyiLzUJEq0CS0GYQrYt8N3rRpry6kblsmxSt42RELK02sCnTz/zAt8Cb+j6mIX9A0ZjoFeRH4P5Un2qT8nhagynZixG52Qi9tucFL+Z6dQn9eikUNS2J386WWHBEtamdDg0XvTr7n/oUaE700PiYJ1bnjbvXStIO1OR3PFtD+Pu2g5H25yNUN8IC6mELVP8qieK6wVkv3brOTi9Zngx7I/R5Os2YF/thkewtNwij8F1H3QdA/dB3dAcI6K2MIfa6Q970KIpEc6Pybeer3NkFYUXPI3wa7Bo1jnybOdXFXeTy84uP+Eqk8+WfXKWBxjhV2AZ0TGZ+jBuOIk2GR/9BsCIszI3vFs53OoDUWXanQu+sjgV/UVMR2JOqhX2txvCdUTEG8NdpM9uFoxe1EBCWHbVIf9GOk3ZDKb0X7W8Dhf9uriOLdw2keCp1xSjOtMbSD2K14xRkbb6r+cmF41U2iKMFZ5QvNqpczODgEO0Nbu41QjX/9RvsEHR9FvvX2MbcPYnSMXgTBRr0vAMyvBgNJryV/CH/mTSIzhXRDDwaqc9ZhpuI6i/1hdLhoZjSuVfaKFQlO/7N0bTkrzaoxh8KWsLdHJEYAeiJDxtATzjX/46PP5KEdZ9+quhpTNHZ0qfuwB1BoifzEXrvyWYGRbxSfASFgmA3mYws1WeB7igmI7n9H5VoZt8cUTjT7VYkoMmQdY/h9YIb94H3BtaYW42UQITTkFZA11Tg77oev1G4Li87nFmM1n4p+g+bvquG+NZbYxwBxLH6nh/8TL4bH9riZtDe5TEUFzzYC8hPapoJbKtaTGOEnUKc6GCL4SvghUmGEzXeX07xWpzl39GXaTypNqS4WeLce35mp1ILbPFmdDovfiRQ2sosNAlksjZ4U384D2Nu63P+xseRqJtcgfm+YEGB6ZEqWexTRJTd57GmqCyBiqo9b1mPh5G8Bg3+hs7kHB5kuAkD6gWcFTkcKYGVIB/flXyMFkz/i8swcCB5aORjZObWKuNFG/u631beLYojghyaq2rYLpge1src3A5WlmSuxGTVY4MdTIS2qYfSKu/U+a8py+tabddnhClPSrCgXtxklaPy4B+vW+ZiEmxd6yNhsHbtqwqwtf36cBNxbuo1KLfRWZpTWd0PU7i69l0z9VMGxO9zC3X3wunx+FM6vBrGnfsZgA1H4/xgW5GjDi5JKob3s4hH5k4CuwVZSlR/dlfDfYpMVXFkqMIhMXc8BN7M5sSk3qYoYKgefc6TyRwsJqinWD7/1+q4NxRRHV5Pg5qwYJMmRAA3R9/Nu2UAERzMYLD4Ht17Nq8KbRqzYadeMJWSxHBU9kukNbOGngm+vajuwoWWOdNagFOkOBOav3vQLkgRVHmK6WL4OxJI9ZoDgIPc46kMrb47/IYyX3dz+2GVaGqQkCUhXzQ+sFRVjHBqnI60+lE9gB7DyJhq8bZBKcu4afWBEftLvH3txgwjKrpgHqFcnJ97CLqoidYufwIy+Wl4NZhuVsdRgZOaOdxOyvGDnWTxSpAM8NU182kc3B4nQav7+vkUHNqEykU2K5Pm9/pRFeSd4ZhE2byZbm8exWbRxuriFPYlTOqFPkeefIXVi7xQZM9zlBsxv0EoKDJ7zV7Ly1DmP/N8jLvQ75JIgp8Fx4qln26L5bs0wRUoJYnMYznsNuEL8xXUnCaYjESF0xKiqk3zQ2iZrImqixQWttUkJFzP+5TutjNM4csvSXe8Y7EKmyBfyjmB05uskht78+BFOgO+7FdrmMDFs1ZtNWB/KhTDR7r8mmkld0jAmjw7WxRy6zo7zgqOVICSJqT1aRpQkmbc+iKJDgZX8LqzQpjyO6kMnrGolLHZ4j2Jl9OJ5F12FjXKKGfMjMRWuNpjZkEW7gKgwbWRyT7dtYFLO0EeL03kR+akLjid1Vj6vuCC9FCir4K3nVhTLWXByJHJt0r6aKEC3g0tucTQftSLYkEN+7ay5d3FTlV8p4TFo0GpbsBeewBYXZ+u1Y5e6FeSaBpLGh1OgK/goU5sdr1jeYa/B+W4HpqY53vhwVBIwPBGnwNj3osi3oh8HeyyGOCtjhFIS8fHsjHMJ1lmfck4G1MeGlSZYSxxT9m+r+63IgcKS/H6dYlT7p/TYIWe7QqerFgbgZxujD7tGHlTrUWgT8bWFkK+sXpisRxxt47T/I4qPce8XS+kWPxFL+nMwRcNe3SMw4seHmkkglQS8Mlsztt7hQ/eZAA54miAZodXFiOIDwqK67B9FXfYlpDCJ/XYXfwDsZpt+4WulpUp3ZAjF4mJHePOxi4F8DN0PSk+S6eVjxd+U76CkAGi5I8AGK477OPLHdw9nTb2Zh4AFISdv7Yy85YnGF9cvRsjN4Dy8UIuMxIEr0DTsyjPdh7H4pfCWbQofZbXROpOyLNEO26fB5Uu4ux86n1zLIQUgb/lKAGN0O5Gu/G3Y6t8YI37vIhLNKu2LuBWpDxJ/VXjhx2j5ifekHeA9D/WIiuL7lrJDxTaJEFCXtJvt3K2kM2miCUPZ9SSbx9Hq1riHWpcKdP5P6Kw6q79WOdP0VAprhUCEQOFTjjT7Q784QMRgnNaKvCc2dKLNRyABG+XWWeiRcZUGhLqqOYskY8M3LfZ+IhxxaE9wAj3UteDHi8hgKXreQb+hImk5yVejxtladcNthQmnwe4dk5zHGB9AdjArHoPoHY8fGzfvPLAua/fnnUP2JdQtspAFENyPz/DMwESq/TqASgZ9bIzG/nse2PE+YkSg2Z8r1Z7nbPphr0rxEEEDNasaq2tT/zPIw/PUTYjV1UNNC12FEOcltRhObozE1OOaMrCXB/SciT5fqUoEJk5yWp6t2C4UyrM/wzW/zfSvkRQGMsLybnQLj1zMHhiTkKmFOYVFGHCRH+eAE+dDDsQbyYdRfkMUyqp7wyM8HoC24xlpAE/GWZ04US0qmRoTzlszaqTAtgQWF4lEQHOzRG1Lvv2rmk53SKzgyJxmeBXPQwLiBl92O/ETetBhewcnaGhSUt5rK4YPOCfeNPp8y37zVxjUGn12LVfdc9vQ3oDFATfRIify07RG5GGaXNpnIGH+bhfNGjsZoYyymIet7drdwTvCZr10rYwJ4YM43YCUnVhy0qAAa0Kn4YKNkXnTDsefWOyxsBrcue8M9QEvLmO67oUxduTP6xS44YLNX6gCBpzS4Sk+n8fUowQCiK2hTBzOWGmVcSSnskINDHHNam56kNEnEnreTqiebwKYb0Lrdb7VtGBkyZ4JkDXedC6niUrYxRmQWphpHWwxpZhibuWkVZB7Wawnd2lLDTa8uqJaUcAJJYCG5daDTKMGSof6AMPhTgm8q7C5QuzF5hWa1mxe4BLdXbqw77U9lfWMmQVZBF2ZemYHPTmb87V7IOvS4aFB4zwLIA6akMYr+GM95H9OBMLmfh3P7W0hc1nbahEjQhjugjGUSdrSVzlGjEf5Du4aOzjjmBvZEGXHEaPiQHPGM7rWawaEDwn+ehQRiRzZET/ulNfbQwmRW/G6OB/Q3BTWbZNyz8qXgh5KWhYr42ugOB+5xG8nrZ4K+qmLE9jehvwT0WBBoRoq3vlqh8J08BaFnEHmNRv1zumeg/8IN3T6v9mOXpqCdg5+4aRyP8Wz8db6MxFlj7unhTgGBjePK9cNBhtSkAbjkmf9cgPERpzZ/O86WnbnGGG9VuYpOGjIXE3KP+T9H74vn6ZZzU561aXm04EgvLhmCfWwNCSEiqOmNY+dDwokRYjJjw3mlFWG7d7NdZhKzIAHY6U0YyxxBAaFZtco+EuaeSPeK7I8787N8bc96Q2XV4k2jOv/MzUO5Swftt7n2YVXHG5rUAMTQ32UXegqR3Wc8eWQmAOJxpwH4tLldXL0wWkVdMxKYK0zkKblzjpfpUjYeTzBr2k53Ml2dbnEWZwW0H0LVU16CQaqtUryDhDMc4vRatyqxguOAwqMdYqIQZ0nUev4eepbR3kzOg9iwIQK17ziRMCMrYmJKKDtFFlIseflSCBeA/6cawJhbDbTPl5oONB9ICSZCSpUSdoPg+Ikm72Orn15hvozZSxZsV6jfyvZwcYLTT/U/r6w3yy1dr0/at9edpwMsMI0DHfmwnwwl9pdoAoejH5GK+Su0I8IOJPWrzivP8oO9TdBeugnxaMg04QM6+XJpo2d4taJTZ7IARO7amqWLMWpUdUgw7VWuXQWjsHOYPSIdDthHn8rxk1c0GaQkwcBRqvAdgqoVRB+Aui8PDK+V6Qejpj/T4mUsOzSwO1G83NpG3FBPiZRsnqv89BOAjCHVBKfetvmmM/W3yOOpSrQjnoxVZFmIn3CYdv9ewltbg1I6o8NcuPiiRPD9Sigl7AEEMotWAvAt7KM3UO3gbzjvT941o4mDD+FRTlaPE74uDjL/1+Y9YKzZUyp/QGXfSTmTY2C/G+BqsNo7GRDEBcgN4dhsqWYofoAxqfT3dap9lyiXx3YBkK/uePU4JxlKtfFlti8skVnZS8eL5kV3SBGDdBMC1zK4VG6cBPPcx+2bx3r02T9NpZc2QSoP02jFt8R4WzND7MDU63Qmi1MDCOXzBQcLdYjH1qTbmtxlSBB4NvjvP9FsG5UdIpaT9flPLk5VUOG2Rv4IDGddk3h5PJEz3XnigrEFn0GvRnSy27V6YDq/3Ifkj4qA2Rg1CB/Zkl3rE9HSO5XH+Y2cBlnVj1sH2To89Jz2sQVXhPdckHfDYsYqNCP3+EflGiqr/toUwkzx+FTzZE0Z+U9TqsmXfbUsKBuIqhUjcwfjBKv+eYFgFY8/RpFLJpLyftWSCUnIdqmcVrh2dD1Og/kpZ4+iIhcBxNQP0oiK9a1x01xbMKgZ53UibnjMvet5kQXTlEq0GdO8ybgi6ucNjlARDlFvxm98O5Onbo8/nwHkSaYUTi0Wuv1L6vWDPRepIkgO9uL3IfTdXfNMArO2ppGazI8cx9mZAkWXE1bc0pjQHi6pgnlDm5pHXd2K94OvRQ05m3S877+N2jDrUrvXWr0Q0RwpooyQAp0a2gvpCgWABU0L9a2z/fgRugXrjzg8FaStfoTU+qU8v9D+Bj2rXy059DkkLMQhrOhoXysYLfvmm1pSjz56QRL1q/+66lY1YwGh1st7kkuP34ilozPNLLZLqvEubvSEq2OPSvpUR23M5d0ecwGmNdpYRWlEiOUY+aecbYtPsVG4kX+pvovpcLTus7FtNOq/pku6g+GHs7GllaPJrrNlzy53dO8807XltWnYADr3w/oSDbUEBsJleM/jP4DyZg2/5K5vSuqj6qRbMRoImRCu699XdZvQKkXw0cwip/Fr9YBiii7Brd1/wt8FCi9q+u30FfFxvRbWJZKzhxVv2xGmJCG1ZHpLD4usOVP9hcC8XBnjYumlDoEbdgVIwNXfvKytPyadGObtYmKIZuDWr4a3AZEaKE2DcDogsCTY2CQ2O0aYfjfzoHQZQ6FZDMDwJfCbD38EEEGQ5WFVaNppZZwtb3fofPbXuW3+Gk/1d3+HiKVsRL+djQIuoAX7VeqDI6h2KuEnxwET2Dy/FcDcuWKWBJobPjUNad88/+C+L+CD22JSaZLA2voqmmWVBfCj51JxF53xYE9c+WtWH3PUEDxZbarxb/ElC3iAZ4l6fL+TmxFYHJujQH/3Cv62GkvgJAwAdvnJCaAcc08dznF8mNbtGYxDcS2z2JeFUZqZQgXWzZ6H8mR/VzKWu1UQpawYEPEYfgEUz8dr/mLE2agxzwMVqql/8DjJv1p9wbiR2jVEX2Ejb195rKGi+kzAPBJM4wE86fCpE/8cuavn64QCrjT3shTmvtQB2SSWo8FzXXRn5HZtZD+uhEd/TGhJKnuyTzDuW1ogya+sidFcFV48cnJVlVzqlB3WG6XOPWkdnaOp4C8/anGUqtS85Jdg7V4bEqxSDu9cBhBwal2bvuWeDr58FxpySPLSO1e7/Q1JdwTjGsZa5FoJOegKcVytsUWXxqFDxWxf+wWJu6EG5/pXGneiYKGPwGuhYzES4+R+dzU2IY8lbdc2uoOyjb4n5SR45GkRsWl2rvoFssagnnX3c/P5/D6UGjkVHShFPF29ot4912qs+qGhr9qJ/BAHYnE3RzonXod9XJKyrAXtitkbsdRQDmUfC/cy10YJ9798vTpjXFt4YaaI18oC5/6PnCvWCZ+s6jwsOqKNweVUNBSDHu3l/PmszIgQAn0pODR/3Qs/vmbZEUTvhoqZEP37utX8g0de8gXWz0Q2+lRW0lX2Rk/FcpKaDi4vrM6OlQlwpBIaPvatueHJEeaQUwPJDb1c3x7LdgErvHe9BkNQzUHslL7ABajtWczqR0k0zTZSzPTeWefoHYvMowxwCp4tmzz16t/H56IkwwE5igL+nJMc3enyNXqRDQZ15nYSfDTBMHFIqEbMLx/C0ROPlNo5ShMU/4gBgi+P3NB8KgAxb/ZBMrHS+5/aAdX5zLgQVpk2Kr5RJItCN3079MdKQiNquZ7k+qnfX9hdP+LMscETAlx1ti0eaad4NTotUge2AdRwFF8uM7wL4CPXg4GedUsl4wBGz7vwWR9ZLzlcrBO8FhgBR1ryyiEU/XfT9pRKu+1l34xtvbWdMnveRhtMshHg7wLedorCy+LUztEYT3P26xJv+oT+1EShAarhnKTL22M4TkFlp/NEqcQKtwx3GFE3aCiNX9oiqrXt9qhfS9ZWFZLzNe+E/DWHsH1Ys+stZJoeLdbA6LisxbwUYJxyYHYkGoMXopPX1jEmZnGrWCE1nER+f+ckM/uVIi2Hx52WVW9d+kNFu8RNu3Wkaqgeu6sTkrUmLITEzlx0VhKJdV13oxp+MWNN9CNfxmiYEKROiCIPDFqigRBMuDcIjvgN1Aww4S8iBVNcYaA2gpcFbO8B8Ks/fWHM5Iwg3AI2OvT8twf684FTokz77RDFCKus7kbG6KTsM9R8SvsMzMocQq7C9GMv4Rw+cXIJBVmPlyBjbzQxVoOiFmSymNAhmaPPCoPOF9OLG+/MWb1+3yt52DlWdPEWOae77wMWSw2q8khEKGEfm5mKnLJDF8iP40WQZI09nhKbwXPYIQwIASGANmwp/YUKzCQDmP/1zt3qpf52E2xbx+ksvx1GTgBk3tDiJLJaZvaMQorEAqA652Z++W5b5HjW3Dn4uF7mKbPfqQLFJV8paDZF7picXVEddQWB0tFLtXpUbEKppcfD6tz8Wgfarwv6QhZwr+BbK+9lIfnlNpJwmw3+2Ihy3vlt9EfjA6oxBct//7kJYqUt+fXkEhGKgBsEFW920a219AhndqkYMdPjoZXR2mkrjUmTFjuoQl5wVPsYiDRjHOIhh2ru7Jc5iUpW/MLQQFYGIl+l/LynVCFsekN0mVF7cxzM0yRBbLGbtg+UEcJkWCVsmWKHx6SoKbMe+gNPs56qG7RhtiNojRCH+kHw30GCIabDDcbR6Wk6JfnreU0x/sxHw/23GwhANPfXH2ucYeA6+rIJR0uVNNsC3vCRarFph+o5HRYm8eTfmZ+DRfX+Wv2CKckHbQ399fBO6EsHA1JfTdeuCvFhHpUCiwoy7yq2yRY9UY1IR0th2bawButaPCZh1SWgf3qT2oLqd661Hp7x5krWsOtveNnA/x+MwFnW0yqOidtfWYIXfEkabRR0nTPQ+XDaeHKZQO8bd/ZFjVd22bB8j7QzQjV1r5KMuBqWGRz58PQRSADqZBD8QIM6jJ+8hGvrr/BxmK3Drar2e3hEItLhZvVRs/nyQMYsVfx+kk6EgNDJh2/ycd9RykIUOCgbDyrWBN6pIjwcnUhghrO+J49lKqAYbgvIfupxZm/sBCJ5KhnBTvyQoHBzSwxp/jSPKPJsOF4zwkBOvEaKozonCJl4hlWdoyMRyJH2eIqYSqXVKQLdDYP9DxUqUNU+5Qc3MNijYKf9Lf+xgQcjF4263e9rHlUH6sfeXk39Opi/mr8xHr0vtHuHnIWBjwXz3otyn2BEWRorjt2l3CgY8rTGepO1ykUDm9IjbjBODaRzlrYwNLp5Uk0G0fqHio4z0KYWI5TMITvNCDv7qmGOfP2fNrmh7AO3iKNV/+2SNQL9L95YUsXNLdjGZTVTNM1WXACfT45LXJ3gkbNWN2zWwr+uyAHhUIon1J4itpDaRDYZxBW43bxZaVUMmKVeAO0l0tR0VWyZ+nnU1VcwqpR9C8nycmEbD7x/iChEtX7F5Wm+SE/6LtJARuGu9syDLRUJge3IagCB51q3qk10itjoAppf97P3Rq4DuhUK1G49mHPhagbuq6sSklYWNo7AbURIMZVymRSnbgIziUWj6w9SpSCBCN57bDpqWprtl1T1wRi2a2UdYwOhfegIXIJjCBTyjHQUFJdMy64cacWPFqg3PUXIxNamOxTGymWxlNsJ5+rIuuwE6gazjQAtfhlswXcZfQugOrXF2r7FYbTNzHi3etIzOm6apnydDzEK1fXPEbnnTbHr6TeGHYJPqdJfb1mm26aqlLrQUGyEAB8fTd4TYRuTZ8vDSB0zd3OWyhscqGmAGJJqiqkV3RBHzO7LNTmwEGoqQ+gaE7uUBehIcP8qYUEhBM4MTm9zGJBGy2/73tSHTxBnhBzPmd1y4ABND5nC6BDRSOSxNQ+ik0aFR0Qeqv95cZqZ/shBEqY67vDtvUo067mF/6h0BwRIG5oLQ5NZ1JXlh3LUMSq2xtiTYhzcqPLdE9KfPUnm+UoQeTJXubu4OwOTBXYS34QUi+zyeFO/qEVJi4ag6+M09OSP3EB2LoKS8E+K8PiiIQP6M8y212FTAcr4A+5ZbGZG+bp6/Arh3dxwkCLZvZ1RKFbNasiYWl+wroYyfQKR/yDyDYZ0VG6UpL+22jvjyoe2lRzgFNQtyW8NZyjx1yl2kBnis+q+H3Tf8wSXf5G8qvpS/iiJT9yxuJSlBzeYU9f1MXC4XUrAnNLRuOIFyVSi2PRiUcGe8NsciMN83hOkv85iWNsmRHBLNjV6iCTvnYG4vliU9+Hk+AX+zp3zPuqNabVkYNDEUliiDHPwHldTPZKUq0zZh1P0SSlZFsVCiDmqs53hnUcyhjj+KY4HLWohjENKJL0dYLxXGeuAL0apsjiVy/pYJmtckobo2exC+wa2Y67mHuHGOB1Ko30EkkupUxFHvKmA1ILxSBGVRUwn/Ezti2uNSEifj9Du33YMCr6OcwdrrGjsRLOr/JhlUMdSYir20BEIk2B5KLA9tsjGvKZBGZdXYO2xxew9Q9LIvTthkdbGyoqlnaXlp/D1Av7op5RFFLSAFk8Go7+M4+opEdxX7tmtTRN2mI2pmVc+lOjzf0CLPmdScRLvjJoi7N8Ggk84cvei9TpGQRq9Sjb1vzaZA0zaGcIRQMFBIqWVXW9YdmBdfQ1esnn1TrfHw8vFraohU11mS2xjzqEEjShv3YcCsQOxQtqz0Hvmf7h8IYdO0SRlbiKUzC+a1tezCpurUZUIJQfHQjWzeGKXSeC18JEtRYcyeXSW674Id0PCyz9XjOsBETmicGC/c6wCFHMdw6LE3GBGr2TvpjcfvWyxZApkSVYF/36UmSSt8GJFf7gg3EvsB7L95jTaBGcZrz/XWUqALdlkz79fbSruJCDzX+NSWuISXRT2YmgkP2b6R2o/7FjHHjAYHEzDe1v1I3IP/xjttiA9jDJn8xi2jvyr3zPLuNdl0ICg4DMMyVA3szACAch0pMZWXZ8l2m+a/hZB/0I+0NGFlkTbVIwcc/S5ootA+xgPTQV1Ae7yBWYX9WMVEGiqnbARjZJiG61JozRr3bbroyITkziSvqiNRf2PnDslexC8MFcCvV+sJy5LxqXZAqM6ezCEtIVNgFDQjSch9iQTzzcS0cpUCbeIL73ri+LOWNdW/D9g1iQd87/vw5LJNCCROOnUInKlxixi8gdillt1Y+adzXeEQLLweZeM2SOg4G7NAeMEuawLvSZ+Uz4nnO1CoNZvkvFOdTF01brfYJO0gEbBSxUNK1AQOWkPPGW8EPHG0Hmohw7/S8STAxyub2k8zoVrJHFb74p0E1gFIGVWkmXdHDT4FkPq9pqC60dyVXRNIGOTLesC7WxGRTzH0QR0J4Xv5syXh1XL9Dx6ASb6YPk1JPbgkXcCQQ0Wsnisa4YXtgS+hd6RDhQRBOq04qXwmRpTHYwBNHErlaMKbR+ZbqsYgnfF0Bx+DWnwY8+XaFnTSjk3uvioI85A3tYK5g8y1LkZpFvVERCxiuAk8d4+/87JoDBD/zDMYPkG7XH0/7Uu0rvBvmEhK1pwqgsH1tkqcqBVxrYJejVB2iObnEFgAQpWQpiPSMvJzhJkml+zl5xu+utDa4AgO/F5T/q+SVQ/bu4u7zfMlkLoJOPGVtsxy8WUQtxsgrzP8Z/Lx/ZcBfzt7QyKbIvJN+F3crALBWsnvfg5KU/M6yZlPIREgyaLp9huDo5GZVWK6KSFcT2bWP3JhVwqMOcWw3+s6cUofG0Uu+ZFqEhgb1K2zP6YVQb+LriDk7KiRgmnomB3FOLvPITrTbiQPGgOHF1kghSDjUmKU9aas0BF5/0w77aalR1Kb1Ba6hJoU4Reowm77x5/tbEaVRUdD88u1SXZCraAN9N3YQWBnnOM0SH7vaWCXSm02UJmk+Oi7Q5BOYse2kkKM3LsYdYyCeUpyiQJxgIxVjmTe3//b+QnbdJKViYe/1psoIbfjM7IBTTjU0pJ2v8oiI+q/FSiJ0W9VwDPxwDxkZyp8IQRoVWHEFhcv2zUS8zj7knyy/7mojvBK9r5NCb+nPfxLROQrfFd6AhWaLThmRo4WlzNih7PyPmZrMVC04BD8rCugQ/6yyJP/+yZGQfL9ph5HwvihF3muZvrUABkUjvcyaoH4nQYPqJOmX8naeFZRWeNr6KYTE7ce67Nzh3Dn77jQoZiqZXplOoFj5E6clGKCM6MBqD+htqrstmib0rqXtRtTyh+W1Cz/wQzCRxOLhb3BjEadzp3JNDEdVy0CwtZxB6kc/MEHwcIxCi62PYPp5sZozFEWPsa12+sW7ZgMYrlIHzAbj20AQ145+PSOfEhSMX2dFx3Lja+WvOTEStyiVB7X6spjrRxqraxnTlnoCTYY3VZkihzPHxKzcoFPCOXA7uVvysy/cbN2+6nsnoz7GNKloiGFGYH1v2+oWCEaKiNUL4/scQ4/D6r6aYeDiPeRZbVFoyVd26MQPOgAsIX0bEQ0pSvdo/ZzK6x+HPL8Liq8n981iZN3cRlL8015CzK/X7IFFUmVgXyIpS/tkiqeMOe8RT70iXCBPMuj5ScEnW9jvUZshqjxsodDNJQwXSIAHJGQFSMDaXpDLBiwYwWcjZN68SPWYaYuk9u0UWmKk4ARgKFxWu1QmkktlQ4U7S40x4XXJjpGUW6+wIPA5Z2J1gmYhfzFiz7ifwWsPqpyBlfw1y8oIy40a2QOm0WnYWI0DJygcLsjAaWpQxKjqodTH33HwMO9hu03itqzZX0dR6TuNS8/C+rOyekc3y8/A5f9xfMnjk5ghra3GjykvmnmS0Ng8UnU7vaUKsywOs9k8sHA0B8qKTEkniSt7AEEnVMDOuwe7ZS0pq4jwt5b7nMUUEmiPpY8Zu1qChKZTQ8vyZoo1Bx2bgXB0SvQI8LoQ64+L5FbR6xFLT2+5HdtdTfTc5u4QQKB1IZ7wXwqQWBP56ohCpB6Xp/yMfhBHxBpt7xIICH6c9IIcBINsn1KFBVpnaCpDSA3djN/3qG4o+Uxgja85+i/PJigmUSvJcnobDVGLxEyY6j/gfAEwetakEUgSIVwARcWCrH3C8RT4eVi1qqg1AAKqDV9WczytktuSc1iVAFtnUFrDT9kAPq+RbsZLRq5vLNUcujNN7mqfgA680NCYLGO8pli3Jh6TAsHFBcZSL7aKxSvN9gLp2sHZ4HhOgYuKwTSS35ppTmm77nH4x2yavkddx635JIdO1btrAWM029PEbMh5U1NUa2sKOMI621n32oi1OK3lyuTrzH7SQkY9Kz/Z9ThvzTw0XWUIonK97hgYuIMVF+GUouPSCSN2FFwE+8W8P74/G+Re9IcYiN/bZeQnwzUiGX7jv1J2ZmATJy6tWJZFdn+recQdz8R0bRBXNlXUeD3PaJyeGLCL7BYc2omomRIAHBPi/b4jzGrrk0mch0XvDKvoQIJ9oHQYQSXck/QsJLRLFLXb9QbmTRVP3sIzO4n11r+sZIQW1BZkKlmdhl5d4O4wGKQOQLIrXAUE5BR6aQqFqfNAGlzME6Nzi/yi51T46ft83dRCHL1TZgxVeCCAnOt+MwRCkPF5kmOdWdHdDP/gruDLocCa2/yugmL9sKwk9G5ATNAQlAaU9xSoSv+PU95TkWueLTBYsYCSe5F3yb5g6pjInePfqYEWhyOFacLmxrQhhpqpNU/MPB6puznys5uPJlP0jPlHqnVtZWAhvS/5OI5J/hFf/U7wz+AavHHML356smIOU3w/QW0hxCakwg4+6V/wyp9M+GGKCBNUEwlXoiRAacV0ghtOnsJllzDrZKQfLH5fpbksobFD+IsmA0ALUpoHav5krDZQCgV8unc9CUcG49i1KKJjGqLQSFHuq5zT9RM7wTbW2RlEToS8DIdQ6P391d+n5PQN/R8Dh4v0f/GuIWW1PTdZXDAlZUZumGF+cC3NNkp7Fefsv0CMRL24Dv60+tYwim/eQCJaIZJD13eInJzcprvvjdD+E92kpMd6EpXpnJ75XjaLiiGTE+1c6LTTj/36FsFGwdCA3OG1HBOxjVnO7XsEptKFvqmNdZF55/k1flo0OGGsPM1NCRJs0mh9nBc0daQXuW5AVaM+KTDxGDAWXKDquRyKJEpo3vlGNJPUKabb11dmUl64r+jzMEgXuKBbUqq8La0U8eXaG1sIUSv7firQAFT8idy4en7SC4CUGgcDa3QEBEQFERByS5jlzXLygocWFwlN8+bZ5gr0ekhWQqRrB+xelm0zeZYsOTsBDUCDbx9wpJvzKfnB8lyiPLg714kqopNBBizCRD3WLAYYA05+c325f+A6aoE/GHW7baLGePX9hpGybzoR9MXeCiZm1qHQUxXkgE1azEf5SWW4OHUQQZMhAzAVlrnwyKjsM30veLQZhGcMtB/Ii011nE2nKag00dTxSNZx8LkfJ48gR0Xa27GkJJUXfDg4voALGPMALlqK7hA/lbt3+wj/zyMNrIVZJ9IKhmBlwA/ywJIJ0NF4SeSsIm1y8F9/p2hkdoAknLM2Th/JKycryDdNlWCVNQpKdogt/k8nSAw8nDkggipJBESXMH+T1qKj+zUOTCH58sch3mdch3QGvl592uTzcbncPrBWTWeXM82LALX8dfUIDWu1pbAY2yYJaY5b5ZI4hlVn3Vg0m632R+o1fj66KYzv7awZD5XEpY7IDyiGzvexjLmxA6qVjGwjqNlZluGeoF2Bwtar9OV/RT/j3U42GFuEep6vgNwJJlQEA3mRgv7+qRhOhkXO0wgH7l6TKY2PvUy4cq3pouVth1cm2mekj9VVKEkRg8uGLapoj2ke3u4paT5AhgYN8boCEyofjUjptz9+RJ/KD1y/lG6utVVzTGEG+3kMi0V7Cy4nbrhjwWWUh7mMrSvF6VO3VAonYjRLLdkpsMi47S6/NG6tVrF+clTj2wFgow8W2a5Ven/Fz0zhafRl2nZiX+87g68Iq+wLs01EXtZdkxo6ptac0OxqZG8+clSlOwlLUEz1RjorJLYx7kaEM2j2bo4wX26yt+GbwRqWpUUnItIicv9BiSiHDHQAA2n9gnxrMXtX7oTx+DKL6AVl/EDkiGEnHs+Nm4mG9XlSscwLTiDwUPXb7kOnCIov3BnLs7XdHNRcnT4nyrByL4ApcAvkEIMaF1ND7zjTkPoFySCBvwrfQrhYfe7otmhXklfSfCnbPtrRHgwYeGItGVOis+Ml8BeHWUQQmMgVymN2+MYJ5PZVZtbSyYKRxfRScmO8S2HxVVdQf17uE4nKT4xuEPt9yyUmv54wDRxXIm7tbyu5v4YeoymhwA9+hBQpT1TVomInEBX8yXIFswYMV2oesY9QmmJirapSGKYZ2rRYfuh71utqVuNRcqIi7OzlqpXVb1uzWaWneJqbpnVGxjZKOoKVQgStMhmNsAY0xYkY1GnGC6kjZZmyc/x3U2yPcUJi+whFGJlb4EO+jiL8XmF9hduP8D3byOxTnpwK4m5d8Fy7/oFxdP/OF+H6015+UIFjte+HWNyWXBwZlifZvzKi+hLXKSsWQ73JGEa6U9hdsrU60WX7fxv97naznkR8nOBApTL4lGqFa4l9AGX/9K1TxaRDrtYnsQJtWiqgvrEaaiEBBdIdUFo8kIEontC7PW7DHHPfhLLPe0vm+Prazqkcefw9vLFNBM6xltt+UsTx89QAHPftM8H/gHuPc8YV2mhcvx6oS6MNuplxfd38msVJHqmNzuxZBSuTZ/fcn/jGFBgvuvP/LGl01JyCA6F4IZI/kRx81qqFAniVH/6rO0lWT81J8cjMDVUM8jfbtI0uHHDDtQaylci2C9qWdvVCBqlSH/PpkUPaXqIwIpqyLFGeINiOtVQkIWal9APNPNFADiuG1o9eu+Wv9jwE9sFvEPUV9Ri8oIK0BQLFgMteXVVGNGz4lBiIz5mWegCckIMCvKUs8C3heFdFmxI70laZgokbxIDIC60lsqD57WRCMEHcPF/kwXwSNZKBdLujJ9/btuACDfSs13mWGnvtIBww0oQKUoJepGycvBpJ1AjZ4TThfyxfxHL5Xp7bq/UZn1W619cr3TmaFhsvlK/LosOra6jrTYel29QrL+moRpOYLPPCw5wI5gS+uqP55OsRGBiGl0XkvWsixHRtE9cQq6RdTywTnjB95WO7JXx9pgnpUZIEFoM8Y08QzvnticSJKSoZqwODHWLbOhXuUju/5FXIqUOK2lQe7aQoLnAiuTwNLQJMgLlQZy+aZvEX1xUCXL1kgILi4adumW9t6AbO9KI4TPwN2AFlpCj/MBTIZykgTpMRFvOsRxlWt5RjodVR/b3b5RDusz4OlwA8ZkTOEprNc+SOQF3H4pukNQerAnYFEumXPzduZEv86yUzMFIyhs1yJko/udQfiFPzhQf7E7lz4UVUVBIccEhi74TJK01mCo9OFGLRX2x2MfQRGu5yHo0JwhcqqDl4gbLncWPJNLpqbEfDc2+9VsVK9TCO9AnyUw31fQBFx1lj94seeYBf+mWaxFUdRObdZeLNYG94b5zkrDvfVlP57n69fXpRzBOifziovEfPWAkPexGVtn7l/CK/x4NP9aaVEAgVUiQwCg2+KQp4BsREfyK8oh+D17RHQoF3aA+RagqOuX6r3f/0BGaqPvOZizRMQKiz5KNhfMm9bp67ZmPgSKV7z2bJdtGhI3zzDzJIas8FDFqzbt3v6qirV5pEzUvqk0kQQ8P76Se488XNmguv5LSddwCEVebTVQbk2TN36n/CXlJ/qq8e9KuIejSQCaRbuO32UiuhklG2E1dFsdKeMOHw1X7+DcnHAhdUzjb3HoK6BL7Dln5Dab+8D9/99lSWJMkqg1jl6PT0YrhzTiwCfgXRWtMRpjHTTqbjfKEkF86bS51v63ELxUoEgrWyPeQkIjyH50QrJvSPBFHDDtU02pKh9HckHBrd6PUFAnkxBTqET+OnboE4UXdU9rFW03zFLU37omxaxo4Jk73oSDQvMQadJm84OIWUHAggCAGDferB1s84ESKBHBhuRwf6GJ1XNS8fXZEGCWrC3uisvW2KzZ+Cb7adgbbG1LNQ642SrD0x3XAk9UM5TsUPIq3GKpBbuXEtLuYjCSA1day93K1fkrVorc7gJcA0EUh0ud8C25CUeTRaa/Lnhoz7knen6nr0luBje/F+aNUksZkeV6iezEq3RK5aJH0VvZ4LrtC/1Mqup2IOljrD9XlSDGVIwzzJUGRyNlAojCJHrDj6pIuSNQ+MgrX5mZaPQtxG3ptlDTlq6YtJJzdSYd+fZ2sG4+Yg7iuehf7wEwykFgdR5twDyATYHUQNNKK32HsTH7va0vr0ZOzLu1zje9pugoH2l6FcX109/snGPyVRJMV1MY2a7NV0vqSoGhq0MkVxe/SKoXeDbaZ/ecz0pbbOqC0rXX+s0wUFf13Yefoys56WcU/J22kSfw4LCP/4c7CMBKALcI5zYmR+slqpGYBw0sczmauSwj3xw898L7koOWKfgf+9fgjyZ1nPNLWNScOqcWAmh1bCQLNDcq/HFsjLj2BTUUeYQ5pfKmbyT+vVhMqjd3cBqoIbWsQxuizaUc/hYNFGtSac33w2+Hnp0IvJ0KzE28NzR+SbN3Jd9jlbYN1cdP6TB168vmXwthMuLNZ46pe+kcHC2ZiwdX4CWW/7kdYW8YRLznGuGC2DeYiNi1er1w/9erKqKq8YCNY4el2uOhta2JtseBxZfmJRq0755pbltSjEBYW1n6vgVf5IsXks7h3z66+EoF5tK1VuQUUiAUbQTK2TaASXnvhiPbg0Vj7SspFqGRg6LwYv0XrRNwXG8C5Fm1/c+1dP/xBc1ce489E4gODfrRl9f1Uqkl1X9xNeawbhN3J7dOg+n7FFkPP6jtY32S0XEw6t2yXRRCEMzKG7ZSoKwRZZAP+nl2UKSz8pv21EvJ+5zgXkLJgcQEOHKwwmnGSD9dP+1jiH2E/GyF12WeRjR+UBrT74MKXtZRXz+98Rp94Q+tQr7si09+922dMQbsFp8B9v/wtuN2yC7RYKjVUg4jLyISIIQUg9mYyx7TtS+LrDlf/zPmaFO6kFqwcxLL+I9sSWnKCh9pHkQdciYb/QAfkxmF5pBqdmpx67J+/tZ8E+vx/Eo9urBK3FI9COdnwK0ejbRaQBVjJB7JNGruZTJLT0Eedhs7l+wRBBOeXqPR2bjfgLkUuW7adETQxLL3qKp13V4kQwjz1gmhuLLpBulsfgR2tCDAJ1RA3mHa6JYzNypxWN4AxoRncantDQZW9cIgZdFh6BR6P8NnEs2K8B/fEb3GDWX4Pcr9/qHo4yDuiTXQDYxplRccoraxeXIYEQpwkIGvj0vxqlgJzX666SoNWgLYpWgjU5vmhFVlB2figrEwoQW5z4VRIidcybvTVsOznPMr4wXMXkbKCBfSJJu+pK3KWnMeJJMvPRsfiS1ho88612Kkf/xJm2kJcDNHLny1gKcHHxE3wy6lSsE/nV+5Y85B4JFhFGkOxoaA7qAm1Pz/m4o1odjvsFsNA/JjLJYyRn0MgJ2P6GhorAH/1y2yWg7eiDr1rl0hdt44UJBkcZMtKq9eOLRlWfO3DYWpvAz7fsykgs2o65oNCFVVWjIEs2ovbAgA35PAwEEDd3SKx6/8v9jlx3y38UHQDu+EHlhkMERg9cOWSkVSwf3zj+evdGAHou8KN4+c7sdwDv/mo6zynOAaDAbHWMgBiIFEBRTxtRaZeo1pWWMTG4NCKZ2t902gDSpEMn+jBcm/UK3HhX75aTvJUUltjN0Yh/QJUVHwgvVhw45OyKvIIa5/g9aBXYAKF5VVUqH/U4tn3WQx8J15FKgDGNWcznURxViOvJztG0aHc8yiRcWTQN6Qb6CzUnFxReGkEn6u+Sna043GnwVIUcu0V+cSDJK62UWEOIeEpuzULTGeUnBJY1r2D/huA1whmKebXkpJggXZhspAUA99ETsb/XlotDi01xjXLyR/svpxEva7+fQ4FyGj0aJGvDT214Lvd5Qm8JstIoDBKtpKlU625CNdTamy2Msdt8GC+ZPFjYB1u4jj+iPDiCT6WvLcZ7NLUOwyx9p4JZqByl5iD4v514aEwEQhvdYal+mXSb1GNoYO4VsYXoh2wUFzwwXN/Kitxoywwd6FPFimlBjAAykRdKl1bLPmmZs2GdR8wDGdqLilGJRnk5zKqfxDaTH+62iVBVmj7opAzwon9hSNeXavbAvoMYc3JNFfr/T469jA2Hc9/YhSIJum7Ud23TyPlgzlR2fqfyHbOVumL7WGx4b2aGO1b9EVh9vsDaqixPagmfgXndjq23WD6ogdMeoXXthnh8gYuTAhhzldc7yKQRo2+FxC8sl50Zg2Vkk4o2/16aHPOLSYV5iohQN4OxFtUCmfq0PMX4/LhTzhHBMaWfh8O4qGl/S+fFAtq7s9xcHT3F1cE5HKJSj7y6HpQmFc5W3eK9hVBobbTi3UmOeQtvRMYOH0YghujUahv79wbPNI9b4lPUVmUJyYWcVUUg5Uq3cUxD8ItIlaUmxWtmOiSOTXq9eo51shtDAjb/z0ajtjiy03YCPSAipukYsbXq78P7Y2fP4NqBay40AnVO5J0ep7IE/Ew6EQNlTMbGTJ/nVuqPkhcgy8IiKQRy+PL++g3PJsMV848QcFHEkwZtch8Ko3TnNyyKMW4KX2aXTyuiE3t9j++o0DCjyTh+5lBA4nw7M/k1LgfnidroS8rzoxguEzb4ix07mF4XuR4Lvyrjh4lFH64dFDGdX05vRPsWVMq9J14wjLv7dXU7YIaSiwp8d+QlCmfZaNU/soJoQIlFqVjqseS/0sv9VN2ne2OSGqqX81LPqPsfmehWAdjB/9CH4J1tu4WOVws20/z246SVIQ5RGvB+F7Xjefw1MqSwN1S5M5FVwwoivn5PSPJfiFYTeE1YLYQgpORLcswBGqCpL3qZZwClTXem+8XsYNtcy6ueRKRF/iXKKakpyLvw/NdsVSjVlQLFIgm5QUVsKZNe3Te1wvu2ibwkmcV3oy6z8mkE3CgQDz0cDmYbuOQNzqqS7517BpvdUZbD0wp6DzcjzVRnszcBzKmpSDN61cekRfLOPAms7APIGa6JQZ47FJ+rDMrwZTL4CY4CbVjjog+24/KGxGyogcvUrz879RL8IFIOeoQHTxVTwa+Z44K2aP08Y0AwoMYdnsBxb4UqR1a/STrizkiU77AQqcetlrfgymdv4TmcoOGvvhyuQgFck8pNUQ4S2cb7O0OZPNtazPP9idy3dg7j3L3GLEPFGo8Rwb+XBbjYL0micdo9xHxppaJOt+hrIvIX/7isQEySRylkGSjLJ2B9/LllHQNohyAx9WFKK3Q1pWyjlUssE3MdEtrcn6A3mN0VI+DnBRz5AEFW8Z4eS4Y+M+61fTeYfXfg4rMFCKKCr9dHC9zgRpHso4ATFInNSE3UvO/LNV8XNEySZEXfICDPaETp+SufM/okqNxiUOMPq6FSfkJmiJtGhnnobnE1SPyxxIysoJ2wan+xSuuQZqsEQuWQ96s4rpe8+hsxYwYlyfZSToHA0qC+1aciHI91flgmrsLa4LWAVm1Rg9I613jQEOipy1VYlWFk79tGSuulz+XYwkCsIsASEMW8cZnaPsPp2SR92cI3/G6H7P4tL38JHtNDis/yapJF0KTY2q99htNYry7oGSuip7EWA57HhU22UfcEXPnkNuq/HikyqcbTVW9jx9Z8cHpOkXR3gg49HSEJB0imsky5UgBRWckasKBlTFpFNw7f22ioPEc4PlVWHideviMavzGyE3ThiZfcYiVvKpa66L1eRbTeSYtlBUXR1oPA43iF580y6sWSyEzANb2FzohYNf2oLlVW9R/ZfvkRhyy/TQaSQTmITCGV2Qf6Vwafs7GR7gZkXwJJS9ZztfbYgflClCGMAordQbkE00+9ltNbGnNNP075NODlvVvDig/7LacueqasGMqSn24TSTISEm9UqhjwdFR/SrW/9xNDPUsTfFLnyh5t6CXHY9ysCYy9mGGPu+0nQzMIeb0g9RfdxDh21aaId1qDG0ejRwcO+iW6qxv8tc2ZEHVx9dVfkXBgqjGRjJmchPqZfwlVl2w3/pVqnwDbnES7Gbv/3N2K48UGb2JT6Q+AIF9Q1OIEIbXNt8epscvZH+2JF1L6/d9ofAAZaVuRwBkaqYOJo0F/Jl6fxYX07CW2CQmA4QgnvGPzSHnT7FVjcbMrXoj5vk+kgXdd6ScHYHxNx4MRJl96/1PKNe3F2Uvc8Z1CtTJuBsUZn/vqaXnCg57j3A8Dj/oQYaNdoJpXeO8yMnlOA6LXg56UIpQMb2kp55a6a85z5oqsiM9ahz4ZuxQqkB4GuvYu43HUyOTk3gO7I8ZAxxmVgENjOxpkzjjdTo1DM+kNW6tPbGpdFMr57Y1uF2E2plQPSsLSAH1QKtz3jYI8rFBbVWxIUI5napnItwTiiDuWOrVeq1Z+Pe1NbbdwncbhwJ6n/U/9HfjAmuzQkVdmDMS4dNDH0psnE8+BCDa/rrFBJeGwqF9uxxFke2+HAxxt+sq0QYuYYypQRRk9/AZgM5OdJAAs0eO/1h5xtI72dam3NHrSFvBcQcf2E4wLx6ByCgk3Q93I6fH9CtDrioIUJLF5iiqIGyeE4V3QcFipsQwqAZXTm8jrNvJb3nbZJzoMiyvcaaAQnE74eZvi+66V1GSOgTpn0CpllT8BsJlDa3Spo9raqDAsNCFhvAhPhuBOWFoL4AmTK1Hu4MHrI2ETcU77b3x6qj2TDYW8+Ahc+8+A7fgUMXmBc5Je0BCYBlFJS8BQi5YXzvOkAeve/+FFOn3il450IeCOdqzYBbn9N382SITHvJ7c64uOzCuU5rym3/mDVSoze/9Zs1nYUellwRXYgFaUn+yrQGnxfMqP7g5JnZcUawj62MvUg5WL/x+M8YF4d7iDByWdPoYsmR0MuO9rnRpZiBmO6sE7uSFsK7eKLNjqw2v4d1Cm3wYj+QmSS3plNpY4pU4ullTGrDFvgysFEpZYsc/UnH+wbt48aLbA6GJ44vVXcyN6zi+oLzUbd/5wOWGJxDXGChRlLaevr872h4OjFIoNnMoQSqmogNA9ssyc1gtAy7w7FMhyLYDwRyGEJXs5OvI+qdG24oyFxDTdQj5og+XDs8h59dv6HbmRNRXVr6BjJOu4Fyl3j6W4T0LC+e/zKHjBiBoUfI7bFC1F2KLb9qezZ0f2FrwcsiEl13e2pxrEIkMv8yQyY/bbTKrwZmCLWzOV/x9Z4pQD9apLSFBT8aJOsb107qhKI2r/PvDE4MRmX0+sevWH/o6pGjsPDsUZenYnVar3anss1AuhY6uqIsnIuIT8qoEfnuiYVJ7ju+A+8XrnQXej4lmch3buWcD9Tg/Tpf9yAaArPmbP4e1oyYT9n9l93TeuA3ONPB09tmTaZJWhYyBV35lYsRG4pYwOa8hRhTtjhA7qZ3NPakl2INUQrQ8NEno4MuDzor+lw69xBzHv+nMTwr5vxy3Z4NqTO8fGyBKHuMIWsOqulP4G8p5WsGQxMDSVj1d8MDByFwizrOOQJh/iJndYQAqL0s5eQKb8dsUxB1BVpAK4kNZXJfl6agTKKUGpl2C5f6gbbuNYLo129yWqxgaZbxtD7dbeAMQ2H0yFjtyQLw7Jqbzn17Q/7grcEKFN077kVS1EmFn8/8n9F9v6YIRalxzkouEDSoPVPDc+pIn1w9EZ+x96zHNmxECKWoz8DdYegdlbxoeWLJos850pAp8GqfXKWKe/i23MqCSFHAMgJvobp/1OgdOHEqyDXpIDHjOLSTvqSUC+rYZMSckg2Tt4d34JDP31YNhDjMLOoWPaD2KG+9b6k0u3eEjy9G/EWF2PTIl3OByZCT6jwu2jYHU4HNa8727r6rcB5HaCf2kcYo9CyC54azKP4U8ClVgR8YVuQJNL0/S5ARl93FWdcVnvCfZEn6HP3e+vtG1rNXrlDQSbSId+y+abyafpnKkO19uBxQBnO3cj37lHiRSrTjRLr6ujCSquv8S/cmASaLyOHITM2jYT8mIcuOZWhhNBxW+dTdfYwD1ar2NG9IvRsCQw+Z7pxd2Mydblg7vfp4QQ1hUKCfAPtlfGGBNjMfQyW1P26UXwC/S8Jsk47XZ7ud4UacY99ciakTJmarVTz3gY2uwTH57kgpYcIeT9G46Ow7+9LOs1gNPWAWETEifbn086CfATVCC8N80ii0thXDImmO/4IdoJ4C57lDod/1wXZOiBO86adbEZrh+0TCKu8tbRGUr/vZIcl4Jh0Dh3sNmbuolTXEXVZFZgN6YuBmQpuNe7mWXSoqKBHTyai2QP2p+Fg5FNQoo1aYyreW4crDpehx3m3t7HF61RNVk7r7J/3jVxT2tGAHY3fJKRYtPXLEmR+fwRNfTk457nzA+vqrntIvN2mPrk01agyKInxOf+rJenvw060TbXE5qna7IAmSQfr7pCegSQELg2fHizSu603BAs03xb9gIYwtwv0xX1V4UkB62LTFZyPnXTfBcCy+eyOFbiN1lFW5ptD/ezc8lRCuXrsfqLSJFVHr+Q3cJkYSnWeTDc3MYOtawIf/+iN8zy1/SVyHJftpRvZycCDTqHNJtzEIQpAR3fmL6FT/vHXmqFsFe/s1He3OKZSyPZhC/AuV4u62hf9fgZX2H0acH0v21Xxm0tOQWvrfJfHn7aovI7r6/Y31Y80aL+MMD1Aly2ydDdn2L5UcdB3wDBDl73afZVVbGpxn3Tl+bJtWkvSZgqUAwKzW0eDy2R/Pi8ZXgBQnvG8ZarOVzYqsRcRf7tk4kpn+bygaxsahZIfw36Shl1Zy0GINsTmzxNGmuMcnd/EQupdyIyvR/stfuGlPubzHHiTFhfXP3K0fflwvIhAZ9CYAHowFggtVdHYH4oaNsyu7b9jGmzEmau3HW/DLZKXghwyihDvs34gnWghfNro33z1/LjCiryuvMgeQRmhzANdK80q9OtDX/jE5LLTA5BpvJJU6XKwS74nahkzq2LYJ8QqU2F+seWp8aGz0l8OAjhSvgLxOm01SY+CEYPjsPHhcJnUaEd1jNq7FxMUdlmRpRMEKWJ6YNYyfxDA7cacEsG2R+lxB1Te1Htrebzw1SGw3rdu1f6a5reRQwypKyZy7MEsXyLl3gM+BUtFLsupIJw8o2KffeSEMcVczBgRKWHVdRCW19CA4oztSA4K5QtZKSZhf7YEGp2tNcF55RaLBaO+tVxieNBMEZaiIVdIg+mOX9VPrjffCDqPJs1jRrnIx6czmC0iHYtu0vNZaQjjA28KXTQ0pXTUc+pLNMY+YMIy8HifAqdo0D5m08jvSh+vr9HBkC7z6BPiytAF1O3KXLuB6gu+FO+DdDBviimzudGXzuD8PJHSZXZUrGtBI45SGrXid6lThRofUUquR0lTm7OYpdvSc0BdZ2eTk5LeNn10bpUAWU11w3A6KY5lWsaw7wlFnRQa//3qTLGe62aWl/DvKKgq2vjkEg/5kCuNMb7W+aoB2vKuUM/L5Ok2XX7HJRg/5Gf7a5uwTimFM/5R+mMcI/aHz4+6OJohzmf/zxggAI3GJHxDm5NhEo8lvH2k6KrwDQwQNgzjrGXb3mLNid2b29/mj24Cwl9NKxKWcH7gXsDPjcnzhIP6wSBqfbUbucKlYI1uF8KPcob20qDLs/TBMmQ/OUq+QQDDsn1ZhD3z7OsKTAAO2tggma5mc0mSTPdR7ZAEii0i45+pVQSSWkejBslrPnaoNMgOyDWJbHyVLaa/i5AzJHcSI+qK+TlHmgXnzNPAO6WffQf2Y0kULbLYsUaML1HvjOMnElVmvLC/f+6EwYEbrL1R/5Ne0DrCsG4nk13ivKJWKEQ/BQ3gOwkHtdWGz+Vf67uDmjQIKrnW4jURynPjSOZ1Lq1qXh/Vm0t3jlBfIauN5rboSGiq144wAhavJzWRG8YQOaUFIiG6q2ZwjZkIkoyWgS7t3PW4vXZGKMnuO2ryOlz8c1wDK1RLqv8b9XbXp8kVViku/gNCHqBS+Y3W7kdj+uhPUoU1d6EHfvOltMi6PwJhAjCI1ZImY/8Mpc0iLJ9AKnMWjvYAmBgeuHBaW2DEYQwomODBN8h1eW2iIKrdiQio/w+B4Lz8UQ4U/6u58mEGuLrUdfEYQuHMlOgea78S5LgjbgnSuBCghS8R5wtkptBdSE4fLYiIfabSRkPvLByymAlX9HmpssEbkL99ACLR0OwG6ybHp03XoZbCdvKfb+y3xNv+IeZAaxjqmBvrg9FqisMnQ9EH5gQlh6ZS4tGz676tWBqKlnlgK3y4h/CtuUQP9hcTtr/SFYZXO1kqCr59/t61W020iWlidGOOHxXPtg3tmTJXejhRdPipNCUM5lmnpQrgIAwlGjISs7KrOE46nN1mqfuo7OEKC2fdliPYczjQphMmd3Xy7JvCbEkKzu1COBYCVl/vg+z40lx11g3fiNH9YXfOevNWZR+bPKqfVus4vRlq6lIOUTutOOqtmE/4P8P82APuB3Xc6Er+jWwfaWw5wjVhlpToLw0HkFBbmFzjQTfaf0lnrk2WXSa8Vbl8GMzmdYjKQfP4PjaE4R7c5vaoWnG57grSqRYgZDTohUtpOpoc6sF93GHR/3tla56qNY8FU3pd6vIogbW5nsAedvC2NnhfbXpKXkJdejqElyQBDPMGPh5Zt+T0pKwOJ09UYyi+HIxqyVxehYQ+t5z+Aw7ePNvrMXR9uzfEYh9U/O5KG8roWIX95lYjYDAnlTO+H0OoXr34qQVn0Lsa0sUOM1wOR25UqeCj9UppiYLvq0A7/mnJ2u7FUBEcfQBSwDXrNcqgNy/eAeS3mFG2bsKrzVLsQ80ddNv4gqFVjfAZEr7v1xyKwSXKb2ii7bnY2ynW1oFfPDnId1kWdE1Re5rt6N94YRYc2N/Gxu6yRlh32tAVGbktuhUWgrAR/2rrOyECnzaCvkrdmSkZucQbnwBRNtyqJ+onbHOEers3QjV80yHFYtX69xPZnWLPc3mO2TdMwo+iX7BkEjT2n33iA8KrbZVUCILx2TBJcq2BGWT0QMzqj39vOeELJSxLbHQNgqmsGbmZ1MnMPTQlAxiJG2ADD10YuRCSmdzU2Z5lTibJgcY+IgeFFXuI7VDFSzDZII7Um7f9D5eZuhp2itcdbnrjN8goX8Vhrt87lFnllkH6uSoi5bDl4TPJiVnkF1phpYmzrXtET5EsD47AoL1flXRE+GnejUDDRbW3UzCdERB7evn0PQHFHECRrP0p5/4XJEG5UpHGdOge5zrzIcgyXyPmreCiPUWucq4/kvehGwdN+pvq8RFo07YKn+VinVX0HRxVZWbq290W5pWfA4UsPCM8YqtLRyVvS0eFJo7+pgq0SmKlRrosw9WwLj/ESlTtGkLvIV4TMQIuh03IVnBL4s/9yAyz3Eb4Ry68E0V0hbEC9oWkroc5Ilp/cIY/lxVElym/4czCCucMu+yieF4l3qnGzdp9cT0ZgN5hngzb8iCbnfEdJ87WOfA3+IlrIPbuZ6XcWJiIKa+xMZ3qGkKLqdUBQN7+xj9qPjoyJYJ+oxsDhiC4v8A/d7bG1U4UElYPUkKSs30phEZF2irx7Dw8aHgyZ61NW9oWSNUBcDc1mg5ac5iP1OujQ1Gv+iOlRv5HUE/aDCWBLIp8EOnXq0fbG5i3u+8NpmCINYpWAPoAW8+0Yx1VsMOsGYC4naGp9PlpE5qnbRKom6dbTBZlH18ZjY7o5rUNFjjca1PWo6p0Xo+Tzs9I7UQywDZwIxbBTuISu6loaVutwGUAxpmAQq8TDxfbQzJYV6ZB+GbncYsQwq+USpxo9jsitUnkq9tnUcBI3BfGv7kt1c457hlVGUJXT76Vn8CST2QgBW+IEuluACQlzmccXZybF7MS7L1eFvKwPUP26bHpyD4KWkJ+zQqDVawz4syiL02Gi0SY8982ybLnNmM2r1Vl9QAq+1t8SQa6NQsSyh7VeOWDcHGRhn9ZgrCi9111G9bPb6kcPUw8IReuCDIMKwct/djbIUc82v2rSRI4P4HcBO2HYvFswzEMUEuZPyMp8iaJ1AOTT7EFMrgZU30E6EGCL0THLMIPpWEOtsF2iMKfnkfUHO0FlTfvR7dMQrRVRY1QX4EC6u/Ej9qJga415ejX3kDn9RQQSZ/gq0EmeQ/KuQHSogtBJQCEsYHpqOwJsG0a3ra8Y3PvakDwkkVNmKpnS/fUllvEHECQa1KUvS4/MK/M7DK0EcT30vEB9WfD61X9xUkuH9JFJL+bOu6zrl48K0KpRsY+L4539uAtxKrJFCLG9D584s3OV3JOH7rCgu3yIj1k0pCRHRmBwkDVMvtpMQdjZvA3TTG/4h6AT2URTgLpCpe3lMhMU7OfuPXWX39gRPlpGOc/NHqMPfOpvygSnz5wpIVdOIHTtHVjTta47ygQO35JddRhunY8vjIeVD8qe/KwS1arsM3pnLvjHkB9W+EhC3HRnH+JmHH91IvIr1MV7rZmGrRrqEIojRb4vdeZc0bHk28e7Ep9zBdnMgdN1s2LGK0xEtDWU6bTYDbWxZYdI/VAkbsFqGhEShw59tCSChcrgSjU/BRytc6752QmVj1IAVvfqvBgXIWfOb1jHSHnFc9eWZXzDenTrdaOzGppgFPd2akYoOazwcLykBIes/7R9cz0igghj22jQrNjnPcSzXcVEgG4hk0J88bebsZEMDCJDT/DMIW7UTEP1gPA8bXo+xo+tac6I8LkqkMP1juQsgi9Il5xvWybpS4YHFL00LL9TSVLTyK4iXkSqAcXJUPxnoW2Xq+LuVK/kOktWNn8WQd1Wr24UqYhlzyHdq/qeis7wPbEBik/ROrXLvHefWpd4V+RwYQWVsEBeC1bu+54rnywz90KX2/IjtojjaAa0Zfthb70MG6EPkBtSR5YiG4G5ZJcjosz1LYSscMZNvEAy7j8pMKD6HRMK0lYqfCGgM42ERcZKUiWS5fcz4IGZdzeWWEe5UW3QOMNPsBLiLKt/ZHZ1sK8EHsLwL9iM1hBlttVSfTpX1NVXxs/TL15xddPAegkcDJv69yuBT49XPoiO/O5b4Y8Fkzh+wkv6Is8ecXP9E5CCZsGlHeLL0Z0Dp+JNOdfp06o19c3DkjDmn2zfSUrPGmGpGw6hRO29/lz4SdVDXeY5a3/+0uDmg6tmay1MCa8C9bXKXBAPACqSLelFiofHD8DZ2rnPgjPYZByZ6Sg9WLGkA1aLzrLEKQUyyaGyL+ROBP+ZNmxNoiV6Jg0OJI99GRT0vVv+WgVIs4vSirXUB9PFR3e1Do/aD7WNnYgazyagVZG0yH3P4xLnFDtJry6UQ3tnvp5Q7opwEpXHQqmQS+l6TLdB4LfJdAaJJ/gVOqAy8C3wBJ9a+z7ONyp3zlKcARl3RwhiWq3xk4VfTy6FnPeiGPc6ZvOV4bT5n2R+hKBHIh70X6L+rgED5GSuMBpRwYBB0cS3UDEax6qJjd/owOOsvevAD+Rw/w75Ml+/RqZw5IxnawjzSxmTZiDL1mVVAQfPFSWJkRWI6UphouHfWXyBfdFT2ShShbTvKDy2AZVFLIAGNKgpomRA5Vp3+he0LdZ7XmvQD7BclPN1NSlAGVem7n/OHyD8FmeBKrIswO7DE2/LqloSy0Qm35iOLI5syW7lrPz9d2QfpUBb0H+etxtUA9eJcllVsdsrH3+Rcm+cbUD3Jr2pOHsMuVnrXKcGL9//5iCutPGf8mea2rN8xwYFQ7S4uKAh5O+2U/kxgict3NSTDgjuXgUQ+lRYao9GCvjpGOvu2w9vT9QjfOgs779sG5oO90hR53XVXyJueuy2l5+7/CRKF+Y66pLetohwO2ebdBGBXQrhCetP1oe18RDYvICQ1e8kFSBK3PmzuOwepnNdbztYBazKnvRvp4RngS2XVwt2TaxJKWNrgbR4eJxStnZMOlnGsXCpnuPBrWyQ77vNbyEpOHg+KLhOy4rK09NVCf37+WuCQii/9W29lgPVP4+Y6d3leKAoMXLTbGG0e27IJzIcAaM0jSNnb0/F43L6glAW3cXtfhOevJyqi/T16mxRr0sLurb2uNNAZSjLAyF8jXXGFB3Xcaj0ON1Stf6+eKeuugU7iaCWhNhot8LCDn+fViEHPKPsNEJb8+KWkLBYpaz+4GL0beyf+ZgKvTw86clUUuVsH8aSiwqN8wOQ1zE+UX+3mFh0vLzd8n1pxZIRjb97g3F2ComZQQbT4rpVFhIzjYC7vMhtKq8TYfXR0/VjuWXA3mtwv/a88ZzLoyQgPNORnsM2F+ZzVjNK9YiDEIQdjP6XnWMX/BZ/Jy6Y64eB54ZPrGGw2JnGX9kz0kYD/PflCcQu6pFK4+U9L7UdXzA7hOMnh9BHgqETXPAJxskdqFaHlw2EFrccWVW13CkrbP2ur9vuB3NJofKonUVKMKwdIz+lDldk1Qr9mqQwWx+9pYu/lx8KErUrVigIP/9Mr9Wbu6lo/V7Mb1//P0I2M18Ipg7ybv++xZ3IGkklDjO5y9kjPv/kKo/HrCD28KaZ1xsrvh1LhN3AqRmZBtkk8YQocqZ8hwaI/UT9oOjdL8FnmOzd9/HLdpPDsyjU9uqZvHqJOQw5sVBYiZ/zVB/ADBRbPC5M+fSqiBQhX9HYIiFgoArrnbNnT2o2R0/jUZkXcAeV7Viwnk5H2YEnOmx+ikxsIre7mbqiirokkk4VzWGTjcV/wnQsybocsMtjkfOPlmhQ8zN/8No+kTrQRjpqLehx9N7b/Wyex/WYrsBL3DWVHYJVYpqIM/q2joHUNunUQj34ldEel66OXlfH9Om8ZBo3D7W/k6iW9pkCEbCJzcV9McBJd9MVHWrsGkzeny2HO+VXdWis49ChuvjGVnp2Aw3/IJtKZ4CB/bnjwn1V4AsD9JHe2QHQQGPxQoZOGtPolBNa5+iWu3A7y/t9HSRHqZkNFRbID1a97enNwAKm1uZ0WrbM3vn2M4JUcHeglBe9+ictEEXRlUpcApyakTeRR1gKdEa7g2IpL+HQ6BIC4nnYQayB3BVszsuc6LO3Qx8BgxMx1QZC+u9mzoQySBtRPfk9zxELKnesr2fFjDtPk5Z0M1+4nNfeP6y4uXmTMDdFNkbfYrEtn1XhGdTwVDUs6WLZC1TK3f3vUQiXcJZwydUQjvTtSb3W8wN7YzjiuTRVGr6hpTTrrkD+IUwLNqbUVGTqx2iuNfxccGlQt/s7zj9+GLOPRn+7o9pgdj7uaXKSwLpCUhcaR/lnW7EPI3sWKBorTDWWNxjTtxPC9PPQbMGHCAukHu2++JxVf4BfZbSAZdi7/BuLlbsgkUvXMlANAZiHvZusZBR28ppkdyUzL6qCFPlYo+VXfF9RMHme8rZkO53aKPvDX7KfWM6Ej9eCOP6I9B/9r3ZTh1uOpyAGqpvcq5p68goUH322Nq4vEar9MK9GIgE2frZFBcdNEBIFtMXQilTvTuaHScSN/FkRHPhIS28rnMLDBlArTr4VUWHAZKYdpHicn2SgSsayO/GzBul+CVXkGWNXUpRjbzYErz6CF/kGkTDKjrJPnDq/iZkBrFsgMYW2Sr6eLaI06EKmn+CCJNxLXqhbSSzCZBBgxqwmKWoxK51ewyjuMY/XV9yDIEuZV4c5DUYtUWiQsiupDppARQDdzd2yvmbj6F7nDkTimJOSXNxOQIKyQEKDqr3eP31TTxL/xRdsFbSw17TXTexCMRffkta1LZ2mKE2aBFk7FQO6Gc2B+tCcjrPEK91qiltykI5V5l8eETiRRs2sC+F1Gs4ZxQFKwAf9rpLqouDvrmHO72OCFa+ffyP/tDphF2SHghpi7y2I6C8BmXBT/9/Ha/hY5TfTc9dW7gABNnLV7zjelLE3fajpz8vqin7FVwZUoCbQecI0JnrXeGXDxrumdthYlbj68oS4hBgwscBoK+498qXmOIpvMrZ/USgFXPzMjMcY3ll494MPZ97U5FeUrilEUE0gRsE5p3U4oO3itAT5yE2dRSr6mj7Tw0x+UpQwsDKr+hx+kwL5BB4yDZE1CN7lUu7VyiKpnvuIqtXXoZbK1SgLxGkAsVrGMkr82r+TVXN4DGqjPi85gLO6SfusRGT8CHX2hXBKnCDI7wYEhmxGx5aAZCe3CtvldlNwo15dg9Qt5RfeYPeCHDHufHwDTuZrv38Ee89ZoUt5Kt/SiijiHq1+jZ5ql0717CnnhISk+02DrbnfhJPKfdHshpgDuGsMKttKWRGkfJIsQoxc8IxKeR7eFgs/yGOrKSftkqtSIKQUGRtD0UKXWk4L6iEVJGWc4X+p61zSFD2eA7H1ZjB9Z6X9hFcE6fo0TmhThs2fgpC/uqF3x6YRIwabek0Sz1oTlxF8ERklfIxBVtXm5y8o+Ti6HKIUMcJLe6NsBupxDyc/nlTqagasup4Xq5ocSstoIjWXRzgJJ6fxKsS56HSp/KacwEpb/DXH7t1nI4e3OT+zxFM0bdwG/FWV4xAwCL9dRVC4MYFLtNhi0aRe9sl9qEOFjUjeLMU/iFOCd+lhML9ENnZ1eHmm9m8TcykMt2q6PTfR1klxFGljgnllqr2g88q+wXiQyQu49KBj2iY8RnjnqanoGAH3XlgX5GmBPjF4uAYM1MDNkifDYV957Vu+28IFPC/zDqF8/3k1XNA/6WgsNPGQB34FUx3zFO4+YdSV3gjafrgtSWnFOXCYVhYHffGFwCItLEiAb9RYBl2DEEDrzxtaYvGOmgBtdOOFhaxalHETBKLpNYuyrREnmVhiMIwNbA/WQnpdPldT5Ygqmmf/mTM0T/7G68wt783tnKM8WqfL4v2ArI2jLxKtWbbrkQuQk7cprPqgYxe/p3FWA02pF0HhioYQoM2XW+t97Lcegv/420L3EKWCvzHcSxGVgAq0eMKCIuaKuui1qo7b3EHHn6zEsZDJuOWQCrlz/C8DdV4y6Q4GCRFHXcFMgM4djW/27V3MQY6zkK/Pru92F8eYf2juQQvnqdDNj24YauEbw1H/ZNnMgzB2+e6Wu1tyXOZXi/VXj+JHIZH7KX/fHgDix2aIR1V326eEzNmzg+H1Jjo2pqXgcF8gptGSHEQDWKH5PuDYEN/G6Ro5SMN0zuQGPR6yKm7iaHStIGUQFNx78NKt5SQuFpm14AgoTAnbR0Hsqo/c1D5Yk+H/pOaonYEDFE+gJoR4ugVvpJSjc+RvABABfnx4ouQRu/pMAmnD1UsLc/yjjw/jVCYt3+cW8AK+2CgHBle4JsKUAZQPy0j4G+wO+zCHQpZo/NnkHi4ko67oERgIlPT8FmgQPh0T2O1izLMSs3vaj/n6eFnAfYf3IgxdnWY0SIv5Te626hGco5Dqzi1JcHjrYtBqfRj0B04ZYKRu2k2cZgRACMn8gK1kDSK+rhaWj2b+eJigom4bF4Ygc2RTtJXCykW7Co2yIJ5IbGEeFw+SBFtli9/SEnveNMHb0pr121DdRgAWsyaekvIyIxGZtA1HJM2uxMyFRnu7xIOQ8KHNHDfQgOqGHjCc+PhKacUvT33SB9VvJYfWL/Si7o1fRd72VIKrA0RvQUkP2FOGE0n2BVq2Bzk5mFl+C+VhkE1QC2O6Wqmb6agwfJcCleCB2/d1zepb1G/sV3Lbwdti+Xn1TIHw91QDBVX2KjT5X2+FYIxWX2XbYyaIETexwA/xgpmOp/3mDApvC5fIaDHu9zlkUvtzYsSSVA6ln+7lulQLLw+PFBYnB5lR/ozdK24zzec/DUJiFY1Gu0BA4oGpY6TM9NEx96sPWjidLdfduJF88HGtAMeFBj11Po1KeX2S7LT6Nqg8GA3uKweK7kKLaw8ofLe22MZlYNpX3RlUZChQpBZnSGlfdffYKMAJtHTKM51VGHdZTBeLbySiDKuxzHs8yAYRJZaHu8/Rh4DYyJYQjRQLtw0Rnz0F6+MZlmitFXKDnlM8ILH6xg1VNUawFtkXHSybTDKnEzc2gtmzK1mabWWWKPGrEGjnx7A45zBG2Nj+gmMnjEbPRJ+KbB4ct3TSS5tTxeZlL1TtpRPXkRhICX8wyMYDlZlgQPlpmtqg2l8YCbcprDauJJUn/g/TnsC2X01wqDGmoh0PJRkNbSVelCt2yZVj3w+ju5sPQs58/aUxsO0YM4tZney/iOJa1CrI0Vla67J/I1x5+6d5G7GSEnLePTRgOLoxAx2QhVzthLrIkVMualBATQBM59yKCDVdfuMTykSTAQSAueKuwQr//EIeWb567yiOPxD16aQXxaoXeZCP8Pb2UhNXJ9DiFck740JK7fRFmpyLavi9NsDKCgA+BFC3AExMaB6kYhzGabVzqJqwRBlvcTBKPllL9htIH1J06PY+7YbgoEUP7S/rQ/rRu8o/KkhMCd/aEOwCthx3xTnqxNSfUuID5vTnmPtTThLA5SXGEO594b+wClKF0amqksNTI/rAO2Rnf0yPszlyeX2KspGuSRdsWHyEmdMP7cwAqnhTjPRQ1ZEoRy8QBO1H7YCru4IZsjNX9VqxmGd/Hi7bD7JLek/l6/HleGOMoNVcPaaUV9HOsSylVTHo0fOxQP+7TeeS1bTZIUNgNjXUK6egWwsCuJiGZ3GdmogENAzSpk0Nv1/hajS0wcJPQFdQls7509pcqVa/qTOs0sgJ9K3Ce8mTESsOAUyph0FF4FkortYyVesDF3PP0nrmOKo3Y4mknbdxKFLCDSRr4qnmMMhMVc0EOYANUQKfxlawE3ztZ1mloECLW52BXWeI7NlWgimL/c2BwyPYrwpHOy6SUgEJPAWIIl2srIJCx53xhS4fi6dRmI1EO+vqXLQGv811dmS8E+O7xrDJtJSbzPCw1xguYSnljYNXd2F1DdwbzA+11TpwFW+BbHyKcpx1c4DYOw1Y+OcuBDx+xpTKwDq/+BRNTO59ARVMp9WNin4HxDpRFuAt0tUa056Br48gIUMChcTlMDugKq75MaFD8130LNDJnhjXf8YFi74hJsA8uZd0To76nopX7Hlwaj4pQKzZ8RFlLPC18pGOOqLAtWmH3tPOM+7rROr6qI7ZhBZahKV52rdQnb2lBHH14OH5GC0cyUjJi18YbvNwOaOso9ioTgIR4bAIGrs0Thfn2gQ+irogRPLP1lJGqLVEbZQIX10z9LUDMQ9vdXrq0LzgFuYuPWJz8NSaCLifJrIiGUhqrbFmQbS81BrFG7ECx93UBpnOesGYim/XVlo/pcHnhIivLjZVDgZSctgD9McaLc7suBoB04EWWz0XCpMWSEUTbo5vbicGbW2CqhmUskpf1gACdRiO802ADFddmnGFk/t/TnHjctuxmkO/MKF6OXmPYaN5+6IfkmoSOTXiF8TzTtyWZ2b0u6t94UqeP1eLNHdXkpUGmuEjKaSCrOGzq4i4eLFegBb4rFpR2TCY/Ajp7J+ngm7nmqE7se+vWQOOuuLWSDc0tOwCixiw18GdjWQJjYaWOiF1NAT3PTuU01Yj17g7HZ6MUF2o4gBRWYEDi6o51l+yI/zyH4r/g6XOlEENhAWTiq7fmNPeHolxPQ+/J9RhKn4850fDu/ioBI4C+8Yh62llik2fn/0Mw+nh70ePaIeYyDvjZA7dEgVL9j+J2U71HkTGroBD21Kjh1RFUp7YaeSAZw4gJEgA+hpXtxh1fLS2jAeTzGIpDwnvT5xkfG/Hq7V0DbevBNKr0uJGvUaVeJKap8gNFc5wfaiKSUnjq8tdSKQPe7DKYv5IDfuhMfmqQbdlWii320fMxgVoYGOJdki+k5jeOIJNZkWhuic1gcpK/+XvnbJ3N2btbXaEglJJvxH1CRJCXZeglqZZjUf70wlxiDZpO8gNmkiOstWjQII9BCmiTLZ338QQil+nFqqzcLEMljw24izr08PZ6DSUSvmBd1GW28eLfRXmtKA9J1PIg9Fp/SLxP/kmb56jpSdolN8uVnRgOxC94gnPNf+lX6uDOdvYV7+FMJbZk29mjoBlndvB+52Hun8FCblEY6BmvBnTutyYNR2iVt1WhhE//Bx9bSKLCpr6XMAFSZH5A8C/1RSCrua/0asJ3OZ/ibJNaJKOs8cORpqCjI0N3vCvue6llpzE8Ys4w6hdFsfSmY4SEI1PuYvu98mNp8i51uHGmH9TWqvxvZbvdftcIaNmFPCRibr1mQpmzEeAKBUSLmtXvyq274BQGkayUvyF62Mk18TygONjog5Ps28a7gYzhKpa97FlzcvsyNfYcLeLI60+vk5TSwrH/G3R3MHM3cCxiIQufEFVhd1EUia5m3TQ7zZmaZKyvGjKamW0Tb//J37xRYIsm+ZPyhiGRkoKVMHaFkH8halDTa7A7gUMvwoBojkjiQVnVOhbQ18zcETJmuNEFa56OzmQFi4MNuEDoEV0IM+Q3ZOdb7Rz+6xXVjWtrZv43n5Mqd13zX03FvRtmT3WmOybRh0subxWdYW+yyshlI8jtMEgmrIoKnd1Tbouxl4ALTHGxnnWxCmn/PksVIX30tJBEoa2DU6Sp1EleSSKLKTpKitwwkWr93aEKZPZCsEnoCYuS11oaDcnXspoGLlzxEcaM2Fje6WTpSvmgu0fdRGJvdFCQqUKeXHabQ8EPSdzDhtD29udUOd2ptvff/Augoye2dKNksOQ8+KxeXJ9Vz6Tb1zMfJsO8MxJHJGF+Fd8Z/U/jbRA/NWU8D49HD5AUBJ0t7R0yXNvC+r6g63+oa/0YzfTfZAVgT8m/1YT3lPHDUQMmzI6J816dnWS81gnHXECg0edW9tzXPe3AuCe7hzcxUZb+u8SORR6+EaQ3PTTjMUwlLTWvwkpoH+4T+EFQuvUMHUVS5QkRgUKmCNs7C7kLiSUywgqZIPRQssnQxOafbpxkILMeNLWzgsbNKZpKxzH4MlLyl/dwmxMr7pfLpW3sGNicB0meZrdb1hUerEJ3PhbKpVShN9xN7fItYdUfSiBERp2JAmX2yXikY+4L2L3bhl8z+hhzoyoszKaZdT2OnQYKGvPt+OumOuyKAQlpIhTy4HHmwUshPS4NrSOQsiToiXMlwK9rUjWfnGQqYek1sji+wGedfjchuuNDpfEk5QgZcrIJhBDuihrYIMO64vpyuKYKa5Dg5TVmnC1jPFvA6DzpUGlMhlaAlBerbaOMdHW0Ce9gLfKT6LULdMACs8To2y0Yv7a8jUJJ+fvOPgeWyzDJWnP09xTPLO3yjNdSSO3OoIOHnb36DQxg06byfAKGjiCS4Mv7bwanTJ+QOjjnyQP9cTht7WrPI3lGcgan2QV2OTbi+lAezQTaDNDBg87PMp70x0+tYx7fYpgrOYhKjdVOT5PdB7IGrp8ilOYAGjAHXFNy9ESZPv3VUMpoNLvqatRfMZd6VHV0JuiNVqN5C2PHsvcJWbPUm5dH13KTGSEBCGAbK5Fgy4gxUDOkeewGRkcp4m42teWx6xe0oDZ5U/OT1Ru5w9iWLyYj6aD60NhM7UIYaRqPEP6YaqDiA0fu+FHP51d0fa8Gezcc+50NYIiLIZkQ7RahXzMW56JFfoTmsOykX+yaRx/FD6nJpwbzd2LtoGcg0rEtBxj+DeEDkfO2y5PIki7hYymg+QtF6K+r65Vv8X8NLqSFUJ2yfZouHQ3Uux7KqjkxmQ7LATtR1gbeOKZYTEvMJN0ZUjdTbfc7EkQf2v+xvEFy/EnD4wWwZvDqD70PHeeDD5NWz9ocK3HD2VwqJ8g8VkhEfETHTwzdZD+OohAxjECfyp69NeySfpLepi0ObyRCGUUTSEFWHf7whFaz0s3CJNHGhqnlYJelv8ptNw5TaxIDW/QFsUDixOnzvSIcfMTExvtLr3RB4rdB/yGPas8jCS0hYsQdQ1tfGX3+HAo52NOxItVkbBRQ5bi+E1JMCcXLd+2l7205TzsBaNWWtz1B0CtysOHAq8HRc02KlUSjRS57UT8ELWYngmzUY+gSF6HnJ61cira3gxa68izfdifp/YgSJEJqwwZg6TmqWhXSBJcfpXmHj0P/TMKahQOErlddrhmPzbThr/d+XN5JpeTAMNTV15yLZtQB3kkjnQZYrE10aOk5Qq7PxQ/nNun5TRyel5M/DrrZ70X7vIrMpaY7SLG4pV4oYoGGA7VEHiyqoyfeeE2YQWTvblsHb8oN5Z0TQ5LbCwrGTGOuGZb9eX25EmWyaLhBHP3tubhNiO8sAuSnQMUwZXiIBJ1/unHOWTs9/uuSg01fv4zai1C+x4K49c2zknxzjKXKGfPcrmvxHongJo/+/FEhovmNCWmoB+NAvNA4GQnsD0jh9OeFC6oNxaaEFneqDPf/HCrIgCUY9L7OaMVGnWFuGUHrXKL2Gh5yR9xfcZn0Z7j0QL6YrUgNK9vHaBV9XiNHL50llsmgiKa8ILnrr0qYQPwNMu0WwK6RpMqJD8bXQOA3BfyUNmXNLdexs9x97qSVrhmAZl2huqahAtHIL85eAy7nybdvPboVCYWqC/cgstNY6SN3tCYk/YiipSp/qiagXCFRvN6fSYyy8CcwSatJGhIIlJgJfqDSyDxHbI6Gz80llLnJ7Jl9cJGE+7BrC4+uwyFpJLsfYF2csz6NFO1wdL5FhqgAUlZW6pFlH+TVDc9F5PmoxO4V70gBdb3mDJKincQYukGHMGEbnB7GvNJ3HTnjExnRvnBhg3yCy+8j/60zwzQfFhzqvhoKnhpUbG1Oe17raaoHDRyP+yWjmf89J3gY+KbrSIZv4jznV5IlUf6ntVQEdkojcD93O9pjANB0eaHXgFhkOhM3z51FN0D6pQAL3iKXfpBg9lyIjnF1Sw3k2PYiCtfFJCn+IwNIleIhyet0Ewhkj6WHOBvQctI3bEB8ibbk9ca+zEX1IWfNCiKQ133K1gOVLd/PkCXhO6qtWA4Nu+fzECWUpceblfOLVMQHXtyQx9qrDIQ0Rklo49b7EmkKeMiPZZ4X/M4JTwTFOpoaVp8LYnBKi4NJInbrK1yx+Oe7gEd5qK68u8QBEK/Cr5tBz6ejJ80KclMa9oTjwuKpUXtm3N9em6cg8D8niYCc/gmcLeE3KJDDjbOvDN9KnXsR26GVfmZNMjSCHSrSxRuT8bCOvm8SlR488ZOownwwz0GVQ6B05KOfFykA4LZLSGk1agBLS98YfoOjsgcWldrzOdMS6TEp4iYuYtSVgiBT2sU2A78UaiAc0dopeCfGA0zO6yk2sua8w0YQRNxTFe0fLMYALkxMN6easL0nJ2lTgepgxWJGCl+RUVD6wjbSlD+jn7PL1NCbSGkyJQxDx3/C99V6NEWeQP9RoyqH7j5qvgx2JzqVuYh7gLx/ozy5YpzA1rxbO+xphc3Xxgdb2pR45t0PDWv1h2oLStqbgx0nFWTq+1Q9YZtHcTxgpD2zfZX+eah/ng1/V8Tt0/69k2ywh6f5cADN4qU1fZK1Bl3+qAPvbhHqwAmNf5QAIcvqUDeIRpaAGENlTarTwZoYv610LPdSz4wywfL8yr6Hh9rH0Bs9yE1jsYX5ER/5deH706yw6XBXIL1ZIX7yYI09H4ql3O/v4mUF+PspjthU4TkYoPv3rmyxf/8KEcWwqTVHOtBXmEb2QadHzMBCIOm2lQE4RMgjPnCOExyQEHrmp3BuhqIcRZDlbkUB/KtjjyelvKFw0upIfoz106lmdqy2R3ynaWD7Oe+l7JRK3ks/VpUjwWgUU7XX+A8FcWIBrE/IKPFYX5w5tuxGySFr1MPGfc6xYbsZm2lTn8UtwWZpHQi2cy6VfOltDu5NCQ+Hs190uJtTKPtcWUod6ATaSMnH1D7XX8L0UoK004M2ZuhW2x+N6KHYqHaaAllZuLfiBNGvllLkllReftvQjz9hN+5EAtDQwNRRPJQCzHomZz9U7mEmCQrjsy1epcVPbUg4FTdQkfh26LKK5h2f+kD2X75Y5QIWd4rzHUjUsS+/SJHOT7i/wEl+ws8jhpiBj1fr7wqN3IheQKptuHSpszm+J05fVQJ7r3SaOSHiPdehOPOQzkEf0eKbiHQIPycI+Mk8rWngRWY/lxieSQzzZF1yUaPaA0OehSy1jW4dTmkyrjx5JZWtylzDVI0BOZlicTtvP10xsVhIXaWzRbkZJMXjwv8VyQ0Ix+8Bcnuc3hZH/y6NnnkbzGDPi6JonnYFoGHWP6LdMZi/hWrD1E+ODxPVqbCtouGxym/AP7OU+qKtnqsk5auL6k4rnhIwhGhG66upZBF8ERDuA1G4XWvcslmd3ExGCrc85Kz/ODr4zATW1FIWmQRuT7BnKk2PW3FdnQhR0m33aMUH09dS+pTCTsk0Wb7omUITp7SIZjrEFXLbVHHR/jIt6ZIv0H3aw6EqROdYyrztE0GBZ49wyiNivhnW/nSrfQNk4C5H10uLQ8Gr8gy9rHDoX01v83u609dUK75lt+6/Q5LSekNqqSboSdRG7NSnndNzwM0w0+k6WWaCs/zQ7Nmv8FU+yAmtFYU3RFXsyOW5q/RslCFzgqiUWRA/6/CFajJpQQ9giXiebd83+lxaP2IQp7/PVHpWpXNTiGaddsSTtlMomq9NS+fvGfHULpARKseO6vtNGKHtg9Pl8g8igS1qZYyqohaHOMTfDkt0tiL8uNrafX3dKA7yuLKq99ndVZvwmhAfHPA8v4DzxVB/htFD2xqhX65jdHhSFY3jVV0cXyumHLZV5+Z3CIvF57stoUHr0FPJGHGk42i/KsxuWdeZWuVSKAUIHcpzdoRJa0chf58q8hNROovU68gtxaBTy4+MxpVKQXekEaHUplQ0kiNs1agZM0JOZ84TZocRIFIlqMmRdePaMm1rDRQwI82e7eplFVRTXu8z8X2FoaP2Cx6PqUBaUU6EIhHaEPTau8addacvDxiwJBBlKxBKWVpg+3tPZuD/RAlHPMZ6835pgjxjdBg/5UMXQXBVe3S9n+GS12L1gfdczkPkD5BhHlgz8NAuRw7voU7JDOC2+oN47C+U1emq160tK/WeCSsdhPp7mI8dlohz4mj+CSag4y89TXWzQeOTCIBS9CH9QzkfJIg1Qu823Z6sXOZ5QHGN6RAE/K8R/FJgxNV/xrS5D9QxJCJsrMVzJHVQ6lVfC6eoZAO7066b9KNKDqn77FLqx8x6EHjy1AXT4RwgE+VduIOQSbckj773P5c3/MCr27e0zgiljQ3G6HyNaC+fteae17r5rQrC0FamHGQtO8Vy3/XlHPxJyL9ZdQK6PHWVWFNP6A0lZbviiMppSpLgrqMOKneZ+PMWUqFYDc7U5GEpatI06sFD0zZ62Z5dYDR0S4g1VYH7FCUxxiis8WkYtcfVkhiM10HxoT6LKH8yPM07lfu8I79/BVjK1u4InGWMNx4TMj+ZZjEi0AVJLM1UYPIIA+jTvGSEehJrkl3sE9YP/y62wZIcItb6s00/dP/kizRrgRlzCG01wiGqf39k+rIbf78mqSfLXHW2cMn1JW5mmXn6WeqahvNxQGXZVdKhZosX5dqJyuPF3tWn8uohgQ4AXgj0lo/lfalNV6ll7c+wq2BFywsenT5EzbcqTKbpHUWXeIVcDojaHmu+CYWKghAKxIaG6Dr5dYRxb/cJF0p90O+wdGmSsVqti1KJ9+9NqQyVRiWudpNitF3niP3zT4vEs0ZZF2jKWb4pyn9eKPwNhZfIS5XeGfDnFe/0aAGxx10q3PCrFEdcIVhEeEoxC5s55NtbXCtOrXwK7OK73phWJrXO6Kx7DgXJscXzNUKs+/apjpxrXapLF9cBYb7k6P5G64Bg+L6q8Cruht9++bsplUcCClQVuPoiAnGbLsBINtl9+IgmXP2bHX8iB5bxeHUhK6xGS9dRgRlw0srBloqdlD6ol2pvup1cpviLqWQNW24Ia2SLWXT5lW4K5S93n5cGMeNp1mT1LrBuq5GIANLHwAlgXWOJDOlLSr61UA/J6+hhzmzY0Txb7u8RFwi1WzJTUT+iuwWiBelt28BenKr8ri+fHejoYVWZSVXcfMiNFFuBfu9xvVzgAttmvOZTrZB/TRoa1UAXU0bVV6SAWGP773D9sU7YcyhLslkwcUI6FixY5Db7Ty4IvwrtJOQxtpnmugh/zI5eiXZA22F+ZzQMkD54ynE7zKQIwEmizqM9rm3El6K8eQYKlRv6KuouK65vuZuNUoBxJMXYC/UjDfQ6USKHx8HWN048ky+civk/9WNajF0w61uFW9jSLmabw8nJYGLW3Enq453C3Cx9HUX3IJmBf6kUiYDx/kJjLO/m6sOMZx1YdxVJObJI9x+iESp1YtmCIm3WgAl6zVf25FVQZXNxHPjTmt6XChcI76QLoWcpBfElzDUCKxsMk/eMLzw2W7C1EKSUxddkXBp9YantOvDROHmJDY6Mgedmh0spWXnq11TnmEDyHReEoP8oAsaLGbJ3hKNig+DgZUOZ9brKCLE/3zzt9bM/Cw0P+s8VgmSmgP7ed2cBpdxQdUOaJm7Ea0v1C0+xDDsE4zm+mx8dxoNX/GgqS+vC0q+qMRzErMyoFshfjQG7SNGa+ynKSalMAeheQipEnlBAIZ2SPIbaUgFbVnwk7VGSHWbIUvzAN5Bpsyw5fQ43Z1k596HUMTW0l87Kz0o5kxbiNr5g5o9xDlUctaoZF6BjOPJK5quaRWEXNOJJf1ZXH7i5vdRJQ8922r/KeRuqfKc2ig8BTB7NYsb5B3H68hbEQy9XahDvB4hVcugDR2wgHBQxiyiwylPXacQLXFDb2ldx0bIBKTxrGv2lbIPMEJRjgEsrBHVhtpHDJ/CUd/gDWLI56OxzIkdSOKTdplcuqO7p8PDrRs8esv9EgxHlmW5U0MPju+FNaxwAVzeh6zU51r3FhnZXZXaf1SZN8wZ+StFUQ/6yY4dmwGWSqXsBUPAlYCsdOsNnJ8isbRbP8thHzxILRWRKwqJPqYpq2/c6Ma0us+Qh6TmZGnSVb5dPBXiml76mc5CALrzUahcdR16HX/IwR8UiVJR/77HSJw6iGOm/GwzdGSDRphw1q905AAE0sXRteGVVqs1xVDbCvbvk0rHy5zjk8Ow6Gteqi7fTR2c9h1fIgiVSKP2rfEnkklPZFoO/guq4XbyZ+5Yi8pqESQQ6isMAuF1MSoTEFkp++DyKwRIuXun7HfIE8inRs74FXNZAZCYfAHrByy8TYhDHDG6HkJFOfREK3U2JV0baY4+MzCU96qDM98lbEyvGbelUJLkbjq4cogu868odaT0BZKnuf50WTw1r4WXYZm50Y6oFl/v5ooniF8Hx6OYzx/SjllrkwpxyIhlSjPaPmrK8XcwxvVOPXn+YubJldHFPEDQrkxBTHpq2nPE9+WcvucZcYKrN88HM8A//SkRw2BQOgU7WWw1+1rva6lkqPPcJRU4hvBXxOEIKDk07etPpAOSWhy7v/ejfdBo4iXG1G6mkiwtW8VCKxurrZ1XesVHwjA6lLtVx3wvpWZa4/hXFWzFPq66sE8QSoyy+8PokQkoInpfgbXHwoxsZb5gf/rEyqJqU9Itv3wif7TuwUU66L8iLsd/MfyoC/k4ctKMNrNV2JpZz2BGKODOKVeAhR9XUrK/EADgVrjWdgJm14CyLmqwXd82pNRYFb+RIPVqf4xntI9lOkKyAJkxtILGHpKegtEZGx/p1a5CUTGm93lk0GDGOgOtXmeCl2IRvoHptAyxJ+i1T3W8knO8cpODBEXZZG5SEXQ418oem+fRXIECZ6ktskvFYaKRuAjGs9VgjTiKlOmm5kCaBYF3/hYT9yr+WIVHkGsTTxxV2tnLenRkcl4+NwFttC8jF+otm5rnS2dBVAhmDSlrF33Z180EjY0wSbeRv4VWV10TnAdXmIK9RYW6gKE11FXakltck5N4X/tcCCsgEjDEmf6lMQ0RrS7GsqVNn8rjWXylF2+6zb44OME/+k24uEga6NlFLiH+rK+0Bv634WUphym+hnrAtiHKwySxCAuSUwrwI/jgKcrDdolJSbYmWJwwGQflH/2BQ8N3ILUHi4+4+roVHKxpAPUXoXhn+Alf7icrSj/TvHP5LcFRt8tKEAznLJydRMbElrspEfmG6hIT1VG99XaR60UoNayKgm7F4pTFf/qylrqO4KN242wkbqBKKUSMODVpiqDIQ9PID0Gtl/ia38E7HgQEJf4lJKZ/+979d95HSUF+hNCffvZoV2SYWzlQnyROFDiXOFYuJfJUrX2ZUG8rfbj/OHChIu+rVOMlEcc5THLbSFFisaUJw5CG5glLMWXwpQ6TNHe82L3S826AbH644A3H6j825MG5Ym3t8jiTSn3uN6essPwRRHs0lt03V6N0TfZAaNDRT0hPwMb7SdhBk0c4xez5mh97liqEcogqFYwob6RO8NR59+irmLfNheBlCL7/PJWVUiP9JAVDgwsIQ5aoedUzPSMuhXC20GYOFaoT23jRCa5ZX8aAX9AKfzTvprxgT421kfyu8piAszP1Gcez2TyrwXFuGcd4NKA3JIsA5ZTen8qfZPTRmgnzRQtWbH4JSoEaHu63c1vucx9tPN07peOqvaYg5QMU8tinWZy/rtsMwX2wrwvaWFq4vP2QcFhOTfDB8dMyCUUFZhzn/WUmrFL3Hc6V+5pfSFblA3UsWdODZ8K72BI3KTF+lVnVAMPUB3DTWKh9C5MewQydMWoL+cV4LUxnc8O7II0CvpDZKjJ/DnR9K38Bojo7kBhJ2WuJ/AsHCV+gmIZHNcxTyLuy95IoQTEX7yy1TQWPpoUxlF3tNEZ4s5oTZMP98rRn0a8sfi/94v/LfLQTJMQ1kzuRzc/jJvx7WOrb0iRK9UUYQhWhq23MPBxC5Ul1kvRvOAUI28T/3QlW77ZusbgeB4VtyB3gHEc6hh6HyedkchbpfLzXfLs4n3giIq1Za5t80ddRtpJl6fcWAIrB+UXuvZ82T4anGBMV/9rLtUFQuQ7bbR+EAnYwcuj8JilG8zxja1yHJfnSLkhMwHucsldhvKQxDrUox0thZCKjBXNxzGaRkb2vsnwEI3hZ1efxrcwMh47+2R8+g+tJAq6+7BCsgtHVypYm9gHTnmeUW432+W5n9FjbpRbX5So83rMlsIAWpT08e4BSZDAD7dwcad7PdR/o94J2d6K90s0PPnc3fZNZTLhD/1u1r1xnjJkwtSfsEvuYsAyvZh7L4Fvl3g9+8gewX8BC0RtU1fWxoKbFbXpKFPMnKA48FVBvDm4/JPr86mLVdtL/9CRD4Qals0/KmdfhSRhY5+IJBk7wIBxhUj795C3zU0Sgi75NPCmm6wRMPxgAhp1YPGJCk+62E4LkquoS099YN4Tz5x+nFVoz369AViL4pN8eZyNT68miMOfCO5vEv0hThwx64Bk1leddOdYwuU6jL7XRECQSY5yw7aRbIa+F5qMQVEyiAZQlMxCLGDD/Kz4NokokKz3UvWJt4ltfJ6bN6sDWpXv8ADRDbXd/nnYBdWenfZuyqV1WitHfV0RlT8Jtfv93krn74IsASEvS15DNNCt/+Z/xwEdoGeaAHkYIUASnFweLTA9ANsF+70dM45hxb3qzuB1/LszzMOYiJx+/s3djrlUu9uDFOpZE0pR0TaG6UvklEmpyGav6ZsQ+ZX5eZDndKayL44fOtFRFHoeht4KE9T3KC0lkVpJokvQ0qoRSAlpc2ay4D4OS/C40N7KMEgTcsdFpN/aJlpKZ2lkVaRvjN0op9KXsyeiDMJlNDOCbwAAhM4sRf5K9LXF1V3vQH+D5XkyI80LF6jERB4FU5jj0fX+6Jy7wyLCdVVV3s6IDyVIbwKYBc7Se+yoRLPrgq1Du6s2d+pQfu2kiACNNAGE563V/8uMJtV8iK5S3XU2OT10qyC4yZjdKlKRteXeqa3vCmsq05lWKCltKClym9QFtrA97b2lQRwueGjdkrFJkJ93qyDDIOH8nLmkWA6a0JLa58Yw/GZorQ3Usqb4vh2cXBO7hc7jlsayjTMdB18QWOeMLlecYIWh6s6EmN0B/xa/iqmfIqI2357CP/0iH+o06dXG1jSb8CcN6rT69Ih93j4SjG54aMz0mbKRCWlbUaI9LGhW83tKbyrtrd0qXtMFcUFKzLtGuEwpDpnyvZSulSRA8syYpuRtB4HYwljwS3tM9yWxYoEgv/EkAR4xokhQ8kvewdmO5kvK890mI8yQUADqEeRHE4kRXsyOzCl5FLes0Jhx4ITSC4vt/oD6mlV4fpg//i+O0oNKRADqJzcuvDvhhjodFzbec/wWiLZfpK+s30xZ1yHpFkShlG/NhDma06ru1P6agbnyhQnB0vs3TS8PsAmYL+MW4H6O4EkMw+RbtsjPqoQ+1fuBwTP06aYQbL2PNhrz30Pvan2AgFMJM18+iy2WSZSsu6wRuO5q5WXym7J017fAm12oaHcrJkRh8606WCbZ8dmAQjJhNn2J9fK/mhJMBbYNveesX8KJ2/iMFoz+K0EiwIGqgyXHGwjJKIqUTtowDnowKyQGqPieaJl+aap48UFckYfsNnLnTCFYvY9Fw9UzFoVPFbF4UKLmp4mh5M3cRmJyLUu0VADjpSEie1/4Rm+7mYXMLhzKSwRW7Sf41otOX8Y9/g2XPQlx5xq7xNIoV2+k80zxmOPNHAhQA5gVoWeeS3nHM4rrscESIMrJWMo4DN0bKXPl7nOSrwBPeTktYD+QoLOvoMpwLHizIKvYEwVQ+QuJuN7BFzEfNDjizGhndpSUb0pHpTXA7Jg5BCyDsnL8w0G9dYPirEcb6Jwpo035XjVQnFkxbA7Sov+aLwT0xVHyYxGJa8shaAY08+cOl+Nub7nMK7JQhnJGUvUzU1bwrW2yH89sqNecNSrwr3IeEltAsAof6UPQy5BjDGg9VA/WgmIey8gyKMWN1bAReWgNC+K+Wdi278ycJNhwl5EXpik4wzuM7hrdzCRMV+n8mUVqcD2733wYhzZSQVjVCtM+L9Hba+gOALX8VJxDkjqfByuAckpvnDwqgQLgu8SQ13hTD0sfpNX5AJqnFIcwHDm3kgSA/Fp+4Soa2YpTpfihOku6ZpVmMZosdeKndCP5CQXqi5DG230rc8b8qswrum5h6Ow5ByQks2uMuvMdOzOi+WmkWUNvtXgOzH7qavI8quIQL8DYzZ825+v5tLnmj8XdjJKRJdivhHhEmv2e/7JUu2JUmYUJB/kPFHyfragLleDz4H+ev1B97AzZ0+icX0tfnfKhkaYhmEnzHOTYiK5/dZuL5W+8MHv5wcaLzUs/S/UPZWvLnfrswgaV4urzJoR3xk2afpIdPNFgwn8uJ9Qhl2GigbeCsv841i199wmRPz8NksKCyKU3OfQdpQxxFFANRKNic4aBGkDPR56aMb4UzMrEDe2ZmRfN+v0kPMbwg6LIeCcqaONSp1M/udScl28OIi2LDh76nEZaVrN0Tc6mN/cz9QRclSKKDtduv0aggCc4dKJM6jGbbRuB2uxaxiYKEQtbHaxHAJwcAfvi+wlGzXJFSeEM9nvwyCzjmF0kdZ+DKOJYzXipSVRMoWwK4EjoWDQjmvXrE+7B+3bvAqSkU236QzLk7ds2tYbvLqvK8OknmKbl1B4ypCxDmrb7jTJPpI4Al4M1P1niBubaV4bIswvi3oR7ogqSkjTEhdHFbcZIzQon3QajABNRJMKejPFB/+N3abHtLwj1SjSMQv58c+v6oBXZ6bO9MPXscD2e4+GsjTpy21zYUWmF0GlabU0V1Br9b2zueqkINqP1gTuQMXN5zgAfY2GT+VyrcDsOvdAP7wVISchkGa7Xh1OU6akgWs/0+aF2x6M/ima+JUOmAJQefc/ioGYmbNCTjcFm2YcNZWw1rAHNO1e62732ux2Ipv1yBc5+PwrEJ2ZXO7HN0wpn1o4Odt6WigLkiHv8M/cf06zYOQLMpKvuXEDwN/JVPCikf/CoGbh5aHwlIgCzh6H2fJZQNCOXuI5ljYSJoTTeIS3WscO0FmW3LsbkGHiwrl9thUGUAlxB6EhL5JogmjEu9L1AWXd8eMExzfl63AlTkiiUTwpd3LdUSAan38VDRZ5E53l1CmoyEM92RVLyep2RKNgML0JWDFYoSy88UaCwibY0HfB0rL2LIubnlqDKQGTSxV2CVgzJZAs4dgFuQ9fkhrevBcrl6phV1es7+NKq6Hbfw/OLFAGawNI6Q53FzO4ela7iqdSbzcw4XdOIUhtHDD2/R9UPth72pwW5OsSb2wHCkR+83wSDeDYGVMcyF8ojSqzR0U5UbUpN0wDqmHaIVYiEef/Kych6LqIA9qCVaoBRGhmjvOSejpp9XvIguwstTerJKY3VskLVVNOeKVxqXOJvojawZSD5luOJLoEsn98jisDJ+oR/emdqGcaViewZx/+CgNq8Rol/6ZVW+wvp7QaIOd4bJ3tOc4z9xt8RaGIOaYslPru9+oq2pFKNkSZJItjVY1M48ektZVcuJD9SjN8S5Jw/P0UiAF6Gp9NwLxsN95fuFi52KcM0R75cebtIXvUi5AWG82nxEvODZj6vFAPnD/Giqz9iwmYzgiP55gX3wHgWO1JKxjJlS8hVmqNl+SP4Uo/nnAqkp7ETcVlSWn9Jfn/lqv5XcCDKKte4+Wa68NCHbUt1eNI+xTRBtM4TKD3Govd7Dwq8Hg2NwTckYkAI9GpJzCqI70SBNavrH/m746jRURMItXDYzo5BHsl4BsBDJyO6xov3fA+3G64K7caPt/nWSi7jrMJnGwwiq7bqBmQzin+oBbvoZcafwhMj0l4nV2IiuR2dqwsk5HN4r1UhRd2KSPdgu5lrScqCf5No/le6SbT8noU0jq5X00ttg2yGl712U9vFuFzxrtDHs0hvF6OOGpCcLpOsRU0aeGGnJ7Z0VQPoVe1atBWbTpUDr7pYRo+1BRaPedym27noU7u+Qj5bz1dHh1sJuIZqe22tUW6fKCaXFBEcN6bRU/m/supyDHHgq3G6s6HqUjL4J2bY3wueiRxIwrI+M1J9OdtJtpt/w12+IAebPYUFr0Rs0KAqihuuE3SMlhL8ZRB3rO1B9kE4CKJ4Oc7RKACBr21xcicMX2hlOesK2q1hfnX/jOUKSlnhlsa0bhhZMZUdOpeH3uj2TmV+O/dRw+vj3BEezaD8yKuLsZqkIN7iVXjK/CINXp1JxpCOXZl6iWVHlVYsGlARK1yM+eRAx0DyCsUeg9mtI2Q8iEo0aHJFjOYyoFCiLDG81vBaAoGXnbHFwZWHxuj9iswb76y2QXMRiaBKCEeSKHc6j8bpS1G9Jf/cwcPFDKUN6bklhH+/uum5ZogpqMUlXDY6qUkfN3T4IS/mi2yDmahf44FbDhQ6TjUUqi8K76gSg6urUmvXZTgK2Wa6o1yQdf7d3Csl2X66g7/IIpMAQb+6qVoiThaDFjSJOHUpCVvaRH3ZiEhzGR4FbRT6AcZ12Jun3PcnfA1W1JmuIiQ9jq0uwDSJaBTVMZrjKzc1jj4zTUhLbelkUyJ1PAZPoQelENXaaqjdkpZNOXwUrVSNAQwY6EduN6kK1xpoHB9hucndjLFZeLbdIwABfttZlDkcbMqxlY3hDX5oGwTYHyxMl0oOqJOg9X3H59Zq+aLUrF8MtgNYnKnzXb555t+HBc5puf1Uq5FOORc1HwsWvKf/Q2Z6MIZMsyNkM8HFExdBBZZyyWsHFJgFUmGol6OAal0j5un+W320UYqJdwV4eMSsThYRjo81Lqz6jZ5yGKUEqEScyV80hpUT4bxvwFp7DY0FZ6PKNoRl61/qOI2oB0HwGUQRX7PzGaG3Grz7vBW63JBJp9Rr6+sQm7HJE1Kie9vCdEnz8NKLG+T/IWtdxh6iGk7HdoSxHQUmWjHzF5Q6Z9EM1ygqXlHq47ttlHrK2oMTcPZTWW5hSo+KEUDFgzUuUTswPE9rvUhvmJh05E2aAY57rekQDrP8u7Pnqi5IObMUIONPJ0NcvXfxvT9N6fRii/cYisX6DPal09CM8ffFNqPVCk4A+f+LmVvkRqKq/TnGwR2phTcRJVR+hih8aDfU2GqqWo/8+XWgI+AaGW0sPwFWER/MggcxbpeRC09rA2UL+aXGizK814TnkzEWEAFei1JBXlDUDrkycTxNTB54YJlbRuOEv7gu8msqO/bTyRp4C578LX66IcX3Wy5Yoh6Q4nVax6I0uEXIky76hB99LrbvDlU3QEgICXu8HLIxGFtA06BwCLvFINohSLrfIcOLR2w9/Lzt8h6G4QAs5wj974kKaVfqHWcWBL2jZNVxBkFXrBjHUH3dZcePtN1ZZUVqgdNTaFCSwEU05DnJ6rrQR0VvhK89DL5XLGtGFGfstAYo7nK2A049tUhK+mWoVGaF1ahj4wwwKwMviWdJCOVP6DyrubcSbRSCo6eyp2OQAcZaByN54tWe9KTIL69L5G53QyBg9c1GsSLe+aYc0+ne4Vyz6UrE9LDJZRexOnz8WBL6BERTJtbFpeyN50aaX2+poIsvkR4lOih28QKREs6XRmf3ht3e1evEQ4sFMtmZHIWNm+max/eKmQwQMLauSa6HCxPDgofuzwjxIBHK2I6fpxIT7EVg+tSYbZQIM3TeCmaylzuJQ/tGwfX0M+WTAjbYzMSq2hlAdYtxv0kJlG3vpEb1FRC1TRbUd+rLAoT7Fo4KaWzgj68Lo/yhk+JqiIdaOkpBKTC6yUZcPGhzNjh0Hs6nLJfdJHRR8q/Xp60R1ABDv3AttSxGmwl0lDTHnyqk8+ZLOorUtO/LySYdsy+NA7BNeQbN7W/7y6So8ImxFt8nePTPQ0e+rSni7UF+EuuYRXuQhkj4F0r4z6K53zyz7M25qPj9h7O9dP3gNEVnbyeIT2rnf4a86wFAqT/NqIxWNtZfrA3n1IAX7i+tA/pkeUfb5DqevbpBHl5sbhQWso+88k7Eyp3bsgbioCojr+UZcqH33AbP6GDWeZE6Fq3+VcdW5NIO2jgiFyP/VAcwqN6hK212hXQ72NM3vneOx1u1aF7x/kLyIqOYIyeWtX+Popp5VHSag1BIEaA/HCkZQyB7dhXNXFhOqhK3KuHYsdldPUsuDaf+1zhgaAW6uulTW+gQU6xEcYO6jCkJYYYLRt0BWReEuXgW+TsED9SQNN23I+taiUqFCFP1PxsG3ljFNziCSnsem/nerixR705vCZxYhZxuzs7Qws4gyG1oiHVRLhBfFTzMgdiGS5gvCClEkCt3CaRicDYE8KmpCW3ZqfVTh4YyLnIdx7aCAdmgetbgHv63DpPy44+dfR8QJH/ddfbnZc8SZTrvqV/9BpcADkvlq4OfterCuUcRUav0D+Zt+TwM5Zfb/okTw0OQgpV1DX6qmUT1OuTNI4oeJzIzLmLWNZqMLfDyJwtAhnI5VCLkQeqjFGlHqlwZ73T4omMWGOUCyrHaCwA1W3dTzL61ewNAiatGjNHWQQpMbdxAUX1n5tx9RyCiIbawR+61Dpu5WcZZ0e1lyO1g3f5sOEdh6eB8ukssRNsEjBnGcEu6T5yfdu/3SutLCYArs51jNC9/33LQ/ax+5z/NgbIYo0Qj2bmp40iBAKWAuhqMjC5NYcfcEJzSYe0cNE81tfN+z2XpGAZjMlMc/n/APPm977bdUkCvNhTO6Bo8n6QNV8EslNIf7qAu8JJNoNjz23y3fnPdGxPiJ1saHYADbGgdKxCoHyGXGjjSj+NyMTKWT0L7oxDEgeBnpuKK91J2IJwVG8mp3Se7vxVpVD9aJZIvwm71913G4vZHlWJfq+wH0YihoHB98l/CAxRqoTRFSvlTaJ4TIoQ3+I30zS6DTjwdb4LJSEo/OLWI4nTccMBTSJa/q1VevPZxQYxcpXEwcpl9Z1mXODABz7a7zdAVKNROMAbpbG5nmXwnz56rs3+Ok8PXDYP1WNBlnhjAjqNe46brFninSn1q0VdbG5b7s64iYic9IYQogAIHQqaO+wEDWILSOYKzYtBRYg6qEmeF36o2l7nuUk+PpRjXUdjk61FVMGsi20ldvTCDQ0WjN+fXuy/9f+WFxcoJzMbCTvxeKKjhzDTPEh0W4DBaDjfZN7+QesvX0f1Hv0EFw+ytB4qe0FIQDmHTVktgOpSnOSfOoP5l+cnj0s3UEtUQA1SYnDwNegEc62lZ7y+zqZWDWoFdk+9FjK39kH543oNX07QYPHJGnxAgGFcttUoIe4hzSMDedvsmx6vBsB+IU6WloFxfpGnci1B2mDieNY2mLH9+HvQWpjySfyP1HZZbGaR9u13WSogZRmyjeq+wM4m12GiDZYAixle7OXkeC1e/uFBeip+PhWMLeEFuMTyUPbtZtErRPFrcLZOMzNUr7pOy2Tml0H2DI8KAuIfagETyxxYqJZ6Uy9G5OxgQVT3vBOZz4q7dpW8YYKq+xLJxoI0DPlN8ALFSdn6vGG+QiGxxWKc/YW4QpZTupJ043qcCBU5LOCjD/0zDU+hYnFAbaomeo559E6ceOnnearrFL4gDN2UgnYQotO+VGgKgIuwEJ9vP8FYc9T1FDBQC/RJFKamIUhiIaZJVyqVCvHbyBZo5uhaWTaqVjc58XdNKFGKv+dsXJmFMwmyIBMPdgjhlfrbCWPQrOA7AY1rNpT5+w/3b2tIFdIBnjx4F+iX4ZR9/8jZNWWPIYsgr0l2WvCjFxTFv65nN7qLa7GjrbOjVUKado+fteOG8R/+kzPvTfh3//VJzGnhF3FDXV7RsivuViuPdGDXP/JaPmcMcdMDDjBDx7WxXCt0XnSDzKVcQUvfYOZlvqZ9LYZYUMAY/nhLTGHI2JJOiaYa0Q5jB225dkt2MUvaSMT/QIS9ONRDTOOxV88HVRUnCwevF3WxKZTzSPvYo03tIyVNFhqAxp23CR3IgZftzh9JJuDKOzxxGZdXyUgAVld86Nh0jReF8R2B44tVe3n4R2/aR892tac/sIbsKgRCXe1TnR7iX1Mmq5dRcjq+4rgYbb2/ID5DpugRUtk7uAn7TcIDp+ok5YHsKd/IlV/nAOK9sKdH00in8v6iCZFctpLr76nF3M79+5p4wtARRuOzEBSK75OsNk+mjIrZpiMxMGy59qRlZwRozB5y3O96YJ7MnzANVd9fdBD9jx5EcxnjdOFSSGkH0noMwzazrJq+zk/zusoVidBrZTDfkhVv0QvKuJwrMMnc0q/5/Bc8W0rC4L/04GlzUJE3nkWGtRy9aDXGzRXqBZZLsX1JRWavdJfFPcO04PW9g8jPHNVCsNTABiLXAsk91bM8iaGyjavNL/F2CLcIscZm+imiSpUcrnPQ+jwu76TdBgbOFwRR+cc0i74PL8nRIRbbuZpwHtEDB/T5bQ/1ixze7ciZ0WTd59AHlqHhNvy/eHN5NrJA4riC9OLiJm3e2dXxb+n5PB3Xlu21pXWJQSFKesWW11FmMIaXYMbxmWh2pNgTC1Ezdipf88sC7bI+/X2r1UTmycoVvnsjWNxQQ2rTJXal+ZzuH/KDIJsTJM/tg7VZzSCA2oFO0u23AjUZVGcP2kfVGxX/nkSj1S2bxQndyCk+DWqWXWqHWo74eoonWJUuRsDf0pen+/BhNVHa7MQZ2w1ybQT89UBJq0MKm+HSyHBhwVuH9Al6u6Q0icgBKB1fkR0fATNvBwi7dWwNEBuM+EyibBww9wwJ71+BHQAFlcA9YMrbeU9OgMOBPfXzzf6kLATquxlQFYC+Zv8osXYDQV0C2e2FwQNTcApH2R+wJG+/sOS64IYICqTxakASXF7Zv5JCt60iwspXmcKTmmzvfaqN1Nmp1e4t6E+qh0s1v16a2dCfn/vT498k6q5HcF1qsQdJS8qzcWqF91pTPJuoLbnd5E40OTIWx0mA063ZBKfRZmZ4EFoskHvbi7FgWmHMS+0qtDR3A8l4DIGgfM/onCW17alOnW+pp205ga7yR7IFEbFxxT0QVuk8oFUrxdk9DjgSNda6M3eFPwvKgmNZb/M27XDF00wC+mXbPtjgteQhQQWAlcv74x+cDRRxIcA2Qloa7rFIPFhwnvF4x0pRpzUZpHYRpEAq2hMpb3Xr6PoNothCCYts9GqUzx92txlC7rXbIPYXK1CSQJVb40/BtW+UxHu5dA+e6CGaVDIUOOUnCp+xATt2RilZR8/fa+2fH1iaPgt/CxCA8bezv5rNqZ+w7H0SqZ2U5a7ECoalcMr/9t4h7hkd4vy+vgl8L1DAQoNmVqe29vlTjeeESCuj3oOzgmoLFXDztk49L0jVMrAIIkyGUO/YXDBzPnKx0+OvhsoKVhUd9C2hFvXr4dDMmSt7paUB5C+dnQ6p7C1FyDtsstXnRNmwJYUtHEWpV98VkThaQZKcVEzOLMG7AwzNvcTg2J5MvjmG0qA8L1Bkv7bID6/jjXyZaDKilH8aVCrzV13hpeBSZDZN549EVJ0o1OudSOpljn85hlaJS2yR1sM29CFTjiQcgR0nttcYeDJvtzb59gdUtJmVEsM2hkUeBByratd5d+nlVSTZus8x4o5v9xfUFKKYtd0xkfSZNB+815fbGkekug5BzOfBh3FDRCFlE8btQeqvmvYbJGEJwCP+EgfSw+VxfnKWLT3OHyy3EPgW67Z1qmYRQMr6T3ya4hGMRrhQHR/h4KBP+HDUPJlyXdNe87qLfZ2KfRl+zGCX544czs0QYffzYn63qck5zcV1L7sWB4uwtLE6cx/59IppfF4zhJNX30rVBTr2lvPAa8Z7gv7KNF2b4ScPwLo4SOpJcTPYu3YD8xIr0zFltksgKCHQRV5ZEWMztloqpVirajrcY2dD5JMYybQ+3p1DU5RkoY4UCbOPX5IjZ9uEPr7a7j2VfusfB2/5MatV2K6aHyD1pizXRC6BnLbe3ZRGpHdgTGxOJSbJO+4FlFZIMPe2WzW9OrSz6ROqCpVaCbpZiEF7/EwIkyl3scYsNmR3QHJTmsANQdOcDimRJ3YL0F5Bf44AsoQVPILRFUukiGI7N4LZwe7utIkvtVwqk69OLmtaoJCAwAdwd+eC5gdqtavmC3gCUum1kzc6gGhaiII/HJSpEbbMo5LgAOmA6CqzEwtlCqRC1BrQd3EHIHbXFnnpNzfKSNrhgFhHhFDf4UGt2pH986sstccn4B103A2RLg06CvmRg8Sr39ww3D1GHTFdxHF5UfC9cZaIKmsWW4XfuSN9X+gibJPZ3U/fiJRBsBoYFb7qBFzh1Ne/sZNV+IITyhUHd8Am3Z67+05moZbAGBF3GJuB6bHyq8idpkgaRqsswep36wtdRxyq8KrAgs8ZCrKM4w9WncMNKI1DWhd5QXEd1Ctss+KXtsyk5c/g9eYpXozILD/p67SkxMLoCKXKcSfVt6qiNuissgqpnNOL/AP/AvK8PkSqhZuFBQ6tFhaQnR3rx7538riPJOtNpqHiZ0bXOW7MhBDYsfQTi0Du7Y29dUoOi89y40gJRqWWJhTcQQBkRwa+toJTB9qe13BJ7PPdvBOTKIVF/L9ASd/9lKZqdtyGOBksrR5irkhVmvMjPEnGCardGvnB5oKrXrKYP+VC0K6XYYHJrrYo2u4handAIj15pf3E6T4qUPOMfgSHGu26wCU3j0JdzxIbIFspHInpSOx4k9ykf4ozQ0sJZzeB0SsfvcLARl8AI67d/YiOs0NCZeU558Cwn/S7xREydPuCrWowP85+XANTcmOZo0a+3iNGuTzRVvt9gIopauVWaENCpip/d6FI39CNS9tcLojvQn1YdGyxMST9CfPMxQZSa0kFlBDPckT70KmbosNSlNGnuVOCtzKbAjdelv2FhxJLFLoX/WTTEx46aSvvFM9UAIGyvJIyonE1YztZSz7OLIY/oDi1/VTBjFeEo0ComQ6u1ToICnt33wXxlvijv18NQ/VfMhfgKLp5oL5xdZ7Kj5nf4KIisYnsGnQBX4a/VIZO+hGkxueb/Drws5W3LC0VRXmSZgFGGlTX7rMFVbr8eh5nRBbGKrABzRIK3/Oi0LanzQrEqFgg8E6BkJkFo6Z1hrN9wtWk/MguxyD4HKJN7bNDjpBx41ZAv4LpfbFyuNLFfMJLdQRd1UhfRrCJvHVhkvZzQPh+DQwhfam6AJwlyxSz/YjcjMBtY+QPtVE3xGLesCZbSscMe0pa7p6WMdTAZC2oJseLRBweU9j7YNpSaq+F2UdVQX83r9JtflSGjzLH+eVO505lBUpZn7uChml0a7+BgVnxpkPeOVRsZT3kGf6T/katS3FShkcXl5a/5eH/R3C+rwmWwqtFBf8gBgo4mFHOf/nTiiv7Cmhh2YSD8l9lJI15Ew1pETZYYsHI8jlzVGGrHpI1/bdrk3jzMNvdnfPgvIfFgCLOoYfT7JxiRkjq/qqbwd58jDJYzyezQMwLlYyQ7lp93WGxbQZ4JyGN66zeNe0eGSp4Ho6k5aqPnpQ2Yghn2KiuIL0QVQhrPW3JFtt39S17U1p2MbCFtoeoGnQ7152IrlEZlw0ejE+3aITNNBvxY754v3A0T1Kj6FjaM4b5CSN2Sb5aRXObBMwM2IZPgoY84z5Q0+MFSmRNg+N01EBPeka2tzjO54N/39EgAfkyLLtkysVbuww5h24YqpuiiFdJW73gFv1bWsvAb4mHLtLNBKAaygZju5Qs+RBuQYdbtnla/GM5iYIdSl6hOxWdClAK3quOnNJqQbGYVdkUjEwLy2UnMHwb6jsnUmC9bHoX2qHCH8i1oqYyw7gMKP6+RS5O8hgxXa6zmKMkvkNSQTW1QX1O3tSL/BLHPYvt8zko/I/U6XHK5py1Y2CGZ8HxIZ/CsYlAlni6s+J5WzXE9OXgtJqFE4M0a0Wv67+5Kq268sY6B7w0MaSd3vQA5iemYlyooehAtlfO6Np++umzNBshcVNHaVVNHmXEaNO70VHW0BJyOfmhaCmRz8GDwBnGDzBtAnfuawGfo3LgzFyKezFWWhGIN6X8BaKRGdr1qQSiyq7InGYV/sYMKJsKNGhIZyTrQb/4PDgK+P6rTWt5jiQoQvqlK8329jt7QRfB+TJ3rJewGekBX7XgGyGsftNAaOBSdUSRmwUgVKuswb1nGXlPB0sZpC4UWq7RqjcFbekoowQwbbaZ4rLORdLyVPYHp7iv9PrKF4ZDoli8eN5AvN8g4JXv/yc5W/XL8Q7677qz4YazNZtlo7y2rCA7/Pmu6VPZSXHTNLzrTvw3XRoXnC+U4LCHQIdIhjKw9R4oVCXDmV5t8LSLeuiK8RcDflPMge/7xnRRg9ou99nSTKlogc5OFU6s2iFyaoppiKkDghz7ZA/WePH1swYy/vJqkpGEdR2DgQd9i0q4io314dO7C8rfMQ7epKcbfXbyeIWogD30TDRF781u9hz1IUT0Y+qtPHeV2CzTcMCeBgXhgLiwKZkk4yVGMUhd+A1d2izYVMGYS0cNp2G+ZZTYpQVgtZIpSJHnYGZ4pQlXG1YHWcoKo2/S1Dz3yzPrDZHLxak721Rxz3NzvGLSXhikuYd0yeRgg7ZBZOfTMOhp02b1Z9CLsov2x7CDzLmcs5PJJFvdG0XhiLcaJn5IgW17E010ifcobNw3xRa32C5rYHJYpfB6GH+3zbsS3rX4HQzgFUB5DcVOsP2n30n6l/ggzxYrR7k0TTze0Dro4hPsPjA7LKhZ4kgkcFv1ktHhQFQ0dkLtEBX8DZLKGS24gopBwxjB4oYUTMFP8+xCxkjghh/p8q+xYraj/tVzbtqdrzlmvyB4FLqgYq0/L35j+s7uyOWqgzkUh5viMGuQ1sVTPt0NiamYX5BfYNYAiIhspkvIvmKGbDveX2EX4cMbWs2Uouesjf5pZRJWVGOcnOW/diamfLMxOYca82XyOc0qtIV4F+5M2dJyVkE41Fn0yxkiJNuhAzM9b5T6Pvdca0Qg4ILgXQexlA8XGOuORU9RJVjExC6SHeTuctmD+ux8RODiNe0/qKMsbBCM1hrnhSn16/CUD+JaIfuk2Xub1E084YAIx2GPP4iY7XeEjnujfJ55DYKZTX35JCYPzQyFY8tXBgK1k14SUDUAKjt3eN677IN2PfCaLhhX6VjdPP7plT7pw7/oyrTmC+xbBkm3pH+kbB3crrEX8cMjS6DFcVjOiiBkDBqcg0YWhnGzNjv4xW4DXSKA1jt4iO3cBt5CZfgGDQKuqBcX4ugyEkxHYVTb3uLm1y33ZRqiEBUqaIq/L+T6FHiZAD/Bmo/mV53B0qmpWaCflslxvN6CO4sVYDii6NPWIKBgbqSD3aGA4sC6vLSoEn1SQBTY1/YM6T6a7JoJtokGJfBIYAbfcvGEM/tcnT5JusvQI+4JUqrBG8vR86AnZUty5BnBUhLhbkWmPNfZ62QoQOarz1AxDCYPZ988pZ0nb5XM056EPjQg5+58X1UqnSxcwjjqo4mSoWTEKR7iQXXgNgWLL6TuRtO/xnLKoERZe/9ITkKCQ/LkybQVBHDGQyZ4OejYdYYmEQYFoHlt9YEhA7zCtOF0v+Cvp49/OCXPZtM59ebt6m2sUbSyIXHPDd6EILbP5hUJp8Kc8304zr4VCx+sZWCzLZDBA8KjYS4JtONzGHpFcSsmiOrVo93/7exC0IKvQR9HPpZyW56WO/MDiQgBYXoy/BGQnop7ZIR188fyy+2GLlVdCnTw7b339M5EAHQmnZoCPg2Xqkit3mw+z5wFw4wRYwiSD0+7aGQ3JXd6c7DmvHZhGrBovYOyuNJUEziUZp9heXHo89phaIeZ0Wdx4BkhBt7oZAFIMToPYPnEu6vL2crIXUpNkbbZFNs2n8MJMU7vr7BPcY4dbblUryN+gd/e+vhovsAJoY8gP4EyPZH174m08mxhx1kZYSGtj226NdvvLSfPWIY7cjg7kA+nViC9RWzU+NU2f+xUQKRWC1F0UIF5pbp83jLiemard2nsht9P0xCL+VIFo0DD+x9pzXC4sF0VVNBPGEPNpUtiMIcuMp7u7uNfXe4LjwLnSrfwmmsN28SbX/FsuLkw3fbbjOgIqtarpU1xRvA9wfsXKN6W/cQm2dqbWW8Jo+RKSx//aNKYhGLWrVIaKrJ+L3ub+rAJsc8dPzD8nf/erLbUha76UwU7toXBiYMouAFdSxy5+NU4OmtOF+j6muhm6CX8ngT1Hn99yryTMezcXT4Z5kH8g0ZQg5/tibsULDrJBml/N1q2UvtwtDKYwMEL6149CKX21gjLDoxoCRNBq8w81yQELVXeb+IdnpjeVwCmUhLFChzDHMQsquGrqHxzOV9rRFiakP5IFO4bEdQ5j1LYkjOIKYR5Kn7iEu68vqnhuH5ylTIVyuXAbupJhhc+8Og027P1TbthDU3YdcSEb22K7ECg/lGc7VpbsfqL3l48HC1gNMw6PSk4xGvGC+k11xA7dx1m+GmiOnvtJRJiLisIimx4Mp2Tlm/ZkENIgklwR8//5tF3DlLkXO8DRXzS4KUAPBRVCmch10Dqfqt549G1nNvfCqaxmDhzBfxWpEA1WctfeAakHZXUc/Y6pbCmZE3zNLg+Wo5WDOCs6GhZSjI7K/8Ots3odDTwJcw2dAyEE/9ost6yHygWvgHEE3WhP8oPb/kauRryIgR8B3G2c6Gu97DCvzy+4wQDgGqo6GlTKTllig2tLWDesH67/GT8dOBw4oJFaGba5sOoODWvGBwhKygXxyRS9VsPpn87g8Aq0vLpaKQ+Yox0ibyuBBXobLihsuiafNUNVu/QcNBxRwUY97I6hVrdxx3OhE//fqa9hdqju0mfucRSFYYE8cKa/Xg6xzmev0pkeKXK1LQndCLvI3mK0RClTZZAH+rUczwg8ok0wyhyc/NeZs9sR2Nkhi9kOKQbIm+hymP3U3qtULrp35ytkI0VmczZ9S0Kq8UTTNCEJj0ivARRjm6Gb1VDhv6a05Rm50zsHZhnXZYLnTlJS6byvEQxMPEjpOcDHIEGeLAIsjkWwwPgKRrSXaGOCskCcOBWy7cyADXlMSUgvkpM+BI/lViHPHX/z0eEBRi0KS1gos3u8OugBXmQhfCE4qLUJ6HQF9y/k+qKEDAzjsD5NoUfaIO1yY74TXUQm7UKZ6I064ZUFfsGDRoInhPsTDnRJzezx1WZGxAPpoEOoC/BVUIft0V0Hl+JKhEYWalucHuXxn2tPNHixuD/zQ8YJ9Knb2ltaMXE2DBlQWLwEJIPRMQ98p2+6JSr3SZwznVNk8yUCBR6AL3YuB7KAFVxrkAggnYDNV0v9K3vhvIomySd7SccZnKOvxxT4TD1Qpiyo/O/2RbdNHl8J7UbetlIHYYapoqTY/FBA7luku6RylQXbeasPkA0XiMSVpw02eeaXbZgiX8XDbdHydaG50I9TF0ewNA95fDrhRtXRFeBI2rirzSJC71VKsp5rLwDKO0jXVOQrtHZ+9xEpu1sUParQDTnkeeHimyMT9mnqnbYmpKZ+fC9HhgE48NDOmA+Z8mkLZR3s4UUI/659PjDJcMa64md3ohC/peH+IBlr6Ro1jOaz/yt8HEnE4PE+Pmnx1EvHGQFVsf3Uqd3ety26tUvSgU8ZmiO2TJFOqwJTqENWhQQ7MhaG0zi6ZM+VjbLWmDshj5qTfXRwIsWFfEgOIcQ2t46TcAIhefqvCckBgcR+tY/Hygr7PDY0q16KkHt3LMwT+1OiXZA8KZUcYQLaAp1bJiQbAgrWZtaExxab8a9sO5wU0eMVkUTlxE+va1MncNmNrGXiRM1aACG5QSrccy3qjoh977SnaNUTWcI3b7opXZ8K0s/+iveBbj0TG6HQPtsvn02uoBLBhvwAY3qb/SQbe8edE9D+pSVq5kIYGjwzt+a//DTpagyffKNXqc5or5jvtLyrMeWvSZP1IyFZcQNhdU2ZrkYvG0Eq/342VBSJicXX79Y+ltXxZDBK3dWo9nZeibTZnr+mmggMtforNZ2zgDEwx3iqGPjXwYvoKe3h/EawdnbbqmYEXT4kt16WRDFqg31vFzd5ZphplWZUkfyhMxFFZKrPg4TGAA0gIeEqCopffMulgK/hdNpXE8a/tLJz+lzYew0g+A4yHOMSRexs6lMu1UpjjhBtTl02QDKLu8KWTPFFs98ccu30C3eYNfPP+lmDzdUT3H9xaBHDyeeYoG7l3blGPHIX2rax3ESjWUcFB1YdKaUOYhg67Kvo2DL7e3Wyrd78aUeOiUn6quvYzge9/iPgED6rDalboNnrON4w4HK9WnGM8xi4helHHXoW+7Kd7F/BvxuIdwHGGOo2HsPOGJs7CaKYx5avbfRYDCtEtSgtOCchQ+8yNi4ohzaca7UxaRlJcWriylDnxJ4o7i8RlwGddmQZ8r6u/q2EAwo8dT6+iVAW8ePetYXdT9UxroGonV4U3dwjANx9po5LwtHOT+IKNoK/TO93EwOOowrfv8FssoWJJg2wHx+eV/SQq1dUiu8Zsx+3U3PIbikx2fMmN/nZubkVWUrk4WGT5CPo96+D/6RYFqYHm2/5AIwe2b9gQ1ZhD4Mm1ila7JeVcULfcOUxwjhgxoUqmva0Pmfv/xraKrdnM+nAkkBPEN9yFNPQwp0gouv/ZS3yxBAahKz3lRbSCLvoyXdK548hG0XzkRjKm72ogtKTqeuTykTbpjlahitCSwVmAgwwLl4XBHtaMhgtcZ2dnyynQnu/WlWh4USM9lDuDSTh0M0dnb+RXl3wYUdhBVFUPPEOfJh023c+CO1VAdlU7JAQ2yku84VAp45YWbv2RDvu7ytrLrtiLHmcp7lJFIPq+PpfsqcILv1QW3ctbQZu5M4MbldkNrjB3S9J8ByHW13oQ8xeCAWck1yJaINcy/7Ntd9V68IKM+GGJ89Gb0CwW8QWx6iXnQ7EI1vlJisO3yutTWVeEfn7GYXAec2lkD0bHLRT/SR3EFiVvhUORDLurVOzUfBkkgTP19vPnfwcERbCbWTj9Hw5AIQM1wdkBFYCxTXC17SPTZRKHsd63dRsrzqyZythKDyhMa5ERSXJ7dpg3bhU+PSXW0cbeASO5oKrSQ80xirf/qjbMscaFVkPVSeOTtrXA+Gxs7cEjy8ZG2kQJMZlgQVlkx7hw2GDSxyYWsTDPuamshOPRI6LgzwHKWYfzG4ekvg65AUDWhDYolVk1kdnKtOuEYCG43eSewpHfwW7iTAl+BlwqMSMsBoFQkbI+zUIHXLUyVtv2w325Op/4bEoe0ZnfeX9ogRG7j/roEbT/fnYGp0cJbe2ZicFdw1UsAYwwM28MILDj6/3Fie1Cq4VwAWP2q9SxoRzR0OQZYfXliWBpz/yroKMCTq2kwdwJcES8hB5gomGWaRWE+HWoSDRdJr3mBRK+Erfe/wRierEiu7q0IvhAYRw58ZSSVwL8ERIeepkevANQXO5cdqn7f7nNEpYYAkjbeOPwchKZPhoGrOPM+kb0GLCWLTDNbo4VRbTfv6JG3P8AWoD51Qa5jUK3/J6QUTXCbFGDxRcCIky9MwRCbXnV2MMfnSzXZgA45Ko6TuMaBTY39GFGrp1Fvhw9y8+J5wXArh46ZYBeQAVF6WhSs2Mfow3tjP/733o98y2Tnc3dxxJL9WiOVuNZhHgTEVBcfT5enLpkZVc5B8r+vMFYtarLPfnda6nXz+Ztj1LGOHcH0DseJxkTAxeS2jQe3yFCaysXZqktoaI8zUVSlj9R9+pSQvrZD6Xgy7CNdLqNpDkp/EmxVnVc4vHS34n0DlWh5DMY1Ot+GhZ0Q3wF/TgfrcCfyJl/dI461tQXv0xUtBNYT9LC59vZ7N9HmYN6JTFf9V4iB9ZXjzXRV8gdYOr/6R8QRqssiAAuOXP/Edbl1Cyk4IX8lNMfLjD84Dag3/VgAqZz3WkHFjMxUxybyK5yXlEWsqI9aJl9AaSCQrVIGdbWhh9qZW94op6XpfCbgDvU2NJBmdudu2k9z/Y24T8SjdnG5Gz8lnTYcRasFEpynD3MJPJCXpr7j8mmS1cQfAHlnjWuJD0KpVeBQN48r+fDKBp3W9Tjf9wCL5U0l0PlLDuuXB431t9lB3yhMokWHbbFDVFPEqp6FDxqbiZkJTdrU8u3CFqCrR2/IQ49BowzNITfNHZxjZloCYLJAQKVQeOJBCDkpFYwSsSffVUh2gSb9BP5BEn4s/eYzViJ6sCU0FVXE6hshScLfflY9aoBOFX9I9AihIDoFSbkXP4HzUncIWKS0MJhDKTOGVqHM+4H2MTENstmzDRCsujxkmf9jwqzAoWsA0IlFLd20Dly7aK7YkJ+L2jE4zg2CeMj0lLQbJ37WZVyC9IngFyV/9lsK4QO2KQ9gHEjRN2cKzbXPC9yxA1HaIBcKGmskFfRrPcmf8AiEEuxZ88Nd8eD9iweuiOBqmNaMyeO+pGU4t4Tq4jnm4vl5SgnZ1xnJTCWQPdSeJFZM+Ckxb7/IeLzAqKYw0z05qC7RQUHPW0JaHKhQYPiWIUW2cIVhN29WA76n5TijlXm2zWIRE2vuxBCsIEa5B5n5VtpiME3IHfqq2ZsrKQH6bf4dPCA3G0aNuIHXTNS2sAGQKqAV1Kfa8zQ4BNO+I6PEjajTLmeU0si6T7HXVirrZUju21l5zURMpe2gXlOZ22J+BmBbW5DgTGOE5kkPqvwr/LGCL77JE1U0f86c1YjeTsK4h7+kUeSYchgRuqWKBDQpW4QTOvE/mkKVt46SArXn667OaC3c3lmXzXbcR95+Yf/ewIaCX+Dr1AyxugXvQATbkM9OEVFrB5F+47j8xDJbwsAYiLKi0JFXBxG8BzodRXIG3BeblM2gr7uF2fGiCIDSUe56yMRhZGWL0KvEuUYqbuZboZN+GvdnCilo25x2AhnZxCadzLNcaNDWQV3ibabxM0i7VzqRk0Go/qJqPbV0/hvFzoKhZxKe0LNmf7xbdgs0W+k44oPoQf/82wLNQMx1zONK/K6n/pxqRTrKmq09cBVCAzlN+OiIkBeQnBhtfgvR0oaFqPP5kxNrtb6cVoKcEz9Jn+e93Udc41NMW7hJz1YeOxj8j0Ili2378vl8wHcKhAI6m7+IMfYPLmnkXUsQZMirmcqFIx5dN6nAZXPzDQHRMLrj41vm05/jzUD1pGBLjhIeuSRefySZ4/UL2J2mR8hN52G7Z5tEQmMjGr52sSt0iQWLFCKiaDMdpkuE1EvrufUz5unzPX08NFg/G2Le2ZkmAjcQgscbm16GalZVgbhIddyzZuo2oKy6dHxLSeFvicKk8bAA57acHECInmeBVElL30wNhC+s2B+n2b3loUlhTjR7moHuwhoTL1zrrkuunlges/s4Y8O1/4Q9nlNC3UV1kWx//G+0tfk3dUqbUNBTNdxyRVsqVhcUGAy1IFwXwO64YFhCcDiTZWUQ/wxogxvjCnL9B2VoZRnaU/CrJv8i2Vn7p7d0mJgbAOaEY8UUIxb8+hv6Y7R9ugMIn3zpM9VPFTYAaYiHVCT5RibAA7sh9kypJ2Jtuxl1XzdoMK0HVHVQVbcR9cL/IpuV2Z3yNiHVnbILoJv/cIVWbFW3wIfdaOTZiGVHs2G7+pze4KwXFyAg8O6+/+ob+wTW23HCnbvObaEBpq1J3ks6TK72EJJch1Ab+NAUzkM+PoJL7T4XxaPyF/IpLxtM57DpCOZ0d3EEWz4ZiTToSIjMecT1+9Jlyocs27KXj8ulRX0Xi0lI9DTxBiZ0IwgXPqgApwirDlK6iUaBOVuh1rRwcQoqTzQl7Q79TTOMULHf/EkgMgFk6JQm9wGtZC7B7GIxPLA90YaT+sumTPdhEyEWzm9znwRJLhnJ/3gfSPtOCtjuUE+Y/p09W/IcfRSxE9ysSrrVG8CUDya/V6957ow7yJeQNpQ5aS+KzKYOSxbH4lcAR02yyMxvBbgFETCw8z9+A9wcau/osKXcwTHIlffhMZI0T2C+5CgDgjkXKRBVGtbm7W1zPvV7q0jhrf4+yGdu9Oixgv7r9LCXFx+PjGp2bLWR3ZIbc1mZe3hzZsGbwRHIgTB80IxBdCYNmA7DtPMjs6gBJapteyKl7s/p8MkoJXw7Vt2bC1QSMrwUzFt/P0DDp3D7BqTP5hVuYof1wmVZIuK9FNSzJVIbRQ1JCVmry7q0ztPeoHWSQ9ztjNCwU0/Tf65FUreipPP7OKJKXoB1KAJdrRkZzltbXwjoZoBhGLdcxYOjjMwRoV6zi7XxqKLwiXukalNKiTDCXP8CxCQlLLixK1i2Trl25RVqJ4AeAaYHJ9TeMQOME+CEYaJH8tz8Rl35BEn2NJsNFyxtxFKy4BKrGMqP7CuhWfEl/h4iUmRDva9hEnCe4Ju8l3dEe+zViEiXf4CKZRUlgjQQkoUpJDslS4stQJMlau2fandUGiplhihCft07sLLHtxXQSB966j1n3aSABoOoKPiDHF26p6n4Btb1T0+Ca9c7hnMpvnbL/rn3+qHn/gLQkimKXiLOm6xH2BxegI4YF0KQN4Ny6uwe4e8Vw4RewiBUdLMICuwHIxRIWAJemL3kf3tm+3lUooWraL8cJYTupOtmzekhdTUf98ovGX+LIv70tRmqeDei2okdRfhMK3sPuFnsObQFxQO8h5aAfpEfIHwy5w16/If5idiBL7X++ky7xuR3KO89tKyIHPFzOWks84bfoMoG3uagiblNN+HvvAWY6T5r0vcDHEX0f8Pb6naHSOXYU/ZygZXEa9AJZR69JPlP4dTn/ffuH0IoIejdqvBP1nnoXwtKgNetm28pzeD4m2IrmYN4WrOHVwpHJT4gAcfUCAjyGvswk7EPQx896IRUbOZ+f5SUP2IwUHwx4NMB5bX8kZtC3fnPvXieWoNnbPBRCnJvfGamJtbE4WL5vJPitRsXuKZmriSPozcNU1lRsOVDFwOn9Aaf0FV/P1wz0F3pycV5F9kJpBjp1wRo+wAQeaoJ7SaBOw9xqLza+7/kCGaINdo7Lg6t4NmxEYwokbZfTJ7/OeTMaUeHIfNy7sNz/T51dxZKTnvGS09xnmOsRobnK6pEAFO9xLmg/p1Dqkn6Yl7ngtvkHbGpj/wuSgZQHFFUxGZjMt/svPolUjWU+7c7TFfh1bGsre82F7ugg2jZQ1O3lapuyt5C5xz9vADyc3pMyHMoXldJDu3EmP/FWSzatD3kWkhUq7i7KQm73tJksV6qBj6Yr/FFPZulqjF6k3pmmp84vBQJpW9c4OqAkH/ih0fxRGna/iWN8affCecHjb8MkqL8qOP+LxpLeVqi0ITChsWSkVl0kYcOaRnt243ThOVy4KtP8Wq7Ye3UO23Zqki7NMGg917rpr43amYs2kCr+EgzyNogRBZX5M43urmtIrbO0RuH/1ZnOYsuW6Hu2Ytf74CeJ8V1GEg8ykRniGZjeJnJqPvYqvYOXttPN9LoBnq3XAa1XyIdxNIKjPVwUjiAJnMzW/3p43oseXvOjBFB7EWHej+LZhSo+KQ+QZCDf5aw8Ok+tTF4qCLWcGroDEpj1eIa0Gqan/iHhuR7D4Qg3C6lWMP6jxbkKZGcMgW9u1P7M/bH5eQghHxCvlWu7a+j9suk7EatwPhj2zY2YtC6alOLx7ERcPbm4IL/YVkCssomjOq+9zS2QGsh83mSm0lVXGxAOcXK3Nx+DLSDpiZD+CbQSbTGBDmdFRRk5dSBFAMvJhBUC+Un2QsrpokmpsunWTaExy559KCOz1i08MIjKH8vP+ZTsO0jkZ87hOuqqvoqCKj2jmTSuMpaxHL6N4HXyUX8kvXefnYWdXsOO5WTv9Yruwu2TSppiZQXFONroOWB292mTgkG9fLmIzT+ke5qEfYJwjw7i6JmmaBL6jG3BHIb3v/w4fkf3IU6IJkPOkB3TdSJIiB0YWHgHcLEwfN7jVzPYrZJcS4X9jUjmYg1Q1/Pte6GxcbTK/oR0z2TpyOL3jLEDUaJTnZWDzSHoWRx2DfZrovvurYDNdukc2ut2wFUfO1pDYLLTbDdWGsuDxsTXEjGIDn1jI3TKl6s75OpAvL3uHxIpy9DlT3fAOVQq6UQcF7WAM/JofvD9p+Kn+XFSHxbeTsBtMjWDdqlN7wXhR+bGhRjAnNzw2Tgx5b4QT78EV0T/L94E6miYxzOW0H2nQneSGbKARtv725sCOjSUhgLMJPawqpqCKTTsAy0qMzlfu3S8m15ga+wBkNHEG+Ig+6Q9hRbN08O/25unQEhOnZgXYAUA6pKmw5FRDkF5Daq3gP2Hf5LpyB9CHlkSx7XE1K9S6pomQFb33S/+MySw/iWk57IrLWFEfFm5y27Va+eFxQf0F6J7ECa916ds+e1BS0Rcd5ygq7nLpcsZj3R1t3kNY4q0NyKBLgi0MZKe3BXYUYRXio2ayWYEO0NkUFtTQ6vsGbaAG4sv/U272hpsc982H90/DCsQdLGHqjoOaFd9lC7BgtDWTfReadmsoqu3nhhR4G1iqJtQZ6Qrf686X7Gr4Ik4sgkBTPGapQ8TMOqAF2GxjLGYAzUgxJLczWYfOs0J/3zfB5VIOJwueuwiCJQKfcE9T9EUld7ZvylykykMiQQLxc7wXEaHLNXPTs0onujZq6b2jL+7btFGBnZq8lbFwyZRXGgZ1rzWUYcKF6u4xTSzLV8nkVcdVHy/GsNBJvaIsehOrB+scrBFPJ1y60KA50QlzCYOn0/IyrhhnGbU1LAuVY3+TlO4v4nlFPsvXEHNI1pkVviq/Ejzuvb3V1XI9heOreFv8pi1mzf4srUhn4j8SoMdAW0l672p0/+KFDkiDasGjF0OXZPyOD7HncakZMltiluSgVYCO7flk6gSB3axDRL6mOoOBAaV/Le53QhN3k9yVQVqPMZawBD/b3aTrF4Y4xOAppwx3FHz/SrSKOytwXtVZP7wtC6mUQ6OgxSyboH3WJFv44F8EIRbq+hlCwDahNsNoHqYJgs66PzLryURXfpj68XDZ4nJPtTpD1UJqAUVUc9m4qvW4+GRNlbFmGXmjAaRa6D5DG3d+lekkuvhePTpU5GmZR+RsOS2FtGPr/BHFJ/lP0ktm9mXLHYMEildDGfF4kiVcFmKmBatqJEt9C94pBBYOPyiVbeVYElEKdPX9Nd1cW/Ffkxc/7AEChBFRcGAeOt8ezMsBHgzBaIqBjAAJD91r3WZgfgi2Nno/mCHRrR4pqP1Vh3gDKy+p5dEE8/q96UAWCbr+8yJY+SFZN3I1UI1GHSGrJNS76PENG21b6jcZp3+0FOTeACyM5wCPyburrp/ndjRf4SCakTYpXZwwkyuAgw+LY2IpuhR3aXvHfpxAN8BgTG02SBMpUbSrveDN2ed0Pm+7DjZCRnHv+gSShGxIVbMwRRpe6lZbTo0tC+bnzSlFb1KBtfh3YTa7zAYJOsQGK/iHSnnsqJ3LlWXw+Y5NH/1Cl8mTM1437L5Wbs9ZZKaf4DMAgeeuR8TIG8tSfBLx03P5ZXoXUti85XsvRuPdzFvB9j1c8fWfBmK9u9sXHDkO155FwlgK5OaYokWrcKhs4M54x/fkIVvMS2nnYrEcDz2i8e5QHagJuRoQc+NUZLARSpaoL/m2w4KG/zO/clMYU5Qmxa05NrNboJ7uoKGLYD5ZrSNBKGw4LLL74bU8x0RZRMhcoxQvvqqo37HFHqvzfCpLpES1TVh6p3CfaS3dGw8xVVKIzHeRNDVXknZZZQiH39Y3Wfjd09v0jgMY9ZiAaceO5AjcW4bfuQPqKByf+JzdYdhxk/6NrmLPqbG/8DYbnxK05U53ycea0U7cI9+tSa0cI77XOc2nw9iyOIhlckqOPIVYqhDhNRc3yPXF8SmVzPkmiVcL1RA4BFkmKClRE11WtvXutPdkP8TAapCMFtQXTQmOk7pSZ90U8yrQtxHNDo9a81mS5wdzW6yXN+UFA344TuA8dXulV9iOVgv52UMBhCIG0iGPfPGfjJWxUD/ZDW66jcM8DCuiQkQPegR6y6FYW3J7l0nepVKLWwsuO3TV8mjR+4gVgR0RS+M38F1h+UsxNn7cPFBD4BGfH4wGjq0N9eTx1e6vPBj3vvFsMB+PesgdeNx/2AbUBBml0N9jcp6dhEZFPL2cte8HlRSEty6iSeFIsHADVWDgk54UdCD61ts6AzXT1Df1qjZlHrP3R4v2ujT0IltwjlTy3sl0zICrmVoQpoBOj3RnGaLWsPOsAym4G1ADBcFqEycqvfVMB858iY5qP9EUdh8cu18xhxIGi4aHmPFdSA+KG3wqoCKmtNBClOCrdmE1L26V0wuKX/qSyu3x4mltYsi1hvNGJkWY3LOMmUs3MVbb5sGpeJJgTykhe63MPeNBdzwdaKw1QmEzTzYJP59G9YHVBpX0EKrmCqwKNy+rJJLZ56TopzhZf28SsnenxBBqfxNaNb6Y+dUkYKj3dltQjeSPFivZk5GHL074ANYpP6tE3r4IMi/omiLmRfFKy9DJ4ENeuzgSWj1GauxcWCRG8xhXjA1d1x044CsUglhRz34Su3bvEx9KeHG7IKG1zSRssOJUc0byJKAi/QD6QBbvQ3eAE1mgbvmw4sammt9YptwQV5rJq56g59VDCTANOlDVLu3QL5yfWB9dXhd2kqggDUFjRvylWjEHDnwDSUVj5Xc6e7Mp+ja06Qxn3v6kXOpGlLAwKr7AMNwjX5UbeHr8iXb7/P3CqdPAV8Wl/tkx6bsocvGjZJSZOgta04VZBruOYinIs2CWaOHla8kKUpayUUk7NCTj9j9KdbUrvNg11D15cKXQgtMjdvtsO1kogX4jCswljrT/a7jlmjORsC/T/TRa7DDWRUb6LeWlmP5yCZllgsCcZtzysC8dTwC0C+5lT9BW3eAQUOXypHhlV/+Ts9aDTHV9ojcmwKsyhMG5jWJar8t1uZnkbcIyTAS/GMsuQ6T2S0XmiCl3L+FTFGParbhPtIJl4ffRX5zfjH62KXkokoliv0qW/WBne1pe1SgYdQppGNPCnhwwEgK2JjpHySfVH4g54MzDXeIf1gVuFimpHDdfF92Xg/E/QNiqjFaMBbGJmBCFl/X8QzWRbF1kwiY7L89TaHz84w8/90BemASTCwbdAHIrY7jgZAYoWmTwgG5J5GrSooKPwI+kRJ9rjitxj1hyh2BzJhyEtTxhJoXSzD6FgxUJ6M+yKS6zyo0/q8B3lWYJkPnrGuL6JW5hSuiEiSZtFiX3QaCNr3yb/5475vcYt7MW695kpbyXKYIJ2ijpUTZ6+tcK8MNZhkrDR4zLMPIUe4QjtTYfKz7HpoUXaJPGLGMhVlDMLvYWpQxc1BlfZ6BH1E9naJRwqWdBBN2Ntqdmk8044DAnd29jRTLVxl/5BhR53MlieOeoRTVh7oX2wZSPXJnVw8Yjytpcn3Spkmi8p+6JP0+58twWtWfyg3yBb4G8JdMvlwsMRP7EJWndRBEEEQ5X84NGLPnxYZL8h0HS5egbvzsQnJKdVSccSXJzy45m1WmVzJfJJg4ew081RuYPJAJZdqr2YIwI1o5SweZj6KoD9OqRx+ab0TjkrPbiO0PVfcQwtJixH0FGaWcie7A2zGkwLXNPkeILtWgk+v5bvtcjZwCIp8X+NHVVK6tYQl22646zU5HP4YveftFEegD39+scPZcRz7LOC+KViFWZVCQ5XCquxeK10YtZj2DDknMR0ktWCQS2jjvJ7z7nVFXc2VAB+iC0iX2rsVyVxiQjv3D7tYqxwKgxzL6O3350V6ipXFD/Zl8J7OzcjrH5n3pwT9d9KGmSFozJn1POV6ZfBns8z67DiePiwBy5T9n5NrDwD0kXpSlwFGhtz56n5J9FKge3CFmr6xxHeMgyh5XBq6YXgEpDAN9YT+a9PEOmMVDin76v5qd0RsAlONIp3wW0e9x3G7oiSl415ZaI4XP7Sx4xB61bCTonMrU7XyS9lrUVnKnB2U6byAtf+/mg6n1ElOSq3M6IjPahH/bTG3kdaxWhB8mfsEWUlFXVbouJMs3PSc6/sKRb11NRV4+b54AWPfYVb7vGkm7vvCrKEJBuIKUIWtzr1wRyB0A1M0pRrBiSwN3EVymaQfvac+vGJaFPLBnYlxRDXN3jcn3rnokKiz9VmQRcyI+Xa8UnWZ37waa43dUuJ+p9GMKtftvsAoPTkleIURjmmHBtvQXL4blzZbzKZ8PKt3HqECRdvpj0U94V20tRp+zLo85KMRNm069gOs+TL2NEkkxDUlSU5IPUOQrO/BMeDk1S9K8ZNV8xw2Wm0M96fYYIKce5X6kzq83wrl3zdojSo5QKBMccf1JxXbCIfiQBVPnXAJ5IZ4VUMYIBijAEVHGAa7Vu1p5GPI7ytuuunVsk164sIXoUwNP5Omvs0nqhRL2DkApPc8s6VDE6La/f0Rvri3nmv8CWMlkXa+bWezJ+pVP4Gw10IB4iTL+NYn/HOb5XNqw/ayT4GLUulZ/6GgR04Q7UFYNi4FDf75cq/6YMe6NJZgBmwPFPqlMHkt+nCr9cCuJtpdO5X+ofbg+lb44lQrjvVjgrdHW7woD45Ggl7Ek5arnDx1sqg7xz4doVY+O2ZlTJkQBBLxTkD/q6JLyOx+eKY4VPlk+qlBzkQRZhdUNPxQk+0A3g7FnRrhOhAeQkQghyfbXRLQKdqsDFdy9hDzOpiY45xIbk+9wLpY356VdWszokqbiYYWL22Sy8cIDubKbbEhwL10nXpedJQSJlSasWyhlgbfiPmvkB5tG6Xh7/XB2xF9aF0+emgrFQbrEJH9t87gERopk0buImaFeSfTnk62TNI9ubdmK9Jdez7otRl7q3hagqZ64VLPaPS7PCZo1W+/vUjLxyNM133e2dSnOTVTH9bSLbnaVhoIEs96XMhC9vmi54Q2/R8D514KTXBg/63EEGi14IS6bQsFmSLTVj/i6BsNi4pMQPyjxKYVewQZAvmSNDusozPXZbeOujo84NwDwA1vFcV99UUxTAtIlDGJ2lu2cN2DCIA2WSSNLeZbT5iNwWIHYlyicWusaTj2QyidBTYax18ijCLcD2f5fcZzetjo9WdKDeIpdRg11ynxTinvqFYCOJagyQIYeAOfBnyH9tVhk9BO+gkCxWe3HoYf+8NQixph1JB+BKJpgxDN6t/YAhgDk0iwwnnz2STWJwtrpZk61C9SLH3wL0AhQr1hjhaa70Nahpb3RIXHYvzkHF9fxeNDSrbSPgtb4JkTXRX08kR7+/tAnnJBHEfaXl5JZtdIypbrLTKJX39nG7b2R8HtuNANbNrn6JFQ4asegTlSPgQIEpAM6nLbTMZYB6EKBFA+FoM3liiwISJPht8KGvcizg32ayX4AjKZFggV6++JufeDRm+CxmNxnNv/0EYcGyTgjZbiOlVAWnA3gmo0AfGHXEBCxzG58EjN2xbue5VFKp6owQMJV8FAS1SlDLXN/QTQHNyMnlvLUH/5p+tvN7FCN7H9iVfOJ6Y72NZvZ9Yq33mmoiqmy3hM8mYFhOdv9fxPcncqDWUVnWnIUrKrObd1uCYk+co9BRnEDz5VDX2bpt3hlAcDpP20ZCXqbA8EckwvLgIkg+sikv2gbhvtrPqNTni5njcdzn7O3HkrPUXZhxOb3U/W0Tp2YHVJ9POXvR3YZMEChGMQ81J4FgmIyc82AZ5bxJgAuIiWFTauSk69sOvArEU9oSvCmUheefhnBcrQrBG0cZGZMYSNWDqekLUJxv/KK2Nrb+paCm/vKebuZ2zuwYI7PbXOzE7JbNJGF8prfwlc7QKXYUMUHSpKW+Ih8nc+HKzOeX99es0ekTp7UQTMDt+6SSrXXK42qMzN6qO5kbW1LPotp8Ltc1ttLk4+oIVR7KiOHl9pYPjPOEsOqigz/KGPWGaaci8lLfrQPKdEl/TaXXVpq6SeogZMHGE+/kVC5iaBOuuAvs291IooaB64w4tlbcXqpQKsF+MJ7kSpYoWSxH+F86kpI/wxDlGL5C3R9H6bturYSoVXwEnLO+n4lRBoIInYxm8zoLM/COtY2A8AUVftgCrb8MNNjSbqY0GlNHh6Q+qyX7rivm6KJ9T1/QQCChACOe2a1nsAlfy/ABZr/9WYJy9chMDV13iPJuGW1ovAMGbo7ywAN6cj8GX+HximvBVU0zK2bcjCIoNRc6zp4SO6dSIvuPDuBM9qGRkv7jdY3FFt442K/yoCewDu1a+ywHSrsRjq2VSbXotrcivsUaxZmjInJzNp//ZqUkcj8A21o02wLSOyAjj+dfaDZRD1Pfb9CDRgB2PVMNnriQzB5jtkRhpZ5jrUT2BwVMY7cHH2JZPiCcYbZbF1pg4TDbkKTq9rNwET7Tkc8cTSCntbavvD2GUuu1xBcP9AoLey1Kvw9NtvT0KV6NKUeHwZbLZEOFCMKf6vEo9Mh2zVN05pqrCQ1qMvN9gOTFlqzeamebvuZ4eUVGzZ6esG4Iu4pjTbxGglQcP7AwihD7KBg8n0DVo/4W3+7GDBr7jHJd8nb5Fe77+r0spy2+mT7FdaNjjoiawXJMZglTgfjiMkqyzQHzN1xntL9HZ+PJpoEUCc8I15glBRjx8r0U43rnC7/1Iv1lCinZEcNlTCNExmwPzgyEVPkfWxNRWQ0h6XrGoS160mByBfH7SDUK3zw+bv/etue2tWDSreVoJf/VFY0xJDwAq9orTG07JU5qAEAuGeWrMcJ5AG77LDCIIy/JC6WtoiqltgOoxBwGoxYGiaU1H220+wjpzUJGEGZuwx3V4CUHWFhMOw2j60l8QiXSWHsm41rPUBziSe8jZ1IHlXKajw5aqwtB3Ov9p6l9QbrAxrwleMx5blWD7RJ9Pc90silF32H4uN0kTShfrA/ljsNBaxKYyt+itj1YB6r+6dlKhmIegU0EXosltUVDf9QT71T4pG77+z3805SnfdpyUUse2brvHLyzttZoAZtt1abmlO1rg3WY8xKIvH38eeXbgPJ64H2M01AS0ST/3CuBrh62M2BNAsOgREoSmIg8fi4djV1LDryi9Zf1n7GIF0m6zZu9Mj/bVIeQLQigA6YS41ySWED7+oSV6pYHvoZj5vo72NabUiUFxreg23kUnHLs4yyCQYXuuJPfC9L4HRnejPJ9vw+hKAyr/CUZyakx6UBA9nM5wadGdDll0tzOj4XyTSfrKii/tf3z7X2R9Dh5Kx+grf3iye2IAYN4pDDXeKbnn8OP3AabgmnVghX0kx/Ui8qoeqb5aRyrljQgie8u/tQeUe+M2WOG9t9bTZAI2Nbz+X5S1kcjoMIwai6OnoWrzG2L7+vwctMysvwf0XWNsHb/N3xpwWjo/N92p8May3ZuqXg+ueytOMGXap9nYPZdOrVD0yfBSaRGeNY3W+kyMzcI1MTTVLN4Zf9iRYCSGoB3cXyfu6h3yVD0C4nqcY8hiwNt8JJ0bLvhuLoxOFzFqMoFVQ3mvqInpxHUyYpk/wbp2gsHWP/AOzPnX459ps+wIJw8GDrfDgfjMUmLTIWMHP5LW30hHx2BAsC6onV2rKHnGwOPd5L2luz/iuBrWu2vSPqhTjlJY77EmbjWbHRLGPrTEHBFaV/QlMkC0H2+oJPB4iJ5u0F6CE5oYx3BaniUjotZrxvm31Iw1larzAToyw2xCJinPArcSjBW+zahXzvFrLfR73YDe60QPNsfwQ68rNKb6+6rOvcywJwMCxF0jnVv5kNeqRstibE/cdBDan6tn9xOYXBmR/fYWIXi/h+SyktZb90RcMC8vaFUnin7pPjHdSrN/fkTIa9kfej2nCHDkdCDtgSSAtyq1n0bZGFkhaTJifkE3vkUuwBT6bnEDBNsqFNKLbPuIMB68FIrpu5NRo6bE6AZ1fuk9k0DU8FtV5GtF9hDGQmWAgmoda8B23jV89cIO4A1qLMdFQUhgVBrD/HlhSlNJRWkTnCjstViIWfmry8QZACxPJVxO2HQrJ/CQCxBBUDxMer26RcIUapqLPoQ3N5YqYiRZu4lJqB+dMiWj2mabeL4YIj9o9Ublo9pL4EUGd5JNqWKQpgaOEL2cys39Z1x0Bt9uK/3yNXyKboICW4YA+kDAUOFqzOpuVM67RTR4UK6O1JiGxNXVynuPrSk//05xdqYmWgewqkg8InWaao6mxmgnLGUNkh5mJMQ0myOWwuV0xtJ4UvBy6ZJ+SxuFQlEAzFXQPUk0JWo0WgyMVtW24wv5c45oxv15l8s3jhdT3bfV3MT/ZDEopK92hqbGt9jLSVU8ydHHhOuKzIx98wsty0uiVQHE+uiZE6b9qPruLmoe49uNSqbU8noTa+ZjXzQ5rFVhrMMly7msF9PNpcTAnt3AgsozkLJuJJ1sBY/SqvGcyWeIBvLOmXI/4efEFv+/W2HOY8Ho569VoxWeNQ+Q2YRwWl3AojQYlV1y/ZBFTFLrwMN+LqayavOxmduFrMP+fnJ4VlBRdmZ+gCdcuibhACjqL2QLThreIqLJfuugiE6+8YITTCd/Oo+TZyjQjeNjEaUyCDnz7KUg20ROxhmlqIn07ZEiMXUDEA8emURaY117hjqRnYwSp/ZSLdXHkcIQ53ILp+GFjUtMTYrzL6uXmkVvjPLO134fDFiMWgVFiKfcTT0hh+84nTSCxlU8nBIC95YWu13h57HYA6gvAwepC9gOPBVRc0m3o0uEg3w2ZFLdGsINfPFlaistEEhevNCJoLS2c9ZnnmJYaHY0Ob1+tdaRwUT/uNdADPSSAnxn9zfeYOYqCEZtmlfCBxGVNKEfxk6/KCZmc+xRqRp3J2n2e1I/vX7KJRvCIEerIfL3ttBNzvZ+EuNwpLgRiawwx0JFk3Gr95/o6VmipCed70regWzO/7zcYenSk0l71ohscj+AGEiBDgOp2CaxMsPy4dujVnTSjpodfD5th/1DmI1McT+MIFFmNNzxkbl7JCGoNXwDgxYDwCf2sXvVeT2pK0I32vRmXaFyHi6Cyl/vmJrtZiy4EN4qdIUpfAHrU8KXxO9GIXcmVBTx7l0IrClWUMDjrmnZBFXwITUwZc8ftuoX8T3FKgEhKPmY6qDhH0NsF9hnfOL9Y34unECeBW9oopf33h4nKKwLc+NT/N8leOMkuNYVvVV48jgsiuB9jq+W77KSotO/6/KlnS4KyMnv1svGSAp8goBUc8HJhJTvoTCZpAGyXVwgzX9j70u8cCRZVcH1SNfo+pB5Ry4GBs+3dow1SlltuiNIo23MqRhSGh+r4KerEQYhSCCs80H/FtKn23Ku7AhBaVsmy0mYNstqP0IEbhgQjjY5UzPtwh5BhCx17WJPfBMiCceJcfjTA0OY+LhPDaNwMc8/8+HSZQjzo+GtGZnDaRbNtUmX4m1bPAxVSdCxhpAguuFH7FyTxgRChR+m75p5t8l+jazt+O5ItSaNqMN9AjCv5fUNcAwzz1sZKTC0lRz6Dq7iwdAoICue5xmthRqxLisJ5eKMqUEbKBg4gLCp111QORUlcHs3BhbT6c4AlXnkghLJNiC8PVc7/t7L7mezgxaoyCXX0t5QKnjj6PcsEco3PFnccyKeSAmjDlsKUeAhjH7/PuAOrnxoVkLh0B9peZGqW5UmjpMZk0knI96ZWz+GssDDaME0Wenrmb2LigwTaRRifJLI70X5g2mof+5Cd6323SigPGONkBuvBTh6WFCxAYY+wueU//CGU0EGxpkAU9YNh6RkqeslFxudq4mrLBqkJ4LHZbu4nEdJz+m4LOpbLOTTUdmfLiw2BPlKovTIAFvdxY74O2IqsUuTDKaYbuclANLu9aLH37nXviHQMfC02e1Jf5THCtVHAJ8d60FyxZGnVuEbM2pfXdTL/L2j9f/4Ucs0BPzEg3QRUOS/dyg1r1NzK1Q7ui5VPx+2AeG5oOo4uAlbP8Mj5R6ZWkb0SgOmUV1oKeCjOrkNHEIpOW0Oc4QvzofIR8Lih7FK5eSlwCakFEYqlnDGvvbmMlsX6uWO/4Z3ulaGZFiOA6Eq51799KRGTcAgn38hwGUp6EpCnEwcKjKw/+o7XIV+JCnC1ZN+Kl8kbeGmjKok5Fx+iBryZpuCg+3Is58Jey6n305D6bQ6yWlQzQAOiIefT97+HzPTkZhZla3aPm/E8OndJD1S3/8+rVGJuzVGF1MH9pGng/znNJMtEySgaOWgbQ3cT+/AXT65AM9B7xxljF7/JGvzUwEsDyNiizOWt03L4izs2+4Q3XseQViQ3IbtfgdAGtm5J38pCUSMyGdSsOgXx/jsPHXucD9DWF/kvRsSPZOYQoIf1+12YVlKuK5Rj5Wo4TjM+xXDdkDUDGkCSKPBpLeq1t8d52+x6praaN4mVXKrs0dc7JWQ4SwQddiItgsFeSgyvvhxCLLlzW4MlMHlj3NBN2J7Vhr97I2b0d59gTCS1mjJD4FyyPcUk6Z2sNMegP9AjaKPui+wQUqqmwOuSCGkCSQhPbEeMjVK13eVihtyPPK4FegQyx1BaKgGJtFjgMf90NjdU6rN0YCAda49o1uIv7Mlq6ElqkivVlzFhhz6pwEKcboquriVfzJwEauu5cNJxCIfp1CPQ5BLuuu4RessmgNwS5u4DIfpEPXCNCcd2bFXj5TXXqv4s3JXJSULKrLi+U8auKaYGAb51DGzD5/2ZR9mngQIMYfJLgNFHn5CJ+Vew5SNIMaPw/2xqDkX2IKZw2QAtvaQppC0B09b7PjEN4kbUuZoCfXaQm34WRd/yuHlK7sItJxa1BFRZyBFl2k93dwMFVqDzJhOpqKpNhk0zzxQ3IgotKq45K6+FDZ0cih4NHmQFdoZ3aOIge2xdY79X7tI6WkcMIQm2uVLjBdLFjiAqYIX5e+HZpMniuSfksTkc5Jc1hWhQhw0wxF5vnADwov9ic1i4as5AalpmG5isrZNkHp3NB6zRiprgwSDA9sd/KkbQ/vfjqfsxkehSANn5UTlthdALg0B+4VDHTyAiB3uzgHii29r1OOyoq2Pi2OPDJYyFR9P232g4GXDVTNe6k/eBQyq1sDjzZ6ae+zvem9WUyIiswd17K9/NaeABWgjsBefRGbfl2WZbd7eGcuZl4D4Lfdxufc1IcMDHX23AoVBBXEwrbvvpbgQhvooTiJbE3fNPR5dktYJXT3XE4bq6LX9cCnHqw3gEe1ZqA+0KKzsfV8sn7bDUYU9z5zBBnOP9jwyEz6Z0U2wv0Z1OwV6RfrHRFYZxOLO5af0tvSri9Eo6eEQo7WUEdujgp6QNZDsW5vWu1Q+bARxjsiT+6hAKb0+PyQLveM5zj95IQ9EYJUGsPcXv85nLnhPvhrVRTy45PVzHJc81dA5F0Dl+9U12+C9FXBPPMIoII5YbLJfNoGPU4Wvlf6py23s+q9Wey8Z242GtCE4MI6vOjPOwGuIyFxxME/NVwMuEidHb9Jp+HoPUJQJty9vouIL74FLjBlY64dIBYeLtaa8wVq/3dMHVpfzO7dzMIug5GzxLvptkQivzoO1692ioJ9mJ0V8XZJ8BwxJEzF65iM4D4YDkSfOpLxLQYthPtPLy3Gi4fTRHQxdlcKjICRr0Y6plz6rgSd5sRIOUHBu+MFXIZjKDniejFqlFkyVYG4xjbhjtRS6oplDkLuUYyDS5iQe5wucwAWEWO4UZILhw8kQTV2lY7Sj1MI6jx+QvAmrQ2xuwpqt3L/MM1j4cdpT23AMfFjItlSKeBrWLbuWKnRyllbUDaW77K8/uI1RiHV1plBYiABrc7Jk10ZM5s4j7Vdn+E6LSG2eHKNDCcVjBCXADvQiUqevh7Xy0ackkiSfYtHdmnjocyVZ1uAMY97EUk7744yVQBAunwIs4FKBidd0wuW5W8HttYs3NfcKXi41qqaFRk3qayX/AJy7UbZJDpJmFov+QX5ziEWrVehl0/HxNcEydYIPsIg15rJNlu1NXrpMNocus2KUVmAY/YFQwt+ohSCIJloFOIbK2u8THkiTmuRhm7lIFLgXkClmlsYaWX77Z4yFWjQTijtT/f0AngyqSvN0zkubLp56nFg+hOnq6azF4QM2KcyB7mBkXE08chxZFcdmUt1U3jbl3txQOdrzCa8oNeNwy/W2dx/ddE4/N6PAGSP8EwqCqg9geM5nS22AhxPHzQuFZbg7CMRTCCMFLrTtsU9xQkMJejQBtklfrc/1UzwGIDGF9LqepbDxG+hvSFZWaayxRLmAWs8fo3fuRYIyPwSxZqyBo3d1PPt25AtIPhDRVwyZmq8JTSIV7A/qXdwzzY+zaWw2DPcg7oQIzSOs6qE95M2FvAF5ahq9pCl6e1hTJ0zZo7u5LXx5PL49YieZS6PgDbVPxjo5Jh4TQioCB0pH6FbLz4IQKEwq3ko7HLG1AvUpx8Hu+919efnt5mzNSbOkyp5TJZIMyU46suB00/ntVJXteog0yof+JG+4w7OVbzEPT89SGLka2JE2zWW39VS9yuL39B+KFzSPWWJXyLVwSoA/Mbq1T4kGGA8Xo+VFLlSrfRGd+CRtULZElun7F7E+yvDuGWTcJYdBednf+7GikTALgYdm9ASMwOZmlz8wmsy15ru0MXFubktRUBzJ+kdWn40v/lsll3riV/tIw/a9dHacTSAhiOeUI1Z3VhzCas1gZshFgfXb8Yj7OvOjhKmQDtODpzF/a7gBZlkITyuiFEzEQ28VHLapIsLiG0FZv8UljM5wOpxpKD/DOZEclbelrq1A0IrLoUx8qarxzQepRL7xmjQL3pGoviO/tiGMTmgPWxZIiEbTJ0Un0SngC2gccfRCm8Tvg9ySJ14benJegWLa9ONdodXw9eghzKGRw/RgjWFJtJMI5GcBcmmQttznOtdN/KsIfv2LUMht6FPTdcp9XwPu+ek1vbYnnVKmDl6KoDDNYBVF13XpiKlDUX+yzRuq7id7vMrdNe8A116PNLLSKSrEH8k1s59Lr1fGVYn4IaDfBPh203NA/sGo9hAoENVh1NmwguQRT8lIsC7CDKSoIaYe6qdkAzLBQmIExEJI/7nEgctqYEBlmQWgZ9+CMH7wLLEGX2Yw25uT7Hyt74SQE4RM9mYfeRu+uX26OZm3/ahlXB4VGoLDcEiHOxh+rF/3DjgnQ9yaLD736PINRgRDunwij+HRnJpPPflE0A4ycLR1qnZdvqgNsbR+hmgSYWsKTpGV51gkP7tk/f4iQawtq0DXUNu7QiJhXLEwTOZxrls9XbRtYghqVt5EgMTMb0q6F2jr9GLfQY7Ns8r7Vg8NmMn32RkIPBBi0nvWG9LqKxJwFB15fmd9tW71s5x/hro5daW+A3ecPCgMJWa+++iEZmmmbQr4CvX8mkwiM7fun+MDW1N6RjuHOirH0OOUYMgtvRudnsKGHOZmA2USHi5YMhSy0zMdECrCi78W4j4MLEGU2qjb8Kacytu+WQ8fXvyoAfDCCIZRmPoJKUT4a0fCstxUvq3F0IrIDy3ox3ufUNXLWZUPXwQuN2AuzAliPESjWTXPNqS4IaiZd2XuWDw8q087lVGTxNlMyV2D/1wNR25DNbNG+elHSG99CTvv96yJfw0UoT3MKDBwpbEyp/Bs0mh/suWtf0ReuFXoDQSn3ou56eJEIkINY5oo42aTtkjd/GTtrhHZFyqtnTRBbfc91rM0J9PWTVgMDBU6TKhZ2nzn7az3F7TXHloW/yF7DRxetMnWFsMLI9fUejjGt5RI8dHICjNIqoVuRJhqt62UDeZDekAlneSl0fEsUeTPk7TuNznD5YHJVhQ66ENshNrT+bPByrcDI0+xmCQnktiEArSHKQtjnGeCEfVBwV6EsNk6ba0jr/Jp5WCITl9Tm4tceScpLVoXRXpaPrw0vFuxl1JWIw3Dt0a3Nd3OaqsslDKElv1fya17fZA7H/sACxhv50jXUK4OqBXAzfp97rXl+QArpIg5V6+JC5oOcwDPnNBIViMZJWDXaOfd5EQsSblULynbZCesLppeJ8GGKekUGYHxx6jsAmgJ9bfJVSM41P5YLYaQT0oy5DOtiOBd48Na6fAb7gbheGznegnL4qZ7NIeE4YiqiFt+oQRAlsLRARNjv3yF1PnhW3MYzZ3TI1SKCSMIWJuYq8334DuwvqhYgencG3jEX8y3dpdUxbIAnBFe5g5Lo4e0Btz9Dyog3o706iKOYdIp1ya5TG55ugsO6rbLYLqH2Zl+FnRXj5lg4iBgdpbky9H1UmEssTy4mNtlv5JAfUu7vJa6jUq58TAZ+47UAe4rxnD9Nkrocsv4mZFfTmyWGDNRuPOYhk78e/HCbzI/W0QKOSdjxG4yYbii0141Y/c1b4ToMm/jUhpk8ko/nq1iCsKIiHSDQDt3pXx6Jz+L2sgh5vfkBX1zs/umwZ0VIVhJ9MW4XNgMjKKcNkXDnCIinMf2p/B660MltHLEMpZ6yta6dlToH5IpDZ7lRJbubN+UcFIgb2GvQmeGE1ijNzbDDWSf1fiTxM8tCyxphuW1/GbPDLlr8x7vg3HCUBphBx3aE8N/N9dElw93rb5KWcrvEG+coxMGc0Ybv7LxkdlXimNfW0py4x9rM2zuABlb0SD9Zg+pPcpRdcSiLhJc9KheGBFa8Npak392L91N+iphG6V0xi+OOcuwyHZeZJy3sPsE2kvbf/q5cJ/S4U06WzjpjdDz36t9D8jpq+NhGykO37AiIzb6dlyzpEVRXdQRP7KT4N80FnGQ21fXsciixJqpz0HUuDT1cfKhhZpxeTbLP48lDeMhhd4qU5BNanQdo10GI9MfflLrD3lWPlZeM9uqCcvId9gc2627V7K10PHmi/XMie/0PUfWkhtCCqHKi8j02pQjB4HSE2e7N8BF7Mu6vo9uP1yrygUErKSvBOjwiV40ma8H4OqOIrXrwZrI6qfFtTUzP8zttDVpXPowz7OjCv85KtaF+UeZoxuAvZO2IWc1OR5k35QX3ePRkxNYDpk1ejQ4rsbP65PiPE5GEJFXfWvwEVYuhLvVHV1netyRDlMLd5pwXzSp1z2FxT1tZyIzGCQoWZURMK6tqMicTglTvz125PDkDzVG+hJ3O2UfYC8imipNFIJB+X+ZjnTLYDnx7nt18vkNI3e8u+7v2JLl8D7poewUoc9Biym6UUbJQH38YSnuuYFG8I9kG6qs+UCq1IHHbFRnNKjNbqEDH1ySBLlI38gsjUNlHuVjmdk5HldCzprQdC16pK8WP0OljzHY/TzR0ixrTh4JGDukxhWWthULsrUK2Vp06jMCuGjCKQZoMgglfKpU6/shVkZfCXiA9mYfgyOd5aLIgwSL7NLwCfWk9DfMVWFJW1TZ0+zvQK3fgGfpZHyFIfscFejfLcVEjShKfQGQ3YfssOeHEYS0cdXBjRfkLoY8mQVXHynbSELMTSH3HmNNFxV2t1M0KSeBKfQezl09wfV0OQs0QGFnZT2ZocnCLPbH4U0LTcklw2LoV2HBVZYQw3hLeYp5ziAtsTN/TA4k3eo20kOL1e6DkqpDOby7tNV3MCoSTN0mosqi8Hcg+7Be8/VHR+AS8ji0lzs7LEwEd9eFSR7moZfM+IbsBXYOeoujwbNHw5UF//mUmNsjzcnslxy0stMMFs13/WvTPm6jDQlNe6Mgy947L2+KEXH19obcH5VeFHmZR4L+nQz5Kz/V7k46w1QXjrDYZGuqYz4Qh/67NxaZ0fV+onWWChW9d++B5gXOuACjmu3/TaxXqiACu8t5FZxv2HyQ0WhmXoP2Vush91Fkw6PT9lPnsaxthjHnZCr4Tkt1UtdKI9dSq3K6vewikSjnfeB1QI8YkhUKXr5Q2SHxCeViLUe2kxVovv3lyGme5v5IdFKvR/UE0PxqN4V1dq/V4ny31T0ASFqNHRTocAi0DJvJRP4Rh2Mjbbe92udlxwdP0qZm17604VR7D7roetBVhinDg8P2sYfn47j7Wg23o4jgdSURw3HLDZlgoRFbQyD8roVgtsgplgQEKZ2oqSpc0f3lmzMw7y6jfyg5Gw2dE7+RfxdoFx8k0z+3JRqbBPyTv181sS7vZxgcQLcdfNsxA2gHe+Z+9wvwiI1UGOOrGTNnRuW+xeBlgHNrL3l0yCRdRjxYsEpryhoKNDc7AA2Ckttb68SOQCFu9k0TRdL9+yO37LBaKUrCAXBOhkcLIEWQth1T8zq0Y1qWXSk3mJLcl+vhd//B9VFqURTOipMtTsyuEJ9rsRCxojaKwrEqxJrm3fNVFzxTB/CrLBdRPlVhDV+gY1J9wkZxBfK4k80jQJ3UO6w5/6pew0JTwrCNY635W4W2GiRJPr16PWanHexj7zgoP+yd50vqKMjAslq3Xmqn47Dosk3jE52It69zUeTfpvvv2twNlU/giYEbr/axu35UH61w2Ymb8KCqPLr8VuW5DnYpLhBxn3P2dyswfLCIBkIq6LsICYUNdm2P7lz0qoembIH2lvW0tiuss4jVgPRJYMgWLHVH5T8AxxuapIUOw+dMoXGpXKcR188ztBF9UsL5L0s79oTqpwkjNqUScIqUErUjbwUnUOTObggnO+wviuiGGlnVeer8EIQh9FxEXQMh8re1aspbo8ti5pUNDcjMJJR0x7d0PY4cWOEb8AIDx/ZGxaY2Oss4fpuv6raSbvfj0yRQWgJGVcf1wjxJpga18NfWfMmjKwNdx9mLzJn4rFF97Zvy928Zdb8kJeEWI2R2leQ84cH3cc+w/kv4O4lv7ynLorDXJxnj2T++Ft+8GnS3MZ50EIW0aT7Cb+VhTedOUxSByTRynZ+dG7xK8rlOjfG83Nq2yuWnNda1kxpbcH3kKUSVbv2X1ThT914OuGS0MyRKOGc49TV4zXOacVEJx3lqnHgzXQOb9A/1NOT06bQ9UfrQEbfrSO+lF87ufR1jh3VvyGycbcgfIEkkOznvpV3cHkaDmPLCY45Xsz1vyzWHKVmOypf3S1JZpKUtiSPjPcLYG+/dOUrl7sgL1GK0YpO1dt7BYiZvZPo0OxXXF/AQO/16bzPVUsYt/UiZ73MJkNXLQgdnSD1dzxU4U98eF66hypxmAH/mzSAhD16pPXpMepxEue8YOpkILVtnZ8oPoxQxL540BE7fE2U+ilDWE7fUlScnfs/gnps+gHB8Q5wA8Sek1TYbEhTQDxdw0A6r8G47iKSIHXkgDCtTPYdWMvCVBSsVQirM4RJkOzAJXRcOPRl0bhesujof04+S/ETeomHVg5s2jIs775/6qtvcvZFRY33iHG8VXk64K+K4rtTEvCpnRhXJhB1M0flBI3l8FxR/qyLVnN4Y4spg8EdgbA4fqVXk2q9hd7GqUYJg5VMjTmVZeH9iZeW6GFe68GUnKz/Y7A9S8SRqadVQVc80GnjGYUl1TubA/JQP0CGKetnzVaK3tb3qXZhx6jWa7qNUkPGuezWDSxdHPVI4/y1WLl6DK6WNLerev5q10AoLciap2zEiN48NEWMUNnzgsrmaZW7G3WvzIAhBkHC4ubZpFCz030YIkILjt6i+gsKzpB4uMmsmIYnMAvE0YSNaikSLhu6jdeHfHT8XnOwEKYgQCUg38M+UpBgfVlw1X7k4wWS7k5z310QHfMEMptcN5WNzd/P9qJjlEvnNZfuS/VbfYsEqEx/6JTN6RsIS+6bo5IJeMJj+zKmL53nFqT7PfPyatN9fkFaPJ0VihPSgKreNTUcKhNXSQ0ywnNyrlziKuFjOzXn1/jTJ2H1/eQsOfmkZOta8DTaGoZ+A12DRA9NZGO2cY3C/Ivg1d2PgwixeSi7qN0GYq33yshmJVro9dLBHpfSYug4WHK5mrb6Wb3Xrll+ZJxy07wL64Q2IbNu1Fu25X3a/ZbV8cr8N1Ky/0KGyyRw/Vue8SPmkFxobu04ImDhKUFfG+CVVl9RazE3IKKxRr41gRc3SsINT7UhBOMaxN63XUQ4MlHZQH4mXHQNEVGpd3tUE8V9ReSNtGI6Jv3ti66vab1a9lDkp/xqwB/aD6hl+xH30UGZ0E3mutVRdUWRgweBiVp33svLYMtN3COaNGybIpAajzePXMdBYoBVcjrSOHVtIu4009BKlvdeP+0J/oyi8BfZmwZGhYymmw300qL+1j0Namnf6yh/PtyqFPEAHf4ROwYUiRLyEL9I2YHmfcSY1+zKgQSYSMe2MTGiskkV7S/nNb+VuGNqH4J1XN5nDQViv+yvGW0wrhykAjiNet3SnvBG/4cCOy2nAWi+IR2xnPcpk+Ko0OXTLfmujx08h+mfDLAVpB+evl32Ukaj086fv4fPYWK+aHDTnC0n9FxouoLUhrRplwmCRqwQQtk64KOJ5w8Y35NX1DSPPZaI6pQkhgLnExRnIPFFgvonBEug5lOhdrJbVNphZTFmB6UzN4AYEsx99Z6b4or1hQTcW4RGztUg/Utsydb6eiGR9IUS6ggdyJAtiQSP62eP6KlwELsp2EDPmKwOaioXhFRgtyjPciKkMHbgCFc6a9dtnd8gx49BVTbfthz4xTdtu1ANGQx54RmiBoD1RrKLvG1M2EkEx4wWhPg2aucL4CPj9Z5fGzCGDoqtSkce4r6XUDSIu/iNNwtTaM4UMocoBK+L+u4WV0YsuSSY37hNGo3th0KjBgBAKRlvcNI6Vp89Lg7vgN5UcAyKsQlHyTm7YdAxpntwTnhwl28hEfIV5BHjdxcCtzFulGnQiuejmsQ8iJVdwlueLBDRCqGtLfFG7zQBieMfQdnNWZ0Jf/rYxC1hMg48C16YwyJVgsoCg3Geuhfvgnv3flBpB7b8+dUurjdeiDmmN6SsUfJH7PQZgxUM5EZol4SW36gqY4GgG3xuT249YU5eEiVal3URt7ZlcucuPhSTlvkx92hyNKzslkfF2+EcDnhg7YP6YCVXP8Ih/RjhXjx7X8QZnuhfLSRPzCeOTgbqPiLzKqozyUN3y5XHMRqnzhNASM+IFjOQixKj6RmvThR8HzV6t6vpLRO0RVk3JPcUg6xpb2hYaa6jsDzSc+Q0EXOiLqqrbzAp7+o9hJW3pjyOOntppz5iQlRLNzDd8t1nPsuKdDAlIL5k6sA1GLdp+fRYEOxa8Un2rrE1WV5UGR6vIya7rjZ4cqHRe6re4gqNaU/hzWZF+sfBg34+7XFkaOaudf7TovpMSY7Itac1+3uYTEexTA0eGw0+jyNDiOz2Yh5C9KfOf7bM4HZ3MalgGTOMUAyG1BMaoxW+LKNEwk21oqQwWMcrsFhfRjecLXNarsaxBZyoaov+dxplno351L8TKAZv4rm04RQOYt6JMNihmUCo9aoNtBmSvJIH1/1+1y0Smaac9KDlyGOnNaTzx095PfbuSxXr4RCNZhW6YOw1YgOROjdK2zNSp09Tz/AXJs+HvkQx3Armv30YYco4hRR6mdooP9yVWctQFuueTAEa5USzVdeRfKEjO/IksEwKt6dYvaC7CrT6cqrNsn9bdaabXXKha1yQzA5BD0AOIJaJ6+s5YxbhyiimwnS43rvs/nY/+cIYNjXNwMLQvY5c1/K7CJ6w17IfEHdvF+d3Ww+3SS5AySPtGjYpJ+nfViLLiO7+86LBavcUw0fWQeqRqQwk6usd7C2u60n/Zd+RrUreCIVz1Ck8yH4x44HFbT+a26gfggDQ2EhXYWUVU2WlXKHaUwhTAfWAGgK7EH4xpew0/A8DQyC++CeIsSG+RlgytAOWCp6BcHWGgifEM0vSuOfNDvttKYJFmoa8GSwILvWMvJCawPHKSkl6O19usumwu0VaWlxxowPvBgRKA9fGbhnvfF1BF159S2kdRCH9TcZKeB06oVP4CcQ9lqWOniae4NNnJ6y90XU+mbcbazyHeBVQ1d7LXRgeVOUv5XLm3k0sLf2QeG2WYVBiHsWkju+UqeD7rZp7blktRbpUGvPvofUELaytzXUNzD2jGlxnUY3M2KEiGjpYbODRetiJPdAl0ynTt4NkAxaHZ4BVdRCHr1dVCrmVmFT7h0duMuPzWNgtFarmFLQcd/hwHCKnGJrO8uLEPaMXnFqqNChFiOW4ll0pvyGah7KtH2sC4TOeJqTYavEZ9kI8cL6HhCzsx8hITkF7u1MQ9Vq1GlG1QJSrk4olorlpSuuTD4TKDGgKMlK+881GgJcH4UkB3+B2dMMuXn8k38fzpJkdOIWdsUpAYrculHKQaawYA9CBjD3EEUA+rSPwxbpsSrNCbfIg5dDZVsdYmXv1B7MA9hB8/Yh8xJzl92URwvZLil0rp9xEdYgS8AHQeXtAOBJkcYdW+cDYXfgq+KVUBqml2UWzdPDA0bPfmZEL7NRkTDHORFv7A/XTLA08gQFMrGNo1iWtZiG6lBYlIoXH8yYlXR6H91sJvEiXQVs4gDMoQNI1iidST8pgQCLNik9D6qD/DP1nVBkjWgAjYGyV5PgmOXThHDS5dFlf3/++4ygxpv/x5XGc0hB53FVhchbGv0WxDVBHcFdSPdKbEaIqq7nixJWFKc3mINX7YGhrk2TfjDlVBBcK7cgp2KHrkl6nxMvqI2872VwWJOz6n9vDh3zz1btOk4qLwawcHsF4BMELFpnFw/2HJJArdkPSUVVEy1+f2IVX3KhWCH/k0/yfNREdROtj9rPRhsXXtuaBKCcX4LFa/T4OQa2ez6UGLXaAJGiiWtf+4+Q7RJRCWc4K1ttPs7Doaxn0gafFv5GqPydFt4z/kNFVBTs1n3ertcrDXq7mHSu4B6svnxTTaUsEHREZ7+/4xxYlcsGvCK2UThWhmNYN+RGCjRW/6aYXQZa5yarW53LMfzcGNz+gzHfOVZavXRRWJMTqEoVBLCVpPhTnccrdDDJGTbopgWQItuz8LE71xplhU2eX80uJdj/Qa5TZsjCm+U3cmA8SByf9+tZ1JQ5U5DRMvNhkRurxc7deFgoPDz3NeZ9X3HpiK746B7swyoUyETxn19gwRItq4KY2TJWgxIQV1p5MWjJhsUKQmM6nEWgTVrgC1pT+oiP92nndAOtDTrkeXhdXd7BPaeP9mwBtfN4uHLuTpZdcVIDKUgiZxWYG8tcbG7fYJ3a3gkdWDqBRcYEccpiIs4ICnWoSXUkllvU2UFgWzuCUGw0VhxUyyivEbp+ekF0JbpWCWc2tILRAiIKT3p+RTt+Di/JcbPq57tHXeM2vLfNR9iNl4ghf3JhMKBjTkCzza/oBvsCJu7y+qvcnwlj8Fv4TRsb37nDhe6vV/Q/ktznC+b2wRu1k1LsHtTkOZ/0azaS1F/r7CmslJiu5eN1pJ4Wwd38Z4stN4hmssEZTsWXYN1qUPnlnrsa3FC/eukxFCKnl7P3brXmHDAGaTOdSG/fEDITZTLf7iYr9SepociK+2EOainfW7nlk9HA/c2P26b3+tYtieYA5ZjqeofHwOo30WcHogm3zTW4z4PFcbgrAgBgL3XTdjiWNBClvzrdCESnaI6DgSUUhyRpPmxHgBsVvs0LDjZTfFHxPRK2wKCwAyt6l0dWwHBQIE0gjs9wQVTTvuseT5UNVFNWa3C4os0vMlDBfxipXmrJFKdladfy/94fWKMJI8exAL0cMFvh5H02Oqlye1LWMdOb68bAZ6K9HnCV/rtibH8GQ9qA7AUnz/Upi6S9KafV8Gp3mNPAIHRa2+XEBYnOLRt1Xhb851HShPuOx10BIISFxutShl9cPfWZAapjZTInBxcIgIQN+gJdplI2dlRESiuu9Uo0vN5aeCC644i/A8cNF6/i3V7qPZz96q5TFai2HXNkQP7SSt8+dqGhQQ8HUV+uIvlArXazgyM3UKJ475Dw5pRys47lSrVHaC5/7vRQ5x+LPkVwSdmXlJPON/1sURGc2wl9Uc3vonE+JWOqXRzPyijzrUzj5qTX0LC9rjfwc8BU9/CutM0v6B3oTVO2+GMZUbe6c8kO5T1PBQeQ/0S5MqKPOhp82xJkyzwjQK1d+MkqO65bKihM6Nz4sE/pZ52hOvdb7TDfsj1/CQpLvwGq/P/EBqcp+WQwpbDeh0ojfTi367SPSpFzxeJJxV9u+sgv155/UqsoyADIpsEjbqcZT6+TBAM4PM8AbFvMgsWMxfz2p2myvjHPb9y5qYuwJMovHf290mfh+W+pScP8gqiztjAnksJjj4IOoEY8ukAvllaN8suWHZFq9GucK3p1jkDkOXphgijlXzMM6g0F4Sa+cQMwxkMkLzg1TSict2HQ2uAf0LyjsJhKERmjLiAD613wos2eS/cVe8t7JPxcg52VV9TCmW/MhXTChG+vPXt6pDAFRSRd+0FQygGrQy/5DoPaxUllzulD4ZGQQO5Rj4eFIV+WNy3Vf4btj4AMVXDpCvRjRRq93HgIp8w6dLzgRe1o/bo48xtManRJqKHJwk7XUdxsTWnkURVk0YhTTNcApL/rYxLacm/FaylM4VxCmGO+s99O3C1dsWGGjH9RM5xbtSvowyEoaPIoH9EZw1T/KCO/96W+K9WfJRAkTbWcbqsLvghNBPBlc+bLuJxEQLsfYAjijZPssboIiTbj9Ffem1Mv/OEn+wfT0CXrLckz7bP1SNdx60wwnYc5r7dQS0jP9CXhca6idAeEmBeuRyMxeqZqzqaBWQbtPew02i8PtwZHW/kdIuRT8+rU2hqqR2Dj2qxEtvaEL8+Vi+C0/gpP5nopNmnjtzg1/shS6BQXVE4vFM1pc+qhadTWcqh6fW1N26qQEaUpQv04bXmAIX/AwDweeWS4LNVzHEe4rkF6wtEN3OnRf2GFbIKgvZtqHqJcIKhKsV8ycPjz70TvVhMKDheJbDSOhk/iy0tsb5/+/P2HvFAKNMvnSvg+6CGX41/2y5yXlJCDFR7QUSAaBHhAw+53jjXHDj/cMxZDBWKee21/0L6qiUdi3GOzjUe0G0xAZNw5vGRDJujXw269gDZhmTLaYLKTiScGP9sZsl+aCZwqWLr49sWFJgdN3GxP3bkzFEQkStV3RQ/QG6y1OV+UiqCarBNr1N0g85PTeAN7rgQ+KybRUMhxv3FzlVn32vjtF+UebiXxHGbWcFT27VGTJbqANL4CNYdqYTDn3q2FJaVLwg/2h+eJY+3KSR6t4jN9BBMILx7wgL1ceWCwr5/PPx/8Z66cDuG35J8MBLUOESMjILCLZ574BLCoe7BwhU4cF3TPYmo+iHzPYsr393E+D3lBIivS0quAm2SQk7CdMMz3q3/AYrMhj+TgTOFHBcKqKBpdwuxkhPSJ68lNzCiJqPHMlzqBYtjWJq+LHAsEIDmxFXaTSCAESQqExWsLV4r0D53UrNjb644i3HALxs8LVnOZxeTx7T7bjEr2y0OPVGoosqDaENUEC/7ktzNtgzk7IZhwrdmCFdeP13RNzkNpzpmQuQO0/NzafrNLllbQDU059EZgJ1MF8E2G4UwrcJxqDBKJ4AXVstonkNuUrizIIv+qezF5jMuvvwgh8H88sUqk70wvvSlV2Gezb6TefNksienIiTBXHyiQgRUSyZZOoEqlPZ9/MIIRGGFLkxJB1iXfY7Zvq4IDCbb9n1bPwFQWZdM9eBJgUnQDzfsjfRfA4JCBbVgd0j/pF2CuDxnGdr76fLxtPGrAxT3dR7wyjNsDGkikb5VzgLyVUNdTrVQLDUVE6x0eKEjut2w2WFge08mO51Qfn7Qkg88ylH7TNFVcVV01Wx+S4fpBo31zH32E86irYZjwqNLUQnIVd4UmdnT65wy5JS4rbKY6xyoVCm41/ds1vdne/hKs7HbvXbTu/zNB3+qvv85QdHFbbcU9Tt917Yj+zxLJsFqHzyVDaZ4RtTwEt2gL/9omfgb2iVZDQdJHWzWRrdIm5rC0cgsBXiE9BY9tHjJK8La4bcxjxGR1JnHAR2k+aDGaLRpaOa2TUZ8b8WTIc8sjEB5S+CyY/VER39thL5z4aefZZaGYz9i/nkC/DSFsJat+wzutTlKvLKNCP2rQYGXXCj2zpAOsq/4Sxa/7IoWsD8rwRnKBcyAyIC/qTedYCc9fbdqeGmRWfvDBlG/bZ/FHrTNZU3jby7hFRNlDfVQnDNQTo9xhykj3Q66woVQSS9LJNYOxj1iKBGWexTipaB7Am6rk5hFjdXtVGoS/xEnIaw1tPIHyA67LIElaf5jjl2P54Zj5fjYQ9jJU41qcNFvnIdrsXjfquvBgYIV1ErcwZItQeNZkVkUSoVvNIwK9idV8egokL/AtfFGk1by+oxUDGp7n6A6xWWfxrpOMPZQiSFl+s68DSVCZik+hmDRAqxXLiNNpNrH/yT7SRnItZ9ljjL3P7LJomfCibWiFAYojep6YFn6cM9Ft6envBfGV+379HvfeaJYJICdKXDRidtwiWyjs0Z75/Jr+i1daHvTeVKX+dWLYD9Itt1nWoYYBNU24Rm2E1Xb9xWbn1pNfDa6oZf4uG0YT6BqdlXX5nElrBfoXdNym8B6A9JHkpJZXzCPNA4OrakmkPaOOPc7C8IW0at14dzAO0a0vZ2StUaeu3jSk67tYOhd701EIu6/cHa1bR19usxdK/2YobXt/Ql4ZI5kSKCmO1ogebiF/M9U1LhcMwDLVgV4WUMeHP309TyOs9iGI5o6s2XcDMp4Z4vqnQYCi5/l7vbOp2qApr7vYRizu/LlVElsqm62PY2EMp5ybt61Xmf2QsS7K+bY3JzXXqEQv7IEqXxG2jp/hcpcZCNOKJRlwk3FuG2yFq6JCKGYre8BpuhiNXjGAdn0ENxM+BZSx2JheG1Tgn8cB1fMs/GVFiTUixhgVZVYlCHpuGfMZHt2f+pPQM5aUZfE26Opq7TAsPnpudJ/RfPLaQjy4u3dvWhY2sS464c3Hk1dMgHSQ0xs/d6B+82Yi7MCRpFL1bJd32gyCODxnfAobixX8nlY26pgoXRkhE5zjMUcA/gi/G6OXX1FrOHGyS3uyMnbw8habYnegWSA/CSMftY4uHMF2YL+HOYHNmJ/FeyH7gSVmFk3nAYVgsBtLcll9agStx8WKT/FcYlm7UrvKcpoI7MbYrN2FT2jdb3SHUEzHUxp9YqUoGkl6ZKMwUCG7pI503jeIj4kWL8JlVrPa+thc/cvvzY15FgJIQNHNpBNjGB5NkQMDwwTMB4PUSSecQ5nVU1Q7WZ8WA62RmXgszl9FSopL9et1XQG/tJaspeiySzlW054WQhQepLAqnETKP9GtYlGO+juJKlSlL3ZGeFBZMPHtVzSEqikqRjuXcwCwB5gCbLy7IJLvcfwzLR8twIW6WhOkYGb2+RGlt3q5/DtpUBkWhLl615wRTwBeSuydb0JuVIT3eX0etXL2AhTVjZBa4HQ2Oi5tDpQ3Jyg/2JVBfSS5eDklGmSlB8KDM/7+7PuLt71mj77pivH2DX6JC1VqCQqjNNkZ2aOAk1jNKStvMq1VsZLUYDJqdnCorkGegWHTNdLa9pn0du49uVXBBhTLONhwTfHDp59IE05k33eog5ZMcnng/K47cSzfvwE9pH+7DhxeMusESoA2IDGtN758VcQcVGUcPGq90rp/jlcYIBt7ZJ3eCNICI5IvU22RCIwQW1fwQujBYwSlkof6ipXfe9OXEr2nigxL4xVIdNzaXTCjy0kEZPnaMxJaba4Tk3OMJeSa8XjZGzXmweL4xVWHOnuD9/MMShOtZ7YdOfdMv9ABD+R4sgNrc46+6PFenig61iT0unzBmzf5f4ywckAFKNMDGiLuF8Qfr2y7WPLB/bxaQGqq3YrPOm4xtctzUqXmsX9EBHPcbiR8XeBCUv7HKI8MY60KAtHEBPVuK1Ns3awDkDU1dQ17H8Dxtodh618LcWv2agmt0wa7h5Nu14d0wB7tqF3UVedywFcXQQu1gKkBzTFBafPnRpi6jFmqrOJdSPLJm9f+xR61TOTfWNSI9ne2KN+diR0sUJp8AzH26+psXO2d+Oz/EGljrHf+tUi/wW7PhQ+hqdzhb7zy+JJWaP0PQnMLjzaUzIQMwV3UVJINy3ptBD+NXL/bweEiGITjOYvLBEBPdJZR/yBTnXDDqzU350DHK928Fiaid8X4TEh3jLoBBw4bcS6BPEC7cQ4lDFZfoCm7PFcxSAdvTjhNdSfrH3IOXfAlIn0PD7YS3WQXto+10RYfx4Oj9KKaDTlmNvafsF7x14ZyMbQYCN7tSI4IjOr0qAOsPiDVv9Mds7z7/Oa2Q3DzY4IsAka4Mb7a4GWn6Q8LfsaqKQRP4krzCctYfrLBZtAoBATq2NFqR+NKrS/q2By1jxbsy6DXAAHhOa84L3/Lz5/x+Ioba8Vqwj+U/dUQdlS/r2kQTeZslllFgjTq17T+USJXt8N7+wZwZmcUInA3SEUPM/qEseJJMrOhzB4puT4eUpluOL1NYIjxZ/XHGbFnBZcYNzd4lLI+UBPzgjRpgTbsCFPGTf3VyTSV69W9QM6VKpwwpSukSG176NHIRYB1m/UaSIrRAT7+QixxJLSRsHvEQir0BShbNkDb+9E+2jfxtjH+cI4WVC9MppBTk53hHkmjW7cB6jBhKpG0Z0UG+MP2ryLwrM3bKaVlFT6kw+F09vg8pXUBK3mzf8Q2sKgQzCmtc1p/UpoimyLDZSFCUhLus30njhZCEBdtuN70yExz3IJ5oOgak1QF7dEWyDTfVHmkzKTDoEML2rB4eR/p+57b3voQWuLRJf0fUOVXDtM615YEiHOTimxRgUbPgV8MUbNvX13QNok0RHFMNFsWwJDK11nf/JU9EwOAg9F+UcXWTzUNNx74D0IQFYbKRSvbq+esJPaiBxtZQiCwR1M5Swv536tfXAfzv+1LPpYvr2aAFNNP/vjt+uqYpQ7qGQRL8//oUDQY0R5cJfjchJdmhXbOTnPZDoa1XpaY+GzOOfaMsXCfri9FJmwADzuFEP9Fh6xx448o1pzdXDBZRhktOFInQOiYcweSdHd3QrVs4WE5XS3EuBDRMJ4aY/gobJxbHtBwbMClaMcTVxormpTqVEZIvAE+K1al701YKgqg4Us2gs+Riz973iBhFooLaP4eXNOkeMkJNV/ZX3Bd3jaY7l9Dxwd1MfNxGQ2yQQjAHpUbOZiTv9XzUC3g/KLV5Enz9ToLnhzLlxwUuSfCs00g7nQRcVGvuDAShkX/vycW0LWwhGIBCj/nDwTI3O6hUXpUrdLLtsjjazFeRd93XfM+SeFA4PVislUJCv3n8/mF1kwOr5exB/4hgSKhdWs0giZG3g6/X1cspn+BnPCMgG8osiwa1vU3qjPttEcTlFKkU6c5f35dmgAUS0QS1ylqwxxxxYOS6vcvyEYem0TxKP4nDdMjlYt5KjMbu+GnQ58s5Gua/zXeT4t6qkLbrsFGOGnTtJBQOBuweaRmQL/z129dsi2KkKnTo4OE8PgFoGzpENCk4SvSpTycm4JJJ1jkazA+wsvuWHoWYD7EvU78hypKmC04ZWvXHWPp/gL2ANfm6nUby4pSyPH5IiZo8T1Bf/G9562mrz/LaHhoHjzKnFOl+KHHFVnPTZmnEKe+uQcknpNFz03fOZm5+SCUf+LZIqQzrMOw++P/1dTUwEXN8x6rveoTHfk5KYju91MdA2kOno7vnUUHuDjjI4P6YjviDqSAPQ4ELHGfL2hPlKCON6If3Vqy9DcZ1yeDANe7q9SJLDARy98dwI3l7fn3co++zSC9yUhp68bQ4FP9MuADHeMElTl5Q52a/OEZLOKZ2Y7gbSJYwAriFM1opHocPgI6rp6tihLINpbBpKqMnlLwDBzEx9FCrOh60wnc4bCrtIecfH8ul34fvXH3U2VmTP3SIJkOTMD17BB4BFqvHICERRUlDeTjUO39Tuv+Xy3zlRBP3NnLOPoJ0RPxGSQFlaFd7xdjshC6E84NPWfgTb9rB8Q7P62o1vOGM0fWxxmGMxH56TyKaULvr59xP14/qnnR8BrWeaCwL7mpB9JpQ/8QRJur8Zh2L5np2C+pqc19etGj5ZoebyDxTihDByZBS/DjzNyvH6zBHDpXAb2LAckWerOPMEwhpZxLyiQIM8SnvmdAOz6228laUn654khpdEYWxLWMsBHQ+PIhgjp5GYOPip4Wcmw+tLrYPqT6/k5K2U4Tzo3pHYg4fHujhD17OZckoB+hFFohqZ+hY6gEEAfogtHm04reEjte/yhkFeRNs/zMim0d9IQADHUG9i/6SBQCUFVDUSO+JOst464MRROPXPHtpFM8Zx4bEIAytejBtzpzKB84dAWte+p8Lfh6mG7xaZXDRLVEGMNjf5djh1QilSOrYq1iC44r3Iz8OC3gsA/D7zX7j+VAw9pjU50nvFDKW68zst6/7TyM95+VBFBiG7vfOi240HccBvcwGkFikfsnW2OQzbNy/T0SRbnCqnmLexnLpNEJGyTsjH4NR86nPMYIuujynQeL0jPzk/2u9g4pAxBwBnan78K6PnKJ/afdZKw9Kvb79+ZeiTIDLOhH3aRKH1US5y1+0MiXr5bCvxl53oo3eslmb208VdRdkgvbuAHtpO0kRCDAaGjof/1nHrjQ7LLJdyC4iAwBT3Ju0ASQnk6btWztp9Jy/PGoKR9KLt9FxlRpA3q8sURqjGApfPqIpJ/lv74frkQrjP1o67WloOFOgYPhVrcG0jwW/tE7IARuZ7RKxtFFt0fkX/bhZr4YwPsUuNExTM8ZQO+0EKeSh02Aa6U4lpruZ1YlqICZMzbdr8rU+wlr1Wf+rsICftDu888MQV/IgrCpbovh6VMEKMLOb1HRc+bU4+3Pe1mc3lO76QMwhiZUzlX8m37JIOfE9tELzvNkwgmQ6FwC6Kxz5dJUwMS0E0swI5YQ+Xwj9mpPifCJbdUzgdxcAdyFQyM/oenOYWOqGT1fWDqzmcVWfCoUgHsPmOFnUxrq8JNogSndHQTosEZbxDjXGYvUoZfvVBoYdnVXe2jiikJIjOuQ1Wf516LyDWsU2X2+tcVwxk4PheGhKE9t+hIPmYMpnDF9E/hri6KDsE9UhSnZnztfBBWoRvuumNRZGLAAUXj937sBAagLn6F6AkvCUigQOY2ar6UEFvp2vaifUZlEic0VTX9SvRbyquUAT51XUP5vWu9bcMdP3m3lpkoMmaofPC3+X//yzCaYWvX8KI5hetXaKQKUZhpPK+i4cSSXcvcIsC4SRfKzRbHetPxxmEjSep2D2TMSFmVv1WsMScvs25jo57o6tj2CPvJfonmflWl11YQ6A3wVAgO9m1YtzENWaWL3Su6Aytu/xY9YqQmv8xa+OoiJw0MlaUonotlYEVqFW/msa96kcEnx+Y6cWC3O9ZIW0XntduBmBgzTNkVWCzBdiNvxcTU6q6qN5IxWIKQvnADoDpYgCkQgIy3E0VO0IbSu+1hVYgZeHbfvGBCTKyAAJieEHvvjp5vhZtShhuB6EehYqCo32K0b/pXNzqHmfg+K8hapnO6DOCgGse+nWt5O+opfLkjsIxrLCyi0DKUst4zPg9V75y/kWEGGte4Ny2wWIrKS5UyjsnytmONqRpE2BdNIvzWS+leicxMCU6748cLbxRfG3cfbgdTIf28LHwWIWns3i9NRIJJ2A/W56C70Q7CQYeyOABjZfm4bqJS3tT3oUzcqinGA60JSKxMmCShzdfBbL2TVFRbqNa+ThEofPR686IQxB9FnWd7w/xGZdXSHS0tAoStyRnd+EEwKuuCKQPoCo1ajCRdXHBkmg0CHaqpWtNFqK4/dtTRNDjbCZ3KaJVTf9PSSOmVayQ8fle4I3yr4hVpH63O+Q09HPb0Zwy027zGti55IlOZ0/4k/9of1H8/1aEwsvJ2F1rcWS1yUlumEQNPEzt39UA+QynguWshHUrkRHFsg1fMBB1PLkm+RwWAB+XbRbQ5fDSPgXqcQvQb/G31iGzvuKl3kAQSFwzAVyf3Ltz0JGBmZtig7rGPlxGAsPnvNdWUps3gp1twOQY1yWSZO9TX2Wvstj57MUk5KhPTNIydyJA8ANW2fGhFecUPnQwcLkrpPUHT8WRKUuEd461rXH9LhIWfpfaJckwM0AFcITVCwFj5ZyajoikVxb8LqoabIBsTDQlEEekOfyXAuorNLKZEMxt+VANZgTB1B6Xoyo9ib47RlOz58eZeHV9mEIrRno1XJNw1f25QZh8WHP74UcBEE+xQYbjOV6iqpFlN+2P/xEH0c7Z0x6Za0JEXGEalnzmS258ACJgRcHHYCwrEfE/z2neWsyI9+lrjJ/ID9a3r2PIvtX+fYB3RsWQlLNb+dz8TfGI33yogfqKMYxPO77DlzItD7er7K2LfIMyDMO72kLh5Xwy6So/g+r6VxCrfIzg2HB22pjAjdwzWywwXB8F4n0/MpnNoHSENUnhVYYgQNnEwc+zV5D5K+Xx2Nkr2+EnN2KtZozOqzrvcJamuyEkcVwDI3e+jbbtEcJstPr/7RnFt/V1pCqffLnrrFa6l2JVivOiVBOA9CYc8tAE/7txTZu3SNJ41pGoo5eJVqJOp2UxCI8wUFcxgEsyFRXLkbaOeIKtzWtCmf0YWdcbLIbKccZcPKiYqMh26ZW9uJScW+egYhujqqNzmG+U4Yj7wsdLQ3qmgfD/LSYaaKTKBJfuoUDC1zq8r+RltSzWl/Wsd/HkxzGCPGOuhWqveCk5Td2vheqEWAT4TnN1o00i7s2UHBIxFHLASvu9cStjTbcls1BX+mXxstR8lFBRf1LrGp683fiYEIJ8Obw3AEPwFEUXMrlQlNjlBmAdsXZDRuyzpLLfq0pmp4cVYYdOFZvwp3SEb9sOrVe9sPNzLesuCF+OGSyLriRstCugoYbTmRuegP3sSKTvRFX/Pysx4qF2L0oUpc8ZuZGPRudT0wfdY69pysm17V9s/e8NBY/p5hZtUecpuvsLDv3o49bNF2qmPDZDFGCkJXa0rFC1lPAyfMteOYFulhfsRPRFPRGDonbNtGSFrWHNBXP3NF5TaIh+Bgop2tvOpzjRT9cSiqs7c9x5hCQ5Q/E5Pe943jd0GmFKsfjmHHnFCD/WZtVHNV8NMs1T4JwRHT7NOYOH88npSZj798AtzvsjcLw57s9SlPKkSNAKhm4erC3LVEn+Sy1liH4O/5JIVO6sNbCCULvjwow/NjHqUeYEv9k8nhTd3kP5cHl9+mguDMw0POLD5dS7ZUI6VwW9GRY5spJY9Evillf/TPcC+/HwqQZVbrSNEiVbqtrZmZPJq6Xi2GfcX51qkSxjVpn5aohhY4X8SllGfeBA4msT9diEfKBJFU7qPJL3pInsCFEM/CuA4QL75kFdAggQD9veGqdLQqsrJ9e9eUFXj6kGrl+fUY1KMlifgsvrlF6p3diHtZjeJN9M/ewVnQfb8HSypK6dmapFwBopuZ0vjqY26LvrilOgJ4XqWbqoGkbzL6+QFpJbNplEjIWxK8wt0OhvMKfI5b79W0PCCxLp8yp83wlxCiBT5ggnfmvbq1xtLN6zbH6k2FBdFcLleNNBo/lUx6aJXue/W6qBQ5OgEJwb8zIfxzTiivbJakm0s3G5KtraG+jr64FGV6Fm3juL3/dSfLGpz4M4zLfZNvf8ni5u1Aa+GANj8Tq0Hyl5InfnPJe8s/O3R1ZXjSk0eRew7oyswJoevLVtso700CXjr3yb9/X5PnWWgDp45TBGPsvhfbtodv3BmpPpX72t280j9j6d7BgKsMHe85bUwC49bIvn9CtyeMYPA5E2/NDuIznBUacusWAUYSxNyTuv7OdPc73Q0Z9pgiBOpIn4cUbSLFFXzDAGHlmBf8EcZUB9BO9DEMzRuJ2Z0MSc4s18SVaOSQ4IMvepIaliezv9EZRwNPCmtJ8P+dcBK9l7vP0fyKnk0exeN+Eog7x84PK9GCbtlGZz1asaLd6Cn4DbPMSgrIPzdO8gp61vkJU054q4dop1HKwJS3LqWktCOA7U/lb+9BGRg14AoM1VvCkNqR65eJ5pjxdw0wxgq7oix4X3zgKfa39rt237Mesgl5x9367NpiKYRkjQrwAr95lHiTbG2UBAwUYeyEgcf3IDAaqYUO7gcgFgu2bekQIlWUtsuIVJZbhccmgj15LESlGIj0DGJTMuliIcnqdS8vgJ7p2wg1vJ8bbfIPIv4m1Gv5WVJLnYlwYplIIhCZiTfL8sc18sR5Yfw11yqjtNMMLXIhw8EiYgvD5+MgDGcpWcORR4vdE1QKnpikVPutOXYFs/GgLoYTxevTjBGfpY0/9N7zk1oatyTCEn8dOTRebwWBBGdA2Jvmew0o6LZN6xMmHbcAKf8udnwf2pPZH2lGKWZQJfKjkVcWIxLYQmR4VcQCvRhcaXhaIyWBgvCG4bNY++YOWvF5KnyrZ51gC+n69Eg6xch2WxZa2CrpEi83wT2etPpzye23aZg9u19a4X6Qsd8iQ5fF3GX3kPqj1TQ9EaQ7V9tyEE3C94s2dHx/m88HESHkTCP6YAnxYng99ZD2etrcJT2XbYe/OpIltX/G1CDJdb0hkC5YUoqrio6ogZyVotvAC9wwckotxwMGJ6VpXYV0ToeqYxUtqwR0gmNBD7HLcvKKNJqk1iYwRvm7KWtI3fpT++ZqpkEyEX04cHyuVYAVCBdIxg1cHfK9lCH+5XlAAjtl5oEVA9zT+6/ngeTOWdHbtXLNxjdB1CmnS5GImC320RCYrogEpBhMtzjDlJFUHL3uDJ2XtG91LGEQS3HxUCT9vInFPKxZm7iDeyHjVTHsjvyiNXHsB1OFAV+HfdhmF9S6EgwCwZYYfilAKM6I+2AVm75YvunU08NhXtFSa5Z37KQTqUl2QnB7A3pSsdJUQfp37jVUOIThNKxdJE+FSbrXZSlguDlyUGmkQszS705VOSsnVqu91Q9doPvcPHrfVUERBj7FqraEhNQjQ9PWgJoAm85FWQge1z4nhSrXwUIjKAuwi0nxGvT3zgT0B8DmK1Zexcb6+c+puA3HGuuPa3EB9QsHSTr2+r/UB7lFy3jAeO7vIhVG9raRum1dyQD0GueDhXlRKqLbW0rWxu+PuWh4bLCpcBikuRW273bN2h4aSJb8C5sucXgzr18sumRoWJlaEBglnTry4aJGbhrfoQrJFadLthaNtESf7sudg54ypXqCjxpDDDrsP59x4y1Tm2vS2f2mvV6SVSjDSk0mTzoXJtTWE1Wh1FdafxeptcxAKgg8Me2lPVBCxAAfX6qepJosonrJlvnB/Zd800s6V5HZywx4YmJ0GStK8GBJaJluxGsQWp9Xnl0rNHuABRZKV8ZYU+ldtZPq/8m0UY5eDhKW4QW35CTnrcyFeomxAZXWWxJY0lC/ablxBzDuI5obUSaKvpyuHOcr6kaAresRd3Ei9fpBTPFrd+jGk7slxqsTmquIGsNOk0PqeBDbHwdqLFraGgvNhCujKGnb22J7RfBAhHmFEaQt+G+X7eSfDaGaZ1I5CGmj0TbIphpXL5OVEpY74MF3ifKJnT+rhHXIP+R8BngD6Eo3IFIYurxH/vivP2NeCrLu9/JDuQ71rNMUFCGz0Q1/OHVYsjRGvV3woOML9STJGRdc9vStZZLsQhmibFWUajjAGOiIbaQ+GODMMRDX8XjFrH+mjWtwdv+fR6+qCmkpamcgAU9fAfjT43QcO7QnTOaf1tzUzfxENfW/Hzx55kBLvgfNv/NbWBslrOnIzpyUsu5RSMhMyRVmVTsoA9x3KujI1Axj28WC4F521CsM24mYC6XKF1Y/nhut+YBj4DcXLoSl2zxqza5E03DuDrR+xOdKqfjZCI70ke7wWoNpMIgu/HPp2kR5hyW/xYlURVJUe5QRHuZ6RbzD2sujrjmTfgazU8sOVBrBNgSsc/WbDjQQcFGsLYpCKUjC9dgpsOGItHL3fSOrd54tF+pm2M8UItnoji3J3NzwJDjV3gNjOePli0X571BLswUDOgzpEf6u1LZPxrtHR5Vqb/ZtnQhz2Qn8o2wi2bVWtxia68AkxVWX1Ddj44aC5fwX4WVfg6Fv89sag/0Q5RfTXIY3ctrca0rGam2N4iEL8uLY0CKWpWam+NpK6EIQ4OJhtUXJ0va1t9hmOadqyiOCuJ8rnIhsfkkjOmtkBQPdaf8C6p/xQEaUh2zkYjB9Y0yaUnMwM6udpzTnAeTP0Oz7hlBn9l9GAGQPjd1tgybP9lfytW5PlSKqmPQ8cw9tQ+l5RFpqp18ZIl2BtzNGBUqmCU8OAnYSgU9OMaZRicnOgjzjX+iQQzYZME60fa9T62p3LEH/K7LxNAhtX9kgT0rP4v9WN8XF/M1QxSKu1UhT0u8uTITTMIE71aVSO0+aiH/aepKasys5AQolcJviBS3ztZ2YznrVfXCkTVwV7FNZixqDuPzNHUTA0PFsRM2M6j+PGzW1YMidg3nmaRdsc5RSG9Og9866HA4OjUrbkIH75/sQJ6k2afoeMgIISUfDnojaYWpzTrrf18MEPeGcmjx0hWo5LbTdePNkW/UMbakf+caUmvLF66kmYzF320NKeb8r2pzrKbsqY2gGMxm0LgHmVAJNiX1zc1Ko0U4O+Ns7HMNPgdCGB3KTYR6piY0yxulinnXhDT5IyaGWUgiP8uxjOzsOZFdLlg28AaWgy8ltaewrJ+NnepzffF3S88YfyoyF1tw/T+pIkCMh5jHiV7wE31HhDmD69qqj2ee2dCuqFAn9WSqDxs/WHvCz0JdnlF55QDeHh6MMaAfx0mGbjeLjdn0wehij48u21zWNvY8SrK8jFNPafUkOidpevV6h2eyZjusXxrRnRzVdrgTjr4S+YdkM4WhliN6sQU6HiJ+y0n3wMdCw+KmYhzRye/zvAGkTmMJ9g6hlhJeR9vnM5AipiV8dyhShc1Ntw429w1y26aUwFmaRIKA9c2HicOLFPwkAvJYmtRakGl9IWilEN2Lo/lg4jvrzIGw4XkxXP1sIWR4ppRkdhjwgSs12b13yCDuY7aDvMqaWgR+RFhjZ7Nb8Ml3JIs+fCr4W9MnzyLHypoYDzS/gg4Li/Qs1hMlQCldx0jkQM4VlcbTVCkB0ZMPmKt/4174LLcXANbtL60inTFTNDDp6p1FUbHaoOb7OsMHWCS3T8lbOgT43JZNv+IQtQsIFmut3LyQUBeIFo7TufHLqAB5E4Q6joAkNVqqKildBgjUxmcuZzHGrKINUx9LSdoJmDk6C9qXM8NesopekmjdWzoaH99sDj8HqpHgX3w30oBQeKM4sBdbkV2gW8RgUOxZ49bVsIPoVTbmEBYJybIROHT0Q22n6IVJmXg0rFu4z+8N5LdgS3GUiB5WdOZNGV1a0PBhbcOZyl5sIMs8NWdM6zrBBVXINV0d1C8ug3tyhcwov9HrRHcY0tOx/DqrnrSRjONfN3vL5jwr7oDzQvxlGJr1L8HpRLr3IS+6S1yFJzPhLWtG+cExQW+EG9sE8VU6jRMFGrFtkYPH9rF05he3VvbBbCp4Chp+qzZayqQGHiESy3cpztIUF/5yZHYQ9+C40iJ2gECwBHS5RTfARGrNEYiYBXUCosATxr+XxJghMtVKpW8WAJtrqQ9nIwSeAimpdGZIHKpVV+6+iqPlesoKxg6zZTDjMiFw15Voq4d4RDeabte13DafwUOSWjsmeY8xQaYb/De/21qYoRDHhqP32klxuIj3plFUl1CVoxJKUyT3dNPXJYAwhM7x0eG5X7GzJ+cEBX6v6JFc6bPAxLe4EQBQR4wkDcoqDRALyI2ceTKdxPmjQ13/Xb+BFOujyotPqqD/qFpaL87EJs0a9ZrevkfcoXLS7AND3wPR0YsbwsCs+XQ9gkv0mPAysbpMXi/EBw6979ynJDXn7nPV6VGLpFUbdR98pzWh4N5qQqhUuu7wm8r2FrrKUF1Q7HtSVItvXRKjHeW0yCZ5VE12HLvoQn2WfveANG270FnfOIhFxxk64w9vzmDfaIZmoaPIk1Es6pbEs9jHpD4GGQDXNzTNUkavzzvCYXsEtyGwx7t0tKmIIhagGlbxqgrEX7QMF9B6j1XAyNPQMDLJbixrWqgE3PvqcQmJrBt6eLoYpeC+J8v5JB4DF5yoJi3/u+Ak13fZUxpHW91daUNLJIwwNHCFodrswNEM4tNfvArlFNREXkZh9hxUgfmYdPeIEuSaaeYKvAM1DjiByGZQY1UW58MfkZufkwvJnk2sfntoA6qDEWi/wOXz2rDd6CXKlmm3o/D6rijtrrOlRzTPoKZLxBlvKKJh3iu5Vn+XOdozr1j3DPYkV9rtHX34ax7GWDrLyySj9gyv8wlOrpQw2XmhURLpxvE/1lsC1hKBc/iDkqVtnIMjHYeirKpnzZcUOMIfo8qJ4LJAI339AFqDIZ/4DcUgYZ8mR64LRy6m8jMVz2W5wptZUrSGOX29wrs9OcKU+Jtw2EYxMWGYRaJPWcP14ok69M+13DY45OrdzrhV41ChggNUIj1P6bh67qrZ67RcEz1Bt5fJpPbhaLlWi0zlP7KOvVAS3LKlg2KsVrTWl0gqDA5Dzb6ayKLbjWEy2l9ARToWe17IY4EE5xCvWlv9un/r9x42xP3VRqW9XuKoECMXkRlqflUzLM7pdTdfsTpCu5CE5fjUtXL1EjYzTjLtc5OI1u5qwSRpPuiB0ydiVC69tYRgr/9FivP9VBnwG/O32ZIWXclLnQLHpLXXSQz6soEsSATQRaTSeKMKoyRMgdpeMhz/PcF02gClJ7mB8HPtlDFc5XtQ1US5bJvxvH4LnHac8ZAgVeMHU+Ivw1ZM03X88iahJbw5CshQdCD2Wh/KHpNIBYNXoM3DIyhRVLihYG2iTCKcLkMfxAzoh+3fmRzyZKVkNT4yO4dIyhd7bWAIW2cM7S6egOCtqE1VdqitLE7Ol3wFJLhLoRzXBGYGvT1V+rG6h1YrLI6W5yZTfj1NTmowNrk4zdhnCIZcCCnEfitFsP+dHaFUyVwLfYSpLrxuHbsSitz8mesLIx/RHrzgYW023AZa2MXycRH26fjJUImOl7MuVr4hwt+xnLYO/YKzDpi8/APZ3zoQzQaiV/PEinrvaHMS70cY0RV3bUAGAPJg+4HHUD6SrawO8ZAahOorHGEr2IBCBlty+6GdW0DFgGM+DxjD87xXN82Y8c4KptZwXOUwajMtWXRiOYiwRziDs9+ZjgD6opMHgup9jd4/UoTnce8LmXqWBCKCBaVknlUR6JW/jMWGt4ud9rBP5E+huG87vmWoP9AucBiH7Y4Q6Qh/jRvta3hAPCvy9ejnOWx2+RrKBcvfLu4fK9JM4/2UnFthBdqZyOO+/oOhWjzIl5To5yWwFX5CsFZ42zD5uraSqD/GBbiCXfUFJ8tXuhuNoi2M3GvVs0FNdhSFu48iboivi0YrTOZ+A6AQl5UZsEA3BaiwrsxgZIyI9KYM0ZwhwGPXDFd+1Ka1bWNhOlqj8ylQW8tVS3kS2ANDc0YJ5G1T9w6ZXrvraiKyC2AOYOZCrEP2fXMdhrz9C7Lcq0Ih4HXg1HPFgwaljY9Zkwz7RF3Pr8iaJPGNx2aQg+xGchnUmXhZXPCmQyRuUsKo7arKQo1+szpakkT48oqn9Y9POSvw2814B09vCm9O/vk6h7vxUloB7sSGVXg9VYQrQ1d3t4RZE3d/j0cBs+FLlLrNetFWOfpIQea5PftBFO8S7Q1GMkrtbsrhA+eDWS2Uk0quQrS/rrFh85rUe1qXR147U+JNaWZibqBQj+j3osrhkjgiPJsHKrV5S/+WtQ6IXSrnd6NX2Dq4m+WfSknGt8kH6JmmCH6YSbOUbl37dssWwp4lFStkzPE/zXAfYATt2ZQwc7xZfekosi8aaGOgHucQslcNlebuoexE+j9tOpMlBlzzzKvtGratnFUgL6NbN1OyANZfoPF+msz47Rp0PvUXZlJLEO6hMb0FAmBf43TOhqXkekKWYQLaiNDQME6+ojyOA33B89csgVLuCnRnm4yGkG+ttfC+D0si8KWepcYOT2ZlYwTDSzz75N3WCwaDnpxk7bksYyPpOScfYWsQ3WF7XeuE6cOXfH5gyCEro5PbPTd7BzdFlJIAUdKfJZa9QVr/coPlhKOSV6PvMj0viUZcVmDS+GU4PqOZem6/Y6EsnADUc1Acv3yty8vi5d6WnulOk2CvgFQI6yqLJb0asBQ/zlV7dgNVtBnN/9z4dKP1jcYzDSOInrXc4TWL2CvK6I8aVSqEF0eGA4h0+R6cSrC+NxpKDAITcRPnWGgZExHOzvA8h9/WcW0PBFtjKqMGq166ptMCHhICb884zbC3fV3CIQNS41yhbWNACDGbm1etyx9lETx+xCCGZgij6SNxTOdctNYYSnDL2OIu3Vj8B0LtGPbfe3RcDq4yMkm0yigkd0/QOENlMMJJDzzxZ7X0oW93KbSd3VP1OB7iKRHuoYIgbzfCIAulWMj7EXzAdi38PaAm5kMAfvs2wYkvgMhQJuXfZftgcxR/KBEViTujJquqcgfamIWvMrBQSrPo+80xDj0x3Y7iRrIyeL8d3VDETNF3vTwmR8QZgpG5KW5wyPiBWnj0P5furOd78clBmasoAVuPyo/jz3MwCeoQVEKXY6yyj2w4JNSuoEFVxo2n/QFbcpGc2CjfgqYidX30EuoVJ+GhV4TL3mz5o1dOh0uCJ5GAzQjnT+SN12RSZjdpjirnLTdbuqDBOxo1Art7+CCrXtZ2o3kJgxTkdnh6a0UC+ipLX58oT0/R3j0YWNak/emfFLQaaMHct2hnDPvWW78GLP0qJ9YDDtmAOy26eBZM9x9Ek/UTzuV/Hhco6vpPpmjryR+ZpTrqsPAnEZFjTqmfkLg1pxMuoa8jskLbDDVnxKiOzZAfVGNDG4lr59YEfPkzW3c9D5LdZg0l66/aaMZW7XVdn5V0wweLl5rhs8pKJJ7zk2tLiYfUNpBK0sLZbNhK8BCcc6BMFgI3rnr8S19QJhxGRKnQAYn7QYackKLGTaLQyRIt8tfP53B0jJrsliKPu9kFA0/zB9H9XShv8FdTOlR1V093Flavjoh7ffTBPTgBE+ipUQmnRI5jA8kgRGUDuLjfyMJyZn0Amw0aXDu2jA8TY6m2t1soooZ/ZGYQXjjWBI1HfXRwI5vejE2z6IOjPBo7gIg81s0fyQWCv+3nWjlZwlTNIJM01RYgH16k+tHGD2nA61dZX4sv47maj86OfkQCSc5A+EYFNa1gzmjQ+zUzpYaOfgs+/1AFut34N6bajoF/cesAhKZc87WJtU4oZ0MXI4TilEQ0x8bxLIqpAoColKzzljfRd6+KKIXPaJ9LFlPIxpr4Or9KOaAtVvVRjsXVWyvKQ1g8ZNcfxbw9HmxpKhnky4x1eS59PewwMhgi6Jg/mELzqpGMZ116SxLLTjoY51JCnThMM8jbKud/R3NauN9Wel96jq2g9R2QkHWt3UbQVQz8kDVptMgXfzE9VhhmJknpFHzk5VsLRaZSFlejiGCDXjkMqXQxvBTAR5rt5yB/5fsIPYSgLR/Og9+vzRu+Fjl26+yhSLQI/U9YI01O2HMTRBTYASw4G6IlVY+3XQnJTv7TiO6Zfoc5yjVDWPkaexkeqZiKONlc8IGJGeQf6BgHSwz0xfI3Ma4geQnU09+o2QD47K754S13i2XZVSwQit3mP6c+eIE3R25tCvlrzj6wLxGBESyOUFk/1RJEFnB3Ck/wvYQC6PdPZl8WscNhJ1jV5GNtyQ22WgqNcaufjE3AusiCLSCSImfh3u95Oeg9Fuo2JZbzaIcKCju5dUqaQqkqC4cSo8jVo/yHaO+ytyg5nE/KAjA/zbixPF+rJfb9AVX4I0tdKYDUQZVJppuE8OwJiw23ZGCDmmdDx2S+G5H/9obmKMhWYSr0v4mlUrGn0V3eK3ZDo0g/M9WWgvNDPRsAp8l3Z5LWSdvaR3jrX6aGZB9XDL4AK6HWlsBrnuMYyRkXpA44koDisfAeIQxv5X916TT6y8qSipXtsaZ0/ZeGLtZ2iCz81rY9KT4irNkQwVigaompcOJ5bWxe6F8lxvxNizBlzjRFRUsVYezyP7zIoHoz1GEAQk1PJasjMJNHHCa//3CLI/4MmUhRpw5oF5nIEzlPU9RlMUbdAGucSu6+TWPIRM1kZu390IZ0WhYndYMafax3uhwC15R8xMIpi9MBz3OC6uCPVSVOQJ6Jqaeo3CppXUQc0e7jqg2KxIeSyVZia22Av5D1eHzT1+5xS9YFbMn4PukBpO8JhuJyOHq6NK6z4g3bE2rktSCEqWzMLB87cxoLeZq7+FDwdQ7uS7oxTcmi+oPGmXMbCNkwKyfKS4p+TaT/FXz7ikOXd6/rkxaWGFkMxXYlj/yjo3z6J9u9aq50h8/44ptz9/ra8m0hmKT4Y8P0tXCrclDybl+TdRHMHfAf3DmC6+CqxSVsmrkU380GNYUe/mGf9YBB+vpjRfTpeeYsyrYew9ZNBWTv+6REaPM/0B7C6Lkj8Bk9yaz394TrcOlcfaENmVI/TP/oYOn90xBVrNxR9Un7MwKiEdFEywvNdT7wRPaxDbttMwDWXGTG4JQGm27AuYv4T4CFaxq4/YNpH6xTlmjhccXXGRw0x46kY7Ia52Hn1y1u2D2989ksCMW3WwvXug3FI1dk09bq1iZQxP06fAklcg0mHbPEEEwfgoFlM59m4rxF1byeBEbp+p851zZ6N28ouRd7oG3OTchVChj1NwKTEwELRNtHwHqvgn3TAZejPj+Pei38w5O3gIJ7NwmrFFm3UlDQbkkVRx6jy5U3XT4r8jaojJqscqAIAf269rQKVdZ6eRx7ocJyQnrmr+BQ6GHwfv2SqYeaQ75um3I7b0NGA9eADz+PWVw6MSZhf6JA6CyFq00Xt1JHoMWWehIV+wMo6xTAEEST8SrqiGQsdPCP+A5jA0T4CW0En5MG91vp+VH3KFiLTGv1C/X4OlRQTafGJiU8MxQP/ol/qUkpoDRSJD4hE4OC38NDA0+JuVeDarDZ6sc1KzZnnYanRyTe6+2C7QKwOBcOKPbPG87zG8fubKGpvy/TtqehCbDMQXe7WAv8PwG0rbgCuGti8zXrKS92ycdJME/DfnmXMJkE10GmRvnZFsxCH1e/4PMnuic4qCsdfL/v7uZmzmwFCd6ddjwP/9qa7QF6uhRoXZJgPZp70wk0tZQcS0Y7OxW8Lx9DIa2DtNoNwi9wkWwgHhUelh7nDg71oZelcxlnSdDnxLKbfi4u8aqhKXfydxxZxbfG7uwSdFfTWYLPg44tTQ71GPH9TAcrDO3e9pO4JZQT/cQRX9IG+6Gmv2DziMupXqyww9N7U0JU63pF5/6DIBZ78oCjopYclN5jNuLk51RzWupot8HVydIHVuT8dO1hCnnHy6nXwvYjmaxCZ5LA6xE4Jhhz8jXIHIKZvolsTRpJbB7atpfreC+MQUCzHhJdATuERl4mpCi3uYjWBraFY2hq71/0pjDbPfTl6pZF2YsyT55cOsNIwBCqCBuIAVPjSr4MBTJaEcdGOZq8DHAa/tHZL51aJleBCWKM/B6NGY1W4vo5/HhMNLKc7yPrds5/pb+E2z/Bwf3Hm4sQh9L+tqlgO9n3EoMif0BgsRmUiFZ3yAHQMENjj4ejSzZ7gSQqA8TpAxPLkmE6T2XTHtBNZMGV6lVkwsaI8Fh5MBVFZltYMiFGdZXPfik2ERnflmjWaA8bLMiEOJnkRM16OUu2gdUAdN+3seiPq8xV6Oyu8an7iYjkRbXOG16WKgAhRERN6V4WIZ3jlCODdyqjO16VCeyV1J5sxI1DUk20OdLn0MU++x+eu/h6r5bcAyYdumuI4+qVHVC+X54a6PAs4CHUNZDxcFxU9zTrgMpUANqyeXLoTottRyeOpCP8a1fNfY0/iQxbPHmJ3RWQl7/yicsTkhztKmzVM0j9of9UNHh2NMfhxSwsoQmbGmyOVh6ZIMdSquZ4C6Eg1VWMd7UIa58nEtMHhkgl0/6yQhbnXD2O9MV8z/OkiGF9I0oamWiE/IYz+Oou7V94Sa2CFLP5roMdV5TVssRjozN9KoClWvigcCO8veqcdAZPFbI+QqVwvQmry7QzbebyX3oExqPSxGo1iywL7486QbR1V5PiHo9Yu1iX1cMl/csCaROKRzesvu80ru0AE/ZIgrihVcPAeshYqLGjbfyAtEANYkkgSgG2ns+5bHVkrGWPyCLsPzKzwQNl7q0lly5VSqOv4/uZowUmIsMWUxHX9iMgPfCE5Ik72MQn9DgNr+CZX+aDLrg5zLyQcqV0Enr+yhhAUY5YnMsDk/+FHXhBs2ykkISto9Fz+BSQ96xsCRkrJLN9gS05JNrE2h+rMoFcGxHZgLXB5ql1OU8+Y50bD0Npwo5SWQNuAxrehniVfRloRobbvy0vz1ghVM7zqUYECLdJyedUaR1jfKy7vdnuBi2Tt0TS9e7sjbvtS1OQtQiE1ube7UiCr8blI2G0Oa/sSr7zbMZFRkoN20vifl+YtOb7agxt7miz/EqMqrDkUq64mGyDgUjv+RqEntNM2zeGuyyp09jjdRW+9dk9pEGsNMu7ipMZL2kLRGWxnSS7SR/CZLo4fDBHMV+PhE2wOn/zRjhRQo4Qai8Q7kjWajlNlWC01Vhr0pJnzcV+RTSTjyeeg9JW3ZdXA9ixLmdvRQlbsyA4vmgAiSPyDh+OZmQfYxRBBDzlQ0u45bxcH45QTDNyOt89bKVBcNLZTENJlmlZhredQV3pxYbctZaaV1kQ52vbRsSmlctKXAMx0gYEH4liaBoCWTEWF3GxEWdjwKqPCsqxyT7YjVPxDlogOwl0qMmnO2vxqXqQImWt/zROdLN6Bo9T/oPS7fr8SxB4fGqHqfmmpFussJvwAoivZphWmXbHdeL9a/UGGXxoDJopfPbj0V/B+NYy2DqvAi+ngmY98qrelfRm0c1ROvrBlmSLr8hEurYJXQP4Jv5sk9CdhtamSD/lu8x48BZ4Ora094LsvpYLVdIkHsgyI8GMvJ24HpJntDEzBEE1SSF5w7Vc6mLwtuKRZQcrd1a4vFA4c2Z5LYKHcXXXNN6g9BmkcD5czPrW5B8T/9moPoYnxW/sGaWOEDLqQaZQAbx4CoL31iazI5KbwWyIr2ThTAtApFjsTVHIokeOfhNQ/jxmh1yna/QNk+zjLUssiY2f7KU2evb0RzgbL4sBmk4laCIcI5t0tt61isH9NlyOWW5O0QQ4yW4DN/bUKT077bqmhJeq1vzltbnN73ibv4ckfPxQ5hucJZQjv3G6udpiBdKdfPr//nPAVOX/PBaUQE3/i8ZfYH7/rsJisjNGhkAotcw7GNSL9c4giGczuNF84AGIK5iICF3hWcdcu1x1d3V61ocS9GWBxY52gf4o0CqdPn3xlFvVY5+tgoEWz6BAn8vYeB5wIBOUzktfM28wjf58CmN+BtWAGkujvztQ4RMXQwbSkB1ppxatCPvD7iNtp9n9XM0lYY8ZoCFM7i9sct3wz7wFuvaI1rz7XbOUA9mXvfyUeDYqH0k1QLQvxrNSm7+ipUbyM66UYOzkKtS45NmVCZQb16rI/x+PeKRwDFnbxwweI8MvsAfZjVviEaH1/lRYe/DDS4sgdwIZTWP+CltTgAwKuv5MEqp6/RaEf+H+a3dyyWyLCqKzfkeei+67N4wvbE1OhxeoxU97Yk1cigZBzq4k0J1+GJl4xtYpqDQv+r1kNkEufuQr0tUR9F/nWm3QCJLTCjGMPnNMKvThU+NDIbyim5hbsV48Z2uqUdMZ+GYfee4oHS5DmL8AmAYeDw3rdGWxlMXtQLOqdqPCo3Gf5AXhn35OeJJGwTwcnaKxtlAWv1vA83+veMe21/zj/EPO583e/fAuWsl0nDr5NMw2rX839j2hz0oXBAzkGjKUikQ467SjuyRQ8db6sjrHbXAAFkrk4ydA8lWmJc0HF6XjLy5RNTIo9b7Zv2JlYFnFToPWuEVGZ09KShmpTpd9wIOomgicl2tODD3iVvl1EvJjx+QdF4HNDnh2c+W8b/8rb3xTJpGSmvsn+ZSLZNOqVBFJ7zyAdZxhfsLuIxWf4+p2LGX4yGPQ48Azs8Sc9FjiC9e1oEIpQkoH1dN+daimvdrwB8mb83IlVyhYU3BXwjJMBeF11hb8BMAtzxfBlfmUopr/Qb0D3mZFWeojmuEVx74WSOejmMmL46y1CtQIPUn/gKxaF+G6giJVSt1CU/AlIPNb51Edr4KtrrRWufenmT8ferELT3+5CXWxb6/IP4Cwb2Xf39YU+U4oBMzaloc76H1Tdg99wloMpuSWue4GgX7fpVljTvyz5MHmCB4jpTNejsjjzW1K5VyrLYWgMTeLjtSJjjMzdRbt7LXEjNhiLzTv3q6Ak5SW7i3cRj2RPq+t72FD/Q46ZLOPPHPxG45Sjk0OX1S44R4amrF9MCWK9T5yfMZQ2zYggkcTZdDXLS3NfFOZsB17ifcHdPmNSmNfGQcG1Z6nCiBaJcaUxCPhPiTdocFXrBUa9ZZRzJxjbQlgANr9ImTZJVGYyCeeFH6E55u1k9YSsnU5LGh/RcbTxV1tFktVm2IPMO7oTWxdayQ2Mb7cJIAgUIPk8/JaDrN0RXx3jQhzBqINl3uhMD+zxP1dYMJF41w8NDsUBMw4/q8r17IImDCg3Kb0pN1S6FwAFz7ogToLd31fkhcui2ZXMRyw0WhJKW9hWVtA1cVRuXC1OTq/Q9wEpWFD9St3ULVqteGwI8F+S4iqxYROezrs0Z5zD5IZjxwX680TGNEp5bjfOUBNo7Yx4X9rcm54emY074vNqNno5Or01sOnSngqvvNZMjBfwps2H/ZE9N01Yf+ocks0XbjwQjsFylPj6pFhfkMnvTXBf3vGODTx1ms26FB87IL9ExpFJDck4jmxDh5DWnyT+qnXgovnmg/zJDGTNDWw37ZNkKX7akIL5itlBuN+B4UJRQKjOmbUUw5Uub0iiILs+wczQsbGiCeV5DqnR1C0PxvfxctChE78fTMT30SmTCZ31rVS0BtQxpX85mElX05AmbT9v4n4qVglHqbCZpLI1qMphcg7l08l6cGFix11Higv93x6mX3w2WX6bGcj+g6QSOfelwo4nWMNOjhr/bcqSgfFSLvpfzSKNk3uwT+JCGGDCA/DMcNA3CtpMlIDpTidOGmWi/Ktz0sCtpGErUsFmoCaMjcGcFgoLRasPONMnPBkm6FLIpts9qo7jkiXjjRH2DZI7MqQ/tdqweT1pnD/HrxwL+u9XqnA2B6dUA9+yUki7c6uqYn+x7I5RjfhN6nUudgt2lvRO5StKoaMhqvY/bOlih7ZjPGBbIbP9ecS+GnJ/Da3CDOw2QtfU8kCtIhHX/UP8HeWuHxiVSae2EAV37Qz6tR9LM2PUXwBbQpslmz+RNLdD1I43UEcwGdv3nVLUeFMQ3bQ76FbTzYkCGiMZ/+Tp+LMLR5npEXowqFvRovONc+V3bh/3Cwz9M9yve8yuMwgF6+YPvefufP+hFEMUCC5wz3KauHqtJhLCfRXuJQu0cVO9TtHNj9Wm/CoU2Tv2DW0UzJD2pOUyXNSz0UVPAbuKDnxlptUlF9045jfHZN9DWW7vWR8Jhrm6tP5HyNGh3GaLsmD2V2B9fPHI9h/nR08fGo94w6V9fuA6AlAnKA6c9GR03gJQRhmfUIdeRrOC7rnZEMlYxvDOv7bwwQJRTmQ/lnexjOJa9LUZJQXKlaEDiszbyq1LitjDtek9kDFbrhLBvGxoottaTWz/9n6r3VhG+wEj9JN2ThNh/QOVnlOUQc2x/CQW7ocnUaHdXV/vHzvoLUmvkEqclPSZHtgcvmT18lklu8uzaVr/Z3+ub3etTOY4PASEBjLl1FDEt46Eb+eL07ZlNvUPY5SVcNZiOCe6kHVoYTQd5zaVwUlPt76YOGMgtZ3Jvot1VBvFr3oeJ/moDepYolxH+lTSl7KGECSWSBwcgW+DD0ZXspltOjP49b1gdI3BW9dgUfHx5ryUlw9jYBdy8xs7/4XsN8HYcTnEyfxLm9FOWLOcNeMUeQ0HuXFeMaiGhTLB98zkyWqBRKRQ+ASXIVKVhiqEXYVyk2cMQd+pF/mfEQUIKhkPVHzL2/rr1QMSo8gl4toNPcj4pbmxmVtRTf179rnXXtCX8W6KAOav9yxjRBlfc2dYZ7LuJCbBAg3dVG1DtJG10FOwLO6P81kXEoCNF8fPsAHoDZkCYe4q57lc3o213Pkk6PHe1awTO3NR9bsPdaBBohneUbMF+XIDogdV6J102HDxr3BaQdDFrd9GnZwGvzJuxAcvzYo4QTiom73fAlLco7z/sUkUN1h6qpPWNVqS9T7+ycSYSVgDqty1RDl/TxTCeM793IT2/aocfvXAsC2a+0eUNxiqQzPzEwc4DZ5ROc/MAY+10Ax78UHTgZFhu3OeD6BRDZbbzB4z+3/BcUT0AqQdrJnUfZyDcadwZHENn4rSd9vULG49esdG6otBe+UXz0/E4wIFMD60GjsNwzircDqxU/poiK0nF2TcsRK99fnggbFUCor6fA/TA2JQdrJpi/wNNC7NyR2i4o5PJkjhAalHY3fxnFu9h85ET2UXoi+WNG3WeR90X+16MCbKAg0iVi/eaBYMEYWZbJgTr6f+lmfnj45HqS3AHx5tqjeUdNN+g9A2SewM5i7ahun0sPHu8s4NfQYAJWteVBjlNbDK61kC4EvnsU9hCXdTzzHFgXiXMrFaDyHKeHAvHngnEVjnXub7Wku5eUHiX+TkKeJotKL2wTequYCGWWwmbXW1uTC/enqTajeEN4sZr0YsmruC2c8HqHsnN4pvvxXuXCOIF4l+7UThRnLiIqdL9+Eu8aZmGHaO8lcubXeHyQJygZcyvOOv4KvDrpEJNO3Pi2OrJ8N4Ax9xXm430B3fyZv6ZF0xQf89dc6M66tXGFuGlu/0XtVyD1mn/Lb+HR/vm3NMf+fyamEFsVkCGHM1f5iCY4QRIlxsBWI8ErcBXmSO7744nZ07LZgQ4gu/kQ2/KInl8tr8A18CV5luwBgMBE4wNSfUrQhIKEq6FQP2atp9TzjSvP+BU7qHnnZt7BIZ/sf8L3ZwRZTdYgJbLGXxGX4JXrr1zvxdJt693iX+W6zXiRPmg8Wp5pKC2+wX9ibsmyN57u047qDaaJyms/H0LwbgaQSb3iCFaNmxPyIvF+38QNLvGvFnD+SS+H5+GrzEzhaHNMRNjF3av4iOdnhrp4K1GPGhTQpOtKupmcpVbinwvw9QeOFRi4/H6LM6ge7Ewf0g6LXWXCwXbDFT1B2LTgVkDbvcc/5IXlLrQ8ga0YPRmh83XrHSLouc6oyOetw7pkDq7FpfCy/u7urHvrNLdK8VrZYqpKJsUbEas1lpmvNxUtZqlZAljw/P8t9A5rkY9WwuYqjxoWKxzjExB0k5V21PGzpFL4oww1tJdFxp99TtGlNgR8z6k6Qc0KuG7NR3sZccQ41iU2a5N3Z18qTjzTY5iMl37oNbdjQqLNGmssZWxZ2O9EnEbwKxbO92HPFATReTvkTmRFaaQTORXnet1xs7JxSAK8A1DQQZQem4p0hiU04l1wKxlfQ8fxD+O0JGzGtrm3IoEA1bpfWuImtKyNrj+AdgBj5OAquadzsykBwXO0w9EBLbGOu48Hm3ZEoaBKx+hcdrfl2sv/LZykIY2EBspjavVmH3ghGPWoKcS9hONg03eU6wlCOUwnysI4T06nt2Z6XTsXcYoRj4Fw3xw2a5cxJ8nrMJtrSzk4EpZs9HUNEpD3rHAdQsDsf1/Svh7bUcda7zhVD4sV7hjEq7Jki55gWk84A38FBRSDFQzieesF2vHZiiKEGuuwm5B5Zc+r1x0lYb/U7a5I/kDhx4s2mDh8j6Ew3qPMwBE/4CTh1d1PU2JqF+KgnsUVJjuD0jKEMVc+FNeGXWV6knZ3yHc/W0okp2nryshus8x5jF/U3cpOP8v6wkFt1BOlxYlTZLcThDhcVYvda2wlxP66akqUo7VVPvcLbBTwphHda/tVGcelihnSxcVxTlEx/qZlvTrI/bRRpVJ3bscB0rvWtcD170oT9tFDXgu+as7Y/APzXDUPe2FZIjY+BGg0qLsaKNEER63+7kAboV89uKIGljtI9b+Ri8Mgio94oGnfpYlNsquFsWBriX+oWYQvA/lA6q8hsi5Q999Kigl+7ogX0NUsGXO88TxGB0i7vj7L4ZHyNYJ3pzWmE0iJProXNrq5I0dbEPDTm4JvFaxmKkQLsLLC/8KY8zE9iJpHx05mvUgedvo4h3Oouo7xYo84C2w6wfKZDh35JyeeKv6hlT4zhaP4+gwkUEPuLcJphI6RJOnTymwzOVjT0P2Fs7dm//aKf2ebApRQkPr8rqWsPbZ9TE6E0w2089y/uE8go0XGVAoDO7u2w6ulQKqsw/bJJ6JU9j7TPNSR6OpfyaG27i5Ht/GB/LILw6kBqqm+BGgalEHUoRuw6SQA6r+1OQxNT/HZHZ17LSBW6gZgqXLHBRB2P7rwMb/n23s1FHveO6UhRIcbidl8r/JTnk+o2JD6iq1v333XyZ/SeQpTNbvyiJgjHs5CspUJXdd0sFWXzG0Rhw6fWkrh8r1AYNdXFGxn+pbgU7U9OuI40PzzaVpO/4v12KnhoIDUDlI5Tdm5airVsg/ZXkFTaQFtOTGzGvR+Cv94wXRqarpN6ZB9bXLlnQXBj3SPmEe1LDPvZKARI5E1Sm6xc0XMcA7aizVjVPaH8atVM55WAuNi7FglFAHnXXaZALc6UZ8zuFnvOXKi835zRA1IYoE5DtdKnP8Qolhme1a32WdeayErSV/QJNIghSvGCLMXa5dHHZTNSnpNR0YRba84vMPCj7MFL7hl+Qp65CEQJUvG7VRrpRfXHSJUFYHOpU0Y2LAHY8hkIkEFpRSUnixJGaxcyX4djGp5JI1MW5SGVHpHyKNLZdl3BvMQWZQyyC0zUAe7LrCKEq5t4+GLxIYHE4dVauKjvK7GHab5y2SdpOoRkd3z5rp6wiMJ852oYa37RmXlzvM+MQYbpnEI0SmJr/2iA0xY1ACT1JfcvRlkmRKfHdDfphF6S+XqRJc8mApos1paYVAd/qjLAR6Ue9Vit5LNniSn5Ut5YDElj31jmJJufAKJrXX457aulFmF4rktRcl9B+EDXVFa9UcCwk/EEJg3jfwYxR3Hzf2XVHCgc2fuxBt7s/dVYnwvCHXisBbxfyrNabAAJR5SNMxQf99axK/ApdLFM2pcexmIo6dli3wuyc6vC724OD5L48g3KmAqv/MV/ppUkTu5j/+tMsa3Y8Xsh7/nHgEbPD97wiPT4NJ477M3seUZCxHgM8GAdulNV5v9M9SLgUQJNG8migGAgrkulmh6u64vO5joBYcdKxYTSGAfU4n0t02lOFJlOnfcDykMSLQEJhUQtySh8Of0Sj4DS4GMzbuECqzYDEzmumW72dymCEYEMOaXHehjKnSYCF9uzTpG/MZ0sYB1VE2XAHZPWLHqyde95S+dWj+WMbzQd6pthLRLepHVFcXpb0oCjvq5UCJHF7juW7vAjzWRuziN6GDuarVrkhLQrZzZFiKdOo6X8DiXklmLj4MVKOPWtDlPJAT2uUXk0ceEPWMLPmNnfOsTIOuakoziShJbKiULE+L166qJ5coLqpGfDQZNq37CeE3YmouzpIsu+L2ON5eZSWKXvUtz1ABLrhPSKKRHKEk6LUxCaPeieyJ2oV66tL/AF67+NVFaOXnD+dclLP4TY3PJoXLNIKIDrA3k6yp4KHT7uMai4RtQ8qYl+F8bBHzi2Q4c666oDq6EgOj+pf8O5nI2sLrTqJTfoPA5mZf2i6BZYDfQ0Qkhn3BuHl4+TOXi3d2+R/A4GYkF90yq1ipE5YUVbivc5PXAe15cWtUbR6M7/ZlQ7+YxkIsTP6mLOX1sLZ1O6xqNsnHjy9BzwYy4chu0jTs4OcOPlNTVYz9PnqT832oRFd+Ub+TdlTzrgr+CNZbClQjwIoyNKdyO91wO/nI+xsd8RqjBwTGyWpH3LfkKMlz1Z9J1x+cUV/DZAp2+thEeRPCEpnvlxcnQS5OVxXl516l4k56vFJlR+vBEusohfZe5zyJKOVVfMZWsq3HICVyGDYO0ABVwy38vB25xIu46mQFuE+JLMafJG/rO4s4MAatYJFYTrFvl6g440guP9nEPZEQKVVONKEB4nHQBaa5SdAaZJ5GenURqCyiqTb0bsxtHoOGTk584C0l0K9NqPE4k6crV798nSfAshkSUdgTDpzy/wGmnD9T1Ve+mHOOsVsIylNPBQ9fnL0USjW9Lt5kDIf6D5ZO6tWEInMZhrbU0xkdBVlmcvuUUr9ZvHYdEcXf3y33hyTt814omIgQXabAvE51DkOcugpWskBuZuzDkN+yZAJtfR1jdYEOh3jpVPaOwkwCnWvKllopiTiV8Ondp+Hz4/n4K1jfqcPiUupmbiOdo8r8eIvl+xenHWAXZR7K+A7yd/HylJXSv1XJSF+rQxaEjTV6WjQh1hhqkC8ly5sIp3qcDVQWxi8LW1w7e7dSWj+x7XAnA1EFSFEJF3I95zejqfYoa3em+2GyOxhkx76gPuKLCA47W8AARI7+AeG1PNJ7EBwlttuiVfOweuNIr/CkH1YOk9dpygulZQY95zAgBBTFKoeoRpzPLagOOXcfZL0p+1M1AheTt4vsyXmXRhP3/HCnKj7Dw3AdqnFDu2uI+SVGn3AVLndKjA3UFed7G88M5RZ94fXmHCGF+pcjePxRwtPq7+MEdicoMQzZfFfuDTAsbmaypB+KYmkFe+/wU41YeRlsq5UFclRhJRrJ4KhnEIzARrGyD1YYycQn61QndpyUc2lO1viUGFCLOgC28pX2UhXQ0rj3nJdj8e59uChmCjdUmlA+WoxcwHjWUTCyt/y3ubq48lkZjDPCMCh/p8Pt4ShOGpaCMGSppLfUi+EEhaEXTAd5BpEc76zLhUWao6M7PxeYwPrzFTLTy0cxKIbwb3pyjw90VmMXQZmtgJ+Vf3qYiW0YNH+ItLs+uSqzT2r8JGHKGpVMKmfCO0jC7Gb6jc7sITUvhtMF2hgd9qgynd3ZSi5a3KE5gm6bCdKEZOSt31nphw56OVcQQzrthSKezvwTySKwslI23eY1mcheKm0pjiuf2Q6XckI/NDYJYCiTq7kKFqaqwPHXbdPiHbTKUKx0Owezp1EdvD41rfR1H5QeZqOrymY2+e4a5QAhHw4byLWvxTRvzrkLGZ4DR3fVW/lMoYOq7z8iYDmeOO/2zueka5XX0sbJ2H+ne3llUfQbcmBwWRtoQuW0h1ZUMc/07eh+dYkqR1iNW/IR35b09NtjiDb1P5raEDCqfiBpFQeMGOdODYZqcBDVSoeqh/Lw9wEMS5uRUsUXtKXt/iU9vaW2GnlToM6DBjKWXb9beDzsBI/VhSpda/bzRUkUBb0AOSgdek0dYYOc/b0fQdn0gCr9MN2Ch7j0uJ0OotzcR5jdnmWuqKeWvOdQLRwWh9HjMF9qlyQe48QsxjXUBTW5OMzYG96IledcvDn8kvmrP3xbcviX2t+9ZjEbdgGk/ZfG4wgZu9hyuYxTPj9yXku6MbefkRyqd0QfosBgEYOMSRzYX72b3LnmZTLPvlnQX/VPBWRWkWf6eB+oX6sJG4R7eSw8Muj1wl9VJMOH+3m/gsasSMZPg2G7m5WzWx7TIw7CFYr4SL/lFQaTPJTURrYsQc4/27WMxMNnf/bGrPVK1/sk/MYxzHmROeH3i5xTOni7RgHBkwFIQzwm8IKXFoZGtv1OSflbCcVKA5AHRDjK6YqhVVDfmOI2+hHwpwByVyOf9BUNGmVrxXkYuOG705roN/Ci1zKUDaxQort1noi+2QLbeyy0nePnSAhlzLDOx+yvVnmVFM4GmXy+q4qlZRddwSa2jMeeEXfSp9SQsu/f5/YNGx2Ty0u6YlgrUkWxwlJsoBp2zc9Zy5DPapawSZYT36JdnQZhyxcOaO/Y0MhiDJ6X/mpFAHhkCl+SibqqR3ZeaMsaybVmEx5Po7NmNYEb7GKQvd0y16QPz6Wr/MmKgtB5ieWKqNZE9pkZ/iNMwb1aPqq1L8xRgQVTnNR1zVM3uOfezlJwPMS5Y0iTASfONq71HEv5ymWJUp4UfWmd9XqZS1EHMDKn783XTZT2rmnok34LlkSH+9iu5ITm0yMd9su+FwVHdJJQovi+6v7IAv/rBy4BKvAl20f0IAOeeJaesFKlSE36E0Q7nq8ketCnmrqkjc1o0bFyT1lKOu1zA94zageEd91lmB4fp4E0yhkW1CdtnMT593udPvFxU69/HNmPUpS0OH2er+fTv76q0kJiZtL68PYL1KvIBQxF54DvsrUFVW6NZsLcqSvODRjxglci9/65/TBAi4rdffsUTKQdmmNMLu4+qlDgL2oU/u7lSHFtq+5DYSH0XGhhDqe8/lERsVQmaTYvcQets5F+2OPygxj/wSwqhYM9mKEsGiSZXauKDGwnlt70yQPhN1IYu/HuAhieZDN5Sk7y+hfquKGG6K5NFm5xUe3GnOg0OjNl9aTD26osViBy2oK88SWdjJGWG63ZC9EpIcjc3+mCZc7957XHhUhO03Hy+Zq6ytWSju+pOaIRqvjq9H/MFr9nmx4OWzbnS/AEW0ljMrvkYtCH1g0RqQtgcdFBPzr2MAlQCTglRgKFv9GaGoSXAkGiBiOHApu0JgrN6m84QxcGsrBJs6q6DbPzNHgbQ4+l5pcDYD+j0PxgyWAOMcf+dDBJif9TkYQ0xunUnY9mWyEmK8nuFwA+VsKWA8ef6Vr5ErXzT58U4xnqD8A/uVArHpdaVG8n71PqXxD3dnLCFhUhIzcT0n2sQT+F/rjQQ5Vpd8BGX7KDGBb8jrJS38psh1ieZJ12+m1NSEPNCDJ6CtrHLfXki3ds2woGMj0pOw0fdKBa93JDmsG8eOWRIg2HupoNlDxUqHf1WkSMh64FXtQeoFQelxeRqV0qlVq09o5/nvHGXr4ywIOkHp6lQ+USOBvuf2OrOJzMHs/78jyaFF3p/zgQPScx6KDiX9sIL69kBym/pUcg0k9QXpDVJQwvWWYgXHa4Ub3J9SCvYkkATSoG2u2BSMtvFbaFwQfAm/UeOKJSo4xeeEeAfhxGG24vEgPJCO+mSQ0VBcI3JUpaMoPN1/KAISIefbCM/R3vvcgk+kuRXECyydFjY4VwMcHlUfDDuXpDFHUJpeqh52Ys/xzgdWpt6TNoExOHqyPrO4Hk9Ki57sC286sa/uGx2yJBXT8K8YwhCBqbHXjAB+DifX/RykHPUbbEMgfEQz0AEYbowpx5ClRBtROGDU7mL9FHU2O9dJO2KcNt1T9MN1U1HevJkOLnd0xT6O6z20W9v7o6pNKDF1tB/xU0NExPhswoxNGvFSlrPY0PkB5lVujJBanlhKOfFy9Go4Rg4x50wIynWqmS2+6UKwh4HQYfNzGcBeXh4FB49YiLcmCkAGEdWIhROt/TQIXHaW2EmzT46EPAvL3YMakrKLgazHSYbi1VA1M4Os7tyLoeKfOzGp4UDFFL9CrcHUtVDWFKlMlGtxJ50QciKejz5s6sv/wyFS+rzRW0MUlVgDds5HfOx76PnB57QAxVXVp88sIehVTthSRY6ukTHIUXNxznU7iMFH9ugBuj6NlOy7uRlbLzc7VuhoFNE2VYzc+vNiaFG51dvwUed2SNYx9Y5uYIR/q0RC6HjCYudw+XOv/3EXUAGznJRvss2s2q4P77mA6o3OEeraflQUmq3ZEtYESfZpH7C/KUydN1J5IynAogQ4BSPpsUcV7ZvfCOAj3XnJyYnddyR7c8AR3JKQDx2aGlI0dJzkYu0qENs5aH0ZXqcajaKtXMPAprA7Smxm2PL/q8xbqLpxckkJsa8I70IcUgKXsiqvXsOm8YhPrdyqndXhH0M4w9plbKHU4zMAoPxgfNCtKz6qTR+O+QGw6bbpinHF/Cok6GpBpROpV3AjbH9Za8JD3pgVOWqfrIBXGMHQ6Dm6xjMAJ5E2iUtWDkSAQPonzUaApsuzSV+/EdR7JM/7k0emcKtOCvcn1NgyKm3XMYklJVo1k6IfXUmfO2ffyxEMX1tHsSDOcdH4/5sKncttgbHyuJYifDzDTt5Wehcm+bPn5SKag7UchVBwE6HaUh43oM12yovUcwBjP0rAEQLjbZy3QMX7JHgYqKe3evQVNzeAEz+UDWBWoasoNAAQshy/zAZX15MpEiZteLEhbsfO+wIwEncUmE8/wNpuvnHbU8AS0Rajlj1B6TXZJSWBCeIdaNwc1sWN630IVFK5oFRuzXXbc9jKkloc6WVX2oWxKnoOyNpSBsO31ph8/rxDfMr6y9M7Q/61UY7LYJ0k8KcZLQm50Y0VbY3MtkxwG5nGv8rzsJTbGwxzm9FEIpiCCvm5gLYMXCipjK3K0oerZsCowaSGvFAP3D7F83DBl3JF0O3vhUGx5st+q+35LXFJWwiOb6tsJsTC0nBcUJqb4tP5/RGNADiywr7s5/oC3u7TJpf7u+/jH1FYXc1zsJxA6tXXsOaIpynsA7N10nL55vsZYj2dTOqIWyE+DxmNkMXe4O38kRFY3QW0tPpc7l1hqsgAo4VDCTAzXUgY6PWfS0xVTAMaMRlH70EUH/+GTOShAfaQfpZOjxj+Y+QdfAnShxKoH3C4tu25L1MUEKzNcWfsEsab4yTpmmjRAjuCIc9b5ZByhlXnZz1IUMq6CraxtXCRewlRHrCML7zTxeNAydDmTQg3XrwqPyAsJg6UQDP7mk5wnIs5axuBUVnzNVuKdaVx3qiqCEYW360u7DKi/ijF8FnxtckrMq1DcrZj+j3FZCMDeOc0Uytln3nz+crfZ6hHsB7VT0oTgvY4C3nFygJRapaRj2XUDVFsEnVIu/QkLWmbgXJ918lFeIEgozItTBHOO/90p13Ji5OzdYAQj5s0AusuImadcPZ+0FsS7uO0rILdhhXXqwCZ+kOT6zoVc4cwzM0Ag2G/UkZ7hU6YvZcJxqlcPaZmXkkC/5/vcT2VYIyFpDcOiBylD3Kny7V7SPhd6ExbIcWBTm4wIz9OwAwo9NTBWebFSxz+7cpcE7n9igh5hs/1B7Gr4D14d2jP/UrOBT4IAlBe1nkEwsh+zqML7aUlVJgxwBI0J+iP3F8gW85xknDZNqItuBrVDAxg/PKFX2UilZWuJSU17MFIr15If3rumjM68KSGc8sr6oZlFD5COdgk7P6jGka1OtK0gpKNgbxq2QGviHsG3TdpaWHOjdNYQeKY/A5uS+2+5aS3G8YspNMmAKHqn5ZJaRiCw/VxrFqTlgaTzUH3sCR3nWPBC4Bf90BvbxpK/9VjOcV/fi+J6vslUs4BqTkyOrwqQQmu8Jsg1NzKYmj9AhWQiNX9eXkhFSIV+xN9Z5VMMx5L9+LA0ACyuiSTvx/PChRpOc96aKtrFF4ZzFclbm+0YDNMMB6E4gQKE6eIZC5V+HOvyyPMxi+atof5K7Xp/dBk4A+iSiq+ZHeNcbjigoBj1gprmp7NmmFCh3P97zJM1ZiQYwr1Jtpmgw3OQPgbXleftmYkYQFZqX8rms92eA7HBE846e/9rdMuOY3wnzbyZXFcPGfS0B9SDefuQWuKxxvkQlPNHQksnxdS2cpNGvyrTK8ReTsWEmihcU2d8XpwewukCAa4ov0x1du88k/vg8yyDFLRxFWNHMl0XVJuy1ONJduK3ySeOU53KUbNb50OpserHSBk4tArN1cil9vH3K7UQxMZs6KotfoARWoU6pgBwHJLLAuIdX1X1c2qlPIJ8FsKftsc+/e/GVj5WaR0ZG4nCfNXufYvcPZLYQdjlX2y/4DhSRDJzcJTxtCX8IYffPvM9yLGI1xlEVuq0SwV+0pd8xVXBhycexbSJCUYZUqhpcMbhSulKGTQJ4k8toDjxcN72gsRVZcl5bm4i+3TSbWU3x7cmYITceNOXb1e/e5wAUDRCnxEOGKpABY3HvG47kBrMlf/65Wu9TqhnIquSUM1YIGnaet6JApxxqKGVNul5Fm9r4PtJnCZ2cArYaofdg6jfHi2KOz3h5Qa4hug2qO1EK5/7EHbnepd/UIc3HUeXJRJVzQGvhaaryxL7r5wLRkSIMqilyazI2W5pUsiM9xuwiq7RUrpxS5hOIoDIEjcJ34UV5EKCOunfKc3tHr4fu+Gm0CKH3RP6akQV99VL9F17iEOPz7qEOsV23XxW/7kxj/g2+iRtu3GkF9YWzhnrP+Fh5ds2se9rORgLD9pa+MqURSvrpH5shud4oOma5aABimixM+90f266OKLVlCpzFnhg3oiy2wlbyPRZJth6x/rG0npOlPiaDfrR0U6SLIbP9C8rdGUndUr7MMgzMxNXAXkqouZ3/6nLipL1QmHXUhXVdYOf4bC1ovY/AXVYS+DT14YFXhOPTAWYHdr2aEOwS6L4/0RMdyFLN+Wkgm3v+1yX0l3Y8A2iTqniyUgVcnCxWm/DCKG58oktXjMqBmeGgOd+y+zF4mEKQViq2rkp+HalBFVT6lK7adXcVAZAcYsb5zndCn4UWKZCImyKBRrnMu9KpHmQ65eXVJ1XTth5TMiMVO0l1XYE+qfJaxb+T9J4GROw5F/g5URMU39AW9vAU3WOEPuaZwaeD8S6ECQM1gnk7TdFgksaDTybcltfAdEDTTfxf6gdgZSJ3pkxLg2YEswQausmugajiDl5+IEcQyzxtLDKCyIyJNtClE7mnizKFDsXaMq+d+9fAqAQlK1MeSZRdSh/vJYwKQJ5NzJeQo2d2j3fDsBv9nMxY2K6oWX5x+yb6EaqmklXHkSPB0F+ji60EcKJR+vpuTCPTLCSR6rZHQ9FwIlSi4bYNR/egoihrvU+WufTDz3/2fM8elGx4zZt3O0l7TdT1jhda2IwFmRmXg4uYqGiA6cDwI0jKAi4QMfS5UtV+lZ2HDas0WZiyPryIOIpknLWoKQSHZPcD03RvYN3iCHMEXO5p/HglJ1/SmXkAznIq1n0Tf2KJoIBJTE7X2zlepIOhWa1OzEefetjaAHhz0KE/YYGVUMwh8Dye0sRRlZvySrJ5pdN+A2kOGUBhtxjGwUcmF8bFfzrAu8lkS2Ueyh46g9AxfhtqCjGhEaMe300YDNde6AffZO5uV9lHTMPFUAtygZhaflVWp1stazFxzJhxikcHx9rXGWM5xyVZ00+tUi2bp2vXRyrHwd2fp9JvWp9wGhxdzuhN5wjau9UMh61gC8NkEV6CnsLx0xatm1tVQgO7JdW5pTazVX16P2d6RviJeDYD5elVXXYzviRKC3Gy/mLUqtmhcfwClk/ssWF7sqQt2n5qx1E7TFvndn8Xl5wdXiIOo/mXSER0heyXSl8aSfh7uvTTHfNQUrcoFujSrk52wsMbtQp7N8Wgd9OQeqY0qx2m+JWRRxIoqun4RkZqp3GEiVqO93NIs6GCzjE2Ep42FlGkcVPM/4yjBZsVsFo+bLYfNgwnxxWxewxx7o3YQelTZW1hs6UZUdXfvbQc6lEdkEpgZXClyWIc3bEdhpO9A4A3IiuOtmEJPf+BhErTtSSzHJJElgiXRV0HS03X39nNDJrfZfmTR+AXzfTIkszIUrpeUTaYGRZz3CY0eHO3kFCUwki+gBOnhtYdHotJL9m6iE/dMyTrU9XMr2CzxZILmZB3fZWOyA4OjKClsqTG9BFVdjbM/mqKH7/ADeBJvVydIGiFq2cwL1cHm3mdTKqo2rnpg6aQ/gqAcg7dK/j91vnpXMVoHKE9eGIXXxdKyL6v9qkvT5ypSzcR9JjGGeuFjuS1B1FtgG5rwU2DBWFsw6ARM8A1tnLVc5snnlJTtxmkSoULgZjUVv/RyhgPhJm2m5x79fKOiHVWxfM2Incv0MZFH2TkQP8CPJ8pSAPkH7hqo9Poy+tVqdlQCzWLO2ESh5YQKCj9l8vcZ1QLzBHZ1UgZ5PtcTCDOuQAI7MySuI3EDUg9ippt6uxV/VT5o+Dt2h/Y3MUkBdg4YZO4WT08WV8LOvpTA92OcpOf+i1DBcOYVJbfeUOqUjZqjVE9snebVGVOKMGn343ZQkvd6RgnqV9vvcJQY9gK7CixExVNSB+cKV8gS+h7Ab4TinaWpNso15ULS1p4q7GlCVzuFXGOmiwUd4Xri6dZrsBcIq8Ko9Gxh6m4qqdyVNVZzpMQG++SEhsdXuage0Arsha7UKkpQf9rwQ5gguhZjkKT/45VWinhzPtgxTcyHoVqAiqOWbt5L5aCvhyolfYJPz+Vmcwbl4zedH8aXS4TYjDBp96+oBOBjFEZFy0/ZiOzAoxcw0wlpPNLU6PyigxUlz5BY6YXA7ThU06GQ4tRD3RcPBZaAQGrhf1bSqK8AYc6u7hTQ4gTMoj5dYfMb69Jk89ccpv4EVIZ/5+TImbcEKPJQYXAgix6w8ebN73ghFNAwsJNw5uwBEqEo3UiQ+WN80p31UA1uDNa6ZCuQ5h5LFD5hhdb/3To5WIIWurSc9lRKwJMeBYNSGjDRJJqtI+7W8B3tHMxD7ONsR93vdAT4DW2IfxZqaPq/bzGgIPvpmKZL5uEW/QM81Ko086cBV/Rc/tAWZkOUQug/+2kRFlQNstJpWSXfiEBUaeTgzpWq0Y9gUZV3Cdecs/i6VlBMvQY0/HIvyC8n0yylOXUlgbwwIEi5qLfjThK4a40whptL/rJFuGIdJ/JS5J2t8K8RFggkExMAV13xt87YGdc3iuoK1xVRtHlK31/CdsT54IhsOCFPwq6QsdmJENTlprGhs57YboaUKUC74zv2I05Vp1quRV2sOjO4dpO9NbRBwF1b/4BrI8D/gkjpDzr8xB+uGR2PEqiTv6mH5PaSDyzlI/VOuBCZGWz7OgMaa53Y6eF6tn8hI4Ax1dJO1rAneiHVMeL56yRxepCC7ECxhZKsOPhbq4prMHqPeotBcBPa3SlYkuHHHKPePkRmAVXnoTkFXZ+Rhu9wTfqbbuXFHBLdXiaOkatB+YCuDI/jAxL7jD3ternXFYLw33P2OTPzcWHfu8Lh89HeM2ZXzl78Qn4AWxduYpCGyOLWWwzo7N5JrCd6DaDmMkXzDl6js7sJ7rJP40BEONw5f5O3Nu4ozDYwEwHXbQLLeyAghGVAFS0mmG0aplmBwWHTZBRhRzCKVWemtsFnh3++3HB7K2lG6/lhVQCKDpCe2x5kVyVM9Ms0/CFD8xOC5+qXIEBjiFbpmEpJ3/2/WBBsgB6RmKUaxSSRxk+YTpWBcuoy5ZjklY4FaME8jczmwT/fBmpY6BgGYqMAJbe7N5Rv9q8H89gQ7hfRLJT334SOEP6xfjwKMUTTHrEeYDnKFZE5hoduOLiXSPuL2/OEQdM4PtnlqwO1fijQP4n4ZvsH35Elu+NKmTmCR2q5/r9ShcppDI/WJ3YgPLaDFzA14iZXKtt/6S8sGjMROJjs6bg/2pzBZarCdxpj/Df2w1iad6FZyj5lTtxhaoVt+3sl8HpDnBAglyYloaTuYd2TMtx5oEIqDCiXmY8ajoMRm7UvLib2aPwX3gm3qObgqLXdCHYyMECSmrg0i1oUvrhDE+dkW6NN3c5TnksyYNqvnPe0yRhV9IiEP92mlXY+DRXy7Y4nMTtshKEsnCncgg+6et3KnECbHnm1DuXyKGy6U5CosPQi5t7ETMosBp7jjBxB12NruwLeMEBOuBOZuuTnMABFO/nlh9c34aNpTPDPmmDkfWzyUKbiHYABb2tHTyhv7BJrYGMr2IHif+LokgHGhb2RfWqlaliWMt8Gue2BfQCEKgG4FKvQ+4GnR3PUSmdJ3mWeMj4m+XZy5m3Uff7RwsHGQLAleLfsXZivpW0wtA4rSkD17rXNrozxiuuj1291YBdQ07jwOnv94j1Tu+f4U7vTM6mjOv1d/UmssfRYEUuoqOSjbh0odrVQTsQvKWZRMAm+zNfJyA54t4luF+GqhYZReJ4y2XqDErnQEgUKbA2+nBa00gcYck41HhP8joW7Ib1as8BbaUJ6HaY++ledC0WxwiSUZK6qphKbRt6OF+RZksk1n9SVF7cMqqxF4JvTsmTz17Dkjq7AxGU7LdCzqnL2w0R8uddyV0D70Uc5fzfXDRr02uhVg3ivNWN8/5DYG9dnwcQv9V3U+8xTRxcIz+yam/QvpUpVUzqoIsnaPrVttzcrbj1nkmrnJJoVVnKHeJrnQqBNHXqQTwdy6PwpEYIMP3+mlzBfAZnlGLZqogLl8JwgLXHUKYQAWJ/krsn38NRSAzThcQBLwkTbxsGIiADLzcLKc1LbY+ZHMIokn703k/O+bCXpXE0PDlSUyv9feuTtl/exmAcXbDZtnrKKGxKTdSKeCi/kUvepyy8rMGJ6dwkFwWKzpP/Ci7DzBa5S1+9j2VmCT0BFjE9KWZ2R9qIAmgQoWPYiFbHBNXsKASe+9SMI3zBXUbeLJWlKUDrgxeiKxzvkJWfX8XxdPCrquT3Lbo92WSVOmGrH4gp5TgY98I0SkNe5B7QY9hLqBeIJuMURIxxTfdtUyLrUwn6WkuVebNRTl3pYXcopG/7Lj4XPBD5F6sW6umAw9qkAjfbt53VYt35xK/smUYQe+8T9KfvyCKM9d9gTzZUJMCZm0cn6K1nddoZ3tlTmZIrlM+Zgiu5xB17tuqnKscm0x3n3ntThald7QSMHr7v01rrGO0jyREDATnl/qDlydQ4q0h0ooe6nTMoe9WuvLylKLoZvlVc2qQH5Vp0KE34pH08okBpcbgjuzSWwNnhIHJFIEozk3J8WvryiPDRyCBz3SV2U28xbh8owWRTwU5qs8uay2XRL+Op7uhKbPYA+jZx4bn3nPPbhPA8rk97HNkqjPiE0vcOoXuAUjU8+LR8FHVeazxi/XKHfzw67kXhgE0IM0PNVSVE29VNRfuke0EHdlPVnE5PrNghkQmOYmnJ1igWxYak1C04rwP861m1EGkwduJ+qPC2/guSn/Ae3O2thHLR0GlZ7aRYpFMVVCffHE9pjvNKm25jFj5p8317GuV4AbWP+IS95omWET1SApz2qT6PB1ISjJ5mLhzehPZpZzWOP03cS63o/QaASTLS3u81ycpGL8ymF/dHWzJOpChEAGZjp6m97X+/VBnOhFBSWvJePDj5w7AI8AWc9M0kSRSyWE4Ex+4Jn85f8Wpx85zAlTVDI0DH0Vn6FxVFnh+ATOKLJJO+bZcrJKGieY/B9OMmSkQ5seeWp9cSd4spfEt4srLLlCokEtWq587u+tG11BP2QIeci0/n0ZK/bUONi9frvk74BFCH5RpwjH29m1YVQaUBjUJh5/GF652sGM6Id7UwPyJHgm/vWlMFjbLAkL7FRvODW0hdNfwf5bFZAoCrP8X3rA9wXJWBQwHV4TpdDJCLYCKKy7pcYrnD2EmUr+i1sClIdAYYhY7hc/KI2PFPTUa2FZj4XCMjBqTrAKACdYlVvH9qSVBs88kOuEBrRX9rr5RnR95JhqR8iwDJGUS9MgUww/70yx9+S7M4OjY8YlZiV6kPtlVuNIUpIAOm83hmogO3v9xXqPfG1ib+e4t9AAunYybbtrHPzs2SeDG0UbRRG6wVB2pzTCdh7A1BUowXzFieg5j9XbiHlOGLm5ATSW7S1UnhaiEJFrZ9/XQlIJg1l4WVfLsDsbkSInxCNXZ1eE7AFupdX59drj3dtfJhd2ElExOemAX8d8hmrDn2bBdR4gqPYY1nU2GFM3ZsojXSwwNDi4OPHwN/qV6W7oCy6O3quSyouhE8GvYRi64BQHKoEisPeTHuZk0OHIN8ouU59PBAp6+MFLEjKhkW8F6j5p621QtpsDasTEBZGOU+bzcNnj+IHwDfgC4esSiAiLU28zsx7utxMuTctmVuyh5cRMSFnbVRq5I8v4cuDTjXBhbI8mREoFNyHhcUP3oNtypHpOT0G6QzFxpNwA24bTjYgfzHOSEmxBq9HQsj0PRUF76up83aWZHNL6ls8uCECLZ7jPeaPB0TjRDddglHzt5m7x4nxqsjFr2+IrZORS8h2EPUC86bEf/hymnb9KPrmqwv27tDu2TBw7PbaZpk7T1lHMOdqvZj+ubvYsv3+rMVh1VUkPCCQKXtIoT3R6RGsYcwSnVgjYhgVQZz7DtOIcZOMk9JB1cT3Wq8u6ZRfJ297GtxDNtwio3FEVSNSMnhTirhA0GHNil9TYA1I96vVEb0VxUkk5V7LrzobX14q2Clque9mfSghoQE5iy21/bGaUNGIQZs1cN/4Hfhkjhxh7Ba/oezesgOV6CHjDANt4NYf7npacUDMMF82L2Mj+zmUgOSDNDwU8yOEVElOpjeJoAqK9/q2EjS9Ih1scPAS4ikKNfkhxoy/Klbgkd3JgW7uKZE0q/NB4ka+0JGBt3fXVFiIK+CrJvQ1fEgVVsHY3GOZGsZF0cmWCAzgY6Y1xyxc/0QD7DxK6gnmT4MU3AG3wx5UZnLihVtfOOJUoqWFDf9/VmwnWj4bZ2r/BVdQPCh/IA0+rxr/Rq/ROTo/IFFgV5bPRx/tE5/N2hDyhtxzPWzDZ34b5PVBK6yQHtXGpyNKVKUsX3Uj8guIxz2FNoIDog56LFSc5SQ5K4vk8CW4etpAyujfYW+3eALjmNqeBVxN15Ifge+c7yprcdbMEeeRZXuu8Gkk6JVtaUzQ29Ni2Y3u3N8Xn/ikgM6sBhbZ+EGolgux2lHG3d647RSg9GPm3JGUhARSfXjGhENwFty9Mxp/mFLM+JOosOXEJKOmS22PayJUmmozU5jVL1s7/UAUcjJpDcaWg50WqvXXox/y63PjH/Avk/lxLBZoRVczlRRFMWRtmZ7oyqobybDXMMyfooJ2JEXD4rpE/u5l+3VvVW9IlrpnkRzZchmQ4Ntrwrk7rQzZEEGJMqPjWQ+2lv7l1o2F72F1ROHU8icz0YsdGgoqo56X1vIYFSDp4ExNcoT9IqDHBAS+WtRn9/9QScUOBpuW1vbQljG/4WnJ1URklP+2a/Cd2uSxP+3CblszyYehox65Tqr9mPobP2ecPsLOBpxDL7ps9r2KZE6eVKMuhlE5tmF+q9OBukl7US6h23qM39V19D4q9lX8Fa6lLbdO63SUDlBUGDINwRW+g66RdCnjiUodZP1khDVv9q80RZL8SPCrMw3Z3tdaIaBbXggxeITwjfqgjb3WzVv279QaNRRJ3zzCWnQbGpkzKCfvxByBUFlVczBsDKCl/kYW7Iwach/SRXcNd0K0pLLHQEgGwg14Icmp5fvBfhti9kTmCd2IHInd2IfQ3G953HuVWhpNG2wJD3Dcf0JmIE8q18JyFtrNEODe65AfMCPVSj3qK3s+FfMLBEg1GYjWHotGRCKTCjpMk3TKbWXHxzsiqL2DvCswlbvwyFdtaHNS9mnPmo1Ic50EkD+GYF9v/f2lnfmiAFOIMhywiGymD0mTA6gv83dB13NvEuy6Df1m5ERYhH1GOf2xmooSW6JudlFuhU/4d1O8axopUkmkb90X05hw13cbOcSHzV+7BwSbxzSGWUk+ifQ0zztcS18fTmaImwRF5bwp2xPZhcI0ZTG9BJ0fExsVPs+fBPdgWAvYjy3SJPOzVpYCd+P8V/AuH8LjNaiL8bzI0p9TPd7+S6G/5ZownwFqd/K82uJnb/zWWhyx4UVK1YWmNx2IIOdWprKJuv/UP8CVh7J722C5/0UdqZ485r9RiENmYqZ4UJRISdszTc371Y6IwyyHvMVCeDwCWA1biqAZkjm4RytVHI06qTj2xjR3Iqlt9Im5hSNs0P/dRk2DUs0RI46A427LsKxt5Dwf7wSUTp+rySLJmykLcbo29bc0aXo3DHqo/TZXTA+s3kAAl3Ojdv4tMUU+obg8RnxANC4Hwtz1o1sGZL283cEavQAD7lKFAgEtSqm7sMNU8TbvakCky9JGSj6EhUSvhgr1nE+RWVnCoKijdduzZnD9skifOepDofnrhDUc1kYQJhzEjCE1i084FAL2nJNtiNSsfhV0hqKr7PQLxqDm6EMINrPGg4DG4vCHeoKRqBLrzDi+TO6etggO7NtOPuE0sREThCZnZ5fMXvnguHCYin1keZZRmkxjO4ug7f7FENkHtw/d603rpa5z4tcM9vPKAzp9nZa2S1VtVle1KzBCYMi9cFDT3b7z1Lrhr4M57QA+hcQUQmXCw8yQRqZwpsOaQdNZY5Tgb1ibuXktFVjWrDquzLVuC94+LZkbdQagbi2LsLmTxxtohD5MT8CUKh65DT9aFU3Ugx6dFZSbu1rwHTwkSKYGzUDO3PyQu7usa39MDF2z6U/dWgUe9/b8oJnmvnqfCh1Wyjuhsfqne1A5rgRdlgR3gWgpgLfdh/iOpASgv3aEouLaBkPo/C2837IGVrKRhfMtmF7qL/zAg2Mo8LzDInqIIvzy0FK3YSKf4a1c07mWwc+uR+QA4G6HyasuCNiPkahBmICv1rXEo5zrvb9bolubb+qjw9nz6gr0zhVCSh15plMilJtFzEkshZD8qC19Fe8SjxfZ1HvAbhGkZ/8U1AILwbYuZ3CHqB8AtOxSsh8BBBUSutv7fRRgtwPFXAcdzMWgOJ8fYmEUUcuPRWOwNZEn2aA1Llo3O6FUs1kQiZpxSnx+RPvUTOcII8yoeUyfFQzIe208723bAJrZ6/Sw3zg4Kl2o1LHsiJNG6FR54bj/3EW0QjXe7tDsYY44U2k1577nxttfv27KkPSK4HhG8lhUhu0tp1sGJMsosQyUt+vbB1C7TWRnWmHKIu9eQwwJIvcdN6QMb+f+XxlndbPjNTBF/Srhdzh9Q+pN7mcXMt971N/1E9OtD9BFbTzWJewJ34GA6BtdNWA0oLyOLO48q6e2hEgGA/XbmobRtjeYMQz596rJzg4fFZyClrrm9yHawAjliedMmL52jVGApm59S5+HgYYHc+bN7wNZmcDV0/1G7oIkbXGSQm1WI7ACEo6lal/8UdpO4AiH866InmH8dwl1IMEzcdO7b57genoxVULZLEud+AkBB5IQZ4CcDhUuBMDgJEyZZx7ApIqhiAXydcXzCkNrY5TvQFg0Bd8wH4+Ppx9y6Abi5d+4+E6thIempHuOIAOEijlaAni533Qr1fIJWkA5rPBnJbk4WzM1nTC53pZuUYFDEcXmS/HOJa4fftNEBBEEud2oTQ5vdZr1T2qbHXSg2lWUv9d6lVyMgZm0uPL+sUSOe9EPXgiCxWT8JreSfXjnBhg2imTni4Ym6o81w7e5VDhPpYmU0/2cwW2+CRxx8AH5lTQ1PtFzQrKee2KIy+d5Etdq5zxp/bm5YjZ5R8gDsMm781MbShlUqYHqrFW4wzwvkmEHMPaVhCjgjc1hWMrbRZ6ZND9w0xd+GqWULLTHhtuFVui0GIv6TmAPEKEmSuM1R0+qMQYAAhxJaEcW68/J4kTU6/g3Xk8KqP16obI+86vEWxFhJvAVTdXmxNq9NxVSBAq1lCRGcqhlRUD8BO12c+dX3U7UOPN1KHG3FJVxLwfKQsjt+20lmmd1P6N3SoPfH7NLCL3rQJCK01J1o9R8u5m4vdh8i0oWnlrilkKTl6O2HOeOrCdZ9mYFzm9tPF/K0iFh/9as0NZCfdz2BmXEU49xEx5nHdvP7MEidyyoQnuO7cbD1/6EJ4ebj+RH+AVC9fjSSfjGcbOtC7X0QKzbY4qZRSlN8Q/C5kLLU1gtHS69rOnRMWHb5jvDBHk+DHhp8bOaq8sR+IK7EY8CikLDeeYwtXY92C7x7xAJVr2Xtvz1f+lBgrDXd1rIpyWa5XuF96lojO/HUaW09TSvZ+9ezYu7YekoBgIXX1pgu/bhmGg9AXfZFJeHu5+sxoq1To8EiYQQ8qXwz+4RCLkcfN2fy3fjIuCyOIUfdzqwSe6n2S6jAV75XwXo9XOC2ICVHeym+6VpgAUlDTzZPjAjITQgkqzV17z5tzEo5PYw1ZvIe3VLbHL3ODEB6kyaDgT4R0+r04FwrdtpChQQQ+2KBNHe4kaXQiv69mVHxYUR5dfVOOB6VDLznQd3+EwaMvURDnDbiN17GzcAAPlBdCDly+T8zneb/9jrffJJ1gk6giMzM0tHY2nxo0XHvU8MEq+Undfd8/lp5T06ARuFiRZzkURvvWg3lMg8bc1LriVTWratC5kQTXTBr8M7Z7CKSeK1eq4QhZ5IlXdAw6VtwWLA8s6vr1KCKE2EQfhHWB1HBA0O9fEw1Lzc9QVuHWtwRy17uiGT8Nyy0PAMnhf4WSGu4brbmxa/9oa5+nHjHBMViS8ezSTb3qVrAV1XhIV0ydr59a+IibOLWAf7HXnK//mRJO+59oJo/Z0ZsOGY3L2JXLwYc0OI9TZYQnKamCKWKbeyv52y7i6Q5KpgCTuEEMlw+jXyW1nBhtGAJlFWwkd20lRgP9VOiFeiiIpb8rF0HYw2DB+okvDX2DbKRpf1bd92Ez7vqMFC5y413thM0v3GPSSeJ9RWaQLzMiZSoKNz0dWeEQrwPP8/6w2rMEk5QLP4CHdL8DKRMAZ9vG+1PVX2ldwseCYXYZENpwZ30HvQZj1o4b1XcMy/E9rBy4qCYgqVN52yOq9M5EP60A+oq6NkCGw9hDS6ul8eFIKrqyNBuC9gJTuQY6HT6Uep04oqyP8gYSlackb2Rx856hxjVq5yU3a23tL4o3Su+rjvymJp7hto009SOSe/YhaB5oMaRJBIeABbXNVnWTGD1hE0efU9oy+a/nEL64+jJu7bg2wJHZQTeWnI5CFlzuPNLi2T5YMMEhpPSG/LhgwsaHd6PB8594uoc9ofUWGQTIl2DS6wmiKTD0t5Tmnok4vN5iNBP8SrdeWzo3daKVNoI1y30KEbJD6wObFYAWh3zyFNsht+9oDtiCMuFN7InnUXwXgXSNXAY4ghKIBkzzUaoDr3z02h3uvgWQh+IzsKkerEfdugSOCX5Wm8BCctXPJk+0r20cFcvSDQSss5CTHjyF/yuhslGd/ZEUG7rSgM6tl7Z1at95HqCRCm/GJWkLdSq/E5M8vYoqaCUoEjyW7ZsWRdEqsSE1RKDoeBbbtdbR7nmTjZJQ3gmH9EQEJMdpRiGJrMBu8ngBUNoXMDHesgXkCsROG/aw0muFdqrR9GeKK+5+MMLW6jPu/c4wHaOl0a7hwbm0ST6Z4OEqXEC8f0Oxawu8DdB5A7UTo6nKuDtVbARnWW8Yn5YrquLM6OBqW+i6q0yU7sWdN/oeTV3EaUDNkSypBOJKNYFjv33xRBcWqjdxxqzdK8yfeCqFzNo4PVtx+RCpVPXtCO9TBp/kLRumDOyZPCcwm2V3nBO3DA2R4gIweW0Qfz4bJDoHZ4ElxEF0WE88GwmSBFgpUrx/DO4itgzQtiZd1w23PTMqDBm7DHTdiUgAl/2dFS6oFTiQhH7cTkTl26+9GclZWcvkhQZW8nN7lBeeqs79yU5J1hdoeI6IRyWuL3w9YlFPVfnUgK1MjodWxxwqj6Oww7kfgCJIKPf0N6fVcLxFutuJCN9QXAgHw/qHo33bvhHMsrW9Wcpj6hOWLBY2DvTiiph7iGtzBJEDJmG2nWT8PWDLWP/gzw6mjfV3N5TWHQitQInx5kLuFhKExaeozalstQ2UupxXU86vrDWKcaZkO2Macx5U5mCV51AH/6BIEU51bCPh3vrK7Nxbo075YdiiveQch33Bf3VWOWynf0gXZ5XQ21T7TdzF75of9+/+D5sD5vUM121YJ9q9fgeb9ifO7jN1YOREfVByPpV+Co5bYao+tP0i2XbudaojYAoO3fx2/wNqX7g3va+9yFkav6OtaDtEilZ2viN5cTw/FtcqIwxYTUmeKqn8T4eBRCAQGt5ZYA5dNpELoXVcEjnudqMcUXSTCLrFK2DVy3BHyhrKvZxZCxozGIJW7lH6LEPAX45OrBOzXyZqwWQxJYmM94YhiP/axqJvewSrrmjksfNaISVDgqgavkGyvo7WTS7yhzjDNJ8cnDF3sbYtFIwYubdwmURKQ76dmqIKySyND3N0XASs9Snl3I1lkVV4nDwZIpLilNj3TTJaJdFw9spblFLlzgYbQmbPT+PmHJYnrKAswhBhbFKpswWITQh4LVx1v8JCuEtp/6o7w7zudE4pjAlUSsbgUXCkbMGHLLW9m1kPPuiCQZcqDDjKndR963R7sV3woq75noL2+mHqi4IwCih2SfkHLK3/G3LEQOUoNeyE9DgibN6nRfSpZc96yO0WpofgKrCbs47FZk6hPaWuwGNpwSecz0uY9D9gfFil1Z9KtJOtv7qek7/pDBzF5gmJaugLWZM35LiPsLnoYTI0l2axcCKQcGJAtC5mfXUBiCEfDy51IRzoMhCoRqZRipjgtjOY+aXHQSI2cQobYH86OoQFzELPtxBlOvNGKngh5eT091dNDR5CsQAWST7tT34a9LBorDoS3ebIMu5/eo98g/plJjAaWP1Gg4LZgubnW9yFYOh/KzYx2hWkTtHLLQ9KN3igXxY7jlfGmzw6vJcT07XbRZY6ZabSpcWB9R8mUPUPUb+vw5KPz1Pb8V4dci3wQi5Z/aOnKzQLpWId9lmd0SlX71GNJ0zWN2gqIdOdlS7t8HPbxuyrifqvZWXa0+ci6uJlrdAfJDHK6c3HkPgECs+24TGj5INSLZFkoJo7gHXrmOHcq7CLFXONmH5f5UB6ntlqZ6LyL0v0DV50zo4uwKSWaq4/mFgyVfzy0D6CyQLWpGZ0kGfSc67QavQ8mXLG2oEiWsBhZoSHc5S7xCLG+1XhcLyDiOtb9sd6YDYlNBMQPmBacP80hRayb7LhvzLVhKUK4eIxaojGUzEzqcECatqlbxbPREOXxpxgy/WDHvgdyEAPBj1jTIOhLIpqjdtqg3TF/qBOf2z2QzKPy7K5y1kik5VMKwUC3dg4rU7wTJ2NLuVJpEumpkcp0dzBi1QDUFeFG9/0SuD1i5lyXhzcCxKvIe7UKo7cvSXrcrsm4KEJsY5oF8igeaDeSikZX05A44NHIsLpQ+kzSOCN43pQZuSdD2+chzQKNQqWjJjzpVm7gWwPROe2yGj6OfsVtGc0GbM/7HAPiKk6Wv3bzw5x5XoqJndMG80yDFRoIzAOA2KSbZ/5n75Tl+c6WiAEmxYRL/yYV5Sf7PSWyKFRBkcwUqefDId8s5T6HL4Tws+0PxZcL9kGrVmoKBl4iZ8cYvvm3qHWM1keHYM4jLtgOJyN+/dG1Pqltoddx+ACegMH4L9a1ASYCdH+oAA2FMwbywhtmBFzr9ATpoX2AeKpxVZEtNMnxa+qGefC3cIBr2WW+hKCdCQvuPvajBMkQPGvqxdIL0GFMbxRU/sat0QV0xRVUpydV0DfrlfCJpjHA1O27akj2QRv3ApwfBb5P9Ph0y2ZbPvBld8thfs+LpcRHoLlSTJwpwDl3rkH4CUC4LXfYA3d8A21aeF8wX6JdX5cK35UKlbLZGhs8hrye1RIlw1yfT0ibtLKIlmJBz9aZZz8WZSvzB+0izgc7JbaB5DnB8OqBrQBNACDd0qbUEut8U74u0z+2FlpVCFQhb45mZLzwAeFDSPISj3FK/en83UMFRWxmtty15DfFkT0KP+7sozi9CbwoKlDPuYA7+ky8gWQePyXiMCSGsnCwtrR/kvg7l+OTujGSM0g/tOCKbAgSRHlBKOe8hx0LjD7DOuGmxU9KgZTGzTfP8oilRUHwXzLM1i7h3TgTgXGjddshtXwGW8p0mVZa/BBDq6P6M0Zgzh8el5FpMWAEKGKK/rBGHviwYUOK0kggAgU4Yk9q1yzx0KPXizXf5Jsb5rfYwTbj6vTBru+5GIm9HVzgDmBD5Z8jl+QSmZk/+s5YKbGybiPWsUyvWslE96kNqIq1efhIqNMLeUSHVpIA+l4QuOTJeilh8KROAM+0W4zc0KDMPumy2mQY77reS9fed3/2Kld/9BgDWNJjHuPYsooldssizKVENW5KMe+Qr9kaxYNIp8iS3AST9PRy53jbE4af4K7Sk2icT41+EM7vU8EGNyVx76Bqicj3Jt+W+dPFKhzyCpVqsffuCFdR6TqSM3ncBxYOw4njlPiNyZZdvqrPHonl5AmhACGnRhezaK+EDEDBGYN8bYwT/SARVJseM88jYagqoSNNTLMI9wHcEfOhfIKvKTsGfIkOX0Wi0rJcHbwidsBO8HTYzQjxvxDaB+Jgr5vmnaFjCrglHyBYr7FQowvsZxqvOJBzLkN7zePs73DlvzS9B2N5vkKPoa+BVgWP84cAUnuoQxhlhV/LbnmMSVQ8Ej5UmHt5NO6t1evAM1zvAfRO/xwT3ZKzrMoIOFzb8aQLmlMNk/3QI7Ro+JxO6d1zsUGAWo6FsMjQ7MKqwS039Ikfeb8Wo8VdPBquUyXhvjNpf0UVYLfv7RA0RZDJaW4F/+NW6BwpuLQkr3HS+ePXkS2PUGWCEU+UQjsz0916X248UtkGil57AYKMVJvF3XwBXnZx6cvdymaYhWHDaS8xyrZjPEpXXIfe3a+Etu7Uo3QZAVus3l6em628gXFhxHFlHwapNoZtpSXGfsCw+E0INCNYY1fFYlx1hTgwg/yNahRhe6UiUtYwTaQs7RjTQ4U0cNBNtogreKFIPiYJDbSsMj96+j5b9ofiidvKDNrAL/byjJZt4npiRzMuRi0wkKnGjKMihf91V+CBUR8U+ddjWJyz+RH2SYdk4t6ZPInnjkm56F/ikFi1islU2dSTbJ9w4e/maCrjxJypudM40fa7sOpM4ONZhptyB+YKHT1iZGMuSsJwZsY4WLb8UwWDOTJO41A1xl/X2dGFMRjKAc1Jh2AponwUlEa+XP0UPiyZYfu+eeKW6vSxt4lUja9mceFaFbU4ys2f5b14uT47VpduXGjMDR3qpPBFP8eiy4ceok3vZoY+Gli7ddMGvuVLl4pvyaixYDn1TV38iRkYt5ZmMnFmH9OTDIqfS/6MICXs5mMsDH9HzmMpgatAsRWjuuXfMbI9VJnBgfXymKi3zje26YdodLeXz2e5nwM/PA89Rochu9gqFLfggPJBgBAODotGKca4cbRPASPvAnC+3bXcpASWqPWsbyNWPECzHi0RYpfT/3ZRsIy0fHtTpVCwiL6FXZMQh9bPo056l9Wis4/okhsNWZrE1Q2MQOfoH4ueO4TjGbq32/uj9QmivcCdwzKQkgm07nys5DM+ouNA80EvAKTvi/v2jxoowJvbTrOjhYcq35qyZpWQIxiwGzlDQYRMC5VZkT/pH6FGQwVPeQ9r93UlbYM7FRv29wRPSYUMVRceSBlciIkP9k2/XWx/CMkrh6ZsO7pBL2j8liQvh4xNJ3XbCYPVAb59oW3kxJvuzCOJpiFah5pfgd3M+2YNf4hp3Z+aGaxB3ZRL2h4YAKPtKMMnHJrtzZLtinkSUE0LJtovOygYgfZ0EhKqkEDNz1DNbsBQBaf1Pt2sR13TgDiKKrTQHFItDKlERSeu0BR4dewDXlOY6jmiHQwjAKocojpE5ALNVl8xyrcgqhRxSX+cGN4gB3fmbNenFMqb1gNBFsEP7PERSKpQJ8ZGlKMt9rxQk5SqPmkqT5Qy0aV1S32Zs4CVrJuAacYXyhabDLDoA3sacoqqLxti8aDrKM0IeqAD08fw4Dc3wf70MDVcs3c3OUE1k5FBCzJKCSFsB8rb3Fh/umJDTMYFQtv3vngQTNcZl6wS97SGJ97OvZhsWMQ7voU8eGLvjPTvwo2qU4lAu6Dg7DXT6yF4AbZK48WcGhkRb0OPQJixvwnZWzPEISyHHaYQS5Hdn6dCvI6C4/9viQNYGav+yoWWHVm/9S5QE99LZkjiGg2Qea+QgkJywCWw0H/hZMaDZ/9sFF0WFoQlUcS2I34Ot1QMiO+aGpRxf9Bv02kyHo1PYrzMDIn+kCC4K8S4vQIX7pKvWm9EDeF3Kiw0TU0UM1qAk2kulkBcsuhwBa30hP78CwwDac5ANux1E1YBiqZJnJZ42to0TvcBF/eg1uDFGjzeoL/Aau+KhhNl0WnfOakaNliLYD8Qz5Cazcu9QbYpQQWCYjWUcBFcF0p45L25/pQwdN7jn9l8h9EbCRBLcaAQ9d2TktEZo11N1SxNtxXdE40KNsh0UZ4YngOFKyIxLh996RFtOdwUb8Q30prrehlxuGiuXmP3nil3AxdFPXgzpFcBjElU9vXhYdd6UInwtAw4WvDLaqtjkAr75yfIVlSW+8kBFg+zmAtOGT73thR9DuvttVGtPfIuJrwwUlajrG1RePlG5j5JcEzjhDUdnm/tHCtKPTr3Dp+fz6uVaXgCskLR9KCCCzVH0s+W9uH+KUWgTt8XlsS3wIRvt7bBgS5OwPUdNAIcPkfnxCuFJM685W2W7sNMvoMdRNOxNOeJWQ2+VxRCtBLYNr64mhvq6kYFemELg0IjV0NQp04NMat2C3BRg9K3DslRxoNmgKiaZklXlF7LEpBFt8wduqH/+ObNf/bC+4ukNeSU6jMiZYdLEZFLrj6pZRvCg3gRWzwl45LiBUJEy4Gfqvpwaw8gi17MGb+m+PysZW+p/IoJGJhjZ8/AD3ihIf35NAmv5mYhk3GUnBnRAaLXSF7SUN+mIfAeehdYaK0wVo8rPojN5lkDnSfOe+1DPpm1NO9DIo5uR0swx4yQq80r2K8/XlIcDRglWk+Tk3kHkP9X/DcuCPmJpMTs6hicy7QeZiBu60ce+TB2I+URt3skS4dYNmYV5msfCeRPtqVNRN0jUKVoQWewksEo3lunrEj3/hP/npe2OyzmZ6d+swtE936RsnV8tUN2LMK4LM4rNfqQXDwkQGRiZoCalIwIKGPkDR8kdGBRv2Qtu4Rxx3m0xKwgBVJs6oDj8iRBCgkez+Ucojhzauv5fLSBko8TJuTEAyQIS2jvlZlqDFhPdq8KZ+AB0c+NUYg24v62kQ6k4RIsVCIR7lZpOM5IMjMXDtRGY04MPyK4BMYhmOpVjUnF/GfX+e70J3pFGUzVfegw+M6wSqMpJAPyeXgVx/Zq39g7Yi8SfdEqF+YoGBrMw4aRu69lxyBLqG1gyGbVbCbTgJDwp490WWFZOM6kfqFqGwrn5OjIFVmnbJx/t9jh4xMoXolBMXQwrM41crEd4/R0OA+8IMUguMRR/c9z9qvULUUblL+KG5J1BkQo33uiw9FDo4iaOZkAAu56JwIudAeuwZ4IWNQhIQYYxWpMljI+ssP6lQ/Bm8oCCJFCyvP+YZXycR58ZAGmJ7wjbbKxKl7Jedj0Lkc1s1fRmU6/U9/qDdncOH4+xJ7dWZiq3okLqLz/e3gx6loZLCQJuhY+JjRFSOtq75U5w8fgXGODnH+BpMm1Lrlfg9t7Spp0JoW2FXERn2Ea9LDZp3MpnZB4yrXZu7w382bIhKlqAeei7kVV1YmvWTdLS6oMcSgYyjHNefZTfDvbW2tcoNrnxmImprpPR1erGKPM6OeZsxEcyqIty2qaJlsxNs0B93TPIw11BsHXHaK/JtrmfY321ayMPiSPiUg4fyEpKSdKRWqgBYBDAwcz5vikEmDUIejHPbX7TPE7hoMeZyJaEj3GNeOOvE1pzwNoW3W/idNzh+2Kg2JXIzcKsIJKvYyMl57dUHiy1mdJc2pNQBXcTLgHYcoviLa3kDLhq4P9aU/BgEuUbU/Uz3l54fPc1bUkIivhybIUNI6SP7B51CUFs5EbjNKmJzD8BqDdBOon8cejqrnNeOvH34WA8pOG35UHXMqVRpbfxnSSXcHhnU/8zXxIimsYmotuNSCDHF//xjdNx3VWOKkKMtZi0hIATQzQsmsmGYcxilTn8iz8bcVRmH1n0Ipl1gzJGYQsIYpDkzFy32m+TaY1fwIYaaWbu+DT7JkfeRWDRq46koxdP5oBRKddQOr8HvlV1dW7Myad3bALhD8YXQ6+APCEDAnW3oE4szc3ssLdMUgv8MdbQCQsSd5/WHZrbODpFPHRgQZ5J+ZXQEm+wPzgjc/AQZDOTDTuyoTlyyUU4hnb1eErugXuV+kEaULaT4Ac6DpHnS69a9AnfVWDHICNw4AkB+OBzI8COYfLyFq1NpjNcETfitwFhs2z+ioKYCo8a+xjLLP6BAUSuANnZVqN7kHBQfwg/1sOVB8kzFYMB3tVniXy8FxPfpnLKlvxmD7IKf4Rg6/cBfRLghJNBoOa8hgbS8v691Wz4ygNvoAzshmkU1ytwN+T56p8TB5UIa2WKZBuJb/vuXREnjjxPoxBBG2qTD2nrHKOOMKkrTpg6I6jIOV41/mEErfR+HHVZvcVYq1YKYfDi4R0GDand3wFf31mZS089jR/hL2bBHajPlaK887LtQo/WBYAlF1a0PZxVwmzOQRfSgowp4PdDEFernhcjGkwJI+/3eh4ZHohu14mWPieGZ1hmg7Wyf244kxY8A+1IVJD+hN4/DVkNGImTqalQswNr79290oYH3w0+GtrK7Ch+SP2e6MEbJURDy5V16+1+OgFUd79QpSMZs0RjnyPHpWdYRW+rPqMzfhmd+2TUglUfZk7cr3KIxtS2LNcak+XXs8Cwu9yf0zbCUez2hqQzUzkWtoag0+vCbwpBrVbmKVjkOLBDf006RnDoZ7g0qAboIPB1J6QOwUMKIHBoDXswB+9w4vDMSYqxyLuvqHsddcuOwC1s74TBLKfRDSwwoQ/9Zl7MYxsi66rJxxWfDawJqbx5WRHimR2MZAWpxTMzDNVVPfTHoENdAUJKzE7WYwxZPXCbH6ZV0I77O29keHmBArjWYt19r03I3XRdy7kPEzZjYLCSdMk8+VCgHCFs2Buf4BLaxVG03rKdM2aHEhqB/OprZ0Ta8IZ2cTSimxpJ+ciHGJHuU6H2Pib7wTrXk6gKRpXNfBzih1XF3HrwlVvcdfKUzoHaOVYY6XBovgHwR9lSq7ZG1OoG7edeU6noi0VypBAaoAv+QTC8miHDJ/UpuLpfkLHVBHNTj643pnR5uPtGWy6S8f7ocg8FZasA17NfptR/O3wajtqLmzUbjCzISba7rH6d13PcDX2DAgvoi6giQ0XtaysqTFh/gRRWvXVhyQqEQRRmfLy6ZXlENb7hH43Tsp7PMD8+VLUmI+h3mX6BZzNaQ12U2X54CiQvo1Vye1vj40oGffvg43j6ElaIA6iWDJDZojc3BqMuYvGfjUGECvpVPa//bP3L9yycpTVUobRo5Ifjp0smHIqTRcT8BlJBWZleh2JiDgxBg5dYhYz0+l2HrRvQPhpB3ZLwf0Hqv0kik1NwneQrtyiIclSm5LN6F7uE8mVO61RoD6Ogm6Q+Jp5fdlElgUA47neHnpCChm4p7jJ8qcjLxOYz53z581bR2j2Z5nG0cXphOjI1xp/VmWeIXwkuWmpMuMKyzXcckS0k2zbeeA7WVllZCUOYDK4siIFGe12Fbh3TPLc00+H5SXHhHCMmLj6p7cmvFUbazheisv9UpIQA1Zf8yEDBP86E+rtavkeHrj9sJjGni7eWsMUrEyghmRkoN52yHjRw+dsdT7qX7+megNBq0GJInmZo83wCWAzaL7Hlxxvhg4pMDfQiJ0QgZiR1St3/tuK+Xb6PVi+fJOAyuBFiTBSf4dpKmttCDfMvHXErXPpl1FkJ3/+wshaq8hR01jSdAsvXPZpE74siMDp97LjBHoukHTA0xZ92sKNrHn9G/u05fq39BOqnHlykdWqXkY2COgXI5fF20uUkRShoMwr8kyBIpSa/QVfH2NHbABY/2gt0j4/ttExQWlrykJMmDi6h1mnjJAZZrK9e28a6dsUgdWrUJ6VHbEQxoa+hrOBJY6IaJ6UiYzd1K8Tch2q5gcBZ7PGE7aOEjKbuLOAOOhIX5TsyL+rfbINjSeLk/535BWBfp/Gawnul4cZDhd74pdtoYn4Zvb2OytEVcb1Uw5KJyfFd0PVp7YIJIk9IxQIRxohzezwdb3aev2Xa4ujhLrWnnIafMhy9sMbZiToytekryE5wpOLhxP4B9+BOCz6RPkbhD/Dy6p57RCBQjRe3qahOJn0GYDagVFLd8Cbj9C5n5XMe6bB/64C/CCoYkSYG6klHHSHtp5Kr7YB+ZBujR6R/3K3117+oksaOnDQZknYLkVMKPBEQEh14m1wTtV9kITdu1YjA52LgN4LprrYEWKNcDPNDz5hMJjuI34HdBKLqJPUwNZ4FzdrzA2dMfV4NCwbBz00lEUiDkVYKaFmmUzYCfSHyWPTVjvIWIV2+5zF3nzVN+ltkBQYxaMJiLOtm2ZTAWr1TLHSzlljM+lR6hsTy4IDc9ym5nGQhlqgQLga+2W9FarWHw/VhKxH8FfqfPKw2q60Oi+kgbOjuIXtcJ61+kk+h5h/OBfvK2EdjeDIlVf+UahwxkhQToIjYQMBjshn2JUbdJR8VGYwdM0XkLKWdAaGBomR5cJOczMl0w58CuXHmpw+DTxrVw52BcamR9Lm4dbliy+zpdSibeXUiZhC0JOPqmH0PjHkSw7aD9DKvQlJEz02F2lnX5KExZrsH2Rrmdy4/XS8kWOMWOpoPPOmcNkpoF5YdF8VWaqNnsr7JlnyRKx9BNhFNwKR2+WaysseExWh6TH9Q3yq60rEvwButfihRDL4SemR2Zcdjw9BKtr6fN2e36vp+t8h5pkFi08qQuFB/yWoJo82jqT9oavLiJuQYIujoWjYPKBR3dV+KQFPieAhTh3K6CqPiJ5xK8r1KO7fdPf4ZNSZLW++8ID+VJ/aF51ZTsaMQO+iK2VXpgnnzjzApNV6uX2ZCnyp0FoCaK47ernj8vhbtmgw/XJm86F/TPXLF2Jq6V8obc3lZjXuhw/QpRVcjN+IIY6M0Buq9e9wipPONmC+aJkrMDa5i9qlUTipH359ycAXMYLTZJThSD+ahbRib50IC3eWfLmSdjwk0P/tC+y5wx72p1Xz+YQYohSv0RkrbFpBccC3EeaLecuoNuQLjgCBAY2/DHyHrqfsnEtYCjsuWf+E21qHTK/TaOO/3IY7wmvCuZ7wQRSn2THgCj7WYhVkR9d3GgS10nB7AEag5q5ywPHNqtSamna7u369Nh6VxcMi3pEpWv0mNfulO1q45cH49o5/doawNHW2GJjybzm/hJIKlFQ7/ZOKhrWUujIiXUvo6wDzFPw71UDYq7HDwQYsZkRvL57QgaU6YoU/Q3TvgY2Z81Q9co+X4wasMwaoqVTQ1B0peqagx27bCRqmg+/aUP2/mUtLEE5nEOylM0DOUnha1xfLmaiyT0Fj8wOqOBM7dIGkSUa6XvLdKx1NdIHcMJyjfsK9S4TGcZbJkd31zGCteRHC3/gESMDIqxP7+/eibFU+JhLE6bPedKyHahjKnersQkaWdFd0jy5+IfQ8MyT65MlspcLJY1EoaWzzZMKsEgeCWH326t3tl2xUMJOXBFXAnYtpfibXMTIm/DZzjv0E+UrGoLdE2ei/a22i228jnbghUfJLFKi8byCxvdONx5sIawC8So+yWX+5jTQ3sRyo00vSZB8ZB0h+u4mGQUYnNrGtpYlDYRAwNEZ1gBNipPMTwNnEEDXqrvtdveHLd4/588iKcYy4LIczkjmywmmlmlsRNtHmpIHBjJ8n+yDW228CzdsErZQ5BbdN9UxTu38vmYoJh8cbv/o92dVraHLOPsBNl4en56VxO+eXKraSSv3U1FyTmDuNQ0hiGo6k0VEMHwMuBKwYz72/mHPWPx5V56Ug3ZcFLYl15CnDxXwQ1iaK7NxNMtWjALWcimhGYpElO0fdQ6dB4AcAlgqcFV+MiqDULDi7jJHor1BHfWHEyqaeIgTz08xKwPNzTl05ClF+KH5i1ZQCWNzAas/h1wvw1d4iAuHm3FRKYvtbqWk5grYsSUcbQVpZsqgi1mSQSHdxXmnEApKFZKrj67xMh4glIwCBqYzlznjub0Jqh3PEvzWmmvmBFLqAKSiWjA0lGrNHwMJ/nlfgpNeoi09rYi83qkOxRZ9BiyCz7NiQFgIAI+p8gfbvQRSTcgiA9o7sx5FSIs9QwiAhqM3lLjVMQqnxpFFDmjXipcGmQ7Z4MNZXLuC77gQ9qfRKepGgCFjvXiA3wUeM3SNjIN2D/7/G8XY3XfE9EwVQKOz1IQQTG7+jdRNrvoENUhEBiyjNckqt7JRPbKBxFIxvpc32PfYRCRyEhGjHgr9bXqxOo3IcsalbrcZxpZMaxwhL39XFhAQExhFa3mnnNNiqoBUKrVQOVcRB6f4xnOz9PFnhLlXkEEXm9HXUMlaQmF+eYbTB1GudWf8vY3vQn5Z7MrGY/k02KyLuOAaDu5AoAMPIIMECOdE6vxqgZRdXdWDu7rjK0F226c0EYvPPHoD5To9s+YFK9F2JWaOn4wzJ9wbgMUN3Cc+6CR0txqgCZm+9nInC4dAFzpeizsUTjFPWNa3AabtBla6KVHWTPXsnAnrq7hd2sZnCznc2YDSSyaYog3C4gA29gDTkq1xh4RG90XVxnxqGJPYJgYTaLrtHiUA3KF7G4iniRwMo040yhrQzeYRGdTomyHZUazmJbONMPAn2Mu1lMt3fpXYJ3QI8zBhn1pyfl2FVHsMOGr3KcBQ7cc0al3vDUS1qUBHJQFIeJy6ewdwlo2hKfVpzE/G2ISyqozz0ZMER9P7slP0X9LkhpTd3FjoLhAJ44kiKvYttVMG7+5znAvDk6vdm4xMG7WJ95oYdQMYLyWCxtizZXB31ac/m+9iSDD47ys2AbecKFWlboAaVdhtsIkKaYE3Lp2mKQPb727UP65eCMkwIrDnDmrFHwFw3b8MWJohdMtSiOMIubHKk9Moa3cXKq3y8GZpYFxCw11wEI5epFNICi335eo1K064WgV9YG9uLA4QFEEbHX1xOmSyhwGdrQXbILUmZ0OQI1GEtrZhpZM3lcyrqFw4mK/BVe1+gmzfD/5JSSSrwEPYGPyubSN60WUY84WzL0ffeyTBGL0wRokUMBKpqdOiFrVyI92KC9+ZwuJAPHIj8bgC+uEUUPDr8M7hrgoLoeucnWI+6xnwsaIHf5QDIeNG4M75+NUsVXsxXALG1hm0YTv/pi/cGdcM6axOIi0c4hLrZLhk+N0jXNHQWfQbsJ3tztM8/C5WrgWNofanudLZa/7d1QdfdU87squTc9WFZ8Y+U7AzoMmW2ZjwPwpwXVhB14kffA1UeEhPDzgNOI4CR0WYCa5xCuZoZDtnCTBz7tVMqyxXwuMv/61Jn9OCztgTFB1yYroYjQ69rhZni2Dx4aJeVnrbuBt7947MnZDao+Q8F+9NNj5+YVdl4nOeztJbt8f68T4WPI4/FQr2V6NO4/VyVrPzMBsd1BplRC+mNsBe8gRRPIv3KiAuBjCCf/9MB7Q7/8NlC8t7MCTBCodxcORJCILu5IVxx6Mm/xi3H75aDlLxWAJteFDjN4GTssnKeEWrD7aJeLgBr6FRIF4XmxB+btS9ah8psvxiL7xvNohLD26Pel0N8t+UTgKAnzmo3NCmyqkTV6Ev6VRXaGtsMp8o8x25InGeY6CUYiyCzJq12ZxyN3t5kMY+y1dQ7PBqXrcBmssoVOdk4rJVUpGm6k+XXbIVBN/FYge4ZJe8sSphzroytozrgb7yE7QdpmA8R7Dx0gAcSC6y0T3V2N1vIyig7yT+CPT2eMWvVaeQ1/C83lOWubaAy/XFpDTr427CPGtCtkKCeJbWTYwLYHkZTkXrxBaWL/E9BjMQTuPFQrqhhhRtyiAuZN3rYEnUpfamP0sQBU2hgBJrv5EmNkBvoRNsfQ30ee3hdW8fsL1NbFPWZTcgvApzxP33Ixo2B8oYm4/WOtgTp4M8KEKmlk+jKFylmLPJ4igiF/+kpLNn74qMMdpWkWnZil9Q+yhI6ZlEm3zkD6WOxCjzo0y9pKSgv4Q5PXjc+sfdWi7ICfDxEm3OKU2BGEgA9ohsm6++8AWB5d1W08lM/zuyAX8vpOq+2AyneAHnE6rkdZ1IWGaETqdOyTXJW7XnqqhWP0YAvL1AM/MGjQyq5bVrlCvNMUVZELVmIX3FdIxZWtRPvrZWsUlQ8wbGHzAi/G9itIRNC8ll+dABXGoEzMbvUnjNvafwex0dRKqtft0C3Nl6IpSLrCEkvxgG/ednjd1E2dni4nyEL6Y3UgyTR+4PAkOLqvXgrZd1P9LTEVvynbmskqpBRsZ0024WOAwNLXJaN1ZFrh3J5wktWtg53UQvWi8ZIBmIP8cy3npi2onufd+re7rHYldl7faDnXoycqJ7lA7rE5IV5olt6KxsEe+lDIse4iDGuOgdK/9aK//zHlW4bjS7BEpa8nSIxE2cikxPo8cUkg7y5X4BoL3VgSVET/c9xGC1lPgepmLh1L9JnphneTgkKatnHCQlKMySF6Hd1YGarWZ6reUKs94tI0hUlftZmrWASnPPQA3urm9dqbLYmU/PVk9Zlkucis5mXjnCzIFyHhIf6VZ3XVtRGgl8hhY1c4Z7tiswQlehM40cxVAHRF/PTbAXo3HQcPFwfQs1zh47nSWTi0BqcdjcyjBdUEGxKYxL3AcF6UT70pZsjNdOrWweZVzQm8ZKBbifAW9iGWCxKM3ueHiJWffPhcPDkFU6rqeMEHVZ7xMfmzN7gkFWBZhEaXGrcAbVhdxUIQMu3ptiDALZrliAlprpqf46SC55I74DjqjH+SciYUwkfSlB0XelnMbCC9AzEstffPuRgPlkh6VVfFaAv/1/QFp3Fqf8FyQqikInyENWIk7m5U90XpT41KFMbcqbg70NDrJ32Zm9GRxD2GSylQlLiaUH/kC2kjr6OJXacBHqCqYWFtvrQodmVUMYDbSkUg88Ri9Y+SueRIKzINhxnSlJvDA7rfzVxCi/TerWaLMtE37h12PsxBpzM1JLwhMcLLstXzLHHap/DThNdO7B7m2JODVgMz/oRlIT3JnbDGW1D2a1l+Iuwcbe7VePVEb7yaBz0y2SstiN9Erjxx9ywIC7FLWTIZ42LY2Rgq8thu0l3yPXuGG0aRbQdHpuEUZNaWOcvUdIa9OBeBWlQwodhMYRgVbHrgNQ5GkU8uvtt9O8qncCK5shP0KWbIjZAvCKMDaMpmBl3da2QZGzVY4mbpkISYJrJJZx3Ea9PZ65nxoZ/4FUgJpduQWZa0F4psOa3dJIojdyhfZjygRAnJqUQM3bAS2dvx3AX+FVVgHPepkQfJhpSiSc267eTw5bCAcdLgD923BlgPv5Je9xyDvbAoT9uwH3szKcqABh8HMz9B58JkF1nGSy/UKUBpsIsdmsvmr0kYNa29sMTyOPUEn5Eu3d0S1NjXQIVMrdwh4gGAN3s0EoQbBbZ8ehOucNJr2aKdoYRZAFlZy5OI2dfA+9+yfnCrViHpQ/n00NzJin/mbo82KQlitBc4GXNT0nAUNkk4umutzJnMBoYhIXnU+nTd/1qnZdqV5HxoExkKUEVpUXr1BMLBuEym1OrHa/9acI/1lSuQ7JjHSYBMdf3nHSdQJo4J65ukhClpOZL5EoJVXwsbQ9PpiMfH6tCa6hAaalUXZBmAdcD3QMDGefO92EzQldiVX4/J7x/sXurYJTynH2GTfgPYbjqcoGu7ecXuPpfu/jebBSAIpKNhR9b7kNT/+H1K8lrYHl3kvfiXxVTwS+HFHGIIva6y9FiwnpNXrYs+QXhA4jYYOP0sXuUC0olRnXC2bCxDv5/6fWqODO4XMypsiT138BpPYYB7Zc5kGFgLjRKqISvRaWWCl0BahhsjThpgSPYgN2EDYZbas0MGSz3kZswgLL+47I7pSAxuPnv6U276tcOkANUBvwaxSZLRp6e7gdrCGj+N9FSbTVy/hg8nrRsZ8F4ZHPUmOJ9hdSnfezUYBL2zKXWbX3j5OHhbglbfYNNqRiIVPkF+jLhFj+zgAzzJNaoy1dYVHCPyaYZJTHMQ1O6UzAc9uVnI4F19ViJ7cMllztp7Ip+6xc6pxq2CmWcSTnqe4jFX9xlZ/B0JFCpIlZrZafRFg1OKq3amV2ISRDEhD2eumtiCaz5nAhQ8w7j3ScRC1S6OaX2FJG+oCLeC1TOE/kc4NBjmxwmCP1EU82FUpwOOkGSkkwBNBKdX5QJB/gJ0dh3QVEyzY6XLtB4O1D53jqzOu2p90Dd9HTDS5vZYAwC9BU7IdCPUnyhTXWJLXuLkltptrrRZ8MYAKwk7+A+ji6VKG+w5capA1Ra46vmPoBXhUFLyFCsTdv9c4/mJYFG0EYALnjCEjPZ+s8sMDTgLZvPrzBNWyng+zICmj4SfrQL+Q+QEBPVxkIh1ctHzpICHhA/2XK8dq0ncWqIHY3LRvNNpIv3ifrMc91Nq4bx4LcYXzdzXEIjU2wbZ8QVzEfWy51cEV/f9sZrw8XgYRIWZKM9ErfI4VoDzJOGDe5AFDZgwKGKnVbWQVf7YQ33nd5C31oy7OkO+8nRkSqIqCc3Szo8nTv4HNgrwgsgfb7tOI820iYCLHd3tdG2i5pqOdTaOvlCfWjM/RnHmkSnyctk5KYWOQbv7TA8pFIjzC/qXfMZ49oc5eruCbZN7qqHc/5hHRybQnJy0aJqRYiRTsNcX+ZhDiOk5wfCh1vEskIeAfGy7i/liLE9SeX0vcq+VdhNK0DxikZRGY7yn2MpQvR7ev1GUGjWC4xbtoUOQiTnAGl3N0glOiY5xp8fiVZCVXnSyXW6rP9uVGX7zwTy9Hh4Pbxaf+hAvNzzriA44NS0boyZR+HyQnn4VGd9brIgXM8JkaqRQegumvBFhDjbGgTKVv09MM//scSbutS3dzSJJTzHJLJFQXBDZZidWBgqeYWLPXrq3w3sVkczQI2AqXCpYkDPGggriOzsIHeowi0bybhQLhtKGbSmjwDwfDF5QtYrdSpvbUpNcBtoacNw2HfsZ4BfhNse+Q8w8GvsgWClW2bIB4z1iwbMm7GI0LyjAB7vDfvehadQS1orMWJ828afyKBei0UOHe9mVu9zr8ZmZ46T/S+Nz8VkZjk7eBmfI0Hwk6Dk1QegvA6kXaAOsh7aguFOl+KdrVioil9r2owu57S1lFu1AXF1Jzxxiw8xD/yw88II4hm0U3JjIrAtl5KtFHVqTsE1fEbOyE/4x2hjnZiMTua0Z6xBfgjA/I0AN2tKfv+kuFx5pZ4ayq8XUO+3CTzWcGKy4Sau199wWijVFOl44rpRtiMahwfv6quGRqT+BM8WW9SoXayXGyAaabYSFds0HViodQETiWaoKlKSAEDFxmRovlpj4hHh+Cq2MmgjFT+Q29vABCrOOebsdQNtAXrfXzI9PRuMOnTOafDm7yOu0wftYWB8+P36qqWGLb67h/MCujJMyLlg6nfTEh3LitZUb0doZjTGWQ1ZPTCb8EDn0/JDKxtZeNo6mB54DyCHdSwQg/D5HTS6JNp18yZx1VuTNQgIXdiQoODAkmZ5ZZuCKOQwKi+8l/8CsEz+qL5KtWnMYUoJ4gxLA5EAef6L+N8ittRcs+RLEKF9cb6b+okHhH1CbWTBh8pQC4vtG3HzvDDVbeOEnprOlX1s/BtgplABtS/dke5iKtqK5w/t9YpifK2WR2+U0x0DpWj2trS0Ciw3U4w3kCOVZHzqUM16km+41R8jF/D0fVsoacp4cR/Hhvju9yg7TbX9iw/lU1vmMx3i4vZ6jS8EOeBJUsO/twj+y0iaCzhTiHSKZDSygD7HpRXKoe1SgWBPlinxuz/0WDnyrZBz2X/7/yulQtsFdnZ4rcCSqJ4v4fwa2FyOUL6XSgQnqTlfuzQENus6wQFytl20G1vZs2ntG66jvtct3Cet4ZuESxtI04wRWpAcfg9/mtcxLeKPVoQzsWtPdfhaLXgWtWKnQhG5wJzqhTLCE3+NMnMAL5f5vZu+G25vyGSKWlpK96zsJJo4cOJeAqfCVmu1mhO+rpV/N4yEMAHuz3s6sSFMzY+3HPQhQN0URcAWva81/e5vxoxz3H8TVO1+nSj1hUee81xnxUwvvF3n8rg5uft0iIay7e+hZDNXGQ8JwjOj8QP4h5uhxWoGiv45KxaRTK4NQ/WtR1frMqQs0eAesg3e2e/+xDhddQFsrNf2TNnsgZ632gG0txmm9yEHJ/gCIZOmhq4W54cIbPljSuIhx9ZhoUy5X9tc09y21AIRyMEVTrv8ts64GrP+jQ/6sn9DJB2i+citAnEvS5v3Kwfk5F0eJVjtf6waYkCzBmbULQ3cHKB3bOaTYQ5ukIsYQ+RyIlx9cYsP5+A1DE4e0i6JoeYy2zC2tHHEdMGS9/mrUFggntMc60OfeN/x6Cww1aQPrhZ5slmqjD7/xMaxGd5ThmpiQpNKX+d7RTlZ/vgKwp1q3sUuShJwabrj4c/mPXHJ4Mxpzla9bFqiDWeot7Dne6ocZ9pbrcuQ0ieUKO20jv18+4m3x0+mfsv6NxbPuoykeS1Xn4ju0MGxRau66jmPdCCi04WLrhKDKVlC5u2tNaYDEDAuBx6bjLDVcZS7S+PHT8hef9ZgwqeISbNA0VEl9rN7CCd7BPddkuUGtfoowpa6G8C9OKAKKxufx/inYvlQt2F8OZcxqMpRjo5eTQG1xVGAefCpTz/JMHPfUWY8ycg+g5byVfAxsYthpl3iur8BNyQhiX3bk+4IJumZ/POnAZ3OW9bL1Gzsr9l+iUgKKMGcY3TWWcTAqZ9Qd+rVCQdkTYQfDutKotQNXyh8heSUx0gmQTpeCzr2ZJUOnVWEuOBV/b04BoVwf1Q6k/PaBAtDXfQkUOtEc25p5vWz/m8s8p0C9tvAZ4N6aI9BIAgtinbWcvBkjnp4nA09xg5JYhMFRhgFBe4AC49sv6q1Kg1lHuGnnIe+kQeClKfTY39pfLjsVUCZU9gAjvksbG6bZZvVV9VAneZyX5hyZ3nZpDSUx7P2tqCbXgL7Mrox9Yqwfz2CSNTTX6HsISLRTZMz2BPX6gsIWCojkJp2OaXCGV7+W3sbCx3koR0GVIMm2LbmwxNyrxdm/6AujMcEOaDtky/phC4GNQbLsG2N1py0Gm8V6fL7fL2gsi7tWf/4aTpDKHN7Dw4Fsf6IoODzOm/7sNMWSK43IuItLkVU0AMcWI6P+7RRZTMp8qiQ+FNy6jg9yvXUY5sWLyzKPP4ZrAVh+OU0AWBvhec0t/I85FRu7TJIxsraY+rRL9JwvZtb81Oi+nUuI1spcMYgr8ZRkQ3mrEh8JpmmekZyFQngZKkYVv2XUUqwoBTgkUWudwZ17F4CUflVOYxE1LoRGFPsHcx1wl6D61IVnpExOtpqXEIQ/ldpiOdf1GX99fFGwxMTZSLsBj8j1c4KubYSk6jfcfPY8UWpJv1IW+t/SrNB2CuTkcbJ9yrnLxSXL3Q4rJYD1XShtRkAkej0EJe5bxWCKjuYEnZBKZ/m80TSOoh04cBoT4tvVA7gL+MGo7EuSoSh8Rken9n88QpEhdqSfCgLG4zQpeRT9tgNI3rgDrhGUFuIBMZH5AfQTyE1p1/97siE8VUlT74QqvHBLlsMqMoYrNcihgcmfwfYfqx+5fSPNsFm0zQRhqiWD6eErkvUi85HjQoUNs2gWRAYzkQtuh32qH05KtLTupt2Ur/S4cnkw7+CnjtkMjupr2cM3vIV2y+/uPpLXh5Z3JgU8bz/8ImgzUpzN+DtvrOjmsk3ia57n7ys8NXd7LV73fcRPvJihb7/22hkehnZs+CdfyDRI9r5iFHlZ8mMSHAWybET4/9R5pwnl9+c0LBGuo60VS+GLC8ZaK/HfpLCS9ZiUxdC/gWZ4gbHgRp5PjNzQ2LzZcsmmjn0Et8wj6epqIXPXONarU7nnFOBQnN080mSBJdWoBVJx56COnn1uDBzHM/1OGiwvzaLK2hw3MIuqmuuCPQBRNb+LyVsUUNaeNxWUZhQ8r0zb+ReSGpddOyJ1CGcrYoLOkag4tMg+YQlAo3Uhed2W9zUCekfw3OEwjTXFv+yrMBdM1g7oPodrEZpVhLpbGnh7ixT2era/5Dgd+mQbRb4dStUHMRYu1jBAN048waEGRdnFG97C/oA9eV5W4ZSkpcMKQRKw/3pdO2K29TO8DTyAZ5Y4qoyjaVd/r2HDwmy1LaqODbx40QmD4mkRMIm1NpCkwFPQTaB4CkjElGPcv6D2V1I5kzOu/+NMuQl+lgsCw6TipPiidlOE6czS5TgCahX2lZEggjDx9xQzWz9FQ9bhK5MG0HH/bYT0rdZk77FTxmb7ywHGYZjS3oYrbo2sLp3B4Ng1n1neSCrDOK43VjG4yaQZA+NCbuWGYAns9Q6XsKsNVXKt76y9N1cTN1qQYvYnxrkQIim+cp3ud6OxYVbpWUNrcBFScNrAh/WYPrlH+aL8K2hw1/NCIqrFK2F7G6QPJOnpNJdOQJUpBbeXjAHh2fjod/ABXVejGrerq4LtjjjI+8o4B/oqf8m2px2yyiFXK0/JBVzpqUOiTUGr3tvyZFBJnoyMsLH2pA4Q7qqFnzcCDQG4IcXmz9dZ0Ug739+53sR3ny1WzfAp/Lt6uqAeB7jY0f1otVsatPsaqfujfgrF7L0WqazoXjTwY50QSEMY5LYR2fUsWnzyKWZOl5Kzm5+02XgAHNJp/YlmAgISP+Ry/+9NdP/sWDqXqLJYmcS5CoUndb++3Og67ScWoct7mKmtrtA2lhCeZTgZ1GLmZ71nh14PkYZGWiwQxXgTVqEHyEim7c12CLn6Lk2fhKj1hpeUiyuOyGTS40EXs+ys3mr9wy9KhJCrrXuEN/cc/jwfonUoqZtedehHrrNR+T8BwUEF+XwshN/V7uBl1ggbnYBNQqfhoYilPNB0pNm/dYfl3ylYbg48ejUBFKOg/0f1br6v1AvSDlrEuhToQ5IpzfV9a5s9dumfMaY41r8CcKDV2DoPDqVtLQ9ycO7t6e/xLBJvZEx3UnaOTlHJWcFpWldUdH/uh3zc2+v6RztrZ/S4FpxaK7SXIf8u0yXdrP33U8fOcp7nk4cro+qo4hJn9iWD2u71mgzWoLZH555YvVvW18YuRivWlUh+QV8XbA4Aoj/QxDeTHLIb9KPiJvNxuOgPtab+Rn+TGaQxAtuCuZ7d4B3XZcqxy0uqGsFK6Hg6iKUbeyTUEHgK8a2KmRqKnKN8Oc3sjdwicgrjdW5h0Tz8Qm6IQI82BzPpMOYjMtZfbrWUFxppmIUMpoz2iUOKl5FG26na/4PizQ91X7dCeNhKWd+l7Ohu9cgWEdBHoYTlsrP8BOPsd9nflCnkkZLquARxg5Z/cEEgGX9UrIerLI+n5phREMqisCsRLP5Y3HQcJqTbuDCSOP410DeLSasOsI8TwyIyrPQ3Co6Ncn7ntXI190vJ/eU8bCgDYdwj617S0AZSSREvq6XeDKLO8lwT5UsEj/bzaTSzBxUIdf4ucDIIse/ixzUuXqdhOvN4tvT41Z59dWHyt+bXR0xgEhR7RfyKMyuvY6ME2sZNBpzuLkZEMOV9Wc4Js2hVb895K8V7opcOhL4olEijIKyfOxNwyidIhkwBjnSK4+b6doVQGX0AiSW+fsyMbQg14jTJiGIS7NVk+HhwWG3BGhIzR36j/Al2DoDdCawlyjMj42pXx/zzLponYVtBsGg4LuVlAqP+4aY89vYzHVG7GFGNIzU1H27QW02q67RQ8pygUTVrKPcjXf7EwDCdXGv6woD0Qbv1zVY1dFdyPmQ32I04fc4x7CySUUP0/BV3UCQbjbNAAe+bpdYSaXczwjOOYj9s9VxVoTujFSEpA7ug7CVRvBXbKvgg444cJugCGMBu3/8QYEXTmv0fz1XXfHNAkRiYdNVf4kHlUDkHDWP7Ginul9LQ9A+CLTlUKNIZj2I3vkkZbMARLeRirXHFp5mrwTmFOPaZh3+qj0d0dWetp9Uthu77FFLKLNICUjTXWyEG0rWc+wXFBwcFhwcn+eg/d3FJE7D6f244dAX22W4sn0SR+0j8jzh7/c3II4+ZPTofHdwhx8giTWVeDTYVH0jX1N479ZOlrXkAbmfdG57vPxnaTZ6gKPQ7tiv59hLixX6MIZcceDI/Np0jTfvEm9eBJBPC9VD3dpuoT1ezuUGnacgi6AmQeRRNrLlrgU1WJQdJ/l34MXs9kHv1jK0Pq0opL0Xxj38WzhTn1Am8OzSyuHHnTIjrR1GG1R1XbKMaRREkefHMXc1Bx206tYVbDmCqJOZv8kDU2fp75hO0/X4KPKupfbkpi+tU8aCAioLaYf4Zv57fjVQze1ImxjfApcfzRQSGpmedvzDDNfY/7ghl8BLUPoYpFxVM27dMbBzSlSoZ9Z0157p6RAkciD5atIN7qteIRObpl+qfHZqBTvcfUml46Go63A8DoLVQiQY8F80sgeF/dYmJkcfFy37yO/KCA4FG51Zu8c4J7DI0F2q+SxAJ2Ke7vUdCIaxE2Kp1f6EmWs0oJ8NNyNzbhuejzDOiSJwVOq0Wu/mcg34s9xsTGxxsHsxYcMJaX+QryqF+s+hH/4pv017JpxwhrgyTASpqINgFCjWsdLcaZHp7oFmJPkEXg2JrgkQBZZpFXiApmiw4YUQUOTpGvVs3/yWXvcqENE3n221LDqEA0UJFqK//RsxUnDyECEmBXJtD7CqSGS4svpH7eFlylutIAAw1qBVDEhRnL/F+ARosBW+TD+0JyU+dw3oErfJuwcmdQyjCh9zkUq2C59e3CBSJ9qjTPQ/0e664STV4ZbpeWL6qscHChSUtcTVEPTivmZ1CLVHRDKr+8z6+5wwJOg8PPgKHLIRFuDjbAz/hGuKV6sITsX+5CFkUrhVa6YRD0q6wYOeilJWE89bO6xOrWIeNjsJQG2rRobcEag//sHTesalfbQHtT5DiasC6ZQKPoKpkNe8GiSm60zMHLk66ILbqT+BPHbpKqpQGixF0KUiTF+RjDMaXMFigHAgj3tVSKaqabDyRF/ItAW0qH+Y2QSq7aPv4n73DqxZGPxYay7ZYZgLMffhqbqtoz8YLGHbKwy+q7RykE91hlpRAmB6NIMu/Lsf4hOQj2JywKojFnm1JpmW4xQTx6ZAbvgzq6iopsrheIHBkSknne932+J2T6iDSg8a+2ZCsipxR6CvNxgha9BGWv0HtXCOKenFR460Ev3B5fYJ43EWzUQ+Oo0dKhgqNGvQd/Oy6/TgQRaQhGz+LzsperAnB1ZIto3HDYfCRrl9AvfXDU3ltsjBqk+JiWkKm63Lc+VXOGlYADxUpdeJYU20yH4V9hB7DhhukPs9hnFsfjfiok+iEvd1Qu5hR5nSJMbaGbSrj3tmWlAInEcpTLBs2HR7IGPDkTE7h3sDle9FJ6k2MLTWjc0ESvwBT0X3cKLaWiyHrdHoqo+7Z5ccg5UCJbugS0wbJ0lNlj0Y637eB7VTPRtCPtBYwjE1GQ5dJX6BIIvNrPtOninGiFOy5m2+f0iGolN5ZMnxakiPDle7WSES9vkg26tO3M+PeopCJ+ybBD9/T6vzlma+KEhGrxMD04BPRl7f8p8jMT6AfWUQy5TL1RyDpU/M3fs/n8ITdWIQ5OvPIKULfPrXHDGHEyJtdhmGTOp7RHMjLsFh1mBjnSMzCAz+lvJRpoCYJaO6q1Yn+EnM7vVM0187q9EWxuJodI2d9oavzB/ePI1ObyKiLmT0UtdAqZ89XAI49WWrwRupOKkL7xrsiw+p+R+aOH5oUvOImR49F+t5CNjlGvxMVDA/KEgNmfyFuLAeTnfMW7tvFaazuXDYwsIK8jB2NOgFZYKrqVpO/SiYtt95Ifp1NQgK+fjPawuAHvRkuOEzjp1jBYsT/oPKiu5cdJ+l7WhHVpWlYNTFhIeEK/Bmv9WPkkpduG78X+FdywP5UuKNeO2k1zsotm9WaJ8JIbbM40Gpul1afv/F6rPkddailsaOJabJTz1P8SQScf94ZKpDWYY//p8qrwgt3TpoOyhtY8jHaj9/dKapDvKFM4+rT4001e1ZhBx2xvMsPXkkD2QEC0WvmXETddjkzTyWZ+sKkh5Sq1zJK0NFdCo3G2gU5xoV8IK9BwIlzmgujtwDQaG3HUcd6o1eWERv9LW6Wm1nB+699USPAh4MdViFALS13rqYrh+gggNuLZ4D6+Nuh010CZOfBCXfRnvQc9hn3Dy4IFz+vlVQ5NfxghQvJgXBdUfbLQ+lk8d9yrLE23EeWlhQRWYGQqhMBLId3OenI/sNTJF+YNJHjIYuWtNZvZxcsb+WK+NFe03SHVxHETC4A72aZFigRM6pok1FWn/UFBdumqhw8q9LYBfaev9h8+YooTF/Rfx3coKh0OfecGKfLG25g8a+TsEejY5Mp/iyaJZj9TojIrC78o2lBLEWYGHGhN8cpDQek/5a920FKu3RyzMFd65moyLuQZVZLW1qJc6hUSfYzbhLg+//fnF8ej32mMYdYj897FQIZp5OoCmQHq4wYujCB8QVPDSJ933gtiSNHWcE4Cd3DcsnfqNNWsOG/jnvdv8B+RQWmcXMmgPnBf+iyd7OHwZkxzRADZOvuohQpiTJm8CQxJJfw8GrVfCJ2YnQUQLjsW+g3TI3beQ21pEHuqOWTXkWL9Mqljhh5JOVmTdHs65I8Paalv0cTua66gtNZrJH755SwXGW9ye/0jWHIBDJM8f6AeLNxFP29N/cgERMOpTQ8mGsWTsdeWE8eZPOgjI+XdXCM+zb3n934NQao3Y3AbkwGpLdqXVvI4MyGUXQBpaM7Fcvz6Q4bk6Fpx+PDp0uDp1cK+64O0FaRMu3hOWh/Hp8WSXJeuURW7mXyP7WpQX+vQKPhxAnYkOWRxdvM9QgcxAkUyLOoFio384ZpJ0GInzjE+ToSZNGmVNq/7VczVOZ3gPHpxtETkai5zhuQhvZZhxsWXwLs12QpkkbDGavZ51HOP2hQlic6KCxLH6dLq+iVFlCwMivTVuK3k3OAByYrtVDFT/yOsbtbjh+hNPryfYgnH5BZ+7FF5q/ZBj7UqfMiFcpTqZCdApy5wQTqYfX1a/G/4vfi37d+e3LIUnfb2aFwxfSaA4OLlQmuj3SnYk9OXblj+qu3Q8xPoS6xQXtEZ4UoZT4hNZYTMSUvKgtWrf1mHBIkZo4tbjzfhBdQYfrq8diHQf1MddREWndI0b4InGy1Nmj2CqNlC92iXRAVjsAlwnL9KiaFzcsZ3XTwCq9vLMTM+HwSV4e86GxGZA4uf8zKzTrvDv2xFXN+TABXZZJxvoWdh3cx8B0DtMC81fvXFupTg/WIjRjKrmxWuyfCy+zIqLnAS8wzbJuZMbI7nuir4f3clQg+BDlPg3fJ3yU6v0411BkVJ88fJbuOhZe0J8+ZkzyMPaUHV/XXPfuXR4BJgqCnU6aHp1vJS7kplLoCzeeK9NZavc4kc5Vk8942hs2xhwsDTg1Yv/fvobfx5JXduPi2MuoYkVgrAaO5OsXVWiQNv7KNFwZh31UWygxwA4S0Z33zFjKw99Z9ihARg/AliNqE/+yQ7SsO6I9twvKlQqBepPrtLixyLTdGwP/aqbImXzq4UYZx53uTUOXm+foWEaspFpXfhvcX9slJ6ydC+pHxvJnLFitBZ00X22LprNDd/slOLcnhBzDSmQlIii7epUdCCIw0c8jNm8GHA/gb6Vmzd9d175LvdkomeDYxwtO2QBD7GSU3PMK6OFbttKiWb8FEsH/yAL3L26hV3Y7BxB5liqO23QbxfAkM5b9M7w4Ydyzi+DT08A7+Gi5QhmakQVzcqsU+U9MyyNlGCMgAVMbwiq5+Bdk/YY4w5GigenE1DYgjPYcHr31FbSYOrPPumYIJQlKEfspNHRIaO9HQhypUo/yA4DzPk5O5725JuX4GENUbCqjXdUXJCTav/xwThT3Va0fjvnJn/FZpgAKmgYyLyWXtAp68pSMSP0OKxmqh3Hay9NwcxTRGaQqOeOkAPIBUkVxUFJuc9MEYEntYJi+sSVbEa6d/gNg0W0yF+NnZ7QPyVMSBuaKaglk/OpcLAATeziOQwjhizRB1AZk1iApenyvjP+3MnuwHWDSumPqlaa/5L8+DZtwSoGBeO/CdHNJAvGZXky5BADDVLnhyc+G9lqvgsjTUjyErJNMoxV0xBt1RxLhEo9hfPi0jC9SKbdJYIOz0KKwe/VBlVgCPHFpNNiIv2dKJu39Vo42VsP3Q6rLQXbZWvIPFDuSZarBfmN8at7PVCOrRU3XR4o8qw803/yPAAPbrv62MT/FimHfZqcZe/vWREHTuuYSzy6GLbszC8kO1mqj+A55N1z0gAo2SsDGIiNAf5pFPkuDwJJeqV1/gSA332NSQf4X2rs/fUILsRj5M67l1+OKm08t2batREhheYVPrLTLQV2BsAVyF1SywRUS/9ZNCFASsfKdKXpCMGVce1RCEIYqqLDgxH7SDAdrYFuIYQxPRvgGFl1+qtVgr29RaCd6SOznjIveBojs7jhgReA5JDRDoSlfg2oMvFN+vJiO1q2v2SaI5Z73jsmuoziZhj89gw/nPRgTc+iCPIJlOfJZTVvklTSEEXfjsbnXdl/nBzUGMEp+7yK4W1ljiiiEgkAwU9jG/Y+FbIfT7sbyWWMVqipAyL6rRcZm+8Md1u29Pm4gBusq8dp3dQIeHPlPSPyisvIfu67jSEA6yewOYDoCu0fb+PygRfcFYNn41AYe8eC0NEmNgvkd//Jq4zFX+wsAyT/ruNfpToBMlURNQSfaNgwY1+fEZPDr+iiA6qyxVmdi9XIrVVAVCq3XbRtkTO9PvHNkNcfmzmhG8CndyYKbVgsgVWu11GzeO4+/ug/ZevLsJwyfDs4xXKOkLaVuP6VXy3jbwe9iNwkeOD5cDIK6RyKA4Ee6d84sbyQ94ReuAHvrJLLm6alChoxbrgmMaQShVTacfTFFmqSiI3rA6ttvJj+zNyjY90C0wJTnWKKtkvawHjbV/YdFSaV46bHFB34yJj+X3rDhSJO+aBKyLyPD+7imLjIdj0X44EiiHLmS1P6LS8rLdMPysQNNKbjjXm8iEcYHOVEeIbj8bvCUHAbFhMNfktsGpL5sf3xknWXR+2ZVYvHqo1KKqDDzXh4zMCuLZtqsnzgXTZzO+hzY5A+nsmPsT5iGWZsyetkfQKS9EuOJE8l1k3T+gehScv22O3Hi4HVbbiNrUMMJmFaplDpSwpDiAeIkPAHVIZ01CpqZIX8z0bv3Xiw7qCIjGHLgeZSs9J9BWy/b22IkPfUNwwTbNH9gl1z06bP9bJEJIaMWBHuMcAWw3o0f/zEkl3+VRcatxhBTrR54mp9Usr1h7CWeoJ6UjP78HaYZ4EnwQbfHD3s6LmEShqfN+M38c4RxCXpT5xzeh3w+8CWCVm9FdeTLPFmVYroT+3cXv8Lpq4DJxvFctbCQGhw8qpPXSDfUi3bqmyGJK+/YhJWVSqyzI5N7twBQTpGBjrndzynOKRuupzRuQUaC9jY//Zrth1FPMPwfwR+1x2TWcQPxjk4rvq8FmTFPTLpuyPuZqxLS6pe0im8ak3uN1niQj2HpQ0nDG/tLiw5OtFE8SyGUkPp/e05VYt5PppaKIuy+kQt1biWq9l6PG1K2ImCkfphJHX0lIrh1ezChJIUhKBrrUIbE7S2VxiOtBZE7TF13TuMlfTaSXefBS+GjZirtJbKyxHVnaGRBSZC5J3QT7go6Y7oW9DtYCrw+PLxAd4EU0WjAHcind49itJY/EtGx6+E1kgbAykGPJP4zRDSlG5d06hGzCDnvQ89DJiy+/tWUylamv/csectjk/OBQLAPTP6mX6hyKeo9rS7GSy+xJabB7rjx/jTrd1hed/0uZk9UzoV9GGh5V96DUlRL3JkiM6K5Q+Vm6PckpZsyZriefhYxc1Rbb9CN6FRDaCVthWVuyMfRlc6Pdxnl3RTs8cF9fZ+fu1H42KLVWfIm7RWl82akicuJKVjF3ehc3W/NaJILyJUwQwmNzFNjzU4CKZE/HCdvUuot925LVFjKx5/7yVcXKXb0YdndRod6f4VPyOwKGW+caOaKnMWzLHz4skkj4XFpA1xlw8LMviorYBOd1N2lmGp3/JONpN6kfqOj9N+J+LdxVo3CP6rjPFSp6b5Wu1qo1LGV+JbhELQV5BEiidfZp9ssjuMoI5A1WIKeKV4k/8SOJmAMKy9D16+TiaElRNRflhlpHR7AxMwiupy0MEwMxV3oxby5uCImkbs6a8kX20gpz4GADnUFpiF9LrwatlOQhnKJbZGoXNSoWVEMLpsWlEaq2j7aZPU8F7phTLCqkn+5o5GUDKLFLRkhgJLk5sOgQxrSGBnaBasUUBcx29Y1HKKpN7//b/8sYI2+LVM5X2dSsZE6SMAM1KCrDdbeH/DAdgsRsG61edZPZUMH0wELKECRG6IV/CM3cCnao+/Re1V7MxKFxCvOGsqZRseDvSrRdQ0cVJx4YQhqV5XVlLGYIVEBn3US0r2d+K6ekhI2EOnHh5HnjXHcDxX2VjquERggwY6+HzsfhQhbovuQj/PSj4ZaShbvyKUixdPnNt5L9uuUhBr0sFw7u2PYrj+9evxU1KVo9Svg+qWUTa7tmLiPR+FskJFPDJ0Sm5i1CX4p1ZstfROX6ATxNeOyG1rstFcToo3qPUYHYbnHTB6MTtsTXJOF9IP/ebzjYi08GFDp58mpL5Mtct+4LIG/27/fbp/spr3y0RveF3DT6bGuEYn0aFqYfX9t8UixWnBjsDSC9xWX4SHrTkR+5PsAgl8IXU0ErqKe4zEYuDVfuWOSAqDO2U2OYzlESEvr9WJka4Q7ziGoMX2brp/MVDxLu1aOZ2heksuTjRAXrwRR5Z+PYrib5Aae5gp7e5c5WccIAq5etGjSGe6ufKKbb1q2LG/lsBFk3ZOGZDn8ERVCzbkbY+BbuFMo7be1SwLh6P4e7o50sbXKrq+OvfoRX+AkOIOGv/U4NDGlPHtdCQYvDTm1H0wh1hU7suw2Pa5omagys/jx31K2OBBpu4VipsRbp5DeSXFrcLRoAP5TijXNW/Ldl8qhyWeffO1dv1iA6ll3F5ONxt0x9FD4D6e7Stw+08DYR5pte7lmdOYWmPWfsbjZfN4u0PXoNbAjMpgvVWc36/NqvczxVi6OJ8hOqVu1sKcWgVRHEtErqs4zOlT5SH03wkLqRP2VvY9M9SZWAqc8kv93pyyv0Xgs+L6AbnkRoJ6J4b4dzWKRVhxP+NTuRDtFbcyQeeo1qDLeUVlwmFBRnoKti3qqx/Yx78VxhINBFlRN1ftbJiEeDYSigUXqJiooW75JVboaUEu+iN5sYOL+laGHq3FqUp/OOMmiJAqj8gQlGRsiyYFXE6mmXODLw3v/6f0R0bZsq2Rb87T14htPVaXV+1yFKKs7DoES0HdfwSGhx3dWnNzvQUDSTu3ua9fTI3FYST1RbcxpAE0+KGfqS8Pqob8tSDphtpfHKWNdt6Gghh4YEGPxudrL1ip97rJye1A4bzMBbSkGdQD1YQwUXadhh7C2nUVPJO1xoc9RLlb5w0i1OO4mh3M219sNiCou2hoWA4H7/yDBSGlgMhYzwm6FAsZPAaWhqKHx7mIQxBcy8Xw0lEWR2Njs2DiN7b0D0XZpCjNC73QxExZhFupgErTIPAyKLn4oVnCCfXmNTF7Zjfby/vw8+5RQns43sMvo1+96UlHEeyoFEpl5YHQJl9TciiRhdvKlfWzKve+0Xzf1sOMdYWdVK0OjgH38B5yWvNN37VrjlVIjsrl4tWUZdIZGqQsvWMgQ37mWWSN6UfUp9yok59qNfI5TKpszBr9TMEA19BWY4xdP+U8kBp74Tvb5pfpV3tCrP1s0xBVV+H7u/sSR9PyjGAD5zBIYcuKD8RYmjH31OUE2WyaIad5GxuNcczucLVyuJLFirbmy1xBVSZTsfjaLUtxTbGySAG/BjNHj1HvYbTyq8pAlCrk/Rar4zI/qKvoQvQpTCd9XKs8qflWFeZrHE1VzCdPqdRjhqVkYSbVQIikAE3Putx6iTgzle01v91pJifHUkRvcnaF3enEyMl93GxAdrIWyjA2kfp4Oj+c/9j9vgY0jEPyBnaCWqfrzTP/PGJj8pJofdpn9+Zgh7CVSrFVm3MoiiZ5AupSixPBKvIp6985EUVUdJx+mkmx4LaD752IYRNtnM4TC/kQ/ZKOj1WPnfwIQ4sIkH3l5XUaahUau6YYRTj7kFL6KBcKGn7QDGkuG0J1EOAYNQdNkJaKqxuYnDofMTfa+ahwKYWq3Odt0k3+BI9bbbanimIEdQ0uMX0MBn4nt+sCyHrsKIqMXwylNP3pixsk2Vg9DMKOrbTfJp3RWOnWTVDox2vfAxL3f01wkQW5qBwFjm2kG0HvSLskPR5+iV/OsPlZ3mVpzfL04xfuNp3i3FzKRJmxSLCH7oNPa0yfeyzol4n4g7zS3/nxDfQileQ07hZX2+wVEs7ys70ON6zrf4AGUH8SDR5Z9Xkzc1uz20VlriNhXZrYCUD2C0l/xK7qb5lh/KshBzzAeAOelsOc/KtS8YBbjuE85J6Df+1VGrwoKGv8txEOMhTdAidayqUH3si9b198ppFv8RAaIZ/gXHRGt5pyxsTeLRjwS29CvzLiyESxhy7aGVqHyovQPfHwxZgDkGiXX0kc8h80yK51cr/xup0CqZHhDgU876hHTFN7t4gB7/BoGI2i6x1l0h4jnw5TDl0CyK2QY8ayAy/wjJAaUldlzSGacEE/szAzb7tLIDRiL0GGESLUodybR+7Jk+p04eHNUQOknQcULYiFuwmhPr3I0kNkJTp5przq0VN0y6h+gyMBCozp0F3RpUTDDothTIz2cn7qME6skRCU7L1MFqKplsM17wcVtKb0TGY8q65piXcdjzczpA6CpKKTK2sbSbIruKfNcg2elFZB9t7fsFDZuSbqRpoKmdcB4SCqa9UFVQ1WDlkOOiEExEF968C8bSmA4XUfX4x9+DPXgOrHWyxQ7CtJuKxPtDLGenM38RpYtLuZv0C5g8SGtof11ZyoCmBOy36OOuwJr6VDxtX4fBcQT8+ia1RWgkt3gk3BqvkW5kInObXtcjrOmsHmh1kXJl07sLlIJaR75Z0HYS5wtlsmkWWR1PWS8VvQSjxBtBKyZgycS2YxEFBZH8ovse+nyQU7FoYahiPNPelW30EDdmBNoOru8TCk4lUr/oIzPkVgtDTgNrweTBpgLnSMDdwF24o+W0hVRKvw1GT2M3WlQbFw/AqwH9efMgP5ap4MnuIho7hjLlByCqb5OGVpQMY/Lx4FDg1cPPkzZumT/6eEqDGsbyC8msYwl8ryyZr3q8/SSw38sER1KuiIakcdBBYszLccOfo6ljPa9c/c5xTTMRdt6hhnuJiXbToG1cf6ARGa4MBxkW6rERFfORKp/L5hX7j/ci5vNpYWhcqSATE2is4H8MqSgjffbfQXllHw2E1El19c0IHqqQznNPqMa5ouZiV6OnjvHJdBrugNIyd7xT+S2Z/IbMpWDnFPu7uSC5+J3474jbqFqOKC7o/8z4hu8xy8AuRgTjmTxWbd+yUSi8O1OZvwAAFzZZPss98JT4le2t1Hk3YOpijMJJejKOIVEL320kjjv6x3v1GmPVYlFpZqaHKNRw47WeO+EZvlCW7f44juPziXQr6N8u4C2piKLnV42KzbK6n3LY3thXLPZ/SChq2+n3JInyhjsYi267iyBL7VSgLUiJ+qscmn+W/7ZxxvIUOfBw6yE7tZWbcj0n9A1TC5TXIoA+tfVXaCt6KiJRZZKBv2j18tdZ7JpGoAMn2mln3aqfdsbuZlFpDkY6cwWtzpNTWAD9fVVF/D7VbJF7S2vnVYAt/GdubqgE6XiB4NxX76etba0HBrpMmVikSNZqW1pT2+4f2XA6M2z8AhmANR7VfPdQspctYCGnYZ4eJlm4oFTKQwMILElE9yV0l3HahRRse5DsxSaC4KSKEVc34Qc+0UgTS8F4tdqgOQxmXRF1NsEwijlY8DMt7NpVl66dJnirfojnETMmbp3uXfvAuKJ4tkDrsF9pC8KJ7wQDHtOtnShhaN2kWGAs4gav6V6zPgt6JqLtp/1aFeB57/+qCBozbxWlymREDDzaPTxpjlqnPPcys4TWMX4WbXU/6b4XOSj/9rAsayEEVh2agGzjTe0xiVx86DVgoqi95wGojOPX6JZtw3/ohbyBDEUkzjSpgD6r0rf1CYZrTaykcAT7lHirwIf54UKR38WR1H2uMynaA/6/0ZTf8DZdF3kF1kp7jEkMgUYnQmHQ1WAIyogVm35D4Xpl32LVzLAspwqB9MA1mXMJGTFAm1acWqEKH81Lik47pn3DRCy65wkbc+f9fkqM6kkNH4xYbeFt37ZqwQvROJYpA5ss6LETs1mUi6fsHg022HloKp2u1IkUdNF+HbD7yqaAXtQ/1ljoO4vATE/oA1WNBrg/ssZExQRUQxg0GXv87Cspd1JDs5O2ByV3FEgkTxlwvqLFuBRqxn29Zghs1BFl9S335QfJDi09+OeuaKHh+b+bG5DMoRLE1v168pgbSaxJjIhs95EWzoPb8W9MjCdn25pgqgIlu049LeU6zMEE5AUgy2x3wJsnLbrC3o0PhM1JlWvY04s34zzgR7W4weZsKZQrfiuIurWouSh45/5rE17fbnXTn38CWT5lqXs9hXqGBflXtkDJOwgK5IdxyDfds4rgNSf9W6QlzXm2BcfZlE+0n3a8iZY7lnT2b2Of9SHVOORZNArbGMNqg+Wo9iTtxeBBq7hTXpjQ0lalqitItaYGlw02zIeFFGglIcdkLJNPGimjiRzp/f5V78LqnKhqZPHOv8fIGXRGtLb2u1ligtWW3pquP779WQ5CrQBaV5nGW9c7E0jBe0tIT20bs09dZTo8rHuj6rCyIWGQTAJc1AALkzFFUjbkQ/x4EFwBZI+eOUERpK0uRYWEE0/shGQx2l6vkWmRpOIsF5vcWGrV1jhIFXKrVCyeDma0zOnfPsrKALn3kLDEHbtbnejB7sW7biwcXeiSf3hncM3/wB+9i/bxzSyuun1m29mJhztdO1hVL6U4llgP1qk6wD/2B0/ytILCqo/TAzdrwHuAwtAK9Xk/NO0mCgJ8fJJ+bA35zxyoOt5xYJDa6jCP40umhYjX9SaA/+j4IA5j9Xr/5DD1oTMni4hLfuERkyEvG4SFe9Vnu4oP/S/pHhKYDcblJOY1kxWwLk22Czxhtye0xrZwu5yyqfvxSKJpf2RJziWMuT9qSygIUuYkHFBTl65KVv2zN99w2T2sBA/1dG44/3Ls051Ex5J7wEqQBHu89MrTf4etlzR5aXuDRo4GsVXEV1LimUaD1yNYOqhSIJDpO0T3gf+Yl0kaFrhwz2hvS9VnOzQEbNCMaY1uzMrSDetGLwzDZl7F3oFdKH2H/VIZMcdcHYuMOPc3qjmXgu/1oqRcWFw9xgyyl9Bdm6rvCluw7GRjcOfYVntRmMQ9Dy8Q/2rbWdxfB8nJ26gkmPd8X6oK32V1QdR421OBoibfZ90VJAOspV1KeKZCdkwV0KOjY03xrsOk5jotRYuGPyTo+36JBaaG4Uf950t2K5CIwdI9oshMD4dyN3K4ToPIoAdMk0oYHhcyPGIDLVsHIRwsMp2boW9IxCvDPE3Ms9soKq3oaAsP0PUU4Tzu8M19mrxUzT5/Dm3IA71jPRoOQYKLOYRByg+3Rex+PqRGbI/XGbIb6Ubf6WBsbTnY/HhrUQo7ly2MFfI4wnU08d8TnW+NADwfCgoI2mW7WA2OGBit0S779AyzjuJXDZ4LZ4lhMJKW36fZ6mnfR4TOodN4wu8CVikYJwNuODpK6lNDEi7sehLG3T9QNQyaZ1Q3d789eOWQ2jRHoS6LCqbZPtdYpI6m1rvuJdjVtVubRMg9piq2qT346GKufXoesn7w8Il6Vu8xZD2luzo31G3W3Hapb4nb9wMs1BHfIBPTQ4LTQ33HVBkIP/g4V8uQzvnTvpNId7+nffg6PqEXoPqNAiqoRb4ozRhuqeg1wpyzr3YhzmuHm1Gzw6czhNnhhQFhA9UYsLtrJko2bPwfuZuOdavHyR+Meqo119EJ/Zycm657d80K8TeOprmeiz74UmPiUhlXXJcNyPyIGy0p1cR5x/8tJOCrWZxnwxwkFiC3QPiqxLiEfqpDacEwpACj0da+vtWyQZeK9CiwZNIqzQV3C5oOeVaisvunf/CFYxX8Id06WXAaoLScEBvI+Sqgo4E5PtKL+TIV/RCTp88J60eX/Rirckh0LuEQuQZwyDrWKs/Fom3UpBRcF9/0TLUHaT+zHL8xAPH0eSMdv+pTeSHEpNRAoK/vuBW63DdgLX6h27e+4iIjWSCxgzVC9hZZrzkHtw99gJmF/+4BF3bZ7SjtQyy8cJa9y6Jz7JqMrHX7KSTPjmWWAbFwYsnB+tSgWv+S6UqC4IJFhlO2W9D1UtzPDPAR43nRfcS04dNDsR3P2DXcos14EkYHKvLipTlmGyK6PUr6PYqj+xg3+HuqP0ewBE89CkSZGx78s7bIcK9ZWX9kTPqGOCa7davAFpS4+jlV5lkU+aiF9OL3W7Lrgk1rqxLpLrwVzF4rs8m7sR7v14WVJUENFhHFs1zs3lgE4aGkhSiAYc6XP0q7hNKOdwDQgjuHwPt/CD2Y+ga46nZJDi7HFWPhmGVNVaeDsFXcgg/jDHeedIuJ7QmG4eSn3ZKlGBcxFdLfR2u6PtwpcELfs1WtLpp8hNynKKXd61yHjgt/BjynSK2FQXG+nWWX+fVD/J8RnOC/Y1ylMSV7YL5fqX5H7FUZASh7/4e4cwpqw9z9GV1xuxZIczTsCtvxJvl62IWcNfuj9wRbWyddk3FmlNkMxdybgA42pXSaRmFCnjGEeEeyf1zUcsx3dmGrHfv4DwQPpDl++vC1FWTz8PeQoUr+W3I76Re1LNFj21P69h63dx01B6MJaW958KS0+L4+YrxBulu4QNGD2ClWDciOmS6G90ASylTBtN3hhKtQpSqKKXAVc6vOJId016KzaSRAaToWUDzlpbSx0DP6EbXAe6/SUV+9GSaDkZty54oXtPFa+WDzr025wes4Ki9Z5ihS91nDhvlG0bgaAo7sTEIl2arv7/klOB3zao4f8MkxSh8pMhrChgYcr5UxFU7jqPlvHNeZsv5loVxP+o6DwStMonZBsY4Bn9oT/Cr34lSwuO8mEYZyw2xx3xJeMQzSIdxFiStLrqGyoC4qqlzDayNOIqxQWQaiXNmyNZjmz+jGmFLmfgzmCtPmdjzlPEBbD7NGuWI1sZeg1qrOC6A0Sdn00OlRRRP64aMpQRJSZUd6UrApvdzzl7/dDHc6cw3hZqniLcMslDZnBqS8rVeHCOh/F+8vN02qe5oP8OQeaH9WmWWY++zqvWDo4lmuGaQyo8T33sBPYx9NrnVakrIn6N//RYgv3ZVlH5p95Wx61nJxWdMld7/cz+QBkIgG67VEV4RZzjHYbSr5JXu7w6t5q9JtxeDKLVJwgeueGPSXL8aFx57IAEw/7cxbKMrJOgYJIHBnQNjRN12Aqf7hi6j2zI+yI47TGsbwOrx0YtLIsxzcUnjYb4vrBbyepXeB+sfNlP1I1Jf29i7qjezqwZETM8z6uqMvhEq+FGXruFYTIPJ0av5X4mBkcfTyL9AsO2S6HW3Q1W5eh19Dui3wcHbrr2xlWCrgF6kXAovFOtDk63tWlmQU7AEd707TTP6ETsXxXAvm+3WakYBU8wpjTNmpAlDSSEjq4mYE/MJ9EfdDmI6ZPtIqe4ybLpmI+OBo3y33hkesEn1OEatB/Qpij6BCRscQ6zk7fpEe5MiFqAuawDx79DIEjxMao0CHVDPvMrqVUkBFmVpeRUIJDnDbkqSx+/gDWeud7VqUjaOqxx94IYFF/kdTbKsMUm1aLZQAtEltPiw+ni9XiSFrrKRS/yjHiEIlIR7uyWFA9ZvThYpRh62uhPJ+/BSlpuVTm5thLC9rCRV/RvlHkwXWPOS4ho/SckcwGKPIEBZ9Z7CMc0w3Gz9s+Y52Sbq9lZbD7+Zz+vEJWgQ7FDz/7lV0nAxGs4b6LLHY6iPHb+RQDM0j91UmvrlAoO5luM1A4CoXdypmGIskhbD8ClZnFDYCEu1SEeIv+bzQOaK4FdNR5qpmrrSwyWdwxzSzbgFyjjyiRip+YIdKhbOM+swHBE1lXCTM70BtnR7K0hBUnnX5nLMGj1jHu8+cSbQmjvR0dwkK1Qai5D1SjqLWzieZKL9NsDZSaJz0kmPm5MAyQnHO6hyxb76ap70bsyzQLgogAUn1CJV//a8W6CUAtQSKGIXt+cZz9rNC3MzFu4YS+13XZ4KNKGKO6gWC/jO5lijLTPxZCVZaC8L9TvakxGlTGzTIIHPVMonwErPhI850uZqvkNblD3AcwvFtuUtQdfrrQgG70/WSc+dNZVoJQoLfHAi23Ydc9Lnmw9Laq7DNGlZag6SKrPG1BHjJdDDQCD8X/Y48qYzoKqvnleJFkxHyzfYr8xLVbzvcLTQRMZooufZfdYwAW4NYTUV1TKAELpLUUKbkg8VsEyqjftWwbKSI0IBztYmBTKoSkvnLbYup/hJOswZEdlBKNjmZWeWWqpkXsFC5p+FZcHwthC2RnoVdCirBGygJ6Lne1fXkNxLkagQoq2AHfr5MRUa7l2CIHuEhbyjwRrJF4u6ORdc0JO64IwNCKn2L+LVLf6rne9/gLor1zR3EXy+E6Rw1PAmEI1qwtOS1+8Gb2ztcJm3lNcdzB4HQtI2dZQ59vRPvinN/s/jcRGW/HkDmnyEfnBqU1tKRZSypsLNTM1tfngGOFdJHR4lR7tjwuYwnLc2wrwBfmAqlcJeC37/LsrFZpFS4kaVpeSgWBVJ7fvaWPMzLFjojeq/jN4gj+64XPFTD/2h6OjwsEKR8eqm9u1YJCYWUtCCaMESwianZpaWasHMUxiKBOcK5kKK6hWTKh7lpyaP2BbUGjAnmAYxnJnPnmUHoT7auLt8AydYemIPkWdsQTmnHjUBGEnOQS95vMffoO0lW/6yVKZHiK/j1JALKM/qNVCtF/c5XmKU5T1TXF6JYrjqud87U6taZFDPuqsgmYZIn6Wd0U9mHhdiXk1dNTOyo49vQCPpqr9Fb45LNdkPx2J9FyUQBiaeyLHYf84F+DMKlR4HJsGjPTkieWDiCunLTFzkjZHmN9t1/VkBZkn6byjqJK/tbDPPL2lf4Irn4KcjjgrLV/BkjNbYwqGwTAu+pzrJErfw7gtspArspqjFKtuY+vVe6Tk32GRnyn2hw3tpyohP1Hn8ADu+Ufq3MVWjTyV+x94uLHYWLo6Ts9YknQzAGPsdcFVkWBzZ5Fwgfos/6NMls0ThAxl/FUkKTm4Maw3EQrWhfsI15q2K9TRKIrPyjUniRbYVSEZSIPVwq7ak0FOIMjgYXUxScqNznDZdWQMluu6NyRXImKSaPjowEymDUScR7HKfzPtVxFHCm8V/ZQiKg2BR4bQjZzznCdcuIH+H6/Fvxmiz65WF/tCTKVORA1SUuDBqZyNeNWCMzWQQQykq64a5JZEec7mr1Dm6VShgfd7op1Xua7SRVwFAQ6nR9GOUH2zhnWq+zVby4oajFGPGDkazo5pWfAI07Wy2j9eSOcjHCGwfl9e/FjLOfhNHv6/MAEYDQ3JJIgV1l75qkd96NL8TwTcsc8TaHIXxtSySApOhkQO9ZsI3QHB/q2N8qbZiLuXCi220wl+5TmJm4ixQmhC6DNNXVEy4kImn91/sjoAezYlgtUj3o1a0w2E0XJdd44iJ1MRGfvEzaHVRHbsJMDJ5QQ6okQFfJXsDa2bW/YYrwFJhR6oR7LIwljxGdtNsSCytyLf41udxxwSyZYze47kWdNfJZtG1ZKYw/TZSeCJoJkcheURnJ3fcw+GPlyhsLMbWy5ku+KogaidxmiiVjW4m6R+vHC9rWFS4TT4hXdPFpgsqxPsJw/cw7qtZx33IL6tsIGxXrESXNj+ABzKejahmqFA1u8LAzWvoxr1R161Kfpuf8fFt8W1+mtw35icCBR1GPwWJf05eTJeeMV9pPPUsUEygmLAC6jK3U0OpZdLm7mSty8XQ6eIu07DW16Z6eImKwnU3P7Lw5ci/qDFcVOVueIv/S08a+MopG1GtsNY/ikVQn9da3p9AubocORF4GgCF2msFtXE/thRQOwx8dtJ8ugQFlBfJLUKWdF4XEKpnbPM9Ul5mRroS+/IrBPaXi6bz+KDgrZLBTtuy4vRYI6PPD6TfM8Qj0SGJnvBoYTOdFQCBuliAm687Nt68Fhs111py1PidPnjy5TiZ6PL8TGPxbLUdlAVRrW1n2bs5xW4irc3rhdWy/nuWCLvWIBPYNt18wyIRLxfyGz1AYASL86eZ4/3Sqtj7iNIQGEsAP9xp2mVzRDGfA/RnjfN/WkVgjhW7XZ0oRItxNn1DXHFycqQH6h4t2J4XWafBara+yeJnhCg5lPp0dNqwfHybOrC74ltCwpnHWH/1aZZP/FDeAPf1YbmspLaFooOAa/k4sSw3ozY+CVpuESJswxVwerBFSBYY53bGqYaZjobBDUWikl8NtKdkdAXv8tyv+tNMH/LteN0auHmi7KY15kBn0tyXUhsTEZlf4uZCifnwotcKQWfAbsr7jvRp5JnTWKfX/857W5Gp1bIsy+KivMz2Pc+KL20AV8qw2gYodYlI8FX83vCBoh65MeyXwvoEnwA+pqhoRL7WKZbNybsc6zvsBfq7Be4WlRyggfiQgkhzqEuHdYfXHe9fED5BnHI2kIVjZE7ZoXOWEFrNI5fFhAn5u/sTyCJrukvewZNQuw2x1aIoTEXYRN2gltIAlEmzNuniumYBEM0n3wppElTdp+nrS1BS/pRAzoclFAQG4RnTkss30EW4JinXEJf1HY9li7vLtN4nJDnC/0CuAP+kC/ats2eWZOV8McRcW+/Qxd7zaaftVDaOlxkjQ5cp0FJzU0oOS5+SUTosTm/N6rm/OzmtwtnLb1ltbWTQu6tPQ3iHhrUPjqHPEiNXF61Lt8oUYQFht96j4sDtfwuvU7Aq5p3abHXp1U8QHYciJG5pkElbpw4q/QqLRmc6cHPD+wLFaywqxWAn1T1pDAzFJ3Pg1bJrKP0foUO7g3MjWHoI/PZRz3Njzt4T6rP694VbN4cAuaTs+TPnxz6bbQlP29urmyS5872WjjGlBrcjT1dAK37fT9xnbI9/RvLwjGHoYBE+6SOLeSIH8rTzvlcPZ6Zbvufy2Dz6VbSXDWoB9omkfIuQCuqKZ4lvjyGOImQ7lXyfYwLagvgFYfvJ6sMmPNhS9k45dnXMH12V6tLXc7tScGA8xUPecJgAQBFrOnvU9LqFx1bN+x4lajTwfkYmcoBOzjmXmEy0GS9p51AJizFpg7qGcJMuMDdCiYNr69Z61goTAWrXM9YTcZL3EGV4MYA0xe+L9Nx4Su+B5iRvM/kqWgG7j9Y3pcqF/xV/6X4qJQumC4KRouttXFUC0dNH7vXm8LnIpFoHrRVVyrx4jjYFextnlFCtennFa7ze9vsW5y3oM31EbYzl2u/IlFgzoANaoAt0nnQFmqWdgFGghzsA8OhwydclVNt0TekY++0ctyGEz4ppw1m0OYX8Yu+lmdrQLUQccX7aKIbEBvXPxXTk8HhpMe1mdepcc5ZTER3yB5puTCWBragJp3uW2Vs3QIU+uxyqZq2NTG+5JUkBz+UAQWKCBhbSyvvFgUAe14w6yHYu/9f/GspcYitblIERiLobPiHb2dp6sbqyglZVSzU660vUXnCu9EP5Mwma+fnx6Mk8lpMk4g2Sga0cp6l4eogmPelJ4jiWkbJ0pi2aoPH122jRbCEDGqKyAFkY1nWHiOOHJL3nSWq3t/W88R86SyvluDGnF+FbZM4pqytStMD+d8XvNxnSn17XhtN7hw68gF8gM1TDyy5XPWDPXvtcbrNN5PBK6YMlr6DwKUQkQgVL5zl3NrFhXny0GIHHk+CAVZl+zqS36m5msNTd54RdbayEhqOPZuXtCK8IHlIJvb4kel/y07Dgf4/KKg9kMP5KE3S/Vf5wz+CrL4otGDOnMw2cNQVphblEgQa3BcjKpHaLCxPiMF3smzDJ5+Jf4XSpiYC74cz3kvVXqishVEDXg2fOh3AFiS5B3YOv3S0iBbOJPkbsMqRbv3sG8GONwbmJhzfKKus/w4ftdJwh2bh/9lEll1kMKOJ5eQ5t3APaSMrSXxv2oYdOByZwYs5Vx0aBuAYTOP9qKwN1UEArZ9t50vCZrWLkNHaOFzpfbmnain/MNR2aUVQozexgLF/RtE7+9hRGlU+mIz/EA4bZdS1K2d15eXmt++ZPRSwAdGl68TvFZf0iH8sIsIfLVqdDYdr3j6pL5Z5LUga+GiGJm2NVtAveuIHpDh1tpBZ2BSSvyNCczexuUpRNvxsW21COciROg93sitpQnojuRks+RGShX5FH7fme4p+QWeRz7SuRXZngloJcnLCJaNFxRWLk7Y7QmyNOj8o9JYlOn+kmuTPdKSlrzAvl7GHxUsTQIE5YOzkFxMZdlanFpSE6Mdsv3/82/IhGrfDfvVGbNORMiAC74NkfXBvdFpBz8iTfe2BdJLlHUS5DSOQgxV9/oa33guVL/9Objl2lSuRtNSDm0KqOGLjEvJWKNym/dd4mUpWXEAEWpNzNtrOZ+1XSHN8TTj649tZl6Inqr21L/w7gxsmsv06o99zQwNev3+qLt/WmxHme/Pn+tFm0nsV+SDqbjJKgO3kDL2HJR8rP4kOzNjxrisGIXONZAwc377jmDqfq5PyBMvt5bINmZnrp7aJwygIV2yNTjvwy2Yo11WLRX2lE/+djelwRbjCkdUXJwZuZmhJCHQRLhFYrrCumkFCqUtjsk4YoXNNAKGbWO+4oHF+8Wn8fiNjK0FRfdvfqZ5TKPPKN9Kk+7WRejUOaHKX1ytZoy6a2x8YJthvqqcT+KcUN8p8MUsHKhRohj7+8UsMVDiQJx3nQ03aSIuAjlEfQlhrcMWlld7FNJCxkwRC8yueP7KYo4uZTCfBdQdqNeqzhwCcdCYeoxoyUBxOFtTaRzlyrJOar+HF87jHVGmzeou9qHVO2i6t4QozGohd25kfWLKmkgTSzJf2+K4b7KIKg1coBCxuuDTQdO5C08ZEYfTlfnuAtl150+E0yoUcK0ia2gg2dsue/aitCZAkII5wjXjsWt2gc8SuGePnHciNqzqDHfhv5pL5g/DvVYEJZjTFfulgqqnMSSeSmO0vxKzOKrVV7/6IVY3odSQzaJXwecHM3JRzGySunAiEqlzFv77hZ24qeg7PgRE01f7UxopoFRt5BOjfTLdDgI4jkmk+8kUNIIM6955srPZfqvKxEJKc2HTciEl53GPDmE/medezShmzSUiDirtsed/nWcXY3S9uFMLHkhIxZTxkpC//Lq/AQB/yOkWwOo9E5yCy4V10bj6dAiXsZ8e3o9cLBZbdwJ8FcpGfgfwtUde8ojQLPf1IjayYM8GyXZs7fo3b21oRuLWUEnciVYocclfKIm4osJWUbkeSSVH18XOctLlZrXLAij4+/iEPlPN+6Wq/XORRoPpGMWUgw6Zx/T2KiVi/jeDGVtoPXwuphJOYwUe77dWdW1hT41Veiry9fo9xiEnm++ofRI+vJyrFGeDuwqSLq2OK4S95o1Uurw4IKMVL+JpNXAcDCC3OICT8V2cYGfhUdX3+tN1seqkdkSEFuXZzpiuj3z6xvGTE2R2RqxBp23l/OfR/WdtuEOPMBGElR0/Q8CVQxuZQ219MUL9MP6RfKmSuNo3u7lqalxut93x/j0fqTVAGtmsOMhJV+RAfQYVmitVaA1Qy3hooKrlOZSo3PUJvbDsH3ScMUnrJEhkC5A6WLfk7n2BkXcprZSmDFLrCuYB1Y787wyLd6LjdIbvPEF08XZkc0g3fNIsIhjroC+cdhtNlT9V5QRLCSzSa7S5PXVVR3hsEYN9BpMtT1x7fj2FFL8DhVkFx0nt1zOsYn2f8aqDdoj5p9SS5FK2SxDFfR/c58Rw5txSgdyeIsdactJV9f+tmmIiISfzph0pisS5WMcR1gxzkZepoe9vgIuSTxktfaz1r62uzEjUynTrATRfJ1BRNc6sRJH5TYS7QiZiXyE2qzR/SfLbaY1hs68wM7wnECynjLqdGu/LfOSUiEpKxCDbwoI4VyHFFO47SmE3CYZLO7+4cRfuYbuILzYSyPTzTANZ50Jmoua0LXWJ77OJyNdgzscJ12Mr0cmCeDlXPiEsRY2Za1pUwsq/ju9vDrlUYYulSznR7MzpG5615lM8jpWGK9BnbhCLtrD1v1iKo60E0rK8iO1uHn6KeJJm038SiK96cxbKSKA529D6RAMHDfbMFxbBmzRQEVhpLF+gdh1oGQI0nDPX2RBPabkYtvgQp9o8XODcJ1DmguaGuPRLKEcN9h5Pls92q8epz2VVmk+kvCUrSAg6MP0wgTxbpGFssaf6KaQESWZNnUlb7/7jH/9UgRq8AXUZ7jM87wsEvgP/wGfrfaAwnpYPPcC5/gn7wyGZepQd0dlk+4bjp0iK/UqfJ6PS6uO5ML/XFTr1QQtybCeBSu4ssjuNbjg3/M5xgiVpaJEGXqeouAQ4TKOLrVHxjAkFxG69l2XGdssynamd+rSPNv7rIjLhNA2eQLN4JUbsWrVnCpEYY+dtvPhTi+kZOHQL7D6vN5SgfqWed7KDXgEkyCgXaQtMwCdrGJ8nZlSjFKNfIIyuTFZv6VYbIV88V2MnLEaTnaBoQtBt8KtCpJIYsNLWfMi38c0u/3dk0vpY1asjMauJRmfYLltLSCODlt5zMPC/9JNJjxsg74LMeyMC9oX5qRD1bTHB1JdRp+11jfGDJduQYCTaYswoyQHQnHGQMTbjhfSP+3jzdRDq/S47E9p1h8A4dZyADgHyK3Ug3rMN6AGpGrh0jfdpLF38wtPt0cWHxg9SCy6JNDjbZohw4/cNAHbEKCZT8uMmFc6wk7d6qulbFO/uJFSHqfJLj3Vo+hnzKPr4s2MaiJp2iaapwPDopaf9FEKG5haxOl+5vTXMUaELK+7O+chX57vtIKtMa0QZGxn3DSTOjCTlAbxNBO6uZJir+qceYzEqAkIchMSVYiC9zUJc1QwXvnhGlazYqG7Vhi9Ay/41c0ZxFD+ddDpLjvwY6yuWu8CVxcwVji803e5EgVYx0mGytII2M+/FuCcq9KeezPDQ7NeyQA65ysvGUr4lQku+DORtQoOKT6DqhIM9jDNFJ0Pjga8CtDAaWDiZjVy1FV0FUOWupBliJgO7B3FgvMys2JWUBmlklS1J/BSy4lKsheqXtIL9as+vVjlSN35RffUitzTpib2swRCbmpbHeZtE/mByrk3jvoG8YidytF0H+Ro+5et5CQiasJP8WztTDPZVCeiqq+lXcbvpf/z3xXVthgigskZlLln6sTuouxSoDGEUnziwlNfnd1iLZasUpruisphJhVrzsiKzLc3APIkDurRF927YabIBLtOFLz7Ppexv1/kzS3YTVvLriYbVwdoen+RXdxQ5Lz+M7nJOS6LQoGRGJ6mujGbDL3rGGYkz7tEK8pq4kPSmqYFRMGIuHs8vHO5VNgJeJSJLkXe2FphHdF+REE2u7ZZKmGBCw3SWfzeRZt9YCJnF+4TKy2o97Ohxod+3w6iDt1SqF+xpWvaNGG4bciaLuHEPX5n7ARqR//61TbxDj1vLshdQOqGOAaE6dQtXmpV6XWWSm5mq8ln3ij+rk24HIqDG3T2q7A93+qigqe6k93zFk+FIaEP6yKHkSIqNjtJIGhr95Suvb7hN8ghm/qzMhL1hlpv9NQCF05sVHdZExjTgacgNNUClda7dyWNFsuORPCinnFHVNRy2DbsgJl75rgFkDRcN8OV3tDDdy73pLAlC9Td4Kc/SGR4saRZUTeDnW7jjzZwRZ34b8BBlzJGiYvpYZELlvuWUKWgcnd0VlZ0tJdJ7kCwXmn8We0zb2HN3u29WWOXIgh24wMSaKXuLwrLK6qTuzwaK2u5mVWXyp6MZtLGI+cAgXBW5fzsfgEOqVYGL8YIw2QZ5xnaMWhs/zT8ThrUloJg7cxSMvj9O4XrxlyuoX8t8oqoe9NC/A9c1ypaHsSm808NzHsbYtxwEptvD0sTmCODzj0kLSnYaIXGgUnP3FbRPcE8ihMOrxyc4KE4pcuIazf8zl5ylTC0vkjYnlzofKQM65eCHA0Ta10475eVOGL9uVmRpFRr4gdpKVCE92riWMNc1MwSi60Oh8s2p8IJB2XzduRvmY/sOxNp2zm3gfESyUDLIDNKyJ3VLoPfcksxlI6mMQWVHV+teahrBL2Aw/QdZDvbqVZOjcBiGlw5e1PllzeDL2Eynhjz9H57cxdTuI3J0f56PLbH0FatJpV9fgQfRYpOXQwbcGwhotdwWWyqyDa3dLY8kK38MHsQjkfJG62NeWa7Dce7xfMhBnqFk4aO3YIieN2PlSIRP6Ca9Z9SN2toR2OcOU9I6P80pA+s424eIl6kiP1AoiEmIh6DI+4iemEQnxl2FaUuPodizF24OPTi67W8KIsYj39MNdo2rMOtomQtBVm5gGy5czKaePPSf6rvCZgbqT8Yk5F/GKesSJqxRYtIzr2aNmuRwc7jvuJEjS9mmocDKhc1MSaLxoPBaShJiQIlnX1bEt6I+5yJw9cL/fl0oVc0OiY6tzlPnGXCDmLN/w+YX6YlvgJtnubyAobBxrdTe+naqMJeqf1rJT8ltXr7GHpLAUmHpYPUIQahiJyIBKtBE4ym7z3xywH9cLecgkGlHkmn1vfWvrOv15rj+dVX8coL1gfGubWZNuBYAC+Rq9cFmm07zaVTfedVOpRBeDVVyU5e+nY8Ub7ZNgpK6VE8kZEXMWiIqx/X3HQ2oH4St3Y7sooFwgnOKFHn1t757fJ3nbBl3MWH78cmf0epwbvYw3c+hkJWgOL8EFgJFErtwGMoWEXnZqOjm1ZkqogailPg1+TUGj6MKBClWhd86ULZ/Vlon/VVR4IOvp94qQSuqud0p6i0GyMgV0UH45CLlMNCevCF5s/WiIILqZiY0gTMtkdrBG7oW+m5U8rV30BR4kjou7IXUUnOMUg9QhN6Mv7xIXh2L8FBCG1sPRQ/59GCM5ArmgD/SUNxFEx9aCmZmqMzO5UHyS9QRzN5uKxF3svqNEz/Biz1mzcX+c0HC4GJGVKJ0mcF9bqYutTJpWvurb90OG7TsuzRDSB11VSQZhDwRXg8zRQIEk+DEzkG7oAVnoSLLncsRt+gFTBPWogLeMCdEjDVZFzpbre8pX2pTj9FsEGnPHy5Ew05vFqWklIbCTBH8GSeJcbVI3n8AlyumBA/91al7GNhzYe/WS5pO+jwKf50bfMx0khHrqBWm1u0wOf90fetC/C9+E/bshD6w/LNAYpqSa16iaSv2M0zJDZb61AuXwxD+JhU4b6uI1/24El+e5egkWUrlHcAQgqN1G+FeWKJ/t5g7YYb44Ukj9h/0y5giJjXLC/li5GodQiDI9xBZMWUQjeIrEHGulrt0l3zK7BdqugeIMkAR2ltjW1P5LrVdu3i72AL6/4jyvj/WiU2UoTnPtvK9qoroKEIYkOa8qC5+IggSqBfvk1C2PZG3fGxgIyc4Mu5RBC9M9QEAMMRESRJWG6mP0EjDFg6PLME1lwHIB1TO2JhVxxZ1d296iDfMRXroLMG008gffue+u9s+nIMeBKEa8PObLr8B6DuwRZfNtAhcrG1ludxBEEQzS5+Wa9+LXB4ctpfGelgitNTI9E1dLkoKAHbCN53+uoR9Nt5gQAfXW9a9KqVN+xcrVha9lFL4+I3QhqK5n4WRjood/sYPNV46GRPMMqGwHCuBD8mhbIaudbLQDpdNUbEgJIEJbWbNNM7TptQTWqrnMBMXApdyOqAcrlkwUWkgwk4OtsN6AWihEd5OaShN72pmMySjz9PPifby8Bl9tFf3auQ2yIN8aLU0im+PZpMgf+5GH33TEUPvSxnNqnLssf7RK2VeqUelXFsvXipCbI8fHvjhyaKYwK+wEnqo2T8yKc4GwEDESt73mKUriETHJ7IMAzKB/PUcU+6aB5sTqrTDhD+q7UpnXdM8s3ahhZiB7HWQNrAviP0ji3LgLH79l7E0fcAFxK5WylvreWhWgJe3iajplQmMIwdhkngQnIReAJrpuS7qbwkCHndaM6EvtD9bylNV2W1sIiKm0ImFY3oDQAazhQ3N+zxfoLpV3TWdAGJFDR/TgXe3kh7xpatnfAMBd1V97ACbMtofrhCVZvIvp7dkSdAVWfYFu1Jnq+1DDqMidbQVuYlM7fThOuhT3L2NwSdiSzitDupOH14k4ce9BXMCmYx/mrCquQ7kSmLkdRqzWHpIkuD8BDXJb8V6kyGIq5aa+vSCfCQcw7K2PgKsyQ3ZKlp2MQyhQKrp0C7xb387AylfnPQcbqzzZRfz14ds/axBWrO2labmYpvejOUDut7fwL7qrk4HSvYPVPDheLb8Sv7ifRmgsQla7V6ygWOqlcVvtPPjlm8ODIXgapEGyYBBSf1F2O5MtgSIE6I1c05/cJ4RmHoIuY60HRQyAvdx9HsQ2LZ4tFj7ZlylSzbyHVpSJ1rD0rfd8Qs9bfzOa2Y9s+nTKkMIFjNdhLhMFiFvcQ8GskyJxxxiwrQb5LJnsmVQMkCxIwIP+4kcvfAjgusRUH+L2dRfisWeG78LwB8ZBVgtN4SVIS7NQguEIOSAFPQp3dy0HkRfBlj7LexTm+zNu265CitL2a0tj4+L+edttfmci4QMPaAt64QNoA0lMhK+brQMyqtnhFQn4MtYyULTf5Rnj2ooK6r1K9clJfvnmusG4TTXzj+gVhBXaH39VixL67BGlC/Dlc4Iw7ctkpXGB0VozgyjhWFHYgrjz75VSiBdWXPJjhYveCc+S2+Ini+gPNwvXcDNOVI0MIFhFBzwBFZINOix5HWKtWIxnKJ2xDEDt4tTGT0y0Fzr42Y77PrA3XscKZZKzur7u/lRSQoWRePKrMKzXb6nmSYRSh8tIZuig6Y3NySWUU4xMWdKlc+qLu/pKrgW7m+PuGvpzYXg6Efrl3SK48+XlbwlxHozwL0Jz9DDvrmbgNIjLySi0Dr/9FqqE5xZ/FrIrNClYu/xboniS186t3JaxfAkzXomzQ/roZFh6IcIPdPrTuQMgvvSWwEsfO8iPjLUSCD5U6BIzYkoEZx3mgo7RnzigKYAsp318dVIo1g1yeXRt4hx73RZsOsaW2u97wwy+hud+re28xBbwnutjVWrvI8NxWdX475PPHE0hdXagGrjltCmLmPQH2gAnBd0sQF+JDV7yqYvNHUbhQdOzpxc8F/c8gGmHDKa90NUXvPjdxAU+ZFFN9GWDsDBzOczjbw+lluDKF9KBGbhIowY8drQZwYKXjop6Fcquu70WSqKx0bfiLQOYmqMbp63xuib13a+HuvRP8gJ7arM8TfDNi6nv6kZH9aZUCKRhgBaRi2HsMtZPEP6zIctZudcZWkJ+aUa7Sx2cmAqV9jkZUEvxWeEtW7xi/pHy62l1KxjYLfQYh6fFKJxRXGJv5yjl005xtiaByQ9y76icyaBeiCKGy8J7jvJdE7oy7dYrzCjzMMk7Xve3UzGeXqEMJsrSCMlIRfJo7c0vfDG1BUuCW+f00VRJDLuxiI0MDZL5LLDsl19JhrSVnRi495dTlASxROFmT9kfrYue44I4tXDIbUfF+rMbSvqw0r8Qmo41m/4ZUrtIsJfgU95ufkvo2Jiw+CkYN9lZuZ/kAb5Y0Jtz6/1eDVzd39gvZkYCUgO6fKUa8NzJ5amV5aIIQr0+HaJ7d4x5IU9jacflmGj2PGmHkmBPBk2VGbug2rt7wTh4Zt6PyfkrP1pJiOA/QW4QbcF0/S7attwacXeS4Qa7+2TVqMCcljFrVhxat2ms4by9Rk7v8stYgziNzAQ31rPjfmtpTxzKmWKEIMiEXUdEeXy8aRciOUjQGEGdWgVtM5CbAWrjijejkx7a9XJkJu+kY8arhR9Ci9r3Xm28s4tRUtwT5nSvD6mb6CSrXM7BLxtaCQ2QZ9VzfSoadJMxx08iaSTAQTcudZDmmMWVsbwNeCaBVyIcHYT1jWnQOGNver95x/ke4/YbERlqs5pVCjY2U2d33iAhSCki872a5aiOVM6olcU/BG+0IWsjdcwR8dRcAI/TRkKzS6ClJFtaTXwTD8YgDLujEYcIcBTVQDnRfi7XGK3/v19tfu51Hf1L0JonPTyUoc3E1P/J/nUi62S5LYolwlNvfEKmrZu5BSTZdYc9nRrLbQgMa2LbClPv9BoOtYEig1WcULNpf2Ey+VlcXK+AhbjyUzb0Ou+qY8QxKvyLox/YZr3NwxmUzVMvIkF6+R5V3anHaUQ6wn0xUXQf6reEBHaHjdanOte6z/IGYRMHJeRVnqR6kljBaunaJWrIJHnRwzS0yOmFfrvZRT8nof5K9c9dJw3Ni0icThOAiHeTlR9r6eNvdOd3mgHB2BswK/YNp2kfOM79MTCXopMe3I6pxTJVVj0kekJwfFGhkqDENyhpDxxOeA19Ez1D5l/oz+rSFMz+evxG/Ezqw9XZCFdTa+O9Xu7JfNNnRsjCVhVPHP6uMFrPifPZC2zLJ9wf0DGl2ww7FsckyEong1qGr6jEmGca4HowMB/5BnZAn6975tApHL4Y1Osi5ZoDcKtTAL05Y0zgQPNXXlkYlrH5qQGmVcbPOOboLGVYeETSqDHCVNNMbg//D/RNNtidWPgOZVlJmRpNZ3f1nu5Q754uWwVKY4I7+RJTrIMFAYZGQLAIhvMV/GZ/2i07p3A2+NPIORP7ZUHMY3n+Vku2F3f3p1/HKRf3+TJ88ZbA6Oq76izN+vk97joI5okkVooFrbdxGdMW+HHrSZgZYwIOhVO0Tz9jHOUg308nLRkAuuXtiu+j4+Zko8xz0kcp3n1kQabf62T2BGXo5gXi81zi++kArjM94CJNJpxsHVOSXEwqkeQqhbUqGmT1z6HUjRFKEx1s9zteZUsy7d4rNdzFDVT0HdJ2+l/ROrZazs+WPQG7j45T4T5Cvd0xhYc//DNYu3v53G4oaTLhNZzSklGI3mFKtETpkGCNNfVctM1zEL5UqL2yNtlfBiJjTiXZvlSob6/OLeZr7NixDvFR4o4gc/hd6i1NEvUnnblkjHbDskSzvfwwtd99YxemRry36kMnG0Ltw9ik0KDTerg8AByj0ElLTfpjJdyBsr9MkGdgaZKrlndqJoZXYvZhFQEDiGppQyR6aUUzvAbrmsuAE5/CYvgPYwHMOASrCykNsRP0g/l2nDXvbvPgCOTS0RDockDjeUJkcWX4HqdlPDyBHo9d6NtuyVYWb4pWXdeEWAieOzQjNioDYd+0F74kaf97j64bWX3OpSmJdCczH5OKFznPkdlYcqQY/EVDpgX8UcAhIAABdtrBzFkJspb3FpYivsfnuHBO+Uuz405MW1802ibtVPOWZv695UpUW1R3aMb8rrcT6BDDmiaWX+hsjNqoLGmwYPopNeHFiv3pZGHIZcJ6pa6TR6G1O+nYdos4UD7NgI43JQoPwblT4Po6Jfnmk5b04AiVqRJ7yKdshWPLFKkp4FoVjYXCka4Gm2D4DSKswOzQiFHeqpy8qgljo4iTve4k0c0MOKcTmN7y2gW5ve5K8icEs1VF0mGwLwtcpoLnHm+HGNGVHXM9TCUGSCyMoeP2zm4SArvRWYcGRai88vN7jO1jaaw6iXTUkbKcgBzoT0DbzQmVnaWCmQGJY11ucQIXJ+32+BDqvRMtegMi2Q3lxTZvJsiNcjvQZmI/5W3qMaLcOq7lhH+MnDInRJurQQtoHGWsre0AtAtaaXUbMkDVzRS4kNZITEAQJGxxhByiQSoo+GphBPH2MkGPs4SOB2jdnBEYDdHxgq0+/awcGgO6EqXut7aLZ3aj0/MJf+YeC3Rrcni+v8z9iM9i4UZp4QrGAbKJTSYePc3F04P5cA1SEQla5KDnehLbjG8NZtTG9AQnjCAha+kFgYdaRfgIJp20ILW7iUvPBqF/jnYEhQ66WII8Ocz4e8WPBJeyz4EzAzIOzf3R21qvBvYSzpF5/esqRsf70yQYnVSrg2KY3D4faaMSXQ/gXrEWED2KEy7VSDEi8zdO5ZT20Bf0CzWRg01kErVEdEBperla8y4ArQ+IYSDqpXTAIbkzhFVv4mWW6t+5gIHEPNEP8l+aywd0uCnEM/Q7T4o3GfiotIUuYsbG86Mlz3bU4GZZ/Bc4dLqbAig1qzwmQUqDlNzdx6XsQizU4yUVCk4yF+1NiZCPwting47dmuSax2Ecw7UDZM4HBhbaZqZUTqt63omvDMTE1Du3rx5Dj7W7sZFAERF/dTLlAt6s3CmBxU9KOFnZbUicRT1FUEgm9+WAMaryJ4MhV00ZcDycB9iar38yPmbAMl5M9lXz/SOwZ2jNlM+8sHAYhClMMLbI5ecI1pkoZyvk4npPG+i+16ULUKgB+TwPqFIx3tHrssDfvkmXIcikVyxQ0S4BlPr8TaX3nPwLJAdiO949bOZ2BpyxQbHPiaQD11DoJoBIGcuOh9RRnLxpDARr8R6zf5UPOFWbh58yovMoGs283wyDewtbY78bRweLbwI/bG+fDqjQPdxpVqBD4HCDv8Yeze953C8HQIYuENjVF17B4+Tv10AKmE6vZ3C19i0pK45NFv8RrfykBah1Ev8zonFawCW2dienp4qcpkujK6P0Af3mt5rr2XljyRg4cvQN8EvnWSbgoqQDMjM2qQzBIf7wlFGZNHqGtMDXZjNCj9QJKLvbuJf8yPdHQvph1ddJLlRNhkM8XdKY/tt3pQ87HlDB9JPAC0g7v/miOyfRQvfFpnXdt/4Zf/Hu9KKMuD5o3uayhBDtFTEp6gNo0r5HBpUUn4PtBpyRE1eYFTSDmiQ+EtYuS830oLn5nz4fH189KZeO45mviE/WlpNnahYwLFtoSijlH06x9+uKkj41OVFfEv6ihDZ6gFeK49t8RD0Hf8mq7Eiy4D2jAakuFCONMFsHM/ldC3ci0LokYl6LTHHObP2gqxurSt2gPvfKfaKikFqSSaxsgXtwoR90SSKdr2c4vIE4W71GeMuX8xDHX+nK+ozflEOhNTjW5jcnDwa9DaEJjzcELBYwEdvqsO2vPn9zM444rRw9CWtjUNNI0Zgs+BR0NIC5R7LaN4gZSpmgtHDQeDc5tk4Jsx0D3eXmLTxH1jnWhe9es6EhtSIU4T4ua/YH2RyHB80crfFyz1+9kiMF7+7JI6PBlknNHr8obUfsu5Duf85VwOpk+U9QacguSfd04XAEG9dC+8VUTXpMAY+q42A6rSYo1oIWLj2gxPKOoQi0Kwl0IqbuOO5ZOfoZKRvZ1ZYj/i7gF7pV8ab+iWGItCH3Yhnm+tJFWrgXxqs9oGlZfDfH6HCQXQKUTlgC+mDYSdiQpL42mxNyIEIWaFDryfyxGXLEnRYtm0N7BsEv0qj8Q9OAtrEOdMiAkJ56KrVtVAQsoElN/2EbC34fJ3YifNzE4PQEic5riy7XbsWIzujSWO1NbpFXm64ZBEqWA4Ml2YdEcElDq5fq3JzOUV0IwsHnKl8/226UeEK0lihqcnxWYxO+p7+yilAMpEYd/MOpage1MwiAKUws7WT+p8VyXRrBYhGXxOPQBUBRR/EzWmC+Fr8eYxZsREkfhfITX1aaVhWm2VcB0Y+rnsDO4atnEDcuvXKs86sUQzyfOUKEzsdZGkUo1433NDLgPCOeLdJq89lkd9YrbPHUaOC9r+nVgDvDNfRs83EsRp9EFa4smiMkUYc6EmMDT/Uzq7dCkI06qvzs/4dmMjXt8Ja4jsAizn4egrEI+SUhUbvU/1Tu8u3+SCT4L+cVJXHeJOiJBk32mjzwSriK7b/lijYvTgdUwXICuovSpAhmB1yXU4yxqRiAELLzk2uZtzagoqsy6/o8NAGGbkDDFF71jCWNJg93QEqOSlCT6ZutFHVTypQTguAybbE7OJn2nvP0kC2MgdqzEbPsGm1nkPHJ9fXEicnN+urIBRjLp2Fhg2rqF7TCMADCs0gI6+0Bcmhysahauy5UhYS3+zPJXUjo5BMjwoQYIuVpOVM9fvbY8yKMdKnae4oe4l5E0T5UB9elEPDtJU6TuzDNxwl5hTPOnSxpwQ+W3scseKPpMjfp65vbHoTPPq6r1pJedkyzY2py85HrmIlPg10Enu4P65jmcLTDwCCXaoB6PeIx63EQJcD6TkRtjUe3HQz/x3jvH1OFNVhFxgQPXbF3zY/i1ICwdHM7ycPsrXS2g325Xy5X9q5yWPfG/lcJtmfYJ9lJU3hzBKELjGeoWDPZXC5WN4WOc2PR5wc+/yYQyQOXhRpAo664MhzengYh7/zpTDxNdK3Oz17vgKDAWuxakQgIKdyxaM8MemMZhFpZM7c41Dt7gcj6yLtoqrbT5Xao/ERSQewhP5CxQgUnQT52LodqQGsbMEXFH8GXOXTMuzCgkokzIfUS7dzCfI6NGLNB4A0vKWhUB5kF8TdbamST3g4XeMQulPV3wu5Mp+PHmcBCp5MAeYvAA6NaHMid8M1pMJGahVfbfsRYWmUCmtBtwoqZQQW6JdhWFZ8qOOOQPyvFqCS6+9AOL3XuTF2t/A+aLWn8sOhTsipJzPge7sAtUiHqEm+eL6upx4JGphoM4n+8j2tFEv5QPVePa9fzAtD9zmYLyOyaiifbWDan72Rb4K5X6wn3Knmy4qJNRD7jsEhImE7Z7hT+Pf3BZ8MbE/ltiflDmRDuMjE5dmdJ/gJfzNyq+a2kdwDgumpk6TMUkx+3nut16zEo42N4/7XcVh2oBJCbhyPMQSxxvsAZwj6INzMskAypWOUgUsW5pX0RKsp6oYV15wl+tSsltQBCDWwCR3B6hR4OWTlJRnbRqDjlCWXcppW6+4DNsW00nVeZ9LiUnlLvaKmU7rqx0HBknvKu44rj7+59fXFNLQ+sxSgHRWQ6Ii8o8ZSS+3LqO+yMxmlASK4iAKnfZGaHNUlx92U6JjRyhgrK+208SS87CJ1kwi1jWcQrnP4Sg8XJkkeHj2SPuv7w0G8InQIL4kNTvPnvj7F4rIn2m/7o/vH7e3o1PdybrbymUbBqSFT3MrYhnbjSYFdPmvWj2E7KiRgKm/xUZzXpZ2hR+MmGeAoP/tjumyMQYAQyQuSzrd8DV4CPlsH4uTlAywENpL6J5OFDdVJUgZe1hPT/rEViP+i+1m2V2TgnmK1tnmKzmbme3oSzoue85hzukmYpHQelhvld00yCo/FwxRI81Un0oCUY1v1xjQwsejaCl807oTpvKixrraZ7F0gs6xThsAqA6WSdH4NejaroOreLH55HpF1ofk94f1DHEoZhvTviQ3FKn3iaiRuevfF+62qAVwtY7Riu+xLnJHMig9j2V/rnNaUq/cGeja0ZpUFn2T9T47LlDWm2H2zoC+Jdnw6jm7lmGuYu9u8ZIpacUAc1y34l0MIWSiCsvVrGA/V6KPtTeoaZ88gb1R1IjGHRMYGlO6DeGtBjaAAuQ8gGk2aY7FR7xDKVUAeqoqo7U84Au3uMAm4MVrKabaB/afcBTiZMi5wAYlxk+puHXAZoClxWPjmU2W/NCRVHZQyesGMoipMfIrSvEZ0QuDKxZjrmMgQTBIeDbWKL8Px4qqtibtiyi39EafslNi7Ej1yqUDUHUYQVzeFSKPyf+TWHgzShF3FYpGV8ZugO9S5s8vjfZIoS0z2axRsruU/YzGGHL9VcwF6rAuNOKmpdS82WF782OunJ21hyRlFSBehtKfM7/RVe2QoABBDLg1tc+hL/1FKcM8sukFekQGDqn7AjNLMf+guR2fvfpNQHiU7PMuRDWKn8YZevEQ/QRtsKBdtv2DIllzoR9csH6psp/D5jJrBfYVz8x9dkvZ/03HnimXZYsBNZhYrlA8oB+I1zYgbGankHsCXscG9VbCiJOhXujAI8IGdOgv3bMrCxOvBvbi0YQXdl0VJHb/SZRmipMuuMHtyR7BtqFS/41XzU3j1yeCfciPneYvTTHVdQ5kmYs4+VncSCn8Uzbk4OfTjq28J9+miZFFeyTOOVY5tPvmaoDFTa7FyY7Rh1oXxRqV71E6rChDm8Q8/w1OL2HSlG5iJKMZwMnMLOQB0+ffRHa3rCG+7rDn1q95lh3lDtn5NbOEmNvdnB3zf+LqCPN94/ZzrzedSZmihhE2b53GXPTF9WAnSxB/CLIOCKKMWqhwl55Jrrl/oK2KyNzXrgNo2io6PhvGhUqmJF+rbMs/bd9o1IYtWrInhS7bBrt/7aV8Vm+MSYVpI+fJSfWC2KHusssnxeNGveetfpYgZbCYk5t/LruIGSmCZKkP8HvufKGzYp0Yda2SRnMCzsMT2/mxhNwmZxj4HvGzJ0+tcedHCW+KH+RHoNd0mqIJoT9F8DWqrGVsfrzcDuHYJrQdAcYp1CynnDWMEaw/6kX/zm9UX+OfDAIcBHl/tKdVLZ4PYpTY9MKhMm42frZjMgbepkpGk6/Jb/otznLMVplNCGQMP6A6usTbOlY7yud9vk7gB++xj4hqLJvw1U3jDfPNt8Yr2Ln/qoYDqABytAj9PxW7En6LGkNj4AWAs4mw65oJFhw8XJaxbJRw1liJO4Wr1u1QNejqY9SMESRwUnmDa9mqbytWRj7avkXj+yQv66oecigUMcQvRz9aeiuNPXT4xyk2808WVTW+NA30KPzSWmMUpGEz51L5dhUtb65i4wxqDTFLS16NL7Yo48SRtY8PKvHbaPuH0khGP6hq7+rsVhQ8Zf3xuqL1A1QpER+tF+7K43rGAeeOealJAEefbsB77ZlP1TVZjWlZa0ctTCrr1QUm0Js1wKCRCPrTobORXWr+h9Fmm1yI27UDODvNxgBgxLn6HkNgVbdGDMNJnR+ERZ9xm1LZmL/utrQ4nH8fzG2klV1/PpLTB/d2siNayuPlaeoCcNezi/NEMTI8UDV657SPLj4ppcrkBojtT+9zVF0HuO5JPfw5oa8eYw6rdNg0rqT/L8JQlRkbwPvNhgj/3SnYTnCF+tcLavxCn3Bb3/7oJiT72qmtH93idnI8GS8mWRCJIzZYsZiejuSRP2So2xLMw4Xu/zagYN4XrpJd2NSi4EidKImibcNSO1Ej3gJWz1ngrMh3XTEy0xHrq/aLEooKnUH2yi6iTCANlrt9ubWvHFz8070CqUFsIDBv4zW5gzudQ8hGakNKFdqH2sQIgAmhq9JnnpVdKwUwugnl4q0AIZqy7JdjvTVY05Jfd7eKGGlgEVo12Wcn/jv6wJ67KbqKL8iTox6apGM5iLPjLTmsg/zTfdWH6PgZPvp/Ly74Qc32ocVy5q2BgsGOmKhjfeR3TEhaQSxJcnR8pg5iU+uuhoG2splAw5dFJrBKfoAAhhdaCn+5IwR8ECAcY//520HiE4lJLJ/fpYKgTGuPqDhhCM3doBow06WKxwmXryWk2kBckcl6t3NKqAJQW0pBYhNldtH00Bgz9gZlvPir6r6MQqkRJEw3hbNI5V+0o39dxHSa+EKkLHz1ID0deVda2id2Q6EJMl4RIfKYZ2leQ695J0LXTbjtgWwTj+TMBSbKQWsTlrudZ1RufDU6ADnJ8mnfTpTFZlzJH+zmHMMUOTEhfKDDi/gLfODICWnBeWEqh0bpSbAoV4Cl/kGEMR0xOCuayu7QPODbv5d3nhEAOyCq9xRhTbA/7zXGO9TluG9Y9d8nUsQBnF7scXqWEc3dMOcALOfQAIscMTLOkpqGMCfcRWy9O9z+2WQ6+q2jGRjU7MsLugoyXE0z22iXxjBuwAQwt4UzZGkLKVJR312zf3QI15i1AEl6nN8E520CMPx9NTk4cwwkNP0ILsqxWDg9PCdIJoufADSmlsPoJ3lw4YMN1iQ6cZqp63gThwncnuHV0GgraM9mCu9ZV3nFK6lORmNuehag2YEtaj6CUcuwGcNSBUkxwxspUcTRaX6V3P1/2M1PjKokFIa7NScTgZLrtBu8tpS2PwZGu8GkijgoJP8uDn5KZsnixxiCvZmm5ATgbj/jHE+c5t81OleKFr9/xmvZkGvnAF3I6dUKOS/YEFeg6Npz8PS/c4AP/buwMwd1lvUACvDDqiE9dYwX5KMXb9G3pe3xQN4YS6zqyX59sTaJPv+P8+aL4FXNUC9eaL530m62KlTVt+0JBk0P/oz7aE69B6QVVK8Z9+vThgGMSsbkeC+qK6x0lo9p+nDTxKexUYr04Mo2pyLQkh85UnMVGEYv8ijdSIoB/aMaIwQJVKPrmwbDpRP+YEO178a8BjgZJ0w6OodSMIhUa1omfk9E815tilJWJdH3PfK7pZLmMeXfjq2bL6oPnoXu1Xl3RW05rvskCMcfSrBrZCtyKyyqamTBZCyn+fP1g5o1W0Q8/8rylSHP99RMXp4UgUeVsmfDI4KDRfak/Ckv6DSJRHaMzVVLtcYqfprLJPdBXCiMMjpAWPbUCFCJGvr3mPoY6uyv/hwEv6umiFEL++7uNAhR7HRiz5Nb5vtBVo+1NhuEXktilY7UQl5QlHgbntETCXkbKdT1fAaRu1J2nV2QdofSGwMeYSpJYbSAIUk8hIWSlS6j9rKXZiM4M05SjhKMAXngY4ljiCE5tZ5zH9d+Ja2xplMNngRNomJZrhQ2eC1cAtXMRVslDtbycovxPYGcaoYlvqfc18rnMLK5xOrPBW8UV531fCez4wnwfJTZaJQuWf59+VYYse74v07IV1O3FM1YmBAAF0CIlTxbFWaZVOAhaK2ndQPacZ/IRV22qU9wg+T+GCGH+Bkn9x2Dt5kXOQv24XpIQD0jOn+ussV3Id1Xm0uodtS88N/5BF3j48niDUl1CnCuWDb8+loWMBNO1kSbiboIsPpkHxXvnLH1G/c5m5dzamuiNHwzarkhm/jzHYapias33yMCMxnCAHRTC8FyXDk5o6e9Xg80Ew3c+lTn/48b2/NoPV6VidAwNoyMfyItmeub1PObOY4t0D0VIMgGQU144txBTOeFNOIPSCL+rf7Pkr1CigAGcpnrWReywGchiNLFm6mjZQHnXk+/6yWyv+FziE5bgX7ou6bjV1IDC8my0eBNAZajm2SBLjp6vCMBNnTob8IoGJtqbwd92ClkHdiXNna4QrRrxSXd1Cs2UBb+Ip0SbavdCGlOmiWCT0kjengl+FGtnCycEYZoblJLC0iCszIdomnmhZCLlEBX9XfKyfv9XD6Mcff5lyHfrPDRfiNOH1i4q1kcUQnA+X1bYNaOuQruX78/0sa/f19T3RS3BES9IXjSaT/Zj5iy8H1oMPV5GbQXfvSshKubqgEke0EnpFHkPcVoq/tPKmjpwB38IyhBJLIY7ZwJFxdeVxfXZLvWMpOPas8tZihCUKZbHErlvx56Ux2y31ptHLUMEJjMZZGBQWh4+NX16sn3/1BG4KDPe/XhVziJlwUTZ9zh9iGWeOeD+zlVE+WcrrLMjL1ogvHdsoF39PuPFgzsZZpE/3dGa9PWm+c/GD8cgEod3FUrkGwsUilABTyRqCv7QmZaOoGqogXFR5h4rd8ZCmHFz8RcL0poavqsoHkHH2D2eBJP4yKMmec314PSfChrT3naLDrjJRN+AFtcxcuEIyTSr56oh7o/yiis1iGpgHgARBlc3xQnh7fGordW8jDfzyrjY4MEamBt/DjcrX1GUIPOHoL3BIqxttSi0WhDJFD/+IzowwEzTD8QhLbzTdqb0TPIk6TW1C1JjWZj474zVGpgU0TLvgoCnJyHqCKfgr5eXTotNSTeFSWbmTHzXnnW+NANIKcsQTk74lBp4oYuv32Ujq4FXnjPiXpFIhpsOLK/cO3kggR6BSkz/ER6UoNxYGfE206NqQzsWZY4aRYf6n++MmdznL+wmPlpEFn3hAqlA2whdOLS4F1rIE2iUSLlgzxP1wpjRNIwm1xxkPUZk/JF4UWsAwux3ZOuRz82ysz8liY8RS7GE94mzSE5miWgAnLXVno72fOy6hUwG7g4+ELGuMAjjHpRD+aymgz1RIz3lYAhYUyVWlSIxp7InUL+4xNRGdQJk8cXHzdgFcIG0cl53OSbafDcxXFbyjaNQhVjGWtFXGPMjap79/a9xlKSRiTXpIxjwzzhlGnOQZfEgrWXHZkca7gTMPYZZj49j0j/ub7vfI08z/jpz8d21L/Vxx+iU7a2iFQkqOCDsw3jB6j8/sXtz/8AjysdoELC3DFrn9xX3DXxlGBZUPBLcvrYiNPIBASqc9LDMbu1/xFz9PT8KQl7DYl0Ffk9tZDP16QURLztFQHDTm/ZozcR0ib+dcY2d8tAZqEDIrpLL+uZZ95FuynkZK+oHqXsJu3VogPwcn1Mfzq/fIlZLxH16x40MSE9KLAnKqwLSTILvSdmPGMpi35WBZ/8fXGV2M5YLZCHAqfErbwY36gvL6knNvEJKopTMqy3DDlDer/HlayRHbr0l6I/9XAXaIS/D2A4tDbpeLHoPogy+fUfxweh7qV9mBOUuNmErb2Ex6holjLEedssHQWa+KVs1VnVlfCBC26yiZn5cd6Yoyn2NUMNxAFn9ZEjf0XOWjrRpn8AD7ZYG7sSQfMqrIz1vPHnYk9NJr4sOxYpq70UcpCiDxtgC1vLWgnhv+Oms+dmWcaSrxveYfeojX19NlBkQlAIrJy7OXzCv2393qR0z0q/TwG3iBvIunnrZnCE84DtD3lQkfvSj0BSHxOW3ix5PayA+/5ecj4ZxpawSsLhEohn2zg9iXbcOyTLfLOG6kiQAiuKklecDeVP0lDitKAQvLLLr2nue5enVa8Fx57SWm1j5Ewo4a08T/cjxFB4SpPwZ9KcNXcmhzwnSNbvlHWFEELaRFap4gYK2MmRInmhH9Yug59qRU/Rdb+cWdrjJA/ROQ1d1mvGMHRwbdmmpI93EWb5O1FfMY/ogMg4cUYtuCaFneUH/c/bDFfTFPN7dR6X7DXkSJM537fUGulkmnemdLP4R4mlfaTxRrbTdtDcylz2jviE76GcLChN4y9LkIb4eS8+ryTFlKAxCnrUdKVydtm1VAjOxyxhIbPhKQJY9ZvsFTaYRJ5mPzpRjVUZ3WUtbdish8sKtnibeaDryKhZ6Q8mAoo2iRn0W/4bnXL2K/H5Bi6s5xeDUurVpxAtoIYIEkxDoSlu331TFcNpTCGLGZ8MM5AUQlzhVMhQVyTip7SA0bDubNUkYfzTG4j1tnMgY1LbQzoPOuyFyzuwAq2i3G8+NiJpv4+PKVQYiG2Xt4r3fZzOwbfOi7rZZZen/rTVhlsBo4IaZ1btbEuMGHS4eXhHTLUmlLwmk+fgVFC+g4l6rjrfjJEXzK+GZ25n/2jbeZzOCaQ0rg232aGjqgx/dufN9FuXfH1sPTGZeun65HHB9XUOKlxke/zqObAuuca9pQosvrwri1vR5cKrodJ7R/5v9rfguoUgx6CpIQ+t84pIwGGP3TGJDFwqql1rwgbuoUCjBUo9UiWu+miUizr5eF6OfvSsfdTUmL2ao5BxT7gRIfWci/a87AtU1i5PvCv1XbsZQ6ayYcNyMxer6dax0RnDhWVG6QoULC4R2NT2SQhOTDnM753pF4zXCdyADB2L36HmOXoHe9WhJ5lbRalX9zfhY4m+nF1986ejXGrR+sIK2bFqduya85SoqM/YRWlfCCOAIvHD66xblHoeFmT3uUmCZd+JcllImi6/wOjeWlHtNitaMMJPaNVix34bGZbvya6SJofCr538Xaw2DbfDpedvq8V89ca89Lens1tW6k9b+L6E+P2G/IoWsCK/O57QLkrsQseohaCGoKRQeE6rgiGin9RAAfakKsbVjT2Mhf2Ll+6SdO1i2apLgNf++ucnC/ii3QxgPGisdFzvjB/9U7+iyKgU0P7c6kpQB1pW+KCI0KRNewhh6wC5UsmN5yAvtSQ8SQrpz+/owkraNE5hlc6NBWWBOJxL5hBkg/C3AJT+Zprigwv9aSSFCQVvkUNEQg79f1aVLyvkhr1laMUr5uwzXVbXBytaq61h1+brmoMcPiPv+YVpHrZn2dBOiiXgwRTOg+dxl10CkBYRi9RAVclbsssPN2js2coUL80LDPaDtXl6P9vqJec67+ZYBPs2yRtc3aQdXy9pOlvNTfqQZfRdVsQUrP42giM/uSU/z5zb8S/HjhbOeEw215p2EP+62fDHwSWtAQexo+mF/huWXxcnGgHJVmyDi8dED28+dnqr9Dce0/0ifqkRTdG2PiaFbA8xHpf8pAvpiE7fTJqkY7WduZrv7X3zzabE1+5AP2EXbA1Q4sX+FFTRlZJzQeKT/CRFXD0seV4COKyaBwuJdEHYhPxiZQu5bL4XdeoN+/4DYADFOhmgM0puSPJL0mKF/5vEwVogj3vu9L50ei4u4Mh5DO/LuwM8pPhtSLpYoiTEEKSEg7nptFbJAaVRKVglJrUBaQZAjRuicb1p76rkHmqZepGm5Yc6lQBCJhU+RVC9L7DsWDcG2x9rMvQleWAipmYqN4/u94T7daEOXhyRXRf+4UgrDMkRa93MMWrTrtKrXhsmghhtU+c8uihG91svqIRRNTyH5V8vT12JmPeNy2oKwVqIwHQzRxRez6eOEJEAtI3gqd9AcBv8tir8vrjgM0fBSfhEqq5AGEVUgpan9c31Ny80LLVuCNvYulhIFDnvL3S9u2z4zCzWrw3MUWhNAt/TVtGCVg4UHw8lrFBK6MaPKRjsdXdypxa8NlVF8nbRgmmGQfUxchs8s7aW1Oj3bOp34gDZvIsCz4lfJ15u43HM7ocT+aMHg8Q1bSawK4Vrjh81RJguorb6zAaWmRlBACXpcqj1Fx0L5FTqw7yxPRRdGFlOLG6vg9/dnz8dfLsSxwKZ/OPD0Bktkb7Doe68IDKJYYaF0bYeh/otORRnwN5Z5Wc9fCwBVo5eyYSravVl/NbWYGM1YvWo6G0LnJeqfC6RDboAoZIUFp9vjgeDkyjdUcZpN7EAXiOWIduwQBsiSHDsQc0bzFTRky4cgUx5Dfue+SBZNiYovOWxhb36eCGpvXLj9ZV7y9UM4FNBPcAXw3f6saJCnMgWMEoEcmVJgbOGJBMTbmyDHfQ79UjQ97+dc+UMr7rGSa/yMZ0VUsg7BwXpFmpDd9Jk2z4eJ+NXppx9jHZLDkbJO927MHSlxIOgxRtvJ4fbJ1DOIxcjUoFAU3To5j5wCIo4aAmFrJzRQ7ackV+T7FaouBGOBeEIdHNTxoRp3R2Xfg+E2T1+8X42MkLRMYfFwnLC9lnBRFXkbKTwYjxZwoe/uWT84rt06COn6K4W6TiwGYGf6I+ZzLk1vWVL4GPq83GkmHLRT2cgjM1m0z/p+6Hna8m6fdZ3Ena8AKt3M4f4YIBUZR7nP9SB/Wc81xl7xmqLNI949GRXwya+k7uJKIYm3n3lnaVCbhxeoME380T7TvSOee9iTFZeeMNc2YQk1wzp9dVZOs5/MBGfABzhLoRygHvu8bT5wVRh+VyBziBCIIO9alrIO8b2MedlXKqY3S3vVSyAvedtCfVbzhHtcoP8od8jei1Lq7zvd7Fqn6J4TKdLywkq8ivw6vqtUh1A7tTsuYHOGlAX8rVP6HDR+sO8VliNNEq4JaDC5ns/QQtHfSqhAWml0g/Kw9v0B/7AiaEMOUKQY5HQEQlyQ4UutP3t7NG+/6u7eD8wzY8Z1irSzw5gV/aAgqKqJtfz0e+RtjC/INNHmIhtQuPSwBLz6oCGH5kRDKQBpnhdBVZc8WYry0GrPwqw7dJH9oVCUha3UMA9cyJPhN6iaJeLHtpVuYpFxa96ucQEE0VQ2bDd63lj4t9dMOHzexTUZty3O7kAV+cgoGzY3aw5ZLif0xrJ2kAYUO+JUIAM6Kt5W0RyZvY8rfXj7SCmWg9nNyJ1GyMDV1wJoGZTcMU8zAHI3DE7QmjEcAVKWUPgNIV8WM3oUyQivKNRR2PFrPIRgGU1Ghw/gZDyu1Zi10yrzZIZ/4AHk1KUbtwHmTNV+br+GM6bh+UyycB/MC+eURQFZDhcPK4IQ44Zya9TkZXNjW+ZVux1HOFFmbx2YXwSP6CcCFxUV+YMZ4te8uwpnYSYV7IFl0kBDQnGEFJyPOAEeFK/Wz7ScR7oVmIVw9v9LVRCNEN+b5kipq8DtlQ1GCAeV7ALwxGYC97AoskBNjMFo8cirzbLmwq/a71oVUypTTz96O/OaH+LybNnZPYJhkINclZ8BYzC8kFHVmDjKS2eDUGkH6T55/J9CCBHeUMgq3HLPRLCDKRWXjpmoCGFA2vSylid4f4V2jY5ieSiu0du6YcG8K/25S1AoQY6uFdVbBkSQrqLzWNUE3fbajnFwTEWaH+N9yNGF3zcPkZdKFnuguzbJA+9cQtmtGw8+L+n9EBGejtpnAHboqBCzy/MVxmveLqpVqI3kPYkNIVWn/gS3PElK8gYhB4udU77S25xqikN9zt47Pmsxl1nvOOAVFKlnk89O+xmjkbG/iwZWhHut1maX0YcTnCYFuZa5rCfKsEyGPAFAMxFLIeAkhUJhsfawmkkFEfiP/rmQxDcCHzwOWFAoyawbQ1DYuwLU7P+q1Y8WU1z6nY/LnCQ2hvNUSS6xcMIfSJMO3/Lx9ivw6X4Jbq8Uh7jb8jz+Nx26LvS+ajSAwL5SBVTw41NRmr9QZgikKEY8UWZ+jv7yzEBLFLk1CQpd0ZoanmNXwNAdHZV9OWAt+UsyETfN+YbCNF5tcgeVmx6GAgURiI9fNRb0/ytUfnsxzsXq8UgOyH9UV6EQUEEUlEbpWe7zFWVVOcr3lVddBY4FWh6RQ5ht1l2IQjzQN3Rog4aFjxpVa0tTu+hQMbhrFc+Ksl+mFl1icFbBkdmWfF73H388W3nfXDIyjfjzz340fL4xqH7HcuGd7303ShOWk9bSqiwTGrlqy9ZEScg0yiRQN+k6FEFrp89vDGDTN47Usez5JBRfRF1ZFnaF/88DRj67CR/lTvXt5qvQMti09kIyqAejfTIWL0qwcbYxBSh5BjpxsatUovwX02UWM19ID5hbXjSinHa+PGX7YChhGENLmAceu6LRPQ5k+pvaGpBuPXs5h9c2pKc77N8CCTY0o52ikEjVqCaJO8hBD+F3xah5p5FxCjLRBEEEfJjjIeS4XKzWdswQL9MVaxakt86mZaMJRRvF4ToOWTO4u8UE3pCGdmwPzxBWu0Ee+takmOAHwUd9t33H8j83/m+Qgjzl719Aln04Bo6o+RaWF9s942v7Faj641JucK+GglRS+9me1ZjFXj4JcDrSPkyP3s4/6x/iIXRkipIVT/qmGWGweYC5s8eqPAEIe9R5e6GyIOuMqnG2VTBPU/tTc/ODBNBMGGjXEPJuX3h1PlXp8an+HQxAD7BaHvCcfCDv2JFWPtEeTCDJWhQACko2jrWIRNBUst4yDtuEsr7aJdYtCJ8Ne0zWTPvps9RkU9PQVHv1cQerF115ZLpKp7T6jYBlpKSAHbcHybGlXvXesDYnUNPutK1hVYmijVgkWDzhlaRvAE7yUvuINKL6wSB44v85PFd0oyxjMCTR94iRGuk2wnDLNtH4g9X/Kkkt63cITcWHLQz6gOQPbenlJtpplHafabPrravj47o+JDq7mWR4Ar8+BfMKzqT1pYVGIHNs0baPMVZHh0DNhqdOmkvtbtzNdgYtPBIRFD+w63tc92PEeDtM7VcbzltOpMvMg03aKTKYPtAmMp5I8GfAukpeJNj8bYWsdesUSWVpxOSCcF8+tYAOeHm55Dw1vpBmTgdH/z1iXBgK1TfqdF7QAruTu3OEPJgKS4RREKuuU210LhIVPib9mmZqgp2x4dWke/MhnogHL7DlYcAVCKaAfUUlRU4m5xX3Fp74nbke/OiLZ/hb6lCeRMq8vvVQ/Wiz9lhvkBGJvi6ppsAf3yDA4QtMiNDyEREFARqfXcY+CU6zXSx+Mmpn4nENre5Zf40E2ZmE8fgrL/aqSp9X8s0MpmNK5NRlztjibp0iqJJef9Bl7N6uPdoDRDJd8dTV846mYGcuHPsoRobxzW5PEshegfN04RIeUVgRDUjPGw7hBUPDEOKfmQdrcZiT0LHWgNiSbrXSCB+eDsneeOWcm11etF+g5fpuWZW6+WAXbLgCHDzjTG+1ecZtBKS4ed+qc/0Gdy5k1jxQtJy3vIyQGq7FOWVbm94CeRneeo6I4njYY/amIItsp2dYDSyj1+hSD3ARu/TERwzXDCR/j5mY57cfsdAJMQI8zPhwsKbgZr62QkStrwpdFbJDydNqlAcD99eiJNSLg9EeV/4yZcHmSIHPymiWSUQWWz/+O2KJSMyUngrIF85Sz4sMy7rk1aIh/tRRvqWVL7V4EM3KG+HJyJS/BuMp5o2Eow+fA1zGtSRcNcHgqwZ3ognbQzJ67Hm1iaYKpOXs3epyL2J9uBZqTaIOWLUkHYEMtcezxMv1WHxaqiKTsniLTk1aCAL4AH7EfMqFhAXLFWrWA/rAfWbJhKAvK2Kh0AVOA18ExgxF8DBTFKfqkj3S7bTZdMGuhkn7EBgNrtM7XXn+LVeaONPtzetkTOStPs69arE2Jj7yzxI0kPXAr8RGikmMG6OUmEFOtV/V9YwcoyyTi9EnrzihmcBYmvqtPcimiMore6NB6YpYoRtFLydkYf3biFpbnceD8N5Ks4t6BovZuis01t6kNTAOHnTFwPmqXU6EA4T81lVWMmPmsMtLIv+0MxYs34lLOnbVNd2jsNoFJKzxsKfyU96M8m6iYmekHnVo0Tupmn8ltLshxwA6mYNXV5wZZ9Xj/4IO2MAD9TUo/OYAuWzL457XncDIoG0jiDgsD01X/2HqMSYSFHaUsfnjFK0O/SU7nLDE0dqQ5ZrL2gra8Wnx2ulz4XAH6RGPtfxzARZC61anQ9AJ6XCzba24KOJ7762xM8gXrq2UNIFDPlGXbtBaNSvzG4YYXP313oRo8TORMQ3M1Po5lGKBMyNa6XRJCg3fFhAnfQEEvO7ke3r5aP1gR3jiMpck2U+0qUEYotx8MslpKmEQtl6n9Rl5vn6JZtm4sIMsj34SBahv8nWp9qD8UDVABZJH5VFCox6AvdgY2VdIRbtRHCGaqt+s9IoO+bHm1RKJ968RxZyfWFRQvBn2zf2SwOr5wOrUv5gK/LEH/J4Z0sJhUiSTsYcIWpMfSZKVBhqt4higpfm1gQpaSYl1ZMEQt9VjFqtyfHEMAzjXvgKXMFeMsvPm9gMVvmVBKb1U9LU3ZW2/TkFxUm6cHulggSZSi6LtZ0xhhYfTaH/cVaWZj/W3g8ZOc+kiJeNOYaQyeEWXSMponxMkMxF9o3Tvs0J67DUuSS5xXe7zWonufPS1QmQ/NUuc5x/1V+w7fpvpgBzZtJzV203zHLJDtnRXghOZvmMIxoKHTyZbrMdVcGg8U9EBaBokU54mmHnbaIZn8mfd5Q8uHPFLR3lbnHmpSBhv+qxHVPK7Gejd4uRzg+lUrVLfUI4vC3XbvHBE+yLxzD82BuV9zCsoCogDqJWO6d1d2YK8sbNh98qmvYGkJ8UMUNxVSZpquzTNsgugmpHtdxO+2iAh6yabHFz35PFZ0Bl1lgPicL1obWMdcGBFcefDOAWsZRC0A0LcbYGieez72JDGhd5k+h5uPWbAWH2QFDKyjIv6lPZSRLr1Erv3MRY191C4msboMP3bo78PxQMc7KUyd7yK0ttu+vjOKzN+TX2LSlSVeJ1A7dZ4T8Ql73oQtDfq5hTNsVoE6qSPfFGiWAMtm33ykhMilNqFSWfHuqZTiminQ/KXr43guYIRUQdwGWz8rFWqmZjgCJW/G0z3BnbfPlfuYcfmAMSU+4sono2wqxqcbP+vLmj3y4UQlf13MCLeaCRig2ZHmi2N6dwmWZwoNsUVlWqBl3AJ/7k60RjlSIezBX4OtM3rlkJpcBbOHJ8Vza5av6VV3yc5gzuYODCX3vcrv5ypo8udVVH+1tPzm4+W9I3/Na29t9Ums+t3mjVdqrS8p/kL1ngihaq4H23sda9wXqJuhGcjapF6MDVHT+J3yfEjT669lAY7wk6rzcz7ODwpyGm7ufPVjj/QZMK8Df3CpOyfqLwuEyxDVxttHjS5rbeeNnqRdPu6d2Ex2Ot/39Jk4UtI3FYM6c6IlwboaC+ROcBRcA2jSjQ60ggV+gWIbiGaDl49d9u+mdN3qxSwrCHhQrYhaYpu+swNjFsbuvGvJoFNZP/QxJUygHFC29QfCcchyuy39gjuWdbhRyaVZphy5fFYqKwmeBmxgqPFDqDTlyuYiQ0hft3VblWuoqWz4vzuQ072HzNW3n/vabPWAquC5FsslBXH6SdbN5GkNnp/1qRn2DIPupdgsO7OfQ8pQJhORX9bB/bLrKqbu97Yn7LG2CkdrSw6cjfbNW030yyT/cJs7kVMVLUOqSsfujCa2VxBVr1z+Xl8K758Vbk/wp7b6AsstE4aQOhmD+c+ULSfpWwt7a+QjfN8W1Hry0qB7IO/K6p4aAcAotF0re1j7hjjvQzRLOZFZh8VKXWIqNSilGQfh9L2Ld3Vzq42LdrttjyY25nQZq1P2FEKI7khGha56hg+Hb+tzNmDOcX+4VE8SW23EIbjfGaamv3KBh+qoXWCjjedogu5X4zKjKTxJl0cs+ldW79ooPU0wcutaM4ktUk+iDaulmjsg3Uy/y1SPb2yFqUyd5LTkkn0n72vEDtxsjfeFZK3VjhM/24yeiKP3rPHTJPNdo8832kLYyhCAu7xa1mhrb9J/A+btD3ySWhSz/4CwcIX215XSbcDSxkx+rXXCsF06GQQ7411Yw3FctD8UDipiWRxEVQKvy2OQyPQHPOUW1lvDikgrJqsSSqVUitRCFD0QppZmRt/EcSxPm1N+hBt8cQrdCptQhndAtjxnr+SCupCoDPOBszeFcVoTgN1+zIV6iguAt6+gkqFW5pjRaGcO4WfM6rFYfrjxgkpJUbLrb43YMUYqk6LlD1E2Fptg+RyLhAWM/sjZAtLK6MHlfL4ODL6KC8UCEukhnoIvy4xw7r5+qRv4pY2F+D+F80awXquWADYtvGE8kCIqJo7vvKgYTPwyVppO8+CIeIKKm44eG7zxTEltNdRFpc1ZcaxdhJLcEXwaNV2wPPn9R9yuzhuIScLOnUpzDPVrlOLFv68YK15iam0EireQV4sAuoaTDLxjuolaE4JiyBG+w3Usl6M3IKJc2E/poceJwfUoDXKIHwVMZwAYwOxfQFBxjDT5HgRuh7C2dMejr/bF1Hbkpwtk3KXpJZ4d2gUFRjcVmdkRKhRe6nCZGTNqRjT1PCNH+FUSBmYOaXbwDWhaOrra/bSN6Ctvu6Y+RZK1qTjwFV8MapMjxL/jRnzal6+hzTEYUYRnY3WLi9shQUUncbWJ7FZaNqkfrfuQfY2beweL1+rLHKekylQ1eoX79OeJdoExgNBEFZ86wcK2zwTcG2eDr5SDPj8PzLaRgi01UPsLym1UklJuxYB5SsiIwD1cr59fKHZjvUrYjcIwXY40SsyH4EomHVq0VWwFKqvV/YPmMlGLgopsrsaYhqVElFZ+cF42kOb5ESb7QEXJj4IIY9Pp+GQMW4UdXSh9QXdoIKQkf5BtgBnuDy48khNBhwI6dr9seKo5Y7weFiwU7K3Mk6MD3R2z4OwU9/vnMA8Zt3dipAyKgL22QHpyv8QiH45DCBTBKvvUx2cXlkAKf3eV8LmOCcY/xB5dfDsP2L/K3LzDje31XtPEgrp9wZBwJ1iVCAkHUP31PIjUJdxAM07RTKe/TrgadNtmxPT+haTCAdl3mdmJk9NAmYTbTRECmhZRTzgudQGnTd+/m8Cdv8Qv8jQckFj3Mh9rgOKo+7qIxPU/Qzb/VEFlSaNxQ38wS1OMMRH4xz51LqcCquSPQ9DmQ7cnAwyZzeljZvFPWz95Fb9SH4HzeZxQO1efkIi1P5bOj2wmUKnx8pWCzJem3dUJyMgHWNRzisy+qLJ/hPgZ1O9tVGZlsUkmvgiMHuiLe51sFOWs+aAhCsnRlrAdXp3Vd9pxAX8jZwNRgF+aXXgIW4SLxUQqUfej0/9K0OLXWHc0phviatOudnYe8Plaz7ZlOKI5WyuHVdYuhP1u0GUbq81+u6XMWPfvqBGf6JU+fO18xXveM5xG9d1v49np+4qGafE5M5zDpmTjuo6h0yrinpEFjVy7bFJ83AiQ/TVqQgRySewL9zZqQXW3MewMWDxiIVdtzA4JwiEGjEOy5V6fUquWuzanBkLb89+LaHwTDqhA1W4XHQH6mOCPtPFa3nSsdiCiQvbc69LWMtgvfmPklashNQDNJ3vrV/e1F81weLQfKTT59KcR3REWKWlhKuC3B6EV1JgzJopXylO7q+OeIW0fJjrTKt2atlMuPBnibDOWJ88a+PChwv2sJzSBXe4s7MFwLpCVA9x4zFW41LJNLr9UwYCslNS5Vnt1yMB00acuxcIZ1vi5RCCToQIHzCr+HUdem5B7vZYnlt7kW3y3+jPb8eauZ2kAIR/X0n9/OphDrYVNJHURrJP+A0D1WslV+xCdsHA/tjd+JF+SlJJTw2nLr6ZGiuGcdS4qTR54zKxL/6Fohrx+GujN+LVGpel3TUfjSRJrLvdT+vmY3gnpOxsH2qDm4nkcyPa3WJ4Rmlhs8pc7vOKZ6+FWDh3kjHh6R8T8M06clfVm5GsNSoVePhuGiQTgSt3OZL8bEfI97huRI9apBAX+O9LtPx/j7MjanbjY4nxltfeirxaeNXX62L7D/+3Y1UF/v+XTWd8Ew8IcE33hop+BVsQwmAkNZ/NBwoGAJTQKel8P9y+wdx0AFMIleMaYIbgjg2RRc0ENnVrb3zmnGGB8RhxjAA85PXyZBI4Tb0G8eNU9q8C9h9X7TqyofR8mrYUPOSXINUwOfE4WbLqvCgfjGYd6V6RaWJVbCrRCBkCRXdrCgRH92G64tCSsrd0gQ5ip7Q8IgLUNXiB/yk0vq3LsqZ47iP1rX/CawVXbGnn0U7uLxYk14T8MxkpJUB7MTqOrjk8fQ99M+Pz7ysNQZ9yOzfWufzRoO/lCxvwzS0Mb8gouxLnCfdD05GWWlfsic2wNglaUeG/Cny4SgN5w9nGqG7Pi7MGBYxbrZISkEHdEqrgCR8rSAA6lL4RWBbVxPeVZEwi8oVd506vBnXPYwbnk1GW6OzE3D5uoeIlqgcOM7pGzxnn4W7kTTRhqZBUCYnALbZDxW7hj7tsnUJfXvUol+b1B2Qcq7S3KJRVNBIwv1rJnBylL+/StS8qFbhFNjH4+R/S3M+o5V4bPzMD700ENN9ENnQAT7ZvP9Cs4Fm5HdPtpFhsWOP69GvztfwFqDZICc8ZSiLRhMAvnLM4ejHElGJpIEA33D9ehLCp7hJfA1A1+bkjG2IU1z4B3pF0IWCYoBlgdKe5/StLpUrplE1+a5rvTUPMQ6O0vt8T5rEjfmaK9zMo4zLDQpnq87L5kWLfLvuOil0c93n6pqTTYnJRWyn8otz/goD8Qs3Uo0kVroRUTLf4n/dyQiyK4zZ1T4b3csG1S9Odw6DbiBLFzeB0szjZat7gIS2cAjTbD659q+CZzzyhkO+Kfr+3SGzlomJxDp4jmIQg3AiX5IlYs/5cuEjhhU3EtKCUdBfBMs9aoL6jKugLZWc9bPQ9egh/UI4vpydJuB9mjl+5E8DFEo+S+YIGRe20GchkM9m09hAl4o+peQ8ywnw9/54QIZQbYaC+1PudvpKAOxo5mkv8Qd5J2uGOlp2EhCmc9+GjowV9hzWS7cTpejNVplz3SKX3cte7ZwZjjZLvFXdTyHPd+X5Dy4I3cdG7aLkM68i4vdMsOIYsbRFwFOjHDILWK8QYBzLsZrb4tlemkF2mG4JQGyPvIMrzwwatOd24IBZ34q9hFP0W6Je5oCn1gXjm1Z4NQRoQUJe3dA6SeF1CtwdtwCLVUpHjMEm26NO1E4K9m/E6FkZrm+eamKQRo1R7wJlt3rN4v4ecBvKz0uUIqsAftCck0JGPB4qYoGxn3/aF0NBcnGL5XOyKwE7CihIOYP6jb6ZRjgnwY/HJc00hKHHYt7X1F96rVVg8aVRF78tCLgRm6uGaX0GPD4gQk+q/1IBX1PE6eXV9ZLOJ2QQHf9u35DcVm75hX3+fT5dtHuZjot0guk3nH1LAc6Y3F5EFstH7L53lWyznFVv1jmOMkW9HLQdYUWXyg4zuoIGQrihiVLCM+0GoO8CEBk/P/6+KcWGx/HRf/Mn2W0B+05zcQKZOVJpPvU7BdnRt1cV1fVcDSMD8AvFEAlmX47IBIdSo3BeECbkdx7cLnk3mNzPk74lfXmFdd2PY+EhNNIke1SBp4mGftbOwnPkYIsbIqvoubRSC2Q0ASlEIcDudkUuVbKP4jNai8etXPyhYhlz2DBSszZ+Gi/IRj5fG+pQjo1lWEtikZVNUktZmMnWPfuQoPhlrIPaOjUwBIQsZYsqeTHlu4kLK41xduSP38MLZqleVvhKmAwbKHViYlJH0qBMHDAB3hwUBwnvQ8t+Otiy+vVGhoel1UmHE1iwi8M2OOwugfX1UcPqGVth8cNOU9eUJoQjjra+cIGZ3KRQfw172jWp1//TNtHkNsSUzt72Qi0L4TqwGq6Jl+7Py5CznadH+2qXPKJSqfPxVST8rgOcoS7I1JUMmUDBKwTE7xd1Pu8BH/Z92tRMJckZ80yPVe9F9RKGWkeOS1KB4uC7s29Ee+GwZsiTUymBTyf0n0iBsjGvom64NNNbilfgLqKU/22nDmIU+uuQQqssIoLtK/Ccxzn8fIVqDPZRkutQv3b98IbKRNL5b98agT7cYGSO6wOmkpNP5teG4a/PpKY+43c0Pr0j6Vu2g4zZW4E0PrUAimCeuElAQYhjysFFgjEinOewLrjyqcfVVxwiB5Zdi9SpXaIBgnmYo3hEfaXUMoNPAlziPjQDbRG1ISuNTsFPVhKGTHgTC/bWnnuSo4Ibr/HlbVnb9DF1cTyzuRthKO2lU/11fq2fPjPr/JrGsgDoGQImiIzeXFUz80dlmXzpEqozRdcUBJMep2T0i4bDEc6r5ww+zMKzEK0BXpbN5h8nZnWhfmG/0pTcAi0C55YfD9//PHz/uDN6GZzvU3JdR/fN4VC4f8luEk4GEGEzoUavorknTpSOLHU2bC4FTVK/gp0NsD9rj249m2shWz/f5p/SeOSL90+EmHwSpBJ96NQ3+m2KEUZRKKPs9llECfKdddcSJfc6eZPFqtijlBaGEEp7YMgTlgl1W6qhCnp73epLNXvptxYqZIiVcOOkNDR/RkDai4nJcNuoZPuFOIVSStKEQKXV3lflMxbV6PC8S3ZoO8oBXNMcQEJC2TttKTnGT190ERuR/3wB/yJ5j+vIGYpW/5V4Y/mGU4k0Etb5X59fduv986aG2y/EuiqC0RdDUx7wc2RpEaMqaTlsOgg3yHbkHKxqRBc07cpL2X5eNlvQJ2W99aQ3ugSX4rsyM2fhwvOvpAoH9lszmfxs4xnMr948aOZSjjytOSWWW6yfGCYt0Fix7jt++rIe11Po1D+ALQ8EN6W/vq00mUqu29IzBJGiPCMZYDUJmB4p8qhq95c4eEWNYXTOq28U1WOA2LNMAov1ychMr+VYkKLzZAzKghtSeYMqgqCWET6QZWpvjeCXQUorFLL9tJfIaRl6ztwYpxUKYf8DmGatkaYBz+HAtwfD4vl8v7ZFOQPRqtPh65UUQbYtkJmIgYTDz/CsDTW4p//a2gnwiQl0UnM8bxb2xD0sybOgY0N4d/mheES9xWtvfnLYFCa151gQoRuHscbKkIRMmdl9g5N4wPTzacQpRK8OjBelI4TUEmR3+SKp0DCBaQpKmsF21vauORfjkEUlaT7nY7AZi+IAjMTz/PaZIu3CecKv7ArrgSCCX/4gE2QHDAFCcM2E1NSFk5KjY0Euopxqb+U7cuEpkFfwpRfpc4ZgPhjU36/OYBgRDgWL75gS5lAaIz0dzir4HEpWEejbTT7P8JLvqc6h9z6SblETVkLTvNY27a6jw9PgIquxN7TJibSGbTLQSJTDKVLONE4B1BWCvAy+OnXdqIHUBddy+7qmhRY+5gkIGHRnFMaFjTb4WTtazHk5C4cq0V0y62ckzlZxkllcBUygaPdo0bIcGtw1/SVEt7mL8BulZ2vsSVwg7CRf04g5GFbhlJXd8ijKVpwnEHZuNl9cGzlP6Kb6AebCbS+GigBNPL+PWDzVCnyVaxas72xcnBUjgGDYAvCcraL8pcgEIlnCwEiVuji6HoXNuwht2Bkj5ZHaqEMZWyzcYQHIKattHTM/tfa/DRiP3sqMRpw67A8/ZY/0WsCUlqi1j83EeIVGAmv87brp2FR8gZHzeTigkHV73Gh/6FV8Kus700ENDGgfZt8iVqcuYfKx8SiZwTf5bc/DG9KJxDN2wlbfQqmIz3/Qup4x9enulPiHfpTF25a0Jo2k54v/TfW9ejs1UiuST/t5WvBQXnhGEHNYHeB3X6J4XIwxY/Vhl2WtzDpPJhOzj4P6EM8KB6kdd+6o5TARcx9iDlGsNDTc6OzJezrMlrpyWZHA/n3KEZj1Bfb7ZP+/K3UatFf1StABe2lY/D64CXtJk/Gs9OvyR5s02fIWJpxE2BG12vHXBZP7WWA4qIh1R2SQhD1oW4cQCw34ixaXNQiYzl8W/RBi5gK60z2Tvl/WO9ATpt4S1tnO4+IGtTzqgI8KXFfI4kYJDP/VbtpT/Ds59G2sErl3byS9ZEpcmm8wEOm0nRGw/+RIgthzGAyKMfZMv/lM5Qncd7iM4YZZpo/xY9DwDVHo9i9j1YXqur3AgpabN1dI5dQqlPK/VQ0tgK2ebETbuSEz0ZnLecyRuav0ICjaRg76/tYaNNDN9UvbrkRuXdb/my345WMjNkdTz7TqhLTb+y0Im2I6ABZCqHuVutMUEpGkr8s+06i1LLyWNR+S0WLUxKgO/eFW/fhUBCny6XzPzzJR3Hg2bp+U1TAX4SB/xh4hqL6H1WEo4BmPifY0R7iVivIT2fUd9PXwMGRDLhiMVCIYF2x9iZ5yoxtlB2oEdn6ZUXdyhPKfHI6jmHzSk4gzpBqgK4XfnEFmtUwKs/AuBjYDjJpqB8qmaWtjXik3CIQ2ImlB6Zq2UgDAnVkaeD3WxELCcVckZHLdE8h5eu5SZzQ7pSFyrIv5Kg7UxRoYAs9SqZkbS2K0kC/mshflGC4AcwmOTWyDpmGcSOLNs3HQPaoiGLC43NH8i43hApRfKv6g85QkZUoUjUuDOBs0Z0G6a/GyAOGO2DoRXNi/A0gcfpJNLnMwY3JGFXx/rG1hdb6/5Bpm6LbV97PpMiNcdVIEAPXOtwCJTB1NtjIvzTq+kT2GBTnBIWzGR3XdQCXcG3t5OTiDJyHG6oPy8pNg8qQ4/318m9SDAdLgJds7JJ9VHGVx7yZqet7T1HxpxY8QT5QV1PmHNeo9DLiaTQQFiNP5K3BkFgpz2xs24cdQgofKCpL2c7bWSvJ5D/SIBFMcDU+HgE+iF0XF2oQyct9bm7DmYhgoCRKc9A8meBGyLknO7/vTZosgv9HLCtFYfLFeLkvo1vRwzz3gpnLpVMyZe+zKf1kR16xCCJ56sHu8PZRLCIha1DCLjsMlbrTO3kNw/6uYgDfjvvYGb7P75pGG8JpJ0ggXC6Ghjqs3q7moTxy6yK5nyjMNHmgAoPObLTcakZIuGqiPfeUxefj4xWLrfAPmhA1OTm5oNrRYAbv8Ldco3E98WY8hizyOs2EkqBCTTnSxrYPdfny+gpwuib+1CVnB+s55i1yOlm7imQ6VMdmrNcHdkLAIWh3VYx7aQms9YVngo83UACQgGFz4EcLii+e/8VUkwgpsJSahk7NXgN0Ip9W/ebY+H7eTWV6xuy0gZaYn+wxLyGkU8QTSHEP/O94PIISoe4OR4FdCFew+NJ4K4tshLnySDZSuJVahK+XZJG994bJZcZOtmCNZVoZso9erzXTRR7VV5tHz5IkK25Le6tKzLPxTSZJrRyj/MTAf/UDqVH7Pt5P8HuUPoIJc5HuEl0uWthnKeBLWPUiB16VJ5a7adkVU4KXn+CdVWTtarKav6a28szFLhLLbTuZvvgkDyk984/MYpveqz/8TmHtzKU7Xol6FvpydfLd4XW0M8wROgNELBnQKVKwhRrl0nNeVwFKHIw+3jRb/oXisbmSjR3oo2zgldfLGo+vL+3+Wpe+qT7rAFUdqhVZHBTvzqXZ3PgAJ5fbhswY8H2Z/FN8En4Mk4U34NRTWfxAMhbnBnlZneF7H3ONUfV8TZST3ByqXJZzTl50rNxd/5CeSQ5Z6P8Vg1QajVspx92EeoW1nkm0xIKq54YtCItmGpVxVWq2r8/UyaWfu4TjKoBBYvAg7JTzaLsI/FJxubKRzdmivP2zIF5iJ+CBtu8ot7qdWRS/qBl411GFVzlywMqOQbz2/Huz3kHO31o5cnNWcrQzxJ+P+qc7TanaaBy+Ry8qQoyMhvW2yUHkiTDhX9aK3jCFTxGJesK+iaRcyQZ+r5xNsHVMCHgRGJRn7jOHjzG8dIeHzH8OxP0g6NXD3pU5EeTGKK1pvKXsAEKr7PJxhzx7iQw0KXRBcaudySRnLAwWasLkAQytsJZiAgqg2AE9iR6a7B7W8iCu6y6kN+Vh1W8GWbT7iapE6PDA3d+Z9C2dxhdD3MsboOnokMl7/cTdonZqUFoHuQhOKGbi5Dkqdbrp561DmW8VoVHoNHotYKy7OvtXdZN37t7q7kMek0wa8HftbXRMskkAD/ZraxnktrGnRs6iUwizqPH1voMtDfH2NZBgmkNMFNXFQxKYPJwCTA3hwy3pJCtSnB1dkmiSvPcUmw47I1MnTVKJw3t6VMXUE5OPzrj9nzOoZphsX+CB2Dx2wZ6x4zMU7J8ghuzuhrp5Gn6/O0QkXrPxZGzmrRIWXqGMrNsWVpg+C9L/pf33+JxLScxDDz6boc4tR5Z3GpHRoXmGSvc9VTgjXv81AEZ0+N/QfRrIz4xaNhlXXVPifOg9VgQ9r7S0TOE803dd/pRhkQqQWBwDJFKUsu7IJqSgr2g6PUxk4Nd/L2Ni3xItHeghC7/tGtZYreZl6i1WRVgEl4YUFPVRxtF1hdWcfzq+DclHEXfbkBeHOlxrZKUE74HjDR93AnRqM5t65N66OQQ8iUgnNwXU1yLUYHcxEtxaslKJoHT4hXUfbMcTs5SgRO0KF+U7KhhFMrEos2k0dVj0mQWGoClj80x587XSK8Puof8HJwi/TZ8vtD1vtmcPUDVnoYbemwDEK6Ry6fY5yOqKxvWzHC6mn/i+JTXxHu+RA0O1qL+ZYmr0vqAsLRZC43AxoHicKbPQWHqgfgWdYlmUeVmqSdIUk/w7Uh7+CA+tB4lAIUILDC3AQSPEToY1PpPxskoFgXNI6sTp8UFAJ2pAtjzoD8zKGc3kg9IfBeUInTDtkdqnSg01Nywcu6QjWjcwSWre5QYc0ctwJRhRK2n/CnqJjpluSFc4qu2Eu+GJZaoHjqiiGsfp+xAtXU90nq/ebFX2eBC0zWZ+KT3PC5LqSB/nsPyMBkTmN+LbT7YHtMI+VGj8fzDQXMTvTzkDTlBaJTHh2YyNA2Et4i4dtkv+pe0KuAG+BBS0h/P0IaCRHOgis5+8g4TSf/g/Ney1ZXGqVo6Tby9MvdAQ0e1g0dtiEBST2Pa/IQhq4ZiMCFtETibC+yGhZtt1b3R/Wu2IE39jhgAqjwxpvOSvNWmce0zA4SMkFoleO4cy0sp5NUNT4lyz+sc+3sgYQ7jboh/bkyoDz84MsyadteXZYrM9QIyk5qQtXPRcTn09ytPmJFKP1M0ZtqosHEHsoQEPj4HpGyxpTj96Npo/91AKtJ+aINh8SupOzuULze55Y/n5QI/a0ftu4161VC27z2HHDFrkWvJcrZeHg0/3JBsbwuxFldNHGd+lZN0JlKDEcV9GO7RxGpmyvF7aw+02a3Ulhd/d2j/VkLknwliQe9wg2pV0WEHVUScrtYQfY6npEtOyZZ/R13hLe/+tEH98UpewfwEmnhuF53B9UtAEvcxL+l5eV9OdfdpBm39CPcM9+eWiqN3yn7Koqt7JkBQw+ax7ijQSm1DaHgtopfZlleSIO1IHgzHeA3mQbB7fyFZsnqRnDP/VOMb+mH9PSbj4ALHfhOcxz5Vr/rrDtCEoG1D75uYWwm0mRpHdQgCKJpVy6zRNwpvHq1jbzu0nkgW3PNrCtheH22ai8h+to4uwtvIcRNsA/RSmLhvL8Ne2AHE95qbJQ6/Jcrk+Tdm71DX8xjggAvdi786SjX07Xhsy1LskHmY8bcXMoI7KDnnx5AW7kEBw1/3uGRag+oCw55A75FT4Vc16H+upg3JlHpkbCL8pfB4uA522aJknOBpGirB99FP3uv3Tz/tvrU52/nPnVNNp40YYMLAga00qx+3D8pTCi1kUciO1lo8pVZtjjPiMrwg4g2o6HjtgxfEikL/C2kynu9IlTK1B6XCvfmJUrUxYboGyCCrXOZikjW8UfRk+cJJYjCKAJRvBHnRTf0enULBnSStOCQpViS1fiLDSBw1X49NRyOpg2Y79awIx6TXsgRXX1Bhzmkfgpn1qb3DEbPzraLFlm5jms/8Dwer4etYP57Uty7o/DJWv3c4TxKoZ+2kI4yvs/SMuRbosdSe7l7ZtIJUe9Pu2blA4tFjHxtUl/KO//0GeXnN/cqNE7aZRxFGGlumBPD0NngQXTS/xULygsoMYJHNalC27fk9zDPDs+mJprEynh96RPp3pKpdNyeFXBs7rjNTxhn+r+Szb6q1lLk1SllSg01maf/X/+ysQlHZZzf3DguFOZzxmScrTpHf7zsUTRq7eK1xAfc93BkbS7pxjxRrUZ3HROKCc4fqFyF9+IFV7Y2yV9NYBPPhGA5Q51nLzC1f4ANIfD9C6Q4sKUvVEq3NaqoprNBTTeDfvTLZWq3r6jSXOeuUVUUbgYhZ2pavcsSnrNL+L73PTehwswFTjzT4FnaXuAWH68IwgiOKDEBh7REYGMGfXLR+uRn/eTwpGAg10cqOfsGXWrPZL6OCN3K+FC62/iWcyjXu/z8CpKZ/QkhuGHbn7rW1s9Bn7X4z0F9rFYKf//hDxwcW4IoV8EPX1ceijViNaf2b2GnR9gw6ICTIx5UHlNYNP2UBJa7d+yOyDL3H/ltRdNaIuceQ4zd0B0i+eakSgVBdnDBnTLUSiHts55Ba1Yt1vTBVYGFGyfm5Nwnohe9vA5jGde3snlS4cuSnORp2Q2mTrccxNimazqK7jPAw7INhYtpdeg3Ip6BTTiJXrXDj1uaX6ov0ypxGnijAMtFK/w/w3geO5vO7yrfy0ywvm3jNU8VxjUg2kRlkPfakSMDTAktTlU9zS4J6hmTuuAxay7Uehpb2ArsWttsBXi6PfaiZ25UqWOk/Sfk5W/po6BZu7/vkFJvQAbJ8+lsRT1g2Urq9qcauP517BWwFe7iWJNhexH0qF5CiO+re4ZRJL22KCHRp4mDvH7qYh/Mb8GU1yNILiGuFp9MHtjSAXtr8ICBzbsM0iAWWE1XNdpQ7JF8vMHQoL3MHtjH9SGwedp4LfidSKSNRuoy49gp2XU8lpsiuIvkR67SuyONGuqJYTH3uvd2hiEdbfPxLQMIYb2scxuL3x5485Kf5Jdy9zOD3JXLpIBGorexzaEu0HNQWbqhHdaWfzw2L0iqrVoxtLG9JftESM9wX7E0nJJ/YoC93C9vapBu/eK79aqRHJfp+oCrcHUSEhUTfGSy1JrSUuFm7Fyo7EyZrO9kYANxnjm6R0e+9cSSBtijdGcETTzw3buWrlzZ4p/uHX/+KdpU/CmsNS9xBJzlL4ubSW7kIhn2d/dN7b8GtTm/qb+p6U7vcPTuhx+mWgTy5CvA5R7pz691rxAFWzgJvrBBBskam/mxHDlSu6KNCkpmMzBDBkTz061FfTjStSkQMc2y/WRfgm/piXHRYBnNjyN6sFdR1+vVeWXBxZLCs2VPZobQNzMoPRlk5gC0gySKgGmRveUdUIWdeKsO2tCH6rMkeoiazIJ7yTlqBk6OL9tL6FGFolwgdi0eJWqbmeK0HFUfTBp+J946fLKB3PbfPDKC9tsNTiaPcvwwB93LYjpE7/PRxOYV3ogQrRO9+h66G0ZCDcJmwH7ayevEKM+jQTdJLM/dnDsugteDiK3sEo2jkD35No67eXGz84W2yiA09vh7NaBJgin31S2ctmR/fIIoxblyZ8F+aRKTBYG70f+rHv8YBSmzQn4nCU25zyF4L7SNzQsBzdmz6yMxlyBJv+yBWRmLm9YHvi0Yushv3UzbJHyJaDf9xAb3JIQM7xvcRXbq1zuwqQgNG7rwSAHiScPYqZY8nvEzNM9W6asNb+mH/mzHV8U3PXaMGP9ttEgB7pNfLcl8e9BqmgGC/tFNQKGEXvP27rIJ35QZzknuPBMKpC+4Ws4cgYH9gjPTAEhMwNONRHcxC9LY/q5IRwI334Dw6w0BW75/CAkQMdpuZnUlPe6tlXYEYVUxxoBgi38djXt34llxfS5B7GuuKVsNbSFIwis6KR/dQa8d9Qb9rV22adsC2loL3BZA5VYALG+ciEYAXzgvIGCwEGp8sMQ9X5v7e7Q4GkZl+KHaan4t7vAxdA4W7iD/5ohQ/eMyPZZR0YHVDPHxLZjGK28TV5zhYd16+StkoTtRpjMc1MflhhkWqfQ71cU+ZbFMPv5+u8FYZHiSxR5Y7eVnObU+OMk301pc1bZPSXEdXFcrMzebbnZ/YCLD5lFNFCbjOlSd29JBk/cPpUCKW9j2+PRRw9ka2tyMw6HULln65U2LFe3/vDHqns0fy9xYGZLVC0H7/jOqye3ni/Fy0cwJsxiLmhLJlxe32TAW9tCBeUHlAsyYuSpPpUWfOmWVlGABdToZKr/C6SAVrYQM610TT3xf+QaeU/x4wBapTZ9ucUhlOg+tHJgGljw9Yks8BYMkCDTm8e7lvevCRibVkFuvcfBb5r7VP7v4ZcGl/kigkPH1HlVji928sy489UdsSNO1uYxtykAEG1Iss/nIVWXJQMkekUfia0vmTW3evwoZkLuSvqKp+zQCZHybbXF6IW2m0EbE8TzOv47IXz+iiQVN6pgsy/YljZUtuHSJZp9xWPItCzOUFivt2ty5NXH3ZEiXz99A3/IcUk+yEujtGerAAO5fJWsgueQbNdm8PSwaVZyoGS0SPZbfk1CSeETOTt4/0D6UcX0jqUbT9Ubo9txYFTTP23rZQTFm3pGWwQD9NZKEcMXJLFGlblaj0Gdi59j4eXIVj4yWeyhIDGMULlFiFIty23wdm1C2GEpEgHFMiEzMt1Q5mEIIe4vTN/jsbP10z8ePGad83WC8n7PNRfv5vdT8FrzSb9SttENcXFLfe/G3v2dw2WEOyPo3xjkz8su5K510GcdQbSDLBuXPxCv0hajMEXN2QnOCJQ4tHbuFtTW3/Y32y/GqT256//YcM//8j3wA7nSvy7qxHw1AD0Y6Rf396eYUbIkK5oRWRB1bevY/w6hrQ4inPXe+UzI9s/zHE+HsD3h2rt+JIRWXTLH3XSGwy49ly4v9sjfgKrX2LQdQ+VKVBkWMyWypAhIGQHltU6zTFFN84rFRpZl5Xz+PLPZvrgC8qKdlkw/LPsEvkFvTo5TC1jN2D4vZe+1JbDccPq9K6pxQOHEII54SSbfRUljlIxVTh1WO3zVo9yAuGJDFgwB9hqj2UhzwAbhmpnAkXFYfOFsRpYGawZeos/U60m1ZTVCeUlNJuPRWuaJUgw9Sjl5vmdIKtvPAOqjqPUA5j8pInvjkGgVdcYim7AIH/Kvw2XQIA32eOiZhfhQqlVXClfiesJm8oANd4tiXqcfuLcq/VzVWtngTb/3tIh+qbQU8CI0np5fm2kUn6UdGb7yOp43tflxRYry5qawe0uN3+KnsgiZMjJ2S6Cd5qzrqQSpsCy9nhFg5FVbjVEOKsCSQFnrWqf4dREQr3kVIBzJb1HFTlsUeRjTuRpwLzFUQ8mJWTJF4++jO0mEhwOXwvthNceRc4y3JA/6AiiFIJga452nYPVQBaTc0xLl1VihQlVdMbw/3h87ZdOHITLh7zhK0OlHO0vnvoKObDMWcI/PqDeZONzT4kD84IlvoMk0XW9UgGE5ticuIVUdud0O6wCbK31fAdcFPdT/AC98EsUKdKWYfq2ygsOu38Lh7x86b/35bglQURfn7gyqIrGpofq1Z3Lq6QdZ9u0LY8qkNeUhK2iK1HeCjEikeReA4ZbSVvHyZULLHmrd3dT1UpcM8jM4c9IRRudLOgLVswg77hn60mM8BT5uKyAApIQlPLo2aczjxM761Kfl9rDhTs3MXwEwdY4b644iqnx29gveeudWg3L8HslsIbf4AFM2t5da6dXB8mTmkg1KEIF2G3I/sMyOl4CO9C9cBhihUGekafIcV5wdYeNWk8b4ENFp1Y7k5p0Kg24Czra2DeSRElPCwPvguzGEXycY23ZjJD59KYL6WZAJK+s3zg6dqZt92AgEH/QdffKkDOpMCJ3jNLNktf9Nb9sH/5knElux46V5D9/EVfvuJ0E7MRDKiYp91qZzpQirkIhrnLNdy7Oo6lLr5vHLFbz1ZU2+k7F9QZ33JqA/oYtgYNZjKhr+FXiBBONLzWRJMv0MeB7lRFywcIMWBT3d/XzGwen26/+XyxUNj8V/xUqFcvL+5rP7smzmnTDoxAPLaOcl5EMGrn5tIOgif2QISrMdKgToUIXAdgXmf/fflO6AP8adTpjvwEWmqJ9N2WqeqYYQBsS7px066Quzkt/ZSUMckSnsVUoLRXDEHrkC2833TOP+0umCqTtyYNE5QYagEInrHGm7RjSYAQ421M/z1EwQdkmfOZQbBq4kvuN4JUKo2bD0efcg8CLK9LRTVY8ecnU3d6JpkwdlZwHVgy48Q3x15oyHRfEMe2L7SxSQDHeADsINxphTC1FN/gtAyxl4yXnrdxUiJ+cXgmW8nReWpk0iF3aHtPHHhYTxykpGdw4uI2WovtLDvoxqet4XzXwfEM1/7GOWe9sy+LelJXDgoofWiwXoCiWWFEzw2HTnLHQCnh396Nvtm++mAxLbMtbfGS3iSeQbhrN1xeDdpUc9TowNyI63aX3vudGPSId9hyA8Ni5qdTxMcLKpLIjKHyTAJ94P3tbQJWWeKt/41JJ3ur2AUMddT49O9M9wrml7Uutb6SaM10nZPVnerG+LEFagq6wq/2P8QP2js1kqDw13a1C6ykV2OAH7RQcLb5uh757yf4HEvtQVK/BmXI48iUaUojvX9M/KBbXOcDQrUuQqvqSEdxXOXDJHmW3HAs3yBcp4gDKXdAmhSq6kYo3yER5Z+lqfh3fLkKt1UFEPzlF7aQ3CoXe3+xM7P2NGWkB48os+P87eg2j9xi0TflQvn/Z4aeHI21MOwD66k1kLRjWQO7ud+fCeatrmb5ymnefGAoH8Sm2OD6aX2AK+zQQMiKmTc41HUcLXSqJyhCyouQdUoAFxkYD7Y8D/fNFaH3fGWtGVZpfhqlIehr0+UiGWTylpECpXkf3+yD9Pitn/ciMur2C+rThFIT7lJeYBZ1Aq3QWM2574L4B8xBXnmSlYuAdi18YAVaLRJi9U8QmF/V6B+cQS7IlF9doNqYjmgCWnK0lV2l9aNLoIWxblY1Iaq0dm6u0HzAkfO7Deu4Xel5iKT0fHl7hsaayi6nRz6zupIqnrkO/Bq2QW3NQsQTt6hhM7SKL7J3ROUM2dsjsrZ41lwlv+I6tkDJamq0o0BOGWVcWWMqeQhl56ZSULEKyI/a6MuP4uqAuzUsz5Oqy4PNNQ1S9VQIhpkCOP7TznjLS7AJ+Sznk9KyoWo92qwR+d+AC7c1vKYKN2ZtSfFX/QHVmTAb4XlFSG0kakOD+TqMXcGzqyQhEE75OknoEM/tq4bG65An0Hc1pnwB316a3q50j0fOsUB4SH4L01wToHFwKYWGfgSaC/AG6KvUFz8dRkazdFFZ08ThMefaE7R+qoVa2OgqZ7IQoVPIh3s3B3JL9LvVMSZbIxaPg+bksb+TwBBk3xcV7oSZjH/vdq7gkqtl9h9JiaLF0zNU6zlVd9AKTVWMGUEy+N/RnjJPEYH3/WyeboTR4Q8HBwXUUjxtNO05PzopoXYjiNw6jVKOln08dy0k6Lrpi9TqQGgGrW4M7Pl/Gg49KwRWnoZx7+GOGgbjY8qRQETdno4bjTPRxzaLN1Ww0kHP8pWaUVn1H/MA+bOxi5+MphYwaNHEvTBJErUBSIACE1DREHvQp6jxIhDPyyMYbhlKKWTa2UlUeAtY97GLNb+h5Xs3UTvW8pdoWxNJzzjh9ZEiBWDiAokoTsZVGQHIGmo1JWc5ZStLls17rfMHP1n4Oh9AyD9lvW8VcrKq7kVGdPAiGWLWHurTfA0FF55HG/hFjqN8sK1VhIT42K0s7u9uYZ7a53+teeV82nYXSpwQFEL3S2YcbW5H2m2Myo/jDcCiAuM0eQ+FrpZVDnPhZ8p8vB8IXS8HFuioG4zd4szwu9V9hRNXXeC/PHUvnl9ZHvkf5r0Ks81elmzDiS08H+KM7zdCbW3cq99E2g4wz9wWKJoUXTedNmKCzqhdzik8btrfytjxuYYcCSKTPVXOOgiJIE9HIJy2V58U+6+GdP6nHBay3w4EUDkrEyDxkjjfLjx+dSj0h8pcd1QIrOzu3bieoG5ifVmCyJp9TSLmQPCSt1ZTgiIN7gjgQJHP9qAJOj4Z6EH5wKC3rcTjs/rzer1qzQ+wbYWC54GDBRHImy1zHwaCZDWaybsaf8+ReXKcubQV5aYK7WQHMePEaRTb84Weh0h2s/GvWKOgDg7qGt500Gh5wdPMB9iQKgPtN6SokpkvuQzUPVVdAZOezQ4BGSI/medO8LUGg6diZjJ0FMV/ZReMuCajLchQH+zjOcH6MR44I6D6N567uG9Z3MAN88JChVNWhFej0rrbXyww1cd8s/AxUaNcf/sagacBOdWhl/npSetP2q7RE4GM05hGiHZwW87Bae6zTNF+pXzPr7xBfqSri70P8fHrXi1B7qj8TCaNoS2TFHIS/TsH63lGMLkFnvaOatPlp7r3jyvHz0lNYZ5yVjsUXawrZPU7Wlwy6y2vr2owTrd6Smygls13og5H2yTjqGugLShWN+h084MjewshhKIGZ4tkJPTaDFSRuslD/FwaAFRrwh/7Lvq/50mJo211Xp/FN0HGva5UIM2QY063S3IFSgo8BSvx3T37mNi2gklAHhuu6B18mIDos5TdSDz48a/CZjTe2SV9x7JsbkL/B8p0/Mg0z3rVyn388uuf6EosfWj/rCfNhwIxu1APYmUj0EirxD+R9o/Lt2gPeuQ9n7X89qECrx9kjP5dyxJbAKvHSLrASd+2idIOoJwNumNYATGZVCkxqpV5bgdIv2IsVlXQPd6iIGK8tKR29qi4hyWl4aMG3njeTJWQGmtXEVvDqAWHogTuBWkc3sq2CnAQxJu8/2ptFVOEWa7m8B/U7fyw5hBEUZRPM40gBvKDESyzbk4xeZQClnd5i0UaR/+Wtc0LoX+GQGkPZfefkWJyBTQAzmNZvlYXQWv9obEELF716bW1f7IxoMxNGITAi8DW2ZC36MTzv9B/u7JjSCNYZKwc+Fq7jq1gA2o1Id0lBazZGmeIIu/Tb/Kz3QOq4kVaXcTpXFcDTXDcD2LjyHx9WEShdNBT7dvPXnwxqmpXPIdvJQeQPgGswZVPgw8qxe9Q8q1FP4GTOCx3pq3nwJZELThUWSo3ptJFLvJJ2BzAkfrEJVknBbTJb1a67KNK70dfeNuiUyf7EpKHljpIY+KMn5OObM45Wz6s8LLDAFrlRJRvrY1j/QLp6V0Ka7SpVcIQ5/6XIzYr9v7IUL/cn7viYZIcyglK8KxEct/SipT6ci3zhApQyZE+g4dsup4pFqZ4x1QlobcfEiSlUAFoclY0gq0k0aq0+xTSj/+/30kSVOIG1neKSZm0Eib8COB8C4SESTa2qmdfyU8sI4INlp/xhsN2xaYnMXvy7c3xhEH6B3rCNnleQ21iTa1IWtLGEaCS8SzBkp+DsdThaWELvc8TQnwhprUwSM7UL+hlvMPmMIUn27mFGR38cbX5ca7Ild6eSqqm0w/roEgCr4Nhm4zvptfjtDfkTOsF9WvjELE2GyodNkXv3on//79ot8oIVpDXI4erYgpv23jmW9Hr4zO3G3Z0SleDWtuv2xYGCu6UUMp+i9I2xpUCMNBqkpXqdAsM2MybC9XWgFKFudswA7dkF6+gdA+MmhUntdsr9KGl3QQDPGavFDNIkri55K3eipRY3NlFMT866vUHQdWybuHscGSAnuLxw4xbH6IqD6cw1VHAFciU2sRPsbStv4WEZkgO/m4IDqrMCISbhOW8aEt6ByUtN4CURasDieZ2MdmZMbR0E0f+WUdDLBVG9kiYmqe6Q1HFWLANILvkQrcBHB5787wZmtReWa9WNRLm7MApEP3h0ZtL6aTcOFayxYRn+TR1ZDvuIxaYYcu14rBVDgEdnHDvMo0K5JemQyNaesf6fhcP9lbJO+EWWCMCBqAjk9aVzoXyAhsBz3fq3yZ/Y1y7kZ/Q/8E1Qzt6ZTJ/4yJVQEHLLLcC3ij+nMJAy74kYIF+hql9jrjr7kMpAxUm3559UnO7ItJBVWuEbGiL+9brzGZGKf2nlzlu8TOabDlBz4RfkeJYLEf+N/vYcHpyupr9PjXMIMwvEpMk1YGkaWosnCo7f/Vqw3UeDP4vRvmVNasNML1xC3cp8rXUy4GsEL84SF7W92CHbz6IzcdjuFUXOJ/rSWW/G9NvoSh7NeoHWphXKneDgUFsf81zwQ3UZpKxRsE59OUTJ3Q/KfMI5qnfv3nW4zJRxC9TpLVlnYzo6oSHA+aRM24RjdYyhre1gNJw3eK2mAXFbwkNxnSCnZpBemVeeVZIJf7WEs/2+UR8nJrZ4FfrsvBGD9K4nkYbDbbE8yjJ6Zo3f9bpMt1XB4maCrUTJ2ouBIMshTAZBTI5fOYGSSF1ymndnLXnHDDD0c0/gHQk3l1+WB5iLNs4QQj8Fww04DExgN7DTR5RzH2rwF0Ydd/pB9yUx/j3M1diFxn3lj0+CHp5AG4HKooUEt3KGHxN1GNoc8wwunlHntH0+luyrFzE7oBApPlC8I82Gx+QY2WKFnJxUcYvOmUQ8IX6hPZasCEIs7NHft3Y/dmEiX7Gz2qluyQZaYUnoBCWnDun/NgywS3u7MW+oQ5j/LcWbEzsUN2VfW1UNyOTH45zA6V8Xp7jL6bMlVy/5a+zyFNHH2s2xZHIx2NtWaumrOr1criVDZ2vkmbel7X2T/mG0fqeAH+QOGAuIwEQKWWkX3+egp8JYVfL+m5De1rjbwR7xu0tzDZbKTq7G/1wu3iVF9NEZQpnDt/Hzh5rnotc9an7nVHF3JP7+/xliLKKaNnFCK+ri3jSNWnwhhW84MYknzeLPsiKpe5xLNmk6RpM1HmnMwGOkNPrPrY+QViFwm0ZfcJqN3/zAE/NfHYeOoi4vgPpUzcH1oeg+FaPGX7MZGQZkBrvamzx13/0jbrdMuvM00aVUT91d3dJFygCFE8mbBWTCqvtMWUFon+JdL3ysdPPsXWXutIoHD2T/1/Vup10tTSgUsml0CKcgFZzVqgWRhwcmr+zlx+wm5C9hCCNVMfAe5eATn/Pj1naV3tAsGvavX1jWOOEhT+RroT2O6pP1phBbbsZEbU53VquIS5ctIH02eDWP2D0Y0dJn3ZUm4G8NWoUaTN8Egu6ZRlBzzaj1+LLE3PA/FqgcBzwZsHV2VtJANaAq8WhDQhvjzwbo+aC3RkZiokaq5NFQriOQTAJLtrCV8809NqoBG7BGBOnJ4FIklWW3oQc49ff9VvbYWaNpw4/2+RhOytdPh7QecUN0wgMFwtQTpdz5hNDUHSWVwHWsGkespCCTaqzXxtP5DJtrRDWYvolYXxMTEPhRHBjByTKdEiNVNVokjD3pwzGm348xGvRJf5Xp7/UOAPAehTrYo0+zZoUq2eBqkUQMlGS5Q6ACKlHJ93DLldOdie061FmwLnYgbpf8ExXmMq4H8SYXAb8FTTL/tkDUziVntPfpYYKVvTn6w7Pz4fesG3Ji0u+fKD9pcy2Sx/Wmjj2YM28TW9X52rwanyr45C6pDXeXONtY+DF1b3J2wOeAie9lHbmf1tI/TDBRb61nyYP5BlHWjNhTzMqde/VjKz9op4NuxHbispdH4ooJWHLzKD7WaQw7Bo0wnfmoFsDqGCzkKIotDD7dbobUu6t18Ck/oZMWzdFuy8B2hwaKhlsjsqT/y+sh+m+pGejyDjGNPcRXlxBSTb8vrG6C4tVznHV5zM21XPqvFq/MyegdWZcYIu2d//ucEIzg3I/FHOVr6HedPo9SdW21GVSbhgXGTfxFQLVia32U+bF9BRhg7iDrgIZeUeSn+vJ4i6y1LHPgagWT1TilZFEL26Ojv7Sms8UPJzmO/WOOG+7HBFfu7s+n/c032ZSmYFN6S5bqDOCbcJ/muNYbGMDMiDxzZNJv0hCK7DHP0hOA+h4F4lusU/khAoLcz/IU7BykfdErBGX2Hpsj3puWqCSx9dilI+NbrV9Ixunmlp6CWwX4zKvVAZqpVWUMvQGhvmMWdmJZ0Zrj9YsyWpYkOPGYd63TNoVBw3drjl8WiMe4FETnBIhu8qahGVt3NWPfwubQn0AK10CzdAb5OmytanOL90x2lRCmDTAWhzlMsdjO46Mb1e0Y2RZyt+WWiWaRIqywdpOHnOt/iZ5kb+ERcZbvMDydepr6w1+nmIguCwxPcdL8B3VhEmfaED+IbDhzgKNY2t3GtOUNZ8BflPFL7FRjV/uTcJwtd+85+uOmbtfsV8u0Ih4wQVYvhloWLuWUE+KuLWGilE2e2kXu92a9+64w6Ym5AN+UYLVPPnwmjRkEFwuKKFVqKj+WrJErrKvrHLOfWKVSb28R5AEntPWybOwx1iqGvTKm61fS3r3T4Aelg3kgVK6I2dHod2U6UpkrmWQJLzWmn5FlYbCycR7vWzB2Kh/LbRMEOKkNNTRlbcGv0mu2+3/MzLEFnSSmccjY1jdjtwxcqEuTpA0eaXw5PJIIrceGMj7SVUInBk/A4mhV0AJegdXhhXYODThoillmz3bMZDhYYAdL86iyZjHccKOJE5Bgr/zIugBd7kKzEsOo2KSjfVZScZRw2hUlYRf+mODHRPH2aMwHp1tbtlgoxBdvb2svF7wWJMOPJS0f8q4GmmBzDWwyJCLVVzBgixefPPunKs171llRG/Qks4SAecKrAKO5ZzBYJlZkn9+ItLVn7Hdxfjg8eBqhKvqhBA+zomPAZT468hEzmjwKBKunKCY8B51c0oxUTb9+aiw3NX9AEOEnCmF8JeylmSDRJa4hg56HzUzyFBASNu1XpMAPiv8C7YguxzcSw0qM9zCh357JESypTdVpZUlYhe+x9bBn1CO8amwwvwbi3V0j28dfMsm65n3GWCCnK4uD1dwDeRHJItMzclwyO0GQxJ8cGSaFb/AvwhfBx4cvY+j/qKC6lUOxM3KLnmCeR1xIWrzQ3LR0wh0dj6inWnR1CHv2wfh2hWUXM7XvaSNLNXmpbQvym0SQ2zgBTDmmlM32DGIVbuDcfhr80PdAPc8jU6Jd7BMVLbxKxIlaEiNbMZ+UcTEAi5ZBrC/giwpeiK6wpShXeSw76mhszpo50AznvueCWXSJJ8tukKwVW0NjMPl7xfR3nGGpkWNKdRrQrYwUOgiK7AwOzvqqNEKwkdGZbvqilPfYWvOrX1MGCpLLIaYIhK0Mo9hX3P+AKhhZ2VzkIOfhAwWvQXFRkAjgW67f4LMdZH4eK5iOgKpBdQJeGMuqMerX2hlPUjfAJAy5TlTytB5AgF6MCrVufAl8f3skHgb9a3C7jGiLxg0M1KhFDxviy+FPaTXZxwwsJ25nKc+EKtjzmZxMTYRE+ZVa6xgGY9YTDM2C51ZuHtcm/Kro4qqTDD2wkRs8OjS6v3+uMFI8NNfpyWF/gRGsk2EXEH1iBY5+m372ikEpYIZouC1ij8fJVGMvrsLmgcgDZ6ZX2GavylFsC3DnpMmbyzuafQd6q9vd1B3vKReD92NQcl+oR9o8OpkJpEB3Ymf2LDEEJPGkf/1m9mZB+ZPKKrmzDKTPguMZNgX4LTHEDK81mDtxEFVmShcm5ES9mtAGwAtbVlB3rMCbgGDnwaanhccEiGKRfgh0hbhAxHTHtfVx34CNfeFIMRCad1ud/JOKIJr3DJcO3wZuInjURGLBdfoL82q9lrxVOIY+y8GGp5mGTmq/fbcNOAUDapMrHthkXFU0Qb1a72LCTNAT32rmKkGfFFA01VYbKaOd1BM3MJ4u1VG7x6KPX/bdtStU8UHB7038yvWVkJ88U6qx4QvqgiYNqt7okoq8xuFsTcJVhMGQolJyuKf/JQWEgYXcqgQRnaadNqd1qTGklS0VFhY5KQ4crsT5W0XnV6aiwc7CptmksqWyukQueyCb6ijmfE24ycL/McxqGtFwKeQfFM7wPN2T89ykqxoqskNmmmc9XphsnU0k2qDN5xqks1nUWg6WyLOmN7ZtmpMJxI2X8AHX04brcvjvSh3g+VnEwT1IhtCwc6vPnKk7dIc4j3sgnieEb261m6jLg72cH/iGCaYXWkp7Ssg8mFaWUIig18vHttQcoxfezoietlLl7jvkZyZNbzupuiWXLVnSyfBXn84WJJT+yKtR1bd5/eynBa5gg5iXvmgqQTVg7jAulxUup2Gp62EYrBi8QbFgEJk1aoJukaiug9aKYomquzJ28Fwn5GJp1k2gXMZEBQqc221eeM8e531uD1vn2/uYfytNXH+kNqrNcCe+oZiRG6ZJYq5OHD1vY+ixgw+04GzdFX0aLYWMipLa7qzYYyeOQeZ+9s27oGv1fsmP09QnCN/8Rs4fDlmQd6C5Up+A60r+8Yg92GERTUrcEWyLbvXeaobpX/Rz5RkOlBJszCSffVwqTXxUEVneD4gD6Jvoxh0FT9w5lEQSOfMvtoazmzmkp8k7XI66ZPRoQ38Hv4/LGNf3Zk/yiu8GAIE+vmrv2veYypcXoqNOAiEQducvQVCa/KI9G9QLGYPUMn4nksjM2FfgGUvPd89vExn1UrDvRfnXRRTag0kJsUuDOG6lomfHHepBx/tMOFAkbgcWAjLb07oAICBrsmnHXQEK71rnhNrbte3yQakom7jAy64pS6hDqfw8MVRMpMUOO4WY+AJUdhqR/AtIyMOOIUliQ8JLYrLbIA81G0UXcNFSpD1Y1wkVLCg4TWeIEdLNoSRhweNJzXWo1l00+6Uf4xZUPyoNBD09psRaDAjjP+VgE/h3UnPXfGg4AnZycA686/Pa8qXC+vN3uy/gLNoIajer6hIi1pLczrQeAuBmWd6qPwNPioXo7Xfljm/NTW5abglAtWmGqWoJmTi5ddpnnJFJjgIynhLtL3YSO9V8yGfYeOC1SXUvoGUtIKleLVsupp+4s4zy7+D0ady2+p+vxvI2CgkpjUG+0pZlj+gnnm9o0HphVupoGjnnH11fOa4+uBCBUHBrJnO1SWUlSyjSkUukwOpJmPnShjIYMQy4JOMfFiGXybowCiXzEFel9rKdtxvls7dQ7+c8+zEYX6kbntilijGzTshXR/qe9Sy+3WoxBwhr4jquRhfyTBTVI1jijOEJkcmMP0HeNbKPdcEWImNVghPlDYz98WenLqOEPwcZZvgiYJEkIZo35iFvSRyTeM50O6Avj61EoBlLXxGPEFPVw5xphrGhYgcjI+dNILb7C+HX4HBpZEmlXvDEcJ8Wr1mpB1DdE/MzjhqccjjeAjYratQ+NqrEdpTXHhRR7xx1HrkgfFxQdBvMl+XqcsuQ5g1Ah4qOIqG6TTZQW6hO0fLoff/naZSjDH8GifDUuWuplc9l70e5p1hSvm4/YoO0+5zuY5i8QbWcnzdmbcRxw5HIcMLlD+YautfJb4kIUJZCFx6NxU2RkDiv49m6dcVZHFbhIdzStwRxekNoHKO5iS/gfKLBmKCBf2VdXPLtipSqV8atnKirxFMdeaISbfCQ09jBObGLgF5hFW3toa8SfQWKElc9HYPItkENqEkgPDLOX2cXVFT+mTGBvZa/WYYmPKycwpBmV2zvySEp2NIshRMCQGAAKymMYHaUebvnLMdHvoyPcmrQsxJouq0OIjsjalAEXk/1j8m2KHZh8BuYsfr3HUpN6GkIf7yG5ny3JHB6lVfxFA93x8gltH9nwX6fzTjNjkGItPQgXhmUaSsAkzv0r+tCpmS1GujJsEtqHiYnrgsKpGAJ28zu5Dl6IxD2ZsaMD3+fC2kZNY87dDZGvTBhkf8W2kqlVt+jD5M7J5kf6ZzBG2eoM7yyuIOqzbOLObwnUgZSr61WPDYHuU/OMT3CY8Odjl/nOJqbu/tnx/qd0np3UbZ6gLmX23wJqk9xuJeBvYCm1RSjqOlEH6WkupVBrR580j5NqOjwCuQ+vkfRnmUluNu/i1T5790t1kyb/E4cvH/mHtl305LHUGMCiQ3G9/IHhnWbypy7OfcoCr3zXWyCM31i17r0f5hd0/Aq1CCjOI2r1pN+fsak4nPMFCjbKy6+CmVVS839tSxFWCknZgEYUcvmiU98oZ0jqTqAfsCbIO0IFZKvdEcTSY2CN5z1bp9qCxep58kuc7FSssIU64CqR6dCSmlLbZyki2TlMCNxuOOjGDL8eHutJKqiKu3JlW73Remfh6LX4KiI7hxau9u3r5AtwUA0AB2fw9z802/2eYv1LjlPi/xvFLtcoubTrpLOABXyKztw51cIYuxiNXQeC0LX9VPDOhfXXn1dakJ5qojhLW7b00Sdhw40uoPr26Y1xCKHuU/14G+tf0EX9X3E8reAQfUbSVJLFIg6xKqJFzEz3IFPsq+nN1VP4+OSs0zM4/jaEv2DFFp1jN+VylNhJKLZkZNJBWHLTQvQkJ3IZ+yFvF0Pf/MhCX4rPazBLaCA8d7ZNAgZaXNYQ8TG2XREZ8Zk7ThJr0FsForG48iTRN5jHCbTNMuWpnxp3cugv5hmn8rx3MsLh4m+wOiE0UaAaWNFlRpomBJrEJ/rq8q80xD6XSIvSBpRE0MAk9pcUvFNhxa72Crz781MxHkNqU4NaLg6/VwmwbZNdZ4EhrbJQi+P6lcxssPqqv08Q0l8V50nMt3gfX0nl9EF+6KTPbOnbQMLFQPfH+OrTYlHH7MvgQO9/0DUCsuy8gl5TAMXPF/kspZYM6WoDZFqGRvD+xDrG/oUiE2m5RvUtV+tLHK+bjMBvQRETx7aSCKwnaaawcJwu3WiM5N3F6Dsie7NQSPiAJ69PrAQnZu5X4LUaRsMouc7H+Ef0q1MnKeCY4fKVosGHkuPguRnu89/yIZQ2lAszaAG2jwz8wCIWNcKEstnqO6Jy86Iq+eFjt40PO+h+x1zPGi7F2wmodzeLq8AOePz2vR1qSWCgbjYBqWXILfJaffeTjBmHMjApw0rXVD7gdtf9GTMBgMwDCt/jiJzI5P7F9tPAdYp0L1P4BFgMK8xDYFVnAKZ612AmlrYE3hRaGi7TkZI7OGMX6vvKQx/aKWNE2juxewRaym9VoQQjx/E4vHX778yBhKBVttRzwroVtxZvNfFCMe7Pzb5+bVCWQDW4tcaapMuRjDS5xMsjbRwiFT95MpOQkFcgI6K6RDMZP8MccZ+dPYcqO9NjOzs9WmRJWOOyzSYJQCNbK6abf7UGoetz1kdjT2bwA5LDNsfWDuzXYOYzv/s5Fj6ZaVTUP2+o14hZZCyH5AvwDrfblvji6LmCLz+wJ6QLljE9TC7QRKOkoWXMuymaeja2qbjqShAtdvWnuZvotdVuepLP2svJR+TmeYtgP38Djc+DmhZ0EFvaXjINJKycFr8ZeHB05DQz8o2Uqjq8EY4JdUe+sXpv+tePhFkkpyjpXwFMhPCQ53IvysEBSq0kKLQPa2arvwWwM3i6bfgDrcjnvFCA0zyOOD4YnhV0aidj22utROQz/L149XoIwR6PrsXdd9sJdwuXUStUXIW/4NqnDvJTza+/ptgKCt+XLrhDe6Yz7E2ag4g7EajHxteXLKLQeURq1b8CRN3VtVfIXPMkKuRtWMZ7mzKNqL30CIVm8nILNS3ORg+cTCu7mCRHnx6+qsyE3Z4I9EthDaJ2LJ36W/JnQwJ7D/hFq77ArN9yZ5TnEQStjBwDhTEYbylNg3Ui6w4jyos/kGyjs8q9azy9JN/SyaNTvFzMkx/Ni9RqGlzWkNNOBFRefcP17Wgjkg7xqCv37IOT/iilvQ44nrHocJoK8Df15VjJps2CHZbOWhiQViNj4nfnSkldBeMcYhKbVVLQlg/T0tATZfXV2coKMfaqdnNI1qYjgV/0piXbWRC6hraUi2BQ8gzYezG3Wb9udwMvz+8UYUwhi7LBKdBE0t5wtYx8X8uxGSGX4cRuABi+2INZ47OGD1OhEcZkWK5IHMyG3QdMuAPHsjiWQMBdo90Whsw2c582xQASALMUmxfuk0p7KA9lGPevrw60ycjeB3+CeeQoIV7Y4UCvelSRt3RtlWl+ssc9xBJMXEv5mvYFoqYirNfGLMkaO1DGqx2OjiXe7tFBVV+qK8g0o/rCzxPQyVwgM+5gxx9W6jWh6aMG6ie5cTxX8vUQKfjJMfjMblTRB2SEjNibQUVQS7HklxkbIDXzpVDuOW680iejW9zWf6/xD7z5EQ0qsKCb2FRDePMRmji547Zn/cbtWIsrSCQSKmM8Y13vpAWhOcibL4eCVpw13olBVfb0kh/hDjQpOXnPJemMnGYWoYYhtXn1QtJzPvTBNBBTY1JA416h6dzf92XlcXotRhahH6d2CpBRTJfLlWF7RscF06nznat3XRnPhTZ/AAK3Xih3D7ILDYRUwjdBphFoBhzzM1l1udQ2er5WUJE21f52IgSGOhWGfe/Ax6nVEZ/tkEqKQhChu/zOok54DnjGrMaWmxI2RPEu/AT2JwKdm2TwxMN0k2zesgMHnzUQtl3A5vyLi7GaTvkYwbho0U/Bhg7PGTk9881xoXsPj7oRTVhDEgv6mBELhqpXC/qSz4RKJzPXeO6mvFSA2oQiIscjKRv5VPuMDc9mPZxIvUp9Z4oJsBlrkkKlZixZTTovBvCt+SuRelzhWTS6eMrnyZL2cQmrJe4dVWGBbqu7vt+GmaU6qtthrSQaANpyl9tgnteJhGfqRZiGF/z7A88sdgZbwU/kK0f7/aQsP9MZNm3c4UWS+g4/cZQlrs6clydFMjoSUlsZT9kjw/quQqrL8rB6oYhKaWpaFnQJ5yn9O/SK26abQ3P6LE5NksBy/2UOpXq/tcbInzEEMpBHGAl2VGAHcEx04oXV+Adjr1CJkF20g0Dd3P+eT3K981G91ekhL/djNimGQ+FfNLBAg8oYwikGmXl7Oaa75DpQIclSQ+6wh/npDdmipgqTZg9Oo13hFf0T0EjdxiDD4I9nVMfXNTkVsNKJMK6qyR/6a4mFeEmzvVS5IUVwmp0lQ3xZQJMRIcN7aAoDE6gJ4t1RSLGwitJhhOsc7XSRhA7gzgMOm+3BcE22oI5SPMQ5yQ6QkFAEPXJ569VISl17ylE+LiKzCfTIUvZj4kffbVRu228T35Sa2SEJKmIyPWvA7Nw25cqr6KxGjnms12C1FJbiidlgu7J/Ud5uTomZgmxoNPBxbmJ50pJLnLkSFvl5prXbm4GwPdsvim0wQzDzaJePABpW5CgcNPBdUJRAaTJXy0OzNRn4Htcx36ZG9OAe/4sm2xyqr4oiEf2OAjbtK3SFqM7ZmepqMMhufKZW98gdBvWHxoyWzVMeMrniApFfzS8NDhmJ64dLiQOyLe7bLGOzBi7p73pbnSIlYAOJ99UBGMxwiJBQ/llXS2o+6xYAHqrOHPA0AUYdziPkZ+ZQHCmnznG39YjEiS3GprfMwWnrg0D9e3gHKf2Cd7QuFxqmCq9fgiJqMAU672/PVHREn2n2hW3QCJa5VhhvlcrEUNDnfjElJ/fDhwPGkB7V5ljxCXwT18y00WIVlA8vhShIyb3T61RfQDYLdvOpkGCYihmJ2XSJs+dpp38dSMsj1RelFM4huur9dmRbfFrzvzUtBMiATGSfNCD8E9ZWA3sfqqGmSRTxQeOZ/q7r9ILe3PmbCuLAa5s33lh8A5DFOznd/8o76878HXyYiAC2nv8imQJ3PTxbi2JstmE/UHrkiO3lhZ4wrKTR/1JNMQBpMEa80abDGORc3KVD9iiVNuxF0cn/fky9SjWIgg7EnHd8F/4LYY0BADBFAnTAcji/ZVvTVkygmvE1ONfBnwMk0DjWnKQatT9sT8TUmCSGiAitnzAwnqtKBNzuX1e1PQtqbwS7ZXs24/iOHfJKD5swuRQEXg5FaMH7xo5GLjp1lUEhkhGcnlPBextcbmAtamOv7KKu3OoqNDtAUBhh0RqNAjedYPMkJogYfy4LE9cXmma3fsxgEDBKhP/gX3lAjeTr5aU6tcYn40JCWJiRBtuk7yTFqrnlwoS5+rPwJ7g6ULwtveTnXHMDNoI9nrc6oHvA74QARd/m802jprPWVIeq2eehWBXMxjTRfkeaFb95hrn3KPbF5Wmwv+Qurng1gn2ym45E68fj6lI0ZRyNRjglwD8Wkz2DY55UDOzdQLJPDSqkF7UZQ7dB9NbtpBLPTz7hN6XaWDYbtHq8hJZQza7XBTGVa5zRJEPSSKRyDqRwWL3Oc+qnUlwioK0tJcQXtdGPSG5+atQ3wT368P1k4GKwyD2wuhEWp44g6kYKocClLhW/gXkWX+xH8gu1ujuOiLDfHQx6N6cuDWaf3hn+YKNBG90YKJEaL2xwuRJI7fIkwv9T+t74nf16sKomH1SItrWjL0kw7suN0q7PQyGk/JK/np8IAy2VMG/0/15b2mtpGvIZBte/GSh+n6VlyJ84G0s9sQJz9IGiAXBf+jW6DDcefDzMHk2Z4lU6G+GW2GKKWHPFKvPpKhcEK8kQ9Mq/debmdFWvPxBOUZxc3WKCSmve6s0o/tzUOLfeCIwYvVqf9QsQ6DOwo0bR5EsXruyd5S3xDtV7HIQaBW8MJAQQU7lLRi9SJc4RUxfJoObk0F4zWvODlQbL9kzav/+akxzlV6TqkZSANytK2v0U+o/IP1fYVD7GyjT/pLora07inxhHS6Eer5QUSU8Ze5f1vUBhmCYzWxRRRMCKowcxV23D/JKSkmCDAQnKkkrtkReUz2VBj/0/XHk/YJNai7zPBSQeIBGfUo9T7dYxyFm+ED4soKaeKPkYn48Q5FIvG4rT0GgCpf4b7ipWCMEh1apyN503q8SXehhtS/RBEDNmKJILg9XYxUl7wW9KuXFuQ2XdhtxcoSckVEBaRzEyWsWB0K04uMQX+zRwEk5GjIKf5aBP8mbZSWw4hAWrIJ01+k5xeBj49nrRwiJrkfutaXD4CYin1TIVcIoSkEnvyHsTK8aLcXpKtk9561vs2B6Vgwm9DoCDpGNcT+vSqYoNm3Pi4NSePcGeKszuxpSQoC/yhAhRW8gfaMPW1EN4+mTvajlpk7CKn46ubJQXlVDiCb63I1BeImVLDxCr6xohr/91ehy8XJjklKPp4jw1XgPROfMdFCNLdfUonEuw/aabHpmFqQ2N6ODWunbcK8K1J347jjmfLTk6lvRJl0dGzJJBa5ml5/2/7Iz8lfkpIdqaeC+iLMdGNqjWIfu++LM7MKQPX8MDbqPwBZqzU/7pDDLzigdN4g5cGA2ZehjHmoBIGA1O7fvd7VXx1S8JIRJ/JP3Ik9K4rQhHI21LXzzybG6Sw/cf0k9DIL8hWl5UXx2D0o1lD4kmoiURDOAYe++Y3ZbNXMhgCZwix4ZCX/t5BSnTUpmI1NQt9Ur1GYxiCFPnjUnPMykmzC1HOBRiO96ToBnZzxcZXFcWN0JiSSEGDcmP1l5fQ6zCh1z7hKnuyKYV7qTU+Yj4MsAqAfcgr34mPjsQTotCOP5rSyaTBD7+NvCA2VMTbOO503wkAZyyuS9E6dyYfGwzCsQGbRXElrYyF1ncawtitc4Vmmm5f9pawdF2AVIbTc06h2RqJsmyExvhu0nmfVwMiOf6pXx/bmwlBwaoqLOjJf7/MndxSIy7kouoz6R1L0wGbDccyV6ohjmMO8kz3meMGhkkyu/H3mO7ZAvsyYyKt86aVwxxWOLbCZpsC4ydFmKA9bTjKsfEJOd8kpnhs7FdDbTVylrfIwrEHElVk0qgtQxx3oobFeXBJ4poByK4IDpDN1GKCOdzZY8Je87BlSJIrolE7DPdF852yhg0EuLp44aKQ3LHuuhD4reE/jy81epAb4Gh+8FSNLa+17HT03DtqAC5un2z8vayoyNaEXXYrULIHagFcfFTc5pY71vBRsMzZgQJ4vaTQYFMPlhBXPz3aa50sfWWFuJO+JMyvPPOwnwFB+cqUwMulDRInkFRZIDzsXNFZGrawaal0m+3R3/C55QQ1e0Nwr0iZlnlZ6MJHYYEqF1s/5jHErIDk8jOuf9c9vUvY5ZHWhn+Z8O9S6xmGaouJ1Px20hB4BStI6C9xHXt7ebEeHJlxVUSXriLy4mEk8y3qJ1YqOH0pT4mfflKbH/dBjrSTF0ThPdrlDR7XevztQVbZnDOHs2+RQwFRrnK2Ll3327MMFNBfP4eVFn8uq8QS7cFIY6gxdjmXjHyHL4Yh1LiZDv7M0lcULIvOVlYPe+Rv5nj7OAaCd8q0gQPowPBwhZ7Tm6GGG3v86lA6d3e3JrNqbhOQgBGtT3SA6iiMGJg+/jDWF4QwwpBJ0eZXChcP1rRAwqLAeTjW6xbKwLL09LGum2eMVo3uprT3dJ2L14GF/sWHfi71WPh5bCtvdU+Bzyq45ZluuTOwWBGlukVB91acuYRjpYxy1QA82uXxpT5AKnEJ3SstTZxFZ2eua63cAtaGjGZRIB6uvrm/beKidv6fLJmmfNjrJvglRSXi4CswwuhezN0jjGcIQfTG3ZYaRKuLBewyG4A2ANL5JocxQvVVbXTSCTCkAnS43dI5FCtNm91JpBwtiW9rLZ1gEu/reawwDYAmHK+fYMt4KQdBg1URL2DI8fI8PyNGqlFXY5ovefTkC4yzvHPASOQW4Wsps87EVdwDNYfJtAjlyN1ZN/zCthBC4VDNgbumDohiqqyh24QHWUEaOoYHawL/l8OfF+SVJmMNg4361A6w9UwtVewjf3UvlOJE5T8ZTgyft3tKKfHgnVma02dJFUBeIXXq6SZKThUSD0MaUegjoNmnNnZdilpdr6HnFsDQcNEiTxgwN42bAUHc3UmZZRecTgKQrceS6IX0G7BXlVnOZ5FUoGH4A05uZw/Q+U3D8BcC3pgm+TFKNVEv/h04I+uSYhMleOVQtTB32zjGn0WEclJNvtwVCPwH3zi5x9FkcF/g/pvVl03D5Siz3oM4ZqKq4bST/vHeyRtHn84ctRYRxztprLrqtXNDtbhbjm4UFwqivaGwO17hUmUm2Fh/0xS08u8EbnEUIe/90xrxt/RGrlWPI8/qWBm4NuP2MWXDMbEtM3x3QFRq9UMFPyz3Yz+ne8jaCg1w47scZMlCJLnO7HkwECqdgXOI4AWdQu5/4YLMogkf0uYi6urxk0nVaJzTAC5FZnRMvN4ngVD0qATuWfYYszagU7moe9kvib7pK4ABidG2UuHgtp8vqIWpPKhZFOklmNtxRJfClRdvntRbD1BcrT9qeMY1/cmQcQA5Gzbt/mfQqLs8H0KeclBp9r4Zu7C6pSjcKIFJA8g0UA/UpaKZserqi2EJuZRGAwGHJEj04WdJJ3GwiARj99yiMzp3/JKtIastMK5Byp8/yl3CnReOQrtEn9FL5fY42080L35FIbOI+DYaue8N8bPgVUhYw9RKDlVZrbQPa9TYXQie2iYyGI4T4jinJP1R9DZBe5Q7jEnQUB/GMg+9J/BOKcp8i5/mWoa1oHYX/uebBAoGbkJ4H19XJrHRLEHj45KeODr8hqPiElSmw2BqWeGNM2LDDji99FuJgWAX0yO+5X1YAiCSA0f7IMUJnsAx+PrK8u4/nTU0W9yeIe1El2Se4MnMunEU1N5TrwWWBQqvF4Bm/wQvqEZiQU5WUNAKk4y21X16fT1jez5G+yfms7P6uhjKUrrRImEq0/I8lc1kaAHlWdvujRYd6MczgwUasTmO3jsN1wWwJsuTJgTVbNIdh/rnEFplRgt/lBrKlWuvXWDYFrqDug5einJgmPBtG/gElWnlV7ZwFSrD1VfRFJYCplcylNrn0+FIEFBsd0CiHksZMoheCN3oP1y7D2KVn8PhZ80GiSefFWcX/Kjnx2EQnvk662AWdiPKpPjgvGcMw4jEi7YJJjuf/fk837zwlzc5LuqzAJAa206raIqBYZ+0rrWF1sfAdYgKG2wNMoLGVdrUzRWsd0SEsHmyxQdEwp8rVLQXl7TtRL1h/GkxNsvf66C+V24ludKklsE7bxjJJ7zMnK4O3m8W8pxaLIsNktPVI6IoWfR1ay3Hl+zeJZj3R12aruw9f0ppr9gGuVWnnKyEo0Qdb5NQNBMjRNySObhaNERJPd3tInOq78JcyaPyMI10eG3SAoOgeEhyVF9Oo1nujezPYcnMVmifezZLd0O6sZ/dAaIoOW3FnxsSUbVz3NU8hL9GsA9r48vGKjKvMlYEqsfm88vbu0uRRBbPNwLYYu1D58Qp4itDPu4VaWrsT6JIEgHFWHnuFhUdMJKOVN1cuMWlpRWUVnEgmqdJ1eHtqm0sX1t6erOmVt4Op6RK1Z/sLVLalX/iSIodIU0wOvN1HOLMdvlVV2GQBMKnrB0vX8tGmrTrWH80GaWAWYj+i+0fLA4fW7/ilQb64H91YO/8JVlDQ5lhNwSq2U61UTXag6tzJ7/Kz/2WqTc62zEEfdZD2UEVtVJFWJBCm87j/YA7XHdqiTaSB2HZjlNaLCs8mxTezZ7sWzfDAQ3tVJ6tparietpDvE4qSGfntZyR+bofHdLNl70WVm2ckvVy1FxIM3BEUxJdGDzzkCoJ3JZWs6EZBkvPTJtGPX17sc0jNoZhiJYn2RYR/jRGAj0H7YdFLigrZo5cuOX7GTOZ42z4E43VKvYGSflRoUyI9iJahQUISNVyV4HrKJqrdmLi4rc1eEvY0Rdc3LVER/m6lp1VHc8xdAKiFl2pMVsNKWLwxoilWB5LzFbnqOsacvbsG5fBLJwm/1P0TP4H7XOoAkv7HMhONSbQqplA4UgUSRCwjSU3HvHBFpDIt4te8z8KJ7fonGjps9VUwRqpmyudgxjYKn+w4MyN7TiVrcGQb/lpeQoTvi04Q7bjWFq4KvGaGnLkiZf4Bv6O3PfNqlbk6mtCNOZ/qiOutRuEBvMTya0l0FodOnLR4XvK0mcoXg2sUlC34nQW/NgjBbd91LLyEKd+gml3iQK5j9KT4xEvGHgblw7j1TW+H6PLwYnTkk2E+IIv9YNwomYLjS2csO3HyfmLWQ8YH7E8Pa1p+TNQ4V3OTU0TkHCEwxyDiiQILZ5mugz5Cr4ar2CYhDxvb0x2AGFei98pfh5LjHAq/C91tuw5CQ5o9fU8Cyu4XKud9R2nmJP0UH0xTVtpqeqvrArWL874MbHFYdNAAKj1MK+lr2YWUZPk1YQjfFXOJE/4J/qTLemZwNDOpt2VG/dIBHlopc28hPPuY4P5cav7v8AEeSInkz35mjGYtAohqoTVku+UuUm0e4DpZM8DSWoMP8XJfez1a9sguuf5fZE3TqDq7Pxj20WB60AoFtPhezdnPNiF2HSeq5cX2dw3WpEgg98+QXj/+Yy2YimnmxtKDbu1bNVzI02FTgUm/vIZTXLxj4uuFm27b/sKc4pshRhz+vwTCRrGcoBMWppIQTTKtqxqHnEny6bab3HB4L/+PbSSBQTZ2/u1EvbhK9Z8qwr5ME+W/lBidcohrAT6vxCnmQeyMik7QG3gcSkKn4cWrOpH3nT/PXjGX0w/8J3SMLqcViuIYQKESNKs2qaASBma+JRvf0pWFuyUIjgOcv+UINs2R2Qsnyg3E9bkczy3gXciHRmNcZHRz9Ayb0Az1CKJtedMZKIcc9skRT1R/v/3XC3j8DL5T8l8suCPkfoPhMr7uXaUbFdhfrNxrHLEv5GFkh0f7LcGWTzd8wwc0wYO7PV5cgC5ncKkKb4nS/nilN4fjBv/DxjHYN3XLmk+E7suX0ZZWGfGmdrOAi/Wqk3ajR92mbn0F/z+CAAJMLiX5kznKoJxnOBgXmfqVBewrl0RumbYaT9iwz1UZ9606Z+X7SKMeV4cfZt6nCZWIVjKAtDyJ4sf8scQE2hrfcGWszvupxLdmU1lxS2CKyCnjK4blMaGzCqmwvO4uArf5iI7YLKq70ywpMPX3rrAr/nYutk6UPMRO/XIpRZAb8vY3uvUSfLtZ0U9EScUIISv5rn3v6nePS1I+tOxGpox5Arb6CBNgupN26Xx0dQB/B3BEY1b3HvzLXyYB9r+z/UcEx7O4NB1AZJmnd5call8rzSOVDWHi+71th6e4J9v/ZwRQDvLKyIsP6CIHx6BGXboshvlcLBhdlmGJz/If/a7eY3Sjqhu45BjHrwfjvZZm/Ohohui5xnFG+ecc+QARJ4jpSnj317OF+XLlEA2yDEOpZ/+RiJhmLxaJInnhZZQ0wrtXeLLMMPOs63j/aguwFAma3MWi9J3JCHqwHkVzsRSmFQy1OP13V20eqUQrHWC/tNzyNTvUxtKJ8QUw2U/KxYzNXElvISNS35VH2nCgZ0kgMPd4tRn8WZc5iKKqFYhHFNxhzvVNdShUT/f8PAvNsYtM3SS78Y97ShGvZhyGUhRWMkeUNxQGRaS9PdC1+ZU+y5rUBq9rEtl3QB3RnUJtxcDzOqyFi/fBXTZxUuf6nkQVESBu6/3INNBd2XdIG1iku75GV4QpLXm4zsB0OXwtefhYbY6NsE5vAhLV8eb+mUnHgubqahsaXxhUtoRNax41TWVLA9TuK65gFLPe1h0tN7cECVAeQrhueNeRUI9DaraDr3kaLeo3YW6pK0CLiGGpA+3064TOMEwZ9EgUr2ap4EfR7Fi2iqWG/TwcYCOG1hF1bat4qTJXSmig/8Wum+5YsnoVNyhiiwKWdBR4LSBVPlhLcYZffTqqXQDmuf47qAHNaQ2NxsI9nz1bghRDSFcK4NbBSZLKYbgQusy2gY0DK30uVH1ujN7KxF+urZ7ggr8Qlg0+K6wSVYFPI8mVoinm5EHef6vrqGGgphyzMBQhigKL09S7L3ZP2RUvSRD+2OqtVsAg10k2VMC04t9sMOC8mUDDUuiBYul1h3jk6gtVX0aeatFU36IOwjITDbIinVLLIM2xaYA17vS+7sRIXhI+OJ4SlM9sruYlZWwomUzipb3umAmfNUaysMR8qUb3nicivR59S6Kewebkwk+hPEdP+19ycSssyWw4nsXYY2/DhXNCiRdru7aMN4AOGyBkVreMQOWmxWwnBbDsgP7SA7dcCZp2bKN3v98ELPDwMUFcgEMBqA2e6EZgxI0gQwy+FSBCg5LL5vqHezhoOjIxRDNrSHB+wNMb8ikEHC78BqyO3U6YqQFRmU1ucI6XpIQx8PV0HzG8WUFvzj6+9riLETH0pUoecTsMd4KuQRtSd6bb+r6YgpLanGfArOrVUk25fhcLwDqeVWgK/TlfuKBcslqck1cnaJF0KkPDvkhgSky/zO5xOFpxwa1kAsk299e+R1r888tCYvMQH4Mq6aQ8xDo/hcarsfkSSeWkTTexRN+dzqkFYZ3xrgmISP00AB84bF1fixOoAmjIP9NjWsdiAM8MEHQMkWgn+8DDHF05znn0eQmMTsbq5en4ESBdniy+SvFJHk76VgftSatS8KL/0zGoUhgSd+VRdfunp9HbYIZwYj+2KvdL+X+H3ssnSVKBI7dcojJi01WsaBp+t00lOJnXXEmhiHjeHOp+uQwq3WEd31tJ8M4k9LyOcKYhhRS8aHKlFHRc6p8Hw2wGIzBV1cB2Kxs+a6E36NpvxwZc44ibx8Q1P2atH8eAm1XDDm0xX0n7q2sX8xrMkH+1m+H4VNCtQaGnQyKsX0flASRH3Dl8Nogd5HPoNGF++EjDLDgBcr9Tppv1QGAW1CAWpvm2SztnrZLPqmByfGs2yQ1b7/WIb7CK26eof6nj2fV1GG12MZtq9WYJNLXDOhIzNiVTV8bt5bxHb55ZZ9psWTRb6CJt+Z3/ClNeSm3y53eUBsEKbZzW4Gy/fu2YbRSeyV/Z9DojfdPMlJM+Q/niz15WA/ifUHWTWVunyVzZwq+wx6D5rJjNM59m/d7O8mgPSc9Edrff7s93A4Jj99sGPxz6XQz4cjQwA9WYlfhg8GENAO/Ok5wJBOxcNb/ofDvgjZ2qD1MO70HHQj6GQtCmFR2Rkl3DT7/hDZHRJnzTYQiieU/bllS8HmEtVuRxiZn2/oCH6td/rbNPIFxmPU3k7Yl2tRdfSCckl3ftTlhgykAaOpFjfdIWcljIhDwgl7se2G2M3pcmbL2peqpVjkVuAZzLUoHkCe4g0TOZ/b55Y4aYr58piQLbeJjlqGKK4v1UJYh9xAkzUd2b02xSLAK4RgVioEG21zmAT3kA5RAJh9Pn+pAQQEYXsSs5Y8qGmQ2PPnCeZgLD70j6lQFC+vyUtDEz/bDrn5CJA5CxLw0Q8AStxyGxBRgmVPjG1ngAfrks8mwnXv752JvTnj6+u9gGpwWzvEBN/GD3nJ3auDRrdXUhNspK8XugzfwTfG2/NIMtYtvK2yoZfA+32rY0kv8yYSVa/BcdrWTDWjo74hEJYOElJc/XdLB93I3QJeyeYa2JgosPh/p4zRkK9qa+bLPTb/MTqX2fLZ01t2QEWsyRNVar6KZPL6evI97mNeS29jnNXKjrh+reGNbJ4HZptFt3g74jORU/xsy8gXkvUsvNtk8hQTTIC2FMeWzfA4dJA1Z1qi6yapCixBQZIPbZVo2Nn1HkYXViCa58vN+rjglS1jaRFf4bgC+oVWf4T9hDwjbSikWx/+TjJo9WnGfvA3vDUriKU+dir4t48TahIUKfK2ibqk0xJ0K9YP4dwnL4AFNm54EgX6I32quuNrKmrVb8TwcN934YS8QX9ItmAC28ndPx6D0nVCSqIQ2lmmaBWo4T1ZfBNBvlszXrtePR5UfSTacJwgFWEcimSDjwAjLRGxGoiIfcqma1YbPgofzpWyRIDc+djkh+hOJvg/jruKpIscaL2au7vGPyXMMNQ+v8wNdGsNzPuPGJ7G2exGbTtpVKb8yQvh8Pc9eOWXlcedkWCaxadtinXxBRygVZMDx6Mk0bUtmVXA/8o2a8Pa1PjWO/7iIiTNl7rqAZl3oKmacrleK2b9y6/kkjkvObtY7MBHVCdbFBU1qV1myORcOeyjNrOinOYQJ+xbj32+cMtjCf0iJu6EbF09CZgE8Fdn9Hc+dk/JqbKtQvfcT2hCDJ+NekhRtkN93kEKhiazJ7ZTKCNg2yEpbss9QZEXluXV0dt1e4DOQtg0fU6VTzvnx17o3rc/AVvHZrRaADywIwj313aZyg5xNBi2u7Lm4csj+ZH8hamBZjJ5tr5AkgoT4h9b3dPmPszKaKLnUUGvBBF0LXi+Ro4uMv2SIM6kXIR1X2F0RYTPKt82kIL4QcRe9TDRxZJ34dTRd5fNAEi8mJRtU2XjEdriWB4tIOr55byptAjAejt+uX4jS4R4fvfsbtsp93SU0XHFp3Yp2z3VwB+azdwwZWA24x/96GdQ1FOJCH5iIk9xl8n09hEcnxWgNOPm3WnSawNjY7cDmz7d0G1zarIgDojfulKFPJEslzj+hJZCDacw0ukHzjv/470nwZmAagpdTYtHjLoERSuRy4HI6LG9yCDhyEYM5/EpNItRufo/a3j0vnQqPLv72LOH7vU13C6aBhAq6nS0k+WIyMltl83ocfISf19nA17CUbUGyJIJ8oxsjnQAryH8ymZGxFwVmlGmJddXzFoS7v7olbWPwW48uhyLrlVRZm89epWuCZ7wd7peKZ60cQDjGmbyUsSp+vvEtDwILHukpRU7ddyifaa48Fprf6C3LRM6AE5/W7K413q+rz+a3+mPXE0HxicI7zgczm5Ie5vi4jK087Ap6nVs0v2eRImOCSaRDGwGnrqcwfAdBMqC+VrVmSbjM+qGWt67w6b2KC29g7nnMvz9sVO8M4agxObo6OrVgI/+slBWky0MYPb5SUC2YFAXJdWJNF/IXDIHWtp3l5da+VaujTX5+R43/6KpUZt1wwYuS3xaSFmlt14AUETt/35GNy2qwWW0RnfsdgR8y2vJ28PPLCi68MMioTCMOw3lH3q/tC578UFevr2yHaHfR7S4YpyBAvytfTsIUKqOCJS72W7de7ruMd7rI7BH8OaOixHJhM+mDpGuX/4o9Yehmj6sUpsiNF2Y1AiagyDEV89jKuXKsPz/XgqYrCSXBuc72/1ELDmviWK3StYdw4rLzZJuAIm96E8hAomQjs7eyOovNZ/4XzCSVAYHAShZMO2n5XiZtYpAbT0NE+3HIMR9XP5xXm+KfWVygVlDjCpwybXhx8w67jr63CaeMZHRnsBQynBp1z38aMpyTaC1seduykcNSbrtU4TaSu14nmLtPwlmlpCLfhA8HXBn1y+FRq3d7PYvduCG+Ctav+UP3Cjw2eapwke4zxvxzdmWy7mchYleWzLfE0+z+f9rz3RJO0bWd+okoobmxsmOd0jO4nQjq4KXhknUGJ2RgngX6AkXH+wLmGX9uOvBGR1+XXPhnv86ZQMaAkWU8Rw5QOCdk0Nl8PEsYMXx0bjynlDc6E3jNB3t/ZsL5IP8sZdxivxyum2WvAbnBloWOyHJJBuynWaVcp7+gtpUwJHT8ybnABeQj09ub3AruHOU5yb91xEjBLB3rKZdBG5vLfaBkxNikRezJ1YHTFVxYb20FVc75zcaxf3Z3eQ48PgzqGsqG++ASJ0yQGzj0hFCHjnHeI323e5gmfvTnzHK4kNh+QEU4t264Ib12IbjR/3Ot1Ey5eRjuBiSDaxxLygM/2rGvMsUqpLhZ+J2cF/fPhSs8lGJwdqG0bgk4VUg025Eh2HOaHfKG8OUpgcGLZ4NdyD8tu+Owa/DR5L61XmxXYZOBpAwPw2UtjKjBa885tfHMsBiwaZthPO+HkcLaaNAV+JsCPKOKogamPhTHJ9RAkpl6y9ULmaKeJswconqucY6jQoNxtJjLBuHoIzH2JnjkeNO2J4KHSBeCCGB5eFP2E48y3I5wVh1DH2+89m4S53LB3KZjBKDzIs2exhPMFE+bjrp/xSIlge9lmReM1i8LdfZ8dMFbWCUW/KuJgxC6//8k4OGn5TO/YfNUkLXGw+QkDV5fmRwJ44uwcCasv8O9aHWEnCwqNGWQmq+UFuLHjDJr9hLw4xnImh/GruVPmmnlhOoCfGW4065wENl/2036ZuboXOtCz2sJ9XtNEidm6KFCzS1VF00Wv4sFY44iBWSAmzhptVjzPPBBsN71mtLBuE2FShs4Z0/3vAXABgacSmVh6EWR2k62yBk76FgT8bOx1PtKAftCT+R97YFpib/hsTZtwHCzYkj5hYe/N4GsSA71e+EefTWZSQcpLK0USpQdJHuVW3xn4a+TJbN3lfncC/MhJt5E0jotDMgvuf8UlfnWJWETjl0S2hRulj8t6EvSKZEhpPZV6yKLLjGxypIG0NHbHcyiGa7hCfm7hoot1PxUf3aBIgu1QT5mr7WbkqVYMunRMKN1x1Xj/HeCO4wymsXhdlu/+n6hw01imGmXvwAx8Mhme5hpCOYml7OjWXb9KCeDTo67QQmmT0sEl6Wihbezsx9b8tbM/nqZo39xa1SAvCXBkHh1iGIPshx3ATFUzwsDa52zoi8mDOcTXA0cIZw1UAisPUetq7KENxthqHIw7SjFIyFI9NZw2sYIuAVH1C/DR56Y4bbG305bNKn1QafHGGz956T/NDDATsZhqhW4gHxyHVkh9+HuchH6l2BCwRlCFshDfdZhWuHg+8G80qWKRsdc3N6CjSbFunTmIPXApPm9KwrUW1lK6Eu1ix2MFmmY+loqaGg7sLeh0R+ezFj9g691aWwZfLLzc4cYGfDIwNz4f9sL1anZZVKx1foCbj4jGZ1bOxuoGW9XGQQS6KLnzaQ3XTe2mhm5Ajt9Tqty8Y8L+Bld59kwG9tvh1SBLKO7G2JHhxW67S2x23gTwv23PJ9437eRc7ARxXlWjGJZ2gczbmO1wsgPBbuRu+VV4Qvk2Im+OI9EynVkVTXg7xcAUuGBluyMAMCNYu3aNYqw0K4r/f7Zx7wShOWzAjJ3gnwjqk3OXD5LFTLbs1c6afiufj1VMlEonk9rdvKchGsl4Z/LOBH9IEctTLTeM0gBLhxKeqbS/xIce0Vvxj1BSbS4gFKS/E1JlVbhj7Igb/kAmAHQ3F8dYA766X7d6Vj1RNkx5k2ugWboq+DwMPVYKpybrGs7p7fCMBTxBZywsZ8o/S/vghdVWwOYTW0zrJndYB0s/rO/7PvlzHLkQyHQvSiFm2B4KwnDt+sGu3QxmLGsI4755YSD2GZHseTSYaiZKVg78Gjm8WINK2ViVoPUZrQ1WU8fBQR5sc1qzZE9W4n7OX5N9ToITLHaUu6pv76a2AhbqeBapE/nVJ3hl1G88BsSK1BcOEBT+6arktlvu3Vlq9J1P8AtV2s/CX0rTQ3sTtss198Dj0f12dKUBGfA6piqyPoRZUbxeh6KXCbe3f+eZ//jHUga7haRN2wG7UywAdp5yLac+EN1n1q6PKFpImsH3reHH+xNETYVJWc9bQOZs06By7P7bGraJzao3DeV0F4DEjawqAZG42hTF2UoZoUc52nWSRqnVOu2r6s47nOvKTrJnybmCSg+Fxt4Mtbz6u2Ug8chECfAafB7wHsdnBmE4f9jGat/Ipg9EaYB/cS15KRJMXki9wotfsMRKTjaoQ3lxTM6aGIYcBBR8BZqGxW7XAlMpRtEZeayOikQUvrEsMo/lE4IFyiGXbjpknFGcnpSG3ip5czf8+juKFBrHUd5o9gUR9BCYqr79sztlauPM61HkSBllqHJuF7Lsx0IbYPWaExsQT/UTe9Inx1QZbAv5UmU2YAh8JL15I6RGXw5/3Q2cz7h34tU+ilC1YPjV3oOE9jdlmdZ7VrKTrAQuHzjerA4iyfFfpe0HOcy5brtmvcGOZy+kFHn3OjRV8umZg/WLQobOLF+LN6VO55LVckhWd8uq7ZG9ccJjjJjT7Iy6XnF5o9NaiDi9KIpybg+0Ls8YU5i0rRfcgLXib7DPUsd1dPemvsLGPQGzdWYGfQ83O/2r2s1q/lsFCYqa3Fo6R18oN00yknEQk+qxkevPkLvN3OE0iI8gKBIxc2UJDKZs77aNZLBXSZgjBxDzZ6km3ddCs+eLfY/2eePe6biRUPNQygO++Y8Z+3XjsmT3ph2wOhb+rhU1iRnPTCjFDUWlwEgGaT6wQ/fXDKwXAYUPZCgEOss4N9JU2//aLU9y86UijviKD43HvfYzuR2I6dsbsbnYiKN7Syw2nXHSqXnSkwN4J4XpeL3GDjEb+2cGbNZ0p1Ir/p4gmozmIPGepRfLA06QO3Zta0s+wxoQntGaRa/Plawbbph3a4k/XGPfPTMGJnaZQROKIZ7ZS54DeaZT4VmhtHEVi2jCctl7Ie06XJtu6qlH3oYuJ80hL41Q1OG6TLDWf5JRH6dg9nviKe4zXW89JJ+uHw1GGsG4GDyX8Oo/MNWRevsH6FNam1E7xu1nlkjozm7vWdMijCpcC31F+yP2FKiNri58sFHlPO+4HEdDUs1LJrk2HirEGE7qLV5/ji3HcqHU5BIt70FTWiik8agFwacwJctaLSpm4QoF3gGB82QUd21Rqtp0dmeL0XOvlUu24mkVWzcNXFWAupLzKg8QMHEWec6zeBIsm47dLaZDLMeZ4lfX9/CLib2SDiyPQMrxD0WrNy8oZKeI0r1kh6Rwf50ilG1e1TrNKMbMDwTpUnSdTWjRIiRT0cX7yhpk+6HEFRafL4zvKSzlPxCPX1DCPS4dBqtnRdb9QSQRgnBMu5j595o2i1E29hwfxoaBuxzGcop3MGfMrqege5B0PKC6LG8EGTay9Dz2RM0Tw+6Zrke2gyZM7Nk85Ts1PX5dqY9AMOSLdgfnbsFic2gRLkZorN5599eBRyHs1m/25qhGh+TCcD8ib+Gqblb5PnBzJEqlPwb1U5JLBduUhd9chGKKuWIuOL4BHIk4ra40BlVqBYF4dvMQGcoVvA0FOJ3NgXdoKZRQFBrz3OLrBABKPrB3jIRkIot5hQ6RQGPf0TlhxzZnfa7JYHtl1oN04huD6kWJ4ArpztrhUnGqne/lliSBLah0kUDQhvdxokgfWvUj7a/ksSj8KzGGx564XnvTcKOojV1G8BoFO+W0OmmKnmUMTvf1VcEOYqVejpK33uye1WMg+pGiOWV+xiFcZgyc7XfSgKQgvOWwpJW/IHTuu4beFeJ/QFA8hH0FSdRNgjWVBsTXZuGYZirM5OsH5hlc/zyT6+Ick8MLTtqsFTGmVRWiHh1jJnHz9ZKboNKkwsWjs+ZOqWbIC6KXCrPF1qXaUg1aO4iOhRS/6B9O+Ya5Z6x57HaRvbq1xx3GicNH4QAD/71jJycvmPpWa1/C5hG47K9G36Qc/VQGUFl5MTLhxxI1ZSGzZUy5fl57Z0Bu6Vj4CIh4r3pSKNRA8nBt+7vXQC5/efFZakzs+hl1pAJrqjV9gEnHTmtrVmVpiOSokF+8RCpsPjmgzus7F+/YRvtP74UKvN5noB9UXej9YRh0HfIVOFyaQ1JL5vMq6I97b+Xxx7diMqNksLWEBIm+BceuXIRE7Puz0CjAHcArHUK7/azRiVLEIFxPDrKv0Y5s1FAEG8k30rEKUrEQdbnZNPG8HL0dLV88fZfXziRD7AzQ/1ZClmhMeTCuTHdgCsind8zRWPhtjjepKCZ4LA6oCt+tlrCZmmtk752j/Y3zmIt5j1T24dPyBJOAfbrF9JfBFWMzbj+CncRi33SuJVWxr0cibYVEzFraxST83q8CGtAUUr9eY53CzgVBCb7evzLvbT2UuweMz1I7NtrQJM8t+bRw7r6JWbfCglgqSclZpoa2whkPbdBkHXQNFVoHt1nROU83kzOIHrK1SLmA/QsdoDKhXBjwemkxZ/Cd0t0QLRRc1E+RfIdyEoJiehl4n2FIn8kcMQU2EsDCTWTT15R+jb5NCrknmBj9o1TuVWeR22Vj1+b+Jb9UAf6Zpesj9w42q24al9fNjtT0qdN0HlnHqd80flZi5/xvuxCimgARkHsxYishvwtxbuUQgFhm63w+lNY2xUZ7tRftVIk8RxyHdkfum9Yt+YXymNw+cKmFgidDk3vUGh+owtLypUSscZ/nGVjO3zpU07V+e4anWSP762JeA7EUjGo7SnSnag3K8FNVEZIo4EvII+P8TWp/FObq9fjbMZARYyYzMOMdPYlKDRpuyaCIO7mFDQ/aqTXEW/a8wl/3MwGiEu09LpkitQcGxC2UjJXQht4JBO+Ubm8cQ61DRydjOhJISMyik8gSKkdH1TGxiUAFC4bKhIIJSS/8MtODRIl5AU3qYqzbA5YaDWDiJiKj4E62p3N1HAir98c0JwvrLEa1UNDlyV96li5UmmsGVh9CHEBPjg6Dzri8lEHCpRpT1b3ca8+fd4AH7TWOijpqqblN1+/7CQ8TN+jwW2x0/v3yXEikaQHnsGa5DKEat2EnqOXSFS2qZyIwJcmBRyYcs13zuIGSQvrxYGW/3+Bkes+dPeLHDxFnUlCLd5CcSvnrAT6+JlxIQsi4+HCq3Nph4LkLu8m5wAL4fqkUQqnFsVT3JPg+cUkYhE3ffposRb0goB2Cql/os+EIrnfzwQpaca6bGuj5ZX7D3N4STfEJW3MeGqfl6StwAIc3iB1tQHxulcNQt5avLOBK5o2rC+lmXN0l114VqlchqaM1JwWSXUh2FlwxU+d45E59J68vZgrSSOXKs/TGYS7U8QQ4AB/bxQy3vlGpHWvkM9imSLwC7B2f0Eoc5lQ4/+9euGyq7VjkFUpPLYrA39CQXEMPoR5yk++O4g2WpDlYhVfY4NKub83VyqvGQJ9cKxxdjxI4QkhJBvvvHaDQY8xtfmjpCDotMXjD5KA8sg5fmQwfNQfbft+ixoJTUhwdlZCiR8jhGkjvONl6SFP29U1JZ832OBpJfqvfuCEaPKpneMEVlkdF6ipenu3NIarI2etHu8auZedoovh8HWilQsKCgIxtH1quOT4RRCZ+bL5MGaQuUMps1ZLnlSH8ZeofeuwFdoJP60jrN4w8kmzcUJiVYC4Iq0pBdYo+0p0YcM1iLbcbBYYOQ+H/+U7qAjRx6ptY5dSF/fdXwuWfOR9/5t1CmkdF0TyP85M6jW4WEarvKZWwE/W01MMF+MUEnCKUS8e7GOfgfrMjbjyKIwHH/76Yi976vMpqrYjAw6xPd9Mg6GcrlyfLKy4rEch+u8FKXaPCVybpkcizBC1gPgg2MB4FoUbdAGl6RHloZzO7J4MCo0bL/d070B9Cy34B+IRvCXmnsGMjVL4CafGlM3dg0rEnIWMybOfJkq71XrgaD6Omn/ycX8ZUZs4TeY8DfrvIG8rOqvvhyc9ySNYQwN+QJo1QJgLG23SrLPtaAsjjQHWgmC3Oigv9kxneioZg5fQ+IwzkyWSUg2mjgykW5e87Hn1d/mJ+nYNqYzAQFRtmEp7wkpIITVi1OhgxTtcTEp43UF0CZVKzArkv4OEI5Zc4bdMxT5jOjolvWSR29uydFp7vffJe9YRkgL4yP+PrHMq0zubGjKObP9k4W/MGHr52TgLvxxjWS2xI85Odtu1LNKr5rJ/U6nTjpZlzqfmgwi3VnTrMHm9B7NiznaRjLftf4mE6+ESzQUgVyP/TcN6DKF68m6ujyaa7flFld//k3RkS+dYmSRsReN5VF5w4e0q/jVXt4KfP4+8fzg7ZAlPGXKIppfds3dgrxHUo7RsY48CaC/NfcD/y99hePeVXrnv7IS/gpwSvMvcj8xc2HN0iBw9xvj/R8uUvkU+rlTLBBD281RbqFGn4D1UZN4qqayZkTfU+2fovPbXkE0PQzoHkbLo//sl8rHiZYZT7GA8I4rKPGDVmLVrF8pMQKVUreIki9q5VxNPa/5yf7W/wfsEEPQwg85+YX9n9hBCJqC85upYWRGgrG0IIYA2Z6ns2XbjWu9WB3QspTMiRky+Jvwgu4Zv1cSJHvS+BNJUsn3v+sIzTA6pTemeLvovDdtj3y2cDq7OxGnICaL0JM0nDJcmYtryvJ6xeHwyAMYpiAh1d8pNVqJ7M5MBQQW9tCWl8uaJRvSlw5mkCqCCm2bSnQq/i9SQwECpQHTc3rC9yaAWDztsxBsRov9g+3cQm5pqlsdNXRWKM8xJ5ltFZyKD7XkBoQmec/zqVppjpI2r/R6HkT/xKFYHkX5/YwIjUIh8IRzkMktn4aauc0X2uhAhqcJxBS3XlR0CBheGjiD1LpLPUD7YTmEsTJy8iEHy4zpZgDIFIIPAeQ2TjO50ioKqO374Ri22hJyXJNIFi6TZnY6Aw/cvMTXkXUXTGGNW2vV1SSwkej1+aeOmqntdSjFQtCzieQpq3p/SjEgfkxP39hjZKQjPC66wUtwnEDZ4cN4MQrHvOTspEmGT7wEyIqL7sUYYtgJc9u4ASZLDJn2ccQUSpzwB6FoHO/rcm4nd6vT33ag71atxYUqQpe7He7g9VR283XuVbE/RlMplz9qVpQQOOMgCsU8I+dJ2yjXPqXs0kb/4TNr5+HkRfQb78vTXWoP5LhvAKqtL7fErljZA5XPec+BT0IpeacWfw4LMjsKNPaAOlO21awHoj9JNXV7WBI0JW6rm5LmOZsgQS+OzyFlUaiUAmca/E1DtNRcMd97JwTggk4xfLIpwQCz2ukAUO29nPI84QCTy2YyjenawK8YB3n9JesQf/UpZd/ccnFjR0Vnx0Gu/abXchcgsJh1E02wenrns0UbBQegjdr4bOwajvx+P57abNYcOQ7aUNEi4QtFwQvj9vJCu6YBtr/SLEL+7lN4PYgiNrk+zXj/nczXmsxZ07iN1/itNT/j7ULCgFkzmdnSa+8xM0FcZZc3IgFAEIEWKEpAZsPhA0rWPlLiUbprcTU2Rbau0+zWNrFYPqvNQdVsYwrrPf22MohBkXcU19aKvKDiPHnK0D4b0X72fTPmm+7JF5A1MuNki2kL3cUn/74QIZ0xe6Xl4hree46QvQ9ilBhayHLWsjzhq4NGX6jZHr7H9v+mrmQdS+zQERl1HN7wPnmz1NoC390Jddjz7CtBA2tceihsvFTlUtZMR6gzBpkobrBpI5iNaT8ssNYEE5Xiu/ygrBzdN4NGcsONniY/jcD/LFUFzRSq1J8GzznJFhJ0bCKl5DJ8EmX0afl7QMeqQ71NbcLW3e0P6t/ri/4kKkpO4cU1SAI5Mj5hQb05ZGi9kqO2I2JLxFDyLy6A8pC5UroN/uMcNbCo9WGZPmt1JGlYJlIiuhMpmWvjp8bFND5FwfI/PJF3MPvxWm5XICNCySMmaGHhFKYvhuLwYLgJ5XHlK5SLxcjhWyY228llFKT6RAYtZQIchBWF7ZsywuY27xKH8PG/sQVQCSNEV7jB+h9crpM+Il+RTpYtrptRMAUW2WQ5tINDrDhjz4IvgskDANTsVKr2y+pYA1NgSUB82w/ln32TOb8So7BWQJP6r2E+h/8P585JcHqEi+Riy+p6QftX3CluAJvDuuemU1cXH3wlmP8t830Nan/FFmD36ifdSEJcsGXi11wf+X/4IA85DMv/zFtoDxM7swip8xzJ4MHudyA2miZLdwuafncldj4Rd+BAqE77pAj9L3UO+Cnffvkezc7AVYXR2h2Z+oTHGYjK7EDrh1RLqumAcB4aXq5BNCd8cXjbZGl/TyHmXCiSmkjzgCeSNsJzfmNNmxsmAGp2CaRc15by47SUFJml/wXSXNqgRo6ICvhyFWJZ3ay8iQNWVRlxyagER1k4iEMolcsqRRnNG/ls2HMq5rDXF/hYSCUCN5WUANzYbBYzTh2+43W9Z71umXeSdWnjesWi+L7Aw7WhDf2f/Wu6s9KH/cw0uCEL1Uvw5h7r4Pn49tb0/KMEjjzyIKg/dATh5qgQHLuCw3BTaRmdXocCrBcL5d/MNXJ8hanv5MKLOkYHjUwm824nz+HTpfKPDws9oq06y2C0xqOD3c3sQoiueKgngOlcg/JaY35FIx8TN6ootPZtGSKRyxm7IjWnwdu1jEN7v9+wx9Im3scyShv7I28mZfa1Fo+DcZ11CxOQolQwdboh9cJtFK2auTdwnqVwFipCm+R0tARYpwMAEZfNsNUCk4lJmvVLe5OAYxx/xaD66gFVQ7ZVjmn+Vf0570ZJR8bnqbZZ0n1ZteGPLz9xiGOdfSsWBzvaSd8isLYniYe7b6y+djCAhm4splNPVZOVbCO4F7F0D4Q04dJ8sIW/9iXBUYx+aYSuzY4+HjzML1g2UxKg+ZCfybT9wQEjIk7a3xannoqKIxauSmdv046EA6eFXNLe9y2s8a1UisldZHM0YGQPFUPfps1itZ8HQXdWMyAqdj3WBt0y01ZzaAvLcg25BtiPHiJbX73v4EW0MIc05dTHBT3FRKZunzRaxPEojbAP5wU9Z+lA1goHjPYGrNNe7jkQBTBBY03QpXCj4/UDeGhBui+UkAP8goQJQHBsWW2HiMrXROkdGUhvOXeTy4ZdOVje1ClRN4zyRAItgZIg22RhPboleHVYH58mX5N+npnjnkcC3x32B2jH/QCnixMtNpFd6sP/4fSgU51o3qqjG+VMa1L1lAOXkHFoBQp54LwNuOGRtWQWbzk0NwdW9A9xl5LdAjJJELn9Jrw9D24QBe9fTS+/SCwNzTyhh4imo4Y2gCbNW7ns2V38SafLP2vOqQtFtcPdj0Qnzo2ERHvfdrsOjNIYcemm+VTH6UQfewEHajPOYaAs6K/gdE4fTGxnB4L8gggKh+/cnoCEOJYQaedasLgaWZGfMOXgFCtJEHBCbyhPWUq4btM/1lL42/zvWt/Y2b2k/9CJDpngJxx4LJnIZRQ8URPYLtrLho1cBlqeCrzIyr5dWMRrvs+HiSGMcV1bxS1fvkZEiizNiFPDzqw2PMIaWaT1vHojw0F2Pyz6SouZwuLCK408ZVGMUhr4voqltMrLYup5oCiAayG/UdbhbMrHFxZ5jbRX1X5D2IudPxaH0ZVFnlkJxWDyIZpvaitt5VVV1EcNkoTAib5mkUbLdwpcCPcCQCFbAauoicnjoGkRJzS4ZtUFURmPqQsMYMKFeduNP84M4sbQzTXXPEXaM3I55wRCcgTHP5ZJQD7KlFxncplk4uKdFeCV6YlcvbzFIgHbcWiP3Asp4cYc3VACjHayJH16RpXc2kxdx5ppMvHK26yXG7jDMrgToUgjfwMS4C8V5u+Cxud4+U4tYnwLM0EQMEYXn5r8daHfFS61vLSdnnMFpJ6EPWq53uqNI8FU3AaFziyI/IPt01popopXxoi0/YkYzy2CiregtKZQtUOV+eAkn4/YwyE+uFHmQEh4gBPRoFBFMCdhD1lFNMGsJityL4rrhHuOE0kl6Of5OAw1T8koqjUvgA4LDqTpipNjxZiFbqCelmQWfuIgILJpAsTu5eV+0ZxlxcRJm5le+EABTbst5s9gAqrXMZDsY/iTuePnACZ4s9ncidy+gtRztbI+vP+QUeg5GZE9L4djSctZU7FZ5U7e/mw6luGr/cAHchHFsc7yikr7OxVN0DsE1+4/+E0XQ6UqPRW39n33nwn0RsXvx7fsHa99WPt1rYGs2xH46VipwrW/d5yq33IVUxDaS9/04Htt0I6hkjCxmaNBgRTaRM/0zvY8sM7A5JkKM4h42eGHxID/D4BIdbjhE/R6Pe31U7DoNHalhiq5dPvC7mvuy2THJFi5LE28/Q9uJiYpzuIdD2RyPf3mN4vQvzMO7fQGoJm26QZM02Pi9+bK/31t6f5/HEEPyUNuaUH9n58IKjE2wPIO81eE5OLeOMVWSliZmoXs2PgG1rsyxEqsvcKizbN4FI/20q2NB+FQqeh25UI48AFIEIojEN3/s0QutDXclW72Aus1I17A/610FPh/hMCnD6LwoCRmbHhb210ewZXOSOZ7Jicu6/gHRLWw3WjYQBQ1MMlSNRg+9rtgG3p9pjTE449JnbRNzlNojDMj4VsclONjxMjvu5iGemGwgfYucEh3nd4z6jMxBxMUkaT7jSdVpeAc5Ha1b5hJxJ8jQImUXLIOj8WuubtBfy0aB2lrsQ26Ec1D/y5cTQ/n/HCP82nZh/TpxA7n9/jsj+3ypjcUmA3pQP3YJ07Gi6eaXrppaNsSFYvaVqlte4HUCa5adoFRSz5mnHFS0DDyNiWaaNWDI5JGY+Tz5AZ7vI1SNQj6oIzrRn5sjrno0Lkkv9BlP0HK3fvxqpluEnsX3ER0MycezVCxcoEB2W0p46a3Mb2Ddlvqg2zjGFk7NaPymogKycS6+8A6fWjRtIvqc3tpFJiTfOtoR1aO4Xm/XIq1Lq4ul4bbCj6biLBX4hqe1JYF896lNITQzz4WvhvYEw81Cg/BtzvA0Acu6foWK+mzPFx5rePB3090UKG9B0434yFGiLllMiABmSKcqR/6zx4MBYr/3fkBk0+fk+xnUyr5N4cfLAhtfZb0q/1a00H2g8uic6mDj8W/Htsg45hGf/Hltoz5kbvcR44oX/ZND8EIg8v/5zDyAscKJCO/RTNCAyVuGfYb1OqxXA2WGIaghHQcvtUdHNEaUXX+RNRhfT37DLKBMc6JfGmfMBCupgS6/s/g/KbPf1Pw5cNkFUva4FUYKdnXODsb0w6x2PSHDxvWutE5IkAlFVDGz8aaXpPWTr69uCkNkb+lxNzJC01fxuLj2NsHfTAI/w6Nk6iUSYDWhmBHEVt6d5YrycxZPS9TWgbiaHG1tDgVqiEh+WE3Njd03e4Wxw/IQQ4zwbo9Sz5R9bpK7qf0tin1OzocBjFu1kH6iymPXSRpPBMl85FkcMjgZkmeonRItw4CGw3/sDmMfBQBJKZU/bGCpryew7vehpn+Cdom5wS84kBQwaXSYT/kCnOevH3eW1hTd49yIKbk5AuZkWYgepiuJl9ysO4sFnrzDd7DJecaAPCsRZCprilGLgKCnvPCYRtTrXieD8bzsUYAb6lhBJh1KAexLKX/nBSdMyTXUVcpCBCn7nwYpu9UzX552Fh1VQtFrX2eCCcX66v2a7v45WWqphaiWZaez2paT8vG05DSLfRoeiS/ATTu3eDOyaJXo2D+NEOyY8OW5L8wJV2c19wt3hjyYdup2oUfLq0exMSPb3t7jSoDXbVFN0ehR1BXwfabjNugfWgWIzdbdSV6GbKNXEEd8abF/o0ZjJOk4wR3SBXaG8vpr7IDcNQeWjymiNyx8e0JsLWHUWybONMNlo90201NWpxmgwpkKfnPDE0dmjfL+ORB3brv3FWR3UnuBGDo/LdeEICbPG9NZakGe225u1yJq5LuFWfLxl5JEJcf+qJIHHbByJ9dwsVVETtwTc/BrMiWe9Imdfk8JgENjY2oAqRzzVbw+6T1Kmtj0hdmIwmgAB4U3ti9VYBJs7SHf7tD98UyJIqT5/funrylvzYp5ZyYKTMbUnuI/38ljaZWOq6jRLe2LzPkJmIPOkeO1fVcXeVJYKknKsuk8/X7b90IJOb0dslVymfE7y8bOJeDIkiC5TeRCzMrXBgJe3sj4UtLsJfUCa6fFAplrPmySgTNgcgHjErfmGzh7EjtPzd3QH9tNEwk1GMg47wTbnHFh8vrkrzv9Ocm9e0cmxORDRtOxWGmLTHakAt2KivpfHI8PVtuK1amx96rXr4uh7rS24ZeWftePEPUaSiPE27BZBs3QOT+pMdWT435g0Nm0i+1RyebBasu+1g5wyOPqjZyAXDzYx1ACFpoXKk4VERrLXL/ElyMVAgiETd7PZQrhpYjdRKdTeZpm3Fsaati5JG/Mgp8dU0GJzQc4H5bOyjJMiSzXcLpkQ5/MfJNRpcOsM0VLYvRDIp8RQN/9D1PNpl/38rSqn8mnSuplRyDSoo6iSEileBCKj/a+ATH7vYx3m8CRKwNLRSoRYx5NwwK0FioPP02Ot1J0hFZUimNtVQHNvrtW4E5gb1V+OmmFaAyR7eQ5pPLwb4T40IdPTNyLyj5GRSaz05vmjtRFeieEAXCKR7vgoGxFIgLjuutbfFydRY8G/3Dt3MAqOB/1x6bgNodErX5OiX19SeyvTHCYXT4RULKRJE2cF7yD1cy6b8WHP45oAtyuPUT75v9+9LSgeQYJmB8bKwg2BCzu5g17gNFVcE4NJ8XTykInZ/0Bzd+dK5wVvRkVAVBpYbD/BWJ+8sRBWo2LjPETtItzNY/rQBm7wVyESLpyoz0uGm9nGFkFnTXcOXN3YlybBfmdzxWFZgL2ElWx3n1JQ4ZycPee/2BGXnA+eOQnVtclvB+FEX2dEmSQX+2ELFAwV4EcWPgGfEy0d29rd6+aEb2pYKKj/tG7EWfKiQe4y1opOLlbnRZl+/skf31J0DiDtxkWcKQL4tq9x7nBYOQJkHnLkRXYX/Z5A28oXvP54Lffo4T74mWVdUSAaFipyUhdaJmkGtvKCy+9Hmu6F1VPBV0hkxqO9En4kBvCMzb6/Gud/f0FZIyYW0WqRQ2wP6hfqj9e+oAIcESH1sZmHunFgc+bJac6TWrSBW5cC+rspozWd5xNxHpjZlTH9dYZA5ywPC5VezivbasBAkiPxnYNOH2yo0zjeoNxVaJfJKhWw8FVA3F1wYFWcgHfMMWs9PumBMOpdfz4hJMR01tGzsy3v2DzVxjAnwE6DzRfB2sMOulsel542+gJ4EqeMoV2+FhOyRvABBHPfGMMWslaQcpUxJTHWGVNUqgogSXucV1VR8AfoxAJS41TvHzvXeMTvEDXosMUjCRpoiMcba+ZBt7jz4RmtJFHVlPgcEuUqI627bfrkMzLwhLbAmff76abfqqfporxhljhn8ht8ZKcn0+vMkkbEOVI2CyyDHpdEDOynpkML8qGkCiN9AiqEWzYRxqXLv4i799X4pqkx0a/2gUGndvJOmMJi6jJVmvLDpX6xkHD+KaHK10sGvYU10fo1UdrUgjcL5pHB6ETu6MoKcK80NPVLngpcB/ZCTggvFblXDQTb6PqFPmLceA6Z8uyr14tZZYilxL2THSZ+3Ex5Ga7+vOBXyHRB3GpNsCHMOu+j2qeEWxWNKBt+lJoz8oldMUwGlzDNFj6oyhk6xSBvoNf+HoYQRYSnjePCtW/1TnpRrd41ugg1DI/3xkXESo0Ga+JkwjjTLK0YJ8eNL8JyJd4XW49vKCjrMgQqwSrV4M8+KdYw6pgxVCU8bnpsb+jshhmEKYfkXUllN5dLCkVdd71ZULouHgQZqMnIgLYhDsRSIpjFgMUFEGRUzhlzUAO5AwC2o80RXKLiMjxRbxEStsbMAgMwycAzHbJH+BqQ8vIkuWXN18iblFUEhntZFLrs3mtgI+ToRPaYlTXW4FcJLPyuc91SF+r0kYXCvlOY4k24BoSsq8n36sNGhj6sEDEDu/rhBQOGstUh7EXjWDWmQ3OF5s0JC4SPxeHE0dz9h5UkJzylaHSm6LHca5rDucuGTh7zsjMovCSLyOxI+suS5X6UtdS55Hog1xVKHv5rMh1QAuIpOU3irkvbeyXKpdTFlRq0zllFwCL5OtWI10/pDASRUwYdZYbpAtMm2sDG34fTeYAyZdhfXMLekG42KgsREv1iN3AGczeo7s6qr2il5whSbNFzpr7eT0Lp+KSubY2AzO7zSm0vJ7uj9SoqRygx6XqlhjSKgUw5lOp3vTu+UD074YU6Qnk3WHsLrWWmVMxiEXQCVCOAjChPPIWDxEnKSaKnlQxkJn9WqEn1SzrlYRWzY80nC1Orr4TsdBIbwghnPMhxRYrKq07uoEhmJV/gr6IsyALyYB0eAiRXHaFNyYkgHmaFswqBT6SDL4FoL9WVhPTX+8RcYsKng8zmKbU0dAl/87yG/o/IbnrHfVpF1cnjS15ngjQRLQOItxGVPWuw9buNUKVYUMus9jWOwUiV2zgVzDzn/gCfJWDIxtTDz0YekS1YZpry1gxa9N96SNahyA3VbXMD9aoIb7uTLcyKjW15kVenr/1GL3WjKd/05QHPXAG7NXKVc8/1Ns8w2IiI/JYVSA1bRXRKnR+mpXC9J1NSOnQFarBDN1vd6nZYofJ+CIasvTF/TuRExeC9+vLGvpWQJHQ3M7NXCctBFjkIpkfw4tgnKntLdsTo8d1ktSUIKtIHKLNKpt16lBIS3YYPuieNzizH1ASTKZLaxmaFlqIgUsfmT2KblZbd6OjdgPuMYUYnvkcaJsnp//OIlcbYJphir7ydt7yUYDY5LaG6ROKdFNcW7opYpVBTyif51DdQBw65Y8do2T48pShLrK0wQ15s45ZmxI3pFVnrZKQ8u3jUcUDA5RBU26KfmjQSWtHZFg4XXeI5s9851zoCcI84hhPQRgQXUTH4VDAUVP99PabiA1ukpjbIQjppdNAGind5Gci2EKF4IbQSw+vv9tw8OF5PFyXW0UkpSf479afn4c5aFizxCgMwz9emY6FQ13mZqyDXf6Lfv326ol0mniA+tT/Qlhkamtf9kCPKq3kxKNidif4j9FsvjCE8Phm0AeeNBgsMrk99XM0Qfb7pIgMpDTR/AZfcPnv/eXgncwjjiEbJ0xpyD84KYDXbczZM2Ar7tfJ3mlqBWvzUUA1Pep885cEwTP3ms0fsiqSKi+rKMmGSKKR0YZgU41SvHPc0nYEdkoUnvlwd7+ASxTEz8YVoFi0w/zkziWLgy/Yez+cxltTlJYDHHFTTurpNkaz3Pf+doqnRV77mG8C1hmqJ4m+tjurLgup4xvHF3mvhN3Af5fL5DQzNzSpfMFAlZe3qeR0BTqgVEFTs4n46qTYIxE/1TwCr6AlvguiIyywycD9kWJZN2iA2WkMqLSFM2AsaWllbWlpwvVet1R/ERKcyl3XMrk9rBtfi7oLbhsxj2qOMvGitLVB3A9TfZGrzKb5FOH4OGSfBlJtovwlA6ld1SIBdrCIA3Sn5FHp06UoWnrgMJPrOKbBQjwFi0Mr3QJN6YEEoaVpcM39XT4ylSqQh11aDhRK33xW0R8TfMa4+WFd4hGQKnGgbw7yDgtp/A1o58oAZe60r3oghxw5r7rjTNieBxJjUIpIAjDKQiOBeLrMjuU54qQlTTaGlEkWxUbWH35D2u4HVLZha1Lic9gsA1Th6X2ngMUljRo0aTDiV63G9TkpoFJ4aKXPGdlQ/vWUbg6NH8zytH+t/tl7eGlg9SqHXJcbUs0QIqWfl57UrInElm6NU4DlGmv/SkuhbtsTDXQcHWR82xJK0hnZi+t6Jf7iBq9nLMRGx0VnllKPjFhjlydI2z6QpXVh3bFJnIBVxnGnhJreEn04R99zV1sK29BqPpCktS1UlKdCWhQYZIBbkbOOxHtEADFiU15jTuJY2goSK7GUJQZSUGXXruNJqVSEZy2s4XqFNlX415NMtnbxcyao/FvPTgVkz8yHH8fnM37laZGwZne35J6+qe1aJmPOuYxUjf31/ovvG7E8Vhy32d8asL5VDZHL8Uf+ABGsmRHfGZa+U6LUSgddqLdpRmOIFCG1u3u7lcS6ngcvxF6q+sLebDMoAAx9zM49pkQEkQy1vKg/PcnyyihOSSW1gS7LgJArAvWRXNvgM06Dg9nedoZALwT29+WZUlqfRFwdpE3xHqGUvGU7LPiiBwx0UIisxrgi2gahJzzsUfOfANz9YOV0tU/lefiZWPemfxVyuctJBr+dmBE073CojL0oEbDl7j3Fn09Htj9LFIy77cmf2bn5+m0bmc/ribppt0pjBemtjnEew1TJ7mdpukY+L8it2NUntfv9rw2L7LykZrUPuqxRXqmGlvJVCucEz0uz83uQpMrCwrUWY3QXE4fQQZ5RYme5N/cFQ0jbVLemyU3NC62Exs/xsBgnxOUd+0bvwO+qHjjvH+rCpT3JyqZRVGskklg9mjiPyxAIXkruRLwkuoch1ZbJxhkLfmPMaGIDV+y6kKQrHVMH9hzJV2JReh/cXFtwkOvTZFBpbOXi9J8Vl+yDaAOGhSDNDBkzjNM1KtuvE83n469fZdxBPd8rqc7rSusqEp/M0HBk1WRR3hTo0cWO/ZoHbA+lAD0rbg5ljTnSo9CqAHIvS4NmCt1QtFlh/lNtDmHd7ksnLlbeSoDZy+ZEiQSp3v/A2uuezCdZ8QYRGWselkjNaGpZ5AYKMEQhillnjv9alpZDsuAV3MPVDWgyhqxftxQSSTSKWy8jPwQ/IvC7cLmsw3olyKrsl7qP2yXPqB5YIzzpWk01ShFNHKbWbxZmhCuox6uRDhwXizWUtnLjRkJGeozEY9X3SFV9uyfUJ4JjYUf3eXt2bP1CAW+l1mBUlZKjTteNYXEpFM1Bj7/Wv5enJ5GXedC8112ajwIbMFNmDfI7/UIfUpdT04GbJ3YjG9FzL4+Oy96B2AXC6RwU3heSY4CEDR83QDzPwPKVsMxWKkTeJrtwQKrWxB3lX2KVl+jZbTd1uvd5AswJSI+pLg6Aei/aRjP1bu/7mtK1GXXsEJw/v2LwrjVLrae4GhEyJ9R+obm80cIQmwJa6/fYa/mbsb7HSqE9dTIVTBlv/3tBQVYAoNvs6RjgrgRxCOB4hSp+GJQZYl+cMs/DeCZP0iDs3UemAtA8rEv7mAq+voQNFwRxLUJWSyTiPAnmqdP602yZoDiMlrlbpoS+GAGZsRo2EwpBGUHRJX2yyPuLMG/nx7VMaKf4aBqBdQNexeYUXR2ejSAXEm4ZsVV/0UZ3Dbad5f/db3rSJ1H1zHfGQgZIP/QjhvOGIFJqQ9v4w/7LOV+XQAEcw6rIqlAitGMYorLQakOtm0DodrmaXk6rmSEppPujcRp6i8xIidbvIJpIzEjS40A2ENr2xiID6rouytNCCM37WjWrD4c9eH2MkAnbCAvhz1ZDC/60u7Gzh0lyIIzAg/lq0A0nF0IPuDKn1p1mLGywXKnPaDofmt4MdZEgEKRggJv8L57PTvDIsjejoUExHYAjRuqbcB3IXl1brJCIGejli+5/whdUzZCqiGW/H9QojbI/ldOvHwuBNdxyCiFIJa4oBzqbSUqiJGJcPqUnQjDgTfMC2DXoHUOovyL0AsUDCLlvAUgD19lDqHDvz62/Aw6aSgrl2N8Mdik0dwWsLtPzUqneSnKRThpAQpwFC1SF3UykPB1eNTe1EIQ7HPPRiUciUwU22ZdveIzbTm68x1bw7SzLRDFu0t9g4I2OCxo6frfoI9oMq9cMTtQbo65R32OSYYxtSxsmpn0AG7F1VH36BnnHHNpgrtVABQUrjucAx6D+tgySsdbcPCItmxWsnPR55SjnV/hCLrooM+V1J6qrzEiandgbAkedp3kdjGDDWHGAO+5RsTTCD9JXviNcrSylYtSuXSf5eeDuCSAiBD2cfnTIHGWiQYHFAgSMHI5R4YUcTsIhG6K5GnbKPwPbat1N/G2OKsjESBBD935Q0XHc8Ww0LRBPCy0q86rWDQ3Gum/Z2fNn6ZwC9UNYFov+XFx4NCgVGXbwqbbMUDgc23l7IRV0f68xXCgphZivQGt+LCiK0DwhE+KydJ61MmzczmEkvIpDnhrT2pUIoUuu1ACjkrh/EEv76/KXeuMZcyM6dbzBriFJmP018jVvgKbbyU+nmkocQwH4YnAURQ3GxxuOA2Hk094FpIdNqenSFz3uU8JKyte3O+1jZunL6TK2zVdSiAK7DSGbQEcyq12LmeUQiGKbx9/1b0MynbuKfG4X9Q+UurGLBy/HeKoBEzltunzGGA7o6ybtak+MkGyl8AkEMuRqxok6424g5uD7xUtdZ/WQpsBQcI5NOdSCucgWsS5ti7c58AwMS2VYPU0/OLY6CbmJZV3jNnvjB1wYAxnLf1ZuzX8I0Et3Nl+cykBLHoUGBudjMtLeUnRGo5b5rZu9uYieiBJO0guVyN0DmVvnC5KrrhkcZ7fxvsurxZovKe49a6bjuSnXwY9NaNkhvkEVkjZRcN1tYfqYMNHs16sKpvxF8zFbAiUhE7IJYpcv+F3Ej3e6BmbbXmORQYmHDhC5O8d28BEOo91rZe+6HW9zvsfLXLvhUXVPlLSRPy5zwTiJ2QI16rgil6BCYTHHbEXbKfw/G9wD0yki5QZrhKMwolxa/L7pzRFITvb23APq5bfFevTxjc/PY4k+ahHvFg0645NCNShxVqB2dNxgXWLP29GoP23o0XfEGQdsB4rPxVcb34iISQ/zHkCMriWTOQ9XkZEeR0qGQ/+orPeJRnVvO/hVnkAVcdqAq22/nfLmdDZmtb0I6eN4NZqL76+VhsoFiQBhEgPNOd/Q2r37WO6l7WngSqNjNI9lf4CdXVjwK+w0wBSxJ/3q2qAgMYdGgcxfD6aJHYRDMGfbzB3b2NfAWIz8t1GPKzKHwCYtu0SRBZ9cl9NGc7Vgay4ok6qev+aciMwKB7Sl+o/v7pyqqIFg8OCbWqdlO9aa1moErVkfrFtolONPcWf/ne3H1Ku+fHuIQ1NtfK7nvT2EB9IyyF+U7kt876arplxLguPk0Aw3t2m1mtxCcp9UshXZhi82I8I8SNTeZwBQ+vR0l2ewd58zD6GvbHL2AoaMcuYQG3z3MOpYiPv1XCH+nP47Sli9l9rDj9kPeLjo2SktiuFoQ8wjgpPjiAx5olabu6vw67EYOWkcnsxMPr+4gUImKV8VouNFgAyS63VWwkCiAO70otmjXX8WENbLAr8KQGm2My+XJ0McAm6xI3Fooynj+Ss55EipYiaoCykDgFlTbBAhAMJrOKosah0H7Z0xj9hxKrBsPXwFyhwgEYcyhkClc2bO9bK9fQT1noAYJMOwyL0/QaE9GpSO5yihIHGiIc5OG+dXh1FiU25VpTUdYs2H3S1ggwJ+sWvjW8xU1+1uMVsS0cnex+HT5zmGVXeM+eMKqQjm7lorYXUsowVGAZhsX29LACS3N+FD/1zOBAz703o7yaDFmjgHC7jwFOG89VTzjWWfAGCqDB+L07QHubbujlX3dsTVlWzLc7BhQwXYlWrMT2b3PsBw8OeWOGfO8gCtfHd8C0Rur2zSaPqUenEwUkJdAflx3aln6dsLNOTyoCqao/4LKwUkQpOGdt93Eg9AgSUn40Tr2jB5asLGwGATeQo3P2SX/ijLUfOzFPsU04xi6eYxjRB1V4z/6nFCwfH+esXsY2gR+O80oxvydECedck4JzOrnk+Qvsac5WMgyf8hIyMOEqH1gbY2U5TBs5lIweH1MvgXwUfJzzjgP/BW2XIHPOBiabNt5OJI88D1MLFSVtoMFqEuNOE9m/dKrH5BVQ+xQ5I2ToXvEeZYvn5KjBqp8CvKGUmffpnEYVirTBkv0CHjzokqPBVMdJIwTyNUcXRjjiSWeco2XaMqnljbTmDtbh9RKau8+JTkuP/Kqe7V4CjSfDhZyOgjQgTJLoFkzYOo19987EWchEgCOGK+ltLxcuw9Hp3vNI321ewpc/o19fMo7TlDuOqliV77SxG0elfjxwug0KSvJ5+hGAI/jWkY/cnP5EOWND1Tzc/u0IIALvg5jJ9oMFTezqcsi2r/uWxC5wy14H0Ll0ka/FyhwOC6kXEe3anSVXU87jJeOhuYjuZYUAolh660+sbYLA5usXHRYsR6dQ5CoMBSYHYAtB1HyD6HprwpUIuWaNnqftEyYf6GrGKIhqFnmkW88MhGknUTFqAVil9kDY4hbrnoROEfrbkAsnHV9ADgegPHd/PskftsX+bN1kDCxwm87jYvHWEOPClow76iAlBW0uFNs9+6zOpZRkhrIul8ugjTfMNE7NZUAtJz2sHD26hhwI0SgFISbZas8wc2Jj8UXW0I+O7PibZtvmPF7tn+sLAjWUORjhCFtGtkKn4W7lOInrbxUobWz6RCW7y3uv4vxMA002VvRkbKRYeiKUSS90YD4sfYrqULtPlWqNvRqX+p7osAfvHmTPiTAbuPtCbi8vre9nA70betuhQlD8Jw4OU+6YZPLuQuNh75j0CR9P8nn4lDWw61UU+rD/TRZDcj1SMI1Lxx+Np8ZQEIJbTlAOgiMU1OO72bd5XCAxlOeIL4GGi4bQd6aUlFny8X2P7sflBf/s1ksT3u+cudqvBhjwb8yK8FROzg/O1N37aOBN9Hc5RvdnsIHrBr/I5lVQUYQ0OiIbSqMaiyq99IkvU43Dzrsw3ebx9DfGTuuonhrDN7wdiB0bipdYUxCBbRnlB8k3aHgp2lqdbqMU5uROwHS86RYa++6MHgg0pugnAOer6HqRK+2xj3mSUynHkZzoliRxrYJAzBaUYxcnyTDISIv56JYshHNiZzjfIma4PFsigo3yE+vitKWHLyf0zOVHwKiTND7s8/+6+P3Fte5atnoEhAXFFETEYK2JORAgK7bFkkclT1Hsu+cOB76u9lYXWyQEmRy2I6L2e54aPqFy+iZEK9nnF2gRR7KZWmFDH78q8YB5ocuXDq0qtwOtP1bKqaNZv/NPtY2FuaeElT7w33zJYmaM5ShO4kKAoXoyILQKwIvoo32vTjcStE1V9q4z2c86jOwirWsGOq5ehjQAggo6n2kRFlNk0iE9qwFkdeoOLorfAXv1lNWX5X0DM9OJdR5OlFmnkXFxGRJ9e92YJ5/1M94rt59FIbp7wCvYR1bnHEvlSeAXbvCBZlIbiQy8DqxnEfXOwmBO6GL1mSxWpW5aHVa4CWX5EzBNeARmwkrfgyfh3mP0ktqnAfHgNfKQrtQ9t8FjhPYJ8llo4QT4AaFnKcQw2LMZlt/3/lXE4TCTP0JJjIruQMKI4Aasp3dklnk98cbBM/4heyXBTQBl1I8aWAFRLzjaAormzVoGt7eJzVEJ3hzFqcNOlGeH3AOewemF+LzKl7Na86ATqAhiqHSBr/WoSOC9L5b1Iym8M2P00WNOpzrKqBCoAbjSTqfi6albl2QBPNWhmKxOuasgrQ+XYvC9uLUMhBnyYZdACSXLaZYFX4kq2rS0rtgXVb3yUlrxhYf9yRRhc22W3w5MQyzSVhquTjKSKidYHTHBy+tOseCQT13YMxnPPJLsEJxkGG9EnFD1YzR/XgOIoum4Xje2QO6E72RmrKVfcluBQX7Y6ITVoSAxv6CzuHLF8MOllfg8PlELWsUeow0U3Ob8nGH7JWLcL9EkHoPY9fRSPvX/DJrPA34Gxw68CMxSMYI3p0XY0PV1dzn0NcEeig2UUtHB14WX3dtnl7bEZpME7XWCaxLH+YcsVeYOFMeUcorkj0lI7CwPTbMtWRy2giCHJw/PcYgje59/v9id0TcBaHt66CWy74XAeR8g83K+FZ9PGleAVcn+oRbnktv8cGgFgxRL16B68KiR7kmu8uqKj6TnZY6B3ZMHLYWC5dt2ih+BKqxUSkRctsX4NELucpOEpYGHugSVtJq2vbTp9Hzao8ABxxzPRxXA6QnldX0tEe+m3y7nb1kQPOB5VreCYL9TocwFbp8RiDHDjtIA2+NKmEn+yo3OK8Ri6jUG+g/QRbjlI00ZtxAol9smLcK6o6TeKwlMjQ0KTWEcZK/Ic09PAOouZ2JQSWd4fyi82QfvL/5qLn1BHUr0aDifA/36KMIVTXur5kty7MJ/jniMtNFevQ2mCw8c3Qtb9dlsCWII8DLXYUJmzdCA+Acnq0R6z9e1ZWOJBJWNAZaqy1QGkGFJIqsdxhCQvvesjmSxMSsgVQNZ50Z9y04S4Ie7aUqnAMTajgQWaeGQbLlHktIrazMwx438ZAL7DqOfj4hKD8kzH9cxVMdTebZzVGdILi9VKgXKSMByxRKbmdnsCvo1F8JOGUMjNNH/gVOWkDTQu3j1XR5Wh7XD85G48JeQ0+rL7PzbjIR1F0aqLCzs77p1VNZGho4tZ+miC9LyCOCNXy9mZ6JvRlxGQEWu7EiN6p6F6nvhtDNGexTtrXZmqnXdb/xAohFe4nouMztomQdjoT1hkXdmyn2OGIufQI2tcwVgAtHNjpCzC1O3fYoVCFJdQVIp4MtesGu7NdkgSavinnkWVSXAHteYYHK8P8W/LvFVVBCEu4s/x0Z0OXM2aEg1rl0Rm8Y94sVZu4kvcggcN0Bx9guUvdpj1oGGSoF7sLdShd/a4g5qL/NN+5li4/OdvMiaV2NZmYg8CUr/Z6g23QkIt3t4rAKjg6z8Ebote4YGbIrM0iVb9PLHPhPfEvta1UBvBJue7htpU4BZss0SQnkLW41TPmt4LSOlUbz1nxXRzrcvAYGttPtMclhORLWmSacwISVMIyn15/LxbOJs5aMFm8QNTG8OEU6Z5LVo8ebOwY6klZbnmeyQcwjuXmzY26hnT8COQoBK3Vp4pdJ+mtmxDFIz7rhBA83boY3ZfMbG6RFeSWR/eWbs2TmPV+WpEwa31WFj10BD202N+IWOlHGMQ7mWH9VhV0QuR0bwpTDV7DISnb2MU/rWm1uaMxQKpwV7J2rSd43GoTKsUepT0T2t7G8oT8fpdk3iJAXlbljhjc3f3PBiJJ7EZIf+HLOns6Ac+xyGWVGvQVr9MqxbxvtGnPuLRyB0yR/hs5PnFuGvcKAtRbcDyTkpf59dw9nj9yIyBcqii2fW1C7isFK+yotAyK1Ae/US0mj8BSHOJbLUbZCIno3QYNf7MBT0phez+IyqfJTX/C6wbMZIpmUD8mpogk3L3Nc+jPOJR0qBYPenHb5/NGq3oJs27EDDPD2Oj/QDz69G/gA3wtrlFkeysWiMIaCSL60hQDIJf++AJGeTpv4+ocGPbjHwT0I5loFDeTwyFn9aEIN+P1RpdJrdfacHiBiZMAkiE0f1rtV8APH2xY8jPiwdHgQqWHWKbJKIcWviDrlw0aCkgLpQc6c+mFitM26DPvfo21pQ0Bow9IsOZ6nwRQJSqkFQYPH8dn8/c+IQkZqrKLe9eYZDetwonsoP5VsZ082DuVpKFZ7URbnr/p+lLji5DXSz8085tGkUKVW0HTiQo1YjGjLJI7OL1+rX51JxwlQIcNVIUZ9zcwIzHAhE4cXIQ9gqYmDAbAlJjghhA03hoQ2MUg0InIwDbSZ3DywKxTdsfIX+4CaLWZR2qCD1OC51bjYgMrZbbLUOoCogqfTHUV229OvAkcNcncx7F2rHj64UVMZUChLBgACOcrj0DhEFUOswy/X/u1EiYydY0CKdxs8yC0fHsCsTSgb2LgvmbjchcaYzPysI7GyS6ahlCFJQWd12tXlBPpCXcpTJMHD2zjwof8PedMgHnSRBuCaNpi0f/7xAFvGnvSAL9YmqNmyjA485WUy6AVM1rS8GVoFdHEYKz3yGMY5sTNQQ+YImqjmXW6s8ZUpZb91PPHvJLjnPvb6Q7nmYCVycIIasjcHzlaV4lTlZAyse1mfmg+/IO+KugN3EqG1iamnyTydZptv4ldq2xIvoy7GAxsbsrnraH3mjePvsBO7CIx/aoKvDG2iHLX13qfvveaCAGC1vFjzgoWKHtRAoO941KyhcIK9r0CLaA+SdzsB1Sdsc8CyjCAZgUtPu0IWI0nvjSjkgL20GpmT6nKXZnkxKBGzMhMHEqTmiSHAVoETgGkZRcHPeZe/g9fU4hjgvzDvSvo+Yb6R4P2Cht+I5WQcBWmKLVriB58MoFmI5/9w90okPUynP9rmg8Mf0FDk9U/5fM+Y9dG3YRSk7fj4S57959rNyWTzRR/IEzm7nPpQS0vDT4knjgAYOY/MBvZYf9nWIVKN9SAk8Ys/TUSxp2l4mJ1pWpZfRVhS5VHWdz1nNTkFnBhPVrwpxIkV2gmlCxXtF6hvhSp5VBNZbl9i3JIVkmT6OOTAbjRdlVOv3HWbSg+kPjY7dmQ6MetcY6yq9wRxzlJdmbsyP60P4i1ypC0UAkiAcKh2DvJR7/HNvgG1jAJaM9ejnbnCUKnY+ZGteXJld/NbFRyXxqtVlua7iyRLWJJDbD5v+S8arXJbHKFEntqJy1y9FOVK5f7emU5abKGIoWzldqm4Jz2RNpiQBZRalSBpklOA4FjEOQGID/lw4lbfMpnkzxjqnIRaE/2u9cLENJgNTAkTWWHAs/pZf5f6xYxkbMdxcK5i9Q9MvoZTz7jjzU5Yg6K1s95YrQ9MWOTe88BNAUplnA2uYPm4f8GrRGFD6cvhdHTttYmduYnW0FFUkWcB+abPxkNLhMUgnUlBaOFaPansq2MYF3a+QzLb/sVmoDD6bMVUx0RWfddX3KhNKercPSdrYmucDXSrQ8sFid6pYoCVtnMODljpoKt0XutnjfUkisHOYZeHYQYM1dXVwKCZ1EsnL9UdUFUEfF3d0voHBMzQTjfaxpONI3GDxjBdhpIisbkzKBHSyT2cRAsG1ntb1visR/dm7nuvi3daFadKIrFT+wuerzN9Gv+6+Chqa8Ytf6waOxG9If8yGT89CuC3VfUqyZCoovhZHRLjWgrqx+3BNwrGwTFmC1bjDC75SQhglVBzTxSkMHt22gWBn33AlRaDlK0L6slUjs6TfGW4Wo9+H3nzDlpRjjv924DJd4VXaxAurjxCsl1tNVgt7jCPmSI32UG/DGsxw10Sh4Cb8mBI/YlDhmlyHo6Q/ukLRkIozzuKsup/SmC5SV6WQrVl8KYIm5/fgY0fJXmxi7+Fb++W5SbgHZGzHYYpq04GnvguTO9gkLRj3LGxAz3I9oWDIQJyqhX7XRZEgtb5U8vQsjgL0Gkjw13FhuHC4yRoSovQfpU08azL1A2csnx4oIu/nScq2w+2ZNC840UAuz+pO6HrN/2SNP6uqtLTiYbFsFomr8ieZpfT/X/w8y7i0aF56qgEYgwPEi6q3rQsD8v3yMMG2xsYVGdXrhTzDW8hKdxBBY4Lrd+QVihoK5/P4Ok+LHRcvtxDIn57HgngzuqRTrce7SaAjHJ/kADzhHjgtZd8bK4B+LJ//SCQWdWhAanTUuztCk1VCnEbbUbMORyN/8m3bSJqwv0CNeD9yYwMAM5CldfmkeC7vgCUM3+oBHidhmnnMSryogBiyaz8UnejA3Jj5y1qekJqipv/pDkZVox+aSTkmFjyp63jH2VjLhFUc+xsIEoNdQbhpbsNg+goYPXs59HojoCw5JMuHEfz+E5upSJL9EWViAj2E6/h5EfoVR1tgvDAr5TrGiQaIsKO2jRJud8JITfolq5EWaKGaGAKidWKFJ4RgCTRHuraOeyDcCboLfz/08mx7IA/XOKSj6DiZIpJmLB0NRV2CQNbzx5GxE5ftCFlLv81tVfcyZBni2vxgOLO15sjzKEtL73dE/d4zMdq4Oxs/W5ho/meUBUhlNeaQQLc/GB5RVMwWN8+tCdLBWhguDECJeLjDMqxJIHg1vBdxWFO6T4MB1alKOsWtYnd6mCdXqiJ7TRNQueKUY3L2vQCtD1tZXn+pIGkuB2zfL/GDD67/s/MqZZ26SKmst1kvzuSSIBS4ajlnnpF6cKOTUZfr6v9APC9AAdzDgdAc54+8uP8IJzEP6oeo3/bKSGO8HadoBEyYbP1k2ODckKy4U9WEdYxGgCWYDpGWhRdovAte6So5WbZKh80dpDrpFPr0BrRr3hkBRCNGVf0oFMAjjgq7hBe/94Hjy9QLhXTC1VygPni3CxVCzoyADhUu537u+Dveur+NWbhjoJJ9jNqVkZj+aB/4BVkR1IO00GXi8L+XcudUZlGJJlcufse+y04PXVGiuTPPXuyn8Ttfbyy0FyJ5XPcvUc+Q8X6PWaO7PpZEp9WdJUfM58ewXzAC1V4jHdJBeIUt+qBxuhITbpLs7E5oa0PGfHqVsfxa2XESJJf7p7/ULq1wg9mXOCpciwZm5g6EpL1xyfIApH/T83DxNXDORTlgKOdhw7t4NmolRLOEBRoqGiXuDVLFBm0nxtGF4iXnaW1VXwqUA9ZONfSAkgApCJz3HpWeVcy0gmHO9mTD14bunpwzbAVRFILXQU6nSk7n035odO+jybRMLJHximXwWHtIJzNmrtznB88+To6ORg0rg3nlVcZwV0uHBcKFsQMeNAqwuVZVw/7IZp8b0fVPCGKfzTr7ruxLKqmAIlckSR6iKYalRqDZGTr/tX6QDF3bc9yy5jkPfX2KHyUGnsj1l9iI1DzTnidLUr5PwZug+aHHe4POEe0WmjKy9/VJklXHTJCKDiZWbCwyoZurBRLq8w9ZG2PJIVj3pbV1SarGkcSVFSkvVOOSxrsK9RzC72CV2UxJHwfB+NYKMXNPGRtAgSeQHTQTf+Uf6OKWwYMqWAPOmrJOv0Gz4FXdu3SgHADKKZDqgyzaawb0JxnRDDO/5GA1egKQ361zOO8UhLmFd9tHREXSutVJ7gdNfybmMS3PmDP7Daf6Vd2jA4Og0RslAMNiNfiIAFTb6Yd1o6e7VMOtntMrx63DP/gN8kxDfRfv0n+9I82mToxzXcxH+IMaiKlrmiGn3PbCn3BXdn/UVbb1XNZ723Ik9n+4UweA2KAer3fkbMpEQ9rPGzGGPQ316NpbQnL5hvMFQntExoqrtk/707mC7of17WuHP89IWqTJX6dg5fbtX35t+LCUsxBUhq6N244lrxazcZ8ReS9TdO90djHa2h58K6xqj/nukesNVYxU0sTyZLAt9kvMhCaYQTO/7/0amsHzPm1+9x2eQfIH0aVzQJ8AwPequRaiJrOisyz9NHfc3wYYBWha71Tphm970NpWmxUkggLTYs+vWuU9DRgffA5YNvf5qdnlHC1feS0KFuyETyJR6hzrKLh75/HpzvXv8kFN8fM38ofgCUFCTLltQsB4dsY3t3RyoRTtAwxTaa+gByY3zXF/K1rmrT45QnDcQzse4+7Z3TDdm9HX2rabPItIeTVKlKqmglZ21eO5KnWSrIV65oq9YjP2Kfypm5pVA9EUraWnwxkxMa51Py4l1eaDg7j5fnw7lJU1JFRxMhlLKxG7Y9H52l+eXLgU4RuzXRbD+AbyrwCtrPMaptR46aPtJFNVqm2t/wOl9fhvaNWfPv2p1/Mj3vVDLZJFkJk2ramlDMPEarsx3+WqVwAqZRTgylKGbvvxgQjVvcJJomtsSxq8XSI5O0K+GIercFn4/WjP8blik/erzovXvUIsabRtdcLzvH1tiBuFU3agu4V3R0qQ3kR+OBbkOwG4qcglJCdtbgc8UVocqGrqtkQqeNCW8TfJBKS9PjVBiXXZ53dyJgN4eqltCBY0TudKY54qiXlWKVo27woVztuqv5uywftMJf2B1ujU+F0MzeKW2ctlnj7hAjsb8C9jWsa/J7Qqo7HTMRGblwKusq6PJWS05Cey9Vvt3hN0LSplCcuGlO30IFwYhHAYIpZfoTyeQgo7eDuUYRiJwuGMN91DkeCRxDp3OPtscdqcuKozNOVrJHnRMrYCjCe0OlOVUsTPToPaXgYVF2toA6GXOiNjeVPDOwSBtmqUm0zMsZBKbTEHmIhE76iD5IGOLFZa6pFiEKco31nS9Y7rT5ODtv7XwEFTsq7c6AUlGV6ZrEb3lQwM4MWRB+cnqY+mSmLcFKvlfyD2mWp1x5lddYwtWDZROQ2NOBdd4ljt4bBk8A3E4KXl0SW4PHJwHpeBavezszTsQTQjJRgPmBc+dbUS/oBVphLEtR+fhp/0U8KM6BxzGGA8KXhDd0mt5DopWvi2BTZBhgG3gsbq8PPVe4kujaB59ggBzkwAE5ezPqAkeKaEQiQJyN5/2TdEBawLjyY7ffNr1s9pGfz9e7DiFKZ46Bew0EO5rpihtVPX/0SsgABtIYsKuroHQDZTP3BFO7q/D+/8ttKcuMoqI0ViLTH1hhRAtvPLevxiR1R1re/uWtmgc80105W6vcvOtGzpE6+MbMs4xo8lbgJyhNNT1tljUmEG4BCu5dblX/Xg/tskD45RaOOImLEbXmIBsas9Jq3pGstbuWHjI9hPKzkROg4lGsYG1kh44FwaEcTv6jQtk6V9HKCBv2JG9zm/DP4ffv8Kpf+cvm/hZu498a++eqvaoYKljDYm7RXYNEmbciolENgpilQSRbSkCQrCiJd3Qs/R7+LdMBFOC5ZMTCcj1pRz2sTsYklUgPj0biDBUgb3lRsYQqkEnfH2I1Kudh9GaD1iXnbCTuWPZMGgrSBpJ/RlgK8/EQHKqh2IsUu3DeICTp26wesDvqVQ7XLhVbuZQIFTAxegLIyK1VLpdU/BwBATslsSfGL5qABYMqZ+66+Q4icEw3SeOZMTvRfEIcOAI0fOCj6c1ATvbCyEG/0zqt19WeqGlv1dwFpnPKbivFdqaRCgQbPISIFNVixVid09m3QeGzXWUnn/C8qdEZ7cPLiGhvoF5W6DJZku2kpaY9WLr8lh+6L+r0x7upDjgfXVZ6Pahahum/52WPZ/SjzmDg66fi3xZKve384f3e7eGVgekjQlNJZxAW7Ly7ODWTLhFiMkwsYsgDknF/kw07kowaEPuCOvWn11Z0W02lzn1vUjNNkirlf4y90OZqb+Uh1vANPO3nFSqHJYy+DjDs4r40eHqaCb89GRx06KDbQfKRWUOdPbCpRJa8dSZQaYg8IhT66ip1kfbmfu2CsHMOKrPCd3xy7KbTSM7L/L27RuIe7JaLFepG3Winrp9WkMsQOB1AMChx1u2+QWrKxbeC+M4m7OGGcCURk1NZEKDdXmQ6tdAQdI0npZqh8pez0/jx+RwZYCgI5z+wQYHgWAcA75r/wDvOw03kdUCMxKbuT9YzrREvvsfLInPb/uj1XVyDx1158jod/b8acvPTs5KyIb1syXELX1yqV27d2DRDmOybDfSt0aVayYvgDXhDSiZ3/CiFK6IdUcsziec88pgGCJd91spQxFKJ3iJCvbbP3MVeAgfQVdmWjbZGWxv6Y2bjBlPMpkf3HxBBmvysuRXl4xqVFFCX29SR34FbICaUantpisX7HwKeqLWW7383l6a+0BNmPhtXsbCsZKO0LYpCF5u1d+vcSl8TRvNdSsrFIk4wmVumMc0IcK0s3YomEbuduVYlCM814yNCy74aCd1oYVLyyd4caqiGbRuYHhwNX6aP1ywu2tUqub0adXGb/hb7HRxk2tx2eNGn4vM4puTn+y1nCuuwipeH81zc9z8CFwG/URBRbINkpuQdU8nVOrS+zCfcEi9CmPkxA8lpDEtV87cYH8ZqWSsZeUSLr+UiN2Qc9AlzXIds5UTlX91+iKaSBn7wyK0fHxjxvy6wFGse4jW8PB2l7tlCaghgR1HyRIxqPJ/Ewd0T4mnPoD3vsjy7STzKIYCd/Ui0XHZdKPaFHsDUlGyZxBw8UzMyR9kjCu6nLRReYqZGJsMLRKM91zpuA5+jDlkNj2oCmsAYSqr0A5xrrqcAFL1FHG4vrwuIh3bBZUZLJ7d9qhg71TBqTcHNVbqe6OkwWOCCu8S6YxU3rXxQB4a/hpA/f7r8qen1JSVD+uMjTMT2uoyQD9SqxE5mVLLyKPTAi9SoVfAWRZ+1UV8sT5GK0u4FwOOyMyy+9cj3h1ebptg3iCVZgP6a0wlIK3K5Afi+T3LQWZZ+ZLHYW/JwlhlefUOJ3ZyBpXofzmvDY2JZdIkHifdGUWqjH0KD/ccjBxvzditLjFKr31Ilfav0PP0bckXYizsAIZu+ZeNEUE+2hFUxbem/EvSe4fpjOJciB9vxEM9aIG+BqJhhdPNjH1cu4V7y0xPj50jVIZpra8JZn4YodOMI93Va3PiThD+fNOsEOJGFoGICWt16G6a6U4fnT6ZjaINrOGxKk0895tJnisjis5g7Yt9ZONwgR/ZQl+6+ixDA+0gkHdLaxrs2TvmJ/ZBoyJZSg3sT+V8gwg4SHuEUDIbe2MWilTpi1AU5bQVv0/30Mrq9LK6mbkMdyAe7q2iCDTT4NrwXIqjzLv1EIHLQkfj4l4TDjDu1j3eta1nOTyCpWIqlWb1EoQ90ODqzR4x3+xPfulgHTsBzch4QFVGSFicnTLG2KAQVaGFL+c6HqPD+O153xQKO0oQ71sy2OP7Vyqck9S8GWrC6i/ov6yHbM2syG7NzWUrPvyGE7Bte7smyNGozWOFrIcgTVtMIr75Z/WuoQpoAz26R0c52CMrWaJ32pTrhaOX3eO2+qOi2Fk05Pr0xP3v3UdCkBVjuxi22mqM4kccz1UyCxe52oCcLSYNrmLBjnfOmexZDgA8xwDtvzJdOM1SMSnCQy41LOrUpqh+pY2TTCyCoEROdYZl79r4/ZCFi62y6siE7FiS28nLJUAIrC23FM4ptUxqbPZTHAIc7L3/dYfM+/ATZw0Zg+MZPPX1IgCqhEozepjVwl4kSpllzzR8EWjbDOnvZuWpuifN2u6qFkGDq4HwKyAlJtQVW5te1kBiodUP8QuRa6UqZaYC7pW2DMbdvlnv8/Da+gMNwJOgnzsnGCJ4hxkae3zVnh1meoXI3VNmgUBj6P/bMi2zHZyqqOJp43w4hBEjSEww9BgwL43X33NJTQ2fpFANfRIPUJ/UFdYkUBO+gDbOWDGj1rQ5K+ziq4EcUPnCPTL8zXy2QFd9Q0d26ysJVHBUgd2xpoLv43AM7V40uOkvXN/ialwBR1EmL0rv6SP9ccQiKWFtveYdV0Xwt2RJq+rM9Zocm/YVa3KpSdgTeAf3nAhC8gBdrqzY+KqfpLulIvf+dDZLsuqYlOjtU+NQwl4uPR0/+DtDa+qCwAyj+CyqweFuT0gZcSkXihtX4AM9z6glmLOTcjQ0rk+l/gRXa/LWa0fS28lVnwtjTCYV4C685lTl7d5R6+JsH065+yRiSTbAz8aaUgrK+MvT79x3tqWs724gDGqcC8NiZdfC02LscO/QNiIaDJloaZ7CarbEjjpVTAeaFVWYqGbJDO2JDjYEF8x3CbCoVLh4ObSZJ3zFAG9tDKAA0s4AwaSSr+2cIKG34Rw9ZMo8qvyyhBeEdHl/MAG9iA3XuwFGfifHCgZIBrntj8dhHEDM1GJHypgYTyY35sfW6aVsay9gv/3vSuXYnjv4p5ZXUAFUBSLQGPA1QPRJe+creWvkhaOWOWsT4cYJw6635ELnfMlBK+Yygxc3IV8fb3+LOKCiCjVAEEbTeh/uT73/BlpHYVEh7/55gCPATJqMuBgeSIJNR9xYff5c8ag+hQiZ7AE4Fv1dIwmDaO3iq03zJEK06h5O+4Jdyr2DgyjQW4G+SCUpwN+mc8qzlM+r+KUOzneY0fW0uJRzf93lh5brLYW39Ye0R/XxR97QUdzV6TdYKF4gACh8VdhzjNvLUBGlOwiMIoG0WNGUdDK7bNYEqx3SMrp6PPyRsBMpDtj43X+E/TUwMc+niuFFH+taRY1sfUdBPSdkn5eRf09pmbLCEcIx4dfgqg3gH3ABJI4j6z43otv+qJpAHlfuPQXqsMQKVakKW++g5xntLImsFBg3dzGtbeYQNV9z7+U+ZRtCH0wbBgjKrnjsaS2NpglYQxcNvP0XpARZ0vyKZu0+ZGGL8mbN7skMyrArySEGEvCFIHv+y2Bem63YMpC9weiV7/9L8Y5hM0Xw8ywJ+mCJs4Sgm/iC6OKnIcLwARyaSozQYXksHV9CAOJR1Ug50dt1HiYbrP/iqDWdBZYxTVwBr/84ZhCWow7IDd/kEJvxnA/xkBhwip/cPbX4rRpv9BvSZnOSyOExfo+8bwj9rhg1vGfGnPEgfF2jTSY4a92mGFuWzIPPXrhqjtWH6J811prph/A011lTL3qyX06QyiJH54uMd1hiYA7NRrtKalbqXYHMdEAnMpLoTAi5G3pnbqkn6Hhs1WRNoXwB0nUdV9T6K9iWCuJNNdHGdwHc0cP0G3KxpOHts59yq3t+TRzOHfuPpk5r0oHwZFjnNZopEptoJF3P2gcfoZ5N5NpwNbH9SHQdGWQkebkse0D5y16SUglOmkYfIIutyS4Rlc/0L4+GQ+LNc7nYBhCKGp4QNWBYj5bkiso6FDQBFvs4LI5TGENy/YvLtrwHBAzbIIQ1OmonBFdr1WPAX3GAFBnbpsd3G8ED7RRc7xv4YnlwlB9sVh3Rf56ijmvKYMqKGKaI30/rlenbAeYik/vzpE5+l53vbDMmO3cYOHPCdC3LNoOssZt3frchzUEJ7kFqcwY0y1Kx3Iv2PrfSrmfJHlpQTvuekHl0nWqQNcXTUYD1tf0aPAMiO5saFF6+2bWOfsLyJP2t64k5BuHE+ogzUx2UD6ojLLieHWA03YmxOhck2n4+NUy5nL0n3y0dkvUjtQPTTtGhSON85Uye0qk5XU3LnLEg7QO17nZY0aNXjQgQxR3SPESvcBsjLaBAJ8kdIx6mh2m+y8xeRTo7N4ujd34I390q7nT98e3f1BJK5K9puvVOdPZC2E7+j+0bk/Fk65Z8E0+lEmUgplrrKbv+E3fDqBZWT60dzAkghC//bs++v2gLEPk96SjnT3bOlkidbftMwp946GP38akB2ZmD2WvZnyOf3fW4Pluwqtv3L+xfLo7y88TTluXu1lypQQpOAc2ory3/XmWtad/3NVDbr2iRFepVOOivPsLQE5zm6m3Elut8kpbc8Wm+xmkQcmOU+SARA13hcDDAq/I1HmXRUUlLx6lPE6u91mfTSDZWLMBajXj6AQr6Bt/rqxV8KT20PkYc4s9rkF+CSfrUW5w9O7rVNB9nttYH2zYshKOuOeQ3JasKLjbdx02db0zRkPrFzWZjLbxOG6g0vW8FV1swKSNkLh4mC7n0LEyDxexs3/npcjih3WQt7ZsOwcPTs+10eFjv8mdiW7OWEajGZJ0nX1a8E2s4RkTpJFpnEx9fRDjMEIPKSwa558fjW+ygORZ/64FQAGYFv9f9qP02VnVNvFvkgDl/Bioy9wSQcwMdcXaLkY5mtAJ/f+UNbebPkXI++HXwQdytImAIZFc8iP4HaGSqgz5n7MBPrMektlWczazJHQ7IGt4I2tzZHVjpI0P6sLdcdgp6KNEVHtiEGofgjv6orBfAGkXgeIqRM3YTHxpv92BkwRfcYtQMotWbq8iEjWYIJmqBRb+FSXBhUT9rCl0xt6OtpcxLtOYkJALzN3nIeuhiO9zDV/ft2i2VWxFqLHvPz0fg6oTmc/mR9J/+E08616Em7pCTpmSMaFxk2k0YNkoXsEnB/s9Fu05202uzdNgXYykXu2uEn4WmTfSfhHAUYaVNiEjuaUIjJlQqXwLaGQ9G6Tm49OlwIhw3x3O/YeEuN6VuPb127e93/EID312S7+qFW6aOrlhNw0iSkfhqbRPwXWYS77G+teHiebz8jf/SnRs50D+Xe3aUvYcxZwOV/acHZq3Vrm/EGo106MUaWkHB9yzYAeXnJEV/MBCK99F/1RofSUThRD89CU8qj5KAz8XInhmohRj8V+Y0A9w/R1fNfFewbYJVqbW2fobgkFhu6Ezd7K+y0H2cHu+ivgY3VvFl9qKL10B+OGFpCTO5sfVoMrAeoSa89y/B0VHchFLtxhEA9HB8aZvRZa9Y9JQuzltV3X2cUvIBRvX1lE5ZHrADWHeuVbg2+AnDMWR6soYoaO2Fwyj+e2BB+hyxcxofBv3+ZwuRafubAZbV+5Wa709PNIJ8JUwhOmGCyOcHsTd+beSm5KZCAqKEdBn9OES5xBvr0zuKPGRAhmhGUI5ZR+QAmJMbtW7Am85ZkxQT0OThFEfz1jmzEwa6d3t+sQRFNyiEO1duFQX1jsSzAGOXQH99UpFb7Rdz0ELZlyCAmJJuAM652o/lvlNz0hSRZmaFZg25z3VFgfUDX+z3q5whXrm1F6NW1MtuhrBZtnoeasHnmh6dNINE66MWpOOluCT1VfMwah6BM1GQHWFvZuoowNx/9rEfduS6MBcK94kK5RYXjxMaUvAjEP8SVDV9kyyHszOyOv3QI0H6gisnknKHEd/QEHuL1ZQ61yyxedGOWiArlW/EsT/iGqUoKXpwdJv2qQVIFxwFbk2cebzk2IWZ71M4upTZR+G9mv30JnLqPYxW/DjtMbI/+WzHppYs64YciNbO5WUWqwrI3pe0BeJ40WCxZNIg1rzyRdWoNtoLroCaWQ6wOFOSEJ60EY6R8ONnGfnZN/x4+qkijg153buMX8uUu1FnwpRdqxVw0WeAcUxQhSy9yQeAUdgHhYwDDbUn1peXklqqf63oIcDumQ+s0XCJFTi/WiCKT+CXECILcmF7RUeo3cDPKz1dP/4+gquxU3aGRXQZzPLrihARyCgRX/5/vVzBh5BGE1rN1z/GVnoIjbHyN453h8HRfu9f25Clq0AQFBR0ia+ZmGO69wPjGCreQzBqdLu2qv/C9Epqndy5ibM6qi9Y7PJ9ERaCUrrlW1qps80aEcla+ii0/UCHQNyup1SFf9RR1jmuULxg7CgvgNhquB0hge2I0ZN0KfQIOdfoujfYAOye90CJzriDAGS+wVFosnA2wECW18wG2V+HtFUhp0cEVCXamtl7CJQzK5mioG0g8c3WjnSYm89zfY8Zx0pigkNxsC2rECmTb6xuvsmRzD4qQI4wcaXt+eDW3ZnE3WZysxRdG3IIdyJ/GbLulfaXYFypLbhC7VWeNgaLkcY4i7YlJN8bVFPTPnlH/RrqwwdRRKMdex7MQk2XPeNnOJD6jI9HuSkDfaCYtuxcvma2IwyZC3m5Sa1jfOjjOaj5Q/Z8u5/kHu0+Ekhcjjf7su9VrDmC4q+hohAwBSXIQt8Rmcd2ZlArJSEFrQNxYVrdWnD2zv1heytveR6c8zhzk/c65fQWGeK+LVwp44o3lITXihQM5YAvw+2EbsvOI86uCHt6FSxx/U6nbUqFh7e0eN6CgK3MOhBC0N+1+oqBhRV8bHZM+LH3D31mnjIGO6ONuZJFoAnk7+2aYnymiRnVCLTxqDv8NFvKOdk+j6nihS5vQ61a9CQmVjED8K/GSu2FcUVAsHHsyeUMWEGW6/l8+Q5+fSCwIc3TIfEN7fRPLGieYo+EUjoYFrVblTHuPzROczsFDJjYXf+p4kFP8cQxY9rJJ0IrTKWnhF1eY4iWQMfn4dTCHb+72ieoSWsA6rSxtqEgdfN+eTuXLApjocYM7po3DfT4E2IwFgEY/hfdBKhQY0mi+PRDnqkqsOqJEROAG4u14j73SqKG9xb86kEjWk735SeLNA/LB/e+A1xw+vKBDJWCiwK0tO9h+Yrqw8CWkE4t+KjSwPEWLSFC9oLvLBt/pSV0zQ66GQ+s2B2KVvZiI+5Ni1wOP8obQnTFBQkB/PQrqTG/bdL5uiFc46fv76zBABrobNhGOspo5Tj4QKO/94goJjoC4vt0JlUvnDlH9+GHP3MyVwBCYUQrFcHywG6P2YNfIQ0CoqmK+ShqWb7n9FsMk/vZ9Mo69kdp2r6Bg8fl5Bon74EapxVWsX1hehbH1YXf95wDwAP71AX3djQ27Nz64w4GpMVJfzCVLf30P3uzKv8G8Ee0HLzI0dmTgimqb3EkdEzmG/gAuxTqxOFaysF0eq5DaRrYyPylr5pTEzdoSyYx0/HdAGwHrIidx+dpzZxi5j3DACcHG/B/T48qip/7tFDm0aNzlOtpIjZtxdtIyZ5dxP4ny/uHfkhtBjpYdhTMXIgGdU0Fgw+MVy2hkYWDWVh9LzALZvNo7mlfgGeplsWNrBw2OMl3+p7YCaexJBlfPP62hMvAMZMlxNqiFCeCDIlW3f5FhSGyMT16HQQZr7mdWYvKIs67RGuvK4cXX6Z1pqEeKdzwnB3IY1NPSyffB4ce+C1nsqFekCYZ2UcrUWHbDhSM8C8lV67BSB4EvOrLWa+Z04HgYwUqxtHFz1UAoB/ZKBPK22zcr1GrfeMHHLQ6WI1C+/Y1Tye1Bm+FmE8sBRFzl5HCmq5G+PFYvF15fgNQ1JeBA5PVTMPqvY8N5BkGS53RH1kNkVwBvMElIpwIMAbs96JW0H/ygb8pJJPqWuVO63St6wGNL+Mo8g7agtxZAV0ZKK25xSxzu7MU7tk3ke5ZpfqvN+zYCMTryhDHXEkoflnFKfQtpeem8Rm7+6xQH/mIqKpN6RljiKVXw+i51kCNAHpzdE4GyP+qkbXLt0Bjk0CPVzkeCBWP+bLP5Hz4bqZhIWswW6oRfuVsgD2XM7fP1krox6trFsSF7XKyB6dwMh1zZcSUFuC3EXlKqLbMK+O5zEMnE0xnkYUEK54L8QpW0dy0QNhq3SS7+Q7XVtK6iXS6KoDJvLlcsz7fTwHs68P1EgVuPZzeHCRtfFkkbXUcpPSR77oFQo5Ky4Ng8A5bd1o7rGRAH4qlGembz/NxoiOvwYsyKW52X1JKgzYJWC66hUA2/ZKAwF2lHFHWUfTSFNax4FAjyeAQbYE/sEKc2gwuRMuVTwVyOOTii/AQYOoO0hg/KTwVqqC6aTZBXReGtqkvEiaTGclbSQXidfAZHtIJUiPpJGCfSoemDXhRD9aFY3f0qxnMfNf0oE6C50T6O/CdxPVCa0l0KWtqbfhjSAQ12IpMU+lHbDPSOdCW29PVGfDLzrSbS4jC/rQYtPXe/MsGm/aNew2V09iFkCN6afClW28lRvcV+cSoDU0Xz2BpLSG/umLsuw99c1AozW7LDBn61wOwKK6+VtpNJ+UiD7jYbGo8lRTRak2aHaNp8oN2WHCVlJiTbNxx/kt38fQMf9xCkLqS9emCpCsYCVnZbJX5kfadL6o9yX1D/5Ii4sRpMrd+74likbql3XHFb09Li44bHTPGPWyRUa4IeW3VxewwOXfXbK1a/0kILzrHq7jUuLKVqiyeqLZDTt6lSHO+mjvemM+KDrijVOo3s4uHq2+/9nE+EsIS6E6PADLEY/HGYzQRj7X6ig735PLxOpTKBwynLuNLr+xJdzAbgCNBc8pMGb/Lghb/Xb8SSfw6vauIy9APAMXfjCGZsHE3kYRcEbsaRLzsSuoyvw2AqPNVO5FhSL7c9uHdU/OpUeWzuCbtW0tmXt9MTqAKB6QbzXRMrIj5DNTW0vDjvHl/COzVQzIkPL4PzDduYnhzoHuRogzCm0sV7M7xlkdrBT039bZlowBhPCuoP69Vvvq1dxRV51v4Xum36PzspOPdZZEet3otZskJbiixhpopQAenSOz3FzI5k04PlR+6zmRJOaVYNyPWvilzgbCS3/OKDKGNIMjBmty8SsnVq4x0hvcPy1lMt/ASFmFyMzekSLTaX8vzlOW7k+jEJXkFAoHxzz1btNbVBAht5HOWIk1I5nS1Jeh5mMQszWUyuyhQ3Xc4OjMdm0Cdj5YNyvv19eBqkJ0X3oVpcbdbSaHdHX1q4Zxu5TQyzMEsxOsFbpyNB/BvJEkYmqUTFwslJW8l92I9uLkUq81V+8tuzhSAW6cm0b8hSljpOUlz0Oh6TeJ0ybIRqKcSNFujrd/LRqkpv2gXe2im+Qe8+MxARXXqO8f230Esm/psHhBSeUIf6dlaM/cQVbeRaLWkQdSor8bhUYkFVAfABjyn6/Fos7ksiX7g2/PxrC8sOnPsprqmnEzRLejrXeVy0gglhWo5QoWStBwPtC3Be5gCLWyKoix57VQGyt1Mf9NXQNq8WJSaMdQMlnhdUDKC/iks3OC6KTfHIMj2LLix0BaLJGM+2NehYFSNUCcE8aK9hTM6vGb56OMXk3LlU3XttNjgmk9UGdu3A8dYUuUpf4XTYVP1UXVNASr05NLFqKqIRVrDarejbbHvCTMxWpukng4gfLLexYFASZ28BKGOu39SlROK+zJx7CwRZhQUn3EyW8Higet+quErO/+oI2EBopX5LviNBpCYetY9JxUAEGaXnl8VLDjFCdCaGjH+zvVIQD/Y4vKy6MeKVQ0uoCex+uZjZiSi1Q+m3n05tFfGUX2lcsjS6tXJnzpCiXBN2bpbUaYSMGa0x+tojj/ZR14WAauENJ7cTexPeOeKYkWX3cCbiWJfHVkKB+UY+ZrlczAdlSYdE3i1F+ZbKJEpoQv8h0OHS3WFeNnF2S607M9B+uvBeMlLwTmvh/MUSDjHTfjPsJ01sjQkhdug4D9btbnTMjRV8sk1W+0Ch22gbAIGBDwJj9sKy5+dSMOleBW6XTNY6cxdZXd4QwDAnszFc4YtxKWMjD3XNaD7GLR2ro4TJOTFZiog5vWESXg/pVHrr1ZJeP2YUB+0DXCmvbnRtlm3o7BE6W22kuuqoGtobclDzM1dSZTuVnzDzMJnCqk/NCS3SvBa3F2qQ2xbnO+rziV+Pix9FsnOx9I/AdhgC4xMIpqait7GwrS1Y1Vza6FhjoUZfQXecYQ50+7yLqEXQcI/Lmm15rZefb2JuHmBZHxdw7mft94DpaWucHWVBkyL8Ap8QVtGfYVfkxzHuVIcVDVAcHSY7ci7+3gvIG6ErBR3hHnyAWqiYUDNh8NOTxIYBIYJckn4EPjLW7o9I4hPLZGY855VfPIX4Tjwr2FqC2+ID6qjuK4grX5JD/8rK0ON/jd9jVc4dtsaSMOz1rWCb3BHsNDzEjvzj68PNnnbJJJ3fu4RVkwLpR+trHhPyHlaUNa/NEf4p458595p4JfptGLf3LiuRq6t2Dw2O/adOFUSR0BO6s5nuMDpzxFUT5RHWGmtNtXGX/cvMOPqDbMJO+3d19Z3eYgt/vgxz/se2S+OWYYzrjGz8QB8ScpmHZHNozi+1jCPPCd062AwIhJubnVwS+NoqK/zGOkd6huQYVUXGjszKjbXf86IJmUFhCgMkEGy59eqLXqs9qC2Sb1ni4fYIwRvB9V9aZ7tffDSSfo5PeeVa0th4tiWsvno+nCypGdYPPlq64EujFml9ffF8lzfzMQ28SMnI0CmJNQPSPUTu9ZsuiKwC6mj4lKAHqAu9V1FWjy5rrsiQ54SfqLvhfMA/4CseG/JrJBLuZuO1Soj8OAF6gfGtXi83WqufCqV3UjiC0w5sOW/Ij6E53qtA8KT6ml6hkQ8wSgx+yPHnOqUGK0KRUMxVlgDn247/vXUkqaRzQmwu/W8hEeEKKFm9DlMBVVJgdIuGdH182PfJJfjAatge81qxXPr0gkPiAgpn49AMXg/pqBtt7z1Ed+T7fyj8wBrd7x4uPBwQ0XqZUhmysnVXQzXfs74HYTuEpCnqOnfI16F2nyEKgQnHsa9LUioxffM/7YkGJZVzMa95fejaCfnRKdHQ0PbKCeHvkpRBcorQrZQ0zI7AA6aOHrpYnzW5Q3bk/lv049Vk4kYLlCeb3aGjzBPnczlXrG5x9pz3vqV+W+R41Ymk68hQNmzVNWXqZemXl8UiSi9NLqZ0gf1EgDWFVLaLseG2XGCE37pQrXP32/JKBlOSC2nRZTjpH8guq6Uzwh4Z5Eb1ydu5+47nEO2Ojt2ikRBYPWJ47jr9sJAJChytBntbFZSl9vOxvahpGXBuoYy+GVKWeN9RnxGPoyqhTrG5KbNJmceOFt6XDEm1KkAgwxgJqs1Bq0TNjacyp66MDDK8nEgWZzbOt2AC9E8ep6i1zDUu+DKnuhzb9ROzlvfaw2vPsFV4TnSPuxftmB8FcGrKIFob6xOyjSsoBk9aoxcuAXe+EOOPPvfBmpNd1Mn+Rr8RoihD2kqOAmcvIT1EENArBMVm8YxpsEpEFw0t2pbdUTtQXB8w9RfMKsAWL7X8M2thXWeb4OVGFA8lG2HAVfv+rdr7m/Mkyytgu4xMMBCzB0dokZxL+Lem1ax4K/rmQqxMrPx20ba3wO5Syd137Bo7oyT4aQeNgUoWPVYgumo6k7rJDJ8xi4ps5rwOyeeVj107wL5w6IV2UBO5N5CgEzo+XQj2ERK5FvbspMbntXIoD94MrFXG1qnJKL7S/LV+Ei+Z1Q3PNR0ieJR9fOGnxaweHNvXYpJ/l4WfAkl2he1R7toNqRy8gNhhR3kzPFjK3vgKI4lBZGUKmHzkTyavI5uI9RhVetlUKOk7DItLDkQPzq3/4j3R/hJQHD6ppl7Bu7KTM4aP4a231JSAC/vCcQ1gGJdmgBeh/iZXGbD277SBFFV9LdhROLNKz2Oj9GCCGnTh0WET1Ph/8QoNGq7KKLNWIuxOXisG/If3ebEoC3LoEhUaQVqfF/qzFfp3ZG43t6AwFSbJ6R7nPvjV4iySYY1jZ0pG/CS+cM+pDu5gJr4WMyoslI5k+EVhTVSjmVlJF7ZtZEfu5+J7Dvy+8//R5HlSu03wHLn/eiFs40oBDudxMl+zMB4/wwofq+I0JrL6A2OUQws7OJaJHSZ4NYo2yV3NfXvf1NIM711yan6ubgBFHH9lRz9V49dN8+q1yTi/QKhU33PC3EdTTbw6dFEgNS+B9hfIZmvAD1GpFXjnm+vb4qXV+NH8uIgArGt5LXVjl24Z2Md6NEqgo2l5fOBl8+8R+Lv9uDG/Oq2clKCZiyR3n1e0CWEDZtZNOurDsHExfBrj63kr1WrKubxOIS6nVj5MRadjU40h/e/o8XwF9Mocx993+qwP5vXQjyfjRwNjkp7rIlS5gTvKd+lA3Mm2pLFiaasOal0VUjKt6GhJxjluOF9tcdTp8xHnQbEPva2vMNdG5NS9M9WqoKQpmJP64qwzgQIALtoxU7KeT/Wfi9Ek6kVf15qLNcJXtUYvuT+zJK63mvq+xvD/+rTACW/hgkhCwGosJAVJkIPpv5mFqWbnC6PgoyQeBzmOZiYDy0hkPmb5okEL8rDdJp9otXJBiSI8b9CdBi8yRYNdgZN/KAC4S23yYEpycBQEWa5WP3vct2GKbltC4KSj5FsBu4USKJTB/gb1NCyf3FaC/bw+4UTXIWo1yHNrP+rOczQtFPfDyl3KuMxwKdeUujqcOFN1v5Akd7nv4Odb4R3Rs5o2eankC20cUgRcMvY1z4JbhgjIZuCP/lWRIe4MhLoXDPGZOxYk3ijv7cxWazlHCYQAU67wJb87NN5EQS/zafuIAJ/fD4F1iIl+BBFtMo7Rr+kfcyTPkqsqQXWjixLRR60Fn4Q1GJGws6vTP9uJFKvVX2p2s64WUKUDidaORh41Qsx19lm31CZe4/AE3ZmaU0CzL1PwC1k7Me+5TKQHCyPHRQBpO8GuFqJUxe0hCIJNKKZXDU2zB0T+dypmPcnrXonHQX13kkzo9+SR4hhBJE9VRkG88yOUDQVHqUOyh+SRKlzqGAQ3RVBaHYG6KNqAEkN/zhfardEGPp5AWUpCRKc3iHOXuNv/mn+K6pNNBncnsqzjarA9hDBkVqmnI3DriF0cA/oI7AsjR+J8wawdpuhlDA3p+hXVB3FOc7TaQ13QHQMuVKaOAcjGVceTN6Pwom++WMmxmYfIf2aXsfccZu8I6PvFd+6aLoMfBtt29VrzYvLGyXqiR+jbuzjo0pPuixydBtmicCYqHs/zdu1yT7MtKere7PTMRIBc476ttw6AbRIqkolYk4neQrTLA2q+BAfmm/nltFGxtxWmS20fSeK9YcuQuivB4CQ5wrJOiOIj2LbgdOdSlIjfPi5bkDYsG1Y1rLKfMPgaq/NO9ehVUSm6BkgaH5+bnY3asz87HTunCtygeMuh7Asnrdl02yzs600dkh/mEM+kpR4MGOKOSmhQz+5g3EnNtuxgEu8j9haxIbaSknJz4DNcnyisG5UdKBk8GsV0BYtiWUCtgUcdqNUvQ+MiHHQ4/f5nlff1EjY66aZYJTn0qu97TceRXfA2yJpU7MsfzAZyyV/fIkvpKRyPFkKqR0Leipr2eyyVnGi0h95x3Vwa9kza7Ay62xxqz0urBUezOOaTPoCgQauk0kdEPD7YEQcfwvPu8KPbdeUTlU5RNiHpQ5ryBaqXsE24HndvjAZEgDhFUqEHrLP1uh3tLf0D19c8u5u889KlrNfePpVzjpZLvs/jX9b0yEqMPQr4jCMeWSx+2EmiQ40ee9TsBpKZE+sOHZVKyZhH546KdcLQn0O8aPtRC41d3tIIdB3AOuNJ2bjNT71cAUDvAETZZLV7OjoLNtxt9L0XqpbFFoTVSnNNdbL3njk9Is9Lf+UvVvG5lxMHjku9tdI399FdKot+JaNxPTG6GSle8rzgEZtbENpWblRF3G/yIESDyvngUZ3+ranGmPckHNcW/ACVZXIK8UFoAh5CmVk8mbsJRVABh+eusYOfKsydVA7R1jpLof/tnS713uPC4kGHTQODOsjFJZ07AROqreDJMIW1bdmD9GxrqFCZYn7VFuXxFoWfyb7DZRpXlvZOo/LKjfY/ogPKPIBks6u5sDnlk9nvbUKhikiCuGi/n6A+nN6pw8ntqlIeO+YClM3YUwmZmIxhfM+HsEIRabuJk6Q8q3aVV2yfhxwS/HvQbbsqW8hkRymxsXvn37QggUxQV3N3M73Ffl7fFQOeGsXgr1etumAatx+I3z0dSx4I6wYTNkVDsmck/P58WuzOLjV3vU/HeSJjzGMfkxrKZD6B2W0MdmaqT6vTpKSPnOlyNBTnsV9BQwT/9bijyslvSoVCJt6fr0Ccm5w/CBWdD1TwAusxyuUIxPXBjpad7eBn/03pzw8gTU6mrBYHCHgOIBILk5Cma+BrjiBhxLWSDMR+4aRkQKVVaimX2v+qYDo4iI+GLi+ncQeodtbAiwqY7Rf/S65tNrGbY7RNo6MJBDevdNdJWjJ7dxUqTiKveqG0ycsmLV25xpv52T9/OrW7U11YE3iXLSnENcs+gVY2n4WiXQdAHty0j2F1dePF5KtesWWCTdzEPKTmUqyGaaA0Kl5Qjnml4MOGCxyv/h73nRuK9u3S40PmNi8L3aynnw+WCzX71MGcxUL1SgyNjbLY4MGylOl73vvLSFUSVI+DjNMablm6hReTFutofMLzuIazIAjZqlq32p4xI9jzmnYdaIse4CyQ1aPRYBx84gpGR0wd/ugz4Qqxz2kQ9euwe3LmHDz2EsvUfA/E+sZnxiW/kSi0jHIMXOHqK0nrO3a8JMd329vZYozqyRqlbgOyWyIIg9efaoeUUajUUvwLGy7cCoRYo3gU4jBeIeJA6VbUuFWkOtp+YDgs/95zj+M9Vsj72gSc/fl8W2Srsj1Qb34E+ndjeo903NhEeJH7oMmVhri3IGL0I6WTOO/aWzI2nocKJhp0kGlHLN0t0tcKiWts5lGoUZxjpCvzl9KxD+n5J0R86H6BIIxWDZStpCgcIgBRrrqo+VWV5Jk9IP9AZBQdZKA/piOh0hOjWpXrDVQ5PFw/e8ZVzOo3CefcxvJF2H8PIkqDfjbYMnctT/LoKe/YO2eqRCoMfjKZ+IOpzb5gojQ8IOaQh1uuzr62G/zAitD/UwR4YOS2ZkDGx2ByabBjceHGp6uEht8wzTQk9MjMdtoXAX6vW35/AmNiovDAmJ4YRquoJ2eI0ZxoU8YyhM9dwoxHKbiAZsI2X2xQNeM+1R3T1/HDz3rbBuOq0cL7zRRdUy05bSvg/jCga1+bYDZwXSx9wuSef2tno5LnTV8tlnHD61QRnenKlw5d/40pbs9mbNKafCHP+1esEC8v6lHTEwFOC8Oh9en0FixTSvUIs4g3PLx0KtvOFqg6vxgrL82ADsGIfylwLZ1vHFOOaO85LKDnG1nOrp5FE8nD0hnrR5mqE6C0cdjOZGKdpL3NXjqTIOO6e34Cf2pdMPlsxnSoRWiLZe+EdEPYyysaOCQx5osu5N4Sz8QuwdPVTY/r/wae/n1G5egVLlIjrFvg3kAwDU87MqCdcKaJ1X9EkP4KMC+vVXOMACMLspU6mFSFimMyGzvzc/W4iOif0C67ErPMIOGWvTOc8PuSSGYtCPsHhObxALE2Gj+Fb+iX8YNZ4mm9dKcdxa6ZNXgdE9vrBk9783kjjaZhZ+9gUu59emP6WB7qgr4lcOQ6mn9wBT0nrYpjXIW4DmsT8C9WE+udrZG9GNFnT19PNq95MJJVYdEzFW+OrH6FtrHWEYVGFY1H4pIK/NO6/xcbHkfh0n6F8jzOsanseTEI2kJR5+hQzyDfBC+4NMbTyLESHQKSkPptuB4bRKwlwOyLZ2CaerEWn3wWX5eR1zko1nkl+GRjdTYm6hh+SCfoTsaHgHAqY15qd+aAY/8nexSNNi+Gu23/mXdyl6OjwoFql28iN/6qGaEYwuhbaDqYvryBwEVQCX35cHNvgrgTkEUoaMNHE8QvLnZ6SOUnOwz4yK7HaiWMT2/hlkbB72CLlNSVYtlWzYXpt77zw1+y63CaERN3uNMLIi8+t79A4iXBVdSZLFgVVBrFVF7y9bDjaqbgtaBFYD3vWuRCtEbhzG0VcUDkxUxXniGdjkDKCtbVsEQLQyw6WqJXzM0WZWMZE7rmHfv5VvWEeYMgj6nNzk93aM0cqvY31hRuF0+pvBI/cfEX1tr/5fChiMGXHDxKVEmxGTf0ROOoY8RAfWIMyHMfJsxnls8XCOq19T6nCpCB5/om4HYb1E6IvpviBBH9afPwAeTN2nfWhApw1pRDmG16iQlxUPxcJ1juxIkzgf2+d+lm6TUmzlkqF9dA7lPfiyyoNgLaImrGAteXMW8iD8uXByDTN2M+DwbJNG1GOznGd7qvB9sjPSXQCW+46SJlK23oT/eNbwb2AIiQWDi6wy+6idVqtWmVvPpkWyNEcL2GuLvyrYCJIju+CSCw6kca3ukXnf0OiUGlnoeLpOPjuKz+JLb8VbwWw4TBDO7HsdTcfHrDCrNwGNRWtGBjWV9c3ZjtZ9f+uLqZpAgHoxewTCEAdqOx01ksFVQnFq/1zmpQZU7zl3470OPuR3mYaqjbyCvmfo4fofdWKRe6ZJgEV+Mwb/tnLZcq8yqu5auGZchREbRf/yJCCH9lD8IgTQgaBhYnwEmWfoj0AB3EoHS9JB+0a4vjiyqISglxO7fOOfv+7u5o0K3oVX2rHEFOG2mVi0AUCRO3SDs6LoOD6nYU9136Bybqlu2dMpVmjGnDZYafp0fYgCgu/tgycq2oNDDbhLjrOvVHeNNCsIyOb9e6DNJtNzaxG5cub/t/uHJm9dExaVFkvXN6PCyeN728HqP3e8nGr01bOgIOkJ2bp2ee1fsVG1+pttIfOcUuNcgUXq0aFb8lFwqhL7CmB5yUaO08ON0PYaviQgZJR7TfSVmLHdJPAHm5mrpz6VOvyglX34ZBt9PSHB8H90n0Fdq2xxYiu/gktXg9tQgYpsfdKX+AXqZfToIS274USnj8bwD7iefK40mwPrqHRg4ShN/go10z1ApK2JHBLJy8Dr0pf53hej6SgDFAI2XrtLL45QsbCIfDOHLcytpoKCjITIWC8j9lIxnM7OUAzUn6LgVAh8KsNXHjJvEzojtGbE+vWeAa1ubKHNoQG1ZwGiMWcYRQA8Fd6DJfQScHxvwXIPvMxzpuyQ2GL3B9BqutuzSW8WR6am7Ex/dxyIVumfTydS8S7+EdKmb8+ufSbmTOmkZl7sXv6FkcNbGH88tEbjdnl6z1YXphwuGMWmzckxdouOxgoVH+H3tNyWoBcLotYSAgE6cXe1loESJtojaV/wUYTd76yuGnTPaFlucW1MthMDsC1pnAZYeozKgo6vvtH4JBuPd04JUxFxctbqkE1KQNbUUK4FFhmIZuizsdb9W0N3xraSbC+rEnhxz/KDMHQZ4QdzgL5zB0qgCD5y/3Fh84F8lXQUZkic4samqzIOpy663W+uuDwMlIG2purSckeMgnBNnx4lz8SaVtc8B26tFAnw5p7N8Muug3gO3P9sdVXt1cxPczGn9Vjz5+va1uTsFr4WlkvOBANW6h/4Q9wGnFlRIYkJhOmO/yT1nMGSXGft+rbeNZ2siBnv0diBBaRsEPxeHaLGeYUvcf5LEvltL2J8OzUMW/sRat0RS/6OqRBw5cjMClLDYhIldbOSw62Mi6+3lzFSB3w084ID8Y+vdJzOZjHMdAYeyS6tBVngbcM5/GxT03G46dzXL2AKZmtc3OHIlIYpCxO8puQyxTo6XNw+afZciHwNFjNOktGC6lUWqHK744GEBhKq7rrYjkscfUvLpD3wJuJ+/EpClYiVKdPq7qYovQ/szEN12k9tEpHjWvoc3YGkuATHpuS5d6aH6XdQzHYsQfPu6ZLKYImtIOeNjCKhM1tUe3y0uBYX3fszV63gsuivuu0B2TmFaUh3OQnUT8lL2KspxhjFeSFKlYEAPKqL874vYlJVFMWDSIlw7OtU70jia/b39sA8h7z7ss6UIF6WfkcGTUDRyZK1ht4UPEoQ9XoX81xHgAhR8ZK5+gYjcbagiuG5IDQSm/N9O1ON0xGiQ167hqWSlj3yxmox9McsER8fYhQrHbKZsAKW2okDBT9r7shKl+knDSR95jrk0bt4vKB72/J2n4d7IqN5uJGvyModEU8S4Br8MdZ3UY1kWTX9MvI68cGDhRtP/hB6MZS8LvcJMJh3Br2yOpxjlvnFPlAUY748yNXI9aGNdIZB8b/eIALj7qWt2UgW3ogHgT8eUEAJtdisuXtT014qxKLaklI03KpJC5NnSo4fvrdNfdo6n5kwT2h0+DPLy9Jp0OhDHX7+AYlXgyu80H7/BINwbQ6Co2H8mnS9ZA3C8zirGeHoljJQsEVVbjtBtHtRPCMOcJT5swnFB5rI8fDymFcpMau193ktGo9oeBRxs9lBqeurLsdMMwFoNwfTDr+0hCZ0Az1W1YVTvJQneaZsMfTEGJx8FxL25TWukb/85LYsk+jSR68mt1qn5FpZsUjaqtPNk5Hjd9GtSmL5vu5ZBw5yNfY3M1rrgy+SXM1ElVB2Vf+LFI0qTa4LnOnQ/omyPa2Gu0AMfnysPET1BA4YqsU5FBNhz4BpFgi4+gMBjjMuKnOON7xkgT+NV4no7cuOs3//gs2ylcT90zNsqWLC6JRyHX0NNd0nI7ezbMWNlQZLAXEEP09c6kfq2r4URGPaAXMSTlOMFZsN1eBLXUhhnfSwHlJqzNcBNBmnP9jgN92wyo4inD47r2eM6ksWoWSNd0qbk7rFPcl9nNSOMtGDOeQgKYAxCslhavbYXSlpV07PQ6URMMahePGrchtlZ7noPuD/e81FJr4IypQKThAEpan/Ki3bOmvsLe5QYcM+edEJvrdTLuQxv58Hm5qJ63A2RMi/PSzYXXX2uHlsDMBG5T4FP1kS8nm9JCMerc34ISm00nk2LzigzSGkAIgxNgqMUdBburynJFDQhX2LwXsXRQ10P/dWvu/VHfAh1J0aQGMN3R1bKigIhq8UFboYFSJB70vw0mrvRZ6m8EQaoQLk5cR702Qez9siTtpeuwxzNkZAo06V9CMmVZ5VsIsGhLxz3N3LlEiWe0i7p/PqiDHxTtXucAX217FIkT1uNmNiEre0Ifj8yPdfJQHXzL2iO5FwV1AWdlVd+8D0zD8Md5e7QeccBdpL5No9DDQbI7v/nIDqUmO7z9b5AoyuLnZ/3CtHKKAVJzErhIflDgeN+VrA4XhEaVGCJAaykdVO40zzHtNQmjWDEJMSMXJnWpbHjXSvYABCifiHCKFm9B9zWaIFCz76zEXZYruRuAn5l1ha0HDBaKIIAoXjO3L5SgQX0wuw1VL+B7iwjAWxBHQf6/oMvF3CRz8thHzIf1EgftGokbRZQgp34R7jmgJbb/8iq9cPioW9d7yHxO5PGVMqWRTx0lD1qWoe3ZiHYyuKjxE0N1qZh6L4XYoK8uD/68wVcQ+EhhGUMfPuErPF+9yrRQMyHJGJEpj/zuh66IEn+OlLj4EZ3HglBuau/Hj4YdAUFIuSROAaWi1diKljNCA/Chergoy5X5WfPUFfcuEIqnO+Z0KuRJnWozkNMPtg+GzwimP9DDLn+605wiLG23gMgCiW78PpF7+u/pUlRU+bQjPJF6BqXPUPr70i2R9bqYwjWEJkmY+O6AFUCN9vYJ69Dt5Psz9H3UsxfFWugSi4aGs/LRXcSNCzA8zdnONxZXwiS4+9SazB0y6ZJNx+E4VGbL4an1P9Xd45gpAMCDfbGT5QHWiSialerbUt0YbWQqyRhrRNCgusWLTnX5Q4D9DtamjeJEFviJhzMUT6LCP8CYH4qIAp4Od3mozjptjFQrmNMhNQhjfoDDwsbDM8FeUlkMRoioPS5uqG3YwBMLlk5r4Af8l88ZtNmeb+cpoDfrCzemV2mm7pWexzPKTrh8EMw+mzeUfNqxZBRfM8BZXK54g7/aAUFvVkKis3s7zXgpRCodby8dDxDsviYixb2Wk7TgsWNtobsREM3jPKnzxs7EEvQo2UE24WGVUD/K5ORJL7j/LKcfEto6OBwrxE+0YxtIOygl0I2bqNOrvMyb1/tX/z0PFSj23wcG0f53cWUS2x0G5PVmsxGe/T0+DXLimivIyXAeQhj1RR66LUNWbxWN+o5fcmBs3tatlDR/rX1iTjpejTbEUXsxz2h23x9AdUVNnTYNM67ffnsgHnrcpe5h7hUxZhj1jDQf38RonarDwhJFub/iWmky3vvpjxrCfmQik7BALKVMGPBJ8SBmlHWeN0xsgDDREcPo/seiHLzHGOg2yiNzcZJvnwpFP6ZOgdkHdu1ASj7heN3fX8bQMrIVVwtMJ7hwFWD4j3FBUKocanLTnjzJdtjUKEsfHPbnUOrZk0g9W8l+d1MPQa1YJ+7c/SvEUX38e14bCi+f1ARfALXDbN9MsdFFFNY8aJqSmFHEtSb8CRciPxVhAGuU/YFq2DLaZSWolLgWBFeTkb+41zst8dkaCCQD8I45Nz/TyvSjTHiTBHNQ+t3EFNLVDzX+8WhCR3Ov3pEWMvIf6MWwxaYd5CSmKW2sJijFT+zioanFThptNgwNd5wbJQFkVMbmD0NCtU15sGinXn19rtWrt+dOmC0jy7tqWQ/wQcK28Mnoxc5Kuoygot1TQuEZdZL9VBlzglm3IL2ZnK77OC5kIYQt/PReLfwnNAVotvwe9hYgq8ZcxSvQpewPsHGHxKMAoBUdnat3jM5NiKr0ki0EO2Y9xUc/MNJTn2WzUMSvXAqKiuL9uI2VhpfJkYZIFlcCvtkaSqC/ASnk5IkqKy+PluQJCOmqkvjEB7Mo8cRxexo4F/SogBrh+SRX8YdysYpd82u+iupmlpItpnH1fpDsK7jrzyrdoyhzbkwYu4jXpILQUB46aaMHQuyt8D1UQkRtBZ6tzpmeVHeilETb1xp8NJIoC1cyMtjz+S+aAjlnPU1xQLjnHayIkoRuur3dGqyfqVmw9tBTzfioziZb4kif8hMd6117jE+S24BIsbTuOTz1EvcQoRLyk4Z3HvNYMZt6py0BO/Zx01h3W7jidr/T2RSY4YJ22vSsntgyrWb+rJu1qDilvNCMdgqDc2xDXZrGqwn63oWM0JDhY2yq3mS5ows0+my33qc2rIK3M1z9Gj4KY6F+TWRn4NWtCPruE+F6iied5lLYp28YS1K91PHHzmh3qZs6iPGmJ3rlJq7JOygcEpeRGVPnNRcEn3KxUGeqIAiiBuIOR3PN+RA81ou0W8V3zdDZRwux6h8/UFVbtILTJOjfsUdbHQzbYYM9emNVd0fWAgUF2igWzXUY8sHOdz+117WjvtzU6EVnBYQ1oVc3JUFcTCRRw/qqQ+U2VSbj8m4qAy6z07PzkFBHspZR2wGT6K95qe9a5sNgWYRs/klKXYJinHEQdPCOCjplxUlFJuLSIZSxO05cq7ZnJ5M72nKpR43K9OJe0Boq+0+uJmbeY6YbYIp2ZBzbxgUcR+avrNAvo368gPv9adI0LQ6NRuj63AVW6eP0BeEc/Kht0R4yb3KiZTvhMPSuVVp/Txuo5RPkDDegbQsG3v+Zw8ubeHOOp8g4uKxn4XLQnrRp+6IUyISLwyfUNc2CQNd/zDhwHWcybAtdb4TA2/6cxFdT15KOj89qR7AV7OkMFLIQAQPSMEXZnNY3ammutD44TVNtvRJxyCaFFEWOFQSoli0/nsxmiLGcSv8tNtljAed+52Dif5D1sEn47+gpqzt3mgZYWsdfI/THCGQTc1oFiS+NUcicxZRPRc/mH+7meKWHJDSmU2tCeMIErhjndR+5XudivdUmQvYAo5lYnICwRzk/IwocRhqFKiesmq/Rl1G3Yw7U+bAFGXfX1sHnGj8wLjRrC1k7yafE+uvyLNuI/KrpRlrDlC4VNyDPu2xr5cIGk1RJmI/iB6u88YTJaa6PsoJPXVU56SaLBXdB7wTwcKNuzz76ESINuJpOXA9zc7SnQLMADkhvINJCwV3S/rC+AWmc0WskMhO6cGWzlZshxG5NCyir7gy7ryjxjRYAIITIAYJGXBBl4aXN1pnDGQmbzRQ/Ls3zm0Gsn0ZvHmjfiZcTt/Ldb61+TM+jx8ba/xRectrMHDjNtnWBg+2gBpc43P+r0NUisjaDGIL21f6sRuIxCCYN+JZosaq/Y52meamQfAONp28OmqJK0vsfKqo7Dauw5/2nDdLNTIrigJIOQs+jwa0TzBd0U09Ll+fsopTZSReeo/w5lAem/BN/YRXz6ueNigtrT8pxt3FEG0mCeUmUBKNOzytM6q/c874k65KwsgOUsfiqK+vBbWwHKZhN3fMlfAmhmMtGJ6Z9UVaUTH+007Yrw4ZsAgRrn4gV8Pg/pnx4G1BoV59QPokDg7P9VNyum2oLn1Bpr1/SlUT10d6UFwgL17QGRpfAkEYoytSaPeTJjSjFwST7FPh1yFGJyivEZNQLVvD+VoeDUzUpPWFL9laflTa4njDwtaFRRx+Hgy5Mj2JWulql5+jUk20bKDP+BQ4it6MReofmQv3g4nin7YwS4hUpGcBqXSF6fzSK4z5kD55ftvSQa1z9Fpfcu/nKjj5bX/oVgVu8RePYIozcJSTZtlgEetSceqspNTzTwLUgJh609HJH7UGECEphnFzHA+shcwJXIoA6RkE7xmW3U+l/Lq/hFX0jN3Pj223Ba6hjZARxpYxyZvYDIa1Jlo8hRzlHgH3oH4sWiqyudHzNYIZKzAPyuQyY13D9Ib/AFmWWuJVVsG6XeIoAuQ36i+oep+7pD07MLMCkwpMyu3ehDySvsC57VWIlddBjr4jfYEgDxngRijceSERg8zbm5YpWM+tAFz1aAM5pfat6jpDA8bbQaiRXyKbbaaQFg+iKWxeaBW29PGpN9fTySh197E3oltRxRXnBe878TZngPiRZ3ApaQ1kj72cBRawZE9df/q52xfyub/WWuiTb5ROtqUz/LhnEzqrhHmiz7VHHhPS7OeM4F5iCdrkFNSHmola4zkkx3Z/LCXxQ59+UcuQG/uA8JpBJ9emuSyyPTKFnBstu8+8J1YoWZzk2jLYOlp6UeXYhjD2Fe/rRaZRHB34Oqpv61RiD6V+19jQwBI6o4la9rCuq1HyyTCRWt72G52SyRjofEEHLdrkBDRe9FbMdtlPlMlwRPrkocjJy9eN6kpHx4gJuUYfEBCqcpPXatXOw3BNZhbdt2gSWTnNW1/Cc7WmS4f8VJHPwu3VihBINIxi14af+mG4yJQUOtrHct0tNfmuX8D2VWhNNms1tT8bkRwzfvhkQ+B0Hgur2mabBP8Idhtsh3ZFLPD6fcoOay/F6jo4LJ+/v7KdicfQCeSqcQ5hZjncBNOF4GhzH5iD1PcWt73PLKT8e6ARo6FoJeVPEvcs981H/h+2JbpwJ5zCQzuwGDxdhBRngsIXEmAgBuSec8I+C2+7G0JH8bnagF0+12d6AOitLUNwqhUXieooH0ZqSRlniyAg2unFH8Y+WubaE07L5DHeOwTkzsRbEfgr4OI017uCncGmRzsurvM9b5rKJIVN31cyV4BUCC8j7/yVrX5REzhOOgN3S+OIb05KhIjsKWXjJuWfzL8nKkZSOi5eNYvWe0yFXO0+GHOLY6KK38oOHze+NxCme0Iv0etfa6t9J+Sl01D0prqCA18HP5knsGfpDH0aucKdA5y6T6iUQb6Q81anfl/bZN9bCC9Hz4yAeSOVqu3ggYn+MK/gEGfjYIA3BmUfcdFD1VLEnIzV4uGmWvJp6dUY4Ixz+zNxt+e+936fdsL+tsCOe6Vrb24OfhGpd2gPY6JUWcoQC0W8ab8d2YJkNmQqvdqFiANuKmqtEQMjKf3pnIqo7VsQDTyC9/8Ppj6i5H82EsaUbp7Z+YQyuqsXLrVmykcoFMp7VO4aFtCN3FYC7p2y7Rk2OM+rKyxhHRSZBVoT2PTlQg1M8xtf2z9opwlkrJuPa/A2S2KGtDkEeUnNBR7JIt4xANdy+jytjQxQIDoiG73QD8Zcz1wDA5iSOhhLEWz6uVufC+/+jy31IfFTMNKNmXFCWTxv7+w30sz+8HDikMYFR1iQB/Hz1q4UtmvzfdfuXYSzQyL7UyjHYt6VqTUYKnICxkeQpYL1pbGnwd9wqCkX77MyO8BWCPox+ZYt8XrD102FhrR4RdrNt+T+7jVtrbUGMccx+olJhOkqRPbS+7NrH+TX2Ivm/E4hH7TgkwUZWpRD6ba8YazpRq0PwdGnKiSAHDz+iDrc31zZT8cxpsfw95MxReXl6lMGpymvoUdHu7zSiiCU/iEaYXTjhDBYSbEOcRnVY+svUBFq8xW/P1POPUkJQAJAwRNPdxDyhiOCwoaFwvUtLwaa3EL4qkqq8/+JDO2bCQno44txeHDVOVeqds2XbHA6x7d2k3YWz87HTCqkryvdsM5e12jenR+BGpQMMDuJNpp3YYzX2ExeLq1iQvK05X+S9Wx1N9iPSGxnKKRo8ok/QFkPJzq0m0RdRTN2g1IsrqZsRR4gDbr8DvRypt1+EnC9bfgDqBcD6OWtd7yzJvjBYbndiO/mlaD/56B8/dcQya/DAUI5ruzTb7u11fGX5JDOaz61KzTSCpB+jDl4R5WQcI904mAy0H6eNbI4conFRTVNCHCe4puNQicJcI9OK37+/V/9RXoLt9eRuTD+SFfC793sP+Uzw+TGCK6oOjDK7q7TqYXafnBH1ql+mjhs+urRFDH6lGN9bKhnxGZnTSA5mrzOJkwbw/txyN46Rw77asmCXvenGrScAHUBFWEz5/ZD1JaKIT0QdI7y/fBYqXDpeSptNhaJyZbx4ClkhohScxXbBl/aEV/MsAFRRDMR7lO+UTrxtTE0ARmS2JdtTQUeMixemwf5QeFKX8fIUNLOMVRcts5ep2pMcaIqQTGnEM2pOLKASAQ+xx9O3GvkP0OsIQBVKMJc2A7qgLs6X+MYU4/1BYjvalz5JRF8w+iXtR6E2q0OTjjxT291uXrwHtGMNaF6DijPiHrR/rGMxSA+pJe4ADTQLdWGm/y1WxuAVNKRoHbFCCd4ABE/tB7ma9ZiUVsmagbcJBv2hp/feO+CCoOR/ASXf32MizO1K18PA+d3a3a6IVOwi0btNqjkcF+1h/ojFGOyWt9ojtJKRooVAjo2+cIO6B0A6QDVSL4Yko+aqb5iBVrLeiZrFjLD52JWIRoN5SUdvZLXvcEHCyNrXm9RzKC/pvlM7DrxB15yjiIrV1UsNUVNG7IdpQRs/go3l3EHcufN+lB0sSwENJx2xg0qqSjYaYigW8thow7OSsRNqQTXSosRmzoo9h3Fdfigu1KK/oiPBeEruJfTwoeOHX6ic0G20g/vqkPDMArZ+xgr8/C60cGE7o5U0gNJ6t9u3vT3gt5xCbYpUAPR8pkf2bPgSRJTfuh37fszzot+AxNu6Y9Cj04aKgIaCw+2hlaV6emqvy5L/GvFpJ2ZdwiVfAcJ7FIqI2gXiJnqOhLlsUrAiyZ71xS//8BN+uEN5fMJChp1vxJljGNpQAYJvGxfbTRLT0cIejQT7xnyO3IBbnAF40eKXYsHJ0rOZcsy/mbF8IYxIbdGOmNR6o/WuxZEKy/W5mine4o7iVyeAUctnsup9wzvk+g892l/J+uOHGtsa+m9tTTEOWFZvR3VcaY3sJpr6YtMi8W9XFDpk1pR8wFqaHPRXhSjoWHBphia3icKs70g8XKR0gJhxTutzl/GDrmWWhkWiBLQR5WqHMzmkdwOlHG7O6duA5GMMPre9UUQJf8cVy8px5/LwE2Z5Y/9H5LwQYZMUvF+nd1CzgUYw/PBr+Z2GE1XTGYXICrzt4Z71TGTjutFUWwyu7ndgziWuqFNEBNmhdZvPOG5xOKnLj56eo3S+u5C9bRUSQoYifFR5iofTatVPa5Tzq/LrIuuUV691EZaHim3c8CdG5wmIIVd9fc3uewZDt0ImQhEcAllWK58fRG3Qnm02sWoV5y6l9ChHtMPt9UZ2J3jHxixqlg1CtoTGdmbAxc8AHRdS9+i1tbzrWcrTW5z0oZDE00Wq/T27MRFFR8+I9cckwZeCWw7NP2YfdYJ1gphHt3C6QyQtnPEYXRH6F4WQ+Ui/00S0rpsokiOL8KmGlete2vS79ZYwacSv1Q9NNEtgL+sD7sV83JEob5drI+dJsHfLAMC0ScAlr6nkh3ISoo6/AxDAb7xSF8F2X/RaSg7ghbi4uHj3oeiMrGUb9Kp6+XMkk7Y0PUmMgtwDAA9d6Bns6MTKefbP6lgvThhim8UcJSuPfhRiFN8pYTqslIfMnpR/0AKsCKktrLYfXE8hI1PDiAEv3pO05iRjz+e4ussnvYa0WhborGR6L8M7kK0ALUsemQneSycz3Pj5g86MILBsk6N4frSauN+EHG3Sq9oBGcMlAfiLfOcPrqNAPNO2dY8scZbIuUun1Np/SgwJFLnEIQzWW3iU7s5yhtCIu3Ho2gKSoGb4sVpBpKL+ZXwdd28Kzg/Tl/ghxqOlT1rwtSxOlx6vkt5/G7FHu2zMCNNwv/vzUElpEdBC43EXd3MIIp3t0vOqmNij02TDUFDySH72LX9l0I3hJiJ7E+yUF2Dnrz4XMAWJdFEPkW4zKgUlCmXGN8JbiEiKzaNMDkXGM0VNhp1jInmF422uwVuZmcQR4ZcKzhrgrVLjmRNyeHWSWTZWwSq7mWUoesqBm8Yg4RRn0mRzdWge4ydRNr/XHrLxy0b9wWM1W5FoqloAifseSBI4BG4GBgpJ43ycDY9hRaYb8dUJLdheQmJ/NCixBK/aJcIKEf15gwtImsnkXlgBxohOEk6YLC0BW6CegFYxmmNHqoZM7SdDpelUjAxE3A9flc+lb7TWl2qT7aGGKgpCPY/ANqyiM1hOl4pcYq80o4hCc0W4+jVWAytm+wg1pwGJna6EA4WqKHpYD6uq9iKCdYy2+Fbv1yvmzzS2ATDwbZy9Vu51I5Mq7vegViaeygn6Pd78jraWXvINuKTgoQQQSqWiH37X6vfK0WjhXwhmwxSnr+w8ryOOTATo3dvMgpvEQs8icPkpPw/M5ytxE74SA/XZ11ilp8ENTITbkGBs5+5N4LIe95eDzvbp9KTtZl5vML7xkT8aYv1NsaXXyfpkm7TdgRfM/nnBb9ynMj6I1lOK/rA+0OXSLx96aiS7trFArggEDKVWr+8/TC5IBExbjZumoY97LGl1/kYa7h/L7xI2nbEW7miLE/iQ4NcNKCfHPNBI+DTG/63mSWlrDHZ5g///RKkORiTrgg0uMDLt3XNsdAeHNfM0ik/IfXON3qz4HQt3AHyLBSZKvX9M+ngdQJTW5TAt5nbw9OFlr4BSAAGWwUhYHbWyTSg7di5R2A3PK5fWtL5ZGdqHvAeE+a0Oxv4wOxR9LSoSwywDnW7p0kdVvXq/E2uY8uMeAlu8pIt/lTnhN4pTVk74+HPSWbLhh3tUCT8HSxuxhOZsxjU0IB9fDUvHi6tyHmfiP4ujEimlOOMrKQVobczOZwbZGe+eAeLPMXbVqUVnIoNa9nr/Q/0mn1XnRuk4OuyJKT/I67DC65iqYxPbizUkHWzIpaYC/aJY2yn4y1jV54YoJJJtSlD7mmLr6vSVvQJGCtl1B/hn2NsnKnYo3kktDlODF/9pi1RnPLdjbEUfTPUsMnXERaRS0WqNFG/OGqfCNfETOZVEuSMb0unDh1X6joL2yGDPSRSJRYrjDfwA8OM1HFopkm3/KOjo0ra9QmUYSe1JxFcI61+3mlu82EksJsszE5FEPTubDopGtBDhrZnlkGQEfG01QynggKlFGQtukmHhIVtJ4nwnYH/8xx9+yE1IazhrO+Ku2npbUsDMUoMwPIVpLaM9pNn1T88hqWzEEozbqd5fIn/L8HmNQYOyPY9dtyId2g4M7mylv0lnxORWllxZlmAZaM7QsrCN0iN03dFD8k7O1coPH4Ax+NUj76E6p0Z8R5sx9Noikuit60/H8ScxVM+GNe259xykV0QBmY7NIaksY/Z5y8W6+upTfGkJU2qY4EbHWsPS5Qw1s7ceRDLvThP0TB0NnAIeCoY/ygEBrjluDkdcEDUFbWelurGmXNM1fPJLep6RVjO/z4gVOXEecoyO8Tw4M4zwG8AbE+z63KXNzqWVsxsL98NYW9yPiCklUtxxtHyJ1J/PZQUcYswi/DkfKFcEp6xq3Oe5SphflUvk+ocJ3cckn2Xd1zjnEbGVq9JQXEhpZnOLvrIZMZ0x1Wgr3qKEQpIFmefIZoSzrPj4X8cPfYKnxF9vsbae7hB7o2WtnRAJ9gzLYM2WfhqrFjZ4v7ktE1HbRRHGO0CeYz1tJNmVq/H0GRiNeBvRZW9cKNGeWqSVe6zakVIpcktyw7uktym7tdAJ8i9qjN/rL5huCrkLmqhROR89na3+2LROO8JebZ/UN53u9A9vs0bHG/yTnaiLnX5tST0dl+Uu7YP1hrmqNam9Fy1YRPo2l0ESIJy32BwB+ZMLp3hDRrhTfruPRRiONBb07zoDQyrKaJ05rs6GiUKvaix/1dhmKGlGGOKnKl4MMzH9H1zi457wHeDZEjQmP8Bd/Rra0HiCY38wNIjPMIq66+7DY2NfczTLimoW+Mw9oujZSwPJFocr7INw7RDsloYqbgw+IugOailRH2en7cl6HRfbKO1RECnRGjinR9fhig35VDlo5Zn/yw+1QDFEhELZ/0hMCFmIxyCfAKU9BlRUQR1+iR4fU6C4uI/ADVd8xIwnZSbd+S/5lN4YwZ4vuPWx+7co2VQmJUYPMCxLVVuh6onaIFZPolnOO+8BCWZ0j9Ro9J46l/xtDfsVMRzFA/G9D89CNWuwV100DvC3mwvVXjE02HTgcmkXRRnen/xyhGHh7ezlwkrE+7dcAuy3xpd62/+1btUFvCfpJLy01P2hl9thtkpLozwgv1j0U7iwxdsNmgyyusuyLpab52UmsVF43fehpjNels4bIgMMyv1gafhdTHWK1PbWhAjvNNBGsTjYxGK4Mhjkxs4OG08etA8swyGxQCSJtH03p/UV/Q2AyOaL6iC32ePh2TvyYR1NH/5BQS5hkWFu3v+h/9l22TmVbrw3T9/pTucObswvstiXnmq7nhgyxXEvINPEX/xC+zaWJyYlLCu2jyG5eriAckTUJHkV9Xx/1uDtaYWOvuRrl5YVQ+ZjF0A63M3bHA3p8ctiTZSDIqOBf7UpknysBI5MsmWjhaFdPz8EgXcQf9TfUH5OTlS1KmFyxRn7byYxP+2Xq0PZ0zdJ0k+tetUXQdwcwTqpa05iUr1PFF/PihDf973RcEtivLIPYGIBbqhI45SZCNUWpQ/r/o8J7ULabZSOo0CDmGwHLMgTfmqg7q4gkqfznjVd5WnLCbq6y1Lo8xxXs1opuBeSoYHjDpFzj0AhdX3zZ3AXvPWwAJHjrnCDzB0wKerQVi96jzVuzVGJE1861TKerISvrcDHyvYvNWZYeZuJ/steerzUiDpnKaaqpksCJSwWM7eWsRUAfU3+1EEq1j6iiQUz3B/sMPj3pZSSbB9by7UHEFxZ+4tOsi4vthH4fpT8kYhGYKUXvz4uWklFo4/CmoL+/0rXy4+NdjUFV9cMA9cg27HTz6nkms1QK0OqXFizLy57ZigPSf9Pu9iDHiKZowrKT/XUys17EqIW3OKj23p6awZcVutw0MszWZZDY/UjyFAFJJvNRQT408o66JMLtW+EIgVFxy02YbGyqSd+tvDyLuID+Orytj/RuteKuuQbsmcC4f498ncAWM4eZ1m+9T30nXmpShbLAYJX6nW9RVhrDEXZNqLRgytkUPWFkWcgdl3c063HIzBLprctbMiRbrpj9DyazyTTrxnFtEiPAKV+WPYkJnMN7xORLQNXNHXHpPXeDmCverpJYQfimuY4+WyqZVJkBoyJ+2o16i0y1zB8t976cIBSkGltdUaWujcojXLpIgK++7PjwH22bqh7Fp4PoHxg1D9cGgfJtu6SyK2mg0wH2CtpreBTWAXwf3PaZzBLpTXlj/co/Ar5vZ5JBrcWQn2WqG0j2a+jnP0vl6ab0femuEshW10an0v3iCjPzUShclQzTMMEvAx3iUJ+nL37qrgxG7NlqZ/AlZEKF4X0ag2c8qun4zJ2ODO8FAm31TcvqXbUQBL+nVDEnmtd+XrsR/Ub7sqrEcnJxwq1Gs/Gja704CPSJI/s/M8yB1dva9Uq2LRy1xT6MXZR853n0BvxCNu0QJPsRkcTaW1bbp9yKBynBw+RCDZ+mqBxSuq/D2ZewSX9jMkLR8zJ/ukUaSH4ZxGx3f3YBuV4k3ffzwgYSEf14wUVRUHRYI1R2vbaiLxPJkxyTIoOjJTDGGm+saW0ZuSWKIwsNLyDTpuF9KhUXH7EdLCMMYax6CC0EHE7/Rdqq7W0N8gK2PExn5Nz6QRNUjF/eixu3Fo2W/mGvhQDGHvOCnC6FaWhSCqj/QK/VoUhYMsFLwqQ/a/cTTU+uSbPPUjaf5nZ8F6JWT9FJbL52SfWDENNPhVsEU6OQcKntEd4Huc1eQnUCtwNBrfCOUhhJxL+A2lURWHOiZ3qkqgh6safjKIR6DlJJth0VwjXkPEw/khe9hWMXJRG1Dj4QSakb1mel0C96xa+H9dW9AAXbsM7QRauntIfHyzitgpqHzPJQLCKV5VaD+GT9ArH4xP2XJq7d6OrJ5HT7bJfy7zOoCYrej4TQLAiBexoLDxNmXBMKsnKJP9uU+HgmSggob7X7WPDkDree3I/bDMd2XnUlosIU0vEvZy9KSbFfPeOjlR/zVcDFTIDg0QbdbwSZHOzQPzVuX+Bf5+3Ehw75sXsUhKx3A15f0YWEdDQC37VR9yxo5Q7jCMhpWNpoNYgpF4w9CmZqDaof59iguhVlS+kFuN6U6ftuSrlz2V7Pg86zn9YUZpiIFI4se0tKueiTrvYuBxAXabxl7mArWfMSFajTCP8UvE181ZBqQ0AgvADuXcyNaxm1tvc+F//eeB9MVhoQPYFZnXzwdRf7yOmTnNSLmWk6ejwNFhAx+8qQ2xBal5EfF1TvTY+2Vr9kkBmkx9Sukt7q2pjUBT+Ag5HqKoLgO3HTZpxBTvslhQfLiXv/sQM7l04NizQ8tmi4IaXr+QCiF8fyvsUmZucF4v/snkQkUp/b3AB3u1K3wSdAG9Ly3utRY2DQ9W30d0hif/1N6D3kwKDjX8QSI2OlbgIJ+11dsf48gWY4HQUTtg5Sh6Op7QrAozrL88Hi4H49/oWMlur+cfgNSEsn7hoxQaS9sV5N7xPjdTYmlg24DSphypRFeE6W5NgOIIWua72u+uB6hdx3lWfCK6MaQkxJfa9XwdslrAtZ7rE6EMl+etOZMYTwgeZlwCWfaqy4XCgnVmPfb6OsIxYKyKZWBFJHci9PDnhl8Re4tWpl700FjrV5Or8kdvF9rFmSRg5I/M/wToAODi0eMlS8Vr7E016ADPoG1AdMEC413IJMclgUzGlsent+7f161AphuAqN4vBlkRtvXY7VVLtFvmWsM8KdTmNfWROygQCeo2jUwO2B0wCIs/p61ZDNaIrlKGz9xtg86fUvNb9BYs/R0TKyyCpL4cR5ESdbgc7jssYOUi2OGw4ec5DULcD2VHgSOdxaa/K32qoCSKhlohMXzKDnPIJzJZpAG/4FAXJ/jLpqNpwMFNoj8aa0Ejx9VEmhLehMysG3+kjU5kJ+N2cmloEfUE790kJG9q6rhg3mqS/iPLmoipsoMTsToPRod++xPuMch2KchUyXh39/LGlapy6ps/e94Dy94E9qJ9rQbfBz5yNLLZalqhGmMxvGaS9aKzWpapOwHzboNK80vYQ+ktCd4XhcUsAhKu6WR80BtOW4h5OYrOE+y2We3z8woSrtJPntjKma5F9lWTE1tZSssArGN1V2OFbod0NM7oBUEhItRJfxn1bUSr1vLHtcpQXXWCzNN2hXBJKnxpDCqeCASCU8aT9wMVlmeZqz5rboESysA18IPPzI/Espk4KFvTeYRX8H7vQDQTAv4eN4U/ACK9bKDhYBY5MnyDXgCmX8V1KREkYHshEsU7ZRtAllMqunaTzWPC5xhVwyB2VaNYSfiLp0dOEd8MgCWMow8UJS/bi+roQmpQItM3hF+kcf4DhdGOkJyTG2H5HxJT93A0u9zURopPHtZx2kPJ60+XIi8lx0FLbgzn+FXL7UTGcyizbFvVDYFwxL8eS8N4wKcLd86UMFPySLAMse/SN/3HjEWH6acOIGknzIs1bt7JYy6w+Y4TNGo1wQjlI5Mm0p6/ciQvpHtlnBG9DTVaeNFu1eECqXAtsZ2AKTZnJREaWl11IiNgGdaJ/9Rj6B7EcZ7XCH5zcedZIGKh0WLr7U8LqLGW1nfESJD8jZlULj+cr3bHVRZCACAMng+KDn9WJ81xM4mQq6mazKcd4fH1/NKldxitFDQ3lM9DCByTgqBC9Yq65VgT2k+a980yZnR79h0SJucLnvrRp2K2F3VRJmn61SD9ZJQWYzvO2FYwbCFnpNBT5G8UaQlbNcemgZXws/CJ9aZiBKE/m0WZLXtWnLVyqRC27vQZJpXCQPQYkE842rYP3CjPGKLcmuBWpjuNce6HcRlAbC7TCRANWqYcB+7w4HEgOSmS5NKq1i5vR+jJZ2sGirT3Fq5czRoVh5fHUTuwT89+iPDRbcXAkTYxMw7wHxaul5NPdO7a2+8jbSna2OO6i6pcnAj89eGTpO133VOQyHt7yPHPwJ+e7VBnniSwvhIL5nl9qRr19GN5oWdkejPVTjEqi8Td/fRQKHva2H2nOs/cnBC3FmShEo18ci/ns4AgYEKaKxq0lh/6THFh3USA6utHmBKQs7iFKBWFysUGMb/f15FsF3aLyxbrtXye1TmgbiZZeqDSr/JlO8XOc5nMIShKV2bHP/ANhtVkZseTldZHlOPy97QHokk8kKtsU1RDmpNxJ5oYLM1txON+xz56E0dtkJyOQAqMGeF5k5EF64/nK4BFIWXR64FksUFsTxxv+HC/Xk31tQ5HfBd8Rm2lcfofMeCMLor6Irb7OmOq+JhqRJGJtQQs6yY51oAu5Rurj8oJppXmDcpg1r+khudxrg2/AZPT1CldSbqVFp281fmUgYiWFGNxH/dXfBH8lZ4S8BxBIxMe0kEji8/QDJd5NEetFI8Uqy9iCDnWtvGMi9Rb40OtoHWD1oDQaexBCGhE482+JqWdnLkBZfHCaqOEbbIDfrIoYHp3+sxiWQ5rLIxhGWrzzPGwuRCc+wWMicHYoNKk6CgNCTvhecXYv+fGW+o3yqP2bIS/it83XYK9DLVkbMUWWReFwxds8go/FzqN/dKrjMzWcU6YZRpv6V9R/Ym9ZQTBEq73j3lbUPRNKJzMFnfY1twwaW4JASq20ugtzNH/jAq7mf1CqBny4c/4T//Z3PCNkMqhveH1lWSczdiwPmgChjtbNTuRUICpChaLspgaqdYE73pWAfU/JgQBl0+/bU/sTuuXNpZYmSLV8ax/Tc+7prN3DhmtzXqumgya6jdorUdUD6y6EVRaWl3OPANHkaP6YGaHqgVGO9/yYQxJi41ppyymW5hHJKKU/dtXokTz3bsOgkkeELPMi7IXOtaeTfwh2cr64uBzcarbN2znLZf+KpLtysdKpG2zv2hpgeV+tGQxL/DxPq1DkTp3IPK+dpcWSp1Acqcg6PhJGRgtLu2pn2lQgDjGqcnTt96lSUggB2ecRyM6gIcA0QE4nLsode+Il8wMOas3jvl6E1MiGSYXDVOv7Y46BZvOQaJ1HaQcJgKCUXZC4cT3VtTp3bk6uQEMgR9ADIDZTUKVRfiv+TutzpcCcqLXDUQRqIUzsyx/J4RCsmGwaLlRoSP3prZiRIF9BDZVlexZodJT7fYoCq9TfS1GkR/XSr4ygvEmQUbHCQDkHclXqm2orFp5XykUo1niQ9RusWuck5hTJllb4pUiVgOPeKv9uQG8NFUqTvSRWBomxV970kbmq6VT1okypJcd6IurwYNBBaEmIa1Fadr6ODt3izIfqNocvlDXAfG2X1OzqTSiA2/5pr4Ms1u5v+fY6ZyOD5Hw1dz45abSRffIksE0httMkbQKYZn90XaYPTtZpii27OzQquaaPLgV0HHesQWli79ju+mClqSZDcNoCu1SKdI6pfdBMNnJLkBZyBhP+LVLN0LpAqnc4ColZTvaJ7iuRH2nticGrb5VnaJzFIuRHb+AMUcrFQ464nzjvTBVXlactARAHutwwWbS/3MpBgzBpoeEPQOS94ueLcKbFMpy4gxqHiiI//88p2in+h3BmizhGOaDzjQtDTUNId31E/j9NLXaLhvUTotZdZni3QEE+wUkLL4LDy6Npk4FfCZsfSbUVIec7Dw7PAUrVPijlQ1bEmEWRJhGr+jaVDv4Def2BaMGXsvNqvBWkh+kTHUZybIKaln1/MkHjJGNkjZPpPR39FUcIKOut1nhtaXG83AqmkK8Wh43LBZji69IvtKS1TJjsrSBqMLREQzDfXGkTsVgmKGbRfThjO/YHtyp1bZ7hMV6g1Xvv7LkcX3uvFUZdj2yZ+5UFpUS7Fu79vDrUP4o6stj+Wce8pnj+xCTlc7cKtabkNzrc1W5jLDSD+pOg+jxcRLixx3ms+8UcM358Lrj8IS7SVX6mEYeB4jQWAH2WBuw+S6K5wClrM4yrrAiNcppYL6F9W3GnzgMhoNlqBhX8dChjQau/yA8Plb7nTICmNK5jCq8OQ+KxSrdQO9r3MjyWbhbM8ihkx3YI4XbGnm3BAuOLR1Fe25lczHAn4UbCoME8UYLf8A8f7jW2NyDT3nmius//zeu2dAbqBPGbKwXysaa5D14IE9fDJ8PpAiwGVdPXvtfX+0T14iAwskSFV4HRG6upjPd6ex8VIJ2L2Yn40Aaz1JuiRp+AlWWsvAWGma3QUlvM7bj5q8fhb1BY/bY2nxylVvbwFsDQhZvRzAOjL5RZqrd6PAIjRQJBk1gC++Cn62eY4nx4YmmooqU6GfaRdbzI40z3vI9MH0H8LCCVzWPArmrZIo9nt4suXyOUBBfMKw1WumLYoVuW0IPUHMPnnZnVVIXa7VSs3V0Bl7SnamTR4aWiMmePQTHa3N+BdzaQfa7dhMEL+M96RRFQ62YzWlbbTP1AtkTjuuuMrspsFP7PK5/byN1y0JhNuBK3kazQX85TC8L0Sd5fKp1hbvHT1txYMJ9fiZen9Uu3SnGiXbRkePtX6qgjXQ7rThKbTWeLKYsJudWi19FMVYIef/5aQsy3xwVipI20Hxo4OXiZAE8yPLRYDVT7GpsxujkgUDR682uco5wkvlcfJhxrYUH2dE3vFPsJGCeDlceEKpziBQEn2MppVwCu3CbnueenRMV9Doq9hwPa0gtUUFeNJ/UkAZNEiU7dLiDMPkk+kRu14Q7QaSFWBGOimvRgU1fVRaBcfdwFdvf4uC4r9D5modrT3PK5Fqw5iaBw4BUAphmmCrZsLh1Q2offdgxbk+gkTc95GiHiT0hJY0G6ppLElnrV7BaeE62y5BBt9jc69XzhQmyy/LbdWr0DUtSyHjtWKET4I22eAiIp4rzNLFXdTA9e6B9o7pRccsSAcuEODYC+WS2XujcVtUoUPnN+myRK3245QaO8JbkktQR/g65BrLFTdkV8OjBnuoeqWa/OnM2ipq8d81NVFtuoLc4CBjP4ETM9V6B3QHIU+ci0XNkYIsycP5B74vUW/68PoYRbAoCNqP7F8rKTjTvgwMoITBJdzkm/uE9IIIHg0sjnemC5Ya7t0aVOs7eTcoDtkjOevgQOiIZjeRV2FDMOQec+viNYr9/DFzfveIXlJNAESClDga/J08jfCGw3cdQqp1gwCyjYwMr2107tP96LqA2kkGB95Ct7AAh72nXK4QzaQCKElvhnCtdYaG8tAy56cLoelvPSxBR1JeS+C4boypuVZOYtNV+vTghpp1hYcnuqpdynAZWffM1/sTNMv84yn3NXqGynoC9fZd/hh1n60fKbkEjPOIYc6Tg2ft9n0Z3YwUGUVR7pOHWKIhufQClvtA9iF4qhqN1vhTWEkCFBWhz8wpmaGFMLs7VRuhtWrZieIckorqCRGljPi4wxz57OdwrCfeAIuHwbBx01lTM8SCO24qDQ4gZvGffZZ8WzMlwYGI8qx0vFldOTbvx3/SsCMY8Yi+IuAQPYUI71569vfI/Us0sl8agwedDDUAwdaSWmNuQlev4UJfaWTzS9hWU2KPAUAKc7DM2yaDhyLREh6y9rpbLUuQPzMyLNjgB9wH4Wsqxh3WlFDOm6dWhtGOVSbYSaW25uUeiAxPL6OXt3Q3a4W5LAJtPzdjhA8S3mkMhiNBcEl2FVll0l4mBagGs2a3e36H197zR/fBD/DgY16NbZhnlasvVkPp+r3bWZVzxARAw9aZsMgIdr1sROm1UVMCbo4Z8botry3sbRxjqkBKsKjNtQxi07ZIi9YxxsOKsExpehRB71I2oIw6i7BaPrpZTggkfIGv+RfkVA9ZaqOYi6nEl9eBHEKSnTSjHky4hAlskrbpkovTIrymKFvnTWsa8NzUPjeFBtAuztCQRzlF7olUlr83J+llXsdPOtk1boHqGuL95cwuYk39DmpG2CzMcVa5gNGY60Gcd+4AYmYy+2jCWMfvL7q02gpoFR5CPrqCsROEeHtCu3Ab0/1uvrCb0L3kL6sgmjGnwSJHuxnWeE8DlYGt8q6RLQhmqLW0VZCDGHiVP1JUBm3+FmkSiQ5pADK6A54tRvRUswXlqcpEmSBRprYxFn4p4kTCEln3pawzDbsOgRDXCYU1bjN93ZeL47tlYiVCadlTp3j8jmH8olaKlM4tyTs1D+JHrrqFGLRiCRfoAsqzEmbRwO2Qs+AIWTib5dsaaSZxfSocdYK3sa4Y6oQyfPZv8srb/mYmVr3sD68uHSKE9gZlOirrWKGGnUYd02kQXyvOdlOb9j8YQtTXc0L23UiIbcUAuuMrDCK/yFAkYADy1rgRH/Kn45cQtqpH6PdQ90Ewh4HttmHwVtSEglgcZfvEV8OvXV3nwDCqv5LpmhPYYy3soKxFUp8uScq95GF73xLQKBImUcWCwcVd+Tix0fc8vBob4aej9vf5RZ7zl3tL0ea2ow4tL9G9HNFcmHb1dY35f46kgUO5u3q+4XKpARxK0IUpTq+gZNSWRqq++4eu+lVTZ6qqP0BpYq87foOw7FkS2sV/xOzuXI4wOLDtu9yu/Xea2Bb8JVYQ8EGyjKgyvb/rLg4ZmMwvQTxSuCiHly9uXwGrwvjfJ3cgcPCU9PuoStn3+ioc1nVZhF8HBQjscaeYJgCdsJRqsSAu4h8/PeqRtL+Wyo/WI9vmW05zSHQXTLSf4w/8ROljwl+l+qCmWv1qwCgyNkGbJOiYrWOugZJEFSVe9FzQTlAngOKcU6bxpYu6QQu+WXsN1TLpjEIo7GW/S/TZlIBnM08sngyqWMaw7eBB3tjYx2/uRGE2VQ+JKZGysss2I8T5lXCuf4Zv2W6GDV99n9ZcM/faOeZ/sZCJ4WACcKJrPApbxZoIapCSF784vwm/NX6yt9nJqdXJsGMshoVugeaD/p3Q03BenqLgZABWHPWYqzjaL0GR1FhmbqfiYRJQuUhCEFhWbJvXdAZwyXyo225LbWsQUAwR/Da8uTbXvalmEfgWmxCBHcZ437TFf+uA7rzk3tc5jkbyHYASw+HI0d8ABVzSfH0C9/mROtoRIcJk9WM5BOhTFdVEP6vRe4cgEAOBkc7oc0dnTZxIlDrP29uDV6hxKibe7jOOkpKMmHuj+F6cM41+hSH6Em6q2Botv4bkLt/9CMBi4SGMcFqQZnBdCbObjmTi5W2X+VJHe0OcYsJPrQO0n4aE8VDO1yDS27EOpdL0RK2oAk6N3shcg6A5eBQ9Pwdth8YXktC52bJMOgYCVuV04nR9Wuy0quh/OVmVju+pp6cgE5JDX26Vq6wHarKuX9ynDEmBmpY1N9jeGsfee43yOhpF8221WFkKUG3BruS/5kaGqmEO+Jqw7w0TtcYPlB6WtO/bAr8z+ln2fA1C7fuC7MZgIGZFzsiQy1wqiYlqw1Hk4KepRIK0FGPuRcSh1kCn4wVkwSj2imBkO71BnEwhdmUeyYXM1c2dDxGigsK50XGR0UgFUU97oNxjI/mtn+E/rMWkz+85qlknitb5U9efUblN/fohssUeIsGGmX/+nw3Dil6fhwbhQIuqIcUTTlQPxCqMn5g0osV+ESHbPHtHBnWccVpoJNgjGtadgZ+7IX2yefEG5OSKu9ezVWmZCKCeNHuJrbbp3Cp3xIwxUglE3Sk9IQmdivoa/nqkcz37yDB/bHXG/ucxHyGTjwZLTxagBTWsQNg3KZ9MH8H5jpE0Y6jA8oX/T3ZzHjs+FhPxOX3cxa+e4olYQ5JKREsL5ODQ73/gUXeiiZHPYLQTq97IJfppVhkaqnBx1AQe0jaim3YFURE41PFfdYpgyxvehYAsZihg9rXO1V63BbKXVxzTEAoz+WZXnB3svg9oRJcmDylwDPAeD3g4+zBqYdiaKwgJlhpjQtseDRO1u//N86HOI8uqBAFrv9EIesavqpUBC97gunEW0W3gv8d4FygUhwRvurkHwN5dTFr9LBBlKVnjC8AgU9ZbRQYma4X3T1dJaaxgj4eUW+TuWhzMz8OI+YP8VJv9jfsUnkbaOtDWQW9M+AijfKy1tV2QsMwg3wq+HgEVaFYAzl5iukDcMfZm3MrKgcsHbqm2EpcEpqJ+x6f6QQ1jtl2kVl2iiIUsYGEhd4ijxOHiFPenRsZYm76bNuQ6/1TZewUdJonU14eil1itOpJTJ+nBwLN/z7IHpRhS8/oWdS+G/XCoqJ5wu49AyRn1DOLYqXdMTPGTdZqND2ga4sCZ0ijyaz1mES/WTQSdGz9gJv05YbZdWXlOjeAj9jZw7Yxt/2Qzo1TUCAhdRMlx9gVz2rPIIIRyL0OkTCibZMSdw/49du8PrTRMO5gskZ9kgLtWy1cSk1vZ6S3Zy7TGX3Iha0rx1U71g1jP2whBeVwygzIlKwjlnMPXHFX5bkSX3tut5GCOUmZsfPeU30pA1zhfjNN+SmnPIlohdB0qTgBX7NtLbo/7RJNGUEBgYYM/ufXOIJCVpjVHBI+isAbScTQMR/vLHeSWFt6SzZllfDoeHiBi/QsJNMiFm8ByE734E+j9n+r8E60gs12zki3img+DRfdW7PH4VnZglHJB/2/rG+oiegA8CbgoQkgJWVCaYICUKVAgJyUsVJs2Cn4cz5GrcmhVaureZCk27TrroA0luX8npiqp9Dg4o7wp3QZElcTwNgE0QGRFPRYTWLf1S8LYGVgsxDiEgYJWn2tstooOt9FlxL7CKTt8Xo9j2wLDegXR54n4FR+GSYx2ecEf85DSRj3LKRrK7SKHIFZ4FjQMl956rFD+iS3wnulNTWBRRRbvC26TQyMiSP5tcVooKZQ8vtGoT790ytStfIRTZDhj6SMg0vslUz1npkwroaPXo5fqAAB7DyRQ5il4wfRlWBDoYAwbkAV/CDZrUhh5zFdf1WVC7UrbUJfJ+kRH7dFSf7PZws6IQIgaJYDPEtOzRjtbdvmiU+07u0cFuN+VSPQdGcRpP6Bs5IecBfcwoPUKu1ZkVTlZ7WkuZ+Unlp9fRdMGjrsBNjqtIWjRfMoRbaukrR6jgMinwTWTa86ApNoNTkr5IEHWcQANYk0lPAUkx2R4vxQqWgfw8TFr9pdBHaMSk3ipeWI7JhT9KjBaR28GOlhBvKiq+2ZyzFPKwoj4Q+wpiBPAhHxDWSK4A+54chG4/phWqrcu09CFFbU8mdvclDswgjA7OCWFptyazWbWz7Ex9XyiLNarFXOPVWNN1eVFVB1LN848pcX5u1Z/iHYKhkFg6GBtLvxb5KfCJ43ZwOXeXEoZp3+UvOju2wASESXMAD+7L9KivnR740kPGs3BdL9EEZg8y/SqTqy/tiu+xJS3Krwwh8LSzzbbVDJ7vjtmmc4RVwM3Sn/S+iSJo2/djTnzBsU+XRnqZ1eWuCRaKn3tesEExsL3mJ0+hs5TDsds/T/YLDA/oAhK9UQGXWgOAJv2L7pT5FsjZbpF2Nh7y/tzeWnXEHlYOCAbhbZpHequiIkcYj4ijLzy4rkoAJXMX0p9HfzocaXWSqgKg/k6XZOtFZhaC8ZugRNcE4CifEgT+W0fXQr0OW1XwGEoY3kaL86jlyLzhwNvFoYaAo17s8YzFUmCdCY1o93JIzDLz2lhw6fPMuo0NHTXjHAnfvbvmLwtcLEEDYShYOb/bKxfRBNXfGZkpojIw/SsqRBctGhA0dicY28vUxg5q+WyDKvqBz+QxrrymjGqE4RW1BQRcWr9hqVKLc33FVe6N12L98P2CyR98FBhJUAJBsI8vmUyEFJfq5RLOIrC/6n+aeGt3rcyG/0FFrYCWxOeXj3bxhEYUcGGN8QtClSODPdKF4u3gCtEaJ/KVOFiWkbBkqpEidf2LFdKVWzYG5iCChBejFHsbkeLz4MEykP/y+7W68kbLekC87N9Wn8+Tjb3NKkGgOQJqMYtzFFWOR0qZ92iu6Yfg4s9llylvoTy6qD47kEtQ0B8mxOipikxhJjtOFQBqH/rckQxgLyYhdBQfzlaW9qVWOBkcnFspgzdK3Q9+TnvOBHjiptiXKqp1UKQWAkrVTrtFCn6E0WpvU5UOcBNKT3J1S6+rjsRL5O2qe+lOv+dyPqtUUMGVnN2mb1971i9dD4W0VsONGb78Df+s9vZSWeuEl0lfgL7QSt6pZNMvvlAXel7Zd8M/P7pWFDdzBfkKUkaUdR5FcO9izee/Gh6rke8VXdWa3RAfxlXo21JOBRBKEXC7d7nu/IGqij+PH+46CexsuAAjJjO4I6Rfvu2CcvYMHY/6llZGN3RjA8vN7Y34M7afJsJWvug+YJO3s/PhEbAFkTqqw7BFxs6VPf7k7IMPCLnjpq0vGLYx5BvnBjDLsgGXzSveenVNHrHGjOPINGrN1w9UvqOs/zaptyZrh+Rda+HEppn6RuGryrbobSizdneYxfNrlNSQPqmFmigvyyYwgJ7b/akcffDtNOPG+d8qXQ+J2UMOpVF2rkd+jIjFtpsjiS7ThpyeobdiXCB/4P0IkRroL6lUfXyCcRRgoKwxgsj/jibYZTvCKnaaAlynDkL/ixLQtJuVYpzwh1/1XTU/7CmhXHXEkd/P4GG1CvXA+R4VanKiCdRpCMXUnZv/7apqXJvnuMRlBfrCkHGJzX9UWFVBVHVOsTyfoK0GkKaU/hGfujJM4c/sGEMefntuRx4DQR8RweL1pXlYdCLBOZAAH1CNsoK5mRe8RmoRzBJ1QNQMGIIKDvWJxapYjpPlJoxkrS8WYn1f5Ebw5twWuclaxUdurAzOnErsXSKd6d+my4ySQ7ONkaR+Rr83aaLzB0imBCl7KSkjyPIkYnRtKCuGvzIfWriSAzdPcylIrkw27PYAuzkClGoBCmiYVquTsYPZoy2yt+d8HIwR7PcA9uZgI4PHARgmLyC5M6JIbihfC8HXIJNEvnZ6T+vME6Btw0qfS36N+VDCfvEZwmZeZ/E7vZ8TwjthfQwf+x/8hEzXKJgUXOXiOVg1VidU6o9CxcPIQt40Y3s6MkQO+Ypmzy21B2Ik7CEzAAOQdb7wOHIy0S2ryVKnSwV50DCLrC4aqP2i8PgxnSNinkZQCXcg+A+tgP1O3Ypwtn40uWJpdqr5X2KcpJrUnyPxxshTgR0Opa0v7Jh1yQRpFQz6i7ve5uweuQMT8fuMWVPR8N/tZAt47EAQJvtx8Yy0AEHWHZRFs0LTQoxAo+05NXa/A54XHcmdthjcOmShVasGHOF6Qok3HJjtT6FhFX5wjRZ/JzudT4F6iZqxp/KMu/DBMpzm2UqOMDNgGS6++plNY+ap1WtIIUcWazFgUeQs1oDXM81i/RT7JBL/xMZTW41nYAHEWfoH0IjQjnZMtjh1MEI6hKPFKfRIOnpHRQfrWxwMHM48S+rcwtr4Bb3FVnHtcLv2w7Jd1DbIaA5WFmwywa2WZqU2M0OQxHtpbzY9x6bi4V6kLuApAPmk3MfuA08SgX5Z1Ve4Hi5mOLafyxWUyIKqw+T7reNfTwjyvA6ut931/9n950w24NkG0f4BuFOwJoyVXmr55mEd7Z6Qf08neaxUnsIhMtyhboPCOLpc/3NFyDFpg8EFrjZNIfLJpbckuaw50ZCuJTfvbUoG2AwuBLDesIdULQp8iFq+NDpiJRvAJ1UXhQfneOx4kqJxXid5ogyRueOjiGIF5hkQA2q+ITo1XKqy77u/yYA3chYAunEouk+tuQb27EqGPC3+aVopJ2FiatZVAkNXW3LyeomPLoTlym5bqtwYCbILKVK7oXIloy9znWqK3oHO/u+qtXny7jY9Wj0sx7tgIIEe+XyQ62P0hYnSoMMANCQMTEL4lr76EwBezHff1onoUAjrrtrZSXsUR1zjPzkV3F40Q3ZKzr81cSPQDg5saXToMvwlD5kb68daGMeNXK6kI6CSDq7yAcd5UZWw9cupdOcP/rg6vLjwDnjtsPU0W9vO+wOI1LjYOb9hxln7WqHbnQTwF/Em55ea7OeKl4d20H53fWJU2LGm2ziocWIf+qUWt2t6XSFIKcFo1NJx12FGxl94IXeIBcNx4vmvK7v09Xz8jbkEODbrMgw6P6uNSOYyS9i3tEHXxhb2BCnIcM2TwCW4XFBLEOQgakZlIFuKgosQuOFRtPmq4vMFhSJt61xE2KIBXWWOBt2OVKGikwyA5dVVLba/ItKBnp/h93h1mPC0/mYIl9ecuFv/hBZwMVtUj7H28oP9ieEQpv02lfKfguYmZqAFb5EJfiPORsl4fRc1zRlvg7ptm0TJSOoYNIVYBWJs61wrZ8SsxQd1ieRqYDIN95Ch7mnOuzhNZS9FRe1J5w+bSnpKL1zkdYN2S4EpJTtBAANZzLrB76rVEzyky6j5jJbeJsRVlEaG2LT9MnpQDDxf1s8IY0N+4ownF8OKhuIHZHmak3m/fD4tQ1iGCC1CnKoK2qurYWXMHLbQLu+opFG3KxLeKJ9m/nLwzuDFEv3MJu2Jbe7TePo4pcC0XgN1U8ClOjWuDix16PTYtG7358XSO5oe0aOCcQXUpBXUOpYGNT/ue/T0OK/iOEJTHVu9ks65p+T2sKgQI/6bEZwLQYRWos0f0mkt/83MaxmRDx01qkueL7BNwQu7UA6VKOYNNaZc+cDTGvBudusmDqa/A5xZdn1VE/SHc+F8HpsOV5I5MvK8QZGyhK+zBGMdkP+MgHzJ+dk8STDRti7PiyC5CRtkQtcomypIYJjqG5VnRflPqSlw9YO6m1SdoWqltREjg1Fspsu42in/KXaaZf8FakvTtXAvNXO0cOOP6nEVdbn+KzSFm+59x74vkif/N13nx0lplPGSRk/hHSApYkNzKjartynB33BSePsN8dDBE15+51RGOH5qOluvGge2VK/EEn295sqyRtU4k+PAnlmKswm7XbONPxznwBHJ097ykU1dmG+u25bb012VHHVA/bbQ6Dsr1GqottxOoBZD6lu4XMX0nna4GiDf7B04bOzTqjtTqYq2HfqVgezuhu664TKV0TYgtftFvWe4Llu5chudmFlu8KXIpm9Hrkl1ct2XLX+is3wgZ+jgbVaxS75nmiYrBSaFqH5WpEtWVuecPHaqCQTCyDzK0AtyhCzNSdtoq0O5fujPUHckBajiTVckqTRmhApchXGmVyRJPZ5uVoeF5iDJWirwl6B2J5o6XLQPngiZaK1Z1K4zv9C/ZTsCa8EWg072C2g7jyRZQOL0i8+6sAkZOqENs/BD3KvPR/BOXqWsGejvZxkVaDqqbSp/KGLineoCAzX35+6Z4yuWIUpywFijwz129goKZV3+4xMt+HBhT97EjsFRXRqWnnsB5r+VzIbpEGn+Kxja6bg1szUyhGPGW5QLwjXJlRX/ZFHodbW2fJZcAiKZiHKQb+8qpaHmNn6o4Ii6RB2Gx7vW+r6I9tLtgh3NP9SOFHuMdoCRRtG6CGmujSun5LG/JBThYuU03TLpZJf8SEngPRzJle27r2ADrCfHJehql1Bx1tKbH+AKWRoM0g++otNhyBq2ZiwfEflKn9o7vjrmMDe/hnyOo84UnFk8OJHJgBS5NXUL6sFM84fdbyxO58ThnvYjQ2daQT5nodsSygsyk+H/Q4aonP0FuL74tpjVCWTs4MMPQFWo2WNtfevWJCGyB1Y5/l4h0Du4Ks0zHFNVSwzluc6uAg9ERP45cEuxOG7ZlK9fKf7PhCcQhoH2pateeHoaKDxizSszM0OGShHM2UnouCSh6AmKZ4xNZETaCMoCy/KL935xF7KOFop/8CdHbTvxPQYk4GTggMVSqWiapf60bCa7L03FtRCbPBveWaB+JNAuSWNa64aL+4RIYIV5wwgmkSQrmIKAnUPz+SFpnfgy1DrxxJG9dIU7RvC45oUBzf+HlhoTgs3GpIessApMtbjzpaR8dGCLAW9XA2GIfW3HSTY0wRBHLhKxTt+3GRyYIYTEgwOl1QUZ6c0ym6V5vQ+aejGp27+0BD5BvnU/xIfhc0bDVBU7pxBtyIZFFikveBrgUuzkCgvY56dacWBewSwLQOdTRX1RvFs9Wb1mNety6NdP+du3/dB0beaT9IY5HN3BgOX6zzDGiup51a3RZCL50RwYe9qdvTltsmjAMYPtcajztGMSIX7T8prM7X/iZYtCDM+ShV7MhoPrVNDNXYBTkTvIM5CrrIygPArdDgpmp5W8IaAyfiUKYwxCBVwU/ULpfu87TxUHB2vRADvsFgemuxstnaNhTHhJE/NKR5wN2A7sQiaG2R4mTtp7V7NXBRpCwked+KBCGxFqSimYeltWnWbecnIbIyGiuMu7NyhZSBYj/81pWM+LcwLBvHhyrLt55MwncFdfN7XFoTOx+SULmJkn+lnvlJg+aCPQ2tpR1nV8Aed6bYVb3rhCmZW3E2wsSeWFy8Ryd3sRzUAUKgMveBhEPfcSDLCiRhc36ORwB30sPtk0orBP8gAAO9OQJbCvZftusC+0cEF5djkCIEfa7ZybCEYG9hy3zuSKnrQ3y2TF8NJ4rIfJtNwsuxxDeftOOEO7gmu8WPx/9IWRIlUwwfXsXupgng8ak3i2xxxuhk3rmw1nyQ5yh60sXdPKQFEvkPPLliDfvRG3nWs2ra7qO3nB5TN8PvlgEjjp92LhH2K3NLldDVegS+2X2CEO9ahw/CT7xk9HJajq0d5UNSKMJEV+gNGKCC7y/TFDEDW4oH5lH+ms/BmnOsR22aykiITvFmKEOzfQ+gybcTa8vfXI3K2JXNEmH/0D3VEysKVy678qIF5G94zYj3owbssrJ8AlfhrYFOajfGJD+Po00RhOXKKxp6taZH9mfx8c0AmgYBjGugUVnozsXCyQD034b2pClWMnRaogqgiAiTKqiXP6+PY2gARx9SdZX8LRZC6ToBaXuy3jLHobRbkK6nlG6Odvdf6F3IBhv8rP5quDhJw64ushmeC/BlCm6yLgEnEWne680Wx1o1HuyK+GW6dPaUAcOBAQF4/cryMPS10Qpze8NgvEPG2G2TjoIUoLWjmlH9UPImATCUF+KSb6IoCY/dW714bqWhrNZQPUOJqrfLFWZQ+kon0O4shXh7lIw9WHe4qJo7DW9jOzrcwsPuav/elyDLGvrTN5vxA8Yjs5/1Pvotw/J/lQlEc1zW5lLXk52JCyqNoCsdyX022eiRgmGL6d0LQV9JNNfbyiWczZl9tgzv/Z+h4gkPuViu55giVS9m1Z/IfpIS8qtJQuczccQhKiYVhyhYZHZ3Tz2kW2KQzLc9sOcXPZoT0FNNqrXqKx6RjrV2NgZMNhmMzDht6tjDULvL6enZXx2cen+sxvB884As+fTtq6YpgXdvlWvAiSdqKfxhUgtZWsrOTTTkLHu3wbdi4C7wpoNyzvy8C2wZFVztnNy0dsvYSVq/2WKBSrjNBAy5bLwlqqDwFWS2+GfpxMFrS2grWp5NI8tyuzYw5nfo5ipeMvJNl4eHj1AYdaJCT9WFtnGUSR4E+NlUvbNwsStud6sEQu1fyjEFGYDoUq7/jACEW7jF5/IEWcSfyvdSu0XczD5Sxblph4Y5JRtFmbDl6gZyWQz4lYvqrFY2mZBkPC0A59Mc5u+be8GeKSsS61gZfEDxnXRX2yTSsJ55mGpyw6oWIKVjB0M2SYqLpxOuGQ4Qxnnc2fUjIuCdi3kD6jzjwD1/Uc3dn0y+QebQr7roTSvuisVnIb9aH7m/hTvZuPbiJx3lSG9543ks74Rok5QBix5bMT23vqIYfiyQSlx+uKqfzvEi1elTJz0b9WKaGFWRRcPFGG6lKcXF+5VxSiBRGa2uFFHCrIbnivrAl41lu+om0YfccK+/2nN0CWh/ENJaXXmljfC4n/lZBAuUK25nIuQC+xILHnYXK7P2G1vDoTKn50ssK9g16l/OmdaJf0xJdS4SRWQwhktnwDFyg3PMJTxbpcRy4c1wUZIz6080nZLvfA2tL0df6Vf9vGv5FSVYcwhIrFhlhzvp+pFUYQxpsuz4V2tH1nVOHaEw+J33SwrygCDVoXXcMHC/cwl3TnloDHGlaZLcaxjKD1T0iKKj1o1TItKPs+UstLOtYLGwgy9/1p5RvAjBWHiwENbDnScQe8XOnVCdDscV/WpGhnf9TbvFs0bDOfwAbVj7CTrIUANsW5mo4RyGTRtnBwM1w0yfXu8b1Oa5suixOgFU+K1XneBqtjDvwwEy98da3qUx6RTVVrlYXosXVRkAMqknBGYaP0VAc4709ONjjOE9Kqt3hWgktrurAo6NoSrvSkLrSbVXsMvak/GHx4FNC9Q6+xJTcJqlXRjGMdo/Z91Yr4ovpUZxZ+LdlPQUSw5ywGuciI2XH9oFVybpOF/tKGDaH0/1vthoRbErxKi9Lc+zP6gTXV94+yWR6IpAT4p3Cm9yhcya3WuKSeJDxwQN16MvLhcsrUKdUUZPpSoGKCtlpLVGcfcqZo6uBv1+zbQf0mAm8QeAtiyeqtU2YPFs1+vdWjX4N25i2LdC6Lly91PpIAKnoBDhfg5yNHWxGlMewxSiABTdzD3h3P051hG4VFH/FI7ftmfz/1H4A16S//LXK2oVaomXGX00Z/VcJNMRS7Jsad1RnaBu1P6NTad6XkdyRcrQVl07e/V/5chWPjargU2cuXRqJt1ztv+X0dPMrTrMw35B8y2RyjcMHYdDRnuiyhlbrZMb9IpeEJDSXqZ6zyQPz/fnCNWTrGWicpE4t/YOzAKt7EnS2iTWF5owJkz1Qgsr83il44chAEnSqVOf+0OPJ814PPmhPmhZ1vQaS7O3aWN/05Z9f0sP1zlPwbOcy8/iAABrm5yXnOROB3FBu1hQkhYzQ39FBsYoV8pPcs2uasu69b/eWGOoskSm6JvsaEhog6g0dSIAMNhGlrgiJWdrrGKPb9nQYR1/0UctQIOyRSaMPQZCMSBEnv6gsmUltMjGu6LcYToTcjR+S8NaDxmInRR+9YNfsG31HtsIeEQtBv1zIAszvblPHFSbSqwk0CIACipqpUICu1yV1GkCXbKSjoJF1O5j4TzvGqWKzCg9xODaZgGzkDM8EL1l2yjJPEEGIU37ug83NYrcVqMyUhDFqVaFkOCOE6g02kWZbNjuG4xhq4IGJ/4rz7VhyauTFaAZgGcZCUTM/2r/1Z0qkWYUmvj/4nONMN1Vo0sMkfUcYnjXB6h2qrA7cQ9D1Ob+cVY/bfifyYqo/DoFBnNfZCSyINaEUg4q1nqj1Zy797IvYIATyfEDePXlwYswR0L1Oq1xkAjC6VUGanoNZsD392X/rOShP/Aj7fAcWyLDSBFZcMLjd5GYqRxZQIId5+y2P1+4gB8EALcy7G1mPHnlEN+If8kjvlGhoep6hc6L/0xhh0I4ah24w6MbmpLrDDIl8JSS0Kt7HTX/2tbZhJNEjUZzzQWE/5JTkDxbytzaYHOA0Fsn0OC+f9a+/vFzWPUDKqsYUiXrVxsfNVxkj/FfdqS1vlBJSFce+PSL60/i9G/mGth/x+ITD37bJuGBEKazUu+UTfsnmwB+UWYaAGn5F8Za5pj/FtOznQst4NHcp08Su6XQrbR/uiUS45GXHRCs5occTKJLM9WuWB1lghzXNq4Bo+E5GT8hVkVTwyOM7LJssT7410Lu27w0NjRbaWULlJX2vHZni7TKAHFB8M9GMpn85YUv5zGC+kT2MBxWnOJ70nXWkMPwCFDuUyShXOO+U4U4KjYHuHvGIgSTt9FyVBs2DS39PBM8MoQuHsVS6nqyydlYlclaTLye6fra7Q/4GYA/ZCsNbOBEBgxIibjr22cN6eBtu+DPlRDCL5srR9siatJclzvy8XUB+nAXacpKhQkwNUt8jppoUcL/BCPuhPcgmGtZaQHQDF1b0N0+F5B5yNe0Zr4mUMFZ+7oZUCgdUlNji4oKb7zfeytVuUGBPsknWRNDIPbSAe1fmphPk13WMnInc1ku4oQh7TyaiNDobd2MuG3ayPZy+rgCk4ZuCnRB8shQhdJWuElwldFT96Q8qdioDRqX2YK7CnOcp7IQ8HaXIR1XTl3YRv76YPkqMnE9XphNTwu2gJKugDOtTGeqPUrp6Yk40d77FTbr1p13hMrtqb5+0XVeSF4tHO55bYRy6rCB55T5ZKT/pUt16hCMV3H97x1jlQNeSWngB2RmlgAvu575LSsbf/a1fyLQHu5Vgp/29pkbPevkDvJ5Lnd5EoMur8oU8CWLSCn8ZdmPfihtwNWREW0zclyQV5pO/Yad8RYtrmC55920dNfZoxJBxw1hvla8pxQqdNDucPZsx9UIQP+6tzfojY4yTMaqPT7hTr+Hp0ZHFK0Jl9PlYFACOsLXFVNhMVC2W5GYntOMPKAWAYVVU/p9FKTGR5s4FizuuaDAjuiEQS2bqqiFtRShh93I53ZnQ/cd+wzWyM/EFUa2BH31kp2P5RHmbCXBFi745C8fKxGBPw34vlyq8nMa+k1eKWU74hR7rm8U3aWzpA0ZAC06VR3YebNOitB3AV3xWOuZkyj+XzIYEa6Mjn6CZ9u0FsQ3DOz3Vz4KbThnyqXbXaWEg+dpXZYJc/6kv11PgOa58jj0RtetHXVRTRS2lSOJR1tr/x0o5BafMca5hVusfOAj4sahAdqjZZX2wr4MiG5wxyqrd1I5gnls64W+JPO0fLPQ8Bi0u17IJc5Pfop6Tiv1LzhWHw9d1Emmak23mCApXhekMdJnkBgr7tokzvbe2TpyM7dPiaOXGwpjC+J3UqNCY1OKRevUTAWy/9Xacx5JFndpQsI+/FNwZEknMMlModJ4NlJjHmS8mXltxelfgHqlD+Rp7oN8ggEoJEp4kpBHoBS2aI1K/9Z/uRKkah+KG6D6z4CwGyHZB/oOouerBzSG9MhN2Ma/5b5ABHMPbOdlAxcdmJeO/LGNRWqE9sNZXUcyIOBZ3jhGduey11snb26l1LEz52qGkg1Qwtx2kbyHjEiGfubAiHmCrcs7P7FDk9/ZO8u9N5diJI3CcDMcJ2OuFgLhUvT9fXtj97wqGgVviMMgJdyvY1X3JfUiMj0ND0teP+3WjI8M8orPA3nOxQ9ogDzNYLwC2zv0JJMruatuEKLnilFFgS3Z2NBSgeTd8YkUdrvozlVCA494Y5tmwlwqFDOvyX6aaP9kefpN1iiWoor2iZNOcg+jhZqBFCWJFs/izs0JSTh07Lb79vTt6akvmaY7s1yub2NItNSEnKXkxeoSmWju5dL11+elhPgk8NmAyKbhxvPkYLH0I9b9V4wdryf82EQBkJubmPiOOlzn05QOUswS7fkrKxvy7J1uV0urn7KZYQFOMdQzOFQuuZRATNr7ycVr83BbZw3x5Mbi1+n5u+9aDxM+K1qJXOIARl075M98c5HKHseSU/xwpSpNeW8w47zsgmvwx2fT+1HcYrad0VPcKA1ZZ+fILPmKzrF3GmoKJpslQ8OX0pedyUOGZiMMD+GzpSNDa6WPCCDP5JsVq7b9+qQwDoEzUDLvOXfM6EfuDmlbg9O4D6V+I/qBwkz5CY9FWOfoJeyehzYdTXQNIsYmFwGVG+okYYCUs6Q0H18QHcqUjI0YhyzORpGWtgDmyy3CGcR9B4NuTFUS+5AtT6+p8FGvE6LGaDNqaUStg4e5RhuhakniXsWE3xStaq7okLmUN66NzaX4SpChhfNLQ4wTLSRyPcYCifhUNmgpUbS1hjoBCAqW4HYIx8EI07H3DTnnCWOBox1q9mhD5SNBEE0+5BIjNZoi0CTFz1teZtr5Su/kE7Qw34LkXUEoQTzrFfOUa65a53DrdI9PW2Kza9dyWkOP6wHlF+C6tHcVR0/mJyUXGHJtlIkQURMfgk+lLnTBbULTLm86Gd2jaoFvOFBNNQhMPBdFwXGfiShKqpkLbW9bJJHBkSo9NfUC82botGUg0FedrQjjbE6CgmhkvMZp2qL8anF4Q6qwC/uqaWWbPZOGbNODknjDlfaiQ3JLlY9017LJHmf2/eqWmX3/H6sM/+CBeZaVhGvQ4G6c79vRno/f6EDfuY6OUVMNZ6WNz/suXEF8Xe7br/bhsM/qdEru43p/ie0b5qTBcbhJtDbonaA+SrTgZgw5RLVctHl+6yWA3s6sJFwVQjXuOh2mEwrC17xoyYQICkIR6UTtn33EFipIBPMgt6+ICq4OxdcmUWSbtdqfgxgKSNMUHWgRdSS4fqWGteQsgot52/JsowOtg9RZlf4vV0w5JXHyrsoCYcq4xV/XsaRE3fSu2y4wONMyeQV0ffv5IHxxhR7ARId8Fs48IzRQGwueG2vpryBAot8GmEHd7azCw0emB6AAqXcw9Hyn9RcUZPjy9wCmxG+yAcjhzFi8clq4d7DWWS87RLQx74ICP7/29qDUX5odob5nBV01J6mAFK6/m3agqrGC0fYPiuos3ndx8Tfgvgq3sbxwQJe/ZJZYn5O9or+WErKJLA0+aYq5JMirJC8rD52kCIXYDu0AXsiKjTeLL+oTAqIzO4zpmIO0q62E0MEp4at3RUMvWUusyfvIUBjF63o6al/qHswCHQvisYtNJ9iWQL7phc2fjU52OaazcwHjifro3amqHbS3NPYbQBX/y7+Fzi/e5OZIp24D9HmDSjtIizD8hPEGaLhGwwfr0PEEd2ioTQZhGWN2LRdbAuJSDhhnAs5h3KGUGlXj16yeKtufGdVR3JBV+HTIvtpmGcJ1wXt1agGDahlOa2z13Z1R6rbi8hH1JC9rbT1JY/+vJEmC7EGVBheaI4N9myV+Ovaf6k5tmc8bzPSUU8NEsL56qizqT50GZxBxbunjq1nxqUVdCBkKdYBdt17pGCKXCtFBT04iGKII+LExIPvTrk/kyk0iZ7NoRz7xUHkJa5407PWkUWCU5g4zBsA4PeW17tP/I4I/ZDaIBGrItYeAGzc9gm97rkwUoLwERUdG1hOOjDEuv3pxaZEpWonokH8OibrIXzx4UJLdReJAZ+iSEOHfSc/rUrjrwuTA79cNjWqw/ZPhEIJ0qcj37LpH21fCVlxUWf4snRDUavLDg4gmiYNoZYBqjZjM5L6gchJhtpt2ny6WvXGXX7QhcP3bIyrxCuNHEroKoeg/IzmcxuB0MzZr/1zZ1Jz1RjleKHiHnTKM4xKFVlE+c+TGZBWx60flxR0gPIfqxpfUF2ON+WlJv0HbXqYR8ifwlFoqaVVAlR3XIZLkkHYNvYysvq5tzGZqXxPE37pSvynR6hZ3V4rx5FqiOaeCjS8g7Yoq+B/pxlHxHSm42bkm51ago4aaVP4f6+h03dE+5e+c2nyhFDxtGgRajEirDcq4C4213uwtxuM6nuOsOZdQS15vniJ7lCr0ARQIrNSfNEGAquYsOLBxyk6ATVgxyh+1xmMNZXmntRMAYv+QuxGh3x3tg+Q6FwMUwdX2b1JPAZYid2yZKJPU1VXu/8Ar9ysutDY6592ijAKGSQYT9nePEmBTEBf9+yXXvK24pbwaCesAOw87skvEagHVoYP1kGtProayE98muy7ogWvL+yMGT8P1lpFgPdOeDzyJUzQOGMehPhP4j8ShLZ/qE4YY0YH1TVnOHlVjZ1NnzkEYN0jNIcWQkZ2fremywM2TSgxegC9iXWORX1QBmSL38iyy2LRP8P/s4Sbk+NaOv0hHl75ki9X0PcYiEoEui7RYkcDOx04K1l1Om+3qPSpxylEI+VYtYaX1PH4ERPYnEvokcM7C2LCdnUdqJiFMO4wZDeqzkIfQw4f9EFYHxo8oNbjZROAS6vYjemxY0ZqQtu7219fambDH/ruYUWyZKmh5y5+Svw1fI7McURpzKaTbqUnGZY0F4+mOtw5419bsqDVJk7heAEZKDTpwlujUYwbeoUhmbAZud7xP5B2JYAg/RXAXujxRS1phI22utOTU9tiADjyM/C/Z3Tb3r5UKo1xNRDovIYmmicZxHiv6Z+Lmo6jb8uadjSbNQT40GQ2E9dkxRvVvrnMguSWMjrdxbDZu0bYaoiTFOewmXuSrJXZBHS592r3iqdoeti5YgrKlVZGGFjaZnvaBLF5aVr9FdpKTCUSSpLONaJTDvjC8xfSSg1tYluheLiJJpuBsNq4oLMtsFVrqhqo/h4VJRJNgTPIk6JYkaXClXmG6D9LkNVSZSoAMrRxGjPezCzWxRZHG76gyETsbGarxrqPvWH5XVX3WbMJ+FM/ZFyXlyrM/e8445HBXFlJf78yanY/bO+gZTsJcqwnBoX1HpCzcuvG8Wr317DcjlS53HcXwpjYX7tbNXCIthA4xFM1iaL3RyNcA+OF0bkxULcT4NzTv7UkqEv2Xgf1WqUeSAkccCk4KAxWY2BWIX2TnzcbRRuYZ2ymxhJO/FUjXN1cN6S08SbC2G09snVQzFRce7x9cyIP/oe0hRnRIgKKHdE3LOCdMUw1p8KPHP1FCocae5vXD0JHifZ+cpE53o624v6pd3aiVJPSj9o6VPWCVtdA6X3POTS56cQsbuL1GGwBJGPEju38+mmssTXwlxM0PmWnxdzAs7B8AK/eu6YNCngF8e+tHBKwidv6/jFuqARibC+h+yUxl3bSnCNJT6RXCxck7Pb6VW07pRBeOVyATKyR0a30pk9KLV0gNxWFThsc8b73lNVvBMBB4jwbuysRwgUGWHaU6ge5OEtpOL1LqGHK3C+hoGvPBmxPRvgkFbGp4jJKCqpMrYiD6RSMYxe+0OZBkJgteJYUoqNa5NPupq1wAxt0tR/mLCeKU+gA1lEkq+CbU7PFuRf0xxjECqDR9CJC0nLKw23PzRmVvnMuLpIbOsmHrkMmjk+yt/Hnb981EtEKF16rZd/KcUEwdB0dd0AiySRoyLzBZpbfNNCTXQuqqpd0BySGG2CENmjPsDecuIoOHMQYkxUXt2OUX+O41PKzYMJyyj89aT28fBaRD+sbScP3bMC6UI8ZvNpPMVtc1uG456Mo3zHIAiyqjw13GwAh/pL/7KI9DnYU2pcKSSvtbOm7ix5zkauNUz4En9GJ6qmr8KDAZ4ol13waNiJGcFWOwo0oPvdcBU/VlN46cFvEVPYf4gLSko4GJNsNBRHY4DDLMkKfUHKS2OyGfq2Jgcfo/LouymroNOwd6CCgwt29QcHPuxkkpzTdSe/MDGS4sWla7kvMunZYD+fMkyvrpxI2+4+ueBKHsun7Y3O6k+FCwX+J/gmil0HnZ30xZbGm2t3/fodNYDsSVIdvTEooQ3cQU256QZdDIIUQHx6/5mPhk9NzCZhTstfYPrPC1+c09D9h/Ec72fMqJYbD2S4lv1QLqpbHWjPmdyUaauixgGXJInIn8vSW729TuX2lPd69bhFNEAOoP5ftS7EkWKVS8QlMTWqm3BveSqZR1ekJBXfbVZ2xC9VH/FMkQstu3e+kzvUEJqKrjd6lb+Ek7jFIMLbi5tPQ9vF8OICbWkMlZ6SlFyhgkKdZF6smpXCT99CaH/obYZZRQ6LqNQqzeSNsBvmLfpRk6nYREEG1cclx2e/ZY+c1bEuxYkUv2YZmj4XsgWcM5ApPkEx4v9ZsV0pzUsZb9PC5IaEhrLrBR7zzfuiZ2ErQlc+sxY4OA/mp7K/3Z7niO+A8YqDC82SrmWwg3sAPaCMwSHnXW3STnx0lHiEilnu/TJkaumEDNcgBL18KAPRsKFadpPgL7Jlr0YAe1Sax7C+D/T1xnZQ5Yc3PJSR/cniEO5OeTEfwUDiGvd2UPEL1gYKpCUIw7dnOBRi9jGLUDTdVdx62DwlGDAOsqYTtFVN0+zh5j58HoI9nXEoo66uYcZtkVnoJjpweKvw8GG3LU62IAbZkVVrVuzaphIP+jiqqYpQmTn6o2bkDScZ9hh0u+HQt41EiC4HRRIkK97HixyLqwdldni6FjiPqexLjswMepure6HhyWFeEQpCQc6rcMrsSBtEbiTAzY1zU/BX/zWq7kiL2rWaunCxKPVR+AmIAJNtgkgKjWhh/inNFxH+1ZfUB4ZZKUdk28CGbTdIMmDR+093Jsx6dgCAnbzEHFC8DbolO5mDbolpTUUszPmOoN3/c0aRpJaLsCzBJ4XQKPNog3/2J0eTLWetRv8nBYbMWlwqoWu4fI+DhOBbb3LwXduRb3Zp+eG2xW5u5XvWK0uvGvMX8UP1yUqNHM8QF+t8M9KXujkY9SaFilM2NXMYRw2lb8O/U2F1iZ+vadEXSXIXV6lUQ1VI4pog8EVaiy5duzZh6OPqdQDtE1XL+tXDl0XdQ0cgJj0lGN0upYkzd9XYGpq9hQU1QT59X4jb333g/xz/Iykx3BghOYxl2BXgbZoHERmLqzlQ01xyu9yIOHwZgyaxO2WJrKkLJIxAJWS5u82inoqL2jg5ElGALxAd20k5dfPu0TUjPYPyTils2dv9F+3u0rl76gfFN6wulC82WYsffIqJo4LaxkHIS5xlGzsmoQtkdPzfWoS8C2RlNC4OL4u9EZPOrG0n1B0/1gOyRFABGgtdb1lklekEq+liFHsm0W2wUwSWjuKzG3/iKko50+J2wjrkh0mNi77LfuTb2jMBa4nCKKKQhR+hrCPWRvg7wxIOglbdFtjMrSw9Ai6+XOA7mnZX7TGNwDLHqmGfi05a7Nl+NhVEBQF4JKIuj+eqJ31N2/FXBjEgmdhBgn5V/sw0nafxJuoRcSwnbO18S1TwRFQ6jPtsg1W86XjQQhVLrjMSzxDcGYXdNddfsVAgd/U4ZSPobPv5FrZTP9hHkt69a3hh4sEJUw/X+AbUFTZ7vQdkZi4aKHubN+mivNndPQfZrbmc6eQ95cn1QI1iM/0tp4rCRenEuk1g0rVxuhnQZbUBrAKlalABnsoZxI3msxPb6UpAZwMu5LWZ3qAw7ZApOj7eXaEgMg8UvuHzZxkT18ReU8iM8sFn5LVUTo27KJVzaX334LuOjtz2O4dATcSZu2h0cs+KcAymBoMKnguDJomDSb4+O8WN0kbIe1lYbHRMzULw5Mesu1LSodl+vzKHpIIg6eHR1HiJVleR3fb7HKH+K4Xo71P4J+HYsXmOmiA7M20NqtN8wpTck6QYd2ygvw2AQrkM/ryY2i/vmDbVROAgFsi3P8MCZyoVJTlx2JGHKFXBvOPMDpm6ANo+rHsIhdNXsyx2ETVpKC9UpfutNfq81KpHYaQoGMxM05liF1Fmi/2ovzvtB8+bqUQL27x26mSe/wknEuDdhLtKaDluUw8zo2/uZjpgG38mtD1TeHQbQoxVpKH88gDACcA4Sn+oXT5e4RBTMZOAe4f7G3/T+1mDi/scMmfKsILc8ooYeiqgHNvfydYyr5FfWLpw/o3Qkhi/HY+tvP81tmHTBM2iRR9Qtad/IviIknLgnwo38Yt5+24YtDWtxkjGY6bFTw2k8ceFJ342gADvr8G3OxQNL6LM9+wJ3Ot7ghloiY9qol80Igrtg5uk1sa5QpkjYs7bGSZU4ljTe8s5g+M/Tg2Q/O/plJX2iMthsWCcRURX5Oj7F5hjkuxo7OHsJ9tXBMteE419XI5hObZtpLG8t5fYUYZrN0PjWLMVtaUjFnqQ9w8kvyqWkRTXLH4PnR64pvX9zMZfXi8iFOlh4Sv+z3ASpZl7Xi0dlTeq0TZ8YDVjPO007VohmV0K/8m6kNpwAXpRMDa4dlhF8lmGkCNuW652M2uoO4K1ROx3gzyf7oK0pPYnNBpn/F+0xsAS+HjZ8i0ZYN4Z7i8JOoRe7uczXjKU4ow21TyLlP1DENy3o1rV6iyX+1CegEpDaL3FWjVTyqdy8xRFn7wCwBnfCqs3rpp9opBMvbXhmJ2TwGbFWg7lGUMBBM5nHFwc3Mvi++rwenktUHVQidYIlu6QlnPlXObgpTLs9CFTNcmdYqNrf+nttGnktaIjtMQCr7XUpJZil4QgsE2SyIqRV9NjkcW92qCZEpX6tpDXAXfpbfE3NM1PEwCiVEBFS7rnpcw390isc7A4YA4mCUMs+Q/G8tnjNFTXqPXnZMgD1bWuzi2/vPrkbgHkfE5Qsc/TJup8F69FmDwv0bzVnkzRCYvPFczJwnVeK/30ES4au8U7gWwiW3xjpGbR6yTWDoltAo1aIzIqW1+Yj2BUp5R3jop5x1z5gW6sOQLVLnLN+U5DqdpvV8qmfDjT5PicL8HMubL4g719xdTrP/OQFtdQEhhlyniKTeh3PjKY3R48Elsg7b7sqMtlRjFyM3So3cQAQOhbn2/SFDm63hb543H3QooTPkfpDIxKsIuHx5LIX1NLHkUvPbGZoFh/wvvMC9MZplUMrRIYzaehM3lxFwC8ekXz6QquvfVw0qR13HGfDhModVLo6AxS6AppbfBqeRC4MfXKvzehnGbMMa30PwJbK7HKipcZQjr9Yn6zNMLbmfnWXTo8gTeoUPa04zz6TnjV3V6z5/7CVY5T686z4nDOfRoi3hzZb8g8mjbL8vZGp51mq084B73oKy6rSs2dshp0e697e3z/O2Jfng8lFgxyQK4YoMX7hAeoJ/4Nc2fKynyN7rZsHwwcAuS2timcea9fFOYxMQpHolgQfMCzpqjOEDYIQGYJKGqh4PQgh1CLuhCvjrs8LtoHXv5YQPcLJlsTvihrqIb1RZntTP7pZgtmvR0MfoimBc9+uDi5CBw58KSJ2+1G7m4ztQos80HjXP5pVKP2LwAiNXLB4wBL4zDYVQWlhjYIQ9d3hsGHpl4C1mpvkskUUOKo7vCdpWc5rbBls9z1r2ShxLKNqOu7Vc2A6tJvmHi3JklwnjpkgAXgDmJElyhuh4bLdG1JbjpxqKh6g7N2SiRnDi++8r5o7fDYo2PuMsEGmbnp7op9N0b21lP4vfPC3hqbhEM18l1tfvp2d/SOhw6gDp7CVPHZR1GulM/MzCBLFP8GQRmhaDomLZ0UWM9ZDmZPDNEPRdYuFtZR47STsRdccFfHgwjmzJhCSA6Gm98eT5yv6cYSw4L5e1nDYyl+KKjgANtgs8rbve48zbTjmDj+3xtF0QarQpFPsXOe0/dlarKdeNUxm2zeFCZekUb/pwwCaFfM9+lyDUsbzT5fX1pzsUi6PrTg/MkLnxaz2XASvkiIwW5CnXrsqJxicvXBUxnmcQH9hZxUMO+Gxb/ekyBLQPD7+B7RSxnjZxPCoPQBkGqsYh6meG61MG9U3p0Z4irKcTNqn1qVopPz3fbkVPtVwAmAAdPG/89YXpZAeLWlQmBi0kie5hGhCb64VsE7GpWx19pg6z/HhVPc8lsBaZGqxW8NagXtufhH/KtRDK/fOwgZ1akMb24YcJl/Axd+kNMutxToHeKIohN0LvAoimbkkiXJC0IepK95IZlEP+fJ+yxTrc9zHfevlo3uMy6EXO3VtetPF1vXbJz5zV6gaXAzGGM2UFeDI93lvALUNDgCp/OKtYMAYi3Ttm/DY+sMsbmZ0me1KgsIE4TGBPCpOoelDnLummjdGDkcPRWMYzhZqXnLOMz/Y3AEyOai85gNJpksFX4B7aLLhQA9dlAoNxuB3rbV8SED4UuF7TUTaMOrgND8yha4GZnQIbm9s2aOmQJBSqxYDfOkvszoafz1e42jGZLBqOcoinFrH//XAO/m1pdclmDeMZ5dGcvoawvXg02fT8q+Jw0epqM2o8cEvVwBQnuYdlpNpfRkt/jdasFbigMBePV57C6k5cmPw1LoZmMYiTc3fwpgdZNUOp/QYNS9hapA+2Nc/0BZ0kqOEGFm+OraOpnE5hwSwjk+CcEK8D7FtIeKtEmRdFH3GTAjGUNb/Tvvz0B3NTl3mOVvY/1M2wi+JU58wWvDwhq8ScY2GAMow0P50IX3jjBckG1eYQF2bBMfpBt35o7eXl5OSCNuVbWZXQ+r61F8/079S32CnVXImd7XMfYmSNRTQ8YatfLzNuNq2QY52WM1XIuGZgO9CmRfRJDWfi92D2PKvL1/0fPkBiyqPrPAiLizAbn7RxA/5xLFdocoDcrJBYGVTVnwjdYdB1m+IwDyngAcEAHAr8dHd0hM2xfsyMJ+H1A7eEENg+jfiHV6Q8O1zvyBioQw64bQsGfmJX/T7Cp6yIHJWBQK5Og8c15hq/VVckk+GTu4HwZFetNF0wLsmaLDjeTBGm8pm8x/oSRFRbchZVXmo0+HySNWAEck9veFkBdxg9i2+rsQPcH1NyL1kmIQDqqAmL8gx/lo4+dH5LoqJHTNC49UAomX8lPfG/FEBUo99TAphgi6M/EfW3lpUB28ga2EKgbidYT6wDwWOZup1hND6s5Q159sdVVwldSSTun9Gfd0f7kvMCBvc2LUQn3JqZaUnHENH34dmP5oSmmwXYPC0gkHAJ6nMIScYWpukYh8ttGnoT8Vv1eqWQ/yiE3sfZf0ZtgOzavNYghBMHDDUziSGSsTu4Ss+rxOHKaW1bXaCZGyYFw9gq7J8ZW/dvCjTXF0UYFKckwdtesBwA/MXjqzz1Dr6Ue/JItaF0CjWTbAdZO/0JPK9gtBbA77G2PpPP/5yIdy8i6wON5X7Jd9zDtHyxtSfoiw1ksHyFkJ2bJvjzDwX0pQoD1OU/IjpdGMR5A3j4tHP4i7VTLlPV2wDNQCdDz3wMmkpM9+W8aLj7jWuEP4vdCaRYxMUp+blGmJUMykHGDh0BYDll+WaHt/H0Hbu1WWOTt3F0R71PrSDS8du1TP/TnIZkw68u9nVnDt4+REnCUxqHcTq7IFv7rjEed8uJzbRz9pq6dTpwWJVfDGm3SRPhakTKKJQBBSO/F5JhN75OxiDbdJbi1GiEtHOpWw8SP1XvDa1OOun6ZsQTFxHowLIJw+/SQ87E60wmO3R0FwXIQwTRwswLhDHy5es2ySAJ9cYvyt+ENqLCzh1p0RL2XrDxV6Y0EYqFYXob03lnOnA5LRGNjLhHiUolvsuGk2DsaDtzPXqnf0YcDIAQGmeOhJS8xcBoXuL164wb0j7IEy9w7+GaoSad+NpLeN0ClmbbF7Ipfo0bL7ss7KVw1KtyNIUuyATBoBIPx8KZ8c/d3zRpprzUw6d+djtGk4euCJp1kmYQqv/qgGzrLXJnAaTa33GaaMvOh8c8FcO1R3pQMetbSS/Z1dvc/MZ/GlRJSLo3TS1q+3hGTD3xXkuZA/TF3AHnHzOGXzWaCCpN5gT1sDdEPYxKHlY9XPIWVXgsxjqrUWMjXIX6kM/AZSrW/kOtKb+cBi+XQgKs7DTFMUJK/IVxakq1kAC0r75dI7DJm+Lt5Ul2uHEZ/8/GIMJuU7W6iR1Eed/sPQNLZ5F6uqbdGr/fLK5fcjvSDodhYuwlRxQ6OfQ3gE95C6c64hcmmweDU4+raBY5oGmcpuQX4aSoHxycHyD3lEhAd7HN6UHgxO4kWIWtfyfxTTYntYQpfIEO2WE9R3OmdBQthtRKhfkr9sPcbnXc6gXy5zGUZKbAY+MTG3ZGQ2vpBQrrqGmcTXa5cTKUCPaLm2xLp40tvJl0kLVLmER445uKlZ6AaHlfZ3nt4ymPH7CEtvApvgAhJabp2tCSvydxpos91s633eMSE63mkYqzIgxwsbGJ/Qcc732DFxdm7GkM/IURT96y8DKMnObV19CdhIBRqnZAMeIFu+meyKhDeymJxQc4F2TMU+Y9xmNQfhMF1RWkrc/ipYEG2vFP9TSBOudC1GUMisPP77wgOEDaztWUxnNZXaxpLNCEnvWoRORbN1Z9TDIZx7WV+3R2F7eA5BtNzZ5+xkqjRKX40KA3FWf1VKGhMiqrEnSuX4WwYQ8vmqSBQWFUpUJ0VNIuKW+llnf1THpXGTNCTl5+aUbAdkvfPqpkDFZdEvqYaquNRFZzKk8xxhTwn3q/b1UZ/r+LZy6VMKdCOxQcjAMyM1A/bsiJO+ILIrBgSSG2JETc4RAd4L/gqGS5OqohaijD8c40EICp/oO4KdBMq5ko8/xuCsRdS7vJjvHgfgRhl6aq41WuLWI8Y1ezKApVklPXi3057+tHkZQ2TglO6wSIQ6txULZicX57ysTqxim/Dk31/gi5Hb+Q6n1YdW3PMvIIHiusTu6nvE9otfTQmWsbPMrFN0psRNKWkt+4hfs57VQuabUtHHyk/kQfgfxCNjxiEfwHEioBez+tyAR5xfJx7Loa6+eFh8J1GdIQGHCEmJF24mBjFrQhTNiirqj1c66tBmgkodkpdhpdZ09DBv+MS85GIgQwupNCLUiyNT1dha/W8xkmk6WafOvUp8JMUt0vlZN9ccUdRdnAvn24JgPwtcW0hMxXQz6cs56VTNGhcJVBa/4ybBXhhir6s2dJpYh6KdQ9UdqjCp0XgWa2PcKqLUK76j0rq5n9PmoNxWtutk9EjWhuE7Qr3KKoNf5wilowiaAmzjWBI7ll8lPGsIio2e2zbSOXO6FR6x42s1lRBEuOyHr6j145R9twgmIQx+zIxZe7jLdYiI/pOHbmt5Tr41Og3asWSNExae5/KA/VP0Rs7+oRiMc5Vu+qFnsOlJt2rIhgWe8IVNSewWE+KWC5QS0Zd8Kvk2aMIfX4MetPqzD/9655E/U1YsoQUeBw+Qxfaj8WOhjHT4mPetP4ulbTN3qagWjCTvCZvAbuk7B8a8agB5HFi1xAKw5/zKTqrL+JnbomhWNhxTSmTssz0PExF6UoTk8GO8y3ItijvcXp/U+dooV7pCJwh/D5oy5iKEtqxQYb39c2O+6YrT1ttDsyqKZ9qmtsPRhh5egpc2mdTlcu4YtfE71is3w7SDfCBK8633nKs2exv1B5sDorWfCOrTkjCxV7rd3D3vHhljQ5dVYvLzTDlXgxzxbo60935a4aR/XCgAwH8aib9ssYNZejs5QFJK5/o3dk/07DzTMmUOM6jnz76Mm0mMTZOFphvthYcB5EwSGEoxD3E8LvtMLKsor6gqEQCekGRmivSatcxk1wuCKWXkv/DJCbMbqqALr1SVh85F+c7TIOUOPBtAhyxhAoWATdSPmAS0AD2YVYArLhGLxec1WzTL4mpJmTvrZr9fmGtKy0IVFCYgnE/cVACCc9pEVJfSXUiQzXh6b5tPY/X5mQ4r6kPm51QDBI8FTuSiKj2KCOw2ik+7bK3sELc/efHNuIZZ5bHZqkJ3i/thic1/6cCOUBL/Oexon74WSFoVELibl2fP4tfULBITa7BoOHJVRxvim7eC8doleIiXusnjs9wFaIVM1emGa7wmesD5jtUFsiSzDotOphvuJINir392UtF4Sk8q2kfq201u/f5cZiMeN7k7Ea8Z8lY7P9gN9ef3ymFCImF4Q2vOOJLz0DQKNZtCVCa6iVhCASckQjiGg8hZIUOunO8PiaWJ8QFYJYM6Nx1xQnEof8X3Fd5/MM4hplQX9NmiSh/YZSoLYolcq+nSSXXeEg5a9Lugmb9cw75cnYEKDrKxYsPhr7HCu1cgVlhNPeByMeMwhIk+IP1ARyIfOzGl5gRcyGGD19KPLHp9cNMQxrnLu/E1kCrfHFctX+Anzw5mGjgo3J3swCxT6RjGpToAAq1YCtr/QaXVMqpVgFh7WRfYEx/HkGwUbipnXvNhqtdbLBVD4wGUaFrQKiT9/aEqfY9QtFDAyPkeNiYrFsLnbrmejz1CsjJdDcj6QEMYE59nuAcn6BmHZ2zYNf5sypf3gFOxvP0XAfWSrtDpkMHVI7hJVe511TMBQrwrdmyJVGAPYMI2UnKEneBfpVF46Dm0nZOfzhgqGYJGJF6QEv85QBfio/plxs72rToH9IQAGXUIeHsq66SHGgVzjdVTiUpYaSnBK6akC9/95AlzgwI9WCkSmveWRqPLiJ1ptkIvo0BFRC/pbAl88yhMxH1fZd89y3SxCCy5d2HSBuo8oTs/U4Wgo9P2WkGBtxLTy05zU63MpibohSVLRgnprlnhDsDRKDTmzvGI+/+DTeKtEoSDDUsWxSJxDb6JjyKAqBfWgJTFTWanVLCFZJ61K9rsg10TIFtjphpJfP7ziAxa52ZPDKg+YeNVOR9LhbCqdx+dLJXRjERgMq7k7SuYryrlEDNopxRaqbrG9fHeTilz6mhi7RP0soWCRMj5s4mWAhnldie0rV7XumcALHCDGGm7O1jRz1g8dQ6HrMgkbETaRar4tBQGBbZGB74GE6bv1bR/oJSwH1TomOAo5a3pIdKgA8b0GM+plD7Y1yLZuAxh51p1rIKeZhxWLdvMBIMpAH8ABZacNFRzHCmHO2J8jP6xqpb5ekhZOsaH29XiL+RG/04NvWadQNWFJbtSGBMjxrfuyJp7U6qJMybx+gNHoNtDtAmXf5qew8S3VWYtdbWwBuWaOz2cbIWAHjOcs981VG+jZL93dM2UM0rWNSBLPUj9R2XAGCCRhDjuxeEfJeAnIzbtL76bjkYAwaE4Zg2KchrWIExVPiOMjYiRugYvXDsqroXU+9yC1kz2A/06DlQkG9vPlC8cT8UoJvmylU9dSp3W3qGK/epgKFkTBthNpz/9Bsa5tmSI7Uh4zKQLNDx4rWHXHHd+waNK/JiHLU5BVvRAF43B0Tc+EOmojHgly/3nGxjpFl1Qow69dS79UHkvXLU/cnIRX6ncpGTF2PoZXDR/MsW/n9InWOzazotP3rJTJBFh6IeGs9OV3bA9iGkWHxoGDz2ukd2x2Cy5AVqtdl2l6KiQPltVGYg/t5uYvawkNDh3ej1onTw43khO5qNQpEdjkLzaM617I/D/AQ2rZtVtMuB9HLzHyJKl1rV0pNhbB0v5ocWEUox3Z8AJ50e85nYmJRfIOVgflGofyBXlYc9tMaqn568lHJ0NO9VCxtYEAgV2soby2IExA0DMhB5oAX2csinfO+WOmU13yVFtsRzHKXaGYeaU4nI3IQ/hklz0O3UiYHwbvryC8ksoNVtOyhiwygrTEQxjdr/ECcla7Qng7NdtNN8lIEbq/aEVmzQO8HEVv0a/d9U/9CPCpq2zVeIDceopY8wYCe+vKe74+uAfWcc/vIxZqLJJ6KpGcwQ7divxU0GW4GVexXXBID0kw4jm2gLnRgmFsoHGdj4FKWT1Oiz8OKnwwtuMDw50SLUeG4dBB85AIEdb9vBNIvM8a5LzxGdkU1B7cdeTl4IHjJRRrXH8lQSpmJtYU+5ITxyT9AJ6pFMMzWP1p5moO24IaCnbyFUX3QzmXRmHfvUljPswC8HRxWn1Uoocu/SMw3vr7wy4t6CelTpQ6Qpdsc1g/B+aMgjfGI6QRxEHDqAfjrdPKh+395oDYrmPqpqALmtk+pv35m+wjgt8BE6bJb9S6m2Y/C+WGRklUApVa8clU2LxWxyoLjD2oNmMe4e9cNJ8gOkW4sYHshk6Ichtqi7Uwb9YTCYvqOEDLaL2H52LTlKO7co4+Bu/aFYoMk/Pqjuja9vWM6HV12PoiWYzAzJ29sC5wI6v52BK4LDCHRLTosiVOwhiuV5KKbc26vCGApYXrUBqDcIgb/Lhrmc5zKxMV0b5vTH0rvBd/S9nplETd/n+K8K4hZsBB102bVDg8tQmx4O6SPn/gQNweuVyWc+i/AzFCUgJ26vmGVLqcZ9ThH+ZnzMjOKBcmVLnekurNGcA/YLKCY5EyBwk43Q+9EklAmViaiX19zZ/hCxNt5Yu5WlTLHwLnt/xAtGHgYmyEVlleamLAGRuD3orrtCDCXl0p7gFnOC+KdYqjZxIYUnkak/mPW6Kyr58l8Cxfi/Gyq9os5GogyzIPARbChdsz4WLOnzIM0qSeedTGg1LLER1nRePYpzp5S50r5NWEL4R4SS6itkhlyc5iNHiXjngfwepIzl4MkwFkv6/YE+ehgV49tlAVaYXp1psfaWXRSMa5AaISG/xL+la7VnklLOhwVO0mJbprD1QJqTx1WeJMsda0LDuxIjz26FpnEHkRVE5Pd18b/4y2Pst9eJfH6SCVZWbRZ9S80nGCyHZn/8JLhT+/bNAaQmHh6MRU4IvMGAIy1HCcb65dW0gpnuf1HmpGwLGdDx/z6ax0VCDS4ZOgJhTZsiCa6ICRQc4SfZFfrlUUK9eDLgq/Q+Ch0xSj32kLUcHPrDVVghTzAcaT+t5CeraYJRnvZm9VO3QXcvZszA6hVaMwx1yIAHMkvtkJ4AApphyzkkoXd03Cv0UzGeAq31cEuX3Ahjkr4WqYm6KZ0pc8LkJGA1HzA86JrFAzawdux8Nh+KPHe2fGab3BpxWXtfxCsCwm7BCsiDOfRBj7QWdBTghhE/VA9FvMJZiCTE4WwY/0B9QCaaxJ/ANDGUXuecm9fpt5zIFSK2HQltLG5rF/7WXoFeC5UxilAexPrOjSOs7XhhGoYAemnf5E5osoXXqK96n4Ug2V2JjyCHnUpECbppl41+hpuJ9V/wlLFk8w4peK4wlQs7r/rQe71kP+8bh9ua4BslOp0Pv7e4QE9nJ/KS7RC6mICL90d214OfXSRZ150S7qCnJ1rxlYVObQueraBQhD23/F9lkcO7BFh4g+9FeOoTbtDuvkZZcOqsZCnFt7jwJaeDB+0SdViUjjelxdWO0mSiT6N42bpSr66XD1eR5eBH4jjjhLLXxy4ASq4J73aMtBoEH4pSPLraKIukRgXhxOBhQm1H0HOWcdvUtOu2O5q13PIUMdjtTXW6QdOxTl3EZ3iDflzMMKsOZo4I0hTMai1h/MjaM9JNq+gcnKweeIWbh94OwJSexe5ummZiwfXV7YfYFrb0jDM3dQF3hsD+8xOKCTxCdb5O1VraPjntT2wbW8oAMTGFALjVB6jzZpiJIYNb23BtbuSIkSx+Zeagv9MfZsccNQHvM2ZCZknU6tLEG/O+UhkstjhOIdUlGPGWg1fk6RrsWRoRgyS2Lfi1OH00P5smlmY3VIa+KkBN0VsB1Cv3RdGi0PoBXwjL32iY+4f/fl4IUbLxjvJdKYMekwGCwsrzHtHpVVpqRjgXeXiUjIZ32MJ2HIIp18VMalqq3yudVG33ZEtBtdHV5vQfF+9OQ0QNUYwODjGgcbsj1qPKwEnzAWvepEKPIOqu+oU0lMY3KvsBReitj8J7hUUpbDCqnaBtfSE58VN+R4oFTYS5fqJXH80RgPJsO/EKVdBrWIqsM9yq8fw6KpPYRGZCM1OIky77X9fctF3XZ7TmAt44MCmfv1myzSqijLlgl6gvIly2jB9pjEblCWh0tqNmDli6RbCI3NosirhhK8TeBMj72YfZcfyHyrPZhUoI8CAUgztDJtV0xlq/FPjuqikYIH1iP7au4sQIZq0qeupI7a2WhStoCRE/cS78p5b2CPBys1gXP/LL+3LWe2W4Z6COPxc+XpznZ25mzSLSm1o3ukJPAonY8DO9P77wVZ+pETbADFW0+/pB6npJUq037hTb+ogJReOYoGrbsODlesEJ1RvkK1/twbcXuFvSL41G8EBvh2J6Lu8Fy/yfJ5oDZLbnx4wuT8ICw/7Pf6tNyg/M3WL8YHsbnYOGI1I3l/QaR18eRE1qq3HFXBGo7qeXNhleI3AL3DxE+JD4ulp/6vFhy/jP5Cehaqa6rZRyEeKZ/OIpNMIkznjyhgJSoTyxZKff3WT6+HGpLVhLrmbo2tDFXeayNhhKAn2YFbZAc8VG9Eqr23p4kCfiBL/xRz5SlyVbgMt99YKBuA4saAMkSVGMn5aH2B8/9CoikcixxnCpTrDVWHi1eKqjdjCQ7zkh85vfTqsdkUhF0XUVRSgtRYxjaJvrw8/GDVBmu3DtSymJec3ZQIEC4Pm4OJ7Ko5ESYLk4hSSHV/IpzpgR0+SMQQ3KHGdAAGnd7RgvFPiTEBWwcpRS13JRG/YARXpLzpGRgwhBr3RTwE7zcWp2y2E1DW13/7tONKLKKwKSomaSA+wk/HTBgYrFsoWGtpbRv65mLpPe61yEGGZV+JwHRAA0CdA+gvHbCWCnQneJlRD30X3Dr8cG3r4kaEPsbtMuF+i6R9/YzEyt2KxubWx9WkUyqe6c7gcaGXEtgaZ+X2Yy//oTsZVmrXcuwQo9v3eTRWYYs/WwHVAaYMaXV7Map/YX0vGZ0Nx4LgKKG5qw3VGEAyv3IYkAuc0ZOhxMXRY9/ZVyj3CFMHVKnCn+Sjpwu1v27CmEtJ+jLzs935vxMl5QkuTJbebK5cl7NXx+ZyI0E/9G3j4vPrr6mfUZhlCn9aSALTUKebs1FdthDlDvxR8J/MXVVx8tuBH8+bDG99xenfPKLjVZAMjErqZ73DluGtJ72Ey4PYRmk5ZtQumEwgr1AeLVmWk5LB1qOAmA3iBHRsAkI6cWJgV2cgrOgrz02jcsJ10JNahu1SCgvLuDdyhjnC5ZAt44RsgBUtp4ChH6uCH+U7QKrG6CQJpRNwPues91znGKV1ap218RPcsX8T+6a83kn9dPgKml7+xa/Rrk1MzApWirg3n6YCuM5d4Cqt276DMTE9FO27HrD6gMBZTl1jpIkih/24+BagqFihSFYVFZ4rdvudLWh9BNSl1T2E2mfc2Rw3/kGnihNIlDrswRokCtqOOdEGKA+QmU+xkfpTysuldt0k8me/+hcQ47+Sw9M8VGa3G3JjsV3E5b0OyJmT6MzcsydjXdQ3u7etL/lWqmaMGCiRNwbd3YN5QhaGrTG6gMbfnXRrXFswNXjGceD70GDzcHzQaHTiCjzRFu8zDE38K4Zin0siS/eQdZ4Q8R+LcJzRP8sdzfrfh81Sls4UP4u/6URfKFoEuaggoWJoqjF84mXqct/2lTxf6qnf6q2QEun99TCaXNn1cNZIYZXZhwr/6K3iIwbT7Ye92TZLVjAw5tTR/ZkgJU7yVYbn3I7EZhjwYhlVDWPICrNe9496WgKFvMgJlHu3oaQJbZxJjmy6NATNiczpGZwqU0OmgwTaAB5HQvLdQdUCAM24u+Vt3QtSARu73LxKQ1tXgAharVZ1menPT06JJkXbTLIOd+QvqPE9IF8+Jx3FYb1KvdAlIT5hAxykM63TMmuY6xhQtUGAvzl9omgux547MWTNEMIuolalzYcKTs2IDn7GhgfH5oxEYtJnIWY0ilA0tj1wFf5lhhcUGpGNFZe6L6SDhv2GYmqdNOGVEDK4wba/SRNiO6XoBL+zL2KmLgbJMnfdz+xuJR8AR4LoWgI0F0xyouqQxSRQGte+HhUmmmI+YO7EMg8W+Cdy6nzsvAkeMErL2wc9tMnsk6n9lLt+hAs3obV/Q1RZXQkI6OiFAW8EVdEDoEl5UdYu64bSgXzS94pfcYXCqj7Qm98aAFTZxgSV3Inggi/xeAUQxaXcElCcpugaCiUfD8Kg+DgtvHhlP3GJSklRPuFVhHTjFFJe2qaO2JvnhPNfwf8UMvD0FDClHPLp6FKWjQ2ZgsFwG+oczFk1unvVwjSBdSEWwduIUH4XlTo63IetCW3WlODnYGGYPJxEsSVLGZtriqmYAGCVcKRwP/0QDvKhDzRQ0weLaaOqkltMKAyynucYNV7lCr5j82rlCfdPAhUqXq+jXcjZp+DJcERS4Frg7kdzd2Vcd5pyfDxCNP0lzWZuW9KeDQxiNbE/kTT/BnOOtOitXZx421k8EIkMovvYXJlzUrOVoODtD5ww9c80ui8Tq0X87+H8wfeDaOtaQHxMHSWpFyxvAcY3uglVDajcur+K8N4PoDyV6Ts4KfkgbOL2xQLhG3MBgVYFO7SFSjN7gYaZ+SoVPY68Hayq1ObZgMQM2zzHSI1s+MQoMI9M5QIrNh8NqnrthfuJIYMAk10Jt0tibLv4pDM68wusJ3Hyt5Amk8hUgNLGxJMyNtHKCblJ+xRsAZVZMoW4TgO5I2Rl1olh21f9MM/wVUlGWm6q5qVfu2ZeuobRpjOjK7Sav+Qc13BdMHITjhzCL2KjfNJR+X36PglMi0FVqnKMNza5UQbDZZW4h8+6Vc8PCZrQDXrRa5YFRYihSDfHxTzRS89iuOoWzZZhyneonnGxW1oblAgIabHuLEL/PFZpRjksyyYr5ZSTHaAVMlNLWhBV24H6ehwY0sts3Myp/bl+OIDRStKkbq0Tfqm6Eh9Z486owLkqU0rqRgm5jk2sFEGGJy6XfYihGfkxck8hwfaiu2OofHS62Cyrsx7kHjRWL2/X/9Gxb2GgALvNnQNZIRfMxf7lFJY2zgkdip4oS+P7Upd4WpiFXDOKTKkfwQhKQtRrKJO9tnGuL1EN/IbEX4EQmvfgKi4iR4nn9DNAeSUInY0CNZDkIDPaUrosuzHDFhEssxEDYpA5z5l/P4UkJ2qxitua1caKeDKw54TNf36KG55AXEV1tYwt4qo1CVgvFVRzZj2eV1Mwm0RGoyZNGWAClxx0ZzTxb/l7X50AzIhNt2spxplyDS0faGU7pmrgTBrcPyEsgTADeGX6nQ4AiOfR8rukLBXS4rw/nn7Uma+Gp79zl8F9RzUKhDUlZChxyPlSCFBUiH/jSvibo4KjLVe01C0bvEdlBkdyYmIlbF6HrEadLHO647GIsKpivrKVKoiT3tVjPHx5kNUvURqCDvMMQTC6yHK05Vio6EmNS5IzNI2uCyDdJ681jE9DbFdewTFsz66aDi1syHFrNVYGlGy6HYdwXW5YHsSQUQbuMaTDsM97pVs/kEH16nNzU+UhVPqRU3wSWS14I7aw4v8FnCbjUP82l+R0ZVsey0DPWaEOwlusxkM1mT8UGwnB3JUbgSZdUjLD7NGXlEfmCeRAIpcXTDR9argz0gMK9bZ6k0n0AvFGwdiV8x40Ax5aG5WVBs4VFZiwwTBYFtxbP/DxhYBg4cfYR1Pe2M5QQ8Ky1OReV3fpNV1PbvPLGvIha+eUPVE6RXWLEv9+n7NlB6yQDxLNtSN0AJq/m7pGTfh0Ud//OHubD0fCp2Zcqp10lSwzXlQOvw3wNK0V4zONLvWJVHrzH5EYr8rRRWARL8hkB10sWv7WYNNnxDvz1o0EjUvmDolFw04lZpioLSuhIcMzGIkV07tgR/xLmaqYD06dA+BCtY+PG8xb2t4/6wSF/XMAiyiN2pWLuAlwq5zUZWpRtFq4OFPMcXIWE65qDuuMt5DqXofRRIhZDPA1trGE3nzLnWR744EcH45HV8HRmmnEw17UhLXCi/OGFCiMKO2nNyZlV+0/8CFGixcS1qSEPDkPiglNaZHbO/qpKEglvzk+SBZGJ946OhG3jXrRc3N6iTM03KrJFLnYTFCRHtci7se7O5UBrUqqnzUmsjMp7X7uDMr2YC/hDVRzfvR/jo6GDQHLWiUoxetf/yx2yQzFhdwSqZ9ZF2n0ri/abxlpUU1f75yWNNhe/ANjSuwaOBZI5SOX4Sm70hgPyt6cEMS19njvZRDVy4mhx44Gr60PdgPpx3IyrSeLmowGFkAmfmQO+hGDmAQu8nRTDrCcxjefc7WUibRzzeNpzBIm5fvllm2vhNyazt3jsUlue0gIjCL+HJdfoB2atmMm9D1mYMZrlhXICcoP03NwHJg46yQotzT7mQ1o624LHf1qYkwD4UEem6QwjrJXXPuxggWiD/h8K2LN3227qx3tLfBg06iASHijBQQH/TulFuB8LV5cgPA4kSRRWHXcGgADPtsFFWqZNwQ/bdB9Ds2tJoD+dvA8o4UJgOyl16v9anIhKOURbEiYKdF5mAzNPbsXXlhC7m/aFBdps14ueQrIL0vH/YtTdUQ6rIF903UqsxuvjS18UI9vo8LpCef3ZXZCNH1gsWCCN+i5Zb0YlWfTiry9G61r42mRDztFBd0Bs6Ixs+SCek1ffK12o3MX9NMSNxUlrSacoLGG4VDQ0U60MMcVaWgFwtjfi6dqsKjcLvoonAcHWMB6qD/OHY43pEw46p0WNYWNAcyjnZLa4cTDhQfIiCNtwpgUolR39zn9eCOObV3jugMhfa4NPXAyRGNO3BY1YvVGA/dCtlBzdDlBxu3FxUv4DjncJ8teU1HGDXlEF1Z7TSZBXLSUuUnhwTUrYkdrtebbWzTUKt7rRe3S0TcQNBIYjViJfwdyU4Wi+/D3J3vjF7xg46p6My4qaLLFkYfV/4tLh1aq291ifdWxlDhteBCg1PrPmCZPYa+Royf/bwFyQy3bcX2jOU6N3YfQ92vEhwtm6i1qYl1DFe1tP0KEf8bAWUdH92khCavCSD8/2NbIYej6MQ471k6RTZQlA20n3TFLeL5mc6uM3C080gSAsKtKCtC6sDiZGSTJlBa6PlzpSdbFzzjkkYiu9Ouj0JsYRO3il88iSdbnwrJlHMW8bKqyW6VnPWMPKYyOUKJTOX1TsV3eo9VoWQr87rQz4wbi2ao9ZHfhdkvbWnCihKWWVMuALvZ8U9d0SnuIYRgilGnQoeMSJK+dpr+nhJw4hlptkG8UPNE0ozQw2XOBtcBfeoCgLtNTZvqBXeo4LELuSHIXcARvMgwJayhDd3Bz9c7s6FXAEWInuVCGkWO0hhkOZTqE9+fnqHtO4rp5mHMQ+HIrOmY7lH1u7p1m3Mmy3LcNZPAtTay7xRJqA/2YkUWM/6fFsIzv4WXb+qBZqlKd0nkeXRzvYIZCLizCZQ2igo4w0isJ0t42chnR2Y23D4MQI6FWfEq6WEzVw3yWvCW3a6wRfy+WNo5QrZkdNMz+NUL3FTYtFMieZwSfG2iB5lRg1thBbwbPF9UM6lpvf1OX0SjwVJ57tMTcIr95jo6DYHx8ORvow3tlzPIWZGcLMCZwydICuUVfV/vk+qORCIcai2M3UXNyH6CWTMbkvUaYo4d7YO6cFl4hrH7LnJ+BTGqto/OEF+LRUOkuwnITi9cKKW5zn78HyCf/qW0WhWISJp0PNMD7leJ95zudG+PlJ8S2wvs6ybh7CErRU1WIFQxO+HwLKvD4pF45GHqdALSQnBiV+cebIjP84nke9J6mIGUq2nZlxxECWdAfIszi2QSCrL0WsCqLsBnIyLqVv/UZUIrxUZWMkmAaWNtbSSH3wzhukDGslqqfbhuxEZ03txNfZfWY3B65QXWSHhHsRTSbLOLTMr5ykxOIY5SeV4eJBZpw9Jx9xFWFdF4TArDzrcyKyDbti32I9uNrnV/CtHhXYN7kMi8b3hnQJ5sID/j638Yq/H88alJmL4Fji+VvSI0/TDdgKtdIK5tZ41GueI9n/sXIxG5NHXrFY1Hoq1kIM4H2+se/SrOtWhO4Klbnt7CTGVhWa+BAJZYL3YK7B6dwS+RLIvf0U591JnPJDtuhuoVRuo1T99X+tILHkxty9f0S1scB6F0L2gfswhDrwkTAZx88B9V85RMFKUwNKqSY6JMeVpnBDpuS4HFqYQzZ53TCQxZ1GzAyEtnAuchASPXjDMbRsYMATb24HFuUmByUGQ5KfzliX/sEhqoLAhAG0fKVwAYds2beSrTTDsUPROB5et2qXe/eYceEMeviH9S/TOmn/fIaWxRDX/dqXniQFjQ6SOmwtumfW7IA+whaJfNSKp1GrHrbf2FfuGAEMaO+IKMrNMJjdMBI3QL4Ch8Z4Bn4niv4cOqshoewh8UhyxC7UTAz3pWCZ8OrFOEfk8HAdDkdUAo3ASTmDj74w1VSukySEopYAXA64xHw+BGYHKel3hBdR9Rnrwg/batkgkMPSR+1gq/OZuRwmV+DxoJloi7B2joKWbgaNBESKohW2DL1tKsEFG3tkwWAitn22lT8cp9g7lBbNJsFkASUQeS/KaFWziU6EMGLID318xsur4sr7cwMHQJV2lS3Wr6qMZYTa7jYCN8FMvOOF9MloXO4/E2eNVGM2jjbbKoMU0W5nqLeP4LS/iPnE+yWTKS2lz5a+AQ3yxLPun90HACxeVgDm4Oa29DHLWWkyNqqpFQKW8o9iZzQ3tfk+tOqLnbvrBjk1IoU6MRAPOCiVaDgIrGpYzLi4qQ0q4zZEQBMQCaVO/itZIebuYQdP5P1VmE1skklQrK9xv/rzFz41smqRUJOdLdhSYiBzOjCgJ/36jIUNR0WgnzgCl06LPLj1ZdPcvvi2tfEaWkFCit7IPY3xGVH2SrOFLGiUPlGC7Drd5ko8xXMvbtBIndRs5rELOHYRufCZ0LVNincG7ssDZnnn1rWUU6xx+JEX4FRS6Zr73heX+kH+69EN1P/ze4m6j3lvBPLFdKcnCJZT3qcpK00nTj9uF97xD96ZsLWS5iN4QDlfO38C7mj/TFxthXPey+2M4p+jVnOku5mW/JUdgC/FWBQUkSvGgZVO9UfdBRiieJYfYd8zAoih4bQNcZDvu13p+qT4YBJubEm29/scK9G3s8UdQRAi2flVRCQgC585DRF1oVfJrWWgtfWhrJPg8ZPdXGy6ppULI/g/j5pNA2zp/cL0FUyEz2mQUZpPA+R2b9cnkFPom0ZZ1JTXrTFWeVRjthturgDAZ/MvzGvuuGZkLg+KhbM2zaEn99iioU2FSB9+jcNnRFDjcGXmxX+E39EfIuKOuKuTKj0Y8o1P9vKOSPvDl805LSkSj3QJhz8pC7toeNcDtraTWUQR5z021M4gA+dpxAHfgbyKfbFvTWMYkYIssX63cE0bqshRMX+Y95FUXx+fO/nnXjBa4nS8q6Fol+yOnwX92hCdx2SB21s5pOHkybUwW6w4vDaf4XDLtZF0WA9Lyxey9BS7NITQcRSW1Q7CZPADFv+6lwS9dXbtdO7HyPGsAdfRFCTFAYzqPVeM1n2jBotoMGSKFDiBtoBMQfzNZtNGds5EkKB0mJwTeWZ08VjE0vcMc1WWRDLzJxto8AAPvgCsUCTZ9IJz51FUwIJHedlwiR4FZUEK3yg4DpwXH1w/71TcEzS49xkc0ic6/8Shh24EJz6Zg99Y2XV8eWDxk8If+7as3F3QBfTNUua8FojCRkrxhYwW2wJHws9zL40EEIeCsb+gpedo3FrZa7pVxBcon53BZ4fonoM6THeQdxL7JDOcpkXjS8wMTTE3/e3xzbKpsyl1SQ9xiAPPA16otiItHZ7oZ965YjDG/Vkh/0+7KsR2aSSYJOr3eSOlafOL5qs/TclwUhXvkqquq0fXMxQ6nPbood6ZerB88mDxSixehIVuLpp1WcyrZXZwZeEVuCQWiSZKUhCI7S0tX9o0U07weAD2EHczQRS4/rm7XW1+R+2D07NkmruijBinr/zghScbTwjiBaG7321Svh8g4brwBLSVmBc2iuQvE4zf/h9QAMcsMJqyNumHLxnZMdQeF8+mnB7MUa9mJicHiQyDUiq6BJokCaoeltKBOlOW4hzDNsDetS4TqKoqArnszyhtfsGrGOb+hXhYetCghZDCOINw9b7YegED83H7k7lptbpaEvYbgDJlys4oYsQstQTzKLEN4yrXlQDiCBh3ux9Gmhx5sXvAu6eFPcLHkQUs1T/XwrkjZ3I5jV4rRRQRDkHX7PCNkk/xBvrKtlYlcfRnwf4pi1/m0kW+IXoTcOiRndKaDBpJbdfsmD3B1BdWk1tC1WHfBe7dI5kPfEFZp8IscBuqUJN36+/VfeKWyxQWikY3FSxDmMphKx54v+1D5PgkYFRNsyOyCBr18/EQhJa4Un5bNuf5M5kaZlR0OeL/elPHnM/EVBGHb8I8Xt1JBbmB39NWR6yxP0qdUoa7yLIpeRzFxRLEJCQH7H4ijiIW9lUXT+/4apHWRwMjx2deLdmlPMS1pb2IUoS7NIy407rNAB3FjAgSpYIhJkIpKNcntj5ftl/htZxf7Wc+NFCGf/ablSzsEdb4oEM+ZW0CDGIGFU/T8NWRDgp0K81W+jdu0N4ezAaJVF0oXSSmBkYN2B1s022wvSQkVdDiVOD/DX7mDAe3OlW1DLiZcIy2eLhzoVSsA2U7H5AjIWmrfRSnRIrHxisOrQOyvo9QU3CxEQNJb6jGMTeNqxDUxulf7UIg8CjElFNJVfYa68l0a8qTVJRFiIL06WyVKVjwE0LpdmdP+1f3qT/adK6UkjTOzkFEan4K6fR0X9U5IWTYvw866ySBSNbgLL06gZ8PtV8UrpF4ATOMnhoCNSkjy4eoDEwyxT6uBN2KM6JsVoyec9FcOwftggxWl8ZxgcL1Ahe+110+7BpUxcPknpsmfuV51Ny+TbTQRZMRFLEaav2aeCpOjk6tj6n0mCEJ+oNQmk9BeoYKs/Gu2+zMke+wJ7wcPQObJrvxQ6lFTYccMS+iO6ws+i439yUX+JqfM3B0gZ3Pvm7TQ09XpAMyBBFm9RWQ4EVqDQA5RQM4jmSVYz0378Z6r4Uae+eIjWgWkc/d9U+MBS5BQj/i/mH9IYykwE1SU1BVYJhsPfKZc/L8DhsXoi8z4MRhixxW99wVew/734UAn5dBwqfzRusTaOPjAu4INu2ah4LO/6Z+nKuOnk2rGq52f9Lv0dS6ijjr+q2lgJoDX/ejTiq2efCZcNdZukPwjsR8YRVWTMy9LtUQcK1bnEIysEO1BfGz/uMBpqPPrmjpIrdosDKE+p/4AN+KFHpE6AoiRsoEJGs7MK8WMuJpBHGb9NRJlpxjqchhe4X7OT7z+mlmpPz3vo0kIPyFhWDz1hdH6VDyXH7oxB+YvWfVUHGv0Wet7mkOsRRi2LZXUC8Obi7L5yzm1XAw9i/qCkJNPC5eR3K0epBv3NOOTxDbheb1/3VKkbxP/4iHFhbvt82bWkyEVDn3tsDa4l4YxAI2AHIZT+oNxBZlkv7lC1cW+ZWEqCKAuJuEQ/mAAmEcn6NDo4qNVYkULYfO9c55hQcMZAG+57Ry6MfbX59ZW1XvVPgwk7BkPhhZPerddu0ej+JxpCdLO+iU6hSoQBKsdZyvsc8BCasnFVd4iIB/g8NzKYLbzv9yGqEAKXt0oVodcq7uAwF8tlRGntueLyNweeFZMvKjXQ1SaK0kw7VKynCdHuLonFqFC65YK/692ReHTrRFenXlCadq7GnATE8YZl1kQa6vMmN77tV3Uv/dncobAPp+yJGzWMcgWJL6ecAz7N8qwHNB2E9Pp7DXgVuSxdFUJLlOxzujeX3hKpPnmvhxxElzNjycRCqrUNIkVNzdVfmn5SJP/yEUaWXzLKbW2epeE+EbsL1BaKEaZAoLOdG4droq9FIp6hosqFIF8b2ZO34yfIAwae+HTEW3DK6Jx55+1gUUZY8o0s499VKVhd8HFGkNoDSbeBJg0UWIs7c7NvNVxAFXlqB0ECWJkgOLiQUkH+UhFo1rWSXJ2sDlSo/D87O0MQX4eNqxl3o6FgT0MZluY9noi/XcWSy5VkvTBgoh452mMRsIB+PPP1jwYT8PkjloYKbWpgb6xPWlflPS0nfWK6A9YuISnk1lXXvMtJAW3Zy8+46tP2LQKa26gJg7VzgMyk59DYu0wtLyHaf/rY9iAJ5KypOYCelL78mgttxzESWSaTEijlqdaui32PvUH/+krgJtMGS3ecEipgceuukZHhKrfWLg49d/gIelaWiePQiQ3tH8IaCaLEOVRAFe86PKMckKzLyv0/2ktZ7QM4AbDfEqgJvubGOPazSj0lkyX9tSn1egrN+3mcMxNX7/8d8aJrXalGF/ZiQuTFDqtKwhG09EceOejg7lacxyp90LHSr0eeEDbNRIt3KTCUKJf3RdpelAsuTJBN2mpNFXU+oQlL8VAKyaPNXAIvA24nBs4pw5oK6Q3Rwkya/TgsvN7qTcBOLfTysQ/zLvzA3Kk79WR8H/owkeZHkeW8G1lOCMEwMhqfFq76CpNT6bB87uSmwjblykr7v+3R0kweQb2fIhvyFwwdpQqS4t+QNU+LgxRTB9auKQja1ZdDJfuZsjxZWTsS55vn+sia0LEfFCRif/cE/ug8xnPXWsh+CZXZoRxM9O2jpKxiYB7BhI3bvczUBnU7+vr1vsNDZ7p05FWD7KG+k+MAUQMpPAqgdoWEwoZkZBS/81fftl968SA+VGp2TcHWBiAYelsHELaiX9uoLzTKtQsdH76Rl/tnFZUhq13wR1LXQsF+AD5LzDsEZnZ4ZKChlHHbSORRVG6qqn996uV8/zvhjuiIfprse74+L9alc/tcfjBjcVguy/WobY1NXbn+TVQiwCDO2BrUOxS/rh4a9O5ESdll5zODuJtiFAEfnuNO4mlOoC0y52P+bxHNncW5NAcLPQriaLZeZlLtW7mPsx4GqtwRU1oWHrUEEd4B/vELkHWw6MNznZLhE7bfHy+iQoJNW1EyP7wl2YcztnSxqx76lK5ABkB30ICxLLoxJmD8BpYDra2cj8wwA7I36aBvQizJQIt9js5F8wFq4CLe0s63LEst+Hp6LU45zLQj6M0ohWYnvmqtH+4QDGHz/VobP6MWkuP1MhxzbFmUGrLKgZr6s5J5Dxrg2xJzLyDa3b3rFy3wjngmQsLinyp3bR5tHxarWFKvRShhtfGCBk5FWxwjYz24YYhncv/ZAUBPik0TJ0S/jgkU0CbTK6/sVmpdV1QmdgSc5vku+08q6qXROwUcRFfVCaX6CrQkhioLERXKzPtWGQ0cIZh2G2y69q1MG26zTiMGmaopA7TrzB3EMFadjvgNNy/T7KD9pdKLp076pMSWvHidT32bkjr1/vMGyNS1AaHz1bqT+Xq+dODz6XrDjcKqv7DUu1AUmzXGzJ5YCEF5riwyIAU2hIvbCJ1AdcWQVIqEZMlwV0JL90N5q5mhaI1yisCQClnARF668KP6MwgUlXQM/eo9arkR1p7hn1AgRYiFhZG/r5RhAOgXCKvO1aYd6vcbfPBTaS/ywdRQ0l4+hL1OQHPGI8x8zQ+FMIYxog4Cn1Fekci5O4NjkPcMV4pOQ0L1FLd/bbClt34LDoih9liCIjhiW0QK6EbpfayB+kYl+Y271JmlS5JVS1AKO4FRI7VkRX0s1STTwL8Zi+nV2bfd/vsTCU0OEehkJxY0FS4gI3q4tf9Aub5K4u/4691KNR3DBPA9lBhlLbR99fPVtvrcGnv4I1o69NjeuOodUG+giWCN+HMLLG2DXtPxrRBatHcIFGvS99QFK25d/pTzKS7MePv8mt9m7rU1ImoBH5OHLIiNfFxCKOlunz2MOxHsPgm/r9DEhnrqpGzWKZrAo7lCLxFCTqKfSeZnrsCS5h449m4ckTUfNZBU2+2cInqHCqLcsV8JSBiKvkJiuC4Y0LgMD+ifqLs10Wc+Z53OF19nI1tRleYXNIZe/AjJXf1VWUsuKdw7CF9jRgiQNNj5Ziu9XwV4bKZfvAlcsQeFxtEpb4tQeP9HQ+8vU/BU7xcm9wFop6fm9jN8GWYISS/3fIZZJvLWPiypQCtwT4SGBZ6jFtvUulICbTLZz2uviZHgaVOlTkpCR9CVAisLVvgXyQOnccNkXZj+t8qldQE8GcCo7dhKTuFpYp4afn+cpB3JcLtFwcTDulkn3igEK6WcAJSJpXk4FXQghYsv/lOvHAxkzp/nAxQLfWGA08QTRuwJoO97xRhXBPl9rcBXct8cZl8AttGCJKlsh0J3JZxBISMx4DSZTrf1pwOaQNrCWH/LjEGYt6NPIzAtqK6lbQjc4ulbgjVNZX2fRE8nuJhfV9KdagoTWa6c3tP0u6dbzD0w2X6Z8PUhbQYcELro7Y40zOAha9ppGDohyB5uiIWDuaQQeAiscqBHGeYwQFp/lXgfI5cYCG/7YRgws7F9qfX/+xBpeo8BNAoTPPNMFkqbu/MTnu+wWyYrBse4i7rGBbM/r+uyV9TSst77fTh5KeL6SZz2IVUufuZSE4ErSJjA7jKGrozrZUG++4XDTgwP6+the00slTKwBY0zSeWdy+MyU6vB1I1AvX+H4WtIb+8TejifVnz1hgbe73IJoj3t0DuBq8+v7Hi6mK2hLEH8YPCszvkCzET2q9cyVMGlvtIiT0m0iBf++PDkeF5OLTi2JtzMtWSKnGMG/oJROjTFNtrCzlaHBuoJ5uebeQf77Ku7oNrlM/opZxVix5Fhfq71vd1tGDCvS+AqUhwtcyW2Jovvy6Sxh2Gmh2NwHvnAcZNGozfFegnZ1l1bml1u3W6FGtJXwTpxJwsevU7hwACqEgpK1RJT3mWzSLQJg7D+TykLfT760WofkIseOvmvmY6l0SpfX2Mx7Wx9VlHqlqSV6LhQc2Dg1ABYrDUKmN0mS1reI2OGTFCRz8cErBjp+Tj+7AaL7wgpflJyL8WWcQaNVQgnZ9evNEfuULfyK07ygCxjJhT4vwO8kddpxjo5nIqXqF4ZjSCW8r/UuB2c2oaKajcCGCPl/GZ4pLZrmPzUGB9IlUSCQ3M7JqPtKhKnzjC6IGUPMOSP5t47PJLhB8lGjFXnYRsPWiC7Us/swebrzpqbpmDCyDha2dgQ98hoa2eJV2gjOeOyVQUswOWXOtmBijvsYoJKRbQUL+7SV+6dns414iCYCmlUrtT2Phbf5uUOvFQ568JHz/PRFxo5GkeaXNA4XGCmB4yi3H/O2a8DmFIHB4kp7s0HfHG3UQDdWmcfK1ImyqQezpOlV5d7WfSrHZEgb0doY/KjGf8svy7dB7EJwUtg4WuUaug/rJSVKF2Es2XT95OkbPJUXWwf4EhjM5BNDOkJfPxAtH/y/CiCcW59/FDCBuFwjBAbXskEIicC1AhagvHbLFCbt2YlLjh03jbwELd08q21dRudOqdi3tg0hamu1VOzqfbyXDTYq5f1I6Tq5EsngYB4RPzhsN77bA2nS3GrAT/5wu9CJ1udVXf/f+FbhUYyQAi/cxNc8o4EtgFqQi/xVVMBEdNOb9CRKfwMqQgfu1t0FyrZyX9D9HhE5dE4R2kCmNn+x+dHAeSUFJW0b5eND3ONSgArqocnWEObYEIOUdYuajATzCY0eCQg6FTpsdWiXtHRhV9Pq6qFmB+mhgEMqM5lVC9Qau8HGjM7ilpwMtLkKSRbpOBnkUoJHFTqtGmQlhIuHO0Jzxm7j2Vdd0etB16EORdF08aS6wz4eCDTgzTcz0ByfPVI6QgoXPUxCNbXWhqc1UwPAR8DHHa9m28139V8N8SWndB8Evpn1h5ED62XTlKbHaI5w8O5wcpue5zCt2iTgDsqSps82TvYD5FNO2cis/Ja5cXsR6r6yF268vigWHSQNEYZouPF2fN72WJZ6Ulz9lr0Ez2Fn+esZ/L1y9JBUb2h3dXoTkv4P0zijwK0O/ixGkEIBQFXn/+de0JjWrGkUXmtCdC3i1AWiiYDaqg9T4y8MKCLK4HG/L2krPYg1JgXw7NBgGjEOakFV3/L3P7YsZPQ3XT/tu1gYxPvoXcwCdTFfkX/HTBSg5VkJLMQOofLKcZ7BxImzhtNO3EuvCgTRNPN4QOUmQUCyNGcsKCUJb/3R2lbsOUacr5M+mxNVkjNiuMQvsdi48Zq8BILW4ltkMRlzwgjnukH2ZI+cdKbjPLN4lampvd32/Qw4em+wyVQoWP+e/N7OyQ9gzjydfdCKhjds/1gop+ReGXCOiavhLJy41DiYczXDGKoH4mh94L7G1Z9dLGv2KUobHljc0fpDgM1gdPRZ37zOmIPSicciQ+jq1hogqfVMdCptQwPVmBxouJw1MaJcr7oYdlRLNsPNsh7SHGYXiEIvvpZ8XysNffh9cjOT1zDTlO/HKzZLwdk6BzTVSMY07utl+T5TTZw6RBbQKawEbjQC+VAWhKYlF7dsi43dulxNri6QnAQB4QDdCCghdKO2mraxZUWHUN16bCIoo9gJj+WA4ABN34jzSCXBurZYtvJFyifBrh5U2vZlEHV4KVagrK7SGbWpJZ0VP9McTuSA2ZKHn1IIXe/1evuSdfA3+jVjsbzbFRCvWeq3ZQ97sJn4RNWGdSLDAc1EjAb/4MPwvHL40+2B70Ze6kCzNHdcpzmCwYh9IePyDlg4E4gOXQ+NyDyQ2av+6uUEnpgh4e2wPGt04CUflouECSXk8lSaq5tqA4keBk7KzHPz48cGCMvsQQR+niEgSYgea//BbKGVJGdepJevFFZjfKWgHb1qNUsxyQoYUtDXyLBCB8lqmPr4/Id6tQVzyeYrloZlT29YHikeBXDbQW5oXmCt3/awekiXhSWxuDwoSWOzyDAZ3TTm5J4TM/4MY8zD4+7DrQHgzIhvpAnKK3L1jjSyZ5WqbPAQtwPIa6MbGNjVwm/H9TJStaAbmcTpjEy7+31EthbjZWMnor2AfIAkQymcLhvFjGPACEtTOUw0e8AySezgn1XPGXdWpHVI2RMzDxCQjPFh4ZhwyBEnqHfjl7c5RDMqN2g8bD7BwCpQpDiLQ9kVadyTuQo1rj3KRa1FHPiTEZ4lv3zKPDryB1gC+vpJBKhkeQfK2yf9xM5CydM5gahtbRQmMKYQ/I8SM7EA2PkBSmOd2mvfaRmQa6odk/WAOEmds/l4xiAO0iSVMaSHZeAvK8kLBQIfHyDSahjUVlWdA6s4n9L7uEP3voWoEwMc6/JphkIJTxgfpSHPTTyZhvfdcbvYhuhJLpTAFfertAt+EWezGneWdlH7ejowAzLaceEZGgK89gQo3RUusDo/kExYvTw6vTdoMeSulXWhGWK/+G8vDE4cJvVJ9kn6Dkl1xrJRSfk7H5VNuDt4GqHr1Uq6r3TMtlMTAYBchU9ZUeq+qMlzHIETF66Dwq/DM3X7KuLC8cUq3o2muvwjtwqutFqjCX+HtWhWSdePGejoPQQ/1YkPWHTde5fZfGvVIyxpbAVjJvAc/liG73v1npIH8MD+lAtIpyNf566qjHCTxqrPLmynJrXSjNkBG0LfUvhCP5E5QBUdPiA31eKYp125T24mF9Qm7GR005N4xqBCDE58HOXm9JZGmqM1MntQxJAx68qTbLot6OGDc/eiAn5NXhrVJyvYMFO1jyRRCrWL0XoXs8Zoa//hlaF+q9EtQNc8y0rX4dsv3uSJlYDOVn9uEr6aWGcWgrAyVjpt9IuuOjhgE7TgsLzj73lUyIUPvPxWmK99UW0z5VvEQ7H0M8jT3VPed/hNkJ+6cfXwV4OHR49riDWRakhiOKzlcOreb0l4LaxAWGL30ucItk8NoqF6J2TDLzSIRFFciw9+WQcUSt0/Jc7OXD93dUQgsqFZfbvh4ECbS8WFpuk77K0kZrnUkojQbRtHMGSZYVh5hm6gjgh1h/77RSec7QppArs6A05WCUP0FIz4W7ZFyrM1j9KY5TWR3g8Le1KMhIbmDYOm+JFxyxL2UwQdsMOYauA6MKYk9aGO7ekxUGwKfFYViZy2ME8wIHn5/mjSH5/i2FT+BW3oBludDvGnNdQHZdmniOvRN+zrMph+yERSR6jSArElwAptkKbFPGr/mfOLbyxe1rcATNru00dRjgdu+pphQynReSBL2COe9TU8eomPavGjtwbcgF5OiYKLE3tgF6sVLJqjUTn7uYvc4tYURzhqrZd8LrLAxaHYJ7FozF8y4V6IemDVoq3RW3nMlk/mbCiPaPKHD6MY27LaucVMwl3B+T3KQEVJ7308R8PboW+NL+c28WBwYv+QBQEUaopH3BRT+yyFiIdTVdQArMw+IGyUcGZWjIhbhDT3nVk9evFjjApEDYljwbtW2ks970b7oSJFkORNTz32+GCqCIhBWo/6340Zt5xU/Zlz/H8v7Ca+7uPGgEu1/LDxYMTdN497yCQehNVVEPwV+vejFjqesaJXjonbIQ0cPFjHw3lnb5h6XgY7U76iFoHhNEEJF2iwoWFZTHQu8bDDjCVkXSeYjsTD86d62Em4qJHl0iGTGwHwsKVJacwWMH3cKUARH5BfwsBedb8u/UC+gWH0hc7zUhzqCDtdsGD35UFEIC/1q+1MLcTv/nryiS0dRF3cFrjZ4hcHmuF6CWBD81MgwpR8ZiFetXyNSJmgbPdaCD8eGhFyDQGnW+xU+WM6r9txQptR2Fgm/tCjrfobfoc9IP7+tGVvlM4h6kCcqqz1Fd35Y1UzwfokfCwIOU6BDQQM4N8QbIzwbD14YTeGkPikO3IpsmttE/hs1vm5IAtBEbS7JBhwH95fxhYpQAoWt5Ilpbshiw3HVITCWYEJrKTISF8MW5vSq+i3NomFU8LoBATwCQpzDXeHl+lsZxNM/4JYsMNmR1M2fnWl0HaoTwclOiu8Rv/arQwzp5+ShQnOyk+92BPXLFZYHodQQ8abLMaQfgQBvRrbyk91qw8MjuTK8Une+W1ZDQsj6u6+eycz5UkPeByTzHXLQIWEEM4K5B+jKjMLHbh5EJlQcL7wajNS7U6L1+jIgN3P+bxfQtNxTljT9LVuUjnRpvqhB/X2rBukRdj/LLDY9inZvKhcgyioWWzJ4NgrwDaZOHrpQ6riagr2N4w4HLu/N3//9WuWOawyI25EjV5Hhrs3bX5wwlSuyrYQ8okKiiJkGymeXm9gnl1IJa4eL/DigTMi76HcGN6D5b1ICb73ADvNrSxXPArnFd7I1UIqNIMcGPXqux2bNLJcaig/WWU9zneL/6abxEUPsjQGnJEnt/e7jfTicO6I1dA4og1JADRQpsYWSs6jdrpAvRmwqqgiQGKQGm1+85Eft2ZSw0znbkQpqeD7hdHLPOc4Lz4uvtNzlGR/v0QPsmt1MZtvgCr36/JYSN1tR1XP61q2wwPDj9X7/xLGpt8g1PPHKZq6AhJFQv/dnpbXpM4RpwRYsj/Z4aFFVyl7RWlF6qlWuB5FFc9aFLtd/ydVU5W9Gv5x6NR4A9/rQEjlURHJjhQNB67mo4UhIxoMwgCgRMDWRyFqbxofKGYyPFRIYMWc3m5gGrdR+7V/dPawi0Yvy7ULl2Oqyh/II4s2TPRI5WR91XcG2nVCzotJhjcPqYTHotyG7wwF7219U3zOQ339siuyftN5JyBLcYIsUc08k5VZ/LTgJ3H56mkt0tNlln81ExxgtJvp8mwIApwDi2kdcWCLG4ARRYQx8MqDvT2Wb0EQji/zqEa4/69lzn2MiV3bs6crLYTDTvVWSpJEk4D1nwDXRNX+XldKgKG4lfPOEql+eTApdlwEr9LiDmbttvQZbdp5vtLp66MnK749H2h1X5X7ECYzpflogYCYRAsWL9euDFIcspiqcucNP3wj7H/JnfZfqnzu22y6S8huSVQfQ8tFMQXdfFlyhu+NwkMmX6Nkwsja+Nk2RtDN3/YLM277RMj4uN6E2Yv3ERGBVcp/pYwqEgVc6r+peizifRLyrFEJfQo5HOTk9DAiQbIpBGVSfnMR9EpbvEZLRidtI2Ex+ifdDmYf/i7fW0888RUe3+VGJbmU8tibmJ52CY9B7Q45UpHmfmWNAyCTl3DxhM+nu1tFiFl/5PGvBdIDG/j0q/O6+4fZTffhodECaKsv+oqXMlUcFJBLpQREFUp/OcQ2prWNjvVR51wjtjbNTBsJ1GoeNRD9qnUZ0opVnN7QbtQkXO51UM9BxiC7J5MP3hWtv2Ex4fqxcWdc11+t5Caawlauw+Nw4DezrencpY49/kR+QEtVmKDcEFjOKASlPiduQQm1EHGeAsw66MwfZKbGB1KkWwVoZKetgbP5AwVBqDrWBMMm3UVUjBKJhH4YVvA5MYWs1tTNiNJQSzhuuykRE7vaI4+Zm58QSHlRp3nw3yHiJa+VLxfcfvOg5upMvwvIGSRsx/1096Dw0eQo4y9FdA+qn61rPtDMOWtQasoiwrstzXcOa9E+dw12+TMX2Q0T7EMOaOoRh1fCWC+0a0cDxBC/YGk4fBRkVa780uZsLlcZZxXFzW4UebBu9q3xEb7iIxNo1lGDtQjWHo7J1HIadzJEOmuJxTyXNfyQ8/TY3oa3L6z09bV31JoQA/JCHSmEjxpGKJQJ9Nl1eNmATgGeE5wdxRpKyqIZb0pfjda1v7AdfNKFRm8QKxjASKL55ArX5aQjyu5dQaNl/O7fXy7rKCy2U1BICyBNjo4HVpUbqHDVoZxCvEi9y51TAp6eneG+K5UYoDiB0duxCVkYZZ8aPS2A0FsyeRr8WwsbSc3P/HfTcSLhVPwGChhE0UN0TNZzXK4pW5VBSjtTn7LYTZfhlPoyQBnoEhWxuv9k0KTmF8dumO1NG/LJLCpIDtfeURjLdqhpewc7083L9KWPcoK7mvyB/uKJreQ1cNIr1+Wcxz5dfrbSNApfX5Tw7sth0nOqp0G/+6LQRBGrFtryRLm3swiC1roXmrf0qoyCTHmkUkt8hZedSjEzUOGxfG/izKOJNtsEyTX5AuWk0IbrEawhRyVdftI7W3oZaNyNdaDayHJNx1prBz9MzIXyTATH51F4SZLgFdC7xNUKsq0jH5QniOc72Ho6hNiX8EnK7eDOb7JkdeJsh7ESAkoDtyPSmqhK84csfDdSoF29QePlIVRq+LZVqRZzyQV8/mLyVPMr5XewBDuBpzwk/awdqnvLXF6k8FvVOcoxRvvnNDXDjpP+y73fDaXrJ9N/WqFGfuVvjvU3GDlweTzh3nd1yAOfSWEM4z1QkwojXj9zpCmO1CtPpDnuhiMQeibdjveAeSSJw8CccuKcT7oEcxVQ+oqp6PjpoSPllOcfuUjFS3G7mztPhtXtEDhg/kuaEt0SfVSWuL/JzGS+ScGjfa1udO3uT/8udTCKsMd7ORi5lPNgssv3GwwmAFcubGFh28ckmczJtNO5efdl56KzMJANKgYt5x2X35JmRJskwAfDXyVzSpc+A8wFoGkOZmv3hDVJ3QkRBBXSUkWu+dtjA8vCZgL6BjmWd0r675R4oLoTKdUqWnWL9rLWXv9zWrp5iaTl6phfZa+Wmzrt8lqa4y6hnLXzKDDlnn2EVyZDz8O2QOP+aZ1UyEsB3PDtODcDhbXyF9FYQbaJ8UW4iERcaldKVfDgxgqZCP2tfHA/eFn78DpFCF16sICiseNwzMACqpasLHGcCkQcRHC5MM+xj0kgRQSXYR3mrhyiH3e7w6bwEK9XfCiyfqvjPlsAbMh1fxyZdw2TVSWghazFrLKGOmK+vyVvjLNlrfn7jrSOTO8WGsBFEq+rSCCHnqsn94tvHQJJTKUZbFNVCbS54pazD1VQXvSCXGOoQKcclrS89Nt3AZAlO/yn6/dI1MnuM8eo7eVMRrouHiESgV5f9jY+6Q0YW511aI+YCMrOeA+3zaL2XuVAGyUt7pfwnkPwAncbgSx87RskVx7u+jlGacpmRDDCFk0bmXi/56rohiEDsguO1VimbZDJqpKf+SKYknottMtR+TuJBkRKZgZ1WyatBM2vEF4kFRI9dcZvdmuEYRd0Mqg8/1FVynPgj5C41JnXDD/IfWuXkOiXJIyum6Y7EftlVkY17ezpcLl+kRHjFQyaXGxPVGEFmQ1JvWnqjSWHWiFCb9Yn/5Ra+SqeaFvLWin327Loj+DgeX3WKaO/AEnhPrkArl6wUwWDur0Cs1yw56HRqggjZB3O9ahe7sqbvYQJVzl5OaUjX9NBHW7GlQnDYMVkPD3XTjE9E3YOoVnTtG7uF/ZRSFTK11zKKsSLuEXJxYGCQEJu+40GV5wXBjLX2nhOssMhrdCy/iSpRiLVE9CSMauj+MtpELlpgwoJoXITAS7JHO/vwnpSeWmGHima0npbLEgDtXDeXLis+Mbco0X2SR3kmG4EgCz6gJHwMbD1cuBd7J8wsfcrYzF9YVCBXoD0HHUMMDO8AqKUZigRTT3dkLdY6LtIRzd+XTECwzPalpreFzeYQZnywx5llLNaBCrl4/bmIp+kCDTKe/prazhD+PoFQoRURpHQSMC1Lhxy82QjF7QUhplL03TJv94UKfi6FGd0NEAYg7GO7nIw7Jqfek4MxdMvV5qMkytWzDptj7+5FpBBBKVwV5evNhrScsTu2/BwKkHCcxv1CJz4HT1ckllQ7YdAt61ePwjvTy58LuhdOdQOvSA+uKuinPOU0/mI01CJCkG1CdXeTYtkm6NaLwBtsApI6hUiwp6lFTFXBlEW4hXkQn54jt6Cpa3gw1RofzOlVX+8KAclJqe36A1deaqE6FY6OtWGj5MtgRixHQ19f2iB7a46UhcON/O2F/mr7To5Gh/pW/meHJ2IeDmTagPDPvdp3CdyeQbmeHcJvXccK8Onsdw8hE/vS9/8OOyd7MmLIk8DtdDhtqbyNIvGIMI+31iccassFq7pIUC2dA8xcoV3EK8hzFeyMk0A39k1k1dciTvZrjOmnb4RCWk5qscbStFXaBL2rfl8otIUQNmeH7seQVAoYb90NF/DVgPm7SHPiV/9Fw2uYeeNopIXWfmBA/SnUysHPGS7IlM0JqsGq32PUkmG2LJ5WE9Un3Zlu/sRV724YUbY1zDVrAecMYQkTzxYlmLGWMu5yawvpWnr0GUXsF9PzYCESzI0pPLQwJaybCBTLCHAUiTOF+nT28VZnC95gmCY6a2SGwRpT5aD2RrAmpH43AmSB5Q4aR9CwSTDame0BF5kfHg0wDU4OVSWqFUnCSiY+ckl6tiznhkvAoLsGym29AUUO5Yz70OJrYZ7fFLQ//SIZkQIcfOXgb3n7m+BJetyPNJdBnD9Gik8rwhPJrhLFV2AMyppCriudouRczoOB0DqNCXtf7EtlOwsx4UIeqJO5f1uf8dZ22PuKMsMa0tWhYOVs9EpvpTrH1IkGhlcKZY3XvHyMPKzQ+Xp25rRoSFjnRYh8xLKTv0B7dnd/xQpdpbxg7LmevsSgXr9/Vyak8AvIZDR39o9lolTWFVIeiVbJ+52VrnNn/wYGeud/70uOdd4yDztJ5golSk0THVoFFDVmGro1senIxWJrNUIk0lYnxRLn4k34CJBKaVC0fJnmBcJn/eMGeAtWySrWbZD4Lq/w6Wr1R7lYwq2sgS7bYi48aVkamym/xMRkuw7yvrD4UbBnbOuVRZBmqqa0SeGLucifun+qw/zxKxu5xa3+Z779lt8F1B3Q1xA9nVsUpJVfDFZQfei2z6P5b9oUshxRYNpZkiiXJ6WSYKjpVDWb3z/wp6DJUZkfL12QrxRPy65Zv71dKFa0Y1wrBumjv8kVogImzUkujzHcVtLcPJz68sOAHxFJsQuiD7boA6Havab9w9UQmosXZTbwdKQd2279A2xDnmt/OvO8cxW5smoQtEhK8fiwntXHoUHN84nfULi4OWNgpHGjT9X6mXxWsLpE7eL3KsmhbQbi11wilgT0rHO84YU/EMnEgf0SeYzPethVKdXCUJY4AZrBdhWfVAJj+TbRLzROcKQ85rNLjRnfwKXblftkbQ5jg2655aC0j8IJ+L7Z6JN0WEAGOZnCmzws9qh37COxTSagtoY77GBFXfJ7RC7tmCbZ6HdSSWkeMlmMIKnEOdLAk7WK33Xt6tQxE0IbdnlbNpVHoigldOfaktZin+f/e8lR12MjBqcCAe3nKduUS9w9D/SvM7VZ4Mm/xYEgh1SNIgdM+kkKWdKL08gv5p+gKxhlVR3Iy/GNDbgwVEwG3IVcmr8jb9+/V6ts54V+HT1EPP0CXm+19hW8RkMtj8gRg7fofYqkR6cG/gkiiUmahl1NMEjPwRCQiA4FZzRM9Sm5qNXYUW1Z460FRT8es5z/EFfSulS8cmokiSuKD0MGHbEMl+fTaRK3qW98ajhiJdJHk9DCM7xVQ2P5zrZ7fQ9r1aTQ3Xzvl7tsULkbYarq9hBwpGywM6nfKO3DN34uM/aZ+G1wQ8oKnwxdAV9heZKAJazgahpWsBj+C/ripX9XLRUQrPiUtT9sP5XZ3kWfd7dFwCoBk73qIe8BEBhWln+sTXrIyLQB43esusQin3bGuMY09HHy9Lle/uzPRTMnz1mM5TOkRCLQSRRJyRn77PBQ0xY+EDmsqlBy8LaZcV0L9R6tJOQEdGARKKZ9jjMzTZLO/f2w/srr+lNIYP6gYUK6NIJ6Y1RUaJWUlqr7KLrDDksE/wS1w/Lq8l63gccwFeqYtPs9DarXyuniMzdQCUlwWsfSLRYacqXEg9afDFRzU27v+IEZtEnbUtCSxT4w4KunZanfJi4MQwJl8wyRVmDnWjoB37AKVc6OpOJbFWN/FbJsPsWOjVSEAKQKGgV+p7gv96YNNVSUQ6723wTpU08nbpR5jo7sv5vytEPmWFr3SAXEhQ6/2IYsajXWS/Vsm+5GIk+qjCctkKDFT+pJRMG/jQxQA9HuUyZc1Em3Fmrmj87CVIr8K74ECS9wt7HsIXNpgl3eEUR7m2flwOmw9/961/OJOhio0PgAuHSP57H6gvLQZ/6blTnN4NZ6a2noDhjl986J0DgEGzpx5+53dtNWX8rJIGuLPlXHA/FO6RsuvcBxZgsONky4EpyLAZEjNneiU9Zsjyo/nJ5tQ8eC33t488S2StI1qN+Sxs/tTgco5OkOUwUrdxoyuZm7dYskiL6wGL5dqz8q25JBDxqpiZFyYB7O6kFA4v2xRfjuLBapmcp53wOaeo86EtbnFLQf5mv6y4NmS2+PMpz+2l3gGimCpM3g33DHqyyhcHqIj3DGmobw1RIG41oy0IQi6eEwtIT72lhe6RCdmzWcG/cwgwGDAs/9/UjKJ2q3g8pISCH2ohWwuCMPVRARxyoBDrs5Ae9dnlXwWMRjnBtPBOBtpfi9feU3cHVnxMoctFq+c+X6helPikIveffxaXQL0n8xHRVUb6IBt5bQ0E6TuX+MTr9HR2Tfp34U0z1plDQYrMvFHYvo/uhuJvO6TnjOXgJ8Rvyx02JuFqJROd4ccHNRAj9B3oyjpmCb6hM6EkviBvIYLh9tSuPVeWp1ICBqF1RMxJJYzsOhUqDDCKxd/DBu99CRZF7zvgYwAY+e81HEyGAsSbAaHbSYUf456HJjOG9ZUa4qJCf4bpgylY/lIg0gXW144ftjx8Im8ExaUlN1j8taKEWcec0hxD4pW8+OswiKdGKIszAIcmQFjFZKwQPUUzo9ecP6Tjs+lUrCYE/Nzmw4rUbrEQe4ZbGTW4oPUkQlZ6uUs/UxMBZcJAb5ktRtm7USDc6u5i1dcM2hbFmqOuz+uBnKmO8Vh2rwQViU23h5gwBcubcT79iVDfeouvtWAnELCP/bPe6rPPHyFjtETisxcNJL4NJw2Mp2aRX7Fs3tDcw28Usst8sg4sE1cPOU7iqsgR9MLn2eAGRRc3bHheQNrfXi76ggisftXvem+QUDrfYHpBkckhhDUseK/02/WD542HXlrw/AEzmZWuz6NuzqXfWJiMXguL8499a1gA/LTSAzklhCwLe43E1CkqfQE0zDq8U7UuVb8+u89EqB0Wh1Uk1rzh9S6bBvIWhv0/ExuQ0V7h66nBdKIuFo7dr3Yu8huCqavTliI93Y75+ZPxLCZJnmCpgCxNuYWmT7bJZ5h6SNEIdMqzlKo4/tAAYa9MqznK1fumXD95C3G0G0jHEy5k4nTH9cNNHyOUC9jljAVnuCZv+MXaxh6zOHtP1UGEcnUp3QbQRCydw+53PN0nTy3mzGwTn1j8tKAqJ39DkaiOGf2WDL69h2DB16n77ZOUJOmGioO2aouLYE4jluE7U69Yn0+TOB8vshvSmTkxqvCsZEsX9rN/bawhq2LnkzRTlCq5nkV7l3N/NDwedpw5Ig6DSm/D+r03ak9XHKHxSI6hsdj7loXitgrxLFoJqmN0XPPtRKQOiEnWRP80IVEAcz3tRiQ8RglARfpPBYQu+1jGoobqpEi9lB17+pjQgtys+haKTMxClApvY9bb93Ar9BanqTpx6L+xAxxAy6WsLgudTy1cqa2DGcdEha8t/gSu+5/KM5chPmgsDXXhtBRZ0jhejTOxH2qOTbg9niTOh2dTo3IxgUDWEMtkxqiD/J+C3maXVR9TMWl8acNp8smVWXNxC/Y2NZowvWD/B6VKnitrUt47Bi5d0GmjaPnfg/oFyNIeIRdbGz1E4ZV01he9sSGCW30TJzN6Dmv/kH+9Ex938z4fEol8Ih++fbBdbn85iwLlGzHee3OPyKUPMzn6tvNvAXN47JA/Ajqm7ZnR+mXetRGCifUpLjNCQTm9IMigbmyysS3yOA43WFH4Og8p+ePUEGEnz4xMqgsaiPq/VbbQZk3cjx+ud28BGwdpsGS9vsIDuQXG29PCvZYGxpvE9dK/42RunwmRXIf4osJWs99y60Kaz1C3QACwo7VFC9Hco3mSi4sggaUoKrxVJekBTmtSeL7+qInaDL2V5KzbN8L673LJNKFu5sHNMmXDygOqLlWEh6gJwv2btezWYbrssTBA0tYVYJ8/HCYUMQ1FESZNTbtA6FEOf6fZDcl7dFCT1fYyNv7tLC/k+r+1nkeN5xpoJl7uZhLmWStgYEu6cRFI1MLStFra3UFd04HbmljnnVRXnarLumJBNNdydyP9VvLzD0OHkJpH599om7nUcAxIA+iS+t/DazOUZhKNJYdpWXe1W4DZ7JAmfdr98Agrm9BUtVsqS2mD10hkL7FI0ES99Szsg8WN3fBV71zAKc1WBGhChWZM92cGOwtwRinbPF/ea2oTR1ri5IFGDWhHOpR2B/IcQb/wHeNLHudRFmE5dh8wukapRkwQnitTkU4LMk0MOuQaWgnErkpnujaJCVg/7EiE9EQq3YR5Jc4NrJE4JzK3sFPTOw8Ra8nWm2c9sorY3993AHSTi/K68HzwHBEIeoZOMGEitE51fUUthQLy4LJrVGIwfFPk92VlSipTOAcsiqXLHqO41449c4woxA74FHbWJmG74AWO/PiZATwxRxeP0o2+sdLF1RGNPQyQ7XERHexcNuG88bD3wyfMY4FEVs7OIHMgLFdzSDUi2o62a2c2nQmkLnBVFpMpGQUlJaOzBOQUj/cRYi3n3bQTpfuozQupGwj4WFkQ2F+8pDny/PHF4bb4pVlxzBuDUBsSYW0I6x3yGESyEjSWd9rDpsCYh40II44qvM4Xxf2hzQQKflsn7iDadm+/uRF0SRbcZmDoShewjmSEQmHx+U7HJtaGUfpLiR8mUERBUe6MzNF6I/fbtmAVfhpKII6fw7GLoVvbD7GmqZsX7K+a02EeE3sBGcIGEDuAsJR1awP3Xt6BqOuDBUONfE35gTk+a6NMW0ASL3rWh+iZ8o734OjZ61xG0v3abU6oU8tge55Eb4JXrCuNfu/MZD0Y3zpIdV5mydi9j6AS9O2ivmzS2GQEw2aKWEdtpXt7NjyxTW3141sNZxH0hvD/LcPTS5cA+Ap9m1+S2zY5JGZzj8A9G2BxDeDO0a9EGuGBUCD45NIdYk7mJvY+lnhEaAm3hytp2I+1HsQApRQODBqZhnlEZvrnEPvjv1EEJdUgatC9UDYD62tOIQERNDCp6HftOZFyEhtjqktLwgeKwcERoiqrxMel/EnJpttT038vq8gpzYFGsAl0ODZdxcrSbSwTIU9BodoQakIxSyzhJ7AoSJTCAWMz4GGoQgATf/elpCLvuLix9E+W9j7CVfbXmBQmWgHCHMrR2q1Jsbj2hR/DXj2y3hDdsjFzUu3PFq3uwb0zbfP1B774cNb4jmpwTESic4ZpKW2wsQR+haH09Ecfij0emznvjZwh+/3m7bHRV96ywEzumMlwMO+22Om/+iwqLipyw6yiNMxW+pbp6IH5aLy6KwvgxUps4ARbjYcF9IabK4MR2TL9blVKSL+GSIa13htZKI9E9gqnx7XH5iRZvL4/2yDq6Wyj665LvGz+w+gysjPaqEfH5mtDKWFoQsxhdXNPxhcQoS3OCjs6dZ/YSsp+IWX95sIKRQDJj1myHJb0QuGfLam2959HwQtQklhqxSY7Hfw743fGf2o7qGCZK4SzZ8IMkQAtFtCJX9D4ESxGhnOM0JIH7u4z9LcJZqgQdJ9XVLp8yjBansVS7sJ4nYj/OgeFfOqoGhcyxz//0Rvq8C68JugKZJU7p4eiwtT2Vo7vGbY4JBzskchq8E1I6oJFvyXAu1X59ZTBxCJw5FmujUqXyZJxwf50k7MRMT9JhhhFd9vda3NO3LOrz9yIR/kgUN+U3TFtmxrDIb4iSKPSq9TKafLnatTrCdGRuzEhLhBhK8lKBBdbBWGKRN3JOZd/kj44PVUZ3CfRduPgG02levqZPR1EUGBbt2yEFbQTs2LkyWx5QCMYc0pSWDrmfGpt6n7BJSjrf8+1lO00d5qjc2i0RG352ymkYx2DFLnWJJ9s99qdROAV/IsTxRE2FmZlgXYEvGDnhTmTbadNW8rD8BTkP7wwFHvh82J8RjO+NM2Z/vOonfj3fADcN0D8N9D6cmuKp/QBUh/usctmb1EVmjvlQrkm6Wk65Ye+WYvo3By/Vq7EtiV8dgnhJdLDXiOkNXi6AtvK/N22mIzo+TAplTcVRkw2YPDuD+7KVZWcN6yrHAS81eh7ByAY7iJCCbr10KWWsa6upGZi43iuJqo7xcIMBB/sIgqRHDdg5uBPDh/6nm1B6hWPOtPvWKtfny/RDpygaSAvGKLu7/tersGg/b1gndUBVJeGDuuC6amEddte7JgANLnEq4MZuVI+cWos0qWpaGyE2Th5cXRKAiGcR4u97PhH1Wsqk7ndFzIxXaL4hKPtKFWfjG8zaIlQ7BJivw8CstoUH4ik/ySC7CSRvQ7wrdw471usX850XBo7rgm/i6Vfzm2J7p0YJFpOGITcP/kjh2JJPAfmI/GIXPtMTQg3+9dNPX+z5YXgHxj4BsUpfm8LBF9dERWjuCS533OaOy4d9YokURIPJppVOv4J7HWZmNQ2TWV6nD5lZeKBkPYvpoAbVeiprjXa9kNdP/XSdR46gLADSWQ69+IFGpK1DVOyWC5helaD6Re6S2SFrImXLMOtsjVEOQSLTUZzr4/SyiN4B1T7bhhywXjMVf9LPit9zZ6OBn91MRFIlFAkCMXtrD++NXKo86bVWdax6zfrcI9g+b4+BysQV3rnuZZRpRY8JR5Em6jOfojrWIlYdjPrtlxLWJaVxo4dJrBfu5F+ZytM3xvuwgj1mqitiK0fAALOQh/7xb3Qlu3kaTO6B2e0Pv9ZiULmVF2yQXKV1ORDotzWMt0jaMK7WuhtrMvHJmDHeOaJDaCfZOS7kzlffzI+V74m4lt/wJWviZAMVW+w53IyOyhU0ybjX0t0fIu/LCKRZv5xcz7XEOaebiwD6q9F9mMyBxUjiKfJKYwzzgZhA6yhAfTv8LnZFxEpltr7bEHoNy67uORxZlWiH5NXvskzkABYcOS/97RT/f0HtPlHTIEefHTi9S7ioTVb398Bxx2YqPVOQpUNFtKgY1FxPrQk/Gl4asnDRC1DUo7/uwA51ei30WYpTnU0KXGWN/kIVT/g5stNPvLtvAjZdGEGZNCk1sonevbtaRs7HCOR5nAJqlxswKzrucSNWJpLHi5xe3dOSqa/avGaoAOIyQSKfMsiGYzzyPvban3YYrWAIsfmMwn/kgcAOo8+dAcI+EGLJ1kAJcY6KWA7KzbPz6PYDKV6zlvMc3854ugnBqkcLzeurv8MvdrPDN+Z20IS5LAd1XMuOxwO0mrtWiBtohCGmGmkxNt7ZKL15tV6zQNTlD+mvPm5CB3omYP11VYpeGTy5qRAOoTSVnPhqyRjLjKlpwTLg8jrB44RGYFszPONyEft2KcCllD7nFZ8RTJoneLl6iIsDVsSXL7WPWCCdmmTdnU1fiu4tbD1tV1753So8D0teOllPt+VyEnJC31tPYCuLE9vrS2HVOv3V1+T27iwxUhjohHTidONWVJd27kKp4TtFxDZ0HXi8jhuBVkZtwdmMmVV8b7BS1HIeovr9Bi8IZNiC3htpvS3JMRBNbp2pNfMgfZiJ4Xa4g5ZEvenD3TlWflyZWAgqKNWCjBbEgjV6pEaTmsAdeuBSV2IbSq221pXlyQMGLvioqQncN4Dkl0KO7ATFqso+8DnMJt1OexeEVzLDoguNqSnVRunvkyBLVhICM28dquIdnGXKJI28uu9ci1RR4KzG8t6UmCv+BwPHRmsZOd7cgNkjRX7NN+3O7tEBZ+142BXyqTO/ouOpdq/4ddCRgllPG3Fwx4UyrhyksHb4nj6Kx/z5IY2Mea0QWanBw1lTS1DcrhyyX3Em+p7Y7LFjKIX0DApBISFr0f34/UVe+K3K86U2Coqhx10qScrEA6Me1/uPeEjjf/TIxgmlZVRUj2ELrNvBuv2/ChFhB5URkcgPFbDUQa9j5vcW/HbGSVfgbR3ZyPIISPJ/n0O+E2DjNhIsX6BrBSmQycxw3nlANL+x8VGPonpFhR/EycS/cOCMzwkuI4J17AgrUALPEbsJkcPuZ5xjkBqssDbsZ5QUcflbxVzqzXyhuKhc/BEneCg/wsCBJ6MxrRc+We4V3cjmCtb/yLxOjr79QLscX2ShzeGJf7oDZLfajrGAvhTLS5lsuU2AYHhvury7YGGxkTzcR/7jdaP/AF6KocR240Rrbe2POtGhY5kFouVAmuerQ8cdw4HhHazgAMXzuVavPquArNDHv8JQqHcuBrmixPneI7zcjspzlKYqq6rKVsnV+JUXYvksmLNZOU8rCTPgi1qNYxFE/6gLYf/NAqZZo9dhFz4AUY5TPSyV5KQOsz5X8bciOIZMurU+lvuct8IiSEt0hnunN6lnL30k8aFLygMaMAH/CD0uAAKmQBeY73KivT8ZRArJYcyHbJz+DV5rECXFCk9/W39dWTlV/EBzUpWDvxYNLBcxvIDFJk1yCCztFB00/7hM48CrhopBkUU0bUfpAdULibqE+c1zFy35PTF7MzcCkxFkBsmyvQTrJqbWgF3UiABeYwV4HSEb+BUdIztKN5rKWS/ZH3meVfgHPfCx4SHqKxK6r3+lSPhPgZuMgEcFlCHS0BZusxn/YZ7hxhKnIaZcAm11EX84dz8mPCbXN7Hsy6FMUmCRoxu2etv7BpgH7ixum58JjtdiKUkPct8/TwslStN00QE7iQ9s0Y4bnNCmyfwcw3nEpLrgPPx6LgEi9A5KPBvL4t1GpjGYqL4Ng9AAvfrglwT93mM4IO//HXl0FmEMewglLkHP4eKm0NSc1J6ri6vPBLfxhVjvKIxjG8ivsv2aQUKTSN8VwJEzlT+CSGxrnzGqtzeINC9E8oRgV1sQ2FnR9hKCVoruLJjybvT3J1eYm/uJJ0aTKJcFdhYs88XGE0ixVPMrxpWSsFARCYJdlCOqzw6BOHE4vpWs/rD6GpeItQZfqXe9625L/QEuEVYxPCh/Fxry9dUvh8oKoct0dIAP0fghkSYI+/hJMyEjHtcUaPQWM6Tt9B3GmpywtFowTnmVTXqXXCnkO/6awYgBYd/mf4Z41uGASjOofzFjFpyoRXiXYKt/uNrQpemvz5fnUWY5hlWQFlLqe4EHYfG2ZznTi20cfJ7BfFCf5zgGsscS6qbazw694XMmZkp2PQmxBmcwx3OyuOtaK1mh803cRMNAdVBQs296DNO4ZEUSKWcP9AypA9OZJHqTsFeBbzniT0k6+QDJ+NqnU99RXu+FTYPNxhG2z/S7crC8wlDJBrFRJm1QEeRyutuxIkYKTepoI8OC8xBJygx3WpuC63Psc8pHONVWzPRD0Qafa7dH7JZ8eq4EqRseUM3qRdI6J8zeB5nfZlb82ioiq4kkPylKy5pMhH76O+o7d9VQdXz4Ui+y9t/9yfm1nRZIg2eZyPk5rn6C0iEhtTc9gyCeiYCDJgDQskb3PApEtHAOIygOYofpw5ijivg9tHGPiZLypka2KguxC1yOudIZkIAW87WjTsaQKEGXk90TQnhObisz6WMysC4zxSn02GDb32fAZ7G3K9+VMxibIUTtQU2GwAVM2PkzrlTxcTLj8pnp5BosM7kQGttInqPLejOFlH+cCRbMGfj0yb54eQZtypNo9UK4k+zL8JfqH5R0Mo4Q7r+4qvfdDVa+3RyDOYIAxKtvqek36oiTaUJYqOmptWE763jdSFFjXYiqfe59IXeU0RV7DJUBN3Dy5yqeseJfr/B/2wdKbktTcx6W5BVcVkuLz6hwVvSyJnpBOfoFiUoDqZ5xGOAuX66ndROF8gssz6HDtsQS7AWgsL3IJsRPQ+hGnQ+8U/V6OTisHgukRvoBXTrRE/rjoxAzfj/oi+UlYxJfH90cOrrl5vhgW/iyAoRQUkSmpA8MFe45LF31Kl+3Ly37Qc37U11J48QI2kPFVMUCLOftF8yt0jvHikWIRt457v+zEWD6xlKnzxoRXfYv8RVZvw83qBY8fe+cIROGRr7AVmuP2vpBd00HNSXsDHvDb7IeSnRa7Q3+93+vDQ0BbxGdJgR8Kmyq04/+ZgO6fy4fquafbtFJbfcWLQpu03Tqex70Jqap7CEZzOjsyNTLMORvH0DxYXQwvSr8sUQ5PIfTF2/CATfSDJGyaE17WXBmHjR/290AJcEwjGqoACCW/EtHX3BSZ5kVrJVIgZS7U/U0MktzP4qSdTZt3dC4b68sahlD6TmA1ihsdQfWBoFxfoMS2I4Lu/cyFxOH+9XQ9Hw9+aCtLgzkrCFWMIabXj6x1WmDDG/uMeBBgnefO4tNeJqMsLHOZ+j7oZN4wr8PXooEj1k8Q0IWH0wYr6wkPNJm0vmbFgc9Dx+MFJ60/gaYASGX0IRSJ6RfwbKqlxv0aWtmkrUdrhL/Phgycw8w4JYgcCYJGg0XDcn4VoIaqUk4E4EFZFdDfPCaz4Kw9gxsd85GqjYQ8OXE8hThWClThktB94wtl2zQXuB3+vqpFbpFmiH4qB0yu+FslYcPZXifd9WN5WleRVYfIxebpv8SSZ8qjrOfd3Qtx8tmbWuY6o3BJvWtxEtWy9NN0Hu/WIudNwpwO5bcZ7AiqlToR5PeLxN5tN5eAL9sUZSVTMVPdZggLA7PERv52DagvwD81NSCTAyA1cRP5CO3otiKwg5Md089DU4k2bUf75aQEKzjoWLpieI5XoOIBrADwTEYVaSbz2dIGiF5rpqMOz8aD0aZ9Pk1U9KzhORw/IDyumUKm+LjnbWLZX9Zw+d9ufXiNbB5z3gFWNeetXfoCzvNKa6uJ/cQk+DWwbCc00xhUcDTd3p1s3ySPjDXEcwyd9rQerltLS6KirjdKTnWiH4yqcB0u58NZ7TiwUBKeZscDNFMW8tRmewFPcIrV0/UTa0kToCxnu+vts9r7pp4faHUzEq26n2ZEPbvI2y58ywbykg5ahywtVG6N2BgRzp/wZZsU6YDmCmmdt+SvtCFYJHJcFCjNmmjRkda8CwTNUe+JZeWOptz8QNEdEn6ZqDP0MnBlEmyNe/B15T0k6VDLkjNAv3r/WnkjTSJghevL3IUJq7UMGjzFKx74ThA8uDZdLnmhs7MjBpdMWdnoJfjbcyAk+koq2jqn2b9gfNQ49UhcA1mWafbrRdcO9pN29DmR8L5SARhqfXMCvel/JM1ckzpWq+Pb/IXIhCjD/q4FJd7C8555w7NqPuDGFhzlnvXbGUZS1CS3ZysFPaILCZqeM3dvI0vPzg2aJc0B6bwsVr07NAi3HPTjucsZyxhxkirxmkXo2Bl14h/J7NoY6+o+KkJiA8hG6GzeDVbLxstff1Pq4LT+r+iSvhUesQNaJst9GocID9+8YhybSgk1BQOESvEowzou9vBqijE9q2sMonFX48hHozCWav5jAOkCruHyVzTwozRYoaX6s44ynJPxMG99VE3+Ws3tBDJbDy8kwKgzIqio0yIMU4TcwWittAF1BlLqRO9BqdPXHmLNvBV5U6d9EVOOEcJ3p7a/zRjsgtpkBB2dipY2NrpYp2KUDQcLnlqq0lsBj2ZkPTvsEiLgYG3YZTUehnnBAZ3uOY6yrVJmdSE91fu+PPay3LFkhmhXc7T9lLcC4Q8nwBxh9fbL0ReMOmBTdqlV2wALUvwTLlbglY1+Dj2iW2RoOOCqYlsCIfhl1X26p6eOTuS7oYao3Iwo31j8kjggGTZoc7IIVq2ZT2Gp7K1SHGw85JgMlXjZE53QcKXTJTC7iTEVyqKTEMq1uNl66xiwzj5Kc/lVFF0GiiB8cYNmptOe6uaabcPtP9cQ+VpVdXtDoC0LrelX2Q2Vk1ecazsUZhIsNCzT34PBLFZFZQvdeUR4Z99ngjlJCKJBiQpCU2KWBKxgurs5Y1vNftgp6b35XgW+Xt4H97EBoljGX8ETszVDT1h5f2djOajjfvR31kjV6lYbS6QWQRuNEBNAnwMVS31MBAs1mMm5+j7T59jc/ZdXllwt/aRS5WGcQWAFd3RirPqvnU7Iz6++ph7hrqmLxnF8QYJYhZjV2U7Wi587z3MUB4XUKBq1S5pwWWevj7vA2feGEMbDkBB7EVfAQ2rzvyC6FC32gGLspJeHQaxOcJVMFrhKQV5Sn/N4ByWLU3XeCpnqlRTO4scnMZ6cYLi1nH+21O+ZntAKzr3CvwPDxrmKP2VyNiJ4D6kL3LlNZQjrKKTF277sx1WNl/aYSE3NXhp37lyoDxOmMFoIpz98DDoIyqCWF8whULmE/GpgASLke9jCy2RS1jHvnAhdC/tpEKaCOD39uqKW/HrKY1ukGDlYNkXPDFNTPncl0Qw+tUlFHFs8B87G9NtEYZNbzAi1GP3enUBFIHQothXizAHLjet/Zi0jWC2xrg21aLpbmDdPoRwbrT+WYPNU66XgMiLQL6lU1Y/e7weVMev+5dWn1sqhNyihuHn3bp4Sgf4niXqoISGMldFjp/23om/EDh/B4+sVousIaCVb2WxiPlZdxd3Bis9Na56Q74XgWBSsRSV+XNlQhPEbeLkguglItsjqDvWdpmFmwTYIkOGvAkYW1yT89eCWl2BfHkbGCe0PAv8cWSfXW1ybYgXYoeF2Id+sueZclMHv77SDDIgiqmuw70yuCmm1Jcsq7XcTG5nAsiKKqUo16W+9mPIcl35FU6sejtJDPO4J1bg7rLgPNDH/CNPkpy8AkHkuYvtHiTUPS24BnkSxG1qciXamMpAsvZB+Kd+CjtmRGsbzdtGdNGD70jZT+UtTCge2KIbFZ6p1IO66YEAhyhZAop0wlIGLrBVD/AJ7saZksLdrfPOqgKxNsfBBxudK7R3ekN2W/jjRFziomoBE3U85mimmRsZ19kmZtiTqALO7XvekMIjAEbWUi71UJSblbuGcgDIjUzADCBcLrwtciooaOfJv+DF40U00QU9+pmEsRTiF9Qjp3H0lrDYTRcgUjeb/DWe9ZfdPwnji8brRHsfBT8giiTtgTV74WhMSVqy8co6ms1dcRnyZIeb3i//tBeJlixWtnQi0BlCcRsJXLNSAuKWA7WiuQy9l0bYKZOOoMEkqoyOxPBA4+swdKNZ83FfUFuYm1yt9AQfjbKM47DqkCk7or2d2t1G9OpnH6oxJ7mFKLT0rOVJ8boFMng9r2m5HXZayr46y9MJTI6JLSdOQB1Gi33GQ2UtEXgev8Tspf9suhvaKVPpWV59Rd2VopNMFaya1MhXCjhib82FVUuEeyGCGrY47o7BVkm9eMsGRKLSaTP5TQWpYUJ+GtFTvSInHHVPa+DWw1bXuUfdskrGhlPgk7lFtsV69FJlvCi8JLgz4KCwjtfZ7yCBDun4ojxU0JMFhA8GlqdBDXXDkS6borBOcBHtDuIqz57OkBXhIYcxgOwjThk51kW2xtf2WpSywQGWvSDdo9K9X8DOjJhWlBHmPIfqZUJlWiuK5DLmoIxGmRZb4I+OCqZzm+3Ck75kkvcrlV+YmtNiQL6s+AYy7NVEBv1At92Y+V/L87sHviRqFPNtWmjhDKnJByEEi/wHjGscOpVzzbkXWuiLhDnGff2yVunNm6+O4nEKOh9JCqU1G6NksAB/uSQTXJ4rxDiBj/g78OKP6EGW91Ji+8NUfGfYZiQN2HlV6byMVKUmvosRyKtgE+T6k4K5IaZ4XwCxazp+hAIh/SbmRcVM+9+1bVP7jfnC2TsPMhE3DJAagZhl+y5UQZ1upxEy7jQGsd2ixLIdMLzqNOwzlLMOkMWWs/puSC1cUmkY5TWw0eb3jIIxs7ONvQJYvKEhcSoAX4HGTv3RWnDj97EwDpeZo8/MWOuDxlnDzhtQ3ZCvIti61zisa2mse5DWP/7ccpUpiMq/CKz5vmgKxFuOTZrsA8aImMxnKyj44Qv/GyxtnorbqNyLck16mE1iQAlsEs63cc38BKNdnEF2K3SLuk3QXJwNJfbICFdmR04K5LztHWGiICXIyO8OFYSCC1cjTSU+qiIlfZIzucVn/0ZBWjwCFvQtEBTjQR2uyKiQSrbLXJMsMkXKi93JWRbWS+odiOAIW5ztBE0mGDMXEg9jFgCTCsk/kzLxaJ3D4TXULMg/+yufCPhGjVyadPl2VZKMkfTDJMhicp9iGJlGxLLvXj3DLvsdI7H0m0buV7QDFAWuULr01O3FkBajQR8593MFnrGkZ2bUQwsAgQzLTvXwOYn/yqn096QScrny5PlOYTxRvLXwEUXa2EYDInThs4HnhiFsajYErxF0UmlR1PqNg51WWAGKF+pRPnTaE/LoL/JQ1skULR1Dc7P3Q8/HuzGI1tmQJlKf1lTQkwQA7SQaautktjtHVWE3LSpaR6xHkUv93efYdir+At35eguHTOhEYG030WXqu4jqgpsSp2eD7ppKNsZK70mc7KEPB93JSflyZ4vlaW8Qi3k54+cb9LYujytTHJReosdFMTNJqler+0tJ1Na4F249nqB8ZcaBLJAV0jvtjlT3Sd12KSBekf9lyBjn5SslAv0TLS3vSEem3lyttHCGtiQGwA9AX0oIw+1rzSI3nhdsRYdh9HLKdTRFzQ8n2nnQOT9LiOiNSp5O63bQfv1X0StPHNyoWt8R+wczx88ZIdhvWzUSDjDGlF0m9JT0IUx2dwEDMqypGw7ndHLIuwcbCzY0iLvOxfa6kL0FZaYXE59yVTfsEgMBH9gas+2AYcduElB05gfEJcdjvw/dzf4PHkhlu1uU7VsLRIGW33HfrkAlcJARpSifiBUQjYq8VNW1gwKPm6mQJYZC1SkxqTd/KIKNHnBWObEB3cA0LShaVkloJLmZgM/DMK5GoAqqJ/lYKe6cQlW0zPc0RJAUc1wGk23ZyB8tAEIm2DE4jv+s1syu17dsf8WA3zMjGA9yvyxqj0MRvFtX/fIjcjqTekMmPTdXuIOXwxcQ+OV1Z2oq/UkQv6l6evpgWv0FK58uEpU8MSZCfpOQeYkbaPzTlC+MSRbvTDV0KR2T6Cb1lmLHEl3voTBUv9938v4YBiUT0qOItl4dnLTN78eXaJ52SIzMgpsAxCeDqdlq01nV1uQaZ3KkT9pZsbuXbggvkJbxaMqMySb4UtPBznF7CCaLjnU5JgDDl7W18k9cFmzzQlfFvDK+8d5hsaHgNLiRqb/yhsvVEoboNE3q1xoKMBw3j7BfEyIpom2rUIPeIwH5qzY1A+kUPQ4Pi0CvulIcaNWiAblSBC35/qtl7CUiABA6m7iraopcOeInW1gKzJLHAT+XIR4+cOyFz+LnJvNKrYr0jFulSrfEpSVCc5IA2gUsu/Kj5x9ifJxNCvbVOF6rqTzUAsM+GvtMv+Avrlbn9ZMoiJlQNy3c8Q2lcCX4vMHKl/P++lgbC34GoVoZU7P9alT0WsKafQnqvXMRp0ydZVO/kSCHH/YqDTmtTJWqzqTFdPcohUyMuuillN8Yb3GYHKUST3Adt4P/CtMY2q2yjC6rQc0GjLkYAs6ahBpJJN95vD+u/ajWR4iH/+PXSJlUUPAtxULPRN7VlfVzsaQHrkYvMXpf88zzWb9eg2eAaxd1o0BNg4b9lx+x3fUElNsTppNN7ertsC58Qc3axbayKm+bu0VbTiN2+OrzGXIAtfIoYNWcIF+p0kZBuRjCK6xwlQ0so0uG2QPmsKnQr1xi/Ho+kGwopDldxWyQTwt4M+qXsRB4XTNzV7nBegZbNMLNeYZB7/Tng7TvP7XVUkPTReppHdHnEX9oDF483QyAlh4pDoRUEzKKEB28XdR1PluRGrgRPIdIaRNmQIFTuSDMZTy9v02RX+vZ4LhD/JNi0+qOJI/xazDyRtF/bWNgGMK8p8Yn730l/2+kf8tZGXjdB0njFxaY56BW6CwGQ0y1zwGDKd05h/hRttTUcvdx78oYuPAVCzHLHVUBYk+Nmxikbfhnl7RTBf0d9Kw0Zzi12VdnQbdPHYl9a4GV01GJFfMhcUKa59sgNuo3lIiXuwGf92QxCT2MrBYp5AF2U9DYF4sX6kQJ3oxfbTFehMdHEwEmrQ0talN+YV7ycLggRmW8Uc4zNIhnkm40T7QiVbNqBDNLMrAdAoZRh/dytgZjDzaLhOcxGLsDpmikYOWrw4Zj/Nua74TuCJohMNrK46Q9sfCIJrlckHDLMziQpESKTiMDXS5yt2d7Ncw2aP1Dw5dG047YWF2qO9nWd768gb80DSd9HauCJUHh69L0eOuGatPqVGyC0gpqbvSxVdbGfgmmEb20M4CA34cTflp5S0m4SXqYCGERUMpi4BwvHpi0RnKijk+NaelxwnM/ttNaZsE9JCm2hV1XVENY2ndpxSHIuRhi3SAUlgUSgzEZvSaxILIDgGN8xe+F/aL4yu1P+X4OltgMUu1Ri361c/WimEdaf0ZFbGpZ9PnALua9jZAdrReA1HR6lU3Ip6iklGqWjFo0iKHgboYeq5bxxYSBT44LwSoydWZtO0EirlhfqABZCE7+jrVZX7nm1L4d51zDZCEMPIc8L8m8ja1UJ9sKAXZkTRkRFh8SWn33tufFB0tZiHhmsj/hkzSvG3vu6lwi6fUXrIAgpFyXjy9hmTrkQIUxaMdtMPsEqhFMvNF4AyETDhWYmLEVb9foXsDWAKyVQz0KHLnC4VppeyYJOKIo5HYyl+Z+YGqkbhNFTInuOvA+Jrg6l619CniKz4EDFZmF/gU+PxaeWgih0cj51YBOGDofc3YZAtIAOXGD5TKQvJtFEBilVYZbLOwF2t/eoJo1ixhB9sUYphjDTASHBQKlvnFWd8dndg137cBLQ1gYYlTUviexaje8B7F3+QHfj12VVWryP2TNBQxTmUM8EGARy0VEMs0Tk0BqrW1gdHoLIJ5dZnQN8C8Ichqf4eGUCNGwqRUWlALIUv1vRXbFszkaXhBAw1X+j5uKU+bG02xZM72YQOByLyBIkgtclI7+HZDKA9tLZTyp2hkZ/+QqMD43+l0VDNW2DmMsu43Lff75BYoSN+WpwEgFqYDp3ctXq1F3s6B6aSYrgmlqNAX0Cl2rdxOP2zFfox5TXGNW9B0UZgE56tqjrCE7fm5uf100u3e11jBfARj4wtnBO51Hw34pWV15F3O6VonuthGZ4gKem9cBPXDGuggEdnK9EhKmmf7mLJpU3pkX9GLmHpCLQdRkz+De4SjkQs5+zf+DFZz05n/K+360iHlGy67oViiUuXE2HmockOotL5Y/KCTgqkHnYcJR5Cmb58xjB0Ir8lOYs+vE5u+9ovtg+c+S0v4WvyvRpYHiF1MGsaGvqiQuHwyRuucrxbkQA3DjZgcOxOXZIzlZqhQuV48GwPOhcLv0T2XPUsYYfkCJECMAqFJ6yxrgBQAWK0DV0jqzvDUEhNJLRsXK84dvXr+bw/oFvaKHFtYDtPV/zvyWm3NyXflVC90RhNUqqCNDLHGFFtHlLSluWluwPh2REg5u6TvJX6Gq+AUZOnyvoiXHkIb2wRUxSj4AM7aSL8C8Wr4C5BnjIj3UsOyjjmtAjCY+Njd+zUH5wvrEIWxc57vpk82ShgRv2e9UNsc7MDyOqveeyAeqS4OVc6KZudBofRV7q6Ml4xwEo4ISfO4pvnWhE/b4fIV9riO48WvZn1RASXa0BP3BUlrCtZYy1UJN5D7b75JvNAEbqE7eRTAChW5hVc3BATRZc3Y/TzmbgQPVfd3XNJQ/s65yFNFygRwB4KvhbEEz8nqnygSGCD/nozJ9Asm33UryFotcYlD8Q95/uRY3wgIIkBruXiZceLg52v8smVSAXw7OYq/8uvLD24JdNzcM8u38TSMfz+7MI5lGA4gFQI10/mG1OIYsYFLB12RUeIeooyI0gK1aJ2fa2fg2c8+gkl/2wEcVhg4A7rKwZrWwSCHgROL3byYO35PG0lpUG8s2LNcsG5Yuneb1CUC9x/HlPagmdT9R8/17By3BtTAFb98D0LwQXqqsiViJRJReoWU9pREk94UJvNiJ7DYIZeGF9wfUmvkEhEB2vmBFkh93agtmksGywkrqlLi9SCfPgUhVC9kMouTI9oE7n037Ec3DMuUxbeyZrEew+zn+POLMIPgkU4m/hwBNmIhedgFwC4hIIf5GGbZrGb+9VwLCbcSjcxyBFpjiJO5ADy6ERSqp3OrxiNgG4frMQXBlVm6U6fGbIwiFSvQ+XRfCF3/rWJIF8scHmT8ZJg1cALftOUcPBa+nEp7nt4nu1goEULUz9KBZVy5VtDwIYQQ9DJ2gY/oM6lzjX7fW1xZWte1py1yEwGLSoE4h0oa5VKLzeCJu6gg9PAy+sw1jjiQuH5RaBC1ukXXq+RJEQ1idmD4AIqbAjUQbLnmgijOUh1d/LSa3ZJh2sPC8Hk7jNk+dAoNNJ3vAVl5hoMmBuOrOhYzZdCcaHiy4FGJa9QTaDDGe2k91HMPttSmvyxDhWao3v9iemkUiFQIYl3mtVzfaKJI6PW1Rzp8a8O7PeNCvgV4gQmMuQSe4Pbbv2/gxcB+sf7eNdYwmdrdvqRMXIoEzRYhZxn5Jg9fpEhQpdLNglpaplaSNpyeRMZfDluGK2hOrk+PAKHmVUgY1pBfJb145AR+HBslTMTYdpW0W4Dq7Bq4qE+0OYuhdQOCK534xn239Nljfk10j8PeFUixN3BQh7mqvv1uGo2mn5ryfKO6k4pg+tpUHW+oumoQ9Slakyiac85UYgOo8IpWlhZzEPwEufUvjruXTQtBZyZs6gVgltwHT3tfgnAfP8PuAc7oYK1K/zKdytpxEC3RcsN70itvFDDXdZ4+Z0qRqKvD1aMf8Ui7Y4MNahqdNXMmL078ky8o9aGPwoDAyzUDvzL2GZbZ0l4YS68iGTawsh74wAeMT2bntkAdM+05typEy/hB4dH5g97xH4sfJXwwb++z5hBUScnLsuCRZAf8Ps9oZcaiegmMLVAvtlO6GDFD9pJ8a57//2CQ5z8GJW6SrGI8B0zr93C+dCibcYIlc0TO9CdSyw9+jKDqwx60Aus0cmwAtUE5+6MoOX1penCVB49F/mAzIoKRC3KqkDJmK6877n6uaJ+FwtSNVi3PLpj/s6E8r1fyqNVjtJ8XKJX5FFIXrD1kUjnxlqws0ox5ktRE40x+c07ZuJ7W+cCyR1H4TPUtuoKVzlolaXSOMrFfDBWAVwXqlwuyTsrmrq4Wt1ZVQz28D6E1fQkjcFW53yb1IW/h7B9DgX0FJpd7m+LeY1U8cf39ySzsQqkgg9EMQFEFPvU8j3A1NFhtD7catdKMjbCT6I98WzdibXVkP2kWYhm88azEYlvytBKP4wpmkxLdfPyTQlh+afKV7QF63TYKG1WKpU8gNh0DGR8pvbDJtHrzxFo/F+y/ZoPDzwtYUaFTFM38ffSB9LnQTa3tcOjuZ81tk2C6JRbW4QIfX2HxkR6ojKVeTHVvTB4YRr7XUNOLQLqjyVrG57d9hkTr1NbCFhkV/jEmBBdw0xg/OtgaGnZK1eLD+Y61QVWUpSVfEbU3cqymIGKO33xy3kb8D86CJdblgF8e4p3Emxv9nboq3PezaNt3XCLxopYMg8uLUVRaPkbfqnMiLr5isfBE2NIHz8Y1BvfyGIY92rLJ75oscMUmh0N/R2mUXAe/1/F+nWMlWw5U30Gnzou96sZHJKJV/AINynahZ3+qqyqZ+2n22PwjUwaHaAQUMBsnemxNeI4T698Zed/asT7eIrFoISkZZD06XW7IVkiKDFtWMymb+8D4tlxZ+8vWG/01AvgFLOw3lza+g5V0oZHZOw7uQXP4X1aiP/NzDzAuIDZ9z/9PtDj0V9RgCkxOBkBUX4PVFt9e+PypCu8ePkDWcHQ7b1BkFKS1AL+mZ1ORtSfP9/zkDnWacIBGYCzoYalSfSLIxkeRnYZ3sadIF1H8NW4E0ldMIPEFUs2Jq6Z+N+yyzZm/0PTz0uXMGa/ofAo/isV/4hfW4RIDL5eO7ZzhdmyJ8Tv1VeyIhXNLOvQsjXCNM3BReVgM7kn6NazUCWwNusfbFk0sMrfeTsjOA+LaxjpaKjj8KXJqTElqB/8SkNP8FF5cX4Ks11wQbJwzD68iSYPblZ3afl2O1LyziUyQRGTUsLrUhRxFsO0zhtGt3d7SipGzNjtH/Z6fYjGzdj06Y6IWGLK3dS03lEr7AVp4Cxvc/D4Ya1scHp5cIG8XN2/rZ9ebAI4iDs9+3D5mt60FdHE8dWmgmmcMgzQyRyEyJ5K3z69fFm6/OWkDDsPoajKZM5ybp2Kx55rwYxDvM1y1AzYzXE+Xe8/D0ZFOAmvDU7fFr04tev+lYH4esaUDWP4GdkLHtoZ5kNV1n9sgKr6EPOMEhgYuuCX2d21iCLPC8/5FKvXtsEMRSXiaXTOD7TycIJ5TUDdl4CmfjUlHdE6LQM/oh8D+RWu+qK2gZuU0mrBIziAISuWtNWM1cppDsHx/t13nh9+XUbLOAGl9tX8ICja7+lVOSdNoYi8LTKnTMVtyjDgeIXafWPuordk0HM9jNGMx80GxQBxIZ6IX0lHuzdYXjJNHsAABA0qgrjo8Ha1uox7fqy8q/8825zg8oO332nMuWiiqEHDrpK7eqLqF3UiUERvIzxwQMzztIubjL+MsdDhtsjvr5v8GoiTLeZOp1JbrgCRCICrhGkanjMfy57WYPp42OZ0RxWVNajbSiKt/4bVqDg1xsl9enqvRVKLJk57Phx7TqnU91IJv6GOrfWYgCeKA4QMI2UUW4psCeAn3Lw+ECe70426JUBuA15VWSp3eIoF7Cgd1nCyPPHMcJehB/35FKDaQ70Y6frDqP3qjvPUGz15UVPuVbl9yjbBB5Y4G8TtOOdiZMkEQZ1wBb3RV6/Vze1pg3+SyMZgCgusbjXwurL/kSZ+0G+mzdbPSRnEax1gQj9TcoO/9UL2SB99nzQyM1+Ck5Ft63x5+OcIQCZSsM+4kKi5EXrhsIPBgIf2vlTxQvzNa5yxY/2UwjuQLiQSZyO5qkkqIBEvV9thq3t0gRbHCuiItIH1bFo3VUxXQeB2e6XIZc7MYVxTQic3tiKi+MhwpcqUDx/3N3Nsgl4FSGCZQNqTXTHnkFe1hz3dOghgTxAtb3GnaMjrQA3x99CwUp3u2lxlYXTB5oxhZePhxoy0yOrMtvqtcCczhi+lr2RZfmaZaMuE/vZ0bg76PceAM+icZzSkMELBvjXA3f9Yu6ilHPE8sUYim4amTPmJoXZYLLepKQ5rk96Wg6nDQ7wFD1n55hatfM3P8eB46J+Kk938A/4GMtHCOOHXoud7WMzeDX9o9qY35dhKBBu9uUv5YFBieaVGxLRiExE3dF7EH8cAZYlbMgB3Z1OlfickJiXOYowYSFV4uD0FQx7kDf9d52GLzih1B83hJIS+NF7GXWJCZsVazokdi+js6MHM/9tVgOKQWkFRq1EIrbZXz4MRcPKGgr2N3EttM5BlaFAfVfyDnUbroDIk1O8divftwCL08J//CnrsI7eeN040lyfETa1c3BB9skoBpw83WgWzwotQFtHcc2vAY7dp2P9GErkL3/q6zSRCCBKmIx1dYoAIinaNnK3ezSAt4bmJTdUqPi9OOTgZxngCGeGZhYWHGTWOiYkTWb2ZGDyCf2Oev/BHnWFlZH3fxydC6HpFSFY44QSiUNr3J49wP+JJ0RaHcyAWmEZm1yIAs8cU4si43xWl114ybnQjElpvRiFepLn2c28rPbYAUHogRwNCyy8chfPEDTk6R9GnTraKmVn0YucxsREe5Kuzg0MOb3yvI61KJcxUbq+OTmaxB6gkeIq5VqU0oV/AwCkaAb1N60fWlsOGEZVa/SSrGp/boSHb1VAzqyUzCHrlh74LYMiJiNQtWXup1WqJAG422PNe3iB8u9CfL/5aKAlIMHOu9NsmJMlaHHuAEXkYeKZY0Fm2k9voG4sJ0j2NId5TTCBYhlSA7zcNtCDb5Iakpx8Ds/8lR+tdC8arl+FAH6H1yNxhqDHoAsI7W46lGBNgoFLy7TkdsQ4oeCHzKzEzrFyKmRu9+tv2X0acef2mCAPobQWtNefe8pYWVl1Mkz3ZWwsLmhwx2knoexLs2YnKyJBu+JuLi1IHZUslnr3m4dFooSeGFxghPsuAjQOjVmD4bUF8E1yDzsaUtoMX/8ru2LNF4VRMesJGIwJHaXEhN44wOUNi2ZofYTsvZAt7MkNUiTxcJdHqg2ZXq++S00VcqbVRp5aVzht2CTiu8GZuGlWIfYTUaHAg9Ouo4MU4K7nairz45ylEJGAduEgTdfly1+hzmHZGGigoITJiEVgsdHtzswLoNNAqXubUi9y1tHdcxA5T8UCVAvfSly9d613FJl+bUTfrLAp3Y2P0+l+tyae8Uy5ckAR7oLVqk8Ac0bPQd93EsKWlDPk3zKacv88FAJ54WhxkEijLe9l3+i1nIpic0zcNqFRxraSQST7YvVluoK7nmnw7lgZdIDtir51Mr6lVFUPRpM+0LQGwFMyi237eSmHNXLdvvhGTg2DF88uJ0rRcKfN53rhQ6+bZB5TbSW9a6swV57rzJbbX3MkJHyHjbnT6YyhUXDZXVvhhY8qdZxGJ2CV1ttErnG3qhSFB8usOhPbGEjrZy9J83V9OPgeOSqRircTkW7DzWJbIV4FFitI2lMfu60m7MPu2ZmD17oFSRvOeYYtV1HOJ/A1kkpZ445+X7Wb/4eaJlouute4TBDhq8YUyY1fFQnhdj24UxHI/ZMB9BLY041xU0itisLkQ2NuAF+iRBNNZ1Sr8pSnxZziXvh8C5OZsFnOg4KqLoZ0WZSMIVwHitXkTEETy46oaORh7EM8F8F5A5eht4nMLgv01hMOqkMHtKEuy9MBBhsFP0ZN2cpMw7oMHv8AH5QtlDd3rfDNfQSdd/Q4G2ZSyv70yRejjzqbGcA8RvON9SX1wjVpuAEW3LBLnlj+7JOYNxmsEIxgbXpYgb/sYqgwPbkL40uaWXtLndqkCp2ppIx8XRjjWRWdX5t9esnPom5UO3wIE5UpMHF1y1qb0csRzieJyQethxMnHYiVj4ymfIzoTUxDkjwr9wHEhad0/5egOgatUF4zFKbd7j0vb8GiBwfrHZKI8xMsRaR8mvoVMeKlzDL/x0p/vm1UNZqB1G2aFh/2LPQxfQHxE2f0XpQaYvIDWesE3PKDKgjZRvMZyxjDzAJGoN7iUMcogtaqGvzE+kztN0NgIQcUxXJbj8E1u9rrofqKrlHl78Dvd97jtK3CugEtn8PQLm9qpmbF/5xJXs1CKhyxnuXzdGmIlK8B/jv0Z+6hBbkq+Ow4+W5XR2C91RsTku/bVlzNWThceGnDgUQBkw7aibe+0nuPtLi9Z+8A+LWFIPg1XAfw4dVFmBm7UhkGe4VhFmrMMncsJJx81NqIAhKx8ZMHwzCkpZmvURjCDNPK1mFy4BnLntvPyqvmg8Yad9gk/i+FmryZeXSVBAGsnjUT6ODm0LqBLocg0yjLKRF1se/h1BIo6iL79Y+JKeGGWeWdjrVM/0ClHGiBGJ8SePKFsNBHCI7fNbpeekMQU6PwebILmE8moLTKVuf8toR0zHzWMHiNmUlt5vnoI0cJgTa+Q3tU6NN5fTnwKgifylf7POlYEVeLj3p0PFk0GyK6YB6pGH3IMG1SYd3ejeo/I06DyCj2YJ91HCGPC6LXD7QAYvWzlks07SHk49Hqn9hS+DRSR8uvGsXouTzU8Lx7K8kQ5lsDJkpm5bInI2ly8+sxfXPSGMUThxYAvQMOhdaO/sw69hFD44s2NGmV6G9ylMluHqgGSvohFLXj9tUdUtVRctvjjfcNpcB/72qyegbIHvhY1hyCXSTp9z2tjq9c9kc7hkazJi8xCmovr3Azf+N5sGIrX+k16QFMawM9RUDE5VfoHugIA7o/6Wjot/CuxVRaF9n1gwLmadVjFQpcL5vUdB8dwWey/Z2MtAwZzrIqzAb0/Lqdt1MrHuk8+xXOMA6S2zWC69jtD/JgnUKuAWXJ5aWe5+jzqGSa5PdthE+rdps2B7iKhdAwQSuiv9e+3omQHuQ11eCsjRg+cN4GRHBLtU9Yprhlynh8R4Z8IJpg+JkSH/snp66OQVuAGHdAmEzJr6Sx38er+8IdTEQe02EeZnp7dqC6ET5XycZFKP55zcnV3VGIMgNDPtKgi/a0j9gCLcvt1Ga6EqmTSZIJU1VZMI/syupkw6JscQRBVHqB81wKpDpVFXcQBvpPh139sojbTlsZFvx63ZTGR3zqQIvpSSeA94DrCDRzgkaOxI2L1sVliooNCw+CfPgavdZiKSlBffAnJ2++vkOj5EGLdWMgU43GAu61VboTVeb2rWQD7nDGOnDntFNFVt35Z+nlWdpLah6tYSlMXe9Hy8hU/CmiLrsPlai7kU96WcTrGUn5yKPi/Oi/QU/4Zo0MJmMP0+nAiHHMqzV/FsSEv1KDHWj9ePjCuU9kD8BJdP5YJAb/H3S5XF4hAVB2tRhWoCyk5fai58O+yveEkuI5ac5EnlUuGpsIDoUIoOhZEWCkkx6Fxx7xlY2UuSap4HZnJ7DuMa0EkXJMeMSejKkTuj+8HStLDu9YnXSQoGLYnR27jQBaStkuaYUSA1quanIRVg7BwHaewROAQOZMupkNmNBTBsqLG6cU+hGT65hRQtndnjQnZUXhsQUfzVxSNeuwLgb1FBP17+HQKtORgaPR43iKmRUiIXiTDkpcsS4W/e+1a479aa1NDVozgKRI3FnXs61iqc26ggxRQZtS4rwcZ7J2Gaq0oN6iUa/9xQ1UFKU0kusASrvMWHiQSpbmAd7VSOuhu+1EbmxDjCE+353jeiGKIGdKFQOYnVVR3xoGcY9CAGXUudbeL84pu80au/tg5LN1Elvun6MCNez43x3VLneRIT7iU1LP0xrC55F8O4dYp52VvhoS60GK3rtFcUzdBpMfPZkHRasakBSUw5SfYK9uMFpRE5ouhVI39aFcXl7K2mMsJVopFDtRpX/58gcx5xDjkzfM91NFG644cdCWVNoRod03QhM76cer2YhWPnPoalkG6Ao5aOurDvpscT56uwPXhfIPMj8BsP3lewfTRQ91ER0axK5Cvbc6l6/WHDyo8muRyez3uJUi1kaGzLzLchBT23zg/Di39yVbvIwl7F8nN4e+5i5YaHFzZnS0lEhBHmpxsWYH3EyyibPhTZZbquXdvTIt2k2IxVaHZCJawU+mO60/4pwF20GA3IXrvg2tlP0aSEp3qtCy4YwU5ST9IfNYKJDXUtiyAyvhJenDURD+/FuyHZX5UHt7jZiWXvcDonLFOlfmYpn0ASo0XVl7OP9ZHt63DpJ/dSO9Tma9hOBLj+rgM5+uH4o+zd/SZ+Yd/RxPDfLX0p18r1g+dGBx9TNAgtIZSsuUPCeqh5PxtN6lF9DJhJDfhy6xgBxuT4WieRishq1MnKSg17iu+jOQu9Pn75bbCzG+jmaf+vC62uEWzOKCZWG0w63vFBVhtawKBK5EEb2b1W0T9UNmMw/ZOyIzjdfMpIXtW//OoW6mCSzThBG6z4NfAf2MKATQH9B4GFlagX5PNGrtQZ7BsoVLHFMKO50Wc5Mi5AoV33nTxEE9sO1awKRQpfLraaIn+PodWRmR3a1iM28pcTu+slK02C6wqt9S9kWcl6VQKUBkFYSoqFXq7m/tjnnsHsjK0IhQIszSbzmUYIQnrM4MviDkdAOxYFDtzdEtwKbO99Wki2ZMbwG0aNV62v98ppgLgdU+yJBH27VxGp+XhrvR6nUtsaM4mfcAT/iue/HHma3l7PF8n74iDkWlV4flTlVx6oGKhaVC91DTOIpIOLPz3GXi2SPfx9aRv0bRsY3AzC+pDPKoGDHPBnVA0fEq2htouQbs8D5chJzF2H0BiLwtNYg9C6J0q2fJTZcv1sIK3LaQ8DGE6s6gBiFcFAtsp4Au9UzZWNDME+yV1D4KJvuVOQUckoPa5Itc2X2cfQTqgcD1ou7zvrpp1IDbPWVmnh4Vl6vjvF3ltxHujiyNHJ7gjd/0Mgos10+avqA9EAZ5lkw27/aSJT3D8BjKSUyalb3HXNPA/dtaKhxVjAXYG9ucnHNBak7SLUx08iAzFDKhjV6dRSZFnfh8dEh9B7m6QqeCrNHfL8HDEMBIEPC++F2owczm9uBmIaqVno2IkBLMKOuBzWrUwWOZhiMwhRxgo3qubdKtCQQQbh3m7BBF4lkwtJp4vHG3N6QFYOKsPD5qxvroMYuY3Fyf6v+x4/dMGXrlAG+8+fWspPqYoArLc/Y5B9XPGiPlVnNGoozqIwsz8VtMRIL41XtB9V43HzLYISddiYogFezJMOvaWXPzkYB2Epp0Pk8azlkWy3MCq4rjviOWdJBMbcmaIUqxTljq+5uLkK+TtBYGgQLf6df9dJq+UZsb0m2PJfvRqrgnEXbcFzJnvJBkF+LDaboUK2nf+sF2Aw8NzJp2tgNoJ8SgBmyGyAR8WWdRYykD1ifFisAntZe+3BVxS7zMsVk9JQ+/h0/Anwva1ufd+/gUjHeoLG7dwcWxKR468WVsN5dsiQcw+xsXboVFSOHqUC61J1TUWT9MbTx9Ve/NWxKW5Q1nbjlv5kUZmYDa52vAndue8zwIjhyPvs/BfTZkGr5dQOHNogi+sdQgNVFv4t7hOJNWaWKuJEvbhFOKiBuw+fEGYHZV028V29tPJxOcbSO6kc6MX42Gzx6iFkrcF7Vjs2azYujSk1kft/Eyl41nBlAGtW3NDIOzi+DCQZUHE0ARh7UeiPoBBRmJ32brOsx3FgEz+Z57DukkLZAWrbVTjRMmS8JvhejLDJISvdPBQIvSCobnK4/8YJDNfYBfhutzxwuMqFekSL2tjp9xGfcyUKmQeIAKF31X4CUfzkCFP3gE2t/AGtO4gpqUv3+IjZrQOjfTMsWRwANYOhYGt+6hcm6Hh1xs7tsvrhy+pISilbEZa96UlSlj+OOUpfs9uAAPbNroZy/TbC6B2Dgwl6fVBD7QF/uM0dG4tkqB/HdKJrgwYv6tL0PliThj4khOtCJE5aPRZs1o8mtIAeR0abgw8yDhIYoOFwUUq+91TTvtVCJJfjGK9wk4Jkb96WbTQksSR29wUZpYEsQ0bmVOfihQpHOZ8C84LT5bkBGKp8JBEgmqAhlyegrNFJijVLFkoIlldKnTvUGuVxZY8fS27IC1+7RqsihZGaBrM7/UMxrP/xzfqIWHHBsnwcm5i/wPl7NtFAIrAk0fm4GF619rQGyW66XpdEfYxPsXpo54Dk715yTk6DmmcO5iSoKC/Eqble7RmR3kDmdKF5b/xYmSg/iPAPasC7GC0WUHVjAxIj4VTxb3Rp1PqwmrSjtaaq1CQkbKlQdXR0YbPmjw5MyAt6yEJvX+EV2+r9+qo5F2SeXH5gC9E82gfuwwJWPPTrDnLswKSHVF+I7d5kT4/1mghVKbieNFBQZUyznH5wEH4S+Mb6rmldk5xj4eCHw/TrrLpm2pivJ6BOFIX2d5khygmzzdW9Plivh5INkdYi2i1vQaLT7p58lPrnCDh9JddAP+dCWYartnUlHuLNlrdo2X1YCeXIjFl7T+yWH3T7l2mYMrh81vSb2JNniIitZS0XJEGPMQUWSp6ns+4qZc/7dBJ2ktAn0CghztwzgwKb5NE9jsmZUke7DwEtzXh6yjXliRFJ2puxOdGx56AGk/G3vuGLl6TH/gWBdIL5RF/pezbLqfQCo9GxqEtAQ8/BT6AMgtE7Rj9hE/h038bDBOWxcdRekh8V0/dqp2VjhaSDf/WfO6GomKr/tnyyzfF8yQILL32e1t+9Og5UYdI/kFVOjGrTYMpBV8c281k8mpptFL66Gt0FZ90V9Oyh5O7j3LY1J4ICKCXNOqpaPZUKn+RQSga7vsNi4yCAXeKiWHP4PWu9T/xCCg9ziAMe4PPzdIGFHgX7DzUOqHKeY1AhD67ziakM8Fz9HDpiX8E9thi4JTPN/vVtIC+4YXsRZtA6sRazjd5l7NlX033JIMqXJzw/V4xVh5z4Z0JErRtsCniRJ2tnRZdc5uVLd5zIdpCRvyvplWpuXLf/dJ/9d3xRs4zUEDzCvY5QrhHfGZ+KfZLtNSRRu3cHsLpqP0cki1eQ27tt9ouXirTWcQDceJe5vrptpyPu8Afq63lksjfP7A9gxYP5TUeOoe7MxmAl56+yJ5HM0/fpvQmUneo49WJHGEmGJHnfhRL8lc8R7t7AVQm5erBIcxhRibsbvFAvt9erfI9yW3EUh0n/cvU9oAID4jx0E3NKSBpfsbj5wkopKh1dXj8BodfF0J//bjFKwth1SN62ZxrFmwkuSv3bI99WCov7vdfesd6Deam+4UBt/evx1ptZV8C31linSaD/YLD3X6f655FsufOSEXUJ1av7VSYyiSQywn/7UMJGMAlIcxZn4tycD9XDfdW/Rmk+hOFTUGwRtrtGqu+HVdeL2MMORAfn1zIwWrj08LuTwwaPPayKZRCQ3O6LvdQgwZBUPKj760qeTe5ur8Xwyhf2BSi42Intu7edffdD6441BVPHhYYK6xFR9D5mS04U/G8vXBmaeCvxcmR8TAoHyxrvlVHwamUNaXmm3ki4/wlukcditQX8Am0ewTcU4dTIYZdtkJp7PpTVB9r+WdfnZuPIKa1ff/GdrftLQUMjUOrRkKR5RNDCcIXDajFSk8IbEumU8bjIImxvkb7v/fcmP0/cTI4ujizQVRkI+r/DGzHrdNhX8nGkK62MPav3+LHLu+ra4UOi9rkm1Gg++pDzW9ILelUDJYZX1p863K1Tpz+RxKS1zwqIsG8q6dpGaEZvmjtsyABjTfayDoodp1LoBivl7NnR4b+V4sZEx7E7/yNGRUq8P5XPD24++EezAxhDvfe/imgdeCrlo51LQ4gzsTLwrbgAYSPH4QTueXWqv5HZ3d15Aidz6tLU0HNWvDkEEDq5gdni6015ED6nBy5rCZT3k7w3tqDdCuzEAR+J2233wsg8yhKSL2mYK5JQZ8kgNgnDTPCKWMiGGJ4OBMHaMW8qlJg91WMxF3hXVs7eXYTIkx2TspNn2SoBwypdoUTaJh0GRSopQxJ30xbwLhi4IMfpnsC8SV24cD3f3YJn2ksP+HXufmDE+GfBJXPPhKehi7rZmHR0lI35XkdaI1rrJGC6eLIStjSiw8JO74DPZORTPIp+BuQirmlObe4P7cbxYooEHGszFwFs6rGr1rZkDp8mlzK8G8Vq0JlG7p3wYeb8NYpIW4o5lWYv/TjJH4pwMELsZrIxqaeOzfJUzwAjXwRNfnqVDKv3VtSJ9pxdPYlxDeXUkWzby49ByX5llwG45CZY4rABY6mpMb3xQ4H4wb1pQf9ChWZuGGXUXey2m+6kqszibGxPsgFWCE7bDDeclbIMssbu4NjltIofkxMBLKCoLp33gXKddtjHDZ2AgsDz4x6jsGwcPgnwXYKamF2OockEyl1unEceOWGGxznuOO0xkXU/xO1FDmjHTgeAHs55iuY1eIkr6IBEQQZAvgDTyR8g9P+CPp8mesyMBc9GAvwHcaa0P4GJGkoKUvgHOYsiCG7BdpSjj4jXSjFzwXcshmQ8FpIZTuwA6WFcgAfzFvse4MdbXUnBuRdLkrpqdRcOHRNSa3bVs3cyeyKEZsfPfOYEuwwJlMigM7CM2MPpmZPMSBZGrLBKQkvKfuiwE7cVto8ernbBnQPK3xme68ZJojxNVTcFEi5lPgMSzrZvTQUV5wxG4IW6HoTLplGhEGqbz5GpZTFjj3rxyfZFpYtnHirXMtCRiTJ5sGuFtiucZD35vXhOAqMPOLTaQ//ZSK7sl0tSvNd6HqAiUOMMmNgfpFbB9tCV4MRRLpwjiqEWun5uCmwSaoVte5HBVrXfiNh/xGlBP/nJLrluVT4DhYyLzpK62vO+TBqPh1vfa0jgW/wlf/vnas9nin66BGHacpKmDNBAY+3PAC7ArY+FKcY8VLJY53ZT4BVaDsCfmvfCOWPtsl733soIk8pcixMlMJ4us7GnHIBUJHThTP37KCwJ1Q7Nuq3B1KImfSf7s+Bx3RiIARmfHO6uykdn0JP56XHXj4gTLB+L1DDxy4KV5ORcLZUhxMSoVJsztrqJlE1wtafn7P1ok6qqNqvUYLuXpTErnOj1XYj7DRLxLWrDt3Jp4xUawHBGdOQ6wAY4hIDvMqKPgx6qS49BrrU1J1a/tqcUic9ZsUEB9mDY7EDpF7nLwdDRgyWduW6A7FfW5IhIAUnRvmQ8xMAlC27ZxwPG4xCH5hd7ZnxrHIXdlNjSNUkKK3WAw7oguKM3PXHVXXfp0tXsCBl2fUN0g+7CFxmubKLieDtxTL/0gCsoKZ//ntVUG4oJ/bweDHcKesGpIxUzEHxSx3fv8VAADY4H7Nj06GozSSPaHKqDIdYLidX13rwSXfEd6PFtLC/dp/yIMFZCcKFmBh+YHrgw0Zl4IonvXbAC+5w247lbUOS+Wjd54ZAqHqQrRlwL3Ai7UNpz0Crkt0yCGokXH2jn8bN+Mf4G9iBk+FPHpfakD4J5JgTuitCHLNBCsG203grHC7mCvoSWOvFjKThvJtHuyarQRhrQhXZ8clbO5UFmWBxfniT9JmSyRUeNG8s8YK0/vxSPbc/UIL3w0PFBnFVZyrP+a7HaLJVlFgDd0EZawi4HPyKP8K4xhhrsAn+6bl2k6OOJIzbzXzWTbQmbcE5j9uhyyM2rhUu9kvNJC6VeK5V4e8rPWmQLRO4PXgzXjFpHXqZlm2Y2SrVHHJhrivjUcsidczMzpj8alJ5yo0Uk1ZkB1sa/ieihZipBjFlTHP0L981MAXxPZhcZR+5WzlqetkqOhHXOMHpUKxUd425cP4KaQkPPeyik7v5WC1U4NKrJth+j0mS1+1iDn8VYCSWdOdL18KNJBwvoXgz0AlMRNZ2GTxxHtL1bXMZ2sUCcHDgDrTL6y1Y6X9/yONGUMPhRoxymUIkR6Yesn8ZP2yOEBfnxeHguhThqK/+j20zlFT2/H1C4WaBoRfokjBELWtyMTYoY9w5n2jy6SzIX0cjhu7eWNIlbn5feaXe/AnwrAWN1LZGTztUnYBS8sU4bsuDzagzYMgXo0u7ncbE0XdKfxt99NyaoYL2f1DztaeEdF2Il+V+BZrLpXXlscwrHpMppQktfts2UpO8borUIEiv3S5ey0iIaxS2u9xuZdM+iukFta/u8Vl+4CaY1IJAXuf9BpPOZX22TrMdf52CYNvbMfbvVXM23JX/uJiSZKG69odpkg+lUTt8WyooU3zAoIsJijarSdFXM7OSB8tYIQsU4kgjmyWVH2hH5UVDgqOc/0l7PAtJrcf0Vw2Zjtfqm0pjMhorUqNLhZ8keSUd+XO16CpI+Cqyys651cMSUGTBbTPdMMbX8HrohvAJTYTD3Zh9Gif760VaDMpdKO6CYo4W7yT06r7BO98Otno03/mrFtdApUjQ2Ni9wfhoibuEVX0BNbxtclSQcy0lW6Qaw9D4khL+7RvIXkQKBgQyKcsva5+x6VqeYY/L0ZBP+110IN1iFOuSy9lts7fEvc0HbZhOc73P2Dc+AQiqv8+DCfY3EVkGryLLeQ4+/AcS9ZxitCmdUMVt/j1XgRkte6tIlLIGAZdfLGtre7MLW5onevZ10GxY9X+P8xwGB1/brZj/LQh1KkZlzrU9VJzs2PfA15wLckjYrZ0vMh8rCeBkOU6YwB9xB0ZBC6EoTPBvoF9lqRhwlZqEre3AIVfLdLG4UmgdZMLysxcZuwIXW4cN+kSfadWfo+mQRJSQrBBuTQWVOfCuFKWGR+pdVvOCUtJ9nbjAUn2jicEeWSKy3K41u7fQ09QUqKzqD4c7CW7MFLK8+kH5FFgm5pQEenhquiPluML27JyzaeytXbs3Ebbzqttxg3CML2ywt7laCZF4lzwsEn1/XQv96AIYLXMH6WSFc6rc1GzjOPqGuiZBUtpUCuI5Okwng1pM12ADMdqZqqOQ5oE86ZPX0keJSy9cKrTFXaKKjCFakVdBeSgPle4KfJUZ+d5USR1fVFWshR/tIycMariCxnPutbaxr+IlpXz7FDhDnPaMof8972ypnFX10ClAqwrYzxlbGu0ILy2xnNsmeQbBfM1yRBE1ScfXrmwoEajFsvMSNGFOcBMysQwb4CasWZuY2VhGn/1Co9VIenX+wGUIXGwyDUAr9iTnu9q4bONFGr3i3bc1YDyroNIZLlG0CKManU3SNx3cmHi4myMnqTGQLWT4jiZnoWJIKI88QRVUqAQuiShr5Od3a+1K4fg2t/V09BwLLtIKeAK5498wS4Ve1BGB7ovu4hTDR7Ef0CPHE2fxgD7LK9fIEUTFCw9DBqGEjahBotA10rWfsANzlw02YxibjW+OrEMa0Laqk1d63fSIpkKgmrVUmHCmN5lJm2aa6oqwqZZYqaOz6KG1VOJTxYvgQKgm6CaxcL2fJqcLk7VS9/ymBaB3aIAv8HtgG3CgEGUggQUv/uQZTq4UEteXaUeFpSU5e13OgEHW/4o+AOGDCUGP1E967aEDn4heYIho1Gb2OA29c9jUq8lUdrimry9FZCdNPrFMA1YXFWg2oWbrsVTwKXepw/a1cPcKxn6ZSimsAJXjf7TsDQPIC2tmBsFo/9huN/mCMig9HJllfuN00KVz+iWxves5NrQvYXr1QaVDj50zBagETUiV4Q/2sna24oktpc1hsuMMAJ73AWB7NIEJ36qr+/cc98RPuDUxsbyQGQ2a9L/NKVLpWQ9bId7Rm76YYNxDAkmEQnjtWerF1/nl+mr0Bm01FmJTZkQtYQNIJUEBC1Z6JSt8g/QZPzQ6O+zNUldGE/GSM8mwDe0w6zYWW9EttGLnNSxMKJXZWmvSz8o7qRBu8zUyRClK82vCmsdC3f4b2+SSuSwNQBkxMO6tnKcQNY02dct/HBwGYd3kZtzecuxNXs28t0Ezkm4t+5G7wywyQ7XHS95oF6bdfYHQFVgBp43uC/agLbpnuFDT97AZcwqtvuXgBqjoxJFyOlh0PtDdRm7Rr4eOjxhja606RaOFwoIj/4cz1s0QngvXb4NRta7LPki3H5DIt+VD7tEcCtDhd5Ctzi5ysbB3oDfVQNjNKbTc4l1WyMT9Mlwg9163iGitOKzjH9hhru9GCiVfDNyg+WF/Tee9ACrPKRKhOsiomOhp1AmV3yS9BepVpci86CgnuRybweodlcDdTNwU0ErVbOpix/XzSf125PEGU7PODKr4J9M/aR8OZp8HCWCVqxQwqCUbGIvi7OfspLkYw1SZTx0JUZIyjBwMzQrpvjAjoZHBjzAG8trIROnY7ilBm7HobbX7eUILLD24QTQ3QqSyTy8ao7MWsCpegnotVEy7I2SZtodibTqDUUSV+v4oROxAOj7Ng0C5xyK28BCFh0SuWmXXzz/fM1Wy3+Hc293c3byQq3t4y/jSNs26KuEYjABAYCUsEqU/N1ezF9McbZaHpcLI/PRC5CH4Mh0LGGGOevQu+1Xveaz2sAg9zsztQZEYt1E/AEt6GONDKOq+E0qVMz21xD9EK9zA8qKJYM026MaIWH/jsG5Vbhu1AchpUWEx2Vg8QwGyT5I47bZ8oIH02+GmwN/sSRRZ/11iuF74wrlTp/5jCypYEbMGiwNaFN+tBU4FWTAsMWOZ6sXEoa+7aNHebTePaAaduXWrlXLRy3vFvIhhuH0QYVV+SxepZN5zV3/g3U/855QKD8rwoXaU80RYzdbAUCfzCTXxctiWne8zWngVavmaZmvxxKvGDvZcfBOwPR9YFvE/7Dri8l3OLkPLAJZBcV4qSUffMqPDqz8/lBBKiXcV/tE0rLKuosw1V32dMWKE47ABElqhMRjt0J53xJupcP2g/mFQcodOqIwABSXyPQB1gDqYl2rPgfXouoWmVDEKIXYUx/ZHZACoIMcjlatTviVsc+2+sHHJPR/U4NM0T3rMTsJQsscqNA9lbYIEwVMF3K5pLeTx2z70W+XWvcrpq6gQto+toX5SCLX86015r3SVV669e9Cfzfe9/MGCEpC+qSddoihiQBfUeo1tBsm0zXThCMNGx2L2s9bwcJl8LIf7EryWp+3CRuBBurake6DOMDZ0SaNUU8V3oz+yYUsVNEbKNA/tmYDxVOX9zwpfy+1R+ncMxJVOVFuMAaEocl58B+G3hxolfN4ajKDz92a1Hxa+F1EkbniZceD9PsHrMvP6ET/D3PhIXMmu3h2rD46ISG0uznVI4wGGLGfhwJfa2uNmjPgwhNSvq1SX7MTDaezW2UvTZaCaky0sA4sMhaYB2/E3ECSasRlqDtgTQ8+NIUe1H5iO2SIZTRU3k4RLi1Mciao1Q1eLtBn79nhUmAWgnYjnv21e0j+AUwyj8qspsai6BaMO6jvWjWvnK7gdUlvKGu7rG5CNR83zSRY6RlRWRly08eJLg7aCYhI6lfjd1fk6XkBy3J2F07CImZRFsxqamlNOWPQvU/5wxX3JLfp9pxmPNzbR1s/yPxS1P7gg3qaA/wOovnx/BttstsKgFJapmALr+ZkJ+G66mcjC7adFVHI3NK1Yyk4zYItInkrVeIOYYu4cANdxHOAh+eWkxz9eAXxt1p35j9Hy/B1RAJ4R1otECwxJQW5lwUpnVzt+qjQUVIbtRIPiBzTHc87wW8Ko3+Kl9BVrNvkzHyNxqqF0ZA4ksw+7++1BBjuD0nM7pcAE5uygLzGaHLzm/W5uIXRn/Z8AWrBpTW+sAyEnV749BAG9zh8lCmbVMzr413QC+ER7LB4qZw/+GBThel4Hr1LFp6i86IAizzE8ntDXMTga2omUVmnmA5ERHtAIi1G0F9pNVbiCufFYRfCuDHx6A46tyxbx/3b4lXKc/JTNb/92Ov2n4oc9B3Cz/iasZpZ7Jn6f0Pp6EMc9Xy+qyrX0lvrBeLj+I5xnYmS0KVELUGoSMWHz7w2nvqUboTWfAgnNHmnOiowwQZG1f5JpcVk5TIiesSOt5irbzvW6ZzMTaLHbfpRnXgJA4WUf0r3Tj8lcLEGkY/HMDlFJF8tPh8iwU3OKyef2TtweXSeqeCKfmtKXhTRulEi9B0sux8VEBPrxIJrKtlFiXAAuP9EiFwtbymbPNdR5EtUiyOQvOAbh/HYxAyd7p3p+d6i3Fh4LfwoKE1820+sxLFdz12GalhIPhg1xm7LmWhYTatjnBgC5g9pgTqKIj3bQR6nuQf5veGG90mWrlu8A+bHKU4SssDlN0mSqXrmNwGU2K+qJdUvyqDXJuGrIJu0WjOd0lysXB1SdLQcXytSuQmDFZcVovyVidOWj/soCBssHiTH/ZUpR3FMjnShUK6f2mTjia51CO/xqqmNqXzM51bQSZy3uc36pBliP3S0QxLQaBMNgj3Vc7HQF1WePgeZmw6uNDSiijpzsqjDq8Cl/Eq035V6EZ3cxHbEv0T9mN0mjRfK5CLKMH8kUm4vh/mqGBaJ8pIQ1Qn+Ki3c4lQmgFx/dhiIs/l4ryMkzCDEWZk4GqGzzQ4ccF1TJi9u42Z5agiElOt62AkSqDkTTiUtZtVbwHU41RLQtP7rYsv7mJZLblUAd0lz/T1q0Nw2sC78Ej2Az47Ik1CKxPD8R6Ohi4tnKAH7ARQuz/83dxYJiwWbKaINgigSfTgaUi8XDznmjWwX0oFdMfcs7d5CszVZog4BQntwu8CP0xYW1Xcu4OqPcP/ffdbWdrtRyW2FaZ4nIqyfDIZZJzXDBuRZ8urUvFkX5B/ruIcAYB3MROthn1H6apdi9CtuByceQ30sn3ByyzuRImdyrad0knMvbTP3CoH/wWTjM5i/h5wzsKtPcOeKf2sYOEFeIZ9u8mO0OrSN/xmuY4U6OClCF3iVLP1l0dMFbtXxHq8FA6DztP47RsYsSyo8m4LvGukFusp7DV+SRv9BYgQSSxOW4ffYBlMcdiu1B90N8DkvSf9hUEErySoDyA5RM4hH8HtM/c8/UOiSveoh8ZC54fDuamOWTpRjTYwu/RUkg2AjYPbQa5HDiCXcp0zrhrBVjEL0ikBPbF35YgeaHJXvIgS7pEnswBxwEYv6g3NsuYebds0NqupNRARozihE0CzKaRMnyl/jTUMeOy4ETgKO1CrZfPFXUEnKX+TsH/4R/EWwHRoKJdM5eHiv4YWp04zHve4f8PgQecayDJeArMU89R4tNbo3rGUiD62O8JcHSiMBh2H2F2ta1R8ewLON2MCIOkiL4SjpZzXEvKpZWHeQciI7XW9azfRov/NNfrzZhOrM+vbi5XakFpUHEvIHT9I5SBpEkhaKA76K26toasase3sDQjhUYectAaJ4/WveTMoMf5/wY9rSXHYPHbR49YJY62mqB5EAd8lKs/1bDPdRym7bbqGdkfvM0Q+0ftBS3hB2c3l1n1pvgZiOAv9kjVuNfbIi/n093wBlg9QpOhk1hhlMp/bxqNIvoFP3WBxJoQ+SvTZT9MuTT5VgDxqpxcHTLSZ/4uz+XELy+cQEGo/r6XcV9D0k84ipCUI5PQUzBHWfN0tSXHawxMojxcZ4+LwOduuCdlqqHkwKhqJmEVHyj8Hs2JNaLYFA4JtsoMyG5VEkswbs2dRnvP7mEWN5rwSnzGJTQ7Cw8Ws5MHjqWHPGayq268DXVC/rhYbHkDQp8/t8+G3R9uTp0YvpTBjngnyOcZLsd9uslEStmQYsGAlVuJhjHe+grN6tZEgqFP634ySnX/ydcD3u69EimXlIZStO9R9aJvL/wnhb88ubwZF/NdeoB456bGF4xC2mFFjT29frfqckko3aoXl1Nuzg4ZkM08aP1xuNWSkNhXIihgZ/P8/L+onQsPSKj4KwfigLwJNP5tidD5DPO+dEgEJH8aE07nkhYrY2tTw6qJ824q8WMAVwqPGUs/0HJgiVLiItOvRxoAvJ8EJPoxODvjkQtGQGdvcqxOTPsbzYo05xJmMEcSIXzwSb7KYgm3Y7Rjj3Qh8KEiTkoQXBK25q7KpTInGiuXfdne97UhXu8HasV2kI/tW0EsQr2nSomUWCzWuktiKcFV4juRUVPUwhbYP5OWViTs1Zx3FY2KIpo/UhC7uHIMeB6IPmHkiMCn+Rr36CGyIXtgq8F/ONLTt47H+YhhaEfM2TCkEcsrzjNQT5zVvq/clga7r7uIsXraw8iemSrgLLYiuEW40HNnhaDJSjpnfaHM+oARwqrS2rOOmX1vu312h3bPsCdCHQszfY3Y5jGvUIAImp94Tmv8D+nigN2ikg3hr9P+fhzYpi6uHRiLRWUXIUFtvHpXn5yN6Nu75LMqHowO4Aq8d522LEoMWnjWH+8V8UMYOywkiEvJxxAVzSo0ORFVcJ2MJi4FZYUXD4fT/rOLh35UoBidgJXCgUbdg9oB1hluHfSiwhlDSUon936Ww7vFUcVE7syoMdmEInobRGqhOPgbE8oOOE+HXL/VvnfieiRw925Z9Vn/iwl/n+8BCdS9UoCMi1g0JTYE6EReNt7+92yQZ94dwzP+r/VptbB1g7XGhxNPBzdDAm8sYSHswUH61/V9jD+vnDUd5lNK878sDhy9k/c/MeoetvKxp+/5Uo+52HKEumsVE81ZZf786Hh7WoOLyXhuKNB+Bo3RPY9UZ7iJ4BiZGJxQZDhy/7+5ppdf4cMqBrUjnCsF9oAXmdsgKBsctC4YXDF5SU+AVNt4o0V//m1J27WTCgwxrV9b8cJYv89v3wZrdS0EjPQpFhaTeHkPCGh32lXPp9wW/Dhpgak8+8UanEBVHAvVindWgiOH5v4iksIEvEc4IF9H137nLhoe77PMmyHgIVWe/9dyXtwJTxczwAdnapmvlNsttOAN2NGegKynyCdMMMx5+/rAesrVreAI6iVpaeQd0NyucQcKY44X8JapzZiCLTWixWp6axfMPkZGyagccjgsmMkmKpD2vbDPCEYVrWiKyILjAmXLnnfeQIRZc0yW74ZS5XNgAnDakizoWOTNfkRlOneoj9g59bwu2KfPcdXsziT/tYHAX998xHv+WT7pxvbbOS0OmoD6W3V8RmgvBUWczoKr70DoEpnLxxeOD3vebsSYzt2rkXPurtclkbmnCsIotKCIRSmb0ATwkiu1svgQAIizQLbykOx6HI8kBSpRhkf8ZzdjarPf8vmrrrTMspyTGIC10Q5d1Ahw6CZvBjxqPnODkgF4l7lxxK2/qf59xgemBAQh9ow6deV8u39Vctuv4YBBQoDg/Elupz8lC+7DWs3i2YZYY5hJY4YnMIvKDiEODWRQgYWzM1DvydfG3vs8oyP2vHg6Cx8KU3K0OWOOxKR24xCqW4zNMDuf2yI7pwsqo0EW7lMghw9HQykW/mLPQzL5c58pvjwuQ2M4msK0GTnpGRG2yQ10Hy7CG0ShBv75V4X391a26XO5LDcboLQUNT7wHGSX5sErHd69rfmY9qYL4AJIoC926kE8RsTtBL9Yv0ux9TDSH8wIoApEy8gqSU6JKY4lKR1zkeYPn7H3o9t5fTAb5HIChjGAqTqoPDrF8A/MG2pfmb+xsEIfgwhUYm0qGFxdcUAWwJ8IgwK4eS/MhMrGUSf92VrqU3s5zb5iaRtiMpwXhLo2p/MybZhBB5FRk/riq1OHFO2qTaHNgkULEQt9HzEtqpuEy/Dy7XMbxnldVzTw22eDlbsam37/Slmk9HxFrfzHPwrgVLJcLrqVD+sEINGKB3vCPI5xPWBlSAsB9xBWEjBX2g43y0mLcJGlAADVQvvI3egmBJBeyi+qUPz4U85ujjRIJF5OshtOepcFNl+q7GRODGqC4Q49hJcF4p976EFrOjC1JRavWQdZrjE9EEjFVLYe3SW/gHYgy23NAFUx9Jr0ORTFb+oTzYZEbXUXXg/xL9Bv9u4QmwnQwad3u2u4viuoywFy3ZvNGhb+GqoEpox68PSwxux6Hta76GTivb7IW2AJkJaOwAv3IIWdW8GxLo2hWz6x/yC7xg/Z7P1FxrwklfbToOw/1qF4SUZ9Q4Dxnnk7hfU4isbWyQFq/WDEMCJ76Qh8UcqjpvSCCpFg/cr7A7dwYKpZCP30xc/6L/vJbi4g4Hy6TmUyzNKRxi7Q78ani6TnW4l8brefnlOm700lw9ZqquP9S5kr0R6MOrDmY97M4vQ9Up2+Rq4LKdB/o29g9r4/0fP5bzPhYEjFlSXO1tk1cHMkvPycaLfsVLQFbOiEQl3ju0TxMtNDglhAKzAQaKyppd6+MluZnf7Id/zNDJvZ0XRt5vlNhsbSSPLExHZUB7ae1EwGL56KxEuuPMpfQzDcz+LPLvjZVwwE+6gsulidK+vq6wAr/Tr4eK4lUaYWtL+7n7zNHOEzxjkF32i/eBlUlnOb08t3YH1aqv6jsV6B0hk79XsZTeoWwAonhG58SRcEffCPAzmzcq53VonmZEjevLmFezZwJ9RuxTMga4xzkZuWxZM6FXvKoNZ1+LzFbpZ/ZD2qgiitalUJ50wKtB3P/jfpCTrm5lazQ7V4T2VHJreSb6MUZ17M8DfLS/GxhAw+jQ0LpzCkF9tksCX6JrJN+qEDEJpqxbFOgm6Q1OgUiN/trJVGIbUBLPmHTHLzSUkhZ+Hzuroj4P3UVgxNkvzj2NHDPhC+hjVJ4++avestusvRZ0+QPT4usjsIen9Yw8gZE0/D1DubU7yAQAXcHe3WytCIzD36ONr/QmCuruVze+nGD9XZR1FDxwuobkA6JvzVNyMxVb2OE5f1Iux2I6vCG1oKIxNc0WwyAjGzLRZaIYVy4+7zuR6LIzKfvNSZbG4S7tIf0yio76iFMuKVbMAK5f/oTDsD22TPKtSAQjsFZz9W51ea+TUhnWFDWQpGVWZxSoiqsrG7jCAA1f4oM3FUKN0ThHZ0QRpFXJ3BEbNIu4gaHq/8/IOhS2bJIUOzYpRz6tCDIBGl241YwmqXc+st9cZEMqm9evNqMnnESeFXA/IV92wFz8fClJejXUgpB4ogFem94P9s5cEZhy+sVWbi5kuMvOxtfbtfw571FSrZYVDkr1ta4mMbEcQYWm5MaU21yOMCPMqk2tD1IoBa0r57LSkSwi8VinxzqLX+Zyd+bO3sutiCKjuLEnDdCiYOP+YfLsPhagdv0SL9+RV6euIJUUe2hXs2sL+sEgM/HG3TqH0NdmlqoeuHlNvJjULYreDJOgSnr077wnHYNpUC/okw0gE9uD4bUOnXn7qSjZjYDs8RVhjRSKXMLTqh2VDBq4zS44LcUOdD6t8R0ttYKWqH6ZkcKrjeO2fEZaIWHhNKYkNKe6TWi+3Hwtu/e3TVgJYQxImkQbF41DO+PkxnDyZ3135QYUlsZX3wQGRIwvKWs0PACO71Z7V6yED48PkFIPgcnVlm2khwjsPnSfmmt+3L35aBe2HNuAmccuB3xEbHN09BeOtSbw7HouyYllQxswOinoN8xFPaStkB9BM42U3qQtZZo5ETfZeyidlIlUIvAZqoLaIQ5JIJnhLcqrC/gcCgnTg9GNxUXX3tOgOT+pMVEi5EHUyK3z9hCdknTAIK4eSuN2515LrF8k7zUxdlKplMlXCXZxMXU2woGkpmPHgmhlG1ltiFWZsjfH9NjXhV7aGr2duofi/AAHwNYzvE66ERPfidQeNY5UkT6IgKW7908xE9IO1ptFuYoPUaT54Fu5CiCbN9trzcS2RAAu/vLMvVz/KUnyiu2WYNebvXrVwCrtKJMnbD3NWzrEQ697/YPPd1R6SDUqHwmpvWWQ4yGxfpY/iIWqY80nMkHwexsYJm4u14YJs3MM8vgSJDoM7sH2h2VOEx8OF5ib827nzhAjI8ZcTi0cJRVFb4Rr3tdH7DBZYDNk4pVYeqgesPOQ2TJoe8RY3dDrFikTjNHtU1tGKRVZG+Rf3Rc1x6c7BoJKdt59NJGnePM9oocyLpkLIllIOncF4TEApoqZXZuafM+rnBoX55fdaruYlfb1GGd8AN94/x6byktixUgj69PlrgG5zlPFRZ4KN1iWbcCRgZ0M8u2QWBbMvzuTzzScqUpk6Ys030a9wiIkdWy/i3bM47excweH3MyioL7yQo2wiWU006KiG27sC7TEff/4Rfjvz23nC28p4iQbK606Zdlc+ayYXR74V7yqWRQM+NrGwSfarDg/4di5klCkVbJOqgso5XU1q0gHTQLDk1eNTmkpreXfaWqWryJ9ZJOQYg2IIl/bVqJQxmQJhouprp5H9ZxfLD1RVYXUU59w58qG/dR5Td2v7dQvpwmtfwDYgLp4zwWLUXfw7XQHD61EGcfZNJUCh/Zc4LVUidXL9Uebkaq6Sa+qoPsldOcQI6th9l1i4UPqYgw0vUANAHwB9dYS+KP76JevFGBSsmD11115sanIIWh4bTe0Y+z0PDT4jrFO9QDTn8GUpMgxN4dy/3KptB9EgNeArlo1py0ZwuU1bJhD1jXz2LWk0p5OvuWENOPFyQACnhgXwuhOtc1GPS4k3AaUO2KlH34BDZaUvEHuuRubj5j2qdbEZXS8ByjHXkMdXv4jdYSnN7twUn22q3cwBSwR+Rf+hxLgc5E2q41Yoh5YPqUeE1zKDITcEdd5UtXNY9Thp91RNy1yPoFbivb7sk+31lXeLA29PCVd7xzksDDnZj0KwRdpCHsW1G0vPhCWkLjbLaGL4efvvfQao8y3sXtq/kqE7ccIL0TJeTKK7AijiInpCPSi/ZQ/wfkRVvA1AjkLOgsd5ShRiWXXF/jv5DxcxMZalpUwTWIKwn2QvtXcjRn0R7mMQlqpXVZkmgEF2isZ0S3QFgAIJzdKTf31tgygBxyOXghlfecNSNgw3HeepZg+CAq/fCJvQIFPJfrrZpwJ9x2TwqXm/JC81/DClwT74TDrZmM8PL8RIGtfZCEnW1CcSBzVWMsD8etbjsjn6Qb6IpnEOWDxBcUAB8TN7YaowHCcSzZDIkotXrQX/aKIG7+ySkagVfiOTySmr/mBJopLu+NhnCuXdUOIb2I34u7PSYst4LGJqEgpaxN1aWA7sahit5LCxW6U8NqZP+bQGHNcjHnAS7zqgIkoKtdm98GLjm4xiiyteFsYmnVY99oQ2B9vWMjNWGK+ERbshl0VQ+aZBc26yhb+RZQI9/F3ERyWPRqYmj3FJTyuIxAHzjL421rXI1B/qcaKIZv15p9r69J8dGeOq/6JOrDzjIHCUnl5GPx9h1HC1a2J8zbCe5fSLY60eRWNT35Vo/qgRATZF20+OSbV+C2dSAYIwUToDRg6rJ5Bqp9YcN0Rq2EkjaSI6iamb3E5gGPN13CW001lez5XVgv5VkVM3oxlruu8aJr6Zc1ztzS6j2PrJv009ThqcNAltTFgbyzh6Am6CdebgN3/nOsZvyta3zk7HyGk/WUlSzmsUujmFT32kjD0HhyJwd4gDcV5HMTd/dajbqUEpapAZzTF8NRmKtwLJSZyz9QOi7TZHCHmaCdevbjW6tx0bGT0MFpR5nlN1+0jFrjUlEH3ktdanWXBF+nwLUzi4+vnAb0AJkYEhlK4a07ZrTtU7cAkrK7k3tObm+xnYuqykEWqKRVpu3r5krrMW+4qjkyWodonjKnn2qgF0L8g420NRBmVLYBQKRUbdkep8nle5uIgQpdh93FV4OLS7suvYXCvr1QmaDfFCiaK8UR5IFntN6pLet8J9RO9F4RLbAzB9q4YFdjDjb01bE+J2SOMTEazmArx5siaY6qJKcYXRSTi0SIh5FLYAW4CDPp8fkjH4A2cGXQU+YKnCXjJ99T/IBYTUbAJjuwSdFZjX54gVoqSccJFAoeXC0Q3ilnnvl1iVAgQVgwt3VZ1QVzqZ71N1JIj5dwppHtd4AIju55h2zrrDhNp6XVsZ9aned1G7HzJ0cvosvWmSR7HO2kpZtch5nwMyjrAsGkJtgtXJPPrY9Mxb2AnDV9nPo8mzjp6fGV7ZzgbeJYpdXuMcjE2ZY7hW2kQzgDxU9qPRAuB7NG/vCJt5L6J5A6Xad0buum+h/fYmCzMozQiBXHqRdueOeUSInuRRoDkQn2W61fX6jbHyaoXcHSJAwDMkMtPphw4FM2t1iU+L5TrdKxV+aM7NfRmxMfKAwS6GqHq5zQn7c32dCp1peIY2T05cGrnHpu05rUVgCeN+suWtegyuZbfSZW6OMwsBPK9tnrhECYAFKY4jl5w50XhW3gIoUNp4OYv06757wJJZ7K9uHfXppBkLQX1mNBosq5IGxCB4DRLI3bMkziyE6pgIA649Q5h9Q1elvITEmUW5KFjAF0dMR2+NjSTlSA4Zum/QNO5jo5NIaI0AEQgmbiSWo8pi6o2efzTJdE1nePiqdQBS77P1rIvh3fTJj+L3jcOCAv22vunAfc92wFWFoi4ZUMbnHlO438sPoR0HsswXMV21z3JE8S3VrKSZdl550W44P5NBKCJYnw87kgW3Gu797yVYskONl3//JE/T9S3KqhF6ajMDslZ96hOWlMukTA3eVB12AuMTuNdEyJALX+7mrvrclAP1vmMOKkIp6quI2Cb2Om1QC3XDwpAdwDeLycxf2QVBCJfxkrLKWw3JRmOtGhNqf0JJFf0cTXgMdxri1f5rtzwn4Q2P81Iv9mgnLZR//jDc8PRfpXQcSff5v/MCevU9jBm70c09lWQetgqc6S9rY3OuQuP0PVuD9tBJcTOzYlIECT23CFmSGocrlLJRTbDPG99W+9BxxYpgkvY/sZvOMtrD14Z57CPBjqj6tCq9U1q9vzxnEcCUP8bpa7GzlDc2S4QYXPWhpNkoV5LR4IABuoOXN+qOEWjqrbFxyBGIUBRibxXU09XEW4ui+4FMEaqUBkA/GNTlPtmtW3ycBgY+X6ZlDCxzpPzDD7saZcCd0/D9h3AVXR4cIu/+xvzK8+OoI1QQfd6ap5+hifTlalzn/9Kwtr/sS5vCc9NeCHll6FrD8UsCsxiTBxPtC3iaS8L5Ajl6b9iDLSqFQtRTc218FU+ETHr/ypFZiTxo5Pj26B9RKRL+scARXKEgACy+K03TqjeVxnei/p/P8seK9emnICyPGTq9GJp0pXDU5sakzgJSSU941meS95OAROzAcaExpn12lep+P/Arn6qw1Yquq9sopdOrafnWknZNDRBmCPlKWDizRjvRH0Gm8IOClqosv0LNcDNbSMjZvqaZ0110U0neMn19ywk6vlqqzV7zk6OJ9md51sC1A0SA+b70TplQhgILySTJ5zpN3RnOHLhFefWuGf5LeUlKhZSsfyIOXlFMItbtVBRSB0o1+ISoY+FPwm0j9I8jwA9YCQvXamEMrRbKeuM0MSG89MAlOkcegGl3BNhEgp5h1lmwXQ4mEw0eYSUyLJY0z2KzXwaQmor1gmAdIcbAmQl+Z/NQLigKHzG6Okx8DvbLECw+5fnl5SuU8OrRwXZRXj+xOA4Jo2Xvr7eKF0hGHHFYZPgyOFoj0CSyADi6cjrBZvA0QECJMRJSGa5/DPNXfIEx2fwvmXh8sRFJxvJbo3MJODcNIPy6QyJzSHWizY27A0xEnuQnTCuDf9+Gl9GBu39mOgd/oQrkoP3raG2u9JP9eZ2J/AQbOCkj0Dsp+nfnZ5ZmUhFu+FzVGsNrpKoeH3MSpxMQvV8O+DnsP5HECg2ICYxXQLH3kHJf4aiCURJ6HzX3f1J1tfNtXM+RTnhgiOfHAp2sVLOcXQhQon9xZpX+Q+QKeyRNC9hXOCFqynkZzQZRXlzQAEzrewxaFTSAVj1rDJvTN5peb21zSfjZuOisauIRnhA/Yn/4D6kK0QoIgB6xVIwCJA0xyyOnaJuh75keZhKTA9T29ApD6o+abLvp5J7lnnf481MZNMfoPIRY9sVZm0NMmWiaKhXm1do4R8qM3tuWSFtPaNS4oL+sqLWuaHTnmq+SVcHQdIAC3BBXqxr7+/BAhxCT1pkXQaofGqK5VM9MT3e+IX00xrkbYGQka807fqX980t89mqJHo9TIVJgs7g+vRGLk0y/KtdDH2ygdVKwykuzgjD24Lgg2WQMfa+NO0R6NPFuCIG7v+Zw9CbJIPgoLfvvLjn9I4EVhGTUbuHtuiqee3mTLQYHM/Cedcw/7by1kfPL55yXv8PYwDSWRi/oepjZOFSWrFVGI9uvWvT3+NbPS33RCAZM9u6FQaeRWxCkejU/qXwrbIpiVi4r41hNw0CgCRC8Qe5AVhvPZPIlJvY2Ese3JnjFjRB+ArDP+ObFvvvg4SeWHcnp/8NbwhZbJ61ii7EMKcGnUQZI9fIziD5iPU/zRq2/EHeCFMKTWewv5G8TQtwdT1r8huGQxA9ivtJYrTC29ecAEouwK9Te4fK+v3rjcBlk+ruzx7NyDz7VETAmZeuDVG3Rp6KH2X6PnBd7auymDk3rZzgl+w0zoP7Z8pTTnk0VFsRafbZQAN5NwELm/mGFolWeBVGWsls+pwT4RmCkN15YN+fzy/7IQB+x9ONOJ5YJ4PI3hD0yvmRxQhhFZ+r91JTUQjG4dgcsNmYgJpz5GST+IWW2Gy9HlLeA3l7lG86iLyhMKx780acm/0+W1OHsLGqbtBghaNSebF7v9w4GxjlVg1AmF5dcP5jUI6bzryxnlhP7ttet7m63p/XbX2UwzqnWka+Sn/xyHRLH8Wiyi4juFVWgod6iWrsCb8Nv1rEuXsCehO9zKPF5cXaoqCm+gdgZhxK+iOVNcZWQEgWLyNjjBrA+JNuUrx/m/0IOj9h6KuVSO4MNIuep6uLNkR9yHy0azJbpKH4UAFsYQoxg8igJK+/A2yTbV8yadfmxqKoPeti6xziZYPzel1W8AdT4/ZP9R6PJdGqKVjEmT91vXsFHLvibdUbAYYpCWWgaD45tSS0L+KNj9wdwVCZsdKQT+wGGEg1yYVfVs+QBoFMCxPmZMHDGSZFL3ETFP38rWuAORQVzrksQFbPaeo2MwRs9FAaODP/Xzyhf5dgF8P5hPntxLX0k4vMLxe/fzyeZdNp6LUuyPmhbTiOquoynSH0SKVLZJNLGylEO4PMJojDG17CINA6ltGJ+QWr6KoOrzPxg6GAe9UQaFWBT+qbZ4rvxUw9ugbMu9DhwK0bVI0jiQtHI10/OTXfTwNn5FuS3Ur1dOGzZD3Sfp/O+Tz128nQPzvuBQ4RvU/oWcjf7WO2EtjolV3A+B6GtVtnchfEbpU2XhtGokjRKIEJbtOY9EnUG+O65kVdCkTcN6RQU7lYj3IRqKUv4+PyxDTKfMfGUHuskbU2uwnjjTmzCPsB5Vr9zJH3eFBmPaRfjJx8N24ljVHiyFD7pfWntxT3YzVenpz5+dS+wf8LbAjDU5CRPMe4jmNZNMKtlu7fLi9R/hSPslQJ8Cu9qQGQRlccvCYnRZjsLlZdejyj9ccsrjwxLLmyyertIv+tkGpWCk1PHC02rs0dFofyodV8OguW8vonxYqg1O3ZxNncGJnmsqtahz+cFQPTA6IDCpNrvcX/GlBAAD0AfdYHPXUqf22BNfk/Q+jpY41lAArI24Qam0v60ABcmM8H/dPMz1BN4o2Ojg4rx9CbTwYE0IzXQU3S/BH5b/zSsjYmm2YjWAKiNOkDRVw7MYf1i1C+AjfmqsQSX9hwbjimuj/uo2EF4YUMEv3+4t3SLWTwsBuOOUbxin2EHnC5MJiouh1y5a4qs3oDVjhesMm6fM9Vv3Xz/PtLBwG/x8+4bdijmrV1FXN6wm2uPh07NG/oIiK/dmBSy7g+eG7VKa5PKYNVI68XnWlrNPlRl3KfCd3Qf43q4ZGl+jMY8YWeYYZn+IOIkijklEtEcr2WP/GBCuVg0e00qM39GsIt/J92rxhJxLvgwx40E/NEYySQYhSHTmG7Y/EQ/QnWobW1yiplrUQmKeEgeAlV44FAYEFHiRDdupX0SGplzIxn3isAzIWPoa72PT9upNkmrgb9ana4dhJ5CZsK7cMPkYDLeGCLhte5uwaYggcHiHs4Fx74jLqeteN8LDVoIrK8eyFYqIfVn8STZuvKiuiao6aeCFR+vz6eu9y8M0reX9ViF09n7NmfyDEkyuTFsxDOrrZG9FeynXARxcXFbZFZFtTfE4ADOukQnKqvSbJeWmQbhUuDpVE2mbbxU64e3Wd3wZ/H59SPzWLB5RW0INZ7N2gO72qiHrghT3hThhi+MvYd1NkQ5NiSVbQhI6084ZP9EiCmFutj1Orad5A/DaYt0tqKI+nXRQqbZrrE2rOmwr9tHuTADydsWxGBEi9zA6MU1jQBIgueqd2SQhmbYgtbCBozrW67NC6xi2hNajupCMJOB0yFc1HCGlBG8MLBKbJ6X1l2l7Okq9C2XXvtcEKV6+ZWv+TQVYulWpEusaFzChjPaEoaDkRMrgt1WPRz+fH3kpuLqpnLqvWeqcEUfvLAlyvekI23mKPPxIJBjyJ0l+ABGKKpfXgSW1UjMsR63Mis0DUrab4QH9rrT/QmRB9tIZHtA8ENrvWHbwW7ArcjJMx+yPRjw69s58To9kE+uMseNLQNNC+V0ZT8JtggwQ1U1O/Rz8twfHs8i5PlZi8+L3fSVvn27siLHqq5DhAJPFP1NZ6KCwe5mV17MEQ6l0JlDHyL2n9MW64fVLKi02oVIoYPpa32Sw2UsgLxE6OloOBI40mU6ZmMYZJpGkL8oywBhWi1gWr3d+QIPIypBZNw7Dr8R8U597IHd4U85n/Pr7k00AVQEfUNYci1A+CWou0vZERCVjKV+CTC7Y151vX07/+8sTYfLR9tLONzF5qAqI+O4dWAetp09ccMEho0Aka3Xh4RqDyEaHCa16MvWBtDLk3cDqY1DwQ7sGAizIl6RM586HB8X+c7vJRRP+dZlWGJF9KMHbNVsu5Bqyt/cddCs6zhoBSYUc5QuwUcdmlkiwR50A7nZILwxJKOCVALS1XeDTyoM+IpKw72lBFs2pHJo0cwGSCfDBtu2QXRXKIpcSa9hnyWyZw1Oraso3li9xNqKWOLDEU4ECttdp8AHiSTYQNRAwYYbF1LyY8s4uVIMC2cKoNA8TY727osg/E88VRlJ9cpyhlOY/kOqQk/dxQ2Q0QHTcMXODMSu32nbXovnSc1aJGOzIbieutmO6a8j2JU/H2QfOM38Is7HT8P5gtW0hFWrPDJuGVjpc5z0zJaY47VNIrv7M3DT6ES9wC4frBue4BSI8I/Hdv6W/cSBw1rygzo+WTD/fguAHbiv0vPMxWYdVNnQPKs0E2YEoM0VzYhLUPYKLiIDLXEim0KNMb/ckibGkz0h1iR8CoLo51i50z3II5WUbEfgsQ4enEPItBBuWEdsL+8iQyKPf4jleQZDVadoBjUPHV1E4sRgYj5/nqxCUGZSXV8OR9N7BJcI5bsq4SlmKod3ljHLHcqmwWZBwwaUIPqWfrQt/hAeKv3IpVYWWusnPIQqNuqVbgCFrRGny1okCxDeoqKOQt67ciTe7XjogARGNEFyBsGokkKyuAn30yjZoZONmex2FtADOgb0Ib2g446S4nVX+ZW7lZ3Y8UBMkcnsQ/PO6PGsDr8KWktC2x5wVZSj4Roko5QooahJg/zFCHyf0c0y3n3l0k4bHokxbcx0E+a2URcw1PDX4DAWrnS6TFt59nKLjermZKkSL61G+rfOqX9Ui1CXq53RAjyQ7wyfS5EfQemPEAwto0U4mcVr48MpXmLI+ixsJOkyyx37zUjNStz/b0kioU64mFvlaMmoYdJN8PmEc86kEonAHphZs5LgRzu6/iUkbGgIr9N3NWLoRE9AOZa488CMEfzdFJjbi7QHziWspl98d7/cTwgUoN5yDMqI48kIJspFm1kwUCEDFChcT8HmipP2IW+pQAG49js/U0QjSk8TyUlMadFHmNQrvSPh+KQJZ7tBSfiRjFYGi6NJvbmi5tQTN5WA/GZ68Lk7sy/qynQz8tBVaWpy4FGF7mMPNwCd0qH0XbQwaMw5UqQILOKFqh1h20yZnC0eHD5YZ8mmw1FhDtCrYqYfiCK+9S88Wk+lVnhJZud3tmQ8u+ldjDUHHU+B11MX0QZNhhk0yte3hLyyK8T79GmxbeJdsV8N0XWwXGJEAGGgxuNtkurFh0N0va6K5xNsMdMeIM/7t7NgT+GTsLpvOi4X7pEylf7+Qfh4oPXZAlzVz1NWZ+CRZ52HW7lfKx1d0VIhUoWL2Zbe6ITxhtRBX5roiCPPZD1YsUyqZx4KbDIXGWub5bT/FLkznuRTP0qi0QEVZrjmiS8bm2PDq3CWrJzDHDyf/05zYoEAsRvqkpSGTPHjSdl2oRk4SA8zZky5MTvdV/jcEZI0Q0SRPCUvgHmHixLchjhyGNgiz81g174YUA2mcTqmTuC7sxxExuZ7IWSYPYk/Ql9ec6CFIA0iNYM95LAYxCZodOwZdKY227Dmin8Y5fd+RrRQGqcnvz7tZEZZecNFIup4i66RZKDZSs80RbrZZDHnzIoClQnt6uz9duMXWaN2rKzEElIIGE2wpYw6ISHvyYjbRgRRUH0Z99klNCmrtHDjQIsGEFwlqVsHknGKLd9CZca4sQoWXujk+WarZccH+Bm/l4v+EosCPOWsyfYM2m2ZVnQejsXtiP3zfWvze6VPiYq5iKsskrnJt7nu3z3IE7+zw+m2jvjnYaqgK5xw0te97CSO/cftmcaHtgWdjUJXE0Kqp7fvD9ZPJCCjAtP8b1YT01Uc4akQDWDWISYacRJ3sqcqjwDydo6q1vlUO6rTTe855vVkLgtZzIGMJ/Er26yu4rWf/Pl/49P/w3C+J+yzKK6ppz2Y9/0BwQNSATBaZHd+3X1g65esrVLpNLCU76pn/hDDyB7Wp80JjKOtw0nXbfcNzhHb7mtTwRQUswj9BUCGJ90kJSFRk2EKaJizi2uNEtAzyjBbTQKsXuosOZjWdHvBmEdLEEjRy5QALmxhEIOW5VCc6GFhH0kUuk/zm+OBGI6jBI8GensxsXN1+HjopzosEmVfr6O0QcrVy+hiskOZ3PyVlJwzetBEDhciMbi7Cu8kmZCr1gF6dTdLyoxx7G5gy3sDSNpgNqfeFZ6CzVjBcC4cMSf/DdxzNEsCCw5501MpQ9hoSdumPnREUkVwLOTxCue42nXpmbbdMROEeQKqb5VMHN0xh6H0At/uIiqpPACJR9qzNKr7yAa06Hjo+Dyb2+rPdqYU7l1eY7PRGQ/TzSQdpasdMsetjjSO0KM0AC/aanNgBDGtg3bINzZUPCMOjn3ActvLOKflqWPQE9GqBSHPb20tfjpKwsl7264wvL4MB6uLBgZrV25WnpAtpSzvWDYveRYk/RuE9EYmv3zEnbE2CvpvxEGCt+SsskGqeHECjW7f0GMGgVKwbqE4wnMX20yLX9lYuh8eRt4utyra/2EAOJSobClFGLhLvjVqB968bU8GO3Kzd4gYMBScLOZviDvlKsOf1l0xL2WTgqXSSTeMayvA6vus26kNv5pk2MF26ptENvBP1kq5bBu7FBuJiM/ED/suxJnkVVn0ww2E15T7L82FnJWZHVzQVAXo8e+WDnuKuzxZi4D4R7VIc4gjYwMlUiaj8VQrhxODbLKypcMWghGh5DWmAGIVZhifdomdXiunRMQdE07GKGXcvtRsjwuwt+/GCwuYep5saJpJFRj+UcGTT/VzV9Dy5xmjcv7W3bpcHYfg6ibipYchEzrmEbpNVYPNXlgKDoStvkGarO3xpjk1dX9+SUNE7IRnLBjb1mMmmYPeiZtfyHVqVyRiT82dp996OnRHmo7GAMQVw6wlVtNA74bez91fIyKOhjoOXc4v3TzrcQtpDHYOX46xFJmQT/a+PmyyD5qiEUGzL9Q++N25a7Jd/XHqH9Zb4jaSGWDmf0/dVr6zGTo0gIcua11mhage6RDJBmxZIjscao9VAmJjkukNRipanegIjpgmNrKaDIeBNUt59zOb1OiFibhGpt1yq95sgCY6qnfiEycNvoT6shpNJdMur2yCnXjrwgSi1mZ3sQGfCkO2RRETDqfgzgMP3TrDdjbifZ+ATrUOczhSpr8fij/xPL6tKdsOLKxwW9XYYYhhpbYsVKWDTP1SQAZkJ9TG+i+IwzUwNInUSJKpfXK0zDYKGVzbKPjdXj+zBGRwknX3E/WxnHlNa+dTj7Vkxm8OQ9rjcql2FiPWkhCz8vnkX6JjMpS6CFM33sBbLgUS8Yc2P8AV4ilMu/7ld0/xj7PNZMewO4n2C5d6Z13b2nv2fM7SRfHtIZ9PgS9uHCTGxSRAQ+bLqPIBUTNo9iT2CVyQlW4qweOUydk3HQL0wrf9EgJtOEWmtaaV52tgHDKIQwWvIjo0xikAAr2iMSWOEp4AqzaRjUfGSAEeFPoDBlKSiXS2ujmapK9+bU4rcmGJdS9fMQN73F2Xx4Wz2Bilam6nO8T+ycXlMldldyb6/wqjSA8cwh7+4UDFuhL3BDRHP6FFsdSr2HWwwF4/u7okkmdFmryt30axLP6Zppjt5TnznydD5bMl763E8Ir2z8zysQNIiYRE/iteAiqTSuu1vuQboynzaDl0/LQwT1UIaXrcsUW/7HVGhZDqppJ87N0Ajx0vfTnqz+BQanUdk5kCSJeSrIWnZostmggAo7yJkqR/4+IuWgCmEhVyMKnsiwxRR8lSWGG4+J7Q1JctFYgtVzqVgls4WWlLAODX7xP1oatptXlJaaLJcFlMwakF9Jp9dvQZsKUbxPMfhKycunFTc2Wi+5DtQ9SCDRG7EGkyZT2o0a9YqILzLyug/1NIcc4/kDp6zVCOoznT97LKwV4RAticnuzWtnR7f0CDM4IIV0jJO9lhGLPHlhIs97jU0KkGjEBj54aIveebKJw7aCIN+wP7SuTQixpM1O6Prfa/Xe1S8mp3Rb9En9fuKHPB1meQrIibB2kgDxT91J9XPntWT/s42GjT55YcalfYos6eZ0eIvqf06/rUaYmVs6j4x7a3owbNuF6CpE2pj9peatFPZWLrGwvSRYff3CA7rhlji/p0V+E4eUGT0jBS+U9WQd0mLCZ5GebT81iw/3d23sX6M7SPfJFc7dsHVHVy0BC/4GTD8U1lM1Xl6XMxL9KmeuLzwZCYlNmjEZ7gRRbVGDAJqeuAyCqYEd3qxSXF0EMYQul6iTGP/kMcuBsAKv/X4XcDx2Q3T+w04lUBBN/8Y/cHdby9ZJee9TXQGhGMp3Cu3JjMZi+ofE8cc4eFnI0I/M6PCuE63e8nxLMEtbZopCtERo78CdA5Xoc4NdNWs6NmDlANbrSF6GkPQjXdCNN45IvKqp31wwIAr0n1HzFWB9bQeYZdgX3vdq6UYkfCYazFP3lqi9/sKwXS5O23BB2jX2b2ffQWSWDp2ZZ9qDrgmtwYwUHxnPDfPttfThXvEu3qwrm5/aZkE5102t4uqwCNcX1Dgt+XwNkrpEVO4g04xv2iK4nWCngj3s5nYnWusEUqzUF8DfATlIvyMisRpORkv3hkVzRgA8qGn+Fnz7Cla2aMedjQoTe1hSM1lMTDcFK+5PHKXElNJKUkGReUae58XxQoGVVecpBHvr4CyzYG+30boBCPduV0XBCIMQo+Sz2F8rRU+9cDgo6afqQMBXYZ7n3IiFZrP7PfuTxBnCdl/dNtnDUEGqXdGyR4//SIXi/x0CM0tP2RQpRvqAFWHzn4ZYCrsbh9iFQskZpliIDuL46yCdI5MCIi0OyFNTY0Z5NxstCFERphYUb+g+Sh83bKVCx8mLCjF+WP7/qKPaQH0URlnbFjhmAYZX55p2PHL2sdWbZo8a3Ycy3SjyPlyb0G7LaIiKSsWzjhYmh0+O3rAP8xvWPPTkqgMNSjyUudMEHTDem2WGtZXBHowNHYWWtASXr8YKgdM6KIb6gKiay9SyZp1brO56SbDRCFp9u1FSdlOLjiXw3x9ieEKQ308bPJRWv6KuLrV//+0yF7KkES6ZBWOjUpxMrujM2MzV9WwcGD2rD9cfGTYaYKm4vCjB5PpqnRgMoYap/qy5ij9Tc8I9eWxiRcUlcqkhoCsLdNXnu9yzkwIkwrFIR7lOn+vxnqUrhbStHgNrlXHbLXrz9cIlMq3vQDiwf8paIb41tBvmTR4AH87utErnDXJm9XjP9LW8CDX1N3/U0u6ohz04VOvzWkwICHmx1o1arMKjeluX1BBktedjaORoQJ2AtGjzUY57c9NNSUDPv3Jh283Kdy93XvoSse7YxZwVKybcsUUz6JEoQSEkblebyEjmC4LElqHlkLy7NToMi2HL1MKDiYdz0YH6obMhlKjCxZ9+OfJW8JnqKh+meEt75MiJBgf4JZoBnvyiOqeUAVrq29D/nvHG7DLJFTmRbI/PNv5UWSy4UT3r8FkUD8sHPJ3mKmLCcyG6FNKp0OxQqma6XNeOKCEIJB5xckWu2u13wE9F9XPFkWlaSSlY5vKkyWGz3aB5MDD3YXXLcr3FQDgEcBjYfk+S3cPTP6AHSLEbMzMIt/M5em89uMs/r+lIhNtPBlTp/0zhaXvgewZ1at9w5Ww/6NFefdugWpQETLGozPvHBiKIB7cqOcuMRmJPCEdj/X1K52MJ5sP89+x8yOEVpY2POefr1xP3kHX5mj5BWg9WN9GJTbO7jHvP8imGDrZqcHaBPKyAiB+Ou5m1VORoXymSqjy+CNfukBqAorSHFHI1povdUldOCmno5IyrTPuN5cV09NsEsyrB2X9BnepiOp0Z0hmpOdYFJetP/SdvK5n0SwlIeTgmkezZvs2SO143KUcaAe1Nlp9NVZyZLt5jNrS+gKnm5ZrSyTpWHKT8P770tkbjp0y+ORt6wbxExyEWA5XzBwG7yvoUO77tKpFjdHYuXyuyKp5cn0+2hNDz53eCsvqGS7dIOA0jzYwxR5GGln/1v08kacW823+By75rhNGFyjfxpH6G/nZ79eEYxluw9dEV905agW9R36R5FJ0d37ooV87zQzhM9PjwNvl91KQrbjOul2ZZfrguvlyIlae9q6z5dfqSPFOvIIDv0TQIKZT0tOU785WysZvNCCaO89GvVlhCzprkxuE9uSrDrtXb4gVNLzhFT1mAeHdzv45dIA/B2K+lqNTMEd6puWwdlBMVHhVhOvKtJ2GQL6MNVTybmjoFb9jEUO/DvKCPKHCswYZgsyRIaNExnYs8M2aMxi7Ut9+cVgEcSS+qATvbD8aMvKw8DsUT6PeRZbG33tQKsy23+ZbPB6CWeUJArfZd3lgz/05IjmII+Y2Muy0Nh8/49Ui4Za8jTB1qUPQbHdaAz8srIOjjQYugIiZoJDIiSCYmOMjSVcYmG8jAUfepqlMADy9xpvf7+IRhHio+dcuyFofkjsX1egGK0SzTM3kl6rXiGRl+LVGpftAmvjesVTBZi6K2CkxSmuhvHWTu++eFgWXekdMck2ZmyoYjg60sMa6Vun3rttK8GA6t4IovlYHQqMiMT6t32MBU9/9JfChUvB9Q0aOceNu2Qhb2RVF5GNI3D+JC/NA3locC7ciDLznnaVPCCtDtq4MpFQIHvhcWE4h3TT5AzhdTJEM/9JxG7TIZP2cFWZvyYAlzPMfCpv7pkCXojwwchcoPLPNwdO+M0XY2/+ATRm0ZTFKVFba8DcfDewz/aN3zmP4z51d8kokEEifc2Fq8NhHmWoL7uFU4AnTMzJ047ryWBPCvt9+qqT59PhoFI0fUamXyfXyGWNIqP5rRikm5kn3MIGMa1aTHnjgfvyYcnD/E9qTZj2ggycgvQigevhVc7UV+GxORQjAgIonnSuH6VANjgQ91R2nZ8hFaUSvTP/9HEd51XJ7EFcBpAJYKJdDRS/YhM8f2bUX58BWV8cYbXJ5L1lOkHsUmQzQ7JXiAZgN1e+9ucH3Wr79oCWcgw7eykJ2/hgFIhHmEObuPHcT4EgSbWugxAR8Hcqv3/U/+SzQhA7yi4Rsc/TL89X+CSvkbHc931q9ODHycrI7P8pm9Xw0XNxxVVQ6cysrTzAglDnvqYRpSw++3/3FD6NSWBEvVJ0hlhQjpNano6fCrpYVlnf3TgsawGpPgw0INgkEMh2vfNhp9PFWA2Wv4vAYKo5uYWCUnKUO5hS0G9asle9IMxiWK2ria9qOHSF0ehIbr9VkIQcMiRRRsGzGttK1AO9dNgK07pgVAmDFISO1xRF1LgrAAnNTTk5XJWfnDFEaCpZlN9c0O5+oMDxR7C/0Hfx8YDPFny/8FJuZgHQmXgzf3JWk9JWlAEtQdiQso+3dyEVVS3DlXDAd0kWfaIOcaRVyee0CXq5jFIo21H4GF+z0tXOF/mkBOrb51rg9TQUc4aXToovNRi8GMuRf5Yfopdl59CsPN/rp1lqt5HZJToDM4MTTZHEfdS2qtZW0NXLEMXLY8n5HKzmZ5dmXFEY2+A4R+Ev78xaFMQb7fivBQMUAOZtPCFOJRwu1dTvNlpZjLvwSunVxH4MBCbUSyYLTsM8IOvzJT3MDwCmHf3c0VBRrFqYclFthyqm76w3y/qDiXWgWV+sD45QgZvzzcTUe92rr+wwqsYyt+usPNyWI4hmeHOorxI49Lj2WHfDS8J4y0EYO209vwrazrQTpHhb4WjMkvdshjKgBClx4ZoRpkiI2uw/xr/q8+hnO1/EDg3R3EJXHcBOJ3ROMn3GqOnHipBmz1yCgY7BHJThiSe2ASrrU/Q/XgXK29Zt6YPQSQIo12QF5Dbdeb3mcg11Z/bbCDdWQv1eeCrS4qw3NzbbPgH73OjQrGBN3QDOobulmUgYAE1RPTjOVwz+Jl7xpINOVLoTlX9e9M74kmkNcR3N1CjoLyuQXKDT/9qZv0mfaZzyBxFeWhdll22hYNiEzyXfYtzsOjZ5Kg4BGsqfaOM1Ay0fesg6WZ5fZnkkoBWNOOA0uMhoGes2ToGaXskwD0v9X5Yqx5Heha9Scpb86SvFZFLtEJimuJ+nTmLwizk7T4MSVrMyYCsZInsrwIuVR5Sg6QKNX06RADER+P84ILK18Vig2PQhpLw1gcAXWuOFKrGYcK4Yv/vyNZn6kgY7RUFTG1KPCqDHYNQ9h+hofMw3KQgozoO4wNY6h5oWhnRn9jGFwhrUvdDUevH30sl9fBLFTDvsAQ82C9wgKntcqtYMCzEUCUWGqMIfHB+xcRchBrPkpVDdjyboeSrKLRHbwYyG36ilI0AVkCkGqf5n2BWwnD1hB2iB4fvQrKYRJUb/tfHZAlXuBo4JIDuc9PaQZHfVQ9h60uvKSXqro0042/haeaG+yvfx0kWLRu7vYhoS598FxlrKR6Ty1EFcRv+BP0omdDE4eOYu6C2o7PZcJs05jMHo5kmvCiij3gFrK9H8lWs0gqO6dL28hJcqEw9vUO/BTOpEfvhpDqb8eLq8AeNgJhtCzdj68ERBEQFfD7K8jUFDEorUZAgHgNegyBD2RpVG8pYglczy7OXq26xBMn2UiZV1WBnVZUY83PNDWnEpY+PBa3HJXU2JN6Qcuh2/lfbn2a0WI2X0/mJNFXDqO/QJj2uztnzuXaKqAf0p4S6OkUexUUAe0k0ZiN6nwhplwqQovEkeLCQ1KId809eoyB1ntEoMth1y4lNLN3LYHwGttjqtH904QaVmWukyqMTI328kqIGS6jbpV1glPz1jlsrMLBLvQobDB3pIrhFlFFiI8T2dCvUOsqw9+OnZhBWxci7qx16RIKeMtfL7LMuHcASgQGwYORTwGJmc+zFJtubG9578xJB9Y8JwXiCR9aXImmyeNUUd4ddNuLWmNM6cxC8GJXSjns3z/s9+w2KUOByqlRCj/XK7LIzg9uflu57kKrN8NCpazOodaeuzYESAymmzxs4P6mozLDGDYthd9QE82u/s9W5eRcQwH+O5oRFJ9YPA0wdDXSHH4QfeTCrAgh2XyZS/PimpvW2+K3I7ozYOmL8B4qis+fOdKKqIr8LxTa0ZvSPm8pPZ8lHDa4MtU69vNTw1JhgnErP3M42mnPvCEJb6Owhu+gS7M0216YIUfWuIMlvX7iodu8WXoe0FDZjsAsuX4htuvF4+ypEAEnOiucYr0uNR7/SWjBjEAvaJocvwyN1E/e401zefu+iXUVMUmNZxk23dB0+fO8XFBgZzlssD1HM8h0F8r8irHDtvxGzl8CBJEITxiu4ViplP5jUhZDNQNYWHVdKiQaPfzHUkZjlt0ijt7thRuZurzyQYVbBRjqS2k+XqoQLGtVCEAe8P/8+jVgjyNW7v6ZQE97a4PVoZcVID7Ka4TJuJP0xPHpddbIIUft0sABI4os9zZOe9Y7K0O3FfwqsFix8tez1iQCaYzBS/e4v58AEnqQIfCiIm4g2IBCIujiTKH92iuQAAVveg8nfRHu/gcPLIbpeTs1ZiPfbncJFe5XnrDFlCHEeibln/wrl/KsyZxGn42fqLI7cLxKocmyGtzvZkffJfkGRow58El2qHDcRN+ZvwZtdehpwuLF04f+od/+FxJ135cw4sgeeumn4ZNr8BppRKu03tLFF+2GMJ2QzIBUfAiSrFG3JCXtfJ3PLMAu4BJkh99CmobRQzhfMov+u1AAuzd7ySG2AVBt4tWqVjqd1BF178cZloe0leFA5NvwDWq8lP3bwzHXAzN0/xFe3Q/DqhcPrxAvio5E0JjwspOsJTIO/GE0GhY8e3rKjHzT50yklXSA9HvctkYB275bFKKNkADoS/3/mUyuCJFUssXUBfiso/nv1CghxJP38oSBFOqE17x6GtuPjHbaPjMTYbSsXZIt0UyfZuT28O2rgk82xK2ifW6U6/oZUDAhbooD4K2WW5yiBEGsLHkvzIeSQ/7nlzEV4MPdCPfyiVUZx/oU53RsqzkRM+T64mthMcpP1Zga+y3jDKQT+JiWBg2YS6UCry/DpIRJpRLRkYDRBTkJ9BaHY+R197la3TyH8QlUvHmMedJ+uwzMHbFHr2e/qVkwp+8EuEiq+TBwP0Mz23VMqA4QkY5pKtcFRCKQj6mJAnL4ueah1NPobqR5miSn3VDwiS+XYmVj5X7TnNXhbrzdRqBu7sK02ZcxitIjSqzLFXt0wz8LKGnO4dVLLSDDZ84j6hAMv5nXAw+5YGqrWtpKONZejz3G19Yz2k71UXPzJDUVTPrtZH9GkNauGScMbVg6H/xyNF19KvwnYK9FHEf5XBXjRNghm31UO52dMnoHcC7o5IfmPay6n2ctgaD1u4Uo1Ju0eBv8BgOSN0XcZ71bddFtlqKYUNNX7KZrzzcY683p61+qAWFQE6TWsFQXlqIt7X8HNVGyibaE7uEgyE0WdnEIde88ZBERCk7ilgSQ/msCN/+d83+2pFIjp8Ai8Uan5RwhpqVUQfcnpHjH9Oqsz64yEnyvKlkXrsMWI49jbJLA37N9nJNFz3B/lXcdOx48Co0T7uZW9Gsf/1PRU1DzsZ43BufirrglPsuADWEX6DLaqgJPG0KYTHLQtuJvUmpzNmRzdwcrhNkr95e33tDeh447W6tmCWjF1eQ48njD8mxZGugoJAYCDl/ieROqM1/m9Ig+5FiizWBNrq9ldsPU6IbPvfmgUiorLmXB3xgO0sw2/9QGJKODO3Brdpe8+M52eAGj5F21KLDROohTaoB1qhBEPkp5UuCcYN/uhFWPopczRZFAh6fFNm+oW99dJL38Kmr9+/Jkwz7hxzBnyzqU27xC58uCcpCO4SqTo8IvbBP5VGHsHbz7z8Vs1BgxQJjDOfFjwUu2dFK8UQBXgT1EKcNBtupMmQX/sFO3tS+0HYgsQIlf79UMKeqJxEv/dOzoNU26unC+i94aapmhq/o/6unZEqCQxJgiabreymabOWJTEPv/V9PMt3hzmhaZvkbeKTMy9wpwie/Sy4utP93U9fMwATf5JmKaaa6MKGdjbMjY5TDx4jupvQ6d9hCgNxwFRbV3eJs8bihnwUxtLrZiucCKcNzhARnMkAaq4v45g2U7GwHY7IML7HHdL/0ii4m+g/porkvwvxzN4LrffVPBEwPv1ir5BFjXcUM8nc8XVfgd0KcOJjZc4JON39OtJqk+CYFzFG7huXOqw9Nz41JVjdEWkcc3bOy8zhnZq8N+Yd2GBamL7iqPHrw0xoFDmtbu2lNq8Ui1JD9F+PVeEnXImh2r7Hcxogfdeh+beWoXUplD03mSni/dJ4xy8L2oWGhYGQ7K/Ygm3fl4oLo2A/LfKXtssE6v6W3uZWd+9jllEuSiMHbt493V+V2q2yNPtfvTuE3NK/4hPDM5kTxYwYyvANW8y3i4GEguwq2SErPwuyN3tDssFrbH9atV4vKRczX9xerL84xCqvEU6i1L0vmIHwm2PIZHvRI8bHLrNA3j9SqxxDMXB/yMlbCuqe1S6NtX+iJ/Fa7T6g8dLEfauajgGf9iPxH0BfvKdt+Iui8xVk15KaMe2xkdXx1IekxC23TJcHceE0GBiLaZdj6d2obQXzGmqRsY8LYfJfJUaLYYgzTTfD63XqjGBJ09K4zhD8cCXQWKBp1VatemUTs55QUPioO1aOZrpyNvz4q8pqO/JzBxpALrQ+pc/YCyyIHDFDglfkovF6pWtfyv7dIS5Ak8ax0up+zUn9Afu9jNw+cSlf8Pm2gfU9fdB1pkm/XoWABdAsYlTgSHqA5/HdJHfXhXDMUx5n1UM5foDvFUvKriWy9SR/ZOlCfk4xMS8U34THPa7N+FWNVqWg4Vix/1Qx3rpHepe7UoarewY80Ci5So11HAP3lLKoCd2M1xP41e5ffQkG+UIBfoQTh1bQYaUSknW883Mp2c+SMmtJMqzNFjcUqf5cNFC45oefuTvieNpkg87YeiYD0OERYXzR7eAW6P+Hf1v/UVrU6Tht85nWfrXF258Xk9PORIQsTXZAjk6rcaI+CPtYxW6ui1kw8KzeuOzE8wTld2OT7aY1IDshwM+kC+v0HfdBA3iTYjP8B2xwlPF+U3X4Kl6YzHaZeA5+IL7vhIH2Lwxu8eKCXsBrMSr4no8A4ehmEGCWGspHW4qiOT+Dc4JZEs5NKaw867ibrdrSR2nl6E1YysHLVuGb8UOk2gKobdPYp4XZhWNfTCCYnZ+oLKqtI9N1AF/S3EuLCSrpNA8obhQLPH4cA2/7kuJnncQ4gCFRKMtjTCN64sSi3wDays1OFsmgg2YuaCkl+AyCXHS1ktvesjdEAlPAcPC9NQK5fJVInkeppSpM3nv07Hfgg86jbgiZCD50zdNdetdwfc8Qp/K5XnTh4PTXAkkwRjZtJ+7J7Qfqse2rs0RXYdSL+9LJG1MSuzOM7g77NIk4G+O6VMqibWUtMvRcc4pFEC3mDiZnzu8oCm51FIi6b186pOvupx6IbQmRI85s36j32QL/yOPNdejkWot51oXXO4BzxSBKaZ9ASOe1aP6VFNMIXXwIvcRVYoNpNQkf4hAey+wi4cy7F+yP4b0QQ9Q7c3NVuwoym8NEY1Jn+yfnJ3BSA81xwiDu4aHM/vBwdMICn22IdkZR5WfHzObquGjuOFYtdMj24YosSVfDIev2Mj24Ot5SkZcRSHeJbSrGjim+lJBJO+AD26RgJxEk4s8TKbwMdesUnhytBhdwkoyZ2WemObM4gnv0b3RueMTkQGNy+bouAt0MTDHiWupaDXAsIQNZlAgcgtGhhINcMPUiYtv8a+WRs3DeI77s5pKCnBp37mmlXTEWRNJNZHKL22ePcX71RghJ+q597rObIKqsuL9CjClvZ6HrnRg8Y/llTLBW0oQZNWfQ/4Mt4h2/djAhm/aQX8kHGJWeKQBSYQzNJn5dKVHgo92VZRcICFMz9OziaNkbw5NzKcwVQ0ZS4z4E7Oex8jo3g7SEk/laRe2b3mkTBi6eMhwOvKCkiYwGqZk/WTVtldEw96/8ZbKgNf+hrd3MEX2mK6X1VssiH1bWfZhJpCmpBKyL1QKjcFiunn0VzNib5nAGXT5N0ADckNTKm/RG/tfstjqJUor3Mh6gqQuDA9UlPjfluCbSi9njnZhlUFKjQMzBkVTTeITOGOLMPiq2myzBucCuEeHY18I+8HjP/Gh1DU0rovBL93Fu1R9QbbY/WqxQmXVGFZM5LHCyIqW2nfLKNa5lU8zTA9+8FumsJO291xfmZqhJ8S47V9HrZCzfp/mXN7blJDysj9paO499oURNMmwZoV1X4v2mcxHL9Nuh9CTRq5k2Ul4pdmAtpsg+Bwyq9PKRgwqjgog75tNJU9wPKPPcX8zGc0nwvEtHSP6im41S9Zpv6iiE03uKkwQuRp9gvaKrjp9czSJexbm8+wooAhMF4CT0OQWKP2CCEgMHgwXkaFHBzqmn1DxsGYPHza056Eo9Pq3+jGxY4QaN6NAvhnm1u08AHIUv4xpjmly8lnPsrxl/GAEwHRa+RuvR+IDt0+7truwNGjLVAGuLKRm5mKq4iKJZje+oZKiLPC1TlEEMRzusKHgc9RGP2FMXSlrHSb5QoQWWX3YGPuhXHAK+HKf787VMsvsiy12BFu3ju5LEoYfEcLrFAlGjDi7MUPpCZW+UcrTvtSxjg7uClEie9zS5zhRP/rnUx6mQwSdQiE9Dfq6KoxKTph2BHRCleBTSw2Xw5nGsq+d2AmdjBHro/ZNOgGEsBRA9MDTUIfFOzJri+vlfJ3i0UvZJNNFIqZi/lxurzdD48tZAl7580G1XErJzDtLlnw7dN0Kgi/6OrJt4xbF4EucSEh8MD0VXaPTYNPqWbxo7xU76yhItWUaXdaaGN84gxp5gGf8DZNsKNGWFvYAwy1KN3u2hi3iW19nyTwmUEYgWcg6IFq7OklMQOhR+xkDdGNqRLqjiwpN9vJQOhKIw8TWVGfWMjSAPkbzndqOIsXlaIe8LcxXI2TtxsJKGp1txvaNZR9QwC5W1OBePj9yCKDfO6O2TQ7guSiN+hvVr9c2XpNSjPTWLT8PEoq4DXsi6/ZWJGqPCafcJ17r6NOaWJbawRUcdTATPH6Kgz4MTM3RjYC7J60vq1a/teFSUbVBdpa6IU0HzHdKuP5572FxSEOgiSOOWoM9Z5KWmPIt0cx/EE6QzB+n1DOZKGiKUHfIGUd0w7ZPgNSaCg9tjscwfQ6SEFX6SfSsCJks2GXQLGK04ko4HGkS+ZU9oSs8oDzmpkyembZhASp85TZcu79XOvoGVSBh+pzg5SReWcRHlWCsOrilwnIEFS0mUX4z079sGlOrJ7WRGzjiC2fPmHT40XHnvQzkULkoiBwi6kg/5bvfVdGqk9hI2bcujpcBoqilwMcZV3I2nGcuoi7Ow5RrO03/GsG/OiGUnUIPqnBznNM0Fm16wFDlXPnFyw+WTIbWUVdU8FstZ7BGJyfWUwaPY/YQOxRTRS5pBAev6QGWXL4ekaddZiD2KdyHgCcHbXBd2POTRpIYM2iZCkBE2u7AtTkbcKSB2j7yr3LJuwVnqppFAyhe8TbuJyt7v0Yf9FaOa5ejEsEPPg2ZsKargCBFj6YeMTN+rB7mWAxIK7ix/mCzMmKI41J5+D610M8EweoWe1R9M/b8dZHu1YjcZd6ldBx4ue8SYXKsxe5NtNsDEFdOB51zgdME+g7oEXiAyPQS6V92OKLap3GR1nc9IedfhvWl22TxLl2PGtynTrpMmLL+PR0MGPVOEgtklsO5YyoYM458MDebmsel8rBSWEdmu1/W+7/tyyijpu9XocVS5l18AhUGS4xsaRQRz8+lWtyS90xSvVPzAZjyGql8S3+QAPxPfKNgrY9MRTUmXrhavcs5mqrrIh/M4ZieSgVBG79bJjakC+8B4+uHBxLCXtGB8FVWpCjtYxiyC/kmNAn4YU7sJKLi/6MDaqMXTzzzFq7gP9/l2Usbcb6FFMtGIRT5Mh5XYaE3stbe57rRWsMLNMAzGz7P5fgf/Mx/30+HUgmwbJ48/KEH7aP/8F9vvT2LQ1NQYGnRcIRbxsdsXjRe5xTYiY3FMdXhG0BEh/SOtaJa5po/P0L1p7dvaolBguqHo0UtWHz3AZBY69eAtdmMSCsrYrXywKZxAr4si79nEsfjbdN1Kq13QTv/BZ7mJHvC3pE7Q7OWxm8QO3H3ZRq3pGaJx4O2OGQijb2xPptCJ764fYo0EcROjgcQETCw0DkZx8+yCKxTFLTU9aGdlQwm/cohxV85q7wcMybHJyun32ek9f/lfXVx2VUTKFcX+8/DLg0XJmNIASLCSRzXkeCLEcsWYbwRgOiAIGHNEP/zDM0K3F/cRPZQM5YArE4qyjXNbxm0tDwts10dhvOmCohywAIgeeRXhYhedSMmMZYs3Ne5vDjPWOYOOVmLJlTU/aSPRSdMDqAT93LWqaZk1oJWTwWvJBV96Isz+K4Wb9kc7jqQ7dG7V8uZY3XzL8qebDS7h9WmH1CYmuFn34idd29oAmaIESg+iD7k0+iov85KfMGvEl9yfuNmJXIIQhjS2FIA+tfYPrC9oO9ytUxCdbFNW31MtMpRt5LEx0EeXtc0MFZtgJU4030939TIV7RuIRNIN/hw9R0NtjujtWXSWnmReT3CsnVK9pfXganYHb+AMl3Thy6cfLIiyEEsjbeOSIIrA5wRiT+FwM42feIUZ+M5XhLyBri5mdHPONThKNAM4gyzG6DZ029ewX2MHKO6W8otL6pqoI0tTCfgD4+W99Wwq+BEFj5MED1YzKJJJHbD91yqhU5omep/msDENHA6oCteXqs5jSVHcDF24ysx0a59A/LnDzxmN1sQLKiE7VLtwzZ2sdfmou8xo8WQtpZ8wbliJcKujDZg54WweSMNAyZrOaig3s3KS55xXF4hTwb5SglW2r45C+ZEu5LKp8Wp8+ZQJ7/T4JlkiUSIlc36iC5+yhWI7GJhFsEdfil4ccgn9QYat2bHgAuJL4pdCTl5AjyP+RJPEctQ8ADbnPqKMa0qWGMLX7S7whrzvc09U+3uhdPdYl/oxUyO8xAj4lThnsDcNq3/bnIoQhseMwEtEylxKoKIcvjzWjFf830bN/KFe5fi6EWMovaym9mE29Jy22icwxBgkhbKLbQ4qI+Lf9T75nKsBpo/iIUl3Xplsef0vui7fskTTXPeCrYHmcJJ7ZGmbv1KtAwQzJU7IJ42MNOXpw1T3n/yeFR/7lgxbe09tAEHSyH7XA3Gz65YFXCSxB/KIYU7pitpyuJ0IKXATskYm1sLLpqklA5/ws8WhzQMsXB3pSFFYZkFYnbo6zsl4mKIatwweNc69VNVCh5MIgsdGOXnWRa/t2q4GYdHAaNPz0e8naKEnXYstIX2XC/RMji8fCRGKg45chuSd2W8f+4VoGiPzP9SZaDwQQpKWxN+dm1qrxWLGX6Ll3ZX21tp+BST8TgGnUUr/t+u7nC6V76WqSgLKhjrFhAEBUwrRav6k/O21yRO0Oc8qr6/cf33Y44JeXZgweMmyQsFjQiDWghIYTOFaR1gRCzfeafuUZc++/g9V5l1Cjk/u8bCW7xhTv6Zf8aBqUnn+r5xdtpo5/iDn8a8KqClL6F1Q6mIsgRa6176ykVrXnrEqxNDLOP0VTm/9R7oGvT9uVncKrJjcOu7KunyqHJ1AwiK+Zgv2MB0z451oPWkqu2qQ5kgbqn82YDe7yId9CVv3f1zL/o9ey5bwa+4sLoMQq6OsUGDcd8f3WgfXQQUqCOY0PgcJDQkxba4aenBtD/wnsJD6PtDNf6R47/T4m6cLEtW8ZSIu3mamgegmdvLZh8WDNfiPf6qX2BlHjnk+lIRXWlO0q6loYyQ8XJsw+uOOSHBMMjmVErbtu/eWS7ZYvXVagnbPT7Ipk61P3+yGS53+N4vGPV4WpiPXITx14qYR7EkaeZNKUjzYL/TP8mLffUbzgrFeHHH6GVdEykHsYZhxc27S5oXR4vMLfSSs4UFj+pTEZ4cpBW/nLf21JSUxDqFjqpCW07aFV5ck4dimPxo3KVqatgklr5HvMUpdg8muJd/4pVCSZE6Hq7K89AsD7xL6IXvb+svo/nTMIYP+dO6GNMCSQQxux4TIhqLKFUqlKg8UQXcpUnwXDJp5Eu9ZbxRhq563e05pJJEOSY6JhXZL8PhpynUkTJ09S9idISJ7xTSchk7Qj+XKlIrCncE5dCMCcoTMX52Hk2i/ITBiofYKAtptltzqyCBf226Ix2dKlvap+/wMwHzcFSzpb9YcFF3NwBM/lidWB+qGwXd9z3Q1BvwIovgKulKsLhAgKOQBV/QpviQgg83lZABpKHhbCQTECoeEKywCrqpzf+jiAfWw1cJ2149eM2JBHcZCoR+OCKEIsf+RrlHeWjD/7lR1qXJxQli2l75tyouNsk/IydysXeKgQ7R2NsWpEeCUfFQeryzAd6DWzCqs+WoD6pDWx/tjAbv6ZVRtAlRYUHv3I57dkTLSFn1/EN6xw1szcDNwGiexdumwzvlr3V/Qz01Ni5h8Ljz1x7tMBU76whotfQD4hBgnjbkQyeb5+sk9mLRVq0MjeJRGWDHwrW3MnPMSVSeoOINn0CiRvhepqukVEV+WATpeFUs7Cxi2/XTYEnKUGMiVWsEAv6ggRZ9RFW/qShszL/5zy1sb52xCyio4E4w7bg/OGGz8ZL1mllVwrO5G5KqMsAn740McC26MxQjdSwUBcTKTJm8aLqcTJrzkB2Y/HLxDsxE1DAnDvvz9NnA78lqMHOKgySUTUX30BoL7ZvH+neizBUhn6gOxOX4sSKBm8M34oh9+9wIbNQlbgJz6Z2IE55Bnm0KQXDTLCgjMPdD3GqpQT3XrFerSNskYy6H/zygFWRmQcRKiK6m47LCSij3IyzerfWsGiYUwjwBpoan5x8yUCAC9vs1vBVJMHWN7egCHLZiODrKyP3zVdXbjAcWv0Sh7Ib1JZHCuNM/ZJGylAuhRbNH9E/xF7z3ykYGqL0NvH7pSz2Ip+BGla3jVroySqo33dHJdV2McxWZCdnkwtRH87knUYEA0QtS8qNWIZR0YhZ4h10ZOt0sfIv/C5+48gIgZyDo9PejvZBipStVTJi1hfD27S2sS7MIB0YxBxY/L303Xjs/AlCZQpQCR44DwcoTnYiy1Wa5Pw3RRyyJ1X5u/GuYXfP1d3/xrsxcHomicBZUBw/xaSXOQCUthrbBKQSyaPSfVbnPS3ML1z9Q4dmk8XArHoXjl8MYILiGK3klN4r0o9vLjRcaMabJftLJbNuVZg/r2lob+Z0+NphK9mSFTu0EC9syPUjx8JjdRwGR+86OpWPf7OWQ1oO/mRA761Jl8jhYkfiocTZd5iCvvIaVS78Tn/DsPD4tilqcouWPyYLiW80mclanDRS6v9rFoQi5WCKEGdK/NqkULjhRTGgE1BnXtC/ylmBSDkqlHy+5vyhKMDP588HgkTKeQW2+TpcQul2duLDVDRy3SOmxKk290igLwxYOIMZVeix217nPmY+FhqGYbhOWVK/WJ4TbKpe8ttlHsiwAs76r5ANyrTKWd52OP8g6wavw76W7neq69dQTxrQU0pkP7u7XF9ypPoZyczXjakzKHrV3LaSrSqurDmGJRbt7/eFn7vZ1lRCtWxNMCQe7WppReXOkPf0hhMwwo5PJJdaRFhP0ZxuwG4xrMukGFk5n4SblBBQZjt1YSb4sA6/tofSVX9B+FAAdHHB+srXD6JzEgHjQNCz4JGtoqleByqdNt9qkTX7itsTFehrkW+qMvvyYfQzp/dqxisMOIgCVfkyzi713F7s5p0dL9kvaCjtnhQF6Np9jW46BQNK5gkSHi9dDukOHw7rCDsY4x4StlnFEH9085Ma5yMYPDeyTBPQqMo9DzoDDWg45dAS2z9XB9fPeEWhHcK7uBImpFmMKB1EppC6mHkg24FpTjztIZ30PtasT3MElNoAeVpsld9qINTVV4w7aDtj7nGYe/kH+b5l++5bvGldf42UmUNsFx0wUjxQ5Azb2+nmrtNwMxFp+3KVCuC5ucl3Mq4sdjOo1ilvxZNDrdAvdGoCHgH2dD6l8PLeqCT7bXVyDkpqDAY31XHSM1BbPb6OWv2Pb7LOoo36dtoFdMjh61qhtb4CSmR0BlP6EknZvTSwUpjApuUDPCwht+E6noX1s6mck68IF6QULgXKrLX4ow6Q+Pf0OoKQ6QrfopV7fnxgNLI1V1cXdgSkRKyroCtbEFyE1F58qQXXGmGqIumwD5K3dauLg0U9cW3L9t5YzBlZ6AUdiUKXsWs9k+PYihE9jYD/VBfEhAHuhImZNxgG2jEsKvwnodYuaXuKTFQC6s5aquIKKRWUBMzl+e5uv0TXQtrlMubv9I2Zc4F+p/Dqbla1WpSLETw529sNoC0PksYZVlbBAPHvkb1LwowQcuuZhpUxGzKvAUNgrzCHjD/Qg4XAueA8qKqiEzJ6ep6AA2BjbZ9HCGG7wsNnoWb6NJ01wKRyeZbHEwhgMWxXRArdWue1SuX7saSDVUsHV/0Q+cs+/HrJ9dCI2wWqscc0klpBSa0YJD8gjXduUqpFVzC0C50JjnK6KRvp9bxeayJ9EKGpp4ICTDGWX/qLkhWi98eGTCiufnN4IZBJQNCg+eifVL2WMXjzpYJFwHZ70uYjXJZimpMk+LcCR+5Bg7GeK4MIafaKcTNxmA1ugQDJrNMua8D9qt+iTZXAFz093fWCMKe/FjW6CvjNG8+pHvND0YeA+o8FSzqH3POppKIcnszFPxLRRWt5QFqG+ZGPbt1v+PQYdymKVFvDZFF3PQXuKtsAQmFuLzm+bLpzPCUOmMal3ovyQXrEfxcjqodL14vLH+8CiMUV1ENxFfNp04Latl1lHlkZNnZr50Rqvpfi42vCaRRgCeq1NmblJEcI+AgwJRLF7CSKOSd6hiQs8bXmW3U5D5lsyBcVvoyXKdmo40AwHbJ65L9rIjhTuCvsJXZd5KzZQYjLPDuD8u14U7AiDEgpfAEWqX/WunvB4Vo73vMYPpeqFbbTp41gxm9uCqVrEVunEqnjnHKtXBOWNbWeno//74teQ27ZDNNrGgWnPYw6HJF7xj7x8KyhYY8XBGfqQJ3RQSzqmaH1reeBu8JAJjCkjZ6Q/qHzZ3mPzASrHq0mqUI9G9lCQ/cu3Zu4+nwOYIpswg/egfpGhK8x8NVg1DhpN7VQYmWFWAR/WYUMHovQ8yhTR9/rmpuvLbM3eD0TQZGz0diuOmCXnHPpTUJoy0dcQwmaXxjvJ8X3E0zggT4Jhb6WbkAjB9uPAyy1xt0OXxrnBt/HTqJtCUbZzGohzxgMXZeGuKFZlIinW5UiQGm3dprmdyqZoOAmfwESADgNF5WIbODG702h9HBgAebFphBS5PCNLWwnATvy+UEk/B6V4BLyAa690j9/PvSY3UJE7UsptCM//6mFdl4JiQakqk+/d4kJUDchn8KgyTa61m/QwLFQ84By/+HyYflEw0KlxS3dK5nuCLB1EPvj36hDear0klHIHh5IlD3oQclmhEqs0rrYkUDSHEDnG8+Iw2DhD9JDd9oOWbAWvNBH96E5D5FprMB8fEfedoOa6rqY984tfkVMs+50z+0zrQlcsqiX68zhOcDHp5Fet9GVr5/E67jnC2ikhcXHeVSrHQSUEyBaxWEX0C7eo1PAkE1EPXCKfAFvi4oP26aPZdwfieAgQgqTMvFKIzzIEs/LpjAKZAzcu5diUQf0eaRM7P1tK+BPEqLmI8nvU5aITl+YgKQKXJjfhnFzxsj3KzZ4dqhM7wXp6aNg1aIoiVUAwokNMDG/LZ+JmBi5RkYXit1vH/fslb5etXWXWm1xNya13ChR29KX19oJwvJDvFQmLuWaEJ19c/qIuUtKmnR5zPTeN9oqACeyOHwR3YccJuUBL/zpZ7DzcS+QBrPDrckHJyQiqeGY45Z4qTBBoZa2U2UjjWgfdtSah1xMBt8g+BDJ+IF8/vXz8mDplEKt+sUc1UxwkGwmbzu9D17ggFZEQDHsSjw+9OgKBZFeLIc0kI86NFIllWhj8E+9lrhhkDm0BEpwN76M9DaDs3r+260fonXJVYJuOcTwZ/WyqGUppIQEk+K44R6g1dYnzqnA4WRQpZeOrbuFNSjOa8BoRof35v3GwSHU1QF/vhO8ytR0kopxGK3O6fyzVHGOOncQJbQcUcdMbwoQAz52NUaXrXX/0JjqvHVLf4+F/AiLh3G6+oDnaJmefmHS9ufWoPOImSOaxsX5ETJdwQP8Pm1PrAUNoxg44g8qMS3PIrNOtavfHe8Ozb/wC0CUAO4On+ePW2JMaW7VXdjNkHRWcHz5Ut4Fmw5j0yJqZZVRMZ8nacoBu6WhI8Oz0EiXbLI7jz3Uk92SzYGzUeXl2T277iSwO03dFtRDkiKWWb2wvBWpmc4fP5+XbHr0drgDxIsqeDyVoAB5LM/s09833TWl2fTiXp5MiFHvciRXryn0hiCOY2VSpkrP1TxQcGHuwzegJgY3V3NaHRHbe//ro+yNu6Gf0hdsUy/OJOcqgKIM8DRg0FsDjwfmbp5YjtOhW9MMFDGXf80m0TkPu2BhRCuNbZrdIpoeDjB4aRhloMFCV7rORAMgHggGDXXrzJ/t+SsacGk56c+2bHYwJT7xiAFXg4KWdeRFZdhTbpBiMf+P/aiZ+iHschr0Eo8NyQ53gORQB2tP7IUGJZawwi676+Kd0geBZQvBYwUIZGTymsa8p38FhtkOJScgn1Md9UcLJ6MxaYyv97ocQt51gLhTakWMFpWwl9f9PoYH3shXRxO92gRt2w9eWID4gYxhiZx68fI3S/a5Ny1rA//hDep2ekJ+MZthxlQoMl9ZgWAQ1i5lJshbSRyDchN8zCrMxrOc5gQx9xQ1nhnnLLofOc37YmiWrp5Gr8BrjRu2tJyePDLBr7KzhCL4L980p0STDYDnKBo3z1bpTc6zMNdJaqCn+dc9FbRh6to2r4iVmkfFF85UaPhhFdC4izoDkMQTb9AawssbDm0SkcaBV/8xQchElQ9YnmLLmJ+XNxMjPrvOVMq8y0UvdvJWx6V4w29E69PVagklJIvT93Z72GCNjqDLmgvTCYwR665igOdK+pklB2IyzTIZljGVwfwL6sNe8FSgxgbbRhKKiOWYttlQ9z2QQdCAoOPLzgNDU151KSlsh0UAvsp/V77HjZcX5iWn75UaT68nmmWgNcmt275R5jMYbNURoYC4BsVpBjzcfSIRqFWuy3BUdNHA7kDxw+7BC4xdLMtEUMeq//81VPvXQenrjGR6oI2cHqMigdB4CCNpuXy24fK4wbFhiNQqgUFK5vwosgSzHJ97uSbTiRfvWkxmqqBSEiFT6oM1Im+wXGce9WZHDzYtCdxEnSCxFZLtWe/ERaT6mtHZp6mbWxrgkAnIt326ajDTTFYIEApBI1RDaM62gg1RnxL9/h9jK6T3VBKLqUFlHqk+BZMVy9FzunAFYOabBOYFFc1ZSGGCtPZX5ZFwXZ7CPyhpozJOKkWcDRs6RNAyWaO9MGhkKaYhBo1m1Cvz2faUrMe17R1J8Gmo3Uz01A0eBQi0zEXkRc1CV73F9tww7bUgNFSiLRHZrjrQi1L3TdwEmO+55a01gHagCRv153iVwZQOw6dIaCKUGekGI2JilAMov6uv9DzPYTqyc/6UV+RfJuRF0gXdgUOUVGn2Zti/wwPK6AdvTCaz5zaOOovdV3P+GEmi2E6B4ZkDZVD44EZDPg6uvcnUc8wA81upMhb0xfvLhw25hG3oJj/56nhrEVfzYY64kYUnCrrlfdLDTPAzmQfUsDZKxSrx+TrBu7Bhnkm4HFhkv8IZZgLjH0vZtlFYFs3crvdzPtRJX5UcBdmaTmAa+4hcY5pnnd282y5rsH2ZPyoJoc8iol2WAfrjo6DPbG9r+ZIfYFjuVgDmQ2fMtpsQYF/a3RbbvZ5wPX4Oc5HWRsPDJ8k0SkjJGEfdYp+lCZccAEWjgioE4TrrWOGSN3sRTbEPKME4PcMnj/9lRlu24vlOMFeQETJj52l30kRuLCyB27yC+/4m3UMbluAskFRpvSMRxQLHduzGtqwqOL+KSFk/dPBjjz8FwfWRtkdv5CVRFvoW6q9qTmeG6FWU9rAGYv1mueZD6poHFK918rCECHXzjIJC6WX1iSDeQfVuPQW4llXaaHmF893gc0xWumw4OEurPonNE7eD+Avyubi26ZY02qVSDaHXCVHugUBhxqcFKEZrQNtV1Yn5MBYnFnAFuhy5Vo1EzylgpPUA/+QBYRU8QkY8+SnPmnXVEtmVuJIzD/bUJ4+LxfcGZ/n5QrT3q5IpYgdivDeb7q5sFCbb1UcnCS283Uurig+9PyyU/++WTaB3xbG7ZTgXIBLZ02Jz+M0lZgH75ir8bVT/SPO0HphLSwKIgH59aSopt77b/WGcXEdSuEZqTJNSwd8ihdIdC17C9yt+2LIIPlEzTUUEuK0KDNbugcF+aX7t9tBjCUKlicKpEZ72syDzRYfvYo1EZbR5Y1df7qLKycItfQYVs0nxjmjHZB8xKYvfEdPrGB65UhVXsN/2mBQ8MNXH68IYOVeMrzgyO6EerXHgFN6RuEjjl7AkZAirDMn70lgzcz0gJc30V4EhUu+4XHZWG7q64w5ywvRnIr16BlaNGjvD+FZbZrALKtKAQCZTuTN11E65FGVRi41DFG6ttc/WV6z7VsewOlajd1IH08WVdl/xCtpNXQvYKmxH1roQkczWOzq24Yq3cV02kLbPtRM9w8yrGcATxEr8A7NWB9cb8b9MiTaL6RgcY9LHiEtbcGbe+tjGEZh2vsFXZ9JWTgTv0km+dd70H9phwUqkBKHvJ+tUxgrdx4BN9wihCHes2uIackrgePCEyKmvLfMc16jmDyTTsfeV6CO4Ki6ucbZMQJJIAG4mIHzq76DT/JKHrmUVjSVK7N5sOkWOWvZIwMInpjw8EDBmYBloppVEpXKiF9hsAks4Mm3AnVkaEgmjNBYTv5RklFbJMc4FOOPzAelCRofGvVTpmUI5+MzAW3VLTHX3B52zuJ+RvZT0YNW1xgpYMgGd4ofI3qW+W5ASoHLdzvtrCKWIXR45PP06RZGdfmyucZH8wRzgISdPNaWshqyY2f8mychSrVTclaDAqlmgYgJLHKdeQfzVkwfqXPXeTcW2GCRgsV1gpZjMyg5e2GZ2LSr8ymhyLjzmXylMjzOKVacPopbtUqIysoFlgMRNo8VbatMA/Nr775OVoKtE06dnP+yLADix6f3FlTKJ+RdC1yidiVOh4DTvy/JIY0PRCxWpoKTkr9ZFrmVdMDifed4UprrVBMhblN/mDtGH5YvHVMRJacgDjNFJJ56joCg0CTzzfIPZtR7dkuHEN8NY2eFZVD0pBDdbB81rExZGNLsabtZ7VhzKkXY2Y/N/Mqk/gxfi2JG8/3tFzWaqgXEUHHP+YkpV9pW+qL2b6vbRR8BnKyzJPedS8KStaSU4mDvvW7NELUMtP9wq5lVahXJNA7n4JFjIsEH5em4ErsNXUZHgwM8/+Dn3tczFuXtmDjdo9JSj/E/cDaBj7eKN0HtQoVQ9L9ytU7xBT9/DVARop+5XWiiOUxfbRQ0U8QaH1gMIZXWoAOruEc4YjCudqSLyUbZvMnoYPfUL0IxheiZX6z+SJ8RMW1YywMKkMFV+3QVNV0uprQJwU59oVOroH4zcUkvlfNMMHodBW4uciHoBaA7CvIs7XIV/vZ5mbOL/RDGiNFh+9W+p4YrlFcPb40jNugN7MQVD5lkrY21DXCTBiE9fVRIx5xgT51EC1gtmesJ6FhFdR58/yGzOrBoT2XmQfi81CVDtgWadISCNyWg4HRQM7zrrGhNrPXA5R+TIKrUGeY1pqFsMjfTV3UvMiLE++70Ioacrj2fB9A6m0mCDKlB74wHfhFesikgI0G3XkyKH5NHOdXzKnDhYPOhtwCImHuJAGyW4PMuAcBphntYbU2SgxiqbacmAN654RWQMKYE5G6vrKDSPLMygPtcmtrlCPXge4qhgpUYq/TdkcxrktL8hOwF7QwzRCr0pmmgDhqKU/O+vHe6myrWyk2NJCTkZGQauw7PedQYlafaNss7eDJdx25He19i7YXcfkuWzj2jznCZx/zmwM3EaYaA0COk+Vp/YuoLct3kpuaRHGMhlK/i4Wfc6lOyiIOFWHMCvWYWSuKWDFsomH5rkRUelWnKuCCGyCfudCvNMZFooClM5rCb4itdC/X2YdnuRJjA3HjQMaP6svpvsEADadzlCgKbHAFPf6ilcZFRPu4bKyhWNIrGSHsuD/uSYXWJwy62tW3X6aUPcAmhkkAlMV+5gWdtLbV81bIYtZ7xgwcGpIGbk9eE9Im4PTRgC/gNjz/jz4AYWhThjTHQxTSBeiNhuyJ5CgyiCNzw/TDXOIMABR03PR82H0+MFIrD5qBA5gTmfheZEInVFvqiUwcbpQYibFrK7tDBndZY40hkJ52D3wT5xQdO1pE7PkB71mCW/1AcZVD8Axr3Z435wRUN6eTVeTk0xUJHp8grGQCQj/h1lILccpNR4FcHjbJLDrPka82YUWiz/RQsWtmpVzbbxL+pWCujP22fmxFZU0EAxjHh+9rSpwknCIJAPseSJf992SErkycCMZnhgEeOEEY8seDOp37VC85AyZxjGLURYDs43NvKVMZ+OzadrwM4QBXLFbgO+Z+oCcGZ0R/AcrjoY/jIzgRAMbJYWx1SWDG96bFm6StSJFc22XU0M0MuY3N2wZ+AMXfadmDpzNCxE4K0Y/HFDd5Y3k9I94DGE72AdNxKCxqkuV7ZPLiCeKIQlvZmxEA+5DhhjyebAJNDzGOYEb8azyDPCQcb8Ln0dniAhT5JNsVPq0DEZjGE9kWuTML8h5D1vyQImGIcBjqQLvyN7djmpwTlCK+Z+5/knCkaelbNhihjZbeShv9CZvonq+CRcCspaunF/T1/Pll8xDKeo258cJBhRWhAL27Bi8q87/wR5K2LXTUkTWnpMyzDTfY7j7jI9F5gEoBE4FavOiox9Fr/+wct5v1nTb917SzIDcu6ALX7YcFXxrm2KVFSbdAOhP+14VKvEyJuoPJamts2oSRKXqBUaOVfnSUy80kGIeXTOpWELkgGdLhhbObdSELo66qk319auyZoMM8LL9cRzxRtx0WgyjA2ZT9M/scJtNUh9QbIYEEX3EH2T/S23pNUar81zJ+uER42f1NRssp4o25l90GzuRgsUJkNs31knMVjkQuGn4swlpvMcJIPdITcZMqVrXLE2nNcKrBhP0XBJaXRliLHgHM0pr2B8GLfBs/ad9YBltuS4ac74ld2Joaa2/QhU/3dk0CP3RTglbZ+P3CixVebdjuFnLcc6fMjJjPycc0OC3cyM3N0qMlN/qJLxr4mglouNcD2nad8sQ3AAW2VHN64ZM9ngSbVV/7Y8EiiVFbb/VQQatU5jeU/ibVWRkOu0o5QSrNCMBwiJWif/bF//eQ1j9lOu7XQ2Cdyd8UJTE3Qv0vMENGRemQwIGjD16adfKm7rdn3t/J1r8ePpTX8tHKPAbAQSrI8ZJBhQzv+bt112Ac3MKal9R8GPl5EIqO1ZvU+kJTzEcXxFFl0YppoFHJ2Uyyj9rymLxOROH9MEwXZO4hPKhdvn3AiOyvR6ERakphvZgFnzwXlsTZjnVpCL/JMjnSOkUVPHmHAeMCk9iN8DV+DdTloRR5VDUDHzTi1EAMaKqLoe/ax/wM4lfGpsk3/jxqJ+zd2GuFSXHFAvxog+QdlnRe1v/Swvc8whOqIXFg4EHbx5/7qHE1cBvdodO7BD4UyMaejybH1jfVX1wNVvNiUHrho1JS3L8Ufo8XBzTD3vF1jtztxWi0ahAaKYlISOdMAoknoX2fugfadVwy3I8JcMLDv2wzeZ7U9Mlb5pudS6R/LGwURoDloVjpdO2xpztzrV7SOQkk9AZiYDoDL/Xg3BQ7ZZp90UEgSgse3th96WIDiR9ymPck2hSwx8YU1Oq2p719WjdIE8b9Dt7xb/v25UANsRrQpyVlZSiTxWMMZfuGIlCj8u5mqHIU9ZdHRFZMSp5gKjwUkGnodayhNmh8KktKOemk/s+kIgGZEU/Fo/hKxEQY+tDBmN7YH+xQ3NRr6RThcFGB6nUafAWdr7aaZZW0n7QSJE3i30lFBxtZPl0kF4pm5CMplMSizuoqpx2C3Pxd2VQs5ZOCqu8awOjEJEzs1ILjA8bHkZ8gwdPgYYwm2SMHulEs/WLIecIdRV/g+Ygvbsuji4ftEZkJJVuexSLQ+Txy704xoJZErvOZH33l9MoJUO7j1D5L4pLPcmH3QGzGkR/skmZC3eFezfWEMOHs/nnXxkdIlHxZZ837t3lOKbjH8co2Lil0GkFCWtA8GP59OKcvlVgDcqg90zgfQJykQGYHvPHI7ICoP4YnAIAKkJEvNS1IUMmD4r2ZfWlErhLTJ08opAgws/KRI/jhYwYqfTPIMJGLx8WgLh3P/1VnC2qHZGZAcbDydLHLW5mLuKtWxdaD2VpAHVR6vNqaF5r2+SCLee08LPcIx13Zb/d+J9TbjyOSmrcSUM893btJrwXivEPUE1N9DQEdWpaT2/TxkIwMEDaZge762uPIjN36dfgW1d9DSHoCUE9D79iQA7XoYaZbeaKeogfvvuCcXObmo0+A5Qv+o36DaLm8AsU75jczVrBfqBZOomnP3c84oc4AO+nQsRFvjSTwUzKagYnExg/GeUmxfyvUERBOLDcF2TTeBkiCoN7KYkJszJkOSHpfHjPt8zls+/Jy5B30vC52Jk+gaNHA6B2OiPaRae7lIbBkzxAenzUEp1U258dBKFeYC1Rb8sNiQWk8mjx648svCXlffsRX9Iq+XQK4062+cZjJTJ1Pv1yar9AquJ0QZ2rlNtVRk7+CiervX2rM70xT7KdXTT5GhuYZAJ4dfUUv57PMRikKBvAvCtkFeoOo2qa5DiJXMTQW9Tv6+pKKNrxmXO25BlHEtamH+ya5387UnQD2rBCBZGh68Gz35jLmXd1JI4WVs8nwk29owcf466R9HY0Bm1nGql9PgoHxnbzV8k1NlOYckSyydUInNRB9pvMG6083BXOHtJDrxf63hWZcxPkEiXStehZkXKJFQc1jvrWi+QL9KwDwZ8pcD8sQ5CfxQ4tBi1nkkwo2/8szZtiTzmRpsHw5n400S23x5ZfttItmrlP3nVi04o1Ohyz7yb/Oz8FQ3UFrsaGozI1IKGTHAoHSZvcUaCoYIOlUF7Rhj5HNiz6HzbsTSNcZw58uUjRMv4AZvtfOKl5xeZUs3RyNSe9lSlzK1QDxdGFb7BiwO2Tml0lN+vBRX7skWW7F2+ufoIhBtHbP2vLgKQeuJ99JzkLE19F85Oj9aoHEouSAyHMw+lcvuynmncs7/a5Iv4GSKyYrSWZ73lJnHDkHxQE6apJmjA4tHRe5bAqyGLziO9Q0wORGWTlqA9/ShZ1/IFIzRkQQHkU9JMhbDbNkt+dVxwaOWbM5wpJNFce8Ws8jmhjNyn1Eqr9va6F8HnStRNK472fypV4wSF6vHW23i4Oq9ahgQQ9/JY64AeeHET7mXuBOQi/NZqGgyXmNc+MENafYkg8Km/SOYBaF9fj52Tq2gdK8nk0HTI2Fm+xUkSxs+/sd8IZdVgWWA4i6m0UG0HOMvuSgVEbiopo/uh/bW2AyB8A/gD9x1mlB56HjV53bhn3qf+HBSUblbvtd6gV8k0ZPG8+P2yjYDQujvxLw6cW0pD79OoqhT0j4I0oxqDygEJ0Sfz5qWKKSA2w0xibarq7giImnItQuZygs5mMHDUWwAJ6bDnVpANW14xFvx8XcOKZj+f//+44nmAWr88LE/kY6ZwsrmEExWamwCC1o4ZF9I9UMtbDXiCOVKile/d7thVIYnS5q+smNkFB0OOMNVQAZdG+mix4fS/Fju5Pe0p+qw8S3bguDlM4TGCEDpiP7vDc/1+yMt8vmaSKC57p2iUWCLTahs2ds1CETdkIEYS41AboJ1et4uPADDwQPkoy+XbDRbFiSijv9/YycvtYgH4PD1X8fbSInmXexvPmw3XIiIojnwGt18zdq3TnV7fgYer8Xn3jPgLCkZhnDTBZpgXcYlRmOYASv0nJ17Ud7NtDI88kqleEQ71eypi3/bdl99M80s17LKc1kOFoOldZ3ehju+Zmn4MgDc3QKsjVmfWoLFyh3uB5olEVePrIiJINPTZ9T589VIqfI2CeXFE8XGtoLK/iaBLP06mTqoe5M8j6/XSJ7t9QXzyaeKZllleCCawdgDE8iBdBPiPkPCbxUIrVoRQ4JSOY4PtZ9yBOQSFLu6kszjXSbpFfzNchIOZHxeEH0fxFkZYQp5H7KQvOon36RNx0Vpv4YzoTfifCHFw5OED8eO6ogyqWeOTB5CnOrnZYTxJaRV+obckA1eyELz2uP66Q0MJ7nk+o6r1jbalAZ9okctfpTzr+D1j1jipl1qtXBOshKJOqg6z5E0c5yqXkUfJz6RTLLh0CBU8wXO1zycefom8oAIr75F1U+i6dPzIF9HANM9qmQo9t8vG9F9Z3lak684OAwJdi4lQzv9pg1JTdSvAeQFfM5h2IIyfVgarQqpd5UwvL6/QxJJzs+TROGEYaD69ClqO3HSUMaw2KvWxyUOLcvYWvsu+17xgtZhXeh4oR00YbiLR/D+70Idr1edCzglgY4Fgl5z/H1LW/sLSLXZYCvoEjDDL4rXPXAKg26CnCReJsk8FszKsGTjBknsPauLiOFUDMNwjP+JbIAh0x6r4FF/lpXNH3RPciM5adBoLGNLvAYo8dBtmTIVRJr05be9nYakNng+Gn/rhgOAZhV0IH0lzXdBiB4q+NyT2IwI7y+Ms9nyeKSwwn8Tl5K+xFvs11hSdMuhogxJj7AIuvrOzQBEDKn/cCZZgb07+Oe1hF2NytEaVkcdUdukyLE9d3GD31i11myxVRoh5+XWGQ9unwg4Pg3pcCKdHLl8aAUIrWcjJGAJJccRxbPIlwdnRi5DovEjkp/ooWRDy/8fiTPZ7Jeceifmj88Cm2HY/CGXVk2nDeLuoHV4wTasqF+Y1vNAwIQx0i9Kkfry0pwcbw3C3YS1Be1Z7dVBMs42zZHZQGX2mbnROoY16VeTBVo/Wpu7Qj6p/ag4kwXeFS7twvdfM4AkaGsiI0z5MFoZI6P0GImskaEzoGxCM7h7p/oCk1lQyER3gRLjSO2IU48b5FIxX/3rfH0TT0wEFLmoIrbagv5kAZnykmMgfdWNukq9zHzCb9dQqApxyollmKW9gvb3GjOHSARqh8cS7QM3w2da6oILRZ+Rt4GaPs4Vf5P0q2Rjk8y9193NGBw4352vzn0Zeje408dK1AXAks2+bthIbyaOuuj6t86O2h7MVEwzFWLYPjBcsYnAOrOB6i+0Eq9UlvpZQcMAhQWGBZpktrbWxLxyUy7epkujtWojwLQqUX4pzCkA/wmsCfONqQDXNomhncYmhVne8lnt3TwIjpa5KWfHXIDD1KhPjEDyk9qtwSMURxocCbbGIey3tRO/4WuLp5HIcXIVxEt05qSEu/bzU4RFP6yRuuC/91+bm6LheiuCDoPE+sVS1lfyn6m1rv/EvT/gar78/1J2/umBL/67T5U5h6V0ZzW+4Q5+1kRK9HPvW3tHtBR1tlE0OqpQpM7lnfo66Q0ZIc3GuHiky6Mtt+xvxx+GdknqjvmkLqKe6tKAHziThT3LdhcW9mPkYrFzU8zK6SX0Ivl3Q89qeNtLQPkv83pMQpcVw39Egz6B+CNtjbTw6mLfJJ4GVUEXymUqX+mRiwwd+OXn+xvB1GhKnFQA7QMfYtaUkGuxwf0mAjBJcwRdNT553i/opK/6rbPPBhRvXGmEZ8MkVRDeLiijP6ZWgVLVC4hJzNBVwpDij2lf0IvraUM/a5OPVGoWB1G16EeuarTbqVdaKgH0tqe98ezTDBM+Tq1TdA65ss7jT5VYIUsswSQTuU4mok4HGd8c6ZPF7U4o+NwnmUAK8OuJeWKDDx/kquUQJHCDrIJR7fX2uEh4K3dw1DdvfuLNopPB7H3JuJZdiFxfi5zeJfD9IPPJxHs0pUa+IPFB1bRu6wPlrSwerU3TKUloe8AkgO+KbJRgsZuj9DCiZbyW/AozBtb+4OG7RPJif0+XrhmAfLCz9HrzosmRUD+8L+5sz0a5ueXNC7UZZs4O8SJ5Ma27I8w3D1rxN7n+kAiaqp9HplkgLZX34Yl4UJQMRJSRkNrWZhjObuxqCMBgVROxSeXCV/Gv5OT5uba1TaA6fvpoe7F355MBVCELYAikALsJMwcK1N4lwBYtJoANC85NnnLT4B3Yh4ox3SX1f11HA2JEjIsbFW4V0dzZEkuCZPvKlS9V8ZYSI+px9nEC9zcIp1RGivBk3hVlK7Grc7D7BV0LAqqTB6G5m8znR6cNX5aIHpPfFgU04EmgoTRw5YFB5BRw5gJNVmVp7UWGuXyuWJR91L7CCPyu022Uspe2zIo2CrLtt5Bo2MXcOE1nx+Inaz3MjT2Sh0RRlNgb7DTmAhnV8X6jBroolHpT2RZ5VyyyZSeaaXkslUI7UJ8XFyG2MSrUqXxkQu7TO37Zp1wTOR8M3sw0mboJKu1DGDlQ/5FB0OM+7r6uiBp2kNORDe+hcrs1gc8X2yVUZJwRaXMlJ8pFnPpljoMUIpSZj+jLY2K9wVtW+GyrkkVUx9jdLLivdMMGkia4BcE/8ECi4AV/IjuR6KhvLEB57e2PseNc+bH6noqYPtqsYA26kT6eSa+AEyqOONy5kAyfJVXvNk/rG230cO35Rhb1dzRdPc0u28uEGdMFQ9DSdgsiByKP4RcRY/5QgoTHTMXH634md6zPawJQh34CyqgO8t788ry3OQPGZYBOJxDHOmcScZPU+ILPObKXKRT+fDIR0UKiYHN1vbwGTnAMUA2tN04HnrKqu9kAa9N6A0/awQ+eRLnLPLThxIUHaSiHFN+wKCoZIV/yhBZe0CcRm0SdybtqZnZz+u0lM+tzj6ppUmjddi8PBRRPgK2BbKe1rVPm9zfrIM5Z5TLRUMnpFbo1Q6JTzs2vqxPNG2PT66cptzLGdeaitBtbRp5Tv2B0sIhFb4MBB14i8JqecbmTpMefcLh1wKajzVJjd69W5+NDdSS3mXbYD4A0Vq+NAD4AosMO4lc8Thu9+vxOpgbbtl5GF8Fqn6n1Ob6O/BN0mbS2h/AGYvDJ4gV8zXpZ6g4tLCy7Fm75QiZY8r23PrqR38ZbZuQDrCDXPZt4GaLkDYNsUoISsgRR3hQqFNqh/bkiSrnPTag8nGT5IK/OAzpIuXtmIkahgVqnPnnraIppsCGmxGlofQU3Fzgf+K0vUGvBp7tSxqMpd7grf2ZvWsju8v6LGKWrPHINvTydG+SnzbkH0TsxPTG9wQ94rbE+zU5Vpko0JteKD6CZz//lRg9FLSAth5E5ne2pDrzLLnN0JehZyg7NvD2HSJGHnyxtHW48Dx926XneTe07/yh8jdPAyb9c1T5iP5B0E4GBP0lR886SyUy4mVjiioVejhPYB6sOtl8r957Fi2KrVA3P3qzKMdH5A/z+1ewWRA9Aa2BNiYccmOHeBMcAwuwBTL1TeO33Iw8vRKKe8scIJCm3QZroiUF02v+OUXxt8zwi5L2zRx0b6JAQ1bQkMJEewaRjoE741bQi3572wKUNSRG4SZ1bz5Hrjp9ULNyZFeYhE53Egxv+NQcAIW+OsmxxI29kepHDTB2ny2mxIdXElLPFbqlFFdBGJWdsRIULZdiUgTVtFkK8sfOeLv8dagF6F5Te36vPBD5bOWzJ61xioIFfSqoE3kpQgs4o3z5nI6Ou7ii/Ag22zxWO0W/z/OhpzCt9KfZrt+hFH9kL9H3i9ejWeIFnAtz513e/ojjzUk9bfJcw32yXYOFfidbq5w/pTDd1EvXWJBsQ5ZJkKoMaZJL3B32Bbp3Vdtt181/j4yyULIY2MNWC0Cq2atIxNLUEjGvVwECu74X9BeX85deiZDx92gzyleO21CiJVQAvIsPr/hsCeAB3/l2+z2rvoZj6VCTA48PW6eidZ2LgPYuBIlZ4zvjbeE+4EOniJQztycSybDVDR1qQYM2E1lTJIq/lk0yJ9tWmtpbtl1OX2Xf1gBMrOFf6IDb6wy61daMaqdFiYpI3Lreh0NdVqCAEDw61l1uXaWkmRRdHYbQ1uzP4FzGizEo5vHnc5AQsvs9lY4NufZ53m/kvSiXgOz1kNm++n/WnKGCOyUeQBk3f2V7qQ0Cd5SHY6baVrWOzwq5ISjO09gDaDLZ6AofOSjcaCy0FihbERTBb/ufxCm0w/fLhRl3fFfm8os8T8KVfiN6QJQ+t8wz9foGOYn5g13i9xfKlAelVh7611bhVS4l+Z8jq4bQtykOtR+yl02BzTf8AI+iDXVQjoRxP0IbgzZHYYRaeeAkitSdTH6JRz7+xT3m0X82UlaC5bMCjRMrrNv3+lqpzF/k5QPkfz6J/W4kM0/24dP1ifaz6sYK65olOCR+7tz88jJzQS+pAbUq8ErVunL1Lpvtw8HKYPGWm7H5IHCmfj/dh9alEo2vS+jUCtpuvu++5N+OCzMocxRP641PPNyKQFyKO636evzpVCuow4IpET7ME6dOKQL5TY59xThw0wzmrkMKPwFk26Cu1IUnsjsyB6gcd9H8e1XNpwyi/Q1flxPgGIpw2aRtAnFmAdMXhGlze5G/KcIx5VSGxbomrsdABHGAc0hfw01bKaoG4nx3iHeiwC9bZ7uBp99qIk1xmUOkxWy53S9/sC5194sKmng9SnCNG+NLwW9cq1tsRwreMuvB6wwdJYx3fy3d4zJ40QPUAEtkhGIHYV39jE3VHdmAkv3JxKy+T9ivMQpwBdfBKgEsZbZmCIOFDbCt6Zeu3wTyS8g59NquwDMYLw6oZqnTBZMlfkjVN5T47WeO2/ez2eIVv5IcMOZoHgQZAj8DUasMIFrA9sSztM+Vw7uWWe2gWaD7ldYSJoo71z7SLVvQSz8FjjTNcxeeYaawkoA70JJIsHp6bUoJG4sptv36TkFcHiZpPD4kGeUpgOQY2mxLUYVJriVd6AukIxdbHmfceD39x0ga9NXqgVQrNf0Qpahoj04ROaFZnPH4RExl5gxsFRLhsZeegfqHIFT1qaRlLnxFBccEdkyl0daghd00ig5qbzSx5Khxei1AXsCww3bsvyckF7ekbg5AjcdgcKAR4w/wcm/75d1LAfFy3nj/rf/3wknQqULg+bvEeFR+/raCuHdMsbOSjbv35HxUY+eZJd/MqvFRhDFHo1hwupuAgjylHj8qccOjFM63H0KFwyJS64evpkTnY6KuMSGXtmL7NOGYWKHmuqGNQULbuhkpZ3How1CQvsr52DG/a//h42S2jXem7ytudLXqzlK8I7/Om0W2LRDyTZK1ZHocnwrspr+64FUAg3bMU5pwVSPHCXjnbeLs6WDW5qB4kkfU5FFce58//Lv16sUZb4SrHLYX1Hlio6jaqulGiS2jJmtzpF9WwBWj0jtk7dWA9qw4uUZoKgkRUJ+47PpRJKA1OHNlfcE/ywzak13gw1oSNM2/e4mliRKmpzW9pPGOFbHcWJT763qhuLiAgvzwF75K/C17EvbWvspZhiIgru3J7iAb3jiP2B3SUmBFhTbOg9kgI0He8pNCNKaIJpvETYZpgOwHqRK//RlEN7DIgz6w7iOQzZaZ7GQJKVHmG10SfMCIr2YATjtwJKPCdxbSYUsFHMA3iz4sOu4hcnn8BiyFGfp2cSUe+XJC/TrPt+74devNYNlLcyjnKQRIO0hhy3Wx3ccy413vWBqZ/0bQES/KLHMdpCX+wxtsZPObwAdlyBSAfPwqZxavmusTyD3Nh5dJFjxnUEBaEIp8UXJsrEjATJhP5pw99kKJTXebeH1QwoG1bgo3nnGqiO8zpGDLNpzl105/w+dZdwD2lYZsb6cceI3mHaZuQLL1eepmeg4HCm3H5Kz/aOhNK8Tg6q9vdSljwGLZXLBz2gK1JHyHYD1qWZKSRsB7rwXqknyCMGA/l+dtCStfIslyTP4wAZyR0MzWjlOlTRqGjPbd8DPVpRHxifMmenGzvcxPeqt6s1BLK2EpYr5C1UFYDzQwB2+nmp7RJ5c4T058E1sxWDz6xJy52x0McnC6lTJ6MUt12xageXbmh/cOb32j3G2HyJYjgStpIzmJVObOj/w/0JHctFO2RH7nY9miJ7QsJylzz87xENru4H6gyHy0biOrf3Q2uPNJvUULRYzNX0OQBLKtcM8v6PdJ6H40lUWAqdiFAkoIwFHCSGajD7Ry5qFdPpdOz1eUb6MRdxYtU42oE/PAKYE5GC1duimhWBg5lzdo9x0MNtMIkvvAbmotOYIBjYzf8c/wTiZgXECzJCGOYOAQZxv6YV3XIoCs4EBfJZRmk3otVo/AQE3MSja2xM3GH+Pwj0k2cu4nvPAYosi4yCk70ZvH2rtjRQbN5nHi4Um0zqltlDHstEDHLN35BSUU93UM2vQRhQ5AySZWYYYXs/AIHsQVHcAs4zlAA6ZUy4+C69Oa5huXCkyLRAIRRBr7s1limII7c6qqes+N/U4nuOypZ3BeUsdC1S+JhN4SWoRU1nJtTJyyHDWkybeeUReiO+78s9CPCULU/HJlMCppG5Am8PpDBMKdbyBgE3V5jAnF2NhKgioF4g+LIXaSfAvJ2WORJuVFlB4fSHFVy/K9YbP1JLGYrMXNTQ2etsopoLzI45xHPQ2RLfopRelgo5OkxmtGVc8+HJwsRHKBjgTpBnYU2cP4wnYH9LAxruisaVIRiT+NRI1PQDqv3bKviCYyGxotRjVIvHyFdgp8DIGzn4mHnxsR4zUUQ1vXwmIPb+Firb6vNo0MyubwCuwveZoNQQN7nh+tvRF6EYL+nmr729XfZeFC1Yw50uOZX5Nw98Y4FMJ0nFMgol0MxMGzU+ppY9LWYRe6ZMJOD3tCJ/vEP6jZ7Pcwv5ivZ5eMQ4JvA0sGPj5xadkKjcjJFdN68t9IN0WX+CcZRXvk7O+JLiOeTk+bC+wYuVjRy5Ns2P8gN/TuCamXW+l4mXFKUyJE0Kj6xvMEvahwI0jq5FTuLeWkwH0jKVG43vG7BzVIerK41JIjQ2+izMch1ITQ34Et0Yithtlu6CxZ7leOFlKBnWUfkavw4nBaAVV4wjojw03sqEgkv+Bry7ErHIiDdPP1BoNcaiHhzhvpXq+M9YC0xCoqfZOzILvRc9cJzaTnIZXzQbrEOIPrgQnhjPaqn0pWj3gOepn6KKC9uQN+ajudpTU+gCNRXVJG4I15gE4UtaX5zO74T+A8DXmeFxNimyA2xhe1fbnRL/kkbvpkLuQLyeYjPpv3/QtMbeZ6J16oRs/KFdeCpGUXgIMfdtOiXQATfyA+jKO1lahNqRzaLEy/U+v1gesI9QMxCSOIErLP80apOn2x95a0HdBI5my8vusqBl36d4lVFUOhyN5TClykCPbpMulJQNEftQkeQjbBjBpVhgG+1S8ZQIB0s7ZQRY5nw3P0rnHbPamP6QPScUDPpKXElm/2ePhS40hUzzOUKwEsIeiiC7KSdvJ6Uw/xjJ/M/uyL0lPWduITVep44tle4k9bwx35kMdQycw+wJLdOxzN/+yshU0EPo7pz5Zrs3XGM1EuxutZukGNjoOQoBNARbwgjbyDzusJFQL4IboKGkbLGY99JcJqPYSOLMFewnLKxDOKHdpF1mwm+xgvDGcaeKKFKXD4cHLsHGcvol6kgJCooSSHqmy4c+aIUDQOFrSYfncvCn6BQTl5l7hMweQhZDvcJsCvUR5aAEiqSBxsIJZousm1mhxmxSenREdat1QKwltfCIJaUFgBiBojqJeoJe/v/vYQLWvSsR810JeQOBYG1ut2X1MEfZyij4d73KlmK3v1Vav1m0O1AVcQhT/RnfblbwUsgX+sPEjbRNaY+wcWzg1StScz9zubYQhWBUKIaPKm/sjFoZSEjhHrTDdUtOZFOXNizMi+haIR68utp+gEtyJPMVlu/sqvHZKkgeQwT8XPzopW7UKNZ85riZaei3h2jVC18bZ5o7XpyFDnDMWaZiMCPtsczz/6aqt1VZS9aHT4fNvhoeS4VTBlhuHv0SENo24ZcFwwdhc5SSJ0Qh7dRarnTu1i1unjpu6y6nfkUi8FZGnMWF64N367tjEPjS0/emqmZug8OjPEILi72c3tU/ylmCx7kCQvCLpm3Jqj9zJ2qGGGi6pj0DJ7iNVmyTxj4wvhbhS1jxdwIgdPx6oIxyMrYs4pMZUJjejJ0+lnB8uEi/kZ0NZq2gayjloy94KURYwPkQ6tHl4yhG21+f3uQ+O8OEASDYZYQJ6Dnnzqwr19HtWfBduJYfzG4BO49w5eN07zkP58HqIDsYA+OYj9wWmQZRC0AQktpU6VhcrChuhcpite+yv3FM25YKM+/utP6HTyT0Sl1AFDkX6lIzcm2iAabmK+NA9+Jr3MpNqC9Fha8GEfb1ha6MD5iDZmG0w/L8N/tLv/CfJp6fMjYP1GLM/aFiCf8XNUKwYWYBaeowylDku5vUbSRqNdJoCKLKJ1NRej0yKOV5DTWMYuboe9dGp4Z+V2nrFMvy4b/+yHi4S85zZ4S10sjfxBVtt7r9Hd33Pfe1h/LYj5jqaXGSrbF52rVYkR4dOIOuLdlPRIY6eRnVnLL5sAs/uLvFfgPqQl4XVcg8P1LoyP6L0HaIqzp1ODXUHMucd0B6/knSVZi3p4XeNp7SfJOadj1XnZQc7DdKW0RvCrJhIubIp32Yvwkmr0frttfJlgQ7dKH2Id+OakuhfxZGaA8vHSJ53DdMXruSBAvTi/u9/MdUlr08LEYgil5GqZswxKKml5OFL5O16QJPye2Mzbtdge3PK7D0eGdDBd53nXjiWAwRgIGqtYjCzN0d2JkQYTI9WRJwa5VjrmOE5Mo0Z30y3nxgE2zX+k8OgR4qqudnSlK/QwsaSBPNpjCHlevBpHMUW/FUKQdKv2nPtHAN/uFp4p2hpQqYZOrtt6JBzvSIXKr9QyoDCeykI10HXPIAsXoLXmVGR91I4Q2vWvQ3aeuw8LIiLjgaVye1SgCMjJmhOSbn93GdOBvnmCuPp7Qq+OdCp3nH1ktdQ5Bp+QxAwNrk+64DxPMt/St20awo8hRihBvvGcYjGz01EIuveKgotOmTTFoKdOyTO9SOa8LfEJRiKh+ADJvclNxf0g+KddrTr2jcX4+3bJ12xz0ju9y9lQ4Lx+Hx97OgvWaHOs+8n/jbAhNHMeFbByXTeZUz6noQqS9tNd4rUhRmTyWq3DOtfVAWJLxjF23sEq1NTFX8PFX20Dolrh3aC6IZ+RMkpp3aCMlC6D0Msa6rDA9rSi3J8I8a9MSYIfQyIstmbn6KFXxwi4/yZwDQfF1g730SmcSHjodn0isyGQ6b9ku3z3yx3WnnV95v9m2sqgP/eT+0sj3twaU+OLVyq3laZZDjsFPsCQ/LaiZ39n6cUk9ixQD/FWlyJJkErUP0CgVAeY5nfV8OgHBZ+giOuBwYRUkgtK0cvjSOL2QrvOdzH+xhbwLm5eghTrWZ4pCJAI6DXpfRL3RjTBZWLDmReE/03Wx3NpGRd0fY+5bFEGNNl5F6hotnwIJRPMOukkSg2+JMTn7O0tahYDBG8bhy6KzYgKFWK2UwLwXFEsrY1LLaO8wrsWgUHCVZYVtlgBbUL5aZFcFJwAnrcjA27WwVYKhMXt6zUnQdVUpkJC+K3UhZkxKnBl+RuR9uXNJXuNgFZFlRCBN2MT2eNGj0X/wTdtBhKV02bVgBzF9gyUo4miYa6gxfvLZxfPL/eYPlZkX/x4g8EYlRBs4AoyWbSwAZCQtST0wnrYLTx5qPpbFOvSEPABXohvU/6tbYYDR1zZv60IQFWpuPCoC365Xj8mKhCpuTdyk0ZCK0Ypz1dKWgD0nA4iR7nf34gEN11ZpRsaKR9r2CbwhaJSzicOZb+/niYt1r7ZyVy/LxqqAIhSBgYuD9RMjmmNGsSu0Pre8avrby4YZMayEnVdgTDopUA6Gi7Bfsx68sQRwkfaABzU1ZgxaYRK15Bl/j6WxvsLb0CrCW5W/ak+efZl26lB9VD0ONw6bcUOdGROhni+lntrVHG3sDM6Mez/+T3in7NN3Z2JJ8oGZ2eCsQzMhkod23aQrOcI0wIITNidMGPJTuzPFUp8A6Ip8NgCsjCfFxOdC4LkRl7c3YLAm5N3Nk2XcK2g/EaC+0vqtAb/W4EL4biCr/sovlFFgKug2+55A2LVcCm2NenvgvIlZ5jRqI01AWSWu7ypucvDVjkdGvn9nMQPHwYj1URazVwcQOK6Cr12YZu4pB03PHcjd5ON/z6Db9sq2jOXX5Mc5BUaEEhgi2qChE31aEp4a3XmF9f+sIr8app2XoSZZETJ7YNCmkCQcetdUfiBJxBi79xn7sXF9qeQrMJ2B3+E2i2PGwLM4XFk2DJAYMOSvMpSN/5Ju9U9hy9ejfupN7VdEC/lahlvI2AxXpJQJXh4yTREBqKx/XDaqcB/vfUOr/hgd5RSKEUg+dfqipALZ0ib2CVOFeDsFBNKOEqWqtvWTFnZUXd912SGr9d65E/LIirKcVdhkUi9IZU/VCEGOe7uVk7TUazBhNtBbhn15V6AyGjHsHPDoBwxiKIMYPRcwUA54hdMy9MX41naApaOjiPTOIuDxVQnNjRslzOa8ctJZXhqsTfAs0Cjd4O97E3bVFFSrpiqxcdXbWslTh7sigMMkts4JgEPo8s+S8TyboxOfb5vVXBzAb3vmd/IO4FbwN0kLvf0aSm0UjQDGIz0qWUr2UwbhXi6siX475V5HCLXGjrK+Vb/Dtx0o562/c+AzIgebn+ShCkS4VplgXzW5iIJmKihAEh9mx1yZHHhZL+YMaStV67ZLX1OMfQmUciQzbpQu+FPbze+KdT+1fKpKKLAalq87lyAWpnON3JeZc5jQZYOlpSu6HmmeJDHQ5lQCJfSaqtxOWumv13kmq4mevNTKzXbVqNh9XZgDeY3R2HVkJYwnSuNfXpVMsmRZoAbKjghCQtRhWKh8NPUVpYoaw0KK/ndFZI2J0qrDOVT+3ATMiM8EjA00BlPJ5zJWqmE43cCTtMsGn5P+aUeD9KyHEnv2XhPrl2if27CxaLrv1yE1KSeYUaQFKQPAzQYc+E5K7YZtrXeGPCSjtuhI/Zs3G6l3FG2CoBZZozwracd6nR22sJTKrzFkuXHeT5cecryRTv0GS9gs0DWrpkIjVbcZcJlzZf8VcAqzv2lw4k+r4qbK1xkLrb2g1H7ypfLoS9+EVxelMwxBqer4HToIqBY3ybOSWDxStS4CgGPsvANKhzKQz9py12E0IRySbfXIZ829+tyJ8COl2ViB00He9TEaTyQ68XgUVXXjw1Kadt3mTv7n+qm6/MxCNxi9yPyXID2b8v7bbjeUf3jEYCIZ1xNPgzeBr+lIgkugAqdjSbvNOlGT4p2aFip8gx2eHAA97PpYzgp/hcalASInuZGOL+RTz4TIW1uM5wwiAXXEHLKNSZfbxNQgrOEGd4zyuTb9I8fCTwYkxqfSSv39WpTxBCI2t5SbriYXJrHYqQzKMBE4w9fPXzSXw6/fb2Vw911h6M00IayDEIaB7UrX1M7Yp/npz3lYqWl11ysZH2ZUv9cgss2LE1hwc9s+xqIeVNNe17XNIPMrh1ax2AIQMSDAnF+sZsoIgHiTH3lCh4VgX26alJ22ckdjebnC2GKSx8KWaNeudhmlGi9HyBYb2PFJPnDyBcLB8fUPG+0YOtuo/+oUwjZFm/7KEFvUwdNZEYBX30iDRYpZaT515KtIltqkYqfxAoEMY6g5mVkJBFGtssA3t9gR5TyWZmbOYL/AvFJ1Y31dEoAeXmgsr1RGBMeaOesZeiOiDK9P/cYcPfn140swJNeKw+swksrELmmK2Y4QODP3IZhdvL0MqKikYX5sO/0aZZUA4l88LgMjykQw/qxtttpROdf+ma9blwFOCK6AsJ6DNrLo9R65N/VJGw8Fm5f+pZ6RbWL2B5SiahBQ/db0ZVxtTTjPDysZ1qY8CBsf1WAL1g2Hio2XqnCOHz6yui6//gt6y9rkfwi9avTvRHWwL8G2XKsOj9nusi+p5925j7/nAJGXY7t1HLHfinasJHWdXCB4OI/Lo2pWHmueInPcu884BaYsWJmW5b+PUcyr+rT2JNLR741uNl4n1fEBH7/kq74g5ksz2b395/H0bzByHMG9/7MKrpbEWUOVpRqr9aIPG22fqGM80CCRCmZ6oi6PmOEcD2ZBLQ3cNNKjCImqzYUScBpBA5Wyo3Y70DA6TB8d5cD2iPgMjiwRUd7zKq5AsDpiVmopAN9PTjuuuXU9uf9lxnwsjyYwSkIwMEupHikk8FN0Dz6aYB7Omgztqv/hn0nrSihoIOI2OkCVVYON/2PEHX3pwW4J+q3h6ww/DcCPpztXNp3Q6wCS9nsmIcbeaMsZwM4xveF2FzqoGBP60mYIgBZTaeZE1KiKmLudmdLgrbK61BO/oCB9WN0uKijNK92lmpgBA4FWcvbKtXbaSrtMZP6kzZGgQj4AdLJOiTgAYDdATe+SIX5RVlZrX78vkj6cvav0AKM44MW2bWvTV+BENVqNDY4f78USrALrgGoobJOvl/Wfa5GpPsfFL/w+IOgRC1dX9JaEUzaKb5pvIC1OEIkVJ6aYmhOmeO8VcZUzNeC3vbzAV3mio2SusPZb+6l1oweSXeuG1bDgAVbnh1MEkDq1S82DYtkT4QnW2bQRpcU+VLS62sy8CBR9G/wgIez63WVQoxFWHjlvHu81EZqyAnpdzn+HwPCaIbev2pT4nbknqOixrBOo+6KFxvMpCkB4dFMJLQSFha1DV51t2NQKVmTg7litJ9OcwnH1dQqTo9fCU1dz20iXuV+SyyQz75GITX+J7uk+gmlHNibg2l+1mwO7SXNytiHy0I5s6/ID/cwOp6uXwM5BSFoWZz1udE+KjK1Yyo7e2kz4fkeCMN3ut1mHyxG6tjpUnnVLqVclCoFS5ytLxlScovjUKzbaYZzTMQLh6F9c/Hl479Fi5+qB0va7SiWhhrw6VKx7ybLHIfK8aO7rmgAGDQZU1Tuv4e4D0He/nLHG+2TEy+aaCJ4OzK3ljytcvaYdhQbnPPVDTE7E819jRK5MI3IqBYy+mov2kfFx1Ebw3WK+VneCKXZ2uidt07hP00RuRA78oGzJte32fEjShjzaMpZb2NtFREqXnyzja4iA9sKRn9qyiUt4XTurgHlYUb7AGVG5sP5qzcvJ85iDgk0lBG0IAFO2fq8Q+O+WnyovDgfI9aoZyi2an1ytk14asDRN5JoaYTq1Pw4vCh0bs8qSy5VXhZ9I4/5n0qFev3foLBZCx6d6XT62UiTZR4W3Zstftlc97FfhTSn88/18LQJnjgY8J6SIu39VxPBmVUnr9vlTJc1qS7+lPNuBmv/ks9YzNsXL4aECwfzN9V+59AxPMjAf+rRHw62KMhNh6mjaZSykqAhgYxAmsTxe/b2AKpDxdNRcfdBK0Wz+82taU3Rfh0UAf2X5uSTc8D0iDIlMcvOsv+2VoxhqxlOa8fXMSsHZB5nBz62mEiIyCAXN7lgnGBiJSQ6kzpHwKmuPq8AcF9oarAu1nTcqpAG1PZLGFgzCtOX4XJ2OU1zfnVpbv40UoiAoIREmc/RYM2+jOBcN8ewT911toW5hPOxG/q5C7V4uYxqIQ0iYoWtgHxihrM9HM1iBKkuk26Bz6GIcyP6qdABNZn9eQL+u8u+w7aNTOgoIYY+psMbeaxJ2S3ORgIpFD5sXRPgoSOaiblcnENBx+ed1F2efPIttRo8bE8hrxRD2AKEWe27w/qi34dcQTMoNoMyTiBR2CC+EhqQCEl9dn0qiWpisWVcSJNaHPwXIzH1fDkJA1oidjTFiRRTvzOTu2A7WibU2OomOUDBgu1asHmTtQyYUF26hRCFMybBX6rKke0vTTHX5V6gXGuBYqWHpzYzDkeH87GAPfrqtSaunsxmcq+3uZzpqw8Kh5WNHGCLZLwGW2Y5hT/FoERfP2B1SHX/P/Bv2uASQg4R6rRdKOiakrY8WR611ffRSld/1xOHqnapF2P8kJMz68aik0d/J/c0lFWY+Zbozk1DEF6UTbXtwI2qR0PctkQIRPvh57nLsKrIABvca/H5+fpRZ+IWxR/9dsZ+u1uXCmp7kJchdvzr/DGEMXZavSCgX5uIM4FXbQrfBMGWYbgDdihqlnae9mMFnGuUVma9CRRuv39O14nKzDiFhTvzVHmj6Yx3n+M7aSkJb4v4m+sfHBl0q+yKeZchETuLhH1bvwbFLAXg1h2DF2+exji/aQxE9ZGd3IjGsnWFBMJqY4h5xOO34wsR3d/eQ5nOZk5fYRn/PrTyMiVk2FdlcPeqES6yURA8GDYpak8cF01OrvN6+OY5MvKGAUpklPKwOhJR7u1OSEhtlF/lwAnpcodESEmHBuLzRmeVVaF1Lq9xgszIoFqnju0PfQFLU/vJGKdAsNWezmqkpUGAJRKzRFAaWC5DaRyGYnsjWG0vm87fANU7G9IEO3FlOVtru7tq0bVmyBADZ8AvUg8cGHhHI6dYQBxCJxQVdsxcIBvWBCT51FZDtl4PRTI3d4E0c2uMfc7LRCPzRy3Jz5+7pfNZs13lzXsykmxpBJsZTlFioSw9i4l1m39YKLUgUVdVbjionUPV8jccqaGlvEpOLUclRtrGbV1WhYal+8IBtNZZOPqTIHC5Z2021ztP/54dQkjDXEfZ5602572b+a7mokdp3rU5jySsMd3ebhz8YByGGWhU9GSRFKo+UiMunki5tqRzcPDEf8ybYIeJLoakiVm/Dw7s75dXzALm+UFWrfxfr/7YWc6JLIxDGuc6Z8RtQ0OBMoqF4Mbzb9H34t0R1KrRtHKVd/PSExMX4+j1QAtZntSQcbVYuCYm7su1iLfhDDvak9go6NRzLg082OCYio5T6tLgLtVfnOq1xHActRr1C8f6o5d/RV9vD90V3Tp07uV1rsdY6uHmdd+rmJ40lkg29Vj/WvARIp1CfzwWq3DVtcn3semTi7uQI6HZR58Zc+5vt+5c/fKi35MX5xvMhjl6vigGcu5TdDW1eKvSy6GUhyY/nh9nq8tQRSGZIi78W8lL0MHWXz5+4FJ16SI0Fh5823RzQBCYaUGa4ZDrZPHVDZU4lUYDnso6rDfbFiUgbrQKRgQARioX0aZ3cLr572xebrJrVoKCnJY0HdtEhHilW1tYGFoTHjFbbPocOeW8uJLSGLtvRsLNawb1c/ZSfsZ6Zv0SjE26QyWQpACK8RecH2gT5z2rnwU2njMpD37LYfCrH8LiUFCRgSV7WBT7yXkvUexxNOsujGPOgrjqEQLQzbifR+HDGmdK/iFocR+g/fuUD8H9qW/vMa8W1GjYZt+OJ+RSjg/iOF6d59f1izsWbNBeI7tnoBO/KyHvvQuquedNPdjIUxFbzQ2nZwk0Chwa76mDEHmwZA0Ie+OB26v9upfmnBnHtNqTxTEZ+LSzziab44evVcDFB4il6mKMsqoyF16HbcK+cUOELiRze+qIhzcVC0BztcP5br1sXkcwZRLpZgfIR/KaAX6osK+iEBDL5NQPI5XGJOD5wJ4Lp/wFktuzhl83dBgtKp0zS1HiFdV7oF+xNcsk5/1DAPqZJWsMAsY/ckB/HyTDiXFNtlWzNz9T+bSMl3MzAU8uxo3Ac9S1VqnxQHtNHmy7Qt5wrPcBUMsMo5CUZ/IlqqjOmtsqCKO04svhcrsDjvU0kvsOTwqfFxtIJJHyKYejYJ7TyHyN0It7Dce9+1rEsPNcgjZZBTP8kl3r/Xr7uWiQ17rC5UCLwTbKOgkNo/b152x7Y4+Jd4x0STDtFeZYzqELNv6x+tN60mnF1QaAKd4Ufj8hKsU2HC9zPBn54Pazes2ilB3fTgXnH0MEPEU9bu+lKimkDDu6p/RL96ySqeyb45VKeZrDXtwC6u3x7Zt5h9gv2XwsnMK0CGkmNZpdOsRq27B9TgKSLOa20M9w8YrsZvRxRN04GyIZEhJZhl30HdEn43cYTdm9LeAkhC+NCYUy22PXJjaPRCWZQ3j6bO4UhcmQAmS/2ZpiDkBLQBLbvq4kGMagAlAvvg0K5YGrax8zPB5gflpLrRgSlPs5sOiHg0YcNy9Kr7hx/srDs0jTp5Kb2z9y71k8ayzUr1BUwyislDv7KOo6vsEWEL+W9Fk1LHucJe7mVwe+BOqxPYC0SX2EQ/uInHLXPQPuhVXNZcqXoonW+gKQWQYgpZq874W/pAGg41TGDKRB0A3iMCV2TuLvhx8C+RRVI9MHMU4i5sQkGunIajzksvVcAQ2HgAK7KNgAwj6co5+LvnMuYVPyolrqSnS6R9z93AvWDqy5SfLeB6VjmFs6Mrv/rgxdjIV5vP7a9dhGPKLR7rLBLYQEzML07LxUX2js9/qVxUuQ0xlq3fwjrByZTBjU4gntrtae84P028byUCw3fjQiqI5gHSKgTr8U5T9x+Ly8fXtICocjy0IBeG993Axw1Cy4EubwzuauXrtjGhdcKNQlrO91T0eltkW/JrT4tah81itbm4wKKJAbXtP+Oh34lhKZRYvUaxUNhwhP+uraXreJgq8ojmcWGevLkewpaie/hL7wRcoOHdDA1EPDuMcqxqCj3pxA5oeUQup/Hqtfzen8NXxnq+M9JOJchaLVUr4AkuObge2okbS0XYVXUj01Lmtagd4EHpxpuCNEwSRvIkSwY86fHrHmLN6XS9nGGo2EzEN9rKQjgi6HP1/zIYLy0ONLoonGWaRAB3rzlwD/QNIviiFf9K1b8RLT6ci+o/gofJWTTIiWUYcOtThL/NDqouZP3rH/GoXcpHn2pXOPc7JdJuR87augjiNra/2NwT2Y1ZBcdbjWTrDnker0BYNU0vACybcakj24sOITzTinI0eUCSUgftYk+2QbOT4PnVIRsFNJGQe4gL8ehyj265XMFWeK0Pno7Jhy3qht0ml5LyEbzSwJxm9xuDoqpppIQ0CFjKm2j7/3pYJMZaQlMln3+4fONiNqWxK6jIOrUmJSNWrBYOiTrn5CNe0N7DS1tIGTSn0hh9I4HHXgSuu3WK5koutG1Sb/scWexBd9nABMO6DZcJaMZIimEo032+N89RyyQYDEwJhI1JfxAZKlxAgwzld1LXX04fMaveSCz/EvAP9tbZyFUUT/oqblHizPU5mt9MKcNs2666mr6A+Y5n7AcvEinFSe4l7KzdF+5iU3gDWjiSKDLwWSgVELg2gvgvYnpDNQAJ/u/iPNb1TkqZGfj1AHe6zKoQ9t9y0IdxbyTwbZg+P1NDQUIZ6H2Lts/uQauIAnsIKnLSHO84GeptTNSQbh9PZsw3Is6XNoOd7bEtlmRXevE0pjgcsVwvTRBSS7i9qLhHl6DyAN2MuEXSO0sE4QioZiH+NNqP81udqM7GFESeXQWi3nfqxjCtZayhoxktYgSXloTiavnsRmLpMxsJrZRhu+6Ikd0FRihPQx/zj1wrC6a3hA97hi1ybxK5NR06YRvusk5/gIrM++qczyoc/hZz82W0i4a/N7URtRuXEaqEy4MeNGMpc13cXka9zTBQPJWfkPAZedtVLm0e6MlEZs4cpXkOcfEZ0145Uel5nOMN/ilOx44xwpJEO2bE3yXpjm20wt0unQb4Gz36tvzvOP8UJ08SLRvcqxWUahjgWdos9mxYPFY8KmkGXF3QXnwuDQE6nepmEic3++3fqfx/UJe2zK1EBrMHh1XxiyyNhNZ0FM3/JS1AHncgIjvJM3IOUIxeOAAqXp9Va/qcE76eRQOUQYHP8lRtOLRS7mUnNGu35hjkHDr8heCCoqhf/2/+pZThNN3ngNqtxrKGz3/wzzHadWd0aY2qA4RlboVua1agaNNT57UWzS4UrcUkaLQKoQXc1ccO/SV1tJ67lAfCaQTBEKyqGmXAxuHMqKP85MZa0+s1a/4BWchrIydZG/PT6YT6CSb6ON/9dBrnfdSe5vN1R8fvnFXIsateySq0adUPy4XUOP0JWj+54xZMwX+238VonLseWi7yVMlnr3lb3RQ+rooFwEuzjrV53hGaHDh5pl7UuErOTR3+LL89SPQ6QVfO/88+EHRTO/sYKbvtQ2DFLKpDD9K/C2HrAmjsjuy3udiEqDzO0Ony1TfLvVwrf3tyEe3b3aGfYBFHf//Wn8Lzo8YfdH4vTvtfgu3Cu3LCozHUHg7JRotzVUoEgRbCNdwE7rPQuh5DNkhv4MFOHywkhZURvApslpi3Eds0k63UgnUgffIc3teFN+fXyscdWIExbUQe6LfH+0UlkRPg3+aCrDkuFyzAOt2GSXVwDVy0iU1bRwS1x01MlO9arFUiefwqHCJWOdM+c4TZj3S/r4B8EW3TgXVFFzvLZDK+es9RMx/XdIvsH6BcG8oMjoTXCvN5S/42PauGgciOKS7HcRqTVn9PHcyyVvfesjp+1MlzMqJbvYFwHZH+tSrtwHdAMs/Y7Ee9Ywdyc4yPWZ8kZwmEE05pBpneSfvjrMrJ2u/uWjlIecVua709p6UnnQjPEwOwH1+amfrhTJTsFJd9lY8KoEe5tSE2IeMqZDh4PYLnUf6VSo5RRtanvLxSniW/SRopFohbzQNvX40oOu1Dvg9cFTsuPYLf6a5p5vP0+Q3xQT1MXEDrzxBr4Oybvb1IZs7urOxJs1qEEbBJpqfB9RFzyI4hK7Vt6GR61lBv1Xyy3sAEqDorBKBAbf70IQGeFNCSlD9XhdXxsfqokuPeMRiIMrxr37IMHXPxxd2VAQ8yx1kn1sMFTiP2xxSr1eHjMHTvLJCyXPbXbkJWwkqVfOvv7O44fDlfYtNFirKT8mYfpWLaA/mPDExGc42EfXSzN53PTr9MpzSoVF+vnKWU9BbMAan2Px0Np6wGm+newsydren18v8mLg58rWqhRPVaUka9UXvORHe9GTzouhGyGYX0lDOjD6Ij4Kn8U2zdTH4GOCwzrsDBbJ5DfEBuzBQZbdP5nyTshJAwKqVZOTxd95NVkSXtYQLFw7+Ei0j642DrP7rK3tqcApEpv6cmvETYjWA5sBk549p646TBix2nRhgzgaKKJFVrJKorbl4Ix1e5RN5bQT3waFNusTNuA35BSw5859wHxFyMBvackkLsouTgoaHV0p5qFlXZr3L1Z5zl8JsHkyNDBcFdO1oVD64jicrMAw7PB4ZGa//Wo+NIJ0rtIF9X6zNiaaJ9QgdK1dDENJf6SYLWWbCmcmG01hmQd1o4wfY5g8YkaonbaQseDFz8WBRAdilz+ROHQdD4wbWoM4OBQd+SL8jnICaDl7O/ijbbxOGB0OrXXffRK6LW+6bVhkHci/lTt0Wj1S39y/JVtISAk1MSfgMiHPkMLyaY/q5daVHjTBdlWW7M7WtIvOwUG7G6xK/lzUoyusklhpB71NFlZeiqM/dxCOug4vkxZENXECOioJPlfHnxFp28xELYvyiGBsVp4/JCCX+7OXTqKOQkBLrBSwZhan67I6FwdZxEBwKQRJ5uRVtyG9H3GKFMRLA0evvRcSUQ0WgA+N0CxYh+O+/AVsGiQ2CfXZS3i1GmBZC8GoO1T+VeRM1TYSCWIc1upWiPrRRHLJmG2BUETgkAojpTAj0km/3FAvnrvk/S6iB9+a7nvXeBKf/4EPawxsKyTrR/AwWA36I7of0Wi3tUmlh6Og+qU7TOBSZhgCt89vt4tL6xf6HPbur3U0uCdHSTmuUeRrbsnVivJfAI++kIEdbyUO3e5dgGwGB0k6U0UzNpVJ513eD+qeqgeL39I5LbhwjXiybbS6RqBHZXpmdvAthUpcpJ6qpFMmWy+KAFQVPns4dwW0wqJ3OGXsKg+UWiW+2hytoJq/lEuRWfTe//h4GlbMLoPGh93R++Zr3KdSge+ubLfCENsXmRmUjvo6qzQ04tQb6WuUOGISrs+76Yg7d5XkUr83jXFD/pzetXVMWNjyg2af1YSGkNgZX8EMaGopVamJcSSiZCUoJS97dtlkKD3ZajNqKDV3Ep4g+NcOYypDfDMUu9lWwNWs3Z6DkGXB9akAU/FZsxti3YZEkcogwXXmiOI4ALmsDrso9+PVPZ5+rMr0STFd5lzEFTxbu0tTvCj/MftPhsZgiY+NxWMCcKzl4O2DcogemU0jtVcovNXmrhFPjKkn5ZRuzWYp5z8m1hBKvzhRPuOlSxggCWCN7TKiwk3V3efMCFpxKwQe6KnntiRoezbARSVLRQW5tpWkpbJB5XNO/f8eZhysh0jD9bjytE13j22Bje991MHLd82yd5dXMuHJ8mS8HzqKrJ2pHq+Wwl1KQl9yjKLFJgheQVNH4w9FNvETdYtfeOV2jnsMGtvS42hTvNch8pj7T0tjFztEa3pt5MXkVnSek+kYSq1Xk+zMQgdzeCDzUCv9w6BQZJZ6haTAUDu2aBJiRwYImEpJm/8bI7MClbqWq6fgYu/mc1XYjTGNDYsbl9WSc98Tocj1T0EgREt3idrBaPHcGiuxYcVZAVvviqyAqs9C1zciXXSt3M8rkpK9SN/5du0lMW5hp3O85fGGWw8k1fAP3dCxNkE1lcNk+W02G373H2eI0A//2nVv50RQcyyLctaYHyovi2dSlY6Rtat6rQ+aWe8aK5Zv0qifUx3BPwCLBqUyW3IHu8nWmI5S/nune72Ub6GOTXww4KcqoLHHLpDd3N3qUgkg6+Lquyzq06DbpUNYOyJ4gwFNks2cbSOlE01UQJTZe5zFaiwR1RA8opikc9RJ553Cy0+5VbCij7ADtjMpkS9GqTJBfWS+8yaCbbkScKfPX26wgjFZ9Tqq/GiZ6MXw6YXf3pXyVIe6hrCBeOeInvEQI9Ag4k1lXZGh573BYK7vY67xsyA/Jk415MnP/foCgU/81fxHL/h/vHkCLq07YzBnWbN2d/NiNG4cZQuUaPLVZbAbqETjafxPyLvuTW3SxcCJPYYyBMX/OiPGdK7dOcMk5MZn+WEh2lsnyQg3+AjuiExeRE4GOBmpwHZuH/pFYi2TYuFRM6HylqCZnJTLcyh/K4zvTkiTkPjguTUTzNKME1FAJw2Tp1vqYkdQKEGX5/uUm3dXXi9IBhzaLS6H8go4ITks+gkz1wzNAd8tdlrXswCyvhNnQ76WkQ14thV/S9QBVwRSLGIrZb3M0ewyehOp29XQBSKeoaekPElhCwL8c/kswiABiY/A5q1VvSIfVCCtBrO1lLuImDJhSFM/CVseKIklWelJ2UnodJSDM/1Xj2cMCwX4VWPDxUZo6P5CS9kHURnLY2Mfmt21+HNer5IKl2IjaInDAwB55bqUKFR8FLQ1OGfktiRJugYuV3Kcaex8rFpL5GDDSSykAlkJ78DPbZqtjuSZQJfhAEU9ZixIbyafA0oOwasulKq/91KPd8jp0zh13bcndLuXCOolzjm/X+hGaQ0RxAIRb6vBMDAieTF2dDK6vgH3GTXrzHC4A4suiYL2DUUM8FmaF9G5y17nC61hBrvZpZXi2rYwUS5/dfA1Ji/B5VRnX6Xr7DnjuAQZ9k+Zn/VR8dwXi86Wejcv9rT2EVPXjYcG5CnLuYEFrK8mZxLVNt+Gh1stJlVHSGvOuL4g3lpipRuBvkRMOBa7RocLSNxb4tAIAGyiNwurIvwUpukZdfL4JOS1ZbpR0QO9AUC5kvWxPe5VV0HyC+e5J887vUbeePUufmE4qiIowfbrKbLxIvv6JF+2RnljxHl+rZS2uquc0VQ4UAdidP/L3yVRRfuYSaiOGD5El0TG8untAnaeHKYk35/fG3n4B65kuJ3c6KrvAs0bXO8o8l/RTuUKeCzIKpB6LIB9utOkwwY2ZGLm79b16mVywGWymz4PcMFLZrBR6sTw4U3TMcetq9JlJt92qS6DYtzkMgW/0H8rXaFQ/nK+X/JfKlKvtG+C95UB4bDmHhyLm/dacbqHZ0jRQrOOjF8sNkdSIDhfCgnLPYLCbVnLWOTEfDq+gEN0n0Qkbs6ybtuDpJjXbhh2sFVmI3aJKO3iSafyEA57wjzAhpZOpHWzXvlWWubiD7cQbgyi39Hl4EaoaGYUXo9ROTcoW6MC0pdqZX6J4H0/1WQrGWqKceqMLAxyKSQeDwvZXdS/dZbe591oqwDrO/gBmJnoRFfd9xauh684+SYjtOy+bsBVFgWcA1hN9hexNXvxXnEoBBr1HOperxacvqZWyMW0A9+YsuHTwAun5/rS5Dk3TJNL2muqit/5SZep8ffRQLXTkAt2UKB/dc08/CnLortoPOxSqcU+HzOj9zaHbU4XBGsGyTv69Q/XkU4GJH2GDZblURrjtmP7juTFqhR4ZlWtN0iVkx3cvy9zljVXeF4EGFns5cbmqdzlbAF8nlqvAf1Kv02LROPo2IigldlMba9XSLaRztgKhoZWkMdWs7sPowD92XmJKmuK7c1XQFObKSmT52MbyGFiq1K7ZA7yqpmSWbDxAKya2e2mo0IdBO3WaeUOHLReYskyRrRjoc33GAdBx7Aq7M467NM1hVULeh4dtOokFQLEUnB8EgxeBdTIZ9iLvGWAn5AtNFEc9DxUFow+BCOfkr21EWjDHbVzTMz5UaGmHGTyRljVgXwwRtyh0eabFxlTCbOAhMI/Ou8WtfSdVb9pFX2prpgkgtnMOpAXOMKWfV7/h+wPr7VwT96TdGUmENHQ9nwrcFabYvIDvifBci6BR+sV6OSwVhCJbFs6iDi37CDpfNtqZJEDE77PHLoLK/rkbcMFVhEKOp3cy46oHCU+6CFshovOlc1Tfkwjew12gEsAKOv99fwHcArr3p8prXX/r5nsR+NJxeLm36jClSw+p8bcsD+LQa3A/cZ4ZxIv2PqlcC9cTFsWxEPZFHHEc4Rc1WdiW3RgYMtLBs5aRs6lC5Kz/brpTl4Fvn4PmF2sdFw6VfFwFD2/xViKM4ypRxsr4tf8LZG8a3UAr55h2nMWoHdTqfTU6zcylANGmJFUQ5LJWWESo/NiC16V3MFyhpLaxWUc/V2yxRsjU51oozmoLTRMzdqnGKiHkuEofP3eaRa5D1c/U7AHOJQDlYoP+v2tcswGF3IM/+tDjiTXxhGaA6I9jPr5aFfPTsOXRe8E/pUmr1vscZbUKvGcM+3e6ds+lro9CKSKwJ0+HShvQpfjPqCpk3YciUvovfqqB+JPbzHAF+VqbD0eQWYISJn6fWwKVp6DLqRwczOJSOiJ/sxpQdBTK3UJlErHnnZYAZj2KWOYGh4KApTGL72SlIQjwEcfdYvfWUrPKZ3P9d5tlB6txXYydcvhy0NpKWGCGiZECn9gMXZfpEME4jEsY/iJwv5qKmhufVln4Cs8d6kxpm+z4MCB4JDoik4IrOHjWJYtDLskdZE9tHrCih9ebO/Pxt6iaCZMbkl15LTDRRdPUuxxlw1hQwdG5uJh0arGHh9D+JKCXYcDwo9hyHB1zAiMK9UPInoFycHQBVAwNF9xXdu5S3OIWo6Ow9H3qxz1+JlfcauCGrg1fPZlQiR044c2uWup0nu/mVVV4VgYnj7rt/VG2AuX+8ztsD9ILs4G1FzR2SWZ1RN+zICEQeclWR23eHqKq4c/Oc1/0S3HPigWVl68LkqKCA0cPnT0V1iOO1qS545vMLNK21mB4m9ajWY1uXai7VuYaK9kZDR8hl+UJv/qKrYbzfT4CD30fRDwWaZoLGzl/6ehKxPljTpSKSJRQBvooaNX+9udvEKCCxp1ecfqDsd7Yj4F2PVI5/HEWdytquDEdP4ZiErrgIszWwuT4vYzrxBYi2yF70JGJC0YIm//Izfj3RW3iDZzoIxgFMrACO0ct3EBDXsrLEw1jcKn4AmGcOy7+nC06sXEpcO9Uo4mNaNF1RlbKjxmk0f+OUrPuWz6Y4okW+dqNb+Z4adWkTJmMBT1DMAKPbsykMsSIjf4B45dPW3F/XrdzOy25AQoI42Z/6ALd4OBfzCTiVXH27F6gbihdCHYbKq5MTf1dNdlf2IANzzfvAu14FMICbS/fc7IWajcd4EjKFje5NIZfa16HUxFRQ8BgiY/fJBupSvsRKBcw+DbQg+d3fc1Af/zph80eNOKyYRW7ERSSBRAjYEMLOUrfyw/2uBdL23GJoSxT37P11u8QYVFRKzPvlRwfUdjoAJ8gHUfvT8RuqKZerEwmKzkWv4JIZLsd7l2AqR15h6k0fsof4NqNKa1HLzFTQnPYNBeueQFEXlkLMBKSYCzDCLqYnjwtaFJ+m2baOb0qxwgIBDhAPHw+Yhj5pWxz1BkpgglnORVDwlB/oWhtQ+QshFHRloENSPnV2GYba/LBR+9QerqOcGUpFTcrfvI40ZrXV5cGbRKkWZe83JUhcwvFhtHzu0TfDm41fRdKb0pDxwhXxTZ5htM3GFteYDiEpmPnIAhSDKrRcmUXWxLZXkJ5Cvb5MWIFcLbovdUa9jVmT1WZWKI+rjr5kskQWfCv/1if6Wougq9JLvqrM1w9NrxyRftMu4sScvB7ds/3lH10USTnkjggcwFx1oO0GQu8/HOZkwqx0+fsBu2lvHCmtOB2aTjAA42yX1f70pGJr10+SZa1QBhlVBRsGMh1knBx7bUqWFHPtnUvncdI/jh15uYXD45zCLBStwtT/ncwuICr3m3ObNyTw+nOkmVthteUDjat1+i/v0Z+qTMR6t7LEkWlMxOhSMiSseSj7hXjqllcUnLn5vG/6VIyp0O58Z1iTL635CMdoi6zPzocgqyRCYJMGQ1C50v/tg/c+++uShxUSX6PEfMGaf1SFb0a5cC82WPriJz4nFCkKXwJpNtVFPmmCQNs0T4xuzeG1Up1wBwslo0mJ6RgF1g3GAUsfVhKawYtlvn2JHbZ7i9K49mzbE0UHSuwec12vW/Osj3BCyQ9wwiGkRAJOnun/QqtFhxkdws6yLcBBaXAjns5L6fbzSR/PZ3Db1OZzvXKLICPPgCSAEmL5Ea2NQu6pmC5d602Yj7AUbE5EoPv9BjSz44zUnq7WTjIcecJqOjbpxri+eJOzMkhqXiUGKMtK+cz/vuK5XyVVnEOiiF5Sd/hJZHNC7ReuMOamlHpvjETrKYN5xkltXxquVWfPYSUp+9lDpsuDdDsdTkjCKzYgNXgt/RkjPtNvsVdFIj4IQMYF6fP/o+3FaCESmxHxfHWX/g8YWcT/MI05UPl8cltXS6DPHVJ7ZK6cQeu2sMJ2JKNLGPcFPWN/mkTqetiMb77pIyK31Fx5h+3PZLj9EFeZF5VfAZWguWANUm9TVa8ygdcQM3/bsv5P6fRsL6qYfU+u6dLEzxynCLyEpLX54K85J656cQP2cs4ejY6Zh6unzOj2Uj8O4/DYbv+BSczV25DFNh8VUWwp73/+qo64BX71qcFmnieWpjIRg0KKS3hG1VYXcd6COi0sIG6W0xGs7rOn1PnnvMb3/wZK5IJBcGoAtfu57jCz5d3jJZSh8BPn0jRSg0sq3+9ow7/MoA9g4pXOFsHwCaY5oZAB4lqOa1fCXgTU9UGc00G5WZmZWvid+DBlrQCkbp/6rnTDsGgG+6glx0TH0XN40QUrdn+vNNzfu7UzFW7IEVZamEWSZbpCWhozgk02Sis7I+JaDWJpnBYq6Hkjh+muOEzkgWE1dxxipBU8g63rf+pyEhaZX4Y8PDbQi7Zh2kcI4D0dvsJWQxgXCSLQE42ViDBWza5k/QwxhXsy9+oJc8Xguq5dMumRxpFm5n47viFhqq5lbzMfFiMFm644r+USawCF/rWDkag6zM12yhWKtTAncATvC+UDWhQUMOfhkvfPQNWFpuUOsaRSNwPSyYgjCRWgLJh6W/0Pi0baguBNfnJgL4iShYkaycRPZr+0NBHt11S8lGn8cJaKzAyasRfA3Db7GFWKyuQZ1ptku9/8UaHMXVYgDHCQ7y9yZpS42ea2zeN3/8Cg9mw2lEAoiF3f30S2GcZANTaBVApSRYGoSWGNMFcXP4C/IOUJwgMv1EBDNIZfKaQCwOHyXNwVeF3nO1gfmHzzI0zfa18Qu0PlH5NitabDwqf/crahihmJNlqCmzRjHTi+iGjbLfDr/WwfNSyMg8KNjRHnAIL2lWv3V1ECG1k/gKCqsN8lSIfctZtn2fpk4bfffc+Rhr/9ZFHeo+MpitRpjV0XBHHSZU6iVPSH2JV6AAjCOOqlrZfR+g+CV/kWE8BDwj5QALMkLcQnWf08ouTKz+FidyDzB+jGnt5JcfIArm3BtIjOre4DLPGvaGbmkZEpkdK0XkpOID7kT+Q1fhO80ECo7qFKIn5RbM8z3LwCfYvISf3FAqMRNg1g4X5GwxTHJYNWLq6Swa17MvBsA5Wnrgec6V5lluKCvphJZjGpTSTKYex0IRCMLGeSzhU1Z62m4g6Lc8Rp44S2D6T2VOdOfZhQzuOyqh1/sE9v9qGNc3vS6cPclC5f8ZDbwAEbEzgvZ/Zw5jp416+lHuLGbDkyxjJaqazj8nSHNn/lrskATWzmfWZre3epQSDWbIUdUdVa4YM9YAryf/x0ovoI4uj7cAKJFM6UeNVrXDudGse4rGR6tuF3/iKLpHiMYDd1ZZg/yYNRsGpXf4yjc6sJGRmqcxpilrdjtpWZo/qFc5OfTKkmal4rW5MAv1RHzjmgTJ4BkS5rmBbxYFh9+PNVxUiQx0YGb3DWD8ldkxCpTSr4786UU5kdUZEEiHxaC13AB38eS6MNQ7Wg2KrGBkKhmhEnRvnbfYQix7r7gAs0vq5If2pS4jnKZ0b45xgq/xt78Pf6KqWrO0n1nTN0R8JuOXM/yE2vqRlpC9HeFy30OHUTX5FP2X1O1/nBQKCpfFoK7+7wWuwJil/v5kL2aBe5h60GQlLW9RZmDEWaPn8r+sOgJ9L6nhbotUasGDOCIeIJ8FuFECIyLugRcG80Qeknzz+8jpzlthLyNLMQqWr1jL16tXUkvlYFJYuGtVygzW7jebe0JY/UQTfypGxblyqZ8uClavEmn8VIx+gMwKWjzHuR8IZiA+VQJB7+J0D3O9WCAxhmMx9ywxpSO8QflxogjeWGCNBy3v4ITQMdiimK1OskGNvT9Q8mmz1vGTg258l6j2tnr3+pI2Og26iMrF/GQvp7+/PxsPaEe3neRe9kLH3cYL8CwhFaWR8a0ad2jYecY57VBzVWRDEaHolwHcNhMr7Oi0iSgbsFP/zK09dRZyF6k4qqlHbA1HYF/RlIl6zpBByVc75fOOtNU0lZGBsFRDY9uUUSe7bCpLpw17L54r9p6GNgHNI4gc5vvhyETWIK0WsxUESuINkTQytvA0gdvYfgMYd9XtV6nERPj1O+p0kX61M10TQQqN4ahDB3xT8X2YPKYbdDALl5pjd+8wgEWaouYEESrwRy6ZVj/7JkYR2yykBeFFzmoVr+ltmwk2zmNbdJXIz1O+dq7W00dixqKO1ox5uJrqGxnIZJa1cj3rjnKO92SdcotsG19/cTdv7AXFOAyNQLqz1k6FrJEDVkwr31B5PelQhsp/Y4OpbUcROTw7wVonj0wYdJLTQEPzzfSXQhW2qM5e3c68yimuyWG4lras3A0QIuhgddLiEacLfJ90wESWlh7DC4jpQ2wA3Aw3bICsmSlBrxpDHn6IvUK2YwVODDDDe6tsKTvMqctJjcNwsXH9h21Cq6x2jIRcyLXxeAp1oB3e1IbdDuQzxn+axomobbKpYWnXsUVBQzM03hBK/ItkpmuJ5mBizZnq4gRiIvpiSvPy6Z6HTWY9zEQ+KFouP7pESpqJ2foT/+Js07FfRyM0lvpk6ZOhYo3OPwQazQ5nGFloOet3SHEEVFRTGTAJuxK3N9LTj6gzdouvzeunlsaDaA/IJKPyWWjhozn9nd1rHz/zyDT/N7CL4xxpPry1SSyB9VWsaniJBwhpxyRWCumkAPm6cM8TRRTK6lLmKTRoYtsG8NSDlPV1j8aAk/R+G5JY1tBFdERYsALNGe9CAXyuNnA+4vZwPZZ2y8asVovbClA62S3zAAaWFKWo0vYiqG8aQ0aJuNM+SYrGPjvNdh8p+Iaemm4cw2uCAXcSuvdyUQWk5+jKOY5TPtzNvBJ2ezvnBR7Mg8KirFb7mHlX5GCiGPI63elBGH57sWOEjzQeebjzv0NagQ3XYVP2jaTLo3Y2kXPUBRIkFT2hmseo2ieDgdSXJVcvn1P1jSLkXePnUUSVcg70kOxEkh65p+0du0hxJptl2VarvVEcC6euv/D28yrznheWYd/eD4Axcv3FdCDB94h/6APbVnE9fpqFywQJH9wDgnvspBmkO30Vck95yawyRbZupFXTUHQUYpYr5eu9OkPbGsg8mqUBiq98fQe7g4ZGzel/hqwQmXEU1XxtZvXGArgtdJhBorLdKemb2ImikHXYiV5OdXoXrpJ6o50JdGaWm/phjVTgtoKMF4at77bvufRT1roltUZXZ97chtEG3RQBpZj/9RD9zjUvmMiO2/nrAc+KZOEKQ2KeuCt8CttQNzDG+lLpwj8fIPnb0u1wLcp+zKqNyxkcpo0Oki4uPgkbrh9lcn1R9v0tUvIG72NfYvHsJ+AYgqN9az2U1xJ56qmXQs3om+UezorG9988XcZMdBnfY7fxnpzt2YlBBji6nuNwL6OoR4ggvBrkKf6H7pSFk4VJv2NqFzDXYlyKh7G5uoFnaGw/I5/wyRkF3oHTplQN85+koZ51x9IHmnAhzZoKs2vBcOzTS6WkDLY0VZEnQghD4aeI4ideg30Voz124T7OoLN/XOPd7fSsPloZWiHPLpzzRVOVpCvT067b0fOJlBx0pgIvNlxj83vJwXOdwNoFafJPoD1kwHeC/ibXnn6oMagb51coiUw/F0qvBv66xpHBVZ81xNod4dP6JedL0msOJLXMB03FDnYaDFe8cHIXr7gK3cV/tKvB1Y7OFdzfmhBPa2kTTtTAmCL5OTXaSTmYTjBoYimm7nW1jv6JTE+MnpQPWHo98pPLFm8ygUyUGSrktivobcStQqbrQqUPtTpxhynjhvEh8DTKH67Aa/sQN6gADuor/96+mm13zaPdcAW5CvOtBvxgbhkGSyidbhaEBaVgkCITUZaMX7hWbjxeH77VXvA2ZgRvN6A9at+j0tMvP+fokn6SdFm7NTQSpMqn8YfXSTY14jigjGhYe0ofj/vYYJ61Aw3UJ8xbnZfcdS0lhdL9mbAK1IcrkrjzozE+EjqDxLUOYMNkpsUVyzAHdgIqpd1Qpm3MrRBsrQW5WfjyGxZyZCL9IGRr2MUiLYoy+CphZVs6OFhg3hwrS3x9y+mRLfn5G37HY+u7/0Md9swAV6i0vk27Y/OzBtV3BxsWLzP+k+NmSYN0cQwJi5NGcJNllG8E5IWw8fy2V+N62OXC4J+WSKyuX7p7D0W4tmZCDjJLIC/jHt7mk4Uf+wzOJsuG5aQSgepQvjhPGzXb2uKfjhyUNU+r13+FxlORlu9CK1BJxjSQ96uYtT57F0EHs+kpQiesttm17OuZiWkjLXm3CidL2iVPRhDd2z6cO7dTNbuPjBZL4xEkB5JkAurzta9HOtdK24qU/Rdj4qA0nipWVi/6awyHz4EdNTGz35ik3+JKCzVSvGzX3rEJgXTnsuiKp/iL3KxYdcwWBvqIVyEquvvL9TyBHd7DN5rQTYUqDr999yjEVLWE30BioYWQr6kv3+R5i/8HU37Sj5+ApG3EZbHlsMmbaL1QxJn7Z5m6jW1JKt13+qADGv9VFWxKSP6LNO4/RCyj1p5iPwZvWhBCBL6D1b0PyZ5dKUlAryZk4JibkODzmZpRvJQG6HCq0fuB6wFIJredfnWcAEyn3Umk7yzkkqyJfbRS7e5TBoewYuomECkQIWlXhNNoZt8qtRri+IF6qx/KusdZZg5oxH+IVwHliyPZVkS+nkY3kW5k0/vzrgW0MKgEg1xhvRWC3x67fHSFFbIu59PxLZOrRkOlaHrGCimf0s6zrrkaEhBDTrfXEBzYSWKlRsUkbGlyjK7BmMKabaiXr7Ck1bB6l99UzaU39rs7kFmUuGZ+keXOe+NgsWa5q+sV0E9EUmZBZlu9GMu0aVP1AhyuY0R1RCXss9ZARH7PiTyQZMKmsggVEd/EcE5Otd6fXqPPfYQWV7nQ7OoChK/4DetMsV3iPjKMhDDvah5SESKo5ma6vjFc1nIqPT4tC57zkIc5SIjUe7wajLsAlBKLuoSGTl5Cbd+c51qcnmbij2ey9ZRfNMbmDlU4s4SII65wfZv4jGXaB6cFw7pau76Ncq6/+NF/KgIzH7lJkcDRXooTZiNTO1It+x4WRw2KbHY0XRZmegO0axfGmyzQIn7z71fvFjGa5GDX8jM5f/CCFYYgVeL/Kbm7R3sneMQv7W/9PWPwjDK3kIiWkoEK0P7VUHvWYcWAC+dYMw+/uAoS4GoONxl/QhpHs9Emq2Gb3EFm6uNzS60S34sJNFscyhhaaO7jSKK2FpCNgfoUSnGC7DDQwwaX8VE7BhXY+1mwdJfmR/WHS7kbQKdQw68W94Aaxm7z6P8CjGdIywIjRb1u60Vm/S0NkGwpQtO9qSzsfxnbcnLWcaLLVwB9Z6/JLpngm2EDVypwzTrWXdm1NDalgZXX+a/75pJj1YLjrU91nrtBv5fRdG5eqCH/Z1W1jV62kwjqBiR5bsox5oyMqNahDIJH/XmURfh1+UFnPHPxFbjHtun3BLJkfJ5F2rlWaxU0aVrau4M6qwLoQhevKrPoQV2vQoRAtxzDTnYor+/nerEodwXx4lfEn00Qt/I+Xn3Ut4VefyL39Weve9hW9DEKpmitmTySJksPMrzi29OY7koO3qYf2/pwXQWTfC+hfrzgLqlRg4zUY3BqZAnCdFtbTtIFkREcD+w08X9SOPjCC2T+DtGB+OQA23E2mtvg2jn6S+CAbNEdAkStVciCnN1KfLlpcKxv+A78vna8GuHkMPRMxjBG/1Hi3vwfThiCicu9UaXwau3bdN2DkKhN/oqyVB0uGqGp+mINyzxMSeyvAtkXtv8PGO60iVpBHMiy02wc1pDAiJnu9/W9GiHOl62gTkB7ElIBrsyaSCZmH2jQeMkLO5rGh1WeUZrPme3x13YTsYiv6mxdAVXsdnNroQGTUUmCj+k7f4p52qu1qtTBIfEoRQGLtNpHYi/GIS89CHPXCXxysqGLlEw3GPAtTrH341taR3pZqAdD+7h1vNREz+/m+VY57sgJFzRc+DC9SnLQqvwQZ2qj2P6Lbz6dq1Wkw/R7w4qNohikdreN9lxyH1xjyGBQSAjUamM/Fi+xQr1lN1K55X+sOKkhPA30CljRWbcC4HBkixt2B4GKXpluTSf9xRcG40aFtVLDmIQo1vORXMg43IlRZsjjSBv8FuZF4YqpKRdOtH01hdlyI81QMRHIg58oNgifc0YbOtF89XBT+zALEH7GU90INJj2GULEYFuj2LVBGUx0ovhnXsH0Ny07TmU46gv5Hg6TWFST1bczxA93k4e6F2vTu6kcD0/g7WUkft34+AVbbBt7afJVkKgJWJRv+P8VbtKDPHvxO2QoSCVcTP1JNP+mRHmghaGtRbvIlSvOJeOgMXOOMPFA9tISRvaFy943vY8OmBpr0Qg28eUrI4H6GaqzSGXLxzp9rOP1HbhujFFIK3fQxgYIoWPgix7wPFP5cxLQPYzuYuQF+Rf8iw7+hV8Ee3XnnrnstlZ3sEDm00a6v5zBm4WvmnNpggnNkBzQ9Q+GctEC/0u/AqZ4yTWp+0/y2/Az4g0AS3/6Av5M26pqdKaOCtnbvu6cBzh+E3RwihwWaMFdUqs/TMM8qN/YSR7inFh0sEfm3MzOftJl8rxLDyj+iU+jUXKVM4hPyiRfZ9PL43rWLoy6ZkQLHr47Xlm4eGz22JrS87R8xhXR5ghEQBcpVr5FJHPf4T5LirjvKymGZ36uqeweKFNk6StRqdz9F8d0+ULfWxEhUF4wqsHldwc1GWEAgtmLd+bgJcMOSrJZZwd5gqoUwm/ozwTWKDKZ0rLylJDVLEjXGy8aLOk8NRwY7+rlndRmLR2WnCTdLVWBxAyk9M2KHx4eYdOO9yfLW2/A1TYgx2kln6xRUJud7qeLswZ7/kg7+CtB/GLG6SHfDmLaE7UItkZMDcIIL4akkQ+5rtROi6b8E71jzcBO7mszImvQyBqVRF1CVs2U5dzk6Dn9DSAc/nP9GLLfauv4VmAKfgAtEH2rycvDBAdC3Hd4KLDKE20+XWEIYZdQObixzmHo+u45DfdJKDiHKbutwB65r2iqUU1ZlH9TQoRxDLz2R75LAegNT8Q+uz7R0Wlc5CX1lpjlnX4tPd5tafsvpSHjSX22EohYLIP34pCj1zkVZQKzw7ptW/oYMklsc10NMHuuGCDI7QBlf/MHGLKbSuF5fpn5A62+jf5396/l+GOUBPZoyMVWHcsaqLjowYttPZotrecPEthefRCfrDIjY+FKbMT0W6lcW8dj9egOuu2aqxXz/1JoOTHu7saN2GtUNcRGBN7AHE5Qw3bIVz9NMSxZDUNclKBTnZAydM/iRw/dNNKoi6Gv1MU6SgM/WpW9Avu67PL/TvGhdOxUnfDNA6DjEr2aID2sIV6X3uo7no0HYrTnSukS41oJ2hBpm1w4OUxcY/0Yx19eFf6upk37plNbjsUIZmMF9CqAyEq7nQhlmola0pkOI6qfRgHsacxwMBnmHla0s330gDFxqFtDXZb+wqM0bbgFSzP5idpqF2ijnYYdugxlOXre2LJuKdfxGwwUJSSk5u52jR3bTZxZ24HLwDFWf8A0ENFfTfwACEedCon7ssTX7xX4aTLM7SETOayZn4UM0hcIYgojO3mRtmwknmj/Fv8TdL8L9h3SBW+kV+vXEJV+vjjtn4orm2VTmuQldvLnWDcRPtCR3AQIKB39cfJbewXxIK/IT8xxCbk7ULu9FXg2JpRo8k/csaIa+O63sYsrtg6/DK1hNTCMLyrpqw4o0/3H/vhqLxDu8Q7x0vUB0mcxBL7ZKfowEK1mDq3ypa0KtyccWkbbZ6RkEy4Sp0vAayLk3PeL51gAfvxq1JkLE650YbBpSbprEPSYkIVES+vWN90RYExnij09QAtD5hSivF73GPcubXC6vkq5Icr7EPkMIsULJY2RUE8gmBrr80rAMR7g73iNl7CvY9gXKhYQ/Kg43W58++KJV9wW7G6AzCbBVlf0FKXtHMBP5Ex6rH5yg7WBWJGo0sJxf9gomMHk8O0Wt3JJaIqwINVZDrTImYXpivGx82m17u+Hxybe0wQeBLV+e7GrCr0+qIr21f0Ysz+sm/DUVDA3DR2TSDhwzvE2pdzxVox8j88gdHqy0oxMvP2vtcZoaRbGKN7J+yt/26KfYGahRa34SawXaV/OPkUH0aY+u1VDTMFukXM7H5VpH0CZYdc/CvDdaDz3Tnb5A3HhqoiqbtqQY4SaKkDv4HCAi82NFW5BPCdR/AWqnkxd/R6xV5zBtUOIgx4MfpRf4Ed50fQSncQemEuBpwH4CYfYwHSRfb3XNKXlkRr7IoM7gBv/aH4knzIFuxP0njoreuLnka4SsB2jFDKHFVaj2aqso2h1RqlOg55ZppbBqrd1tKcvPyjg4QuRMBjhkVV/34z5xPOJOAebT+AeXOf+qtRRFiMKUny8g0PLN76PGAWDTLDN7mQkwxpXDt+YORKyvD2bhg6av7xLaZi35VjyH6B4dpa0Cid1rdTkN8a7vAidMucxUDRpDdboyM+T5P6F0+NO5xixt+7/woeU1c7IRnrJXUt2/e8irJCku4KB7MoYphns2oyWcblZ9GFlecW3V+BBKTMWG9GLq4dfMLsQ/UMUlXs+kVSnVQLa7qBIP5W2sBawNnyT0Ivk2H2tuDs8Ic3iw7h4QwLAq5bUpWYmPocaeZ9z/W7O5WvVjgNZVCGAfOBVCnck8s/Yc3fCVjC+EQD5MooCoi1Bt7BAivYGEwGRVWaB3gu0L0H4uKnTp554dIJLRnqWq/LUI1vP9nsBdEm9LoWDTJgQbqvIMWI8sFQGhblkP/Uvf71RC3/s+ZDyRCLXRxT8nu5Jkk2s55G2kzWOkRLQh+XLHBsm1F4x+zpz4viaAYj4Qen3DVFz13D94gRP2juH4B+rJxyQoe1ixvG+7/LP+vUUe/R4ihTKmFS+DSoK88BQOagSgCrcOnzhk4K5YB2zN40XqbK5bDeNAhpmjfVr+QtDXLT04EDW9ynl0ChqW63cVxkNK4WnwXo9uSatUnOqSMRYOe2gNZAXoZh59JQS/Lm4x+FxW9D7cbqGTHrPVAhRPdCoq7oFGjYhzxG1qZ1qn1zZVle271OxmM343TRdZ3Cf/DnPAPdePWY/yGRRSJL42AYiGiK2DwFoAICpnd0009umVjXo/C9A5Lajgd4nOpRP7IX5XICG5HGG4xtBv9KQNGg+ozm/1BV8RsyJIxSIqHR9NvesJA9ct7ozOa6AieuCF1UKQcFDkMyzspVDj3GMjOhEO38LGeMN7423owypBroFEzjYWKSDLIbnCqtGkB+TSCDEdQPBEg59b9jxaD22m6bhHxYwlq5EY60Jxl2e/RDpYKUD1fwWDDv6WoWrPip3lS4KUxroTS6qlBMgy6OaCq3dfsCDHI2TnsL8G/5ex/ECPdMqk0B0M9j92VJhF/luCLY5GJlwvG4vKIPhEQKumDxarHHv+y7+Cz3hw7TzjGTJsiOyWwh9/Q/m6Nq5cXFsYOhvsqs3QRrExVX/TewTFdNXL4bHq4061JbWAmCTw9+9GUEM+hJjh5UMiyqtTeUa672tUXKNaFby0aRxvlLjodS1tVkeX1lcx614SycnkABxzlF0ux5M8u9u5ezg1lQ4NuhH0geTDv2yaC15sMR4hfGRA8S/LQ5kmByy/RNfUWs3dVxbWcD2itkh1NKrPnAg/EojA6m6JWjpsDIa5azWpDscZ6iS7Vc5D1vusImFOdD2XWNDqCRGdc7WVapsTjOEihOSKi6p0yUuV/tO2Uq1IzAkU92oi5rJ2/S8rQdjsjdWl9gifESh+N9K0V8uQrG5niJIb2TluhXKtOa6H4VyQwbIBY4y+QOjjQpuH84tq0QHlLUcv85aaK+TqroVWc6lVZp41hWPi8uJtD+ifkk7QeX8gxklUjmFpw4M66nSugn0mCWPNECVYFImJCT2dL9k62av9mzY0bFtqg8XrEk2VE3zdJ0QzwtU7gb8/QaWjcUj3TLVXIcUxuhEKp0267xbX91VyHFMJt608zmSy73hYM8Act+Jcs0XHQSx61roj7OBx2pSLosK89rPzcRTxrvEGkNX7w6dI5aIS59ykY9j9WJLcjZrQ0Uy+GAAoS9pSnTlDw55x1w0qGH31X7PVIvalig94VOZtgghga1LGM1Cx7oIicygzZAWXxAZvfjcdJjZbO4GtsNLUWIsPv9CszZ9QoZKnVJ44oEHLb7S1gE6lJi3fLdEKHP/CcXVDHYdQHQYOD1kBbsIDWy4kB8gZas2sHjXe/Mxz6ItM6ToVbL8W034dGCejODFIC6zHRW2WxhkqkC3/bG9i9lIL4gkMnonxqSPKFjjDX8a+5k4BYMxyr2nuBvAxiBpZqZ/VNXv35y1ipLA8BMFNx3zYwWny5bGdfsT1GuHdgQuPrP+zIG9i+9lW4BJ7sch29AGqeSE4V3SCL5Z6q5yMQAQf9FYxb8etRB1un4SxnzigBraM+Wet4bm/ouO833LMdG1an/pq5JMGNH+aT59NiyunezbiJc7/XB4tbuN4pHFL6JWRRQaoMG8O+EVtiK5/9AA6JSLJdUXeRNdYnN6eMr6FDW0szwo2uxi7FwMSbid7/eiSt5eTumB9UojqdO4HKmOluHdH7QY04O+LCUYRBioH71BKYx379F58oSfgrkcTPBcv06+8gPw55O5UllYcseOlhn0Z0kYJ6K4NNuz3fsqzTF+2dzb+XG1LnaMv7r/w1tl3Sx33oT9XBjLlwvPF4aPlmV6Qs5TbX09n6vzMBXqlVexY2Q3IJXF81Y0evXnYF8BItpOG/emix6zTgpeqnmjyUSmiTmWyh9vFoj6AWgspdm/3SGzYJdTCngLotoN8oFeqsAFK+kZSqm3P/z29lozvAprkWjttuabCuaJnqvFEh4w0IvqAR+wydA/x+qyzx2ynPD7QY84vOdqE5aBQJ/Ruol1O7SRIaEq0+dW61AKIk3VW/5cfx8OMttWAkdU0+M4jbLjFe8wNaUEaHpatYhkOXnT3QzXdeaf8xQDvQqaEO3f3J7Ae4ylfSB4cb8y13i3HTvoEXxVZGnJvtBujnNweUd8ILRgXMyg+1Iha3Yy3QgZ8+X6T5ySoDEyvZYCJYsSPC+CHgfqjs4JGPbXW9mXiXI9L3MckYAbKzmun5PeGPqYMy/zzOtlAq8E5nPPxklvD3jQ2hsKyYB3otYsey5r6hwgxGdJxUiubevBEWMvWRRgB44JLnx+fTjT9165WaBUaOZSeLc6vOKelNPLPU5/rZ+Zd6fkTlLxCU+4N9I0dESxMQcrVEYAdnMfrd9iVQ9Kz8RQAxHcYElS4xWW6LgjquaD8KOAO0+mkrjT5TOBm1ZlRr0JKIvCc9K7s/Y7+sd+2LCxIoQL54+6c1vKXq1JX6W8UI1q9Nw/AjuyKta7MNcBuednmWX4achK3ZHafyr11f+dPPuKx638z2yFpzybe4iaWzKD8KsFpIuo3c0sPSEAMmLeTKaAwujHlSuYYbO3jRkEXFpifx+VxObslmUAikZx0vtsTwTKlClInORZm8BibHlk2BBKb82xzigW+kl5j1skgLWb7LpUN/BItcDtY6S2yyskfTz4OD1ZJXFuWBbzKGoKV484tqZw+/UG7+QuVp/lBdS8ilrQ7h/B11wisNwlrPqj1f0uDvqWq+XXwWDawDjR2Ub4iZSbPz2rdSLF896ZFR+XZ5hAeO9MfCyzQ6oX+Tokc6wmtLct14T5uxMRhxrCrV1HcwjmpeHvj5C60nX41Az5llsts84L91El6CB0U5EkX95CCh376NPxJciI6bpcMzLdIxIXrsbl4d4KcATZP8LcMbgmoNZPDvSTm0gQSau1l7CLf8+okzSC0rwuRh/OgLfUB9xiLcj7TA8DVsaceWt4ojMgTM8qgPi+mZF7bI+icYPT1DkBAeoXxtLbS3JMqvHgLm0LxIQgidOl9vzMjMkW/nnk50yW/uSr8rSSeiEpNzlAIe5wmuXVNCzmMoFHyN0MJOQv+1x0vylsYho6Athpnffuud+wZtzRfGvcIKyADj+9mpamkqrR8Zh7X01/+5+bdp+N/X2P+NR5vaRHOvQA757LkZwRwCUbFeu4QHocwYS0CQMz68BkMvv+EGI2PdE/OFodVkbQNB2CGBDIpjKIi2jyy3Ks2I7E5q1CDlosVxMBybwZUAe8Nxjux4HeIUi+XXzWH3qWd0oZ863VJMt4E0QBj41Up9emKHTnfHFgqIh5IEAlI7dLop2SdStRsBm3X1P408WjD5Vo9Izrqsyf0xpHYylz+gY/EpckXp/XizMJwHtmxAp+mv27w5O9dcr1yoieLsbauiVCqU9tInm7gaeC3WIt4jZkj14qupieTw33NyEfRDEz7tc0LF370RKPSHlhSLQy9ybivb5d8aOGdZmzvCu6x3/odRA5B+E0TSeg4vtapEGOaECcrAAgZ/kH3efpQzrIfQOVo+rf7k8DEeLRB9qIlc1Mhwpki9EAhlnQPoJGYoLTOjphoQ+/NpsXXK0swwVF5TbZRJxMXw9hOFERCy6Um9hyzfyK+sFHfzc1ptHK/MysTG0nPgMZ66oJ2nwxaADQRvUL0+DymSqyUQFMvoje9xcEG08wR2aZboGW3m99VHQ7hThGx3GTvwigi9A7PoBPzolSVtIw1MUSq57r1GJxntxth7mdy8rZ1gUUdIMubwxX7ac6WRHj6Pj9Hj3lqjpt/rqyt7WO9q6LJNcUMFcjIY6HOXWp66F+n8unIihFS7ko3DX7BKvWe28wQzXXRCrihZ4q1wvYiLOIwwgB91fcGkamDYZuMKGiWBqsFVoPDnbo0YWpTmbm4inpEdv8SO9erk1/ONz7WR6cmibDJ0ImqaA4FwTFSAMFHtLbU3Wea5MiAKW4QfhXho11y5F4rWWCLGJN34wK3v9LEKn+K3E9pQJsbDbtYbAyvAPR/VZpmlcclGIiNjehtflOM2/KnKpdBw2XoPirzlhOkuJG2mJDTPyswdVtzo97rG+kY13uQHST7UaOO9DMQkodtrzLOgGbniTEL3r1/djFzaDpMGhb9/uxz2b8DyBtSTpwUB+TvGlt8s3tpAxW1/mn2Z5T0NhvnEj+2GP4I7axXHVws0ODs2AzF2ow3aAcejhAaIw0+EDPboQZyS5keySE8UsBSuCbrJtRodK9/2Ev/+IgiISOeqcs2rGnJ39BCMHYZKvyIDFlxppTAGik/vxzPobJG/D/CjR0qAkpfQlmq1iSskOujeaV2GIWe6OxvFF5Ce3Ml31qyUEceR7s+rArQOkAZhUpU5uC8dW47UzRIgCrApllqST0zf2vOdnIBI7Cv0Up7Zbio06sQ9pI2sepeim/g89Dyd3898D1NNVlPuFhOmSowWSfPEJ5oGbAAYh+w6b5nVVXgw54wL5zrMLuRAnpRbQbIPe+mBPPd80/5wFiq1Vru+ynaxqlJw+Owb+ZRcf7Y9SWFyVtcc2yeQc2OFZdQ+Kl40qhs06BLiJrE6JXD+NUEhG0a8Ms+vdmKZUyflhkkjq6WJpvxciofEYHR23md0WKJ8Mol7zj33fN5ICanqG2n6TnqqOn9UPkgR+lAChQquEr/0WrKmO0P+kbh3IIe4ejY6zZ89S0aZSj8b1j4jKflJzTLp/cVHMTe6CcBXaorI6ulM1hAx0xXAaJPM5xP9NmM8uM5XQKS3O5uN+VD1PHovMQSTQki4QFXw2+DwDY9n5eBMTMEnOLVCLrKpxBHN2WX5eebCzF1n6WZAPSLVKyZKr/sArVavKXs/DCtksRx/X5mWJkik07f6jk0PJNpNhWYj0iFVEcuMbCe5lJjB3tMDbMvLqZpsG1rexeVs4yrXY/o1B000SdVK4mqzU/wDI17hUMwIESHV8h5SlyAhfHaATNdFFJ3e3lada1hNQiNCVvBBBE/xRdQTDjein6aDWyl7GwBfSifOqBXBiIY6AWGLhCV9SIsntet2wpMqrwnGUsJdDYJ4dXprkG6I8bWRnGt+pNSWYbI7u6hVX5P4HwQ7JziXSqYGg4vNf789YvReq/nSJZqdXOtoiwvYLBguMYgzCSjJki7MFFWApAcGpSMn+IFb91ijqHFSFqCCocN2dYB9hzD8utkzb6W6gdJ5MiDCWjBrfdZ6WU7NDBp1lOLVRKJRs+Q8GOPJ1Wm+v9/GAJ9B+bAMKzI7YbJZ+rRzhkZoKo/g04zsaxJEC49dIWAGf5fKelesYmiMS7gBBMwpYZ6PZrtYVgNIFWcgbtZO0V6LPvzuWnsz3lXrBGYcQZ7IYxNms2WM/9JdIyywffeUuBGPHWkyAoVzDfkupJIafS15TnrCVCGl8MeiF+bMEBvLsk8ouW62YUs9NX6F5FAN/djHZLRwycpZKauuNiORe6KLoqKrWtSpqQUK2Ta/LB2ONd+ZT3ZrHtSofEg/tZQ7EPW8RtS4SIM6YZBgDVy3GysILWwgB/9i25U+68XdSEJE4j8+T63lkkdedSinR6SC2xzg5veJvx3EgtLhpqLgbQf8uqrxd4cLrGZnUMhe1srO90naRtkGgVF+W0qQVwZMklFCexy5qQnYBJ+P/zwZnmINXc9+jZ80ilnSPOgW51HX2vT9q2nRx7o05erW1QgoGYIPfJI0J1/e4ykdT65ck27UBeMhEEYHSLHaPxRlpxSyLNYEOo/pio0Mp8kQip5Gxtt5tJJM/iG8YGJv86iw/N8bK1NKBPKm5bpsoJ/KXJSTUKLkfjnQsz/rUGyEvKpf0M49YY9o1sWOyi1nFUaHPx84ElHFUWXIcTnniSQxgsB6caRfyRrLD+4Wb1QA22XsAyrtnqPOsMCIcPdRkP/dEJ0OT442stg+x1k1/nIHdvnwA9XCBmiSOaIpSlBgv+LoFzSX0cvVFD3ljePtUBdmz1nH4VmyNUOpuZh3iUOcVpRtymU761cn2m5+mON+Nx3yt1eFiCRV0BPkvE+e+GGIV3mDDaUAv5z7zw6W9WEPi5jjjHi2xpucFgJHc4wNsoVsZo3M6tD1kiMhtJ6FjAquLfkvjBGpO4U2U5k8hxUxNiLAHRPsRNAbyOiPa4czH6Tn4hWfwutWmUM5W194ui2aWxzTMYVuYz7yN70WgFohw/v6JEoBHwqXewN12luxilcg8Cxio1XNBkytr95OhLtVEQ7XzHGRsfURsmU94oSWoJtiQX0qgpDDzI4TJRTXAq9w5amv/tVNfARpRrO4N3pfDLdPlfDAicpsDB2SgmRk1LcuGS/ux5y/vHiOwzMsvc9EUMC0LlxVoEK+EfzJx3WP5lAoxMdyX6jju6QyEMC9zmfMhkskSt1gjc0wV2F/7No8rk3pxZgLtxbibw6TL5QpqlcICFO1nyiqzQfAvv316FL7umcvUZqqofdW6VrknTcoKfBjQ86Ic9/6i0q7n3OAJz5JF2uxEY+FEnyM1KJP7PHUj6Z34d8sgs2db1aY8Qer1/fW0cV2FNjZMPyb2jRJ8VBuHXriXT1mMRSwZ0QrLE8GYEI7Hxb3j8Fo7OZbxbwLMRd9hgsFvhwBciaQqjpqk1FiyJZJALrhtkA75yNWfsI8dTrtJPlf6llukdD/1anDm4HwLsB4Vo/GLHgxryp/NFalI+fU2T3dq/tXb85a8Ofx343QNpGJrBoE8zUKkvUvOku0bV3kzGjgswVgyTnbtKlxCtM8PHuvHfl1dvJ2+Iv4k9/qPb05PtlInLn9QJUm9gW9xZfaPgJjwe5aj1/BHkQdATq2L7d+xk3oCTWiXW8fRXB3m89m8D8pbvVkTicLs1peg7SKVeFF13d9rf+Nuc72fjDWJwiV+oPoL0rP+EMYgHHT+6f0SjfYtrlgk4pDL3/uF2ajKnFqrKD3HsSAsHC0C/lnQUpqe69CnEs0XF8g9BDGTJorqJsS2ZBxiuhrU7ZcYXFZg24DF529XJe+qcB5Xea5qsCIxkWezV1Rkfbt/qbsy+3cisbx5Vcyx5Dn6xjv9gRmaAmUlD0w7zLs3yxmKhXUxqEXZXMNdCf8PhVbBAjV4HYPlfShiR2jaQDElnFgpjfmJXYZIstqj/aHVvOW2BKBW7p+2S6kQ0mro+YmypbwboveCNTPPhpS4c9smQZxubmrhQAC6yCdx4OPpmrJXkkQWHkVlqQt6wtf6hBasqeyCryJR/09cp8vI6hJl5x5ENo3CbHDyCPy2ghWFIRUT4jrIn/Q9T8zn2dfsDOlWemamvj29vFdXRkl6nDmZkVrbgFKTUHgIY6FdZ1ImzWE+YSsWI09i/jOncqEmm0/JjiR5mn9DKH5Zu62QE6un7wdAtdPVNQwlbfUxinYkHznT0aqJVHg2sJ9i+WCP+R4kBmHbH72nzwK14mlpXKlLdrDZFbu31TxoDQnAxzE1XWi9FWwS0nepQ8jGL4daY3LSredGXvE1I3qwEzLYYFivASLPgBTHDFMxjB4ZEboi0UwWtcg0FmZgo367sBDrDtIlXYZDV8oR/rpFuoPhPJX9XYlw8jNHDB6MhqTKMsfpbJphhstsnhdGixB4zFN4GRt/dMCrPVPm+Jm0ArCBULP+PGA0gN1HGCPAK9RhHiQGcNd7fS9XTHMrAp8HaJhOrCDHdmiEcw5wBRFyfTEdNWsmDY06Fns+bEWN16xe1H6O3M0XXSvnFAlXEq6swLFahsVYusyt3TyIiYSwXz7AvpKCTPT45M+0URpRtTDxdfS7vtBs73xvGlXn5W1oQOUkLUM4Z8pSuNQsvMd1Xl9fanLmUwB1jC0W9TLY7HwuZkK3Do/QGRX04vltFNnehXHmlhI3+nq3EQZPpoQlyFW7lxMRJY9JBtFjLoCnpVvs6tmK5g5/vb9Hb3mFFeuNZth4rXblZAYlRpRcSf/HVFBFbQkSvxgqc5sPzs4CyFlYC9wqIDO15gJCfpb3Hl1q4yEdklQZv98+sHo/5AO3QXAGN97ZR7j7GfwGmY4GLXdlg+5rrC2FnPsqSANdL/pohhX11TcXAPHDtdOaaimzBS84hwebQwwlHQtVW46qXBCxmRQwgi93m5L90EcT12KYf6FooOiBeQdhimO27+7s0UFfqwIjAjnd38eMfSP/9FL0fnVAhEJLGntnvHhD7z1vV3aAZCuURHKfH9tA1HNx3UAclMh2xYRVUzDY/WML8ga6BBLX4Uuj0vM3XyXtHMfqf4Dr044BQkISflrNaajNvYzBPL7Qf8wmMcM3OfC9s4Bgwf7xuXAUkfzVxj4u1icX2xq3cvP6CAjxFf+B8u2WuvrbxA4gSdJQuXVK/3gUZ3bowCnW3MhbJP2sQnrM3EFLu2MM4pLNzIxQcfOqxoUz/U7DikpBMLZmQgNvY1Qd9sdk7guWz7/ulOSp3RYvLOe0HngizGQB2wVTbAOVXMll0CfUtqLUY0xck/lyH1l5Ibx/Md/+RKrU2po4tYK1yIt3SGuA+2rn/XnUwZvSnH8nvTJp2WlLUGYuDo3pztiaFiygw0Jm3eDxFZkXAXXyM/r0kcC2Nomf0GVg6Vx516nTtWyHjDYOKiWyIT1+4WbcufEuav+o/uFGGeZDLCfLRrNIbrlLGKFQeN9lEFWNzkDXeJ2EpTRMrelivTzH8M8zxclubk0n0DAssCs9C1xMWhvw4wLBkG/lY8GofuvlE6ToW+5N8iI72OwcdArPEAnfd5qWCVj4q5P0ApeQnICj3DR7BArfg8ZZLyeBLmF6txcb60H+vOHysvc6XNiizw0IKV1e9WNONbPmwvxPE3PYi3xP50XfKAo+z/T7vpnSzDEiUOvRbnhEY6m/Hl/9FOMQxuBtwWUIYoqYL8ACNcl6CdSwYZk4+qj8aQUsLX5MqhSpq34DDItiJw+j1cQTfe55tK1qPvWy49RVvtwHyLC7CwUSiZy/H5eWu81bYoGGvwLABwufl3xpMDLBLjy9YXiohCGwcVlgHcD2vOImWtnHHB1OlvZT0OuFPEgFmuw97g53SfjaTT1mLcA8NSHmAFfEnibdY28n77NeX8A3V/C2ozHyOvBKFlDmZGo1yzJg89EYGa2PMocKROGuwnq6FdvQfnPsRmpbfr2gJscra3DXUSvQ/CBR3ZYw194xWH8FWQh4/ANLu84oDecbW3mOp28Yzf+5v5cQXyr2ad5TNqlyc6xQ7C1dgE6MMxVwOuJL7EYEtdZA13flJcNcPrvwv0rGe+B4xs3a+8FyHgIEsNsz4L5av6C7N+RVp1SnjijmLxJYurGVJNlTFT9hpEOvdY6tRCLMhJfpWnmdAGAJdTontmXCCNfHUfKeJUbbrDPbfKgSluea2QE+8IRXGsfIUr0+nZyrdgRhxWHxbHN2qqF/tEr3EIG0e6Tfn+94rW07y6HPFOUfXYrhtbD67SNx+XWoP/GwwMvZJpo/zjzgFh2qPMYoXhwHCA2xCkYoYa6IcCDrvVKBqmMTchbSbAbAMkKWej2ajJjCjFGoAAqZXfsWiUw/B1CWvz5WM0OQx0df6i31YLMPeZBjhGVVTYi4XslmDJqgYnotboHnAmjl4dVq1gHITCLD797XIifUVsCyOH6NLMl3TgpBa9iVpWWq257geJfLFG3SyXGX6LI6nQQbjy0r3Bt/8SQfaeQzc8yZOfj7FgI45btDjqz1KiQUOSiccVqY8RCbrAvIhNQ48ueryX9gf1w+Y0TGIABvd81XuSicRMcKCc20wq0xcV9BcjLXqpGKlW3uCuQqMY8Mvuk6kwOhFAQtuf4i4NWF6Usu/0T5y3e29shYneDxncliWj5PLkooZUjXv8z7spB5Emowj2XpQRvIJFoiERufB/1al8M23jRRLFIH8XBbRnxKGXL36pZt9E/CAgd0AbBsEpAqjlDDSeS2QXw4p1hugkGYaHdELRiUyCMkgYd1gGOHJ2s8zbCfL0LDEfM1ZUTcpx0q4rhKULNuKHAPN4O5W6pevfS5L0axqlUKXVStQ11ee+lNEr0YGtOw4K9VTIXtK6972YA5xozRwz/7IPBiRoYZtY9cgUBXTf6TIdJ5vu/C5j+a1tF4BLBl1wVWfUfINjqIvKibDb+iGsC0LpiVcYXBQVaEiILI1JJrl7d9c8bZNSirN5BVttM6dTUS7j1n3c2DBWj+ZhG2IP18bY4uubttX3CNwGoi/UW6JyCUZrUKgeUkSRtZrua9dkmxvCe0CsIITQ/s59J5MXfeuZtZISC/0JVnC6/8r69oiP/U/nkBVKhjGsy2RkeQijbjsl64W2VoiNhm6NP2+MIXsQ2e8r5FTZaI8b6NUOHSxd4feHgDKutyc4Wrch9VeHzc027bIRN3HKgokqN1Dqd9cM02b8ScxGu3+8JGIjxAokfhD7mWUrnD18CVQWeG4periHgeG6r2h2wtR0n6ce5yfLSPTvLqXSMIDNHWYX1JA7DQ2Jni1M/uQOO9VDyKdXtWRSA8OgBqSZWNwr/T66/w1LPyeSPAKi8F4bg63E282bNzyrKUwmw03Lht1TSfS/8YeEuOX1f2lwymPTyzWNkH3lssjh6bjxG78xVDbTyJNJNfKuTe3l7cXfKLyc4+UJ2LJzgDvADYMLOBH7ya7pwaNiBShTUDK2FjF2tj2nacZ0tStPrlJBzM508LsQyRRi9oY0ap2jNDkSI0atPzWudXRCnnPLrayZDQR1FIYtmkCX+OVoPJvgHQJdBjMgesKsWzWqcVgJ4Q3UL+eX/oA4mg3H3d9kHv1FEySeaULZrYR8dozYZ0n4iqYzJFUcE+reHuUwndeC4dFRnKOxHwMhmSsjS2pw2hHKTRbn4Ndxf0Hqtyh+ynZn7VEo6mZ2IgDDsPyLdwAHwKUqIyNr0NRL7/tqa1oyUwv9BPKpfVGZPwI08+yKChLK96Q3ht4cZD13MrGx68N6PtX0DgduP93ZaysrM3dcSB3n1Xw3L6OmFnRfI8nmDCHPJrfoWV8ZgAOLU0N3IOzbU3I2k3jnh9Z4yP8gExa79afAVew9kV8cKzd/dDgAM4t2i9PlWCfrdbyelOVxFXQHKYHZGgCFKA3BufbueQuRzJRJ0sMc6RRF/Slwrpma9TVX5hLppAkGycm9zPeDTCFJ3eD+LOStTpNv5NCRiuz54tOf3UUv9wBLLA/Hcl4TTwzwvxitSJDFwrq+T6BHHYBOFm8vGMXPZYHCpyC+726NlTH5hobUF1SfeVB4FG2HA+iAau+gAoWrRQ8CHIorAUBVdXo/AaUdT42fnwk6lfsbkbByE0yonIhJgDDFMA5VqnoKrwxbFH84ao4JBsJgiDqJmt9a/CFFEq8laxKZZxiS+1zrdwRqaOjtgotjuDsBCyzfJxwxjelxFqTVsehtX5/N3/7J4eJD3tvzCBFjoKVwvuhWwEBVd/AghoF2zype9caQR+nxY+PG9ianqph7u1E/+D39f7TNsG/O++4nzTX7zdw6tB6N6HejEF6OFZLwB/aFPzCN8PieK0hfoJwtUGQQqo1jzb+nNkY6Oakz5WkylpBPimnprNjv/ix7/xf0Or6aiYXGHgVBxtu7GzLLvRp+qKZ2EER0GiD0/lcMbTlw8kjw1PPKSx+9yCu1kuo+C0KVlrFr+vLCljf/oLaUIpaAj9Ye7u0/hNssnjGfMBOkUDQo/7mpNGmkZ6BGHFEwS2kPI1s4FXJ8zhMH+jUaWQVMcRWl4SUriTxckh44qiMwKQcCPTS+b5IT8hYEYNpukDEBbX/36J6tGaPXXjp2NpqqFx9ZRwdC6WX2Q+N5xOdKZufEQeStrbedLlyhH6YSUPnhsQgJNP9ATEzXCF0aLrhPTEzItYsCz4rbF0KJ3blLnwibVYL7ieCiGhDTiWANoHIr6DHNKgEx9ji9TUpBQWo0+q//3JOVKWqbKCHpzUI6bC7LO0ilGf79joVCQDG0BPtpqLzk9Lajl5JrFidziMpVZhFMV3R0lECc5cOXOjTGQ6nRQnx2YU4BWR8N8Wr3pA4GTwfVY9ajvY/ud1djHLOOIXo7+gDQXjBvO8UE3WpYDFikJ/WTVv1T5VYY9+iEzLgZV9GIjkHXL2hc2JegPguAstMmke9i/rpMhlxqtfDKBBVZU03JPXVTuGUumc3MJ9Fjfs5Z1nP+WNwRxq4EzVNCk8H4QLhKt7YwXQohxK60YgU92pK/pf6P3HESAKCX4mVU89XCYxlT1JNaR1AHWX9OTIue+eqGk7oDkoW9UY6MRYMADp0ot3j234PGtnuIW8StfTOcmYhroU8wfKZ7kuAHFPHUEKc03yVS/Lj3VyAKL9oO3O41E2sePNCl6vTirHhdy5ThurEw+2tGkNcXdYzYYiytj2O8FA+pJZtqr0YB39PoWBChWR+15A1oe11x7zPRj0QPyVIRZaKBGMLrXpVTO6m67+SV813iae9WP2HQtgtNWs95iewetPqMLvvDGIt6INBlMP1pGFavNnXs0gyWBrKZk+/bzEAakCl9T3zgKjBGLcQGMcv9Io3dZIbKW9/6mhhvuQvpjF1LB9AHghvyL1ywwIG7+dw6+ZVBnIb0Jsn+ZbL88nBGelO3dR3xseZ53f7iYSs2TTUuLztXB3uUwjpqPDbqrXpv7MKafkfnd4pmKENz9rjnRNLtxf2Zx3jGtEqTMu4xKmNXwa7ikRxSGeYxmPV7MP8XGeZ63bB04kf2KS471xAbGvTaP3aHTxWdDNYhucmOfc8KOeb0Fvn3maQVC7lTu35aclzhDkjIt64TiR7BpG+9++AKefmVaZrl+zigySzr9nga5d0QWC9cUolr9cj5yHGhLWNVia/1Zg/QvbsZz99Qgg3AG8xhaPceSYpf3qCPTSjlY8L1L9kqOiLBJQzBD59jdXxHWhq/oeTBDRc9ocJVSdJhj/IRnr7JLxselq7iS1KHzyVqVJMFjpjnGRs/Fn0DR2qyw7HFgRktdE4PFDuc9KCWoSIP2BH7IOX0A5j5QgkwJnmlXj7O63KgOhruNN/XxszTuWgldvHNflUs2Cwiu2eYvTNsTTIjPhxtY6W08ojmDOZawY2MLfKIXMQYw6f0VY9IqWm8Fcx+35QlOOs+3iZTShLVWIY0PTO4JnCHnWuU7WI2fbvpTugJTFKZwV1dJxgTfE0J7lI7W5tN3YUAc+/yMT4OMEwmGgT6qn7Jmd4hG/MHGFW/huyDSsBrc/Ok5tis9G3+6M3KZwg37PJ6F81Yen88dC+GB3tDc4sU9C9Tvux8Gijbz8nCStsPtxOgl+u8hqxTM7s/YA4+lO3xHjJZhgNoNFkS6FJmCGKorMqCHkZGa2Ee4tLigg12Fe+nbV3zUyj4ev0xN0pGU9mRy+IF9W/WqKBo05il7xQLd1E6/E8CeljIeR6dhzKNst8oH05IN6hxzpbnZt3AiTHd9+geJIm2KyMxNIJvsGnwxwRrpGZEhe4Apuekw5pcfddL6irzDIqRwRHekFw0JEL8obraCkAoidrg+dYMw8tGNhx1OEKQ/K36w+sGfzCpU1OqGEpu9jvvCdu4w4tDV2hQ9MN4xOwusjxVN7Dfgm059WvRBLKjDK6DJkFQ1cp2YAiBB7SfN1abJr9wGTCOlZm/iuCg94n0/oa/0oxr/MZtQ45qveSO+ZNQXmBPEwbDsgAouV+MKRJzc8tkmyuICbcRhVYheC+NmmxQe4Qn1Luk3HjqJqpeMq4do3CaledbSYSJNEwpSedGl3/tfkvXLDv9or8TZ71Sax1sGRwaaXCbcD14OQIz7JZFWs/OUcuwGqU5dwH5MzN4M9QEr3AoBkNbV4BpC5IOPWsr8kzoPLc5TjaXPmytGGEpg4TEoJV3QgQkonP1SM6QL5swmkP4FFoaphNg8ABg3ol10SSa3BthrZ/5fd9fsXtkQt8cZ+spnOcI0hKhQZJ+leU8ZboWtlmc3NYaBvqKDPS7tVexXLzz9mV3W4DmOWLk7X57/pYeFYA8GrLnnHYb57ZzPNY8mNumjvEbKEzQ1jRcVuLF4Eg2Wp1V5I69xxWg3BrYRiAFL7HSHtlsboFeZ6jO2LVEwbRPf/35iV6CgKu1gDelI1rWpHtbDx7k6geOyAZogkspCEJCXeG811bWjTSMd/eOHcuMjjvG/3PES0KvWoy0mOCWtNZA1XYKscefL6TIQJ/XcGlpfig3Gc9HhUlBJYvZv9pwXzyjRKYhSJ7Z/INJ8UAkot7gsZIVTUAwYtHyyKJDzj1nfBu4Nkv/Nb1V9zPlbmG1pgoCIYd1jDGelpguQ525soSGV1ZAAhsBNRzAtqFB7R5VY4/Vued1/V9ZSMtafJqo7QpIlGW25UHFtd0AcejFuLbSfF2Gin18L7DdIFL+K0x2suiN3lbwnxSFPLu8Odnd+7kEQjU/hamc6mvh4jhFbc53Jp6RFOgvk4g8zhK4iudCXI4brSeaYQtUePkRdKTNDufOChZQGxDDciLYVrbytkgI5n3fVfYgxFh/ecb/63itc38VVb9QPt2SnHUuOLfyuEVKAIg5vWjDdllgRRcWJZ1X7KQDde9xJ4MHiHGqE4/0251ueqayTEY/1Xa1qBrw+kZKZ0RgMYsSyCuKyHL0UZW80ZeuexOkNmHDs5liLgEAAcBkRWHux6mhXE/Dbj3Ue3Ycmt4bkOBRWZ3amkhrC8Fi8Mk0jVv+l9KRTh4oAJc2oovXd5v6JHgcYUMHab3OWWFfaZep+n7swl7jZ5SHGcqhZ+jfV/SKIAVlusWabaHC4LFrpxwg30M1Au1fSBeQ+p+QfCZdME3DlRrUgC7lx8Ayq9K+JksMW7uUJJdJowG9DEszSEcyJ4Ooiv/65nUBahZuoS1s87wwNp2zt3SfJCqR84aI6oUcQqqdWpStC3Hfkejzto4UpndcmIEcM0RyULhzJklGVPAZBCguLb/9TysRB/0OGVqys4HMU5dOzXs37IqjnT4Arpn8Tc92nKRdEoVqk7orlpcUB+B4iXirlyC5hfQw7YLirdDJQmTd3Og1GMWWFoiOWhWeYMrFuhWVmnIxpnNHCuchaqe6Bti4knxH4IHmLWw09v4etSb/Rng7gHLrDkp6uDDqLWAwLBnHW9cxB874v6VjQ7yYbH0KQ6BFc0xr47ZVXzT7ZpY72L5RXPqbkFxHyGaXb0xsz9CtxV+TR4v1vpT+wo2yxF5wnU7wfJZ3QiHldbOVp+4tQvZBqvNnTfAv23yKqO70hvE9c45lWu1SUmNbvnC/0e06mdOfQDHtnmHIeUodl/M2h/O6o7KkjZ9MjFMS6dbvf3IunmzGKozNDXo2HLiCw/QiyETPH8IueguhPHPFYeMVCPPQHnp77NW6tCNynkKLKEqxhkJl+iObS0VI9qI9e7ooSc8ls3qo3pRqsbm/7yMxg7CbIQrPd3bR3rZFj/ZTfOqWLpSHhZRvGdgsHfgAkO+vysJAhCeay06R1oyU3dq8YRsPBYT/EmaJ5c3eAjZFJG5ZYnF98oYh+g8U6Udo2nhbeNQ6fldnRQO3Qpy8SvJU37T110hszbae4Nn7DdA1V7zLGgGWx000uK7qC2IMtdc1gWEQzGGEUtsSSNppYrd9n/zALQs9BR3zl8YqY5hqRFza8ufLm/fyEPPwt6Yn8gcyOI7zyA2RA5dqu+ApjL2F92vyeWyfNezJ1grmm7bfWIsjQNuZHgWs9W4QEd7rVIfsAG2ys4NJwr3mLMv0OHKVzZSIJ6FKjdhcR6X15A1A3FT9D+fNZsW7rl1F/up5YfqB5q9FLs4cwbreIMlO4R8kx90Wry6REx40DfkRZL+zUR41wEQHY5+5HbW3CPpbRgAbOCzvS6vJT1bqN6uSe4o0ksWXm2vi1y3+RH8BJ7uvbzdJ/2b+g8VX2W8NDTHxwzxJ+xbtwIEJB4JM2KtSDGWU8b/HjbfpG7StrjGXpkV22w3Y58my12S4mtjwH7PRd7I30u5+FI5dKxM4YzrMN4PbUoFit4YTmeCTwk8TBkjBz/ahoYJS5BRoJIyvUzs2NgoYY+DELs0Bwx1Kye0crD9qLwaASlGbaYYlBBsw0DMB7j3vkDka9AHKO0UI/gBYWcmjrXLgQoqyzdoey2lbKWo7dcAUbvvORmEOEK8B/AwZb87JYjRbj1ajGKbCWBq7Ba43zDw1c/koniDUWlaS4C650KISnV8UYlmzxz2sitNv4UASM8TON4ZEvzDcgftHua4aohCFzM3RzvWZrJ0YSUW93r1OxoaYq12HxCQs8ZBYe010F9lSLf+d8X9B6EqKxlAqCYXcbGDoTCkFOuhAJWJUYvqmlaO94Md8WdWyP6vLZsfUIN+uOdS4D/zQ77zRA2qpomYji1I8Q4cnLJQpwiAAtshRPpcjWj7oBLGR1SClwrr9e99k48013QXhVZf3kMuhVpcX6SZNoTkqMJkzDcfPE5EoRgQRlN/n6+q056itNDvyGdQ1SWUOli0sufDTmqIP49r6PtF2a4D06LEvuyfFJgJo2z+udVqZUqhf9dt0jVERMcpGUcCQwkp4q4I1w+tGgla8PCXStBsPAX+hRS9Z+EuaOPvFK3T0f4gVWoBXkEvaH1JTHSV5BEo7A/SP17/Za1K2PoNydsposWVimHnbp4fs4mntlolkArkvrwMeF8HH9JQRiBMh+qM/hfxXsNRtFENf2/wApWI0+Fr8y7sqcDCWI9EmZllWKgBPZsvQ/9urJw/AmT1qaJrlK46km5qB5cvZg4gfdCj8gv1Mi9y4Hs8tKQU7tOkGHCAfA0WCS506kTt0ll1vOonqcPqr1MX4m64dttesK+mUacr7uwx7OQtXlVIhlkgBQsrKgNy+qg+Tunaui0SqzYMIv2WylJUNluMTaOA/m3ct8kwlchZ23KGMsIpC2YvmLaZa0r+7/d5/DJoPMEJGwVfScS/a2Lma+X32lUv2r4d89dJi8gSNzKUSGUU27M0UIkMRBa7r5R/kqfmUhfc40Oe7kFh/HrzrBvPqyctmXidZl5wkV/zHW581gGg26BVwTUfgSL7Our22it9X5R67oMDeEdYBhG9KeJGxvz27vCj67EKTXAuDIYek8fJWPBWgrtmyGPg5X1O8+uDDLgSH12j1tUWEXk/fdvc6yYPVWES/bRL81kfeXtvCnhn/PFwueivgbMMGuM7ULvztMKYeGIMEAizbIm/EWO3Mijof+4Qanq1qRzV4BMhrUdAcenNJ9yCMnjNWx0FyjSos6/mEX2IPcVoGlPIxtgoNi2V2zjpvD344ganwQ58Nvtf58JE/o427vCWuHyTgviVCwq6ryxQQauktKZNXqEGu1A5UwYNTYRtm110CwfTpasa0kpW2ZTb8+IH+niJfCukp0dNwx/XdYC9p/9aCgYg8HKQA4ydp2AhUuVOIgM7+YuAGJ0/BU1K5sGLllKLkxNS1YzAwOdZKzP44Snil0viiZZ/M7r67iq7hgTbiDa3O0xmbphqVc3J7LtvsoQn57jRab+D9FSshiSQqJ94dAqOXZBydKzLbWsXSXTr5MeL7ictom+buf7IzJqr8bnRPrIGrS5hAoDfi8FAVjd6DJJYlgitS4iOh7nKiL4nHp4ZZQz+9F5jtbOO+lA+RL1ex1KL3ADZZuQqnbem6udQyWvboUUzxOXXZjZNpFgwFeYe5XgQJ/+DVDBhdOPjX0bwmlX6PZmCyTsEM9h7JGgK/U4CF4/qKaop5swfivYAVrvhegvVgzzbN6DSzeAdgBOU4zWDrMep2ZE9/tJLV1zNxzG7EU18TTllTff4yFHltPlG4j+KBLmG52n+iMRo40UOzCXLddkEbN4fYNaVoUPuklBtN2zsdyaVs1eD77D2iEDmPMmBo3X9iHJi0ExBlxAVuRyqPU7xnz7HDkfbIsHAS2t7UM2k4iOGvU9z9E3Zltgl+/5sRITiN5dD1THYZ9cnenSjBlE/R2971RZ8Ki/l9XmEagDqNiewpEBCO9Fn6Q786jFDIouXRnguU8AlMNozxrZD3tU08pPGbuMZr93hfxCnKkY/0lZRhFt0ehkHhfGPcyJosTe6CVC5gCu3MpgxJwgczU1NQDHajSg2aEnS/zwLqe3hWt/dSn+f4ZYN0WlxTVd7963hJQKvGuM/COGYg0FKM7TYZZ4nhndUniD2OAvWvvK2MQpM93tndMAJ1WPB/CVviPq2jBAobZZ8yNH8AeJddoP/IyZrbkiNvj5Fbp0pv7J5Qu8AF2JWIwBA4ChSJ98SEVBgw6AGd94a8+hzd4KInFUI540N6IdSIqD5DPxNaXkLYyjtnFcroksG6aW0UNxOj0E6GNqXeolfhX0FsB0S5xSqruuvROeX52BV2JtZFKWZkqxYhDtD+g6Aq36P6+YRpINmHo2zhpyMZ6yQEkqenItL5Z03C7NNziLe2jhuI5m0Do7jBLMhzDu3z+ZSHy83dZGnaFeAr9QeguBmJ/WWmR2ltZx3oqsUUfxTY39iMjF3npqtJlUmrpehTZbL5Kc9UufypaZhUzYR+/I/voO8+fx1Vqogy+KiXJaW254noCL889J+DcwseTNqIeetj6CA30SyAUxhPz7eBAceMXWefYiyy81Ep1YO/PMkSx46Ls+NJLjjAm2d4FcAIoS8MwdwD+/XTU2HQS+8gaXU4dr94Dn5z5uY4Vr12c0q9UfRMcQNdvyuXXmUV77Cb6LTWhX+LGzX/4kOmJUZ7x1Bj/6RMg8sIBCjHm56exqFR/Dx3MUvdri1GKLaJMeTwe8VfZzuF79jNy9dv78onm3zSoxvm5vs4QD5MpuxzTvocN4n96lnPr/O28cMz6XlYCS7XhmMn1IQBFQU0I0gMcaEGZIXyFoGsT6R4lnwDoIl3PyHSzIfrPEZOlg0Fm7eu9RzU1R89pEi9wdgyN11X5AvSswdB31BY8rfzvvwmY6Gt+0I3e5waIYA9kwiSIyNFdu34dbePpbxCiWO3iu1mPQVnXU6A1t3VLcVvKC3s9jqPDM29GqRI9AuU3OVbK6qARB3J72xW+ldC44BA0Fu0VfVS3VPVyMrswsfqpw6QJVkALcf1zsU3Z9vE25u4JnxsZBcIZ0mFKdnsDCmxQ1/K3fhn3yxQVP3rWIfLvYxZcHYD0twyuEeGKYRft4zjUKMdpfY067c8yFXmR8Ru7oP/r50WnyR/tpMTW6HLWzN3pTIo8p8RXFmh+8eFr9x6lrAPrbHC9ywqQAUzNq4h/3zfCjN1R4LVmUT1l6/kpnX8WDd1dZNSKcEXNLfS5olIBwYYwwixKi9XfPYGPDEe1lxo2/LbE2jueqNJhbuoP8csml9XgmMr9wFqwYZVCklZROS4PRVLxDP57d23QzP6unNdnE0bO3yxKweewm8/dA6QqzkksVDPYOxAJqSmq9Ngk7mRC9w8maze6bTUhJYst9LhzvycLz8WcjN6+VVf6EN358Z5TsfUttJXgCEonbb4ZLLZ5KVnOQqz2BSvONoTY6NRUnA9ZipoYh4430MfxTbje0clIOclsT5HO3ZSMQMDihbACg9WPkdbOhy0WGUZ8RpLinyRmsHh10yZNhr6UY83ZV509F+YtueIUgHoO/QKMOjEySs9W0QOzD4vmfcX/fY2HHUMLwtSrZ5t7wI7PZLMWyeVF0+o/qTKEvoNDg3FZIbbQnooAikehGZQ3HKY9xF4qFiTlKUE06pEfoTLJsBua7reeWh3eUOFG+EgWDGvCmvlR+6fPHiLOq5+Tknwq9aEN7Gl/Zi6wvnK7cgxf5eT7p6DnfyobYOnKRKkmfmsgSeaerl9ybU8mW7VSkiA7T7HNG0v6ClhkNBiQfPf+SMB0/+eHl2m6qNbePPBcAmEg+m+n+mmiRVGeHmXKSMSfr9+YvQcwPjIO4cx/9Q6uQS3ZIGby5FGYj5v8RnUmo3RtuJAKUH/eOqkuuzmBg6uOxw15ejN0dO7LJZfN9uS1j4LymWNOuHTcOpcfG6EI9wRL/dCw4zt9lZ5aTP3QHVt9rWxHzS4Adb/HxKzkuvs8E5SLenOLeIiA/eJ0eeDvxavqK9FpycNmouquLIJjyB4TTbXV9Pj/wuzI6FJhY4jsCnWN10WO4glCe9DrGO4fIjdvA5ROWHdSN1Gxf7ynfXG/ZzY38WF4o3Z+NWCdtH0pgNCpBEzYsgzo/txaUfWJs0BXAMKAtQ31LL4Q96Zpn9Zxxm6MXHM+FcF0BTrCV1mAlkSSn05HjZjOz5k1iVe7JtXxBF9x1ncPxt+PEv47+I6AJ7S9qh/nzWPeJmDWWqlsU4DOR/l3iCCqXqNiNfd+uwxWbrJAudLC/qb8QnKVPzCKI5sMPsttZYPPlyFwyVJhL7P0W8yWbcXljFkn4boxtWci8idhi9XpFcoXKf8Yh10vklCc55Hap7ci5Hbug0aYWrlSZtpiXrybQ6ogCctXlPPLqnLiuB7NdAGSl1/UEywPkHjfUOtpkKY8XwOJzzBNTi5KvHpOSH6AK3SzruJlGHscUYlB6/8A8XPm6mlhTGWuzs5Qf2Td0YqGZ4KqohJ6aHFM6Z7gvs4TJm4Q0bCYt65fQjAtDGg7bVri2HgECUMRo3K4aADrua9koXXXfGpb+lTcYwR/m2+kJkcUv5dzr0k+DxUBFXZpD7dC1rGukXglidcbkL5N8pVbBIRDtyTa0xIFpDunbP5OJB1L0DUWfFr22lm7rdZ4C1nGYdaSDmLk5JmXBz5R7UvCWvamLYhdmVhR+rFSmHGINCmRh/lWyIXY6aTy6C6KrcWebPecVS/ZsWmEy0oyf36p7K06o/6YCYUrmYLp3Rrx04PqDG076C3sgWkS2sBh6bygUYfLarYbRq70X81lFOmYIg57CZXigmPv1VoJky1A/wKwtH0UYY8KKqxp++YZmIPf60yRHBxOQahjJmMMQugb8KRf8CPX512mFTj9396RflSO9k77jtKXX+Eo+i75egKCxHEKB6epMgFXj5Ip8jZ2Un00jXVspUp5dlomj6Mkx3QUMPJCDSSb/xWLoqOev09+xkdWegK3zWZQ5MOOBnCI1yoqeKF2Xz6j4mrlNXpsWsa75IXEl5UKvxcXhvusxbttOv8Vkru4Ec6uIRhorTEcvNNOGBFYvUoOKgf8YAK1ko91seejsYID0XxykqPDV+HZxeSrQ+71zvHUM5ywOV4Q2iRVwl25OBrDwkDUUeh++7UrcN9BPwybv7RELRWv+6jpNAYdX9J1Hdc7x9FtSwdha29fRiHz1e7Kcu6kUkL3O/itcQjNG22t+04diJm+cdJBcvrn2TFQ6fFhEOrquCHS7L8++2AQHXDzJWfSRh2nOl/g4wMRUoHizZCIejmWgaSDU569UNt8PkCHJKDKwjEj47sPD75JEWxihBL2DFlW8vBTNZPo4j6d2pcxZ2uqj8mY3jVJUVGc10EyWvLA26ItXR4vpSOS6+M4yoK4E9/Jrwoq5ODzZ7gjC2+sx0g1y8yhvXaP+4zO7ZNXvZTfS97HYLJ9PGOaHqKWza7PHtok8RR2wSwHE8rvYzVH9zfqmhTtP7t8o95JXmn9VvPyWbmherngXiNBq505blwHYyHjhtCivSXMd5knKBBSaXJ/evJkp0P5fE1wFNBmeTZUlD0jA6ikUpciqNgiASeEeFlDYegYcJet65JXB0yx6obXJBDVQVkylcTkQY0UkKF0qp4kjyiGxlrg272QexE0APIpu6oj/Ks/ntvmM2KtLI5Heax8v++GEdHQ6/4l8crEalaaLyTaNgZEisnIB0TVN4O4ghhfQl7qhkQPtuCZ6m9Vl88JvaiPNFDVord3NyRlv+6/t/Y1ASgPoqsH8j0zRMKWlplziZZWSn/Gy9UGaQ+Mf+cVYJ/+oSZuZSE1TOBAVJ3NTXEFZ/kJN+WGKDJd50ZjAgOP+auBybVyBi6FCn0EuQycV1XCXpsO1ctNoDmpGrvcGX93m+6TpBvj/sQ/4WQICbJE5sslnr+EFmgyNYOyzK0OhZ45zLAbmv4lt3ON95DbD3Gpga2DG0mJrNKNywCVMznDyPTGdmzLxRnOZZjNv/RORjbn5mmAFvA+VHJHHx8upTjD0FOerENTv473zjL1bap4SKlIwjHk8xTGqzMPjcaNrHhb/h7sKJ/OC8jJCXbEv0OguSJA7FDj3NnTK0ZVF20AqDGlxUkGxcTWoC6Qclwk1Or6BkNH+sHVJAyaOFcwnFwQjwTeqyBa9Wqo0rZ3yGI3jfjX+YSN28GjBrqTLaEfz4BEwe3DKi8pypKv40XCWOL5bc5YGojv67iGtv+zaHXs/FTGk8iAaTyldc5CKVZgfcDlZSOFcATev+If4wDsIp37xrK2qNj4b/ixvlyAb7po6Y0f3R4so8cWKIInjVGm8cDcxXztBkmRkB167WpI4GxJdRyWcNEw7n/Td9mxL6Nr21rg4Xe+XeCso3bPI86OjSOtYw3D9KOhiPX4ew/8JWmt/JcjVMprWto1oeFkiGfhh1OGcu8JJuK6cE0UDJOfv2DiEpPyerijAEHjCxNWxOlyG+YmF/kspvTU7VDFOYG2n1/5CAatXN1RWzTKqYpTaXjwiCeF+VvlqFu/ateCuDaw1ghjSxX2Bgj7gMa7lXUyENMa6c9x5TuGqALMjWxr7rw298Y5Azdr/KPA/3d/oJ9RnxF+KRW57Cqzp7xCbBtRw3yltbZvtqpU1wQCZ1oODUQN65qZTG76rnsqNTBkYWc+4jlZCAq/wWKfu7EZq6qJiAMmZapvHjmrtnqrn7kkiYo+ME3f6rGC30Mwj2zbDirESc95NfFNpEcGW8pvPDdmYdHUdT/5wEICWYn2JWDbOXYEMbIO6KwQcvo0NX7Jo13KQo7M3x0yiVJ3IlQgEKWRnYcGEfEZ00LlbFdQSPVCri/S4mDiP1WtLDgx8A1IM3M0PuVZWsBpknT7fgeIa+uLWDywMiTQqDohPb57doTEchtXO5h+3DsW6M+fYLB3xwbfMkB8Kisdr9bAQEblPAZFfcuedNSkWSNz0dl7nVw0nQAZTheirAblwpcokfwM/6jLuJW5uJu63QF9zKZTk8kcfkdvT41Z9TbgLmoNynDXBajEZkJhKWnkPExdypK78raLl3BLMFC8834EBK3+z0U8ta+27ya6mc4HA32qb+z2B2FKt/t1J0DbsMAdT3xJMWDIxOMsZZ5Q/+qcHiWnt/DaEifZ3cJ/SHVcFg4IUcOcfOusCb00jkIPFE94LjGx5LpNUJxn7vHrCFNbZXL3uFy0FXk5HCR2plG/B5OcY4sPNwO/KnLv9UzcsSbws6tAGmg9J9AdVBQ7bczp0+alI02NhpPsJWcFpgu4rUuc0TqYOyYJh0MQZayVRehM18Ya/wu3Kt8Z/1Qtns5VaH+hQFtIhxLgkk2IFDZh7ipdxyxS9/LztBbcyRw4MnFSUjLaj0UEuVaS+TKvDynO57YkhGKyF3epBsYDp9pLFoEvzwzBeJ4NLCdps0atNY2YCbes1bMp7MKzmvXSpeEJCOk8ZxjxrvoYtSahB/ANtv0nqseaz6xtlCSeZIHOK3N96J8rDTbYeCiJ0ueelIlCN7JAPkFQwT4xGpYetyn5vL8WQrm1ldgz9ikTkZOgvHgszKv+jJVYACqc6cO2SU8NP9dwlIYZ3MDOvXe4BMK/AWiB2o6TS0DlkeAYU2DyMd2RvdHG/+26+CY2M62tkLrZHuWYdF8rGLn8F29z8dvQvkz6aDlt6CSAzqPhjeALdU5DgSOgj3Im1oANsyAT2D2UM1a5C/k8cQ8iJYtxetQ3CZ4vTYBUHfHi5EHGZyVPv4f6r6cx02HRxh1u2R53bYNSW0z9udTOjArfje7r4hJzBCWox6L7rGbgQ1zZtGvPdxsiA9QDef7dRoNb9AM0zuidZ0YPqB6BWf1Yzh6RoBq6I4raZlpoSyazDcd9LSX+VKRyWvfywLNA9Xb1YkX1PtRspsT37HDiOOxoAtfVzyRCcwEygw2BfYDQx2jBR8zPbF36aNO9Jv7TE+R6pnb8R/xzIqnHTCN7omy4eya6ygdYxNpMbPBNCII9rPve/MmrW/UGEsAuYK4d6lbZTELBGPEcK+kubRGknWxl6HGGrJrL+Y5b6Qb4Y2JdWTQI0g7F7UYiUN+DgOfUq/k2HnujAmTCwiJJuZpgGyYSqP6u2CNPiSIqQeTbTSCbNu7XoRyUeaePcW06ZpU1bxa/iepgrTCnbNXM91g7gPF5ciJ1J4VEHMYFPn65OgZiv/PqLWRliPxK+1+6KCeb9wdArgA63ll/U4mg+/p//WV7GPSJsA27RiVna6Obz4KbmLBBvQ+gD6/HmxBKPO0pMxxbi01HJTLDUQ4sCZWj5jlcilvkysWx4u2eCuGTUhOwdJuMam3DAh2ORoSYs6/UR53l/kZyKrplaHJv/j0xyqyTxDFJbMIJUeD7gJKMtrU1jVYdMhiJaki2FNpME44s/1p7YZCNUgIQk1DFc08xF6X/3Qci/Jglvgo5u4WjGnCOoBsQ3wev5C4Gwd2f0PMQaNM5TFgYKQMNlUC5oxFHjBHaDIf6MTBOWw9VrZMlmX4Q2RbC0jKIwEx72U3XKVFzASd1sIHWcUR4AyqN0rb1vv2uf29vrwxrP7unEnffM+2kIIUGGEB5QrT4pFV9O+QsV3MR+uZjrbKyqr2X6MdTGgYa8MW3wsUGrrvIvYgptClQepr4CrPnVEXsdK9Av4+wIylUQvM2DmkoHJHW44eiGjduYSYmGKZgSkOLCXjhMxCiu/dcGeP5Fvq+e6oIrpn6PcIxBFsIwBtSwOjrbSReGzS8wLGH8KzePpKDLA8S+s74AaH6riQbnR/ZJeTxd/Ux+KjZkqE82q5jJI3Knj60FJef8I39xWUhbwIUEi1oCaHH6O/RnVne5HYGzGsB8+eP25RvKCdMjmYieXsSUv4541H0YGpmlW+Jif4bSZcIvv9ggCYnB0lfwlaGTddF5Ud6cwSIZVBS6GkOv7r/dtliJH5m1K2IHb+T5q0aVNFuKdI0keIFbwMj4nRE9dgJio2kAC4QjwKYmR1OAms6Y8emFYYwC5jWoNc+8P73JBt8sMOPbJft77HZmJOsFgFY8aaWoXYNUMEDyTu3+a5/UIIDHbulhY6ZKBfEYnboOxQTdQ09eLif3lHleA2rTHYexNADZf6otmlK6DgEQOBk3PX5WlPv1nQDyIDb2bQVUqZZpbpV6FZSXZrS1ktoHmZYj5L46GGTRfCG6qugvv0uRWJ1nOqMbsYfJbuv03H3HCGXsOiVklWOa9RSvBEXAYU8SPoxv2VlWnKeOeZ+hXLRRNgwM0+nLhdiT48hB6YWdd4QK75F512Yi+NoD78xTCc3xa0LQK7O+3Z1GU69Qi3ygkEIbu4VrVzNdrGJXn95WPSORa8CUbFvUXzd1fuqImGuCysl8TFEzam/gn/rAY10D2XS2MefY86kSTJS0uwTtnf8FU0hjlO3KHzR3zGbfoUoo9TiHAFmxzsZ/8fomNdemGIJdmF/0lpEUu5UYfR3qQFBl4U0Ok/wM9sWOXw/ggOExHJ1b5Aha6XkkxD2DS/d44JZ2yLKEQpwqTs0KsHLQSSqqUewGgLCzwTQq6yaQdVBnWrYqONVG/SokRDheunMsue6qgAFlyUin8ANc1OD9wuE3S5+Ls3XodRsEz5L1WKIa63QYdLjb2LJfNXBZVyZDxxVDYXaudKC13vpAntiAz+9e3rzE1f0we8/VCHNiXVXQnR0OledWe6ochg0Z/04S1BGGYfQ5necWZBLyee6wkzjrFBGhr8w8DOxUWx0b8baTwmkbccq7yy/msOrs/TY/JU3S45zeMjqxeFxkphP0SOqfkU2LbHezZGqYs+sXygB0w+F9KMO8BlM1BMeTYKZUBR+7Y/mwtq5kYQnf7sRt3O5Z4tUMXpiG+6AI+Ez3buzCfNTCuDL21x55MSL2q7rBwbxlK3i6KS359SRrnKfoeM3nQ0GhqHDYi/pT/uHcy4h8iPg578irCPmrr3T9tqfkKGKmJMGNHQDELJDitYHLthK+6vqk30o4crGDR3iy4HZC05yJqiBk8CD7dIE/4xpNKEEwdt3NDXoYhAoGhZcSzmBLRgUlCcwJXYKfe7kuWx1NvbaRKv+YNCOzh1mQ//LB/jScMxjWw9vGm1nxwRCqY+NEyY2jYnU5T5WPBFvp/zPgrXZcZ4dvf+PJ2Gs/4295wrY+acL84PqHvyM/CQdP/i25IS9i53IrJj1+MJji64wB+H30asjMcux86OgxSfdpYyiF4F+fQIu9MNgTtxNWU6b9l1LjpKrfPCw7+8TyCX9loMsIJXhe6vGv5aVJPeByrWoV/VN0M/DEm7Wo+0Nvwi8R/ipr06sAmjYoZV26NHNOp6ylwlw0WumA93ZkOUNbrAP00OepfqL9FT18cjne5nz3ZbnFmZe4RL0xn3TbA/F5XSk8nghJ8nPAZZDTevf5XO2FDJyu3DUQSpSrXQlCK+h0JH/bNflF/1DuSU64aqJ1FwGpuIRh+hjrgGDFCQ8I2bnnC6gHnntXFiU/o3d9SX3ToyXZE4U8xCWjmG0+Io2KIQjR9+kz/uF78o//vN4RGrkDdPv8DwltoOTaoa2P2inz6sSwi2udzjMbV9iCGviViILqYpSHIaLiwzpelw1MGxKVIwlMJOCmk/0x1WKZ19imH5VgH+ubb+cCDCI5Lsmb2CjR522mOVLYSex/z5Jwf2rkLHQ4tqpAmwBAUN11UxCjbLsHz11hfq+SwEQpZGvjNMIQSsmeXY+cejeBmOSiCyHnsH/dOa3vF5s2iT2VpByj7YIM295M9eZxvvpDaWXbhXDAux5sqdAEplhKBnZYJ8/1qYsfkhqvkBgV44kucpwDVJwGayS6x+6VgeJBJIp/RLNg6rL+7NWlXWN1CWBmp9DKMcZFZG2rejsucg7OUDkYFT+ZBwZNRENUUKRfBSnKNjOJanc+136otvltWyPUcZVK/+JlgqelJbA5HoL5wSx8NZEYqhq+42YZm3AmbEQY8KI8/A0C7eTYi50cvahL5flkcfgVtYY0SjSG/fm2+LxyB/pMhJBXsq/+WnwWQQ+wO61tKy2Nuht2CMN/+2E4c4N/XF6OrssMGBzaALA/3fQUmCWjhhdJJbYqg5kkCvKygu/IRPXWMpOfu8lAWZz+hiXMlKNxFbj9pfsnm5BiQmxGDGc8FK9R7JYLReb0yYJf1ZVBKswHFgq1oVM/ZBwmfKRuW6MdTWjmZS6HvmD8o5B7vW9baHReuadhVotSjcXDqcUV+KWM6IgPgDuGs0pHs7MofMcFL/ASD7TULHZ3/EK2ft4PiSkIg/M0YexhmeoB22FKH2cNqUytv5Aiy7Hbq6aCfLx5h4noRE+j2GouLWqMRUi28+UwxVlsHDuJt16mgwcwdFFDtN2HtqDs6SMqELT197apUTHTrSqqmUKsLSOhBEMRANcCG+cCH/1q4H0DlEF6P++cvWT2FTEFfVx3rccYsrexNMnU2KDyXmhIyM6BArmlNWRuXorccd271VR2Dek6+wYszvlHCghNy9vPDtCVngAXNL4RZQMn2u7SXX8puPfgnzOVPS81mzrwInZDiO72tAiypYu3SUasPNNzgyeC1q1qz1qU3TJX+ztpjYd+GyzlmMhusPbNzr4oXjCfjKxzGe7G3kb4jhUZwtlbXCmGTfGnepepwEu8c6LEuiRax/Zki25HbQgOk4bxAgG84wP7tgdWx7eRvetEIN9z5a0pLT6X9e/8BUOnKvZjxjl1XXQNEZGgYjXH+DAWDKm8b4sQLfEuQhB8Z7zw9BKLGOvlYMIfvrbpYDUf5/Wl3p+ZU8QtfoJQyXW5iiQ0DiGMNXQmoUeq9WNJuVaW+d+ISOc2oazy7utlpHSI6m4Zl9Sef5E2mrdQlwbQ79q3Uit97rW9WjN8P88/XxBLxwcKBxzamzM/HEpMe3e8YPibrHwH+uyddeKHHM8iFWlDicMiGpztlOOoNK8IoaW0j86EpDB98Gbub8eP5B1KhkX2zRUgtf4KkZpiJgBVgQrtBOAyxagRnIBbR8cEzcSNPCotEeapxik4IF6Ku5qfgdOZs4Ml7sl9W9ekap61X0+Hd7nVcjxdoR6YSH8Nsg2FZGvpvw/yXU1Ps8l6cLhZJ7xNJ4Tnnt+HA/tspqqQ3R73cbPmPMS4OWFueR+rujcDSy070BQiGoyQjEgMkU2oGEF5r3n7yhKPaS/+3Kos3yzaygeHB19wWeNkdBpa4Vo7Fgtut5RxQu+OTPfuk3/XDA0eSO9lEYpEh558Y9Dky8rP+ZEpu3ligYv9e4eltyo9E7XzOTBZ/tY5imU5bbbDuXjtZQjPSJ9q5CSZQWwjdF8SYcjiEPUZMpQ2CwE18LEiwMzT0rSEG3xRVQyOiW/H1TjnibE7BYVyKmmO4qyf1F8TBzS2+f1RG+J2QVaaH46OwrFlS4Ewa5oTd9C/7Rh6Upfh7eiIB1B777SmIODRBTqKzXrwiPox5rhxO4anMciIZGHcwLB6w36aq8FQ1+9E5AbfQG3iRbmFL0MDqpGaOWAZdkf8YAPwWFU8DYTGhEExqCFsA5KQQASS/WkcHjQMfR6Q3r1A6V7S0g+gz1Ti6CiOe1Gbn31+/ZdEWW0rxTIvmP19UqesejenAHMXDHeijFQlb9DAbBc5+OV7ml1/FCYbKQsbZtmp+QD7ky4W81UNzAIwQiajZlYK1rTBVGejbxSq/kKkvI+PUIWLs578ho2RB56//YQSz5odFU/C0P21pjFRvEesL+nsHzVGIvw7E+nOzYrd6lFdFEXV/BmMoE1sLgLmbNcSz4LgoJ/tQIWjTuApZSkpPcPOaJ2FNibuQihxzxRRNl5x+qkWxHBj2Lbofo8iiG26SEBcNDbd1z6SrAEKUwDo7PvNRpZ/ptR9SLmyJoQIaydiFEsa2/q+gjXsDg3kU36NKa3Tl3rOZvLy+5fP9A/LKprVsdlDG2uqoxdwppqdSzmvL7HX/mhHwWIy8cOu3IK/ObKbaTryPG9rq1hxT7U9bMBzJtuhg7IpfBBoHnA5ltH/R1xXRx9RpInFktZkrbnM2IYg+ED2cOSYWbdSzYMfjFejr06S/cXfXPJ87zcF7cPnYaSlK7guFnBu1t0FRMGCnbv9XLDJOx1hyd2gwfAyULD9es7D5QMnQaksaA7xF2rsaK1aIL8afumypTgP6mTBosiX0TR35+jbQKH8yP+RNygG9qQaZyAnozseLlSCTHNgCU9G5wEjvjNNbMw5+bmmrIyVLkfzNgbgIv1uG382tZmmXdmoEK6ARrMI1yyWxIA2CJS13mv3VcXQvG/RVFn1U6XiaHKZ1v3bglM7UPyPAM/7018/9Ovv0u8vct9nR1zEjU+X1DitXyfNTabiaoDXYAGwBMYUebvHxmPG1nEeOHuDV5pm/wyokEGEefYch+Rl/BiYPp63X0I/KYk6UqEjLLYuhOlaKn/d6e8dDtReBMetUWGYmwkcfL7pMpeSLt7xWD0J/Nvz9BKnD9qQzj36RETgzvvD1rxToWdG8O89IL/t4mopf0V/E4TQ+b2YcjXOefNDXVv+S21F25ofwJHGTlyngVXxDFy4No56bsEdYQOfJOOuecG9RnJv05oJgxcl7c8DmwtkidU3+pQnEwVdW5uuhIM5YNrvLGaJ0OLuMFDmWIefAM56nDeOOPrAzSIZss5qkXZvAG760tJdSHcvzXryr75MvOzya0zovfoI9CY2JdlmZwLKI9mE8l8jgbcv5clIy+0W0q54gDX443n9SWdQ5fzFwcPKGrtGq42W2SPn1sdn6UX8qgqxTKqvki5O0VYS3s/EuzmG9jHbdbMpbnijcc5dkwW9DWkpaFviDOHIYhWDOxpLTPrG7Aeu0dGx6PIp50WVaxhVygBjfmTRMsHvlLQme7A6SmLPtQaH2pwALuYXABTkG/Nb40r5ah1kfXFk9KEXIq9eEQ4oF10e/Fasouh2PDRw5Z8e9/EnKpMe0LycNk9pTsrbUfLJAeJzOWwDu8EsI0kPhrdgY9dfjMKD98i4iYjkfEDRKg8tn8AgA9bBmnIGGJ+m7pvMBAZbugEDR7TCfe7n8H+rs25PEjpZzKH+nZ1jD+t1D/CaXnFD+IEehGzxarwFc56bnNzYbakhyMlD1EF7Y+67IeSiRrWjlgi1EvfJHIN7tnUIXHAh/75mAESbUAJJvi1LkG+dsRiTbPDU81TbAj/7NOaXrEXaVaWgNDJ7tB4ZAl5G9SjsRf1DwU4yEY9Qr1kAmNAoXOpjRzldlRgZwfwJGzTZnJqMVRp2W5xM/bYWpHyunP6QXOkTeb1u0HQlw2IcPUDsG82hHCiAV6ZNLAgGAgx1/TmUDvhCSlEX7Sif/5QBZ0fSK8gfpIUqF4tJMDUIYkakmJr1SSB8tZ0GU8STgnjhM/+KgHpwSDlYZssLtJ7agKz8+mDYxxZ4rhm1TncOTLQVUZIwxSTOrfm8YSpO3h4b1Mg6G+h1k2cOwPz5sWlt3fYl4HgMFS3c322xXgxFoIxe9csTj8QOBXix1A5veaVYuHyTUxRFvXJe+xIQubyy1anYjD/BC5O/zF7U8HjALkafxrSFkXOuBOxlj1nOXhsW0WCxRUiCZ8Hf/RfkAMdmciZO7q8p3qmdCrepWuG7t00GHSNUt/5O1AuZteIQBTrChfb4TlhEX9fcZ/8OeR4Ap1WYS6WenWnX1doP8Vs9QPuVSipG6UQtze1T+IfwlcmQc0hSwSmrt+TfVqm1vENcV262VcKMMjh3NyETPQlyEsobdjab7Jk2h/ijyYDsusTbovdGJFh9gGjkjQpwdzAw4Ozw123z/rhOS3exqXWkVG3HU/l66kORxKInLo/c1Ye5iitm9JPuH878epnqBnVzEC1tsalCpHUlFDzwHbO+fG8AXzQsIfEN3XGJ53v+Y7qwoPKlkiGcZCJyaBf+QtCqVtEA1IJj+BRppRDDnGob1yOllfI1t+cN4UMYPFtzdSxyYPdqJYDRyvCMTOQTulbA+D7/JT/+XPItGbjD72OkysOxtzeYPT9aDuZ8ncFPwqWCzPkMQVUZH8LEsa6bucJXqK9FEhfM5bDD3ibzZ9Kws1lrWEKXc8iKdkS3I8Gdn/wfzvreSHpzO8Wb2MQhn8ucS+ajqbFMEXZ3o9/sYqGHCLXY+KRWs5q5/3cb5OfDzzGcSyBkYltPmvmVcwNMYdjJA/RmHD0Z+RfsdOz48CpTLyi7hmicHgKVmhuRHa1+crGDHVIYggWjN2gnyf8g2gW9rUtJeoVKQiuOtvMrg+MKEOyhsr8+fyUsePDrE6FDY2mZuHa7o+9AkUz9fBEqr0e1JGgecdSLIq/hUo0DgW5e3378k+kti4K+/7q+O7rufV+iKFqjiunA12dwshXbrUObcmZN8qml7ZBf6H95DE/2VG67TEkGpYVqUADdeg/R1LkdIizSnhpzVuieWx39J7tEPRm5fx6ZjelFYb5yx5fIP0D7pngjLgG2UfyjYAOOHBLS/HL/WizmXD0+9iOEbyEOGWqqYckn+1GgNVmCvu25fPKql6Uc9KAJKyadIc5DrUF4XZmpjQulOxiZ4azGq4e5G/jiINQDoUoxUx15mFwslIkru/HTJAnjnQaGYEflpJ0Bnv+11m7giTZfrkEl53XX+mJ0lm0eeS/tI81pF9lm7qtabgo7vPmIOLIRqEHbVHMNvuZ4Kz9wK2L3tr0zD8hhmXuzV6p0ZXrAlgDkDOCn0rQPVQHc8LUkX67E5ihpnrurpQ38gSM2Lsy4qmV3vpdWPpTrE2lcoVv4nU6hWQRGeDaybBjxiUuF9HJgKTbm6xoS8V8pIICLRFVl46UX/36AZTzaFZKhYSLJvdeAytxnAI6IsapKNZXhgGFuz3FpV4s2817oTW3ks7kn3tX+0UFvb6AKGwgaNFkOyP0OxPXnazWDVuEptsMYOVKgH45GtIrK4eHLq4LoJmy8I9aBvcLeSP6jOCO9mF8zr8I2U6u/P7XvYH1WBiVYv3DQ2G/YSJ7TcY9KBn8ahxnn37pNbOSku0zoVFeyZUxB5583T1s+euQxlgpOZIZoV/O4yesELfN/+fZ5Z+EqBE+f0duvBDQm2Dk4DRBsWCGBlWFJU0X1i8Qn5M30TXPVMQIqyzz2zMlCQUbW+DJfTKXovKKxskC8KdbaowAm+4rG+1ldgU8CQQXYMEEoX+R8oDtPgLe5JdBx6Y6gERZJfTI58lQfL31vU/7/79TkNUN5moIBlrSFpS1J1G2/F0cXpXZx2pvHh48YcUMSfQ2K9kPMIUDezZDkco1qCkMoKY77/XruavAMFyPTF3NRyIdI2J7Pj7LA0ZqvZodYVkSDweQ8LKt7p+VMeJf4tPagBnNUQ02fKwaEdmci7+6GQcod9vkUWFaUwPJeKLj+bn+nk1U3tN3EL8XYnKE1T02TKpmL41TX332KI4MBt5gdrjSjlbUHkO4VtCQb6+Y/ttEri90vkh9khlAcu1SHfJq5Y1XC4oHXAvjkP9Jp6Skqc6rdWrG+Lq+s6LLTBtAJPt5mFdpGNXnsZIfuDLHD09q4VSfrTYVYkNqLv7K2UdjLalvfMuObnKoxTVz5MU+mqEfiFSo3CuhcLIYPhvjPVnp6VPKVBKWDBlgnpO1uV8vdKj5b5wSxGd/RdDSkKUl3oYVrZ5OcGqvbQkfynRSavm1PKf1mRP7JCFj+ycfjZMbg9CFiIf3juCzJFVp4F1N0dJDC5ZJTCA7ElfFjgDnK+zAwGL9lmN/TRBotUZmfSCL0s3fASI8VpqGB8O1BZDsXd0ud4cfozwM07Z42JBrIhUSdSLLCOGUIazGEjdREViopfM/bZEIhR5fj4hCb3jrrPzzGVhpAwB2l2M5gkneY0oj3FVAGzJaMqdDFISTpNekFCxD9ygyjBxBW10YXo5I5vO4yKuzhh+nOqN2VYXasIMdT/bdFu8B0MqhaGV6sgY6qj9y5k8fFg3AE2IRrmcke3Jw/wrsD4UxcjMwwCaMcW8yxS4XFzpOROu9XnT/PiGvfO0zLzkDqNKpeB2YQytgARRQDp7FxHfc+aEZKPwRPwu979Wv7lgTZsXo7lh3ZbkMXlgkpR0oJq7ehs+F/YkyQeqtQPfOuZKcWRB0okaKG2RBPsEELocLU3bI9NEwr8OHmXV/GcRSA2mef8g0Um+8II3u9lQwMX7M0zbXir/26BkV5qGS3VG2utoH4tRqUgXCGFsjxMzjF+Gf7sDkaw2c2YeFIcekMEdQ0l8RPGbJwEhYd22MiEQ1EjZB7HfrVUr055dLUdJgBOAZlxYMYlsch5dWlgsGjNPYktMyST9VeorzFIsbYUm5qhdfntzmE43MN58+jKhh9Lraq1HSMjVKXl11+qxGgTA3pLTpDRWsMgH/VhzFPoNypAwqO75YSvFnFOeScxbBFPMOzfYp+fr011I5ZN8HYITbT5Ppmv5JPDXa54M19OmOorIfI3MtFthOwL2jEdjElU9LOsGaMygjuOzcN7YFzKgMVUZUAthizJMBnpQjWAz462hwlkC9tR8y37vFQac13Us67rW/wOLFc44Hco+utBPWXNjYPHzr/X5C4xDq7yBRat6ptAJxUKFP6b4PyafjSBa5fF06JQy58Ufjt4Bk0gq6X3BnlJQdEiSMgHH2lvp6vj5T2NLAHp9n+4uH1RMMJtu+r8wVjMMNp0iW5ol5PqivBIFdmCoDgHKFDZj7OSWpMlaenAGp+TGzKZi5PcbI06tkJ8mxV77/sAhc2AEuyOJHxyhwDPivcho+dRtRns2edNv8CAzLiTvp9tZmbPFmIJm4nzpcBcXMOin0fZ0TPoE20VXYpsCc6/i7rpIPPgENSJFRfgzDyr8XgEP/MynMDObtr64kLQfbORSm32+CcuLhvRlPe3KjalddUCsCl+s+UZICwjP4w7NNcfhG3JoQ/e3nYBbsBMAHrpi9Cnt2nGwYoQKf2UbqjoOxekBoMMc07AOFtIEm+46KDFAriYFgX3dE3DXyapztoJ4JoM1VPvZLVZGqDVkMWdq4TTE/YEI6IPBknUKQ4yhZ2+J1/A20GLcWJq+W4fIuCGgsWAOG8bAx8Ta8IpiqT7TYHh12doSGwFAXtQLDOd/ctEevBV+JsduGi7Bx4d8ZmPr12wjY8UPQJw/7c/Jsi0RRC/d74dBBvw36dAapUVmCT68dJrIx7K8n3HEZB56loFJtD6zgnIamQAFe1YX1Bl4/p3M1lL+fGJTxEDPBs0xkU1+v53ux66kM2A2xUX+iQy+/hom2D1VlzFprU0bqwU9KsKQpKED00zcN4YPwa/Xa1LcCRjuO/NUgdI/PC8Cg5t3pjZepAGp4Iz+423fxPFCDmCSY6h0tit6ooQ57W5scqdO22qlBLJktN3vHIYz5JvrSmBZjRYyo0E5WdaxGQ/Ui0ujIpdY2weIZYmOkQcwgNK9kBLO05rDFb9z3oRlziVlnr13Q+R4jD3YBTr9xi24GVwJmmznNBgoPoMxIpeMxlA8x3mG66mS3jxVTiOJboEh9XLeMh2cOom/7n3ZZCK/kZItLEigdI9w/HZvULqZfpY8sOfDrAN7XTLrTuqbWYpUcggUy+hy98iKNY6Z+tDvcXTL9C3ysfeuamUvwzmkSzXJv/rX4aL/a0hEjqSftZ47dT4J5UKlWpVspeSMDbSpTMTre1e2R30v2LskBkNefqlT/vKV7lJU3AiK1ZHHdVxYXQcCommK5q5pUWDweOTwUFkN0H1l3nb4hOqaSjNvkUq7KBTWiw0E8GG59UqYHCUNt6I7EKJyMNc19pxp+Y5gYWjuFin99a4C7gYBZmuTWFYFdIRWM6Ckfp8xjXf2Azg/rY6UqFfUENjIhNas2fEYuQfE1ZsQf5n+AuCfZ6FdF2yKjWp6gLpuj1g2auqVN/QPiOwNpjZJI/lPY9+LBihWeQfM0Ey/Xfd653ERoMWPM92639P7aVVewM2lHZJuewHUhRGjbhm/wltnzxjo8jRjVV2TQfXcFObPz0YHBu2qgRlODAauLDm9o4RhcfCORTOmso4G5O3TptzVvsxR3rg6BiQzdkkg9CwPfzsAMN+aYkX8GosnAiF/X+xhinBMn9n793Q2qfC5FqF5NgFO8u+jiOu5KeaJzkZIMVHlB4fbFaJsIP13k2bFrvKpy9y4Luog38MnNqy1S2eRTveg0Nbf3zSqbIHD99JLuexeu8kcLaerWsfRvIKy6/T0cNA9LF2Gf8zdJy5sgwnzLkcoHt/vnHfzcHunQoNCM3UuG3Qkh4821wz8H6IZFf0gYZFC5mgWZr4bwJGwU+o5bAdglEYQ1T7i8cjQFGxDozzRY0JUdO/r9uUpZAYPZz0fWgEm4gkYfCReoUo4BHLA3QtUoGqGBss5FZ45HgChB8x9wS54azm8TpsTcQOAyCTTRYRTaKa28O6ihjss26Hs/2Q1YjzSu2V4A7ad+E+VYM4wuGISf8lsEMuTREh19K06MD3Ccq1kc9MAuOfzfr0GPPgKf74KJ4ZQBdOaCB9+n1H7IE9625jO2G0bXrRjssKcfGd1AbjodZ526TpfTwIgIdLPhDxi/Tg6fni5EgdqPQ+vC+l4ke/8Wu4ceY0zpU6oYW3uZeEIwENi8eK6bLrWf78urWnfemfNJIfUosbBgJ5hAou1J9zbSFLViY4d8XPEMsn1lGaHuKJyqIspDUy48guWSfDHIEANKcxatYf+JnaMBLUA51Hods4KgwIVsIG8zDCpgM3vd1qD4YmTCAHH4GUQFpE2a7rVXoOk7VLAgJNH4/A3EmsDHPeTE6HumtMav1V72WLyG05/jNSfcprc0j0aTfIzRbIcbvmqz04GaKIi+uoLmajeHb9EgsE1IEO5H9pdmSkNPYN9hL3wiIqp1Bj8K6S4L9OjCk9xF1FtPiBSOuGXIizX5Dq4iYldQArZtIQo7pff0E3wJ3pPEU5QyQuVdXYuVsQUECKVJTfNuTnV9LLRmDvE1I6sI2x1vo6+Uzzg1iMChzb021SxRCSOAqU+9860fFgFH8yStpWn5oueK2l1OqyDRk1ccd8E6aEBfj5RjMemF7m9QPgO6dfZaqDQv7A40yf7Vzxy6rc5RshTRjVXkG30WdxLu2i8F+ztKdty8G6ZldoJ4dPrSkFTn4aSM6AUbE8g1xzOWyBQgRyVrR1npgTfJypWQy4aYikzGiiP9TgtGyjucqg3ry+D7rtK+/EPgvrh0HQOnqyk09MQsCqBnQ6K4qMbEWp5j0glAp1cgpz8BaVwwGeW0e8TEx0+dvhsh6Z+/sk7zFfCn/uXpHCJz8BBnJHylrkTMDYvajmXRtk3LA7n2YqXnymPMV+m84/VYrdCoi4/FQPApkVJaZVy15IgWisrOcppfSWhsgNLnO+zKjx+EBFu+bcUgtVr+PbkpFPHK/d4r8Q/lFrhZEY4VJpz01/eMjjUclNoP3mcQSH6doyiUC7filHl1Xc6g6Xi6k7f15hMGKQKEpaNe9uyBPAJ50m6QAZVmqzTPtnH/ArIX57SwlgnrnqDDDiQ/FqRtAQPEIUK52CycwxwZq0ImwVA/BvCj4PBdXiBS5UYFzMUcazqsGZEfYAu388YRmMf1+TCplmzKeJ1dsqCVABgxQIDrfYaZqEHspPrHXrVzd8cBn4NMc0dzrCXSigiQTvJudAPbaLfvmP+yNe4cwNms8z3LdOG4rVIqddDZ5WGKmXHrZ0ybFnsl/NSVU7p27pP17FMk5nHJ0DRSHz7dvaCIJcElat1tMMRC4gK3ZOiKpAISlAk9GmX2Esz7ETSQnMTKghmL7e2Y49XtiugIBaa7az4Recltotv94ulbtfeE8EL2H9/Mr3/dUPnYikK2pA3cGLIcw+E300xFLO+q0rngitf7DzD+uxDjfVmuQSOxr72VM6gnezUV3KB7jxW4KF+mPYw8OQKjfb8JewVDm0MPCFXZj8S0llEdSFOkTe4u3yFodKWeskq9GA3QUZNFtlDYV8+N6FKLKSJC0IlEowpsi0KSXqck97I1Y859JHCxcAgvN1wx936fvhy1yJMA/agaca395/wWu4MdMML4DwOZ05ZIXvKbABx4LnpkMQneLrHm4QfW6g04kSnFB29FFCascC0kcoe4DtNgt+Ju7KppgfUQdaUtIOh2hNbct39lkFSa8+PyxO4L1gpSNm1T5236XNHvh/zWExBoO90kZp2wiC0ln3q8x4/xSjYpBflpdBZS9jSFep4sxs9oF1GMAPiMQJPwKCEZ97xNLojOQdBnM3qYkvlPovjF16lAuUsDlJuvAb4vFCnK2chK1uqLCDu1e/P8t+FnuOnmuPC8oQJzdIVSTbOPS3DnrpjtvPBtdX1V0fvVbA2opj0wVIpKlCWfnzpgqOKNFP7VdFlMrXzG4Zv7HYUxM0yf3UUj4tNwwL9tB+wHNn1tHCBpDcrf1ihMHgnuGvJ1eJETqjSi9jcTKYxLRuzzgGio5Zg4ILmY/eELYpEcIUVRSE7BCl7y5dvuJziF18siFqgdovmyRgaem3rgDpJ824lOmVq/DEIeeiaoBBP9wRB2TyLcrjSvyAbxgK88RAD8Iw8oTDqkFf8oeHBL1fSPnYHc/pq8MyxjOHoIWVZPDp5CHsuxCydRteNt21QOpPKlbeZ0Bubg6abyyoahD2Q4r9AMwhvAOjjasRFazFYVkl27IbIs/X3P7kvibew2rSIrXQK5oSabahubyGiDbyP40cV+7emzscGUq79Ws+JPLQC9cYauM9pVccvaqb1BSNbKs/2jKhGV2YZbACYjtIXHtMmrR0ywJHyA460aOEDh/mSsE6hlOsupX9F1Z10iWJ41H1esJlFOJ64KT1zQYGniSFyx3Mi8dQACOjC52/KYfaocF9+VhVEi3CN6xcE1FefeLBkoaQkLcz3v4tozKcNEyyIRjKaNRI4JSQ2v7v1NRS6u6R9saQuUGfjVjuxobfnw5RR1nw+STSRu3PCvLat3XRzlvFuGPapNk9aJ0Wk1ZKQs+OcLgOfvLEhviSfzE0FoCgYYAuXtRndzwv20WX10VE1+FOMamF/ji1YmosVtUUMfjv21nNJKiX5XVX2k0m3PxOJt8P61erbQUxPZZRURy9AQtOStA8myIlxcxNCfnGeARddaiq+YbfkozbSrSQpwY/H0HNS7bk9BxqGlYB/q8zxaojgxLXTXD6xpzlBYy0pXe/HjSuYFUT0ks82FuY0atwkzSoQFGZyl+GAHfLxWNah0Nz7QIh0o0ApFqBAWel5s/s6jMNsuPUBJcXsHVWdK+bR0G94ItAnLv01vGG5BA8uaPetesJCwDvk+kQj+oNqQboNyxwMr3dwjrnuesyvKi6czYnvjNiUptf30RbmTFtZjG3dNAf+2Hzi71xzAouczriUDn9GA98HnUxXZV5K521DQcbPqX4rCGa/BLJT3ExnaWxh5fABGlF2OSeO4IbNgTsE50CRQA460clp/YCmE4zC2bfx8L9HfKKVaqoFw5YA/ck5sntJTO3yYnEMRP2B13W6GC8MT8BzRUGEN7Y6F8dePhxvAPTu/Y3R1dMWZDjGD7wTqvNRtA448KCyg/8Lwk/6rthp1r2xMCe+a+wlGnwsjUVQzsgGBg5bbPDVvZNAE86I5M/i6pgWkak149FQPk10KtZRcviQChUrOFsFTRI3lSv0ZJELmGcDckiM8TbeaeGyxBgJqSFoUu9eCrm65472c5MKKOQlQDhhYKfZX1nbaMZepjabquMOdrL/veAYcdJfokesCAHkN+z4ARwB7t7gNOgkMTTNrP9TCXDbSQayXFQlCAsovrlHy563/qhipk35RTE6Tk1PaGeq7JYBUm4VjqybVnzVXUwnY98OvgAw3RAvYFo6tq68G2li8P4impF/xa43kkEm6g+DmZ9BMLyqx0HOe1w2VwzagHOsLhJByOWoTGJmKGFUdC1+cTyxk6ppWpTFPFdhNupOMxgBS11RUm2dwa1Ck/hsGyHiuaAfke7pJEdDzwVg0VAosLUpuN7wDkRDtaghqm0HtQLfbKOyQty536OZ3SjUUHCT4J55SDP9YmP70DYqPK0J3kr9wLfuDUYfHzRx5wMJhCOROSbuNrp8OuY0pPVTyP2G2fCodyHO5wXkdQUgJEBo/j7e8UpVNldaINhJd+QjP2H27ix4DEwSIGrIIyRN9dNsNDh5iG0KNNwjn5B4aIIQXVpnPoZPKNxe6dqjJsofckqmNjaM+VN8UwNGd8+Su0vDIL7/smqEIfsf9itXops33a5t7WZfSeClu8rHLeZme0Pylmtz1nP6EtyBbNa6mBFAjGV4H3OjU6zVJxzMzjjXIcJzsRhXXIp+uTZbMcpliobn7zd43YcLjsE/QXtAWW9x4PMWdfFAt+RhCXb6GBSPYZaKkIyt8SfFCy2bMarspTkSjvRc+RV3qJkij07Z5lxv8JaZS8HeBRXXyb2VWyKcyy+/swSD0U59/CIsUmYmf0ggUOGe6ypAW8cXnaQWQJKhHh5GczMxZUBIsa7cV1xq9IOPZCRgSqUamorcPlC+vxYTi1C/Fzcf80V6mPCkxYGbHKHqNPRo/wvYaXp/lA5TzOXlKuf7+v2khTcbWXrnGVCgz9ANcKZwlOWtqI90iwejkEGtk+mZTS6sIq9kHtZ1cNqICiOKaZvEOF8jT+TLeBrihtFs7AQPqw6rU4qngtvG+4QVRelsbykDse527mPEawKRohUVtMYeNeEgPXwKTkUh+t6DP5RNuCIQUCw+TGLXX58hf75J/PwlOVhk4m7j3NljxKc0vivwmnfCbe+v7U4KnIS2bmHEVILmuiTyzUMZMJveWgPSqfZxfp9ExkdkUUs7GWMhic28oRf/vZa5FrSeunmAjxzA6NMZRZBOSi/B2JdMiJ16GRJ5WqP0j+nvE6uosrVWxpYHdKSjHzq4z6/yHPVibDhTuNbN1rYvGb7lE7NuM1EHc2HR6/NNMUDy4MOyCU55Gam51EVQHOOEu7krHoQ1EKJuh4nZrQLSaMh6MskyRTua4VkPy/qtItx0xiojrzFBdhifkKKhxrVdsOE+Ew0pIljMJ5+NgDmLaKWEPjAZ01bbTHXMrgJYS+fP5lQLcXz1yYeos4j1Gp4ZtK+eV4LYtWbIKrxZ3MUfCu+J3v/yLX76WLq8znOKUh11UXzH/0jKYzE97c123NoJ5RJP8O6St14akhPrbguSlpdoMqA9dB89vcaMfNeZK3lcBVPqBXkPMIRrZfekls4ai3v88MBfNoMmXZN74NDhHlKc6/ddk6JYEkZmebwiVruHYQ0tvJoHY+NOrx4KXjkEQXSjaid8vcuRb9kSgVOlT7jCGBrhHJVayA7CN8fk9YAqsTdoQjcLbUdSxTxK61Wh2u6deN0k1ij3hm8SJ8JTUG5quwZ1EizidWtm6jdjl9yXOFO+6vHAUTJPc/B/73r/ZLSuTh2Tt6bYQY2OpnNbqIMKWSg6kK3ywraT7cC7c0FSaquGSETaAZYQ+l+olbP5Fv7fh3aS0qbbRc6S0IF6uD0bI+I1ccCF0LUNFpm+AUcQdFEGD3XuGm+IiyRPAp3xTF5CU82QkLylMcQe0APP7IP1KRweS3qsOBUQdhNRmkqCM8YmbJ8FeHT4ZpX1J+EUme3r6TqFTYpQNCn+wTqZb7Wz5Xr9ZCfxV1LxJy6bPYumcJTetLCurb5TdC8AWxk3T4fkLrf3W891Pz1bjt02qYXwEVXVN8AdD/EAts3bfEk8q5nGL26hdYv7OKm/JoKPuRXzNsf/COVgBKNjBMjju26eObpxv2BEbcHIM4x4fv719kbuQSBVneYjMURGtq6rvNLWyNIYTSAxK1zpdA7Zv6HfhvMiBc0yKXV7ON9SB6xzOODOp0lkcntMK7MpAhtsnqu8mwv54olm1IWuAzQq7bpDT8URIcizUTjRWurSXijICrwcr3j2f0y1FlRZ1aCaN0EeHLm+rJxiHle1z15YOqjsERH8/CxQ41m5vNTqBhMZepYHXKGn0kmgdSkFvhekFxBTvgxMgyfZt183zwarbTM5kHhiADxuskUZ19dKQdzP8VronymM3whGbQoGVVFw3xFwVN/J+nDlzKuARlu9tuzdwYJHAKL4M0b3vk5KR+9bYZuTwI/QXtKorY8+4cmQcoSr1VcSpFN3A9T9Gdk21EX/t2e5aHU5NaIMRxkg7+Tf0n5JUwwBu/xZcu48veSfrOsCu4btC7nzebUw8hl/b+J5NfixmRdH/CzZ7aoDHaccJN97RJJl0FWWuX6Keku7/E5MaQLzKhcTMXAE6AaeezbXh3tPj4eODcQQYjBB6JS9ZvOwYZAJkikaoHoYBr1FzxsBUZcfwdB0YHN34XMGsdINfzgHaOMQLfnlEFoGPZOP/lxWpxyF47cEJmP66hnkQHyOAlfhEr3sxKvK3fo+d4Ay/fXho7Cocn6ePO+lppANkppaqDcErTlgj1LAxgt8Z+HQiKGSXEKRemI8ycEFH972do0EdG0YBEA12bbjv0xZR+dqiLbKHyFkoy1amBgHRsCZdCo+Pk6ZOToi1zVYV0Z1rtQqZP23urfs2WSW/IZ6wXmyw1U7oRILhTW6BZ3DgSeYY28pkl3qEbZdS37HhfU4653v68nNiPdgSE6YlH2vCHQ7V/IHY5mII6x/9rzDsrTvT0g5VjX591sBbeUwI6u1IXyK19ypPK/IY4Cyw5bxdpceB16/IXllljUW2HlU5cWe39Wf1/1WilaT3wNu3ISf2jMnxdiwFaL20QtfEX7sVT87blMvZ80Dv7481RbdSuns/pjiGHNzo2bI4hhYAJyPrqdTmnpVokblGmolNmjyYmY1P+AitpXo8UyUra3d4LkgYNMl442/d3mfPzVDfunJHK7U2lAMc53P8zUwODrHTdAmpdSTm7JdcTJKpi70ndxd4W6BoWdL6FbzTlc/Et5BkApRtA9dd8V5vlxLYrg4f78oFQI5dmHEAdx03QIs6BA9/C+I7mUq//A17lf3aS+R6ShrqpW/gQXC2fcksgKCBZEdQ5EtN7J9uvQvjj+rNYNmlE55/79r1oMZ5phcdGbcXKy1LcjDj8JBIaj/356D4KjHpdM09GjGsAiOKRPkl7WWmBeIW3U+ipz5vuD4lK19fXz/rxmdb7LoyRbXMW4YkcAn2B/Be0bVUJ9XVJzEzO4J9i9PIcae2NsiP/V8wMv1ySJGSs4iXDehmfD+RABdB4e4f36Yq0nvYhdT3nPDkzFn2c7StYQwMdgxcPvbigVqgEENpOL85xLryEs1AKTwV8c9jouuBgnaPKVv0DdxHKjvjuBP+ktnkA2FFKHWsND43N4qSmJ8lxs5CUuB22vd5q6cfKdmwuJ9zwmv7zNexhOjeykLPiNRpXLsAKecLtN6uyYOtAF5oZdpW/PNICxN49/huYWi6WiYzg2uf+FwhEnxGek6J/ytja/uEHYnjxK5Ef5JH4aa6lRGQ9EQfsi3jJ7VJoOjwI7NMgzanU0BsHncB3bhhemlaHeUPsNh2VfWIDXjFeYmESkskU9HMvrCfvkX/OaOlhhqvJscvU3fuMJQLIbDHdh6m5Suj85gx2PbtUwfghnA8WjTjMaP5gesliB68Yo0QLupem936IOKbbFZAdpNftGjrCUzookNXTTervioh9AqalNm60q10PFyBFuljKAeAn7sNhuQu/bgDPQmZGQfxMiXQGa9SL/EFZCWoLvI2YlH0i+Vd/L+R3zCBNtNwFp538MOWl8NgM46qUbHdrEn2ZJ6CH25q6KaW4MD+x4eY3Cuks47z7iZmRDFm2TqF8+Vd3THdMiYXUoIqMWDyiDqnVuquVZwtBibD8Iam0BD14q718YEQ5FxZsYv0xFONOPf2xdjmbx0yUcBeMJY9ffjeJLhRkQqDz02NpxyuvlYuwZn+lr3BsJP6nGwkaS/36zWR1DEIlsXzMK9QY+LnV0lD97azLC3Z+gqLalw9PPdELRUeEcd8V63WzwnmKfgsVu+HfD+YYhkqf1S+L8DUGZ7xhzo2smEBzjjP5zJUYghrru2DlMBiHRHXdKvrR833Kqwqd8tQ80r++cPnhEO328X7cVYGoH9DnvEB03CoWob5V6/Tu5cDeMCJXm/310ryY2Rk2p81b5DurUi2jrZjOwiZdEoPK7rU+CQn72pGlr0mRQtXMK+pfF8IL3vEIrVy0h1+pPwakHcaySfarBVa9ZCgBpR/CVHv6qhAc1+/JxWrvnjqfkhP4o6HMqNyF9/m4HRXNU2Kz/Tn6RFKcNnJF0IGc1iSgclv1DS6b/+WQwEtb8QZS0OEFLH9QIo7yW2/HZGDdRxOcCx8lwx6tJgJsn/jlh54p6uRoPx8vMrVObcB8iT9irQwWvcGJhNirSQ+oIft2Ic6SRV6/g4JhYNLrLGbTbWyv3IPktqETnGEIXboE2AghXgyxVSQszzhootkKcVDSnOJ+GuKXpOHWPrdrR5grgTNhFD+yJ8gRJjInEaQcfTFEjYcWQuHn9ZH+k/Ea4AlfY1i85MQSiq2yJPOr5/lLdU/Vd7v1qO0uya1rbihHOTfztm+zjXMBSTRUSmEk8A1ChAqpiGpN53fwiph/a9ZrcU4PBrBEuk03U7myp0BBFpbPNJEBbaMjI1Qr5v0cIgah7Sy88C9y042nhyAFtE/3PAdTsRW/loy8BUP0Z91G7TYmqsxoh6uusv4KOWNaANWyegWLZrtF/3o8SFum9DKyel9iKqS45mGer0OB58Dh6U6ROXC0DlFU7uOwxjhfzoBvaxXBthXFJnVxlWMScm1yFf9PRzl/Kk45A9wvbK2cClM7yaPGemNc0DaaGZKK3ATNutEWKS5UDQjy+oAoicN41wv5g9Hxw3o4zWBY9Zs9x0+7IMUUu8mjkpOj17IsEESSXgCX4ayfH+2B90LHZtvsKjRPSfBPF4rZ8uSSdvL9+n7h4N9O9Oi/KHtSoTfUEKyxVMhfhGkWcdTKLDZPlLZ8+E+WWlU6RI6v6syHN5l215JEwrMENEoTdqrf3U/PLQiSNlF4tIK/n8YZkEu2iWzvir2gFjKbO5XvHXOWfxlK0MEwdw8EnjQsfn1OOBAMGgKPPROXayujed+WhI/byL6pi0lITMjAT9L85+Wm07cVQBZxOxAKnVbvOzZajWU10G+p57lwS275BzVgV2YvS4ZCDIUZ1wJrL90JNAYyCzsb7ZOaABWcQm0Mx68XkpJPPoRkokKxbJE8WE+hbRme2yHt43MMJ/H5JtGZ1S532Ygm1Z7gjZQ+ScnbOaTNM08/dpluLrfvLAuuZVqouUj7RpsdTNPw88hLfJrpkq4ioEDx7mvB3iQnN6G7b6p1XV6uRwc2lQ5Uj9jVu60aP1aPae5/rhuVvsX1jJzEV76FFO9SO4JSQvgUyLKeZLJHqAkD6XOW5kEYRwOoH4wlKAFbNMCzRHjfL/LxBiDI3tA8Mf/zBk+sq+OZy0zuoe0E11lWmssAKDHY+nxNTCYQ5yK04v3OJ8W9QeapMkX/eGKRdVeaG91jrYxYjgG0idUy2VAoXc39k7ejkmXec6VWXDxnOd96rGfyad2QTigK//2sVfPm/3J30lrazU1SRmsAtaBJ1xTnGKlr7ddgb6X70sIaMatkeX7K+cB1XuL4R6tQkHYZB7pF77YV/h4O09QL5fUu3xlPZp/4eDfJgJacQKC2ZhZwlKPEY0ExqYCMOUwVjFkMqTPnvXRt0KIgzyBS2sn4HpKzZreU6vHlyZtG/tW/4N0KhQrTh2m65i1x7mFvoJY2TSEAUM5Z74Bhf+ywMd78zNTyBKcsI9lovWaERzs9bb6r5ekXblj/lVHvdR+CeWPInSwF3S8gFjEjpdm90vMJVWJ2RcX+v8T1GdqGnW/LNI8BQAeUcuOqzPJs86eQJd0REGcJQNHt9A9fmoq20iZDjZUhy3MFeDktUpmrFoRvWqpA7UUep1d7UwGj/yG5dp0SN00ugI1IteYldTFjm2ZLs5Zj5vYMwF7TkhkGhJukuUXPcRGd/xOAYA+0dSnfbKM5uJCclo0wxQFLX6ftCvy6hiVIhCgy8HIcRXkSQm+o5Vea1I3I4iQMsK1g6ixVvgZndQ3Dcfe5FB/5I/eb9BDqZ07lpLgtUOGxTr8Rep5SaZ3zm0mV3zyp56dyGtMnT/YJE02DoegoSzRZTHvSJ/GNCeW1VmWSqO0pYBOP1P2iCeAVupdfxzWOaH5ZACNrjE+AXzSJyut9BX6DdgS6XvGPn3Dz4R5OOt4Rdkx63X/kh4RWkLlAuswGgFTli0ZAm3lKhHtKbVecn8tBvGttH3FXkQ0GdFCbBa2A5Reo0ULnsNAnyW3MD5hLRYUJP8m6AKWz4NnzWF37U8eFXnosR0ARU8E4cWxDZvM6O01pEkvngjXT5rSogOMlBfw4jhUvecuV+jJiZyQCOrfgVCF8+YwBLDMMZ1rjG7YLG5rUIawskFjIVN3sNtsn5Z5fYWeuoy/ELHXFa+Z8vCrWECuyRbeZLOGaL0i20T9Kf+Rem50lHTOR9PFvq55aM2H2S5Gk+PB2nyT42wD5mJZMaYqc7QoTfC26uAKPgzFTwF61k7phyZcHOQfrRD4pCJzGaR+IaIaALs7lwZ3Y8NEtcBTph5yjHRBEpEj29qbXvyMryxIV6HR8Bhz5vgaqiQvP2o/Opy/SsgHbVZGyNe6S/3rZ96vNRYyXZOzRp19Plxzi8IznvppRFqEksVodJ4Zbkkpd6O/fPI/cfkzkq6ILjsfdi74fME/L1pi7J6LFff011hGDXoZow7spHuNCQczb9r/E8/dAFuWWaZV+UupT4HaST2fEh5OX6Ucd7TQxj0w40XiP+rCDmV2V2/1S97nzHb3cQYak/qIGaQBjtUbkYxhMddDKnXgbA0GyOyUqy4Q/Hz7YGYhLarUoa2/0SLHfu0NCQ1BbDDacU6pZW5Qn/JYS+2AP9MUxnw8QAupAAyga6qgY3Qj5BO9TWldXnMsAv/WvOhmYQ3pfEbwUpre3DKb9g2yKvxBLS+U48piZKb5i2muF6rEngpKt4s9A3gfvn0LQD5DuyGU11YMzFE+91XwsLQg5Wqwrd73zdIp5+/dnknp648NoeX4EbGkSeQumWkdoC4QupEiUDioVtCJMIAQwcOKtq3UVmlLSIy5sQaUCAE9/RHccm+8qtmno4NDIhpYa3FruzTlgJcr8/QD1RGRasH/lvLZfUiLsvOfxpRsehF4DXJMcRl7YEls2oOXb8OXDMz97ZqL6TOLCzCTMu0WmuQhFvJa7lgeHD6Q3HFx4noTy6GJMRXepOy5sdQjf8doWR3Rmmi9kmIvoAUmkHFl5Ai/tUhwNHWhtWxP0SP4b7S5tqU1piDIR2pCosNqowSVKuUbdFOVGM9icJotlX0j8bw5pxKGuokj3WeM2xhyG0Qx3p5vW7ZHiJQbgKYK5D5mxYFu6Dz/E6osoKFJN0AYLbjxInhUWuyyfNqb8SnNT4pqfPaPtrK8Q0c/Mhv+ghn50oAsOVkj7gCakLISCypRg/JGVxcfXaznVX+Vn1MbNEmbSSxOOoUA4W0kAtl5qCnGNXqmBPr1j1v9G8Ec66rlYNMcWH/mIhrK2pJxxr9a8/mHvdlcAyFRB8/4xGX8qk3jQMx8UtInzEy7cn/ln8yi2BTF7PVQZBDTpGKudxtoPy0puI6rO/cd5YgSzzqmfAyuhLmj7/hSVsIOcGYUV6kO50uo5eCH92fgPBe89UHyo0NCFtmjoOChSkjM55a2B7c0o3fTncWaSasVqVYEd5P+f+RGssWWzx9aCteaEBYbdgmOkMckqgd3tGGpKRgGlwQFGSD7PVdsjD2r1HqSsyfliE7MSZdMPlQrO9+7BewkS1QnYctQUvIOCG0o1DTTpBTCz9x+H8PPRL6hejXFRX2iRRSDTbWjewDqQmn4ffY6Cdi5+VBAvedPQPqsmdErmwNGEfK9bMahAWh2kim+8tdzviQq63FyQjxk82cT7Rc6yaf1WsHsdDQvzXEQ0qe7yBE7uNNScx+g8f58PHohT7+nb5mNaT5G4DKySnCBIigEfCgOYot/Rc5tTCqCQ+r9twbVgZz45MhrRspByN99NiVkc6JV3Q0qtCe+61c8PMxadq6yjp33I2mvCkmPPzF5OcgxFH4b/AwJgeI85p0XUqttBJcq4VdY3wxNrOcW5uz/QvVxA1sGXJ0FiJx3v9ACY9yYbBzlxrDqhoEFzmeDa1M4LxCjrqqf8lCw357mJaZyPQ+15BwSYv0eu3iowLsoumOsz8Ifvx7zFxbE7lV/6s7OOfqDWmjhYCXj5pXd7QPscSE4ZShnLsSRYy2bMp5XVfOB0cN8e4f1eDzqE76G7usfBGFvGP/4qrRj21+sp3rs6/WEJqbY4CAghfTc9yVMh+rk6/UKzMkoLg3Zpd1jcqhmn9f42OuN162VuoteW0TENQkictAKZj1NRaqbbIu5s+AcS6zZkY9Kj6nEBTARh15yDSi0NKx75M2rooMbA28bj22+wQKeoBHxeB7SkF/iTBqg/BYxD+oG+j7x0YiiDmxWdWLKa/PZn0nvU0Lw/O5iEV3IPstN5HdUWL4duv1A91+w4eP1i2oNnwJkH3sBpmEM3XDSI3VRE36920a9vCC4ppS+21yKx+EK3KB7qrEwP0fJVuhilTEOEpV7mkz+Fp9EW0Jyv61W1wFJdKEPluDO3lVmtjZf/YzRpo+jC0aNidBCQYkHjGyfVOMaXLahPzGO/Cbxx8I1f5p57KKVuh2RNpOHeQSWZcWhbbB4q0OTUhhkYvel30oTtSLfsmLSg9sBl4ZJHibFKIOaKjnMZt70Uf6eaAwTX9F+2+t5PvY2NWPDSarR2mgB+cZI5raQHEFuGaGHhnrUQpS1jjCN8yRy4opYyezv/hKrWapUvehMAzTK2Q2XwHDMoKEn/QMewurk1ulvjHKRCf9zhaLIpIdK3wiAXezym0lwQpw/KAA18BY+Kkw5V18TaN5eCKYBYmGMNcRfC1vVtWepb7PXevIKUyOy2RcrxBmp/oFUj7fy350rW4arOYH5OHScQjoyp5fne6uvNJxpKdQ8iLAz/nU+XzAIhm+/rATWJZqEweuGV7D1IOqt931DsECjIsTAVmQQZFH+CzYGRMwGvx7b6epeMY9JDwLXswI4JrgI3AZp4utNbxePLfl/PlTJV+RvaYOIXajIJQbzNy8HwdZIMe3jrK1ax+W1MC+8y208K4KVtQpJomPZDrjVod9XPPRndGvZwu5vWLchjT8fjOKwebP28GDrdasAcxNyyz4UbVNI+l0l2+3LdxVURKUX0+U4uyLkGWOE6XtTZzv4XqsQ6w5MsywzRkdeznEhXpEwOKKGcpGTlGcErzulcxOovBZyjbdATGhh/193jgngFeqokNC2hfQ7dP6Yj0+Bg0WwxnNHHvHv3/mV1Nfijgm7N5AY0/krSzvx499KlCENfEQGpZ93JoMvwwq2ByPfmok1v09R/0a7aMd8mfEawvj3yqEFzwpIKc8Ue9q6FQSuOvZgWXA4j8KBWUdajGQr/l3WvRSAUzl9fzUxAdiev6oPCHWGhPcuniim4yjFkfhZ7m9BakkCQXXnt71/eD7e+nodf5sl7oblyToFYRW9fZSVLMWowdWYNGti1Y/EWbMJHnFSqtBlpBamykIOw8nf1goRTx/XndUii4AFe0uCoK17LAn97PP6f8ih5wDu6WAj5cqusCf984Z+kg2s7dkA5n4qHY3s7pWBsjDkK4tOICqBylWRgX4s/c9Qb9jdVAU2rx0mmDhajdRPSsVWVNc6DM/RIWg2bMrnklAB8TMC04V6zu7QXrH13ZiqwuGWCVRI60lqET/+MICdgkG01EpgkzWCTY5gCca3idhh0HPXiPIvt7ulmdN6M0Hvx/eJovGUsqW+ux1iXWzqRT3ncjOWVHIoMus0hAbcB8rNZMgmziCYGJCGwds+94X+nPZcNDVMud/VbxvN7LbHqr+3RMJNZzFsZqMgBXBM9yyIJyF14Lmt0D1wpBJAUkljnJvCbEySPSSxoe7cIEZaJSRk/o9K+aGAKic4Xg2ezicO/kqYdGt5CABLs+Cer5EyT6AXiU/3X6jsoxdLb1uzhW7VDOkMh52Vqzo4+3VRfCKzLezL78Jljgm/y9WuF873xnVXqK/xqX4o8nHdPk2tnWcSksc1MceQ9g+ytbk4pilhFRyZ5e/6fKou5vCRQM5E0evDYafaDdPjglP9wPlT7rrD+V92eVHJak3pDhAFDCdOHkYrslW3ASpabkpUgu9kuu6M5eWxm3pp2w/b9KGxQGDkdxSsCX3MOEZ4ZUECHpdONYDKoQx94tAF0nVCkTDWX9muaQHy0dIratkjFgTcQ4nDqkQTIgZZFNxkLk+H32aJfducYTpnzbEbXhLZEm+esYzAiEXJ1uORD4TK9BaqtHrH3qBoW/eDhrQZvIvg+7smyH5H0FFEgBN0CncLwfL3Et3qMjlR+aR9CtydMS0ISWRMgrI64b8e/+uN3ciKkaiWu5s1rRflEDcjFi4QLqrJhHzICnFUTP3+eRU6wF5LhrrK59Ng03kutKOzYTltMLaQH79Xo6U9gEP7FnoaITNxezVPaaHtR8NZZb/nWoWTTDskwKg8E0RYWraJIJEV42TQ4BiMdI/16n5Q8711I3ems2vhrBff5bCW0v2kP6u1+3mvkWxav01P2vuuOENNWdaNWA9DxaJoTqalvjIWq9hXDJurP9l+nDcqSWOBzX2q9KQQjB25ds8B2kr1zyiPg/5ZCbSYjyyD0kSi35cMoyTzPDDTVtGVXEQAQ4Ck4vzA7kdjVDcV00tW9NvPWGfJV3CX//kVJZ8WV9po5lzlevjdFeWO3dy3OBbcBZuD7HUhQLpaV4OKKO+jP4VzBpD9/1SHdz3WJbwnKsxSvaWqWKIExWeKadsapZ2/uojYJ0zroAUng/n+i01oGTYuMHWRCtkMT9/eU2ZwXq2S8u+CA3c6EiWR7KJXfBgnPXdhNSnMmkfYqTvFCTSUDB7XPlHu7U/dUJWQdwqAupZAhh59pO98ANPY/nHdHf9F6xT8xM90G9ibQsH1UMUctbta6ZJJ8sWaik7fcjWDRBijp5piWN9+p36+SMJ/J3kRoUWvDPilwrS/DM2GN5V9iiv/cpfZPLOnUDUtqbJ9TftYqqP8QAiWndqiBZ75LVptsY2T9LHazn2Bksy1RNggQ733stxsvOv0Vb7uQGiTeLCojpqC2zXa1XiEhxI7erotWQaxJvD7ym7de6vdT0n+9JIT6sfB5opHiQnKMhjURWvMT9xh70wKpx9bFFg7jE/wUnosO0Y1DBWCFjGWxNLEN5cDqfX4h1wjPvcLKECF4OSKCtri6Xne3u95OiZ9MuXa8MejTi31VktWdMkFyqvaSfnYscMnSykZl8YQiA42Tao+waayta54P7tPQNdEA1DNkeeLdByCHZv4tp0r6CnKafr0IMTdkQ0/0KaDH1C+O23vF79roVTSKc5M6nRjuhCvayyVG7HjYsokrlCBZYSGRUw6ZrKTkdrk6Qhkw3eiaa+FZvQBl/TbcOk2eGpNc4z9z8EXQk4HDzXtQVpp1hP7q+tbhu5aEgoivq0GLDkE+V8mikvdA3AOn1KisyglgaHQWZv7iMYuqCvYjRC4jKAmpTYy+ELJ+Wx0sKBQTci3PBT5HTlzA4dy3KZDWuLdd4dJaSSucU7eiJ0wMvfmLFpaP2hd88r9U69Ba7WpOaEkcHNGdwLGabATBHye2gvH5JsYhvqf2wnp9Ha96sPdzTXFAt8hoGEQ+a7zeWqJANA+rv7ZmYpohkhBANKB4/mKukt33g9MuWAc3HtSQ/d33SLszR7LnIRP4ICbGhXJPY5pIMzd6mOCaqKlhOZFCiaQLfJeTRtTxjPJoLf1XQbFh07pD6/1nxN+OPWUwPkWMZ+o2wciGspN6V1N3QJYzFNoVaa6WXxCXCs5AU03lsitY3XTuxG2M8RNSOHSjG1FiBKJgOu8p+JRUoXtOPvPgIrOYbGXLIxlbwkdbpFHwBkFhRzmftEs97uePGFOEuJJ0s4/pZ+7apn7cs7hAcmQAVrqAemsgmPk30sUFrzaDRTnnzYMRqvrGVWu/7AESsfedt757vhMiSuD3Lerr7V6oMza4K7LMaTErHokSCDP2JQL2XTbInnkgJLHcOmyJRmJuYlmDv4xCiu/E8N0q+vcgKQ2agg3mzdt6sel3w8PuU4aSmVQ7LswUkAEDCLSrEPgR+tF+64YgvShgcK6WEw+rI5wiHvs33U9K4x2fUF/VZSH0Ss1Lsa86hcWq9CLk+p/tZmMsz/GizZ4ASKiXfW9xROZPcW4mWY1dU097xgGvPYqAYDGCXlyWAsg8s/3aMFwVA2HrCDrjbkT9JjhTTn4wWmEek7WPe7oJa3ojFg20eeDH0DFJzpepHxx+yYX9VxuyScJ10tDNMZfs+Ji59qot4EFwASATA+ai3xuKKaUNFJXiuGh4IELZqWGzcbqtzgG2HSOT7S/Haw3eIP6iDT1JUh6IYPlKd+nsfW6guCtB6T4NpNp2xnSKwZ9FZ5CpTZyntTpt9ffQXKz3ySOrOhRg/4lBNxI98v2/Upz6w0e0vJIxYFNKcIvLpYVKGPePZ6d/DeEWNXt/ysTqNX0sGAzeh9TbPNuJaHxD+z349yy8l5Hd+AjPon6sirVXqh0o5iSZC7j1NtWfOpw2TKzs5zqgt13+L5uj6NhmU4JQfvfrtczLibB4/eHEA68F28qVC5Q4xUqxS5CjSKttV91jjkg8RMqgow62lAQmIJuhb0vvehUWaYEDiAx98CAGyDSjJNn3KDwNVy9TbeigGCD3wLMH97KS4chLkJW78YT1w/Ef1b0/M/kVcwE+cp8CH2/MXQpsE4JmKtmtWtIqbVniLozjOM82XDAytK/QE0ZwF/9Kvn/xwaabt5nxklx2GJ83Bih8gteSicSNCpb4UFA1CWNmlK93mVubvns5iFSH5MjsdYxBtWTzgMagCGp1VGXy/yaIIMQ0HlZbSCp9NWYYRDZZZOIO78Y3wYOsn0PC/6dJOpjJcUdSnX+cM+Z2Sbcqudl50FlZ1VOoPhJzEJAhPHlKs6lw2gs/ZYm+lUYukdA/rD45lQkwpWhbPX8nO47xrKtFZMOJcPHFC4R/rfNiBZOMoY/RnaDJrUJ4Ue+BKuX1k4XppDtyHiVPVzQUxxFeOaHUTxc6U/Gic8APRjOzXEuOaDDhJlGa2/k1LwViqjsiDpB5swjH1/T0l2+SPJ9pfV4patGzSP6J5vCdpQoz0Of6oucQUWfibjny4VzaPrp/1fF1rEhnj+V6bsfeUjiHA2KZqXEnb8HWb6z2qAeFEdlqigy0eaX+RSV+eecpGqz2wqeBJPO5opgk7ApvBTov1/PSYJObYrKZ+dSP/j54odfa+ufVNOloAfv/JJ4F/y2st/YM1E1+7lCLRbY/ZVnpDLGS/GUhbcjPFqit9stJCd66MTd9tcZVXqRxBxAgyuUYJW02+JI202Eq69nIV/III39cQWAdL0ZGqhyMQcy3FeFX+EFIdWRQPD3Pi5JfruykXDltEfuoOZSjz1TKaY22/znHBgg2H9Lujpy6h3lu5K2wyAgk12/4AiIgw8mPKNhopsNdoXlJf11Qa5FnTmI1lUvEtT9jj7RL6IJDGH1N1jN37yeK0S7qKKq1J99nGXTR+w3oOSlFrtFYNVGEbL7PVDm+JhVftkBdnrnjep3prE/TG+VYjsO5Sn4aDBHFgTs1OdQ4hvx9ZD2ElnU+nFkL4Ex8PIAFdeyfnzO4GTI8kFWZaNreobOEJuxbSqWVvL/BZRlIJgUqy2ljyP9qlkdkZMGMNj3jtb+Z2kvVWHSMJK8yzj1hMa1rWpFBE2UgVg43Zga1WeR+93tmY2Sk+qrsDz4U1MKo6fC1I23/g93ikw5DK3L47VHFXEnyNr5tj7tu2WjvYEKQAqXDUQ/f+/anOLlz/9sG2f1h6Ccp07TWo89n3+PYuFccP5gJY5DOlv6VkzigyK7dvHNKXb4HRNHMzX2G1wVH9Ft4Dgayu8l3H6A+dj6SGGAFiJ4Oh2sqn6MnZsjAbwhHTXitWCPA55p9PTO2+rSXlSHERoGToMLQeXYUm1niA2akc2fCRcNAvY6A1KQbNnRRCktM/AwzMzxV7pLH3twihWW3IB1ePmidzlNpcLgGvzSAOt/HWFXNsyufnVPdfizpKjMX3sMEZZwK9OnS2HKok2rpYOO+6s1B6h/18YWQh4/ZfsCTmfIPCocmyjfrW3DFDw0s3I4lhfllyHtEGsgusoX5e7xorxTWnrsRTCSqTrFmMNyJjsa9HkDiREuSRdDio/XL96NIgD3dnCeUrpMMwET4wv/dsgOGszwYkAnhgunOErQ29Y5HT39DNmJotT4oWrLdsqfBYlpSlAQT2DBQmt5WPWrw9KWnBKRNyTks9vopDfPMM6twpYZGAgJTgxK0bP+Zu0y9VKiYWT1X8NlNnVtn+A+6kP/emWPWZ7JzYYGWn/aYvV6rDx9p+dFC+Q1GKbXjPwom6PAws1cA4wF/VifvubT6MadJf4oR/mpyfOd5+qp9tct3YBWipULefDDSRCpU2kV1Clprx6PNWc3cXV0JpVEhM1+mGCAFiZV5P3n1bBAKQIX55uXYMAU3/vI0fpaVjZaN8oqL2+vagmv9NjdojZDxPbo1reUgzralYq1Pd8hrhaOzHZY0vTzvBMW16vuIp50N21GWTOAIM0HA84rGjvDzYy1pktVdANtRhHlXRWVWdjKHg8nbPUV5/UlzSsmhREVH1jV2mBVcIL0OPsSVXO8LfnqC+Ixjmy/gv0H1TpModQy8ffACJMaisbisltSxjqYnftYTsE2ptcV508ng4QadDXAxtT98UnRFx9s14Z72FWNBgZHVrYOFOSSslEQpZSyxY8eCDQ2vjMH1uPIByjAiFVdCpxb8ZS+Xoa7qZD91d1DTkqO81JqsjmizDyfN8wD3J2FfeCgo9TltAh6jop2SKZyQnwiG9CNROvhncudWj17XFUAtAokG/cdEVxBQHSKdipQIwYV2iGmbmpF3TrUIM5RHqPlZb/2tKYDlglPgf9AxmrD9PHZWsvMuh77bUxVjQX9mVLQoXKd4DWmMP3T3iQusL++f7oHw76XbMgkn5z4fXWX/UOj2+/mlIpAyyXzdU7OdgodyNxGJCRM+zmFkTLD5D9csppe2WmAOvGaoPWU6z69KorerhDjSjCrF5SB74HM2CFwDkrXR/2r7Ngre0hcN67gV6/LcDblVdV/7iTbQUoy4Q18lXCj8Uad081NJDVD/gYiFJ3U17S4pwtdJdSgivga5+PB8h6gKZi+Q4cxg6RwYxyJn1n6EoD38E6tqmqfsrfMJKP0ObzUlTIM0pPtT8HeU7nYi8mhWGAcOW3k67vqIawFJfvu+rkJTuAVC52K4rH51fAJqUqu0Em90t8wUYDggAiLy9VA/V/gxh9Xvkx0FwdWpKy0fGeMq9OvmxHh5+B/NpWOTfz1afSXJDYv4WVuJbQId0Vc+bKjY8/M9Bm2Z2UgR5AP63k2zhCKxEdzbSMferw4JGK9UPPd212XrQ42HuIzQLLNDpYrVX25MuyF+RzV+gKl1GFd71mHZc7exHMIy1GFFMX8dRo5IegJalpm+LeWuqtmEjhAKJzCgg7U98UFrV3yvYiCwA76vWGFL67akOnFo0+HjQURTyvmbvoei5ePDhK3hq2CUO6N3yZnto+H0x2ABKMTDqZ50hzcEzWbXXX+6bkv8+hu+aAcIZvck/G4dCq529QF6VBN1jRCwbRJO97J9x5gXruPXsIkP/Y1TbpKF6GwihcN8ZT/YiuNtlTcah0kFYYvwaO07p5OhYjfbKR8BvLnfTxscKt6mG2zPKT45oxFOuE1qFD+ulfKws9KVTDft+XyKBeFxQTFVgg7cuO8zXaeaC1+VNHH2jl8FRKfoYeIqi5FayRy2HI7d9sjBxMuUPkzCiht8zcgF68kdx4+pGkvDadYMbKWd6sW9vhpDaszbKlie1ddwS3jvEQHxV9yS4G5rjzf46L1ZLh1iqvhFA5XeQnIe1ZNixpaG5+xSMo9Z/O4ojK8EG3x3aOLcxq1gd058iB7U8YYGXs09IDzetuRiY2UIMSuUltns1fT9PRu/6daE4mvI4P+hTg0rbGfYJHNzxiE+UV+AkIalaId774d+pMtDB1Z/x+r1E3gHZvWa1bPSEMXObER6HlpVXTM5T7daEzo30VJsKnKPbdnA5Sg8Q7Tyy6uB54M0ccf41hnHVurLT8eRqKzRGCSOnmptzyd3D5WDXQAV2YZqq2Uex/T4dCcZm3+nUrtqbL3YI7q8rdl3mAX1nSkVJog+2gEXu1DULR/VgbMHrc2W2ObPXEWPP+cpGbwlm9qY3woPX0rAsyuZzvPYe3sLPGryU8+g48j6bhOqT9P5Z6K0dR97Jv3/JEdb0ZCY/2AR89NunhbLsig8sshrWTBWPGje9G6SBclca8SmXfk8iAljMVPncHwo470NFjZ0vsKHYAtt0JRqjPy3p9KYuEjwCOQpXTuWVPycmxu0rBlHQ03rQYZgAUBlQ8s8tEi9eaATrayRjdA+3PS2igAmAgqICCkvj80OwVDZN4Kh7jjKORV5MEDT9vKneEhCiK1W9wPr3Fx+Fz/2/vf05PdVmTeZ5vG7NNhn+Sdi+iBjWcB236wuI+lA9wLOzeYCBjM0sqG63TLX2ZvZW/CFY993HuOnhgbbZTHsQJklgles0F6EIlsq7d89n7c4OiblXUnIfVyFNTKqjN5aRUMBl20ACbfP3N1a3U0UtCPPGXDuMHI+gyQfXp4qr5CzPpp3JKLlNLB7rKXZi1tkdCCyKpASbA5ywu2jScClLwy/l75080B+hjzfNj1M0Pb3aA6p+scyNMxBByUm+tbXcecOQppqlw2ybNr3N/RxG3EPLw9dzYmM67qcHIBq4XFP8/KW4WFXkafimbciJOcalr+/mpj4GsyDyKn3x0wgsJQaAJDDVFw4fjwV076r4BQybCaLr+xFPVAcHMNfviWCCjdp/35L90geVIi9zoSUEqf8xdrmgx5Bt4o4Hycb9lyXMsbLDAAPctjcdywQzHHS8owSHzN8y7KJ3UFlTcn1qA+MNXqNfDCm88O/+Qc+ytkdb8J+f6ubKhpA61l0DAkQz9v0U9yimFxczq9v9SJaVRs6eT4ud19KdbCzjwaxJtDkXXLZC1gLZpnK5YD5qgTfusgxIBhMhcGAhPhJ0kOB2dOpAVxzxlxiwYQ2mRNMEOlnvNtsTkfeTRMF1Qr9aBCsyzDhMMvh4ds9x+I8dtm1Z/1kQgF1HWO7nCx2qQZAvjIdHmr8w9+2X2PEZVrzBc0t0uvWgEKkHCE5O85bbJQceu56/9mMYE/ApnD56NiKbq8QswSXd5YRJ3wQQpI2dT2TpPr/WeVPMtI6QjgrnUIc87q8cdQqfbVPmyvQtcZtljjtXVz2iZR3HOAm/rtEUxLW63TN03hSgrHYNJSbLejVBuiQYnb0zV7Pkw5JBICC/jjzwpkNbmCbTBD4b/rYds/ThSQ1aNtUaLe9/Ov5Zejrj0TBiuCjzx8Hug0FAZbR1eC/FP7il1ZvWrn26ZERYCrG6Z3kbx33EaKUmUSfQb2WUGUXqH20vBpXMmBwOeW+cZ9vt6PaofzFIG6k0XYhKoC+hRKWXaMaxzknHkQUIp6fPtuy4rHcgEd/WgV6U9KY++vokNrgxRCUJvTNXtT7mtJvWs0nh8mGxr6BCzAGVKToc9r5WFQLoY+4KKfpYsrhaQ9qtmjXQw2BQlZJujfliENbBplMWZWRb/qbG+EDdVccYNzYOA2WDHECwLL6hT9vJUeQvhuzWHD7VHrSU+ISed0/W+RinkT6N/WrIaKhsm1JJSHgx47/O6rqEvDU3n8LTkem/xYohUwxoXr89jzUTwGtJt0xpMZKN+6o/lfk+qmijZk7nYuW3weTVIOp7btcsMMF/UO5SjonJRXN8uFqL0bmEMfaWueEHa/G/Id47iM9PWyDc/5a5QjyVTmm4Bldnlgy7C7MWZHFAyBnJMD1e5dEs+s2Ipwly79pMrZBMR5CEw8BC4BQ0DnnomFeSFjNaqRGxPH/1SA2v3wAhazY/j5VZHmR7YB0w/W5iLR/ufD4stUvufb0s8vvN93kdH4LSn6BZ+Ic97S2myTjUO2X7dI9mhugpNQkccBhjga9LejVDTshh7ceRcx316LPXyeaTXY/4146fsZMwy6Nc3UGQceQdXid0heV5zG8rRpq+/iM9qX4zAMmGPy/hjF9vko9jgQ5AOxxzmS/X8zUzwe2lZuGpKiPfRyNEVjnYAXpC+4lP0fOA7K0L1LRoTgQKKxlhRiqA/HAmfLc+gdH8yduftuC5Pc4/Wr3E73Di2MPoMoNUsdlrchKnaLZnW/8rAwau5KJnLIwV51FBhQOnlAGdLeKM7LXsPV25PEuGdcktqCfdNlTmvEqT//HpM8aP3172ASLXLkVN1PvQbewf9kAQT36dW06ijlkZMKNghh2gkw9VIjoBqyYrAGiSfWlY2yv3qlRoqjKX5WMDwrNLGPC1Fc1VeCrBm8OJvJBt2fpR813EpjLp3TxwcozrVgJmYATDZe7tF9QQT3acWCrtpW3ROFrSH3zUxphCYpBGcWan/ciNfq84KuCsqk8pi0lOQDH+UxvyQiiYuO5JLKD8vpabbtziiGL0kZpHgv0qxHHoCxU5TXNxuYP2F++ujfPtqchD3aaMUPruhDxVG7ohjyAppWnNoLnwiZNQjsz6Dfe7G+FRnTqGDIC+C3pYJeTa0g/fIH0IYYXdlVwXc1uggOYamTZ0hpKH2BUBnOqmWcUbQ242jLMV6wB7hEzCk6dTKBQHp1u08MWPNE7R7idaBad3rHWB2HoS7Ft/U7MLkvH0u68C5ddc0zI+OtsLKuBiTyqqDXIUBbm52djpNaxWqY3aRcGh6zc8IjiG6bG35O6bXalYO5LFWAOZf0Or+tuH59tVXH8Tcktrg47s+lyEpwpbx/LWXH1TI5x7Jv/aQZgxHByNE7HstEQfnm5h+28YDhGxjN9qf1yxHxN+qh6anuJyc0DS7wyYdx9fgnOyNqmyCHRcxXwSIzd2lIwiZpzVTghp4+SAuiCzRAeQ+/mg/hLbduboTIQj4L6C1hf3MQ1gx4l1zcs9RJpOvZMkkJMxewCssysFV3McukuIbWGW7RxfLZ3Ce9/JplujURtb7ESRL8DERazXRJXv8B30N3nWAiL4LLkbrrDBc85VRjmbobYnYgEfG9/PPJx5SQR0Btq07i6AZnk0V/kVgBm+9Qk3iP+IvfHfTip0ywNZzjNcLJcb69pKCI59n3WMOVsPupTkx4uw04OMI/GMnVlxhDrKYEoOxgjo1v1YS522pSo+TBxdHxI8ebUm23aai06rtbb2mtugUIFdZzNbugJgcEAmaCn1qKmdnBgQ86QAbrHkljcainyhW6penXS4x+5gaNR0SmTKGIbHO7ILDQNnWMko8nCsQr3HDfLoX1iQjklo64smxzJOt2KV9Oaw2kbIluUz/IWcnJkEmtASUw/dOs96z20HcxKcOvJRoBoPTs9r7AG2TuQ9nHsmuSV5RTkRD+FaicFzapTWvEzvXB0IVnH5J0nIUwI8ETB0Zv/qNMqThMoRRIWP+i2txa5+MqaP7lGTqWlR9UfXNLEDZZmvPPwC0k89ACL4WiPOdMhfcKXakQBC8VVSIiG21qLWM33kam/LcXTvIIXRaBACwvssN55M6cM1PUitiUZFmwXBm+yfWw9torfPiISWu+Shcy7CRi6z7KFr+MhuRRex31YoVgMHdW8PH6mnLlVMvXx3aJm4fP+QnTVInBHSPXIVNH9x9+6x+iV/zAzKTaGmviCJpitcNAu2wcW2nPdvxW96U3p9pOkn1VHaDQoMAlfJCrxjzHfbdqh8FPYOCrSJ3/t2yFu0X53ewf90QRVSTCE9nUf6XKmSlOj7TQpyI2Ua+qJOMOjLWKFA5S2E+pKGpIYRTB/MKtxGGgMeVZ+93252enUvm/Z/o1dFEiNP1nRyj7Fe/4uVCnQph2bvqb61lnZbChq0+IfavUwSR9QuCmPbW6MAe5gvt19xoWi9Oz76r9iy+E6t5KK2ODfOF83OPEAHzocT4e63UPFbANFcADaI2oQdkAcp8la0HllWLcLIr811hglyNEXUfxNKs4cR5EUiElkPgDNndgurkQshXYiOtgwKfgcSL+z/bfpNYLfToEi1Apvq1C6ZZ+NxerldWfZJsnunYkF3IH1Jcrz/l1Zuls9xy7+qECQa7fl3ZXZg5qaiOTg+QrHgNmU8RFsU8kpWsATXpJJ460h/rUJglV/xyGvX5EXmU8Sr8JgOfGNhgbCFmvbp/CYB1l1T0hsODifNfpnuoU1QIq5jY934R9sgtOM4RkOp3rBBGHqBhhjNzD//7s9uIlKYB1H36XD1c3XAA+GRxBYIvnJilsYhhWuzlAQZMqFbRfvNnmZsq2jfDjI3umRnBz80fbb8+pEC8MYHvTMKUmH3a8MAMM7xpeFeEg4REnd9ZC8f4k5reBhQMf2HePkHcLFSTX+wjXRmRZ/uSgpzJRjkXTIwmfYJg/GX3PaRRNo58L9oheyZ4guGP+ptDDa0g5nlBMFh/f5mk9M1MZ8ja8/mRTPwFwG5W1FrqV6lDfOCWB80ILidK8in9V4OL/nbro9Y84B5Lgd0g9j3KEKGmFBYj/W/+RF/uTNeZcy9b5EXjlRTWnC5Z7qMKRKOXUfphNzNlWLIuEDSjvNPbiMm0gO9SbQzVzkEtSP3JuSA/mAmMOpQDcOq+W98mJ4Q7UXG7E3FV5E58nm/wa7UQ6Tqo4tPdKBr762UnwgR4SDk2rPEuL7jeHHebEX2hxgdjHxIT2xMT0nFbJwdT5hwfb3Ik4JzDhgYRPdcE1jcsCHL2DCzGx6x5PukDBXbZonAsSGTQbtdwTJ/xgBElbhLG8XY2xYL+AWUH3vq+rdd7Qo8L9xHk0nkWT6uMbBNoyDjr7M3pMmVSL9HPKWMublqkgA7RZoizk9On3AxnlDF1uQSjVN5IPPzRjg49dCTzADmlDeuRTVa4elm9ge49HXa61F9ucEQgfTiDH/03wQ69hFbki4ya0GyegNph8oIs5tzhb39pQGn2GV1U9KlYG9OH7qCaHosyzWyW9tjM0AAQRbNHQfsFZKXxcNL5KVBEQ7qk5kOA7tlEwpgig4+YZlCVEp2U8dPcrX1moI8y49iEgbtssiremj4piBD5H2t6yNUngF9e0O5C14YuIbdC+S888mzmxF/rFl1WNNKuFdF1hghd0wOvcUsrG9u4RGvGhrdTaFwxfxymDU1rUG8DXUK2d1D1UiCj1JH/2lKFO2XC4pZ0xwXAnsvt9MD/2B9HCAlo3+oA2D+MmQ9+n0OPbb6fgvFw4X6OPJZJOyCCjIsLVt/+nB2by9B8nHPFTRgl3KUlDnx+i0QJQFLibXFZmJP1WYVwl2XO4VVpfnwSdcZ/Vr8FA6Ar0WTAD5huJDimlyolNWVyF19QeLCJujEMvduERg7g+5TEOB09qF9NWUXBqXFbuHHntGWyGEsKt3pByIX+l54qJPVyXvIERAH98wULmYUjhzgChaaEUGGoz6v1xisW7F6ThuKtL60+kbk1OP6Jr1gvoJYakmmPBJFAS9uUDZY4V7nWc9yZaCbPeWTX9DKCeNKdHjpiPsNypcOPm2qA/ttNNBM1mxHwp1nRtlAY7LCeQXFC/VuD80YhsNiC2FcmCFPHDRN7wrZ12qQVfMaEWu/pEtDHVY/QAa5nLPIg5CoVu7ZpLLLPME3FYEpOoA6/BLe2J3S51FHAvdbUn3V2Yys0QDsvfERPDqQ1hgBBYkff6YLMSKq2k+WMEfDzI9iwioLqEevxYDThX4XDTiPkGy/vb+xmWAFUaQqIVhIBDvSQZABR2vecuW9obMj5N1YwX7NCuI9oKZ46bGfUgpUh9nv7DF2bSmfUb4arAMTjr0znzPYaym3xZqIbhcDrYFuzOeOJ7lvEOcpy3n9dcPtOEnyOStNGqLFcArKrUcX6t92oNXZbltE3DUgxdNk4ENp9WcCTFGu6g1eQZ2LZZHVufCxsdpy/Ws9CB8Z/1BiNIGA2OPxjEI2GM8x/BQtCTg9gbI5pChA4oicpjRAswiv3c/IF2roDYHCe/MaVkgGqF5pXsD5gGXN3+YzwaU+EqbfUkhHbj9IVvQz/xcHsFljz/JXpnXmLH45H2rNvu4zm93BC0X8ZDtBedW+LFs4E6ZwZ2dwjBxmnzVwVIIZdyv6iZIMP5xnYemfTAHVnmFH/YyqNTkzUhTcPXixHV6TDsm/w8YuiVHQ00dcvzv3jMiFNMApn/yI1ER/TqRf+Ck8bGFGDZ9r7fbI7ig81tt8yRlFZuKcCXdilcuR6EIU9JjIqmc42SHE5JOR23BDui4Lx+bebzSW+Oi24Ayop5THfEHepqJtaE653Zx0Z4imucLAERR8Tq4LwLYDykO9YsdnVQi4Gf7yguyARHhv0whQwgmsTNU8ptj/0FPOOpG3QZhGEB901p8YPTIDN2eHOdFu2u3Kl5JZQ2mSD/XAYOCPwBFPIeqLdQmg2J3Y6mkFOBDtPlsnEF6tPzWa41i4+Iu0jChHld62L5L0nt4qW6csUycj4SePviUoJXCA1ilWWojbWzT0ewxGwseUUROejvIbSZjEc0bR5Q3eIjUsosBJbg7GnR/eYkbqLtjufXEiAPk+x11CJskgzQ11+M64Y6U/IiWxrdZJeU8P2lO998Xu/Y8klxYWUKef4kmoE3oH//1oxh5Gf1rMo/kuIJbu54ysMc+ilfdflT9iTdKq+se6ZxN4MrM9oAmhdJCN9c1s/k5PaM2Pms5AdxFwDfGi5gRsEcSt/YxS/YB+fOE+7YZ3q0zcF2kN2BdHQCONNQuV8fc/CIF6p1bhZa4ZD8IxQNuOS9CGB1dzo5VNqUnq3dcPa7HhTteqBwzTkDiZt9re1Jp05eRI0h0YD8wxfBx1M0Hro/YMBVu7ZcsgwSz0EiM0QMcw7ru2h23cn8qGyLKXLRTkGZlzMUGYTtTk1zAhHAiYX81lCCxuQtGgKqfZ9zYvV4QNl8d8bnkaLwdD/4CZkNOWpQSsJvzGSKKBPCmzW+52EQ7ct2UbGBYTwhxT2kEr0y9+xdF88eTmSlcJudJ2ahvKdXn1HhiM2EpgMbDkv9BhEt+u808jztZte0svly6Wkb6k4GD2IScZGhrw/bSqyKW2kAAi/laMpxx1zJHpO9R4LUhvdQT3iOGKGDIWK8Ci28EkFn27bgC+CbLt97fZEICDhBN1Prdaf9pFdcyVtI6YuwjjPBftWzFr1orATICOkyW7Ivr9cPzUYrjZ6xLhmgK1InljOpTvn4SllcDxc5jU2nXZyeBPmTiTyGXUF2gHVYvOiFqmF7Jmd46+6ztf7+AKqCGjdwXD2JOfh2FOqWVAdvwz9FdcmNdzrLkUEJ1pcR+5370zUqRC1Rx86DNKgP+ytrPzvBbQk22QI73QMmM2g9CV792LKi6KZ0fSx3OGVp8IDkdsvdwGoAuJftzmntxYYd3Ola7RYZOZmFOJVVAQ3b2RxmpJU/o2LQH7EOLWmObXGDw8p1Itey98VRxmIujQYihBHmoiEj3eG173KAI77/a2JK7nHq4k1g5lPSDLoFeKkMkIh3NpyMAfXsKLboTeIVLl0B4Ga6sAh4qEK/ZII+hDnjqGMZichcMlL4MwuI7hT2LN/NC/kogZriFDG2dmxcQ3sGjGB2VkQ5+/4MzAbt5zSdN9YgB/ZyxEfV7xPgkRA3fes/Uzyh1ZBMpA/q2FlpALqCjiaNmxHPHWAHY9vWiKzGTID0wkp4dJB+nG8j52Ce0BHphPafMVBdfFdd35RJh0EloHENBYzoc2ZmBqaROmDINERgS0FD52SK7IXIcwr1ev39o56ZsVdA7zT1EfJPRLi9d7BE/p0awzhh7gHUu0Q4/ekrKpvQDXd7VFZ5GKmqBz1TebqCE8qHrw+EWbbsgPlk4JSrfiBDHk3r6IFPnAx9S54CmeQ7tt6s67RMFJxJdLEa07BeiXmGzb1DciDD/ZpJFoieEczzEUbLi9vuaGR0NcqgjPC8nkuUGydFK7hi/g7eXqjCuIPwru7XMXrwbeOhVoSNZO84xI1JNbDwWagRu7/h97h/GqkPOC46PWvEWwaqJ2CzsLLzQf8ahDeXVgjkbzTxuoece1nckGcpeYh6WMK4Lacgq+VvLuWiQwOogsHYebvK78rIZ/xKkXXHRXO9ls1zMiQ379DEax6RuA+eOUm4L+FTi4mUpbXv8v4ptLoCwEvieEMca9zA6LsurZ5y/s/XydfMaQ+AGYx8lX1eHdyjH22e4HqoTyMFuR8xi1Ecwmuw8hraTrpJ+a+jMD3V+XcJE4A717pXQpO3IiBsXcwkEr9X1MRODOJC9KUqkdvgdij12BUgI7B4zoQOr5ESAzJQ/xR58S8g9tXgYuA4BO+RVsZV+qiYJbnQ6ck7K0ra8zrkeUcJUROFEBLYnBsNJmOpPEr2FCW6djSAQZ0IcodlmoARPzQ9KktyqTwiQrYjDdN2cvFG1Ev8IOlxzmpuyhE2jXy/6/RV7kLrMN7TtJ+k/z0to7j1R2E0AE2nIXXr/vRhJEZS0yu+IqVqr4JuSUICDi6swHxAgMZrHD+tYdVq3tSVtG8X8ju0NLk4Mi+sAZJHjObey6ukeSIsXFwrWsLbPIv3MjMxGEIpS5ESZ9L0gXVOoFwzxI8Spx+jNT8+mntbyWNmidjU/cjQXNz0LOa4BdBQLL7RsP0NPuSZLkZUIUho7XKx67u4Yqgtx7NRYy8hzeO4atAiGucR3ns9w7jxOntOLQJ2GBjzdG2mEtJB7phYduTXoLh7rbgpsWSSeJ5i7qlvbBmCegNP03jFWX9Y/Rsvn8Cea9xeagjCNvJfWBEi3mTtkIVKaLrGOqozRO3w/aIHC34Y53pFNoKLI2Mhxlco8KvIutzZdlOPZs70NqVWxr9jyXW507CrcPuQ69QaZDx8KzoppX4pCE6FAmE0v5COzb4abyQTnUmt3k2BOR0OiFE/AbQewRCK5wvOyPNS5u9ju3RUQs5LE8/jdhiKr5W6wUnzLAPtlj+wQE4nB9Q/9cdxSRSs0oelVte5WZFx6kfFWV0MYCBoVNUugOut5c6+W7LyoPSFRwUgfmwKVU06xaQGz2fvLDDv5UqI0rXaJfTJ100UVkzKzSOQdiqCw7B0vEQAwzBDFOguJc/j0C9Cy4lpxB1agBifHo6FoTvTVcZCAVWvlMrRSPJ1OKeRv8z7tAQDF4ZZ0bkrXKqHxJ91ymjUsy+BvmF07SEc0xP7Pnnw/uZIg1pfObAAtFEJBtxrFMUVX/9nAozgKiDPBFdjL/KqPOQuIV7ZHHbfFa8uvl+lPrSmRC6amdMe1h86JGdvCdTiQJrdxJHwXaFzA8m6A/W6kCNmA0ut66sqaNlvTsHLW4nmVaZ6MDcPRJXYDD/bsDUt8DFJdWt5l42FKgjFdUdwmgk2CuaSZG1LnK27gyXvVt+SSDlrcMMoa4cTILSnx8Z3hJXnNTqkTfbxjAoc1qpdLPc8+BdSPbvI2T+T39EF+vWkfGjqHoUpC5IK1XkuLGNQAL3NqVRtLVs5oF3uOZw3r25Jh5ZVdQn1Btbm3ee/zTslcS3Buzfnun1XPIfGMpdergfQFim/L6asj3IacB4k2xrQMWAHfFaXu1ndQpRVAAeGvjBfhnAzLyo5896+GXCRUbkWVK+GV1Q7+pxTzvof/uHpXie5lGCCT73bWqHwSLUPMKfC/EW3xELjyVfZC31yk0lVFwYczmoxAnU4Oy8jetCf4iCMc2/KEgBUIAS0DtvcnT8IV6TV2Hr9Z2B6FJOE9hxMHhwvCpQ5GxCp39zgPXlFREa2y+QU+R6oZ+wT0pQ+l09/ypG8F2IYG9jDAgtHdLxzNR4CKNoAs+zjmEAJBEm1S8E5qAkdGQUqMbG1RFpoAkZRZenZWWuWnRKMzk5wh03rOTJdDJDm88PhJfces6QNnKxp6sTOSGWQL1ArxdZH+hYY4SfvKX+8Nzl8Rvsk7EY6065rz+zNcxvHzsBvCWdbPGldXPZ+3CVwzEx+BDtCvk+H18Z4K2ylXryAIEgUTmL+8wUoUeJ6nMFgmWrmn3LwEPPo2wIPw4d899E0/bXRjWI6S+e3zytcW+IWa99mPm8GpyNP4h/cy63Sa5z8adGnTVwvaXSLnvoCjS80AeYVcBnZo9R+BAwy5o4bdr16Q44QKeUsxPxGiDtvyBoucJAmkCVazQAO5I+oKq7UIiCnX1dURaRUIhw9n50ncy1Uqn+uWEmVlcZThQZfE/SYx6lGUyvM1ZptZ/jATPrrdZKQphPHnH4tcrFgtWOMQncE/pyjTVz7Lw8NX0qYBXzB1ev9ig70VCoJgHyLEj1rtwOO0P3Wri/rJYVY+u1AEPy0qzahznkzgwsHQewiaxIG3Gf6h858nVNZdgYGl5TS4IXnTRjPABLoV6rpgz0pmEJ1ZZ453ksCBO9doYULCnZ6XywrbawDo6ogLc0kdvp3mPD6EgrTR66UM+Kc3IDqRJNcaUa/1J0yZNDWA/FWJdQVwF7pPPj2or0K0DTWPeYtg5YEe/Bi+1leq6BW6OjpkbunUlmU2uzU1YagXDcFhkRz4CPwqvrDuSOVO+O0XFo9sAQGEN3HPBELvRVgn5cZ4t5e/eQRf4aQc7AatOy3WkU9C/DDvaXbO/5x5s0pZLGxcs2MZuLSdJy3gKRF8exUFJkcMAX+HIIx0tZbuqGoAf4Tpmvvzx9OL9z/oa8wYV1cz2u8Q6y7izgFiFra83DIjwSf2j1vPS3bkhXaBNFDf3Io/W73u9qnHxrK0F0RcDslG2++r6My7QhBXSNPz/xgHAoD8ems0ogn7fj6IbWTU7tV0mxrqWb/Cl87x/KU/YyvQ9Gb2dBMCcEU7FRQxjs9D5DHe8sivXQcvw50iWGwddXiFAqddhcVwK/TsACOEowbMqjUpPZX4Y7q4AzMz9cfWpZM5U5IdGubmZ29m+wmpUD8OW0NxvjVb0yYhHr8pQ4wsPCHk+BfkVWTr8s+7TZ2uutaz9TsauQINrv0NMA2/FdaRDJf5gkuze9vt8DPcZpVhosha9bVaY9wRSsv63INeKtNFWYv/W3/9iafYUeTa7hQTqD19bfu5FOdHV2PXEjBXkEhYFyrvNw9LJKDOYV6xdRHuFONCEY5xsNqNbRhe1SRgGlguN/zKvb+yWR9OV/8bZbkq/8Fs9BtrDq91SN3DtP8bhIvvR8lOT9hRHl0CPYqVf1XHv4SVElX4Lr2gi+rWsI/D4L9Gy7155IezWCEtPNB34YlD355Hne9Pz6ahqS6durfoQ5nY9QU9KJ9dGmx2n6soz3/JqfUESuwPoDdvoP+X4xn91UfLDkziH4TDhV5nnCTvK8RQHO8DydVrZCf3Os/Mw9eOJ6KG/ADxX6vUnhFhq3borWmJgDH/f9OhoMit+GCvtiBbtNN2N2vcE2eEOPugljmF8png/B/76NqKzQFgm5KnWO3Z/bf7TT4yeR5Lp7uy/TxvWKPxZpTmLjJof0+HrolcoWJqiYtDQUf3Y9BWUw2sz/tve9m9FwXhS3di32U9Nf0B8i2Tkju6RdKCNa9eFqad1YcLAanVR5QEoxzf9EM80cESxEXDCraGFQiA9u2oNamJA0QYfUsNnsMzzQZflxUrGihfYo5WbTwJL0GYo4BcZVuNrTMJb71qHSb05JxVMVZ/67y0zvDfVkMkKgB8WMO5xMf4utwgb8G+v9Dn85FgpgsR69r6d+Uey6ZPQpR9BoICvOtA3JY5l0QxvdVvhyfQGomzjxmYBuQD8c7sfpsRaD0rous3Regt9z+pgAwsOEr02Qrb0khtGW66XlVD6rFLOanTOLk83q5a4eipGbUSpVqE31/iGNd1FlKYy8Ih5JuhRBdZj9SaRxsuK61QKvg2sYXYlDEW5UDq6WgXZr94p4iGm/q9rHWbdSJgaPl5lu0jvXl61U4I9Qb+pnzZl8l/JdAv8ncH+RmmCtOBbR3BjA924SgxROcoTjrkFd00YrcuKcvZ2v/9sfh1rsRJm69frLsU/Ub6BtiwO/Tr1LIbSB+ywKZKg3Zx/IRLKQTidfbNHS4XS4t74j5hxwUM6vZb7BnD0pAoaEiDOTHLdtJBCE6C7MGXdZptlw9tx01iVV0exVlCYmAMyFyIcTISVHO81Rpk0mX0Elg6+cTW+4l3uUveG5XVMGml7hvht+z74AXhdOkAjgXPJemjrvYK50lp7xeSklPjycFteAyiwzUfmPQyMiQo+YjCbgUuCaO0Nx/K2VqURc2FEbuIGWPqf/wx5vdcwRTH/7l0cydlDO6Ucv1Ve5YuylJI1sZKGbHSxuT0j7BW/cdjW+sMrbzugvJ/WN/UL99sTE34AY1gkQhwIpmKAX34HCcoQDWSezfBNvPzC9D88XB9phPrEDtPF+c2M2yX+9IXYMrJfwzQ2KsPkVWLHXAVk/SlwjItGVaNO6WaVmQWHLu7thS/bG2RGcw0/7FGmfP96tAnK+nSxStDpKaeAkmXnDLLOs6hA8YMHQMjofuLnUOYiYgVr34JMTh6GZIfRGszxqXntKfzvCjDkSSXoMLkgGXooLf1XFixNzfulyUQjf32ZihkwhD6MPpw0FUBjIJtdFqPmNf4Ux3Jh2y8n9/hzFqPNo6mTpegj35e6op0wvbxGoK4yq8zFl/M73snP9sKzLf/qgaqCehgTCA4ucovwHEN84Ey/0LkRmPufT6EhGUItv48UOS34KJxYVd/lVhyBvfzLEt5bd5fNdv3WO/qDizuVOzi/vdDR65fYnuNAjJWjaCREzr1RIJVABzDIp9gqEeTpNdd308MAaFZEFfwrQ6dhI4UXkOLN1O3EGHeCx8VZVnGpyI2gg/tFNlhFmTsY4f5ZAl6pZfh98N5dGe9N1+25kWISpQDICPHpFt6I05BjVbs/snJOo7QC9A66M4oqEJpbrITb1cxQTbuKYbqzNPrRJOOYlCiJt/gwdBzvOLQtY1aHOs+zulNrGaX3wjOt7POWprdMuioQ78ZA27lQk/DbG2fOIikr/wIfbKjUqj8WPrbp1eHeHPSF1uhW4ctuDIw/SwA53jdsCgnsN1TmVAlnQ9/slXd1uM7AeedIHJydBrWoN+b03P4jxljhUsVQmkXxNVmcNDaLi+7PmyRDR3sU7FzFBcqWYH3EAZQxcSssPgL3+h1o1tk6v7YStbazjkzpxPTJX5gbD3jjKne9LwWiU7k2myZ1aKnwxlybXLbnB6jL/wD8dNwu3/W+ORTWl/+FluKJrwcNACxhhLbhFwsFc29xIZupdWkYN25Jlbnw3248QLo9rcTghZF0SkqhEOyvhTox1wNrXUtHojbFiF/cFZAIPvbaVo+W2H8fXRwLVO8jinrFR81gl+6ecHein2TPmUodLrNl165Z5/Nh4XiqE0swIRNIcNa80xjd46wIm39TwahiYEU9EH4gjIa6S9jacg4EMdQ/FIOw4SmvaVmH5HwrlKiXopeMmxVKnzcdk5x1g6vmMAHnsSuNd8yDFEcfKU1hLwAGqZSjSzfpadoQ8LK439isoo2m0WEdc2Wkz6fFKb5bjUFO1JpKKEdigcz3fv5U12EZUQndJdUqu3nc04IuDVVafbjqnpW7bFsgogEYPZye13ZQTgy9SUvrvltHg8muDYKoALVRL2q5kexFrpneNmlpZah3ym2PWK1RK62+hEYczbiTYO2QDvEELHfKRwk4okgEx4B1iOuG/40qjvw4HSvxhcEVxkl50PD0JNVqO7LI3+oS22EN91WVoi5sT5xy53nOMGKsZPitF4FM9+8vtGa0dcUsvXCL+SIdg+gPdyrWM/iP+I5xD/bbd8QgC2LeS/uTuNstMRxWhiR+t8hIYw4VTPC014cLid9UAvaR/j6gxUik9aJkyxQGJklGBLG8tqwpIv4CY4bMRGcz7ZT7bSNzVKlFDeisJ6Y8NkZWoU+NxLRk/xQvMS6PvgZieDTLsEhuRK8N1uNfsNxHZE9qjeQczCUhCzvFAwSCOHY+LmFqvaKUgRRPeWWlzkB6GSovQlFkf7MC+aokF2HKOGgOOKXcaLVPFiz0GbYR9kom9FL/GsG0kOewVIcbppPSyXqNxG9IpNqDsBsZkMJr8z0dH5q9qRA+H6JwGxT+SiIBpYV83eH9wOdsefc6aBlXrm+zLBt39myMkMukjdjr85J/SQJEm+7OOCXd3Z3mkw/tatbk8qzZKOW5ot8e4LdCDxykRfjgYLg7kNCjbQ48DCh0mWDHoLGUHNWWD1tE3Jz5uHT1RdCV4kzEVKFARlCq/c32U2ns0D3ySa3s+rQ+nouaT/qXAUiaib76SvnnfF9aHfY7U4xtzdKK/wuK8i4CvdD2Nxzj+jpMrHbs4HX3wX2NP51UvyGgis7HD3RqDbaK1hXeMRCIr2VoO/ye0MQlgct6KxYaH87t+4UyZc+U6eSL/ZvKJy9MGSaGesAhJN439UwfOMdgM6LL0qKftdxAb37Ca0qjQwfnDCBcv/2ahC9SQENnioYKPnPnHuNzus2fcWv6ZWyIppMfc7yaf7rIFRMJD8JOnkSO4QWvpMogpqwtbWcVH7gQNvtOKJGP0wXtD5e/LyDp1Pbmi+0NuAf4Gbp9SWMp/XNB5GKmtM0FOQB1tPJjZJ/qjkE0Dk9UP6oSdvBHH4PRODTpNMtifZNJWqj0foSnFxZXIn31dFqJonkt5H4qEDWD4Dug8AE7e1kedyx68K4F7+ShhxPqXEeqV/OMYuS4HIz3tMP8qyWNrK+7xT15ia/E/iISiTp1UTyoiuyKRnFHIvtaSqfrjgtDopwfiIAFnSU3CssDjOmSkt5VaNAekySQPvJ0d2WRtHhV9eoGMqqtaHzTdU1Sv959nUAadLiexN1sZCbEh3yTEXdKADGdeZD8lqq/q2PIgYocl/QNYini/di/m8S/oBNijMggfvHb2KBow8Be5jC7RET4QP2Z9oeWBkzallk4JxkJXnPXv2JtMNDb181BjtPraSSkZbxzkH5KV1PUUjpIhZkCvrRLimHp/CQs3R3CP/PbDD+pclKCim9WJVgKSkwjFQauBqTC3IdGk6HDDLuMbxaAcpunT6BcoO7i2v/WD52YuJ9gb3cEsQHnKU8T589CWFAYO4hh68ViE5lwA0U2ftksNI/NaloR02KOPMYNE46V+SaJdzDWaz6KblYw+FfxegvAHIenPbZ4B1qVyvxFdTCMztXt8Ji8z4KMFLfOd6e7+vICClIHr2xQwk1ifM41afQQOHvJ9uu+H2irs1wRDgyfg03Cc5WegZY3BwlQxq3tlgffrnosZmg3KHqTYPi71BSZHDsGTJfTQjdQ00Gjl20abUq/F0AGdV5rDAICF/0MMHMrHD6mO+glh9fsP0w4gjrU9xGFke5ewCxto1g2sWM4x6AunO7WGt/KPu0qbNwuJg/Tu/fA4ycjBGSh4M/uH5fFhX3KkMMaqT7tGyneQRt3lR06iOxeiNfGEF0N57mybIrl0Y7qhiMCSoxzM44FD87F+7emBKwPDsvXVMgnugtulEQa83lzBtfFag/6rcU+pZNZbZSWuYS7zMH6Dwp5ZIFJ0+Q9tGD8BeOzyZHdus2rvvTgHsdI5tkL2W7BgaZnMicdjIlMkxr/2oUlMTmDmUBJTVjhlQE3gmlr0h1HmJawQm8lyDiUtnYrK/n+RKvEGL4hc/j2ocfMBBmBHGcpA8BkCHnnBzPjUAslvuyxy56RltYWWYxko127ETo4vp2DNMCId9BrZCSAQbMZGuDZo/BHaxMRzmI3PwB7J6Xcry2Qv38pk3v8kJyXW0U7kB6EkNuWm3B5WuO6KmA/V+GOBbgzsQXCcXP7bKWLtd/+h9qeIoav0xKDxLg+P0OHR5AZUP9Y13pvoDBoeOSDBY2G70uQBJXBz6BtY9HZbSEpXyYBWSPCx9wxhuZlHsj82daupj6LY/ek5UMiR+HCYnOQ5uAo6ejrk0gLGTT3SLLCNgXx0HoVGEaOsKkSUT9mX9N7CgFdc5f2h8kJTXpXr9ZGFMKf9Or4JJDBczVMbXGS/fn4avBMeelgodEIJStQsg8oP9+oOVyClm9BZfyPWspGJaOemSYCTjV+FSYHJu4Bs3RlqIPTS6fHAXj8ynaCdBjDFIJCV05+w0EiESpUkiWXlysqHmtPYoKEySASjZrZVtNzB3JwoRel0bgpYjyj7f29LAZOwaD7yxC6HbbdlJwQvzl4xilkfhR4fa9xkeBazwbhg+wzEnmj8TDij92lcs9oexf9lP+EHkhjRArihCzajEspYhtqpEGAS2lTiq7Hamx7sp2Q+//sDhcjA3sRKMb9AGx/kYnapF56hS/kv69a2fdcrSFGKM2TXazvDXVljNsRRoMMSUpT9TZZcYMVSnq0fdqX0V9ITag637ovqUOrCKWB2xq6XVjj6RKqGBbaBZITb8KGikqHamFtfviyyfOiSIBGRgeJG7+BrhEpxkpZTnH/1eJrZ603utKHv00dQ9DiHWethRlcaFxJsIfPtN2xuBDAlXNSRW930Uk1QHRNsqWGoqZgyxuIJSXF3qipbD7VyUxblHpA8w6P6ngvKgVi5moo7yhX6qW7eD21FkULlPMYRBovwI6RJSEiJv1QkbMMaPz3e1MLMiRf66D8wpOM59hnIoaxCUXe+BeIz+6mtwavTvQ2iF/I111agi6I+ecEkNIfNULUQ2qI0W+W8cyC0Ldi9Uluf03y7YrRow94is7mj1sxN5Q5UPrJph32C8lm1yraC3RE5RusBiR6JmkD8gI5+Twu8igGlsOTGh0yYkm8jwhE5l3B3P/v0xtem7tG9JhskOFrlKz1ljmy6VGa4RkO269bSwqO0N9arO77pLdSRzJvh2h5JKASkppazWTbhSG1eTRleyQJUcqiBhkKdxaXqwBo14hsyijUBrFv5IaG3iFMXmCxnuNYClrykTH5gcpNi6PkS5+1AXgPoNdDR/3q0ZCCMT//nDG23oS9yKLtTy5xZlj/ejPmNyRe/VMoL6zAIp7WRS9R272MXPl5PEkXDjq+zKUEXxShdjVxjZh122+/r2D4X06nbny7fMGcrNDlxnFNx/2QfiDYumXpviDNRzvH1lqAOsU8qU3FpFT7ie24h3WASxqN+4V28tWaxf09dwCvc0sQlV+mqpOuh9nAR6qmmtBpM3cs5SzaPAWQ3ca4es/ZTPtSvWlt03oIsnh4VQnLF/p84AiVpsPMTKp7N5/41kbC2eyiU6OxbdkXWBbmOQMwsh/LuV2BYOQzg+EluD8cqT5QK1IteXURQTM01+joX1K486EAhrcwEEkxbc4MCC2yOTBPN8uQNov5mP2wEZt6WUMZ5wEC+7IjpMtiPBHdsAhAt3RXGiNkVLK5YTLzJvmUEEb4wpP2p0FFgYwiR7HBx8HVu5ZONxUHDMNFs/Nhw+5y+aRu4hGDxr/mmj/ecOSlaryCsyxtfW7tZQwkyWrohdUc7yRyin5f0PbOyNzjHPRGNgBIA4qt4ZHB6cFPhkekWxC+qYI6aKwqy7a0a5MR+jFiR8JkzOw1660QpEpehbMTHFX1542lN4kQi2g0bGwNLT8IWxCOj420V8eiqVSZfjsUWBGw8x5jhDD5f2F0evCH7S5c/k+X/dL8eCEvbFulnrIVDETkC6k0gbJj6w1m7OefaiXoAeTZY6irKjjPrpmzc8DWoKAtsCwcWdnrd9AH2i5r/tavuMIYwS9bNSmsTL+vOD6oOlKL+Qvgo6YDMvQFgVlntP31OV8XGPKZs2kuhjOPBPBVHWS6bXvlJniCwxbMnRIOQw9+X6rgnRAogrIwL31sRgVXcBts4KX19OlK3DKcSOvD03HPK9bb7cM8pOq2daDyXfPGv/MiPQ/TwPKfkXp61hb+K1P/8UicXemsFZlPuiGj0EL76FYsk6nuXhaDci130Mp1MOytUBLJKXTLH0HXDenCt3lPNz+LCQ0ou5bi/TjV06OePbNsMUDlR3VLqtCCaDj44A8T85vW5i2dDizu/SMklQkVE1/h6Me8NF/iN6jtYo0oTHwiyJEm0ft7xC9kcIHCZZOUTLlK9+irQ0DLSlRDX9mkqyioMwSToUa0IlQnH7V89HSmI7ZyGRmGcHzCJScS0z7nrhepYGNhvr4cXnuqhEFuiZg1GscPfOyzBH08GTzTZold9gqQR+EpiuwNvZgAI6GkJndJsY0kYQr9HpiXfP/Ol3MIuGqzs9J4DWjfT7NErvPNA+8/7EcClCVR9cns4wStO8/gyvQ6bblkvh4vUhw7Vd9muPVd474y0henR298fm7sIK7t4rFSdZVMIRYn/YTuHmpLn3LqAe7MO7kSYluTBQ8Db0lagzfVdF7fGHh+vsv103YP5jPpXCBk7JVj8Lr9Pp4/6W/qp8UGSs/DiIBr/kocusg2KEfpMrZIkBOJZfrBiJOgRVGijIpeu2k/bCJdts2s8ubiu8HjFJSrUPgVqcjd4rTCfS0yaS3J1G8RUtzsW2uhf8Qta6O4ckT8TJyb02c0BSL603b7E7IacZQj3O9hXapXcs35tF1AmAoUn0TqhG3FtZvjblnOTTmahXEqDSv6J5CJT1zY/bS0X6OVHf0oQstYFwlVuKLDbfmCJLjozQMXFAy5X9dM8lZebPWDDpB4npHADT06iQnR70s+maEPMPiNjmVopiBnxTUemQxHq/7GSA77Y1uoTMREPugekcKR9HHjGtdszQUtQiMFVNeFUQtEzUuMM2XU2BzZ+xVJNi70luRw+Ga2rdhMP0uO7IaeocZjCb1VYTdKoayY/NF/jTLW6DUE7hLpBk1aRVm5A94FPV8vJFgm8Sc+kxetoPaR3GMgun54eC6S2Yc5/I+QlDW3MwvK6Ah5fuslZcfIHZtoOMtW8Tv46aDNSmgfliVxdaXa3XwZOl3bEpyxQFOFOBMorO4A2Go4GKBDHHkOKhA7IL+M4vyaMoQ+0rqOEYHCSWHrnDhXwdIBHfppvNixmv6WxykqG7dMfWN0Lq3ujCWVeRsprVE+tHN7LrGAdj6MsQvq00GU1R6LOkqVrh23j82Zdm8bOyknS2j8HeYUMWka+h8fp3/eJxKTSWIuzOYZ8cEEdLTmrETj+IhbknAQYh0ET6roAUddAKM74i4I0FZ/ivKIXsWGHTdkdvPVmXV4PYFiiI1bSo8oJQBbxQ2NfziT2Ok1q9WXno5WYVWQc523aURvDm1Zkop7pMD7T4JTXTqGQh8dOnuZ5+67yVoNWEq9Pp8DO3CXxGm7KZBczLsvyZlKbimsmwSBHB7+tBAffylYljBd0Y6FMRMmJw2rBKAizMx5FIoHzGui7Z0KkG83mLfYxVk30eEYK2AJayCBjhJ8J0miP3dMki2OkC0IzouqxkjO2jM4CRars3+107Ma3LKT1DnOTulM1EllcQ0MGT2F/mFiI/7Qh7eEoustMw9QqiweNGiXx8GkkjRy2vO1A28HGblq965Ob+dc9mOzIkH9M/QGgrMBvGfyqeE6ASlaVWY9Dq32dYnCeQ8KX3v+7j6tAbTRY0tU6tK7TLNexm0DDeyxZa6GnN3iRGBGO2nmJWMzXxlCIQzM+d2e7hs531ddAD7W93QHxd/5ehoWZAtsxcxnDiIHgj21JhHHRJZHHaRUmXNfVynombUwuq9dWGEHhFS3A/uzE4lRXGO05OXqGbqyWBUxZfK6I1zlmfpUwJKRe3NqG8AgLsvN4A5LOxMWDZnIjxBaP1lLZXQG7P/BM0BGgEP1yNHX7nchO9wPz9MstP92F5e9RllIYJmZB/8qmrQPQgvhy+kwJwBXelNDn+gmfp1A0Mj4ylpSC+LxnNcJFwUmLovBIlQmIlsUhIy6Fc3kdJnavhU4xiU+KjS9yhhAYyarJtA+A/+/CN86WG969dlvJdYfT6ud6EztwuwC6G7XdIPYc2LSHgLdJIODYAxf303luWLw3WOCCYaPECjPJULtIm+i0nEBbx5ivAj1kQPj//cw4OXrXDsIg828YG9PnC05SVZRLdCcy7kdMD9cRHkrr3tgRpKUE5bN5PFrkFGPXI72rnJUVmLtkAmJO5yJeoF8pdQ5yjC+EFKd7DfIao7lmg6UaCBZZw22ZlI+Yuhju5v3q08CKLSJxdrktDa0CVyrrTLrNlb0a7P5SXmwiSkMZp/T7l1ucl8nAdZDSmVLpYX6lzg537i6FDN580YBjpoUANg5zw1haH80N7u5cZNFdGHViI4f55Cu/ykncBN+sgvKBgjSPHgfW501TXZc/7auvUEgkKgJVfteg1JcqgecMdQRC09dL7zhNEUOSmT9b2IITLqLjRGca7px/ysiDAz2T2rGxdDrHG4MQmm5c0x78eiWndgkicrrdhFmhqIiWj97aZm8q3uCoSBgedp9gRm+BUMyywIhMEaP6ST9uE4ZiICt7ri7TdGRLZYz9soLKEBDqq1r/dlE6iJr+JFFgufHQdtpgaWNix6hEkCBJnJ5BLQr+ZZy20VCtj4TdzsZU+ttBRegzddrRraq9qoJpqZssIzNv2O8CI0tvmuVIg8HKRhrPmZTw5eZEVsk4/kuzRaRMZch7p7Aq9xxmBL3GYRPsbLmeh/a/w97IM6a97u7O/oihLvQ/rQkwiTkryMlPBktu9jsYoQ1rrvWFyTS98vijXb7yG8WFlIHTpKOKlyaWSLP/lNChpEAznOXmHPJb3dkoKxQ1pSLjjoih7UfN6+J9oUhjg7ifeUUJMWAcHxwg1tyqmQEeH+9dQDXOShAqpw8VKWebKoAW1zg6/lLP0kiLYqE/1glFOrfdlChejNeaqvQLJFiR1xJvkSfZZJvNz0qGcS0xtfCa3X+/fr9TsxHUfV3uXZBTeobYkqp06K46oNB03gXLsF+/KUL9c8XChggXQo3v7z0OzPiEbgfxwrL/tvX1JsuEks9YRhEBfGflkjbp92uhaHbhhz1XSI2Ezo0uoCv31vk5EGERT7EugAD1ggR2w9FQLnBSffzivU0coihH98+gJKHKm9CtqxnIQXK6smU0G9jWmc52sGaIEedlEZqBL/I/S4yVLMPyE9XOEYjfGw92tTsd9BIzoz4lzo24FyP3kNFm13Wb4L7oMm/Xn1AZ9q9ib0TDtHKZHhCWVW++3QGkfA4f8ndzEd5TzdobG7/NdyWeMqtdJxCiV6IhSh8rSfZrCSxMAva1S5JDG+8bnskdYHst3Wmc6tD+u60OloFi5QSalNsN4Ud0CQx8ZV8UavIjt3B61stZjpy68uoUFlPVI/sR9cocgV23+PHywOVnvp0nXcPlt+H2nUPyi5Px/A33PMGbsehcAAw6y7nLAuh5jmiJK4a/K6uOQDxhDyLEdg+u9rCdDaywySSpyE0jU4e1/uxtkcs6Ndk+bYvu5f/DcgyjOKKo6J6j1ZcKTvyy0xlM555Zht0AmYDfHx4Cfjh5yMMIIwZ6Zb8Q0lIyD1PbqQgGj7/PPAsBxdcGjpXoo6TbzQpnlSUo7FcNMP6fK4EsTdYxOO/17synbyEOcxaU4d2uhfoKaAnWs9Rs/5YLwuB/iZeqdCVwkisa7HaAIw7Yz6rjS++/32lrKiC8XNdLkJuMmKxYVlR6F/8fjUc+1fgBfxicwSNjmwgl9z5Cxp5vyNGDNXUrQnGZaKMKzeZWe6JiJS8iAVdCV3Q5HXnAqFJKWMQvVdxWEJaSprn2wp0VdETOK7Wt+SwvMe+LPZGt5xkYztI6pJ6fqDJn+YBINmbFuVaVhnuezpBnyHhRw+ljF+Uv+UTWsYiQyHl00Cb5paAfjxCCGoQE6cqR083hk5mX5gFGYSVOxN9vf6OmNIlM9YrNaX5P+ft59xAZS3dY409/j3F2u8Hl3GKNTSmfP87NX3sitptWTzFdykFnJprN2U2JTt+EWZoM68qGk01HvEjGwkcrPzupMujfx2iLLTPQMCzg2EHjH4Oz2vXx+QhYNfKCEUXY/OV6+P7RDO5m4xzp6CWrTsT5sQqAtbSWud6OeodE22XH+dRYg7PiALnhBvHLlD5clwQTApJ9GDGQNNSZ+FVCRmhMHObHFgW9Va+PDCCvrweYjNGqTX3s5xd0GxeZCFFO9k72gw5E1MwrcIWaJDCMzZfxVGDDtIqsjUyzKjqlXM+eTpk0nQNSxFMAxsN0W+S7NUmapwhM+Fp1oULwD2hqS9Q1W45LXPnXPq4idwp7VlfR3F6NSOq6DOJp4FUxyc9loOgir0UlVr8PjASNl2DQmWwEKfNKxdSN+bjL0e92N8NMOm0E3TiNm/2m2dlGgOgNH8JdI7iBilqnC2oXrdiG7/PWa5d9Bp3+9Kv9Bh3MyaDFvJVG0vB+zWBp3achFc5GBkwrnYQRimqcdPP8gQpmkRM+4AtpRJ4PPZU1rYt1iNeP5xaC9yVUqFfr3YoGarmqB0gbxHC50LphL8hDWHFcSOkd7UH9aD00uB9eooLap0t6Dr45iaZFkQQohflqWQt+7DrEbKsrZUOjPikChHS+YHcJP9P3oX+k8n7mLOja3LrTm17M/0EQJ7I2KGMaP919D5RVKFzOj6tzh0f3EpNK8FR77qxb453tsLZMQS8V6dhQf2gwZjjYXhw/croZYhwITC87grs0P1Q1THPnrOkYqNsjGtVXtCrz0nEZJUFwlDsUj07XzIKfOlg1A2Mq/I0i3XerJAKAVom7RkLqBw6Zfj+WyjPrBI4+OWqKUP48gbcwdsPbcmiz5kdqUDRXK3yRX19kF1awIt1NA6U+yF57Hy+2SXhbRyVKZojpfFfI15AP+Pof7koB8nRlYNIiGf0xWMRtaj85VVUIgqojGSvD3bn/W+1zO6OG1G6i/7doSDiGsjRDMY9i6JtWAwJ//XxG7Njgat+tyhcEpDkJIY8RJNmbPZfxHWnYNzSKvXidoArl7aUqq0koW85MYjcEPOQ4oOS3/zkRJpL63klWf8LqUr47PMdaHPAevhXBj/pTW8DShd9RxcmiyX38S5TrOpV/d+KJ4XL7vWrIn2GuvJKWeXIXw0X7hb9QBqXxUIb+p8C0qc/zi09/CxUBus00Fa+0URsYC1v/ShIo9Jh+mO+ihbmTjRyBOUtAykJVuawf4h+iyqksUG4OxXEvB0S0UHnXbMSVn3Csg9Kn2A8Js+udar0C08Qqj+Pz3ruOPCP5bc134+4LAHxjmHGW4sE/cNfWylPjCsCnvg8cFfVpG8MkLXE88wcROsUGRB1UI/3By8mXqRqrt1mNL+6pmKAJXbFHR/IUbIG+Gn6D15FPzFxn4afEuL0Ts7Arny87Kr/9HGloxxF0Fn6fBFuA2gnN6k1mrBj4NGFeJ/HITBfhYNgq/TYEW4Bplv6hVTxffdEnDXOTWjBroZA7di8xURR2GiFKL5zwiu1WqTtcKxso3fQgWpSgkMeppZA0qULIISkp9vmFXaWQDnqOyY4X2ak46NZ7vvXGhIXixEQn86BOgD2UwPXBI1AZZzkumuBgs2bJc1fHCIY0WGojZ+oXmy4RXIi/FsV7gzAov3IbEDFV0XqvFmqTZXMehEjBo4LXCJE/OZ4Ptd5TsX6Weuot8R0hVqtY97mqU3bRO/NWJ5xRrzavnGDHg6ITvWzaX7Q3hbNSc4q8zNOdbMqtLLp46njDB32EpDn2rEFgA5o2Nh1Zu0AKM6R6/TRUrDtsM0u7RXMgQgwr9AIQ0+/3W8ow+yikr2zgizg3q7G1Y812PEBiJmbr0tgPIraP7X5BnRBiAQCMwBv8x2VltIFukimgYoD/OQkfWsaTDSfkb+d4VeMv1tLCdMBQExGYbqX2GP4+MuZtjcNGDTOqo1wNNS4Dkwef4w5Mhn92rvQChMkdixfBQvLyzYhAEose8TbQkaC/zUrjO7/1qAMbBM7Mzqh2fves1nLLVh9m006xAj8GkJGgVlzHY750tvQHW3Pa/66KMQ+7xKcGm03pmJ7jExP2DL4pvL9Qr6w/rtm/YPHGiFYJfyziBoBStNyYZ4jYobAYFFdxNHGjcC3cnwj+eZ2mDJqUJfiLTisdmVnJ0CP8TCNi5ia9OPwCb/F4NU+5ENuMsr6xstMJNaM3eV6c6/escmJToopJQJs26t2r24WbLF7athW3V65M7D5NQ9phqGwrVPKqMf5R7xWV+EHqP1LOJ4dMuEDjf/iOmjuu3be87Ko1+hldaVvHuLYv0xfu2KfeevPFJNxQKy/a3DDMHcoRZ8TlLu5NgSuSeHiah7z5V3tuKxTt3mreB8mY0INTeSsz1Wm/sKJcwzypFQ4GO4IUKOVKSbKC8A2jiFZM46HE/FHiQna5Rl8djnVG1oDgDZRgEtB7MjYQh3W+iqRkBaEaFnKWTZsN3+buXaYL562x38A6I+6hPUq9We+wEZSex16YWKU+U0rMWshsONL87nS8If9rusc85IhMbsSutBL7CFcJ9E+Pdf2gH+QFjzrr70ZxPrESh8XSCPc7sdCB1k2E8WdQb7Hzc/ojdr3Azj4dSE8QFRgpDu5fEuj9qS2WHYszKe00nVvUvFkDW8hkX3+39sTIrP8IInCL1Ymk4tNN2d+d2iz9TeTk/LRh/9USdIAO0aT9LvGP3UtyNlmekXywwPdEG9sclFZBJTKWbLirvn1ISXypWCvhfrxDWTZmW4R2jo7aYu28ct90ACDKrkr6NL954muFxQII+qluofKrOf/wZBp1Zz7+owfYOKF3vTcoMrxeYRGn9/WhL73nG0wgQJvzgxvTxdZ5DgdOb210u2DJcfayaGr1u04qjumalXKh3xb8n/Luc3d8Ol/lZco/pKsJtIBWyLDgeqZwRKza5PxS+ODSWOxm5lmwlNRxZe03Ndpc+JChhYd1KXYR2BbVPkGi83mCbzXQdB5haBEpVb6RgxgXMVnsuqnHgQrY1oU/WSWB62mDbLoZVBT1YZwOW3h74iCWXQdCBdkk+MaN0PBJNw2enUhAWYIcsXvdogEAuEFzyeJpGeRcMbtDwdxVTD+DVWkSQie9xmzl/0vMEGk6fkJsP6ONeAFSrawiRXKlQPo9SNjb48WTqkZIArAhKA+uhsNFT9mzNVY1ZaftY8cgKemjD3idt5oXy5mEjOoExXN297ELKAhtPmRQpGftMGMar/ByM7+1O7XxAKPGVsHA5imlwWDsY8f/C5B59bxD+1azK43P86tKB2YP0MljxZ/QXIlS0kwhCdivtkIfA0HTwsJgcjoSf6A7Un+3x7WDcU/48INNAxA0HALv3ZA/CsCcrMUGTwtVgPowbsOqydxvjrzZ3Ydsbb5arWFJ1ctbZl5ACsi9SliACMfhrgpNz8bOzkrGORLURLKBGRKnGvXXhU3qVVTImruktIMzMmM9NVvi+/YnfYG/5S3lKPp6IKvP+UgPkmHYz/2d+Lqp9dJ8hYe4xs58MN/9JC0ulfMluhpKWdqs0zTyk4gzUbwC8Jbz5wAKMcnAKPNvFPWY62/Q8pzi0PZctGfQLXwQ+jBEk3xIPjFpGsQ0cezg3hGhUeIPaa6hmCUg+2kXhM9B6M6PiZ5KH/bXwdYN4FxhkalD3PeZhaY+G7t7u+XfTQs1556wCQCA/jZf4Yp4MKJaNBpmNkruUuT9nqyUElRkKCDeKzHpopwtdQZpI8II/fGUKIHQyl0hRzBD0XIcrh44iXnLvfGH/1UD79A5pw0WRfzrC8qGfJkCqkm61jztaKxJwV/P1WcSrZk77rt90tU2hpuNxuU8keBCRSweRCdBQ7yxFhH9MB4JPSGHws28d/PHhX9+J1twxQ4enJObhiKe2Q1PPuM4K/IQrzEiRozKB/x+KwvA0Ur+DO7FiOh97DB5m+/2wKW25eMaoHhI4X1CL3rPB0DENQkdaSzlDKru9Kky91TNzq5TWJ4djcDtyLr3q9UChkzkFOgXAB1dQ+pAeXJDTfemXKVTo20bYj0jQr2fxJnxQtcEWiwusf3NxJ94Ka/Oum7iYcFDetRZnyVzRyjVumFOj+jJEIz0x2fy+1qUdZF5X4OPyWzC53J5sK0wE+n+Z89hm3VtebFo0IdBRuO97YfeOs1pZrjFtcTRcofpmpp1Vlnvvr2HOfGxZ4dHDsk14f/ynrppAOOiBL1VjiPERa4znrUWnTUpsH11v263VVAe30Ha7VkC6dwHjdX2Pldkn8r97lwTwkpbrqWS8Z0+ArRav+yquPQOUeRTseundjffWNLZTRWTnOIrI5Cm53al6lV1gRUzgpGCSs8DqNyT4K9OoMkQ+US+CqRtfqEnUK1KL0xXpX49/kWtx/89lLujb+t/bL4Qy276lHDUa75JVIEFUdUIDSAWTBcu8MDOpMQFm0DygL1HBG8J/oVfUkwbU/upTe6cyS+y9BjJwDZvv7OYTw+mkawcJ9ueTcG5NLnnvsITptr1qNF9tzv09NnJKkgtpMlJTZkmPbHyAlVx8nI9tXMV/wg/FzCqgqKSjXUqM/qyOYpRlRoTuLhbVLMsq/5HrSpivd4t1+e1brEsY01Ioq57P6Ab7UzhkYnbRlZD+Yyqn2Jv9DP5AzwBZxUEn4RdluYIi5h70u9a4nqs6cdP89wImeON1Qe9Ef7W3P71jCYajcBCajV4UcO+TDN1to93W647waurLLc54tesofLuyi306ZsxQXtYlCfO6uwtDXqwjadnfC5f/ofkBUi3yRXHESSeo6GbfTyodPFaqiI+oe2em+syrl/QeH7TW9Yur592PV+kj8LLnuJuQuuWcWdnezDIVK3/aFwooZvpViOq4qHNybi8QXqP7Vr35Qxu9i0Ym01XbzgsLNVUEIxpDqY3DlSJi0KGxlFWjzfcpKkf0EkdnUUF9qqYU5SxM/7U8Jy3bVD4/OqSuKyJn9GxP/4qtQPCjtR7DzeW3A9UM/bSH0jsdaS+0W4naFsdjWyG5nT1AcJsakrKq1MhAWU0t4RqJpdzlUSWM1+Isqp2JD/jOdxvzLlSS8SkQLyMFji9nPo3hkTKJpF1N/0dSyb22Yn+ckzc1pGVIaguBpIPPHahsykWxF96+teP1cHQ7NMaT56YGmP+Lh/D1UvbpnT5E39zT708ayfN1zHG+7A7krNhuhHgpESK7vlhNqhpe/RsdiNstoo3g6deHhaWIF1V0zoE4E1qeGrMZ6rTxV/z5B7+8MxhiN1Yed5JKF5TQVQ6Nv12hnJLao0/9mLkfRvYaWDLJFlPNFUlLOkK982xi0Tr2ws0gcGeA1scJOkRha+d4kuXdGlO8DVmZKRckiafj0T0el/tcDOc2FVAvonStdIGoC+KSwo5dt59+PNO4wpfyHroGjNqnVRzPWnnJd5x1+ckqbKdHPVt8j58mIa2bITCT862sJpE8SQ5SmIMHi+poxTvIePbeEJgq7ja8NI2LjXnpAYnfkeWomEVYpi5DJVN5uipLp/emWTLG/TxuSXKdnURFdW4iZxXNpFjp+Xay09AEUKc9/3xPPJjN3hiD9ZXp0pL2iHBGe5OOWc5GQF4cMHAAleM7WBkv3Sx20IhyT/IHRlisslaRMteO27Fu711TxS11EFCx3kBMHEy9ka5W6IfpXG0HQDUz0X5mQ3PfbHhrHjb3tsSQ4NXEDLyXWs8piixwKmeJTK/saJcoHGCyTJSJw00SX01PfxnK9ZP9gnTuGxzeX9Pk/PMPMsJZILLvTq5qXk2gQc1/SJp89edLvfvQ9Ho8D7wf0VsJlpGCmsto6h8ppxvLEcYtpB84zNaTTwxrLYOsUJ6K5uW34bMF1wZReDt/R4rJqhoV8NlLFzjOJmDheRo9LG1Qbe76nM5mVoOVdqa0+X928iPeT/90PUWXWj3s8SAi1YCNSIKCBy0EuV6sfCNq0yEJO/4y/B2NGKF23woZU/QUvyKzs11FvlORQdPlPeKEw6jUzl3yf01qkFBq3EDQJApRt7R5+tZQ1wUpF0+0VY+pF05N/C7QhDHBX8pXuD2Pmwyrv63S8BJVgSJzUh+zndQzfVrJop04qs8mwL3YYhbf9rQaGusK1ot4pVN1k7DeHiVADYG2QOMmftkQi7JLIucERWp1JYv99rMINgLvd3GiaCBnI1cf71BuBP8pppdIzuTI/+VvzFNSsbWBvGH3/7lbcLD7YmjoddVtjJXSKbxrmqjizRzLY6V9AOsn4fzf95bsKwZxKruDIrLC01jzOPL3PHu+KGK6BLB6Vk6ltSnB2tj0sBjsOAQB5obz4jTjz7DzP4UtgfDNmZDEFf3Ci7Ceo6G4r7Ump0QcDb1JzV5hPJZuSN8bOTRp4vbPIVJfuoW+H5ZJ5BMtcVVN1JCeZIZ7b5D/kf2DztTJej1cs3RHgVgSi+foyg49CDL+iQ9pfSrlJHVW8tHZn3TyYnjSgAyo13SKUdAlpt+K5j0fa2+4yj+vV1N4KgkUjC0DOJk4ZtDPUsMoNDh4QO4zvidFdA7tQa6/ilVD6jVjRT02PkSy8koRNEvOAFphc+mdHyWleMXbWy0xKsC5mM3gdYtsRlYCBmDTQ4lT2dF3wcfDZCJ72szCPk1qeAtaQosNMAOCIwRISqLQjRJxmAR5g08fXT7DdBw9H5E8Rtdt5UiMogGEyfXjF+UdI5E02nNbR++Q7lBmC5HL2QSh+voxaNkoez2fguWcba41jNHTGwJfx5a+s7dMK5ZS9rdGAfz9Xl3mKaQl2HpViZs8oCFjpbYLSe2amRI0dXfXyg8uTb+scka2+2DZ60FJNkZmzkJTGB/MR2cccmXA1VaGfO39dzlU5YjfAIOgh6dKX6/fnIEFiAVTyx1roSOfD/Eai3LBybNOV4zAY/8W2Z3/LLuweSvoUvvbUDzOpV30gFbOj4Nrq8q8elcUe8LYOChNcCgF2qY+jWO9od0Wh5zjmgOhx9lSdn/7dkFb+LPITIJg4gWF+TJhWN7XIxy7gelqdK5YPmg7meSqC+B9845CFW7THXyWkl6ys//HmmAftdAeYwYdGb9yQ7Nx52CetBG4UzAzlTqszb3bA6XUniHZ3mgPTaLElPHXmW2RZ/01yP6esgMTVWktAUy2SH+4V6VR5zheFy6HdaRtmQDgL+9X4/hZXXUDF/5Pw8BqgAF8BI4nfujXfKjddZ1rTV2NluBRlU7HmdRB52D7+NlvwNxOiMyms7wLdZj1c7yMXCrZMsZoHPCbc6k648Zv2E3x7rPigbVrSUuq2D/HrpNkre6ZDIgde4XUoPKUb6kQaOdNxgCseNB/27wggpTKfMAUE6+GQ92XdKTWbjsoq3uZBljnsDw+C2mq13Ym3I5K3vHej3ZxQR2yNzvtf1tDluPv3a2AYpOug4Iakk9HGs84YNW3OaT+WRx5S9/qyXMBUO6n6AFo2P62Gt82Tb/UhumyuYulIeEz6p8sYqTcQcG13IM/CoiQnKwka5XprW0gqEK0/zK5h7iIiLhIBcCwb2Dubsei6Fx2tz8i9I/w0S1DLlRY1VGvn7NYXuawCG+gMoImwB0OK/lFRsf8UboeLFlTjy4tFiIZNi7RMoge3HU+XCJiNw+9H8V/qeQvYmNWNQIPP7o/MiXg547JFBX07uav6KNt1mthEuzF+l91sFS/Z1yaL6upQ6bjNpWSou3cWhXlznBWZduLOS4IE1xlADhhvECfbp8qVBSdPv78ETQ/KlwhKR4Izg8ohFvKCdTf1O4P7A5MCxRBt2JYCZE5If+SU4qHXECliG8YbN4YA6rNVRZVh0OPJcreOc0Y6L5v5jKlIgL/chYPQeIl1oQFyJCsB4tkFsuBce6SbabbRlyXVzDOxWe1YW+zzuxN5e7SMGG2Sm7RW2noMWDPrmTD5+6TDswA4jNc5pNTmZHkEart0zjsTW0WXmGV1ZVuIzydGMO1rSLrfTA123z3TeiRS7sCtHtZdWrmAOvawD5zHa2EKQ4lp+IX4cpRiBnYUGpS5+7z487sLLyG9Pz2iafdTMwnkHfGomyL2qv2TXCG65wBFObfn5RJ+hC5AIiiGRjkRQe3I69nSimRsrq9zO1yanBAp/jb6m1lLEo/l1DeQ7HqHB5aIbFXJeFg7jBHjSlsM+gyZex5fSLvJFNpYPSqrhVIVyHSIva0nKNw2PpzPUFhe+PdKHg+CUAbz4nL7lKbGgN3BafHaRm0u0e276hNoj7i3tkDJCcVHsiHeAqYg9Sow0zbA7QzvzKJhRY/JDoPG0X4RAW2vKedw5L6L+VEFFz+jzEXOBOwMNWCxB6UCzqPOTEvrgcsxvIuftGfPaLgbI2ySnZuQ3CV/ns9hnqjvu8avA0N838FQkDzy14oaMuz7hD2jEa48oggtiJ1whQWX+gbEVsHczqvOkN1/+EIRmbI4hsz8w9pWJwCf8lrxw+4rjdsp57gjgon3vd8UckPpxm418phA6TyqEn6u7d/Pd5ryM2k/ji+QWIpz2MCgcYEtF255Pj9vjcK6a4yZFStxV6p35GSNpKlvghyOiUCFGpOa0cl6YGsztrWhoh94IrG7B8O5bs5KRbKK5i1bVLgmBzEyK0kR9miQPvB5+6BfmeDkeQ9u1HtxQP/OR/wrgTQXf9bkEA6IqG/vcYk0VXYFSvc3M0YT2tquYXSBwQ9pHW85namKYzjccVBGVtfeyJ5JLXwF6cLlYi4ntHYgZhfJCyi2cpwUK82xni81CGDh7FOXpk6q0zLgY18RH1i9hVnudBjopOLQCuNWvvbcOT0k0n1MlbRmJXX1u24oDef3v6AOuOT4Z0m0H1d18vDr2Mo4ygCGDmhLH4EJeEKDeg4lSw9OVaugI+B+r6K5vXDoDd7bG5pZFkih0+z8EUXtbnuFiUcPuuUgo2vBFBjMcVKCAMmoPLTrwvS6zRQ8ksiWF474Mqrm5Mp3QWtWJ5qYtJLjql/RYjp6bOEG3PQZKeAnkPRu8FUnhEgi//eKOoMeV+JDVdEd8Sds31r9tBUfKrgRvr0+RnTqEBb1kh0VcdVGrnSs6nWtk5XZSJz8VtXAelDQmg87U0mDPHfwYG+VBeBM+lerJl/SjHe2hd4BwPXWfRUb0qekt04xc6ni1YbstiyOSkug4WQpdohJ8v6g7plndSjLzSfn56uNcdcIea4jUeJQ5WLPZr4eLc3RK2rVIsvUTZrA+pfiueBdTlUmf3PprEESHVbOsH4aavfn1UN/sqfA9dYS0y4NzEPSymOC1bm0Zia5YdHqOG15gHDZHV7NdY+2eyXZyyd2LwtxezilfqKdia63rgUJqIz2h3MIzmDSvyljkOz/+dkSTMNh/P19Tiz1e//yszS4+PjG6wCYX5mh7W3b/aHINSgqzhLL0v82vOl1nf1Xw30wG7TQnxseEOx0pdNaFuFMMTpCwdZ2MaFcJ4Sk1gn1rithrTsbaLF3Qfe58WsEmWF3DRHA4b92a8Rn2YKrNxeLI4TDNBrU8+vS2OkksEa0a8QVxDRlhu2vwmKHMtDEEBOnl64Jga/tAGmY1MrXEuSIyHUmGAIUPTuicVDOxOmnMXZeZk8UVGn5rDl0HHHt9fnshQp2PFyRQaAnrTR8hbVIr3VqQdSXFx0yXITPmgP6GPwOSXA+TmmPZ5sYOPKF9bjaG4ELWPcSgrsz2ny369M02VeyoiHfO+sNWByGUNhTReAM6vuSVxQP+pl1faJG3m3wUJrnSwU9hpYKC8Dz2z5njgrbFYesDgzkDTcyHdOaZyp+4r3WwqDQ4fEr9h2QVWdv+uPTXnGShrG+vcIHRDhyaRenYPGfuiNJ5g0Sqxg+uRb330w4nkLnOEHv/mud7CxYXGuZJ8BQgJ9KvL0wI/XDCoN0XTuul39/lneP3NAnudvl0hNhaRVJf1dtFWzXCGfrvvpNSICcFVExjPbmTd3rJIb4Cg8Q8XIWyieDFl/huIgjlZ3EB9WLD7XgBiGW1jsOpP/gupqJ8QifUDEfZNxQes7JlSzpHuG3F3r684po7Doz8ZiC8VXLaf6+XXjYQYnnFXTE1oubWIDiALyuOaOd2ltEqlxzKAPCcvSup0axo3Qt3tP3bFLk7mjK7TLmvXVZrvv6qV11WWcxZa0ZrfgKsBFpfiz8M6C0whPMjKK8p0iDQnoJDqA2Ufyyap1Y2dc8e71XR761JjrdbrtTc1KO+namnz75xZcKbIav4pc521DArk3FGG42hxkgWJvSjT1GcYfvzFn+XEtIlDJmVudrforKoK7rBTKZa/TA9ts7dQb3yi8zvPJC6GkqywN5b7PBCln6XXb1R9zz6+RokdnzuHn7TJJvKjaifKxogi7KqzYnp9Ati9vilC8+mz11ycqs0fMRCtTWpKw+pL6zaJi6FnQIyODs0tfyRFDRo2PjM5Mi/iTPpN+witWpTC120vCEbrCbn1mWZUF/CclFqieMvqJg4JqWmgdc0RSx9uDFqGoBxXieRJ8pa6tWXKhuhpQ85J8ITY/7CFCFZl7EYD5MjZjWi5IpIrXCIm7dpAFMoDFZDAC2+WYWstKNFUnMHNaqAOc/e+qA/BIOm3i8yOnp0MOrkn7wOXq9szGhIYy1T4PifBwsrl07p9jil1Lmxx6ym+DFv8oe6ymECBrj4f5NaNHqtJdm4AEraJwHX9HVxx0JCSy+bzRyCAWBxWUIlypmUmFB7wGgkNhtRFLxVGLIiTdJ5b19ilLUqEJttmPO31FNefawCeSK2kkHmdDv61UqG80RRFSctR6xeDE9EdkMyPLDOS9ykH/bS9Sq17MRuK8AMUl1jo19vcE6R19RL7Ya0rvHPFkj1RxEL9LDh1ykh5OYWg9IA2h4f6rThWaSu3ljb3Gu++a3LY6CQrMs821NksAASLXPkZ/+CLTXZqzt9cXNWBI3ZuFFzT/wAmDkvCSotzbHEMN2tY9Id0Oq64aNKZf8Zn4sqri78R2z98vKnnwMorb17JL57bdD6iT1+9Qc8ZV7G7Dg52XmhY3WfZy3KmLyGYRl3uCtM3arXabEsZtbGT9ImgvCnm5p6yZ3ZmoHJAkJql+BCRo7wGaUZbaCbhYrWfSjGa/8n93fMWCaprps204Nl3MySeqY99/gfanaCSdsYu/u2CHtsUzSLJIRfAf1PeJbv8FGjk3i87aHjBYG2RlZZNBds5G+rgzf1qp5qn6UoPCx6N4XhNdIMKkCwlplR1TcTTazUJQ/9WVTsrhLOE0n34eceLt23lhuTYw9UWH4aZeV4L+GQ8hBJI2VvwY0WmXstFSWExB69AHcujoV9hFaxc+8u/tfdocCCoCWFjThGSZD2llqw95E4ddo38a0JjM/2w86kGMYTGQNK2iFj6VrHi7JufapWHgH+gWDbZUhZm7Nhs45gLnxBDBTLZhFJ0VpxhL4hxX0Nqkx7xV64/bslY9QvYsCkiTUeYEEAK3bjYDpzCjueggkUW/ySLaCKQI+eX/rD5m+SQvTgH1Xj/Wj9BATBoa7EhOr9gDufd9FK3W8h1CrRl5/KZmK1UU3c4Fik/vxAqHwFNFhZ6B8rpeAlJcv9FX4a0R+jeDGh3WmQig7f8TdLh4wxsGBbUKJiUkqPdfSYxlg7c904v+MR4m195Fnc00/gkqoUaBQ3Iqsiftwv5DEQOk5muIsndhiAHgMUop/c0TXwstlgqR3f9q6WosIBRZm7UCEYwcFfj0T/pAkPX0q+NQDcsRhgs++fi/YV4k0O5zhRr6VUvE/xRoxnhgqMHNtkv7w0C2P401sS6L7g+M3txZz3Iwn0Wo+vETzKovebOVbwniYcFouU5fS6d6eeTn5VWSj2BQjweFduOrpTrH8PdD2b3o0gumb6DCPc2Zo0l7D0CjIAMqrHspjQxgZMpaiJu1xwNfYX1/OB0SJMguIZpiHB1SfTEnpvyScBzwr0LNxvLKYttTnB+k2d7y48TUpw8bSeth4gKI+bKgfY4yBmea0dz1ECrYoOYh4O1QpiDvRVAHrWBjlmIEV59U8l+yA+JhyILIGMpCbbK3FqsyLTJNSmgYR8S0ILQQq9dXqqVEW1ecMzFVtPUDEM8pR3pyTfAWWxFv57/v3Z+rbN7prsav7rZRJGt1aUVViiq2KKa52EascRp3nZTynd+BFllAo/1uR68V98wiyJ3c0zXbBcnpK1zzaTrwaydiDQLHqDLUWEmuHFVrlVyzSib62gV2YIsS3heA3ts89aaczjNLaVysO1hyZJ/sJLiDHA8vju/9HR4uXj8zQpYjtpO3k/p7crNEy9uTWz3q1v9efaeCIipqlmGYL0wR+QKTiBiu3xhbUIwGKM9lUT987KgHHTtCKY5TbA9TjM34xXT2q6915EAYDb187MNmxZznvYZO4AnT63C2WeCjB/pvDr8WuRaUSvCjEyN17b7fknAViiwoKSpOm3xDLdrIFz8tvD4Tr9nH9Knz0DAK9BjaylTq4ypgTmT87bwyacCBiXozC8MYbVqmBFu6vqZI0kuaLm2FxxWfAJINMik2ghV/MrK7NRClbOKy3FtfNaCgBS5GZU8htfYXc7Gr880xwDZ85HYN/qRhCF6NYToVKEfWqrHxh5rcgpaB2o2Tc6A9Pv2FnW6+xDLl/1PVuOJZyzNR7sQp9J4yBpHCaMUFYEQ5zXvEwrT1M6iNHX4k2nv+iwgyu3O1ZDoJaTqdTz7A8X34pV58WWbEL2PPsvrtL8LMBZptsNKZ+4ISJ40s2dXRtO2pzJyzicfEF8OFATSxuZAWqRvnu33BSqsy7xbFGpDocKue3vSUKjlbTom4Ky3QiP4IpTDcQ4grQnddWE7GKtuIgDXheU7qOaXk1EsCOF0S04lCa5TM3WdK9OajstxeYIMTI+dbFIBhvYCaVDY6ehjMfyjgyKSUsEfY0bydUvulCY8VtTqsina6HuX7DpdX/B5rylEQpFyLnKOU1n7ldwlwtZWDZXlsRFu9YQYEhrcpA5o/zrVEBF12fpxQZ+5JdH+fdGmR3zQQyrkX8hMRvjG8g0eqblQVDjUGZrOjvDj85H9msbVuIMYK63AOT2ZFPWDKGJt8sPZoFcUjmMx4oEFeCy/yeK2PxmTIh1+alz17xADr2NZA5CuCxEmtg4KixybN4TkoDTpeX0LFjNic7m23zZUjQVi/qqyRWvPmQ3hEkgxzw+BWtvhFPmglZAUHkouCM6/vuBxd2w9l/3TjskO07jKKFyfoOMhNeDgc9LbH7GOAnvnattOdaqdjYBUzG9b6iG5DOVFXF7fJuKHrUpiBoj/oG7X3uHW0x5nutBPABbfJNL8/wExtVG1RzeTj8QGyfkDxV2aYUpVz0m5eZpJmxjS+zikUpkYFl+OB+Mf8Lh1vbEt1xTnRgFlrTWWxcsRUEsIBAdNyBBPX7gX1HY7EHF1y3m4Nm88i7+UyrrcRhhbED4d67WdQrPtHcpdfA/i718i+N+fnW7OYYtQ5m7QQJshHuW/zQgskVJdL0MUI4PLmpBtIvuFsIMME3SorkU+0YaH7NC/RzynctIEX0OQWCtVdtRdiuT55mv3pBl3+sNTGmjG9JkI8tQLsd+iWLMiAFlLqIRWmUGtazl0QSo4ffvP7RNkTSzM3MSvTF1DBzO4Dyl9LXYbb8pAswRU9yreQEDYXMwmcZ7n8Q0dpkmmZnttrCkn6TCp6Dq6yEr2fORQ4+t2rzK/DqtErx2l69hE04jcUvzvt6iChEtz4EEJs6vQoe9UrNt5SYixRqt6q7x9MsJLzApoXH/2+DsQcCdMFnZVN9QNw6rjwIUHDRC3mt+QWOfo5lf9d9KiDolbKqEYb4xvsw9dZi3x9XhBP/9aEDTR4xEhoQGvp8V61Wv8Gh+OYgegn8u/rAaM4ZPqqE9urraOA71/TmFucr1K4az9tQmyUvww8NePZQWzHaiHFTxmU2QuXO603NHgccNuOiQs4lpQgCb8cre2XRW4H+mK1AcXdp7bL+DinMZ+B/6nvvlt1b9ELUy+v375Tafx8FaXPUrARSAAOAUTUmTWsB+cuytbeUQTEEARuqqlijliDWbr19hD6D03VkFYyfKKaLha4+iQUp0iHE+kymEzLdsDn7hLJAF3WfNtkQkIJJ8TJCkQbG6j8A8xhdmLgvbxLCPgp9RpP0gGax9w+m3FYG9TtxmDtvjN76MThSrgdg3+eNohTx3MUyh6Jil/HySF+Bg+rN3KDkk1yn+4o+xJngAGpz+dKRQCLdZh1oueGNj00b+2HwfYgJoXyvK4jKZC1qDikm7OnctkjTVRtaC7v5mqRPQDeEFqXvVkb4+D1Xnlgr+R2Q8IGVtoMdl0S243LpJXz2UdanKLc4DBk3bcqpZh5BOl+yMplKClDV35cx1ARqgljeoS2eYaLwQrOOv1xSlAljXIDsrOxv+3LOns6N5tTj/IQ67+pbTsHG/I5ZdCLaXbse1A7WZ3xoI07z9vm4i7nNY1TKnex1spx3IfTyiRsajmFz4AunBJEntthsHIauXdE9iZAZVGG7ONDWbwLYoi3nu+Wm80/pZGkmBLCg3PBoZEdLqS7k+IDnaHrtpwtBTfPLkhsd+bpojGf2u3Aqj54gNo1KJmOqQrAu4vmO4mCwjnGWzA3b6IAqRvB6TstGTKifowGJ7/V/vgxBwo0M7LoLI7lxeOon3AD4sZMr7jgs8lDO4TKMaxG8hZQQEHb2d4Cmh7MZIl63k5LYz6UNkKypP6qoxE48RNEKMUW0nrPRsXd/4XtK/c+1qIKgx7XQwiGvD/vTKH16ifBN7AkhvhPGhcCZCFmRIG4H/VXpWvmR5FvC+oi3KiOmc+iNi48/3BnR2RYmIyiUZRyLs31aONCgW5WUTN5s2bvpa68+HKt6kLKXOVpgu2g1GdXA1V7/9tWzWsUIy88/CzsmRlZk3NA3kYtqtLhQWcPGN9xgsDxd95AsvBmyb6VFfSadef8IG2G3H8zOWRr0k3vHe1IA/o+GKZZ8xpvqZ8Q/7c54ggibPjl2IPO7Zfh6tKoX+wwvRvl8h44esNwTu09LFN/LS1iPg7H2rd6dbQdFfD/CnNPbra6bSBYtH0siOKV1SVZovpJ5yV564YJicj+tzJtl8yJ8a2SL6bqnyXKkx51+BjWnjRBLTz/OjJOx/S4hqITWHk3GbDMchAJVZiBIf6tk+SdbrPtoz9BEwv9mADQ7fAV6qRmuoCSzpbxjj6GwjYrm/Dg/0sj40cBTrGG0GirdWX1zAxp/DTz0mpcroRR/7Kju7nPwiFLH51+jKPVjV9X1iO452bkY34waGCvxnKGR0N+Zr9fNb0L04QaDpj69XCHkwd6S6AJBGQwpXoRa4VyhEcQxTMwlzv5GBQKjPMnbDq9N0i6WGEx8Mdh2hr3L6B+qLbyq1WEIpNPsXB8aBZGRS7lgP+ujwKiI/EdapdNEEqlJAPvkMj8i1oF4XWbN/bU5IRC7THtnAAiubtM5sLZRaBCTvLlQdlXSsjDu2jXReYxCeM6gdMWZXi0TmPITZrjjYQyYuSiPqbmjjHEj3wYa17W732CG7KwVXzbifpTyqFaRnRzKd29jDW9hIV1fAVYfBbc1XU098PL+FBajwsVjAmmtB9A6jbjFzjt60zEpFB8ThC4NA/YohgPhZCTKkjsg9oIqkQJSTsKIMNf98GNqveGw5W/TDje9od8Iib99VX3nwCTbOJ4RdFCQ8ApTGSRnp0wfy0Dd82gFHYB3+mE/XeFn65jrdDELrahw53m4xoC6CEI55FZEa3W5Tz06h83eVH8bQ6WTt3hlVeKWcQvEFRndqSDmPuVnL+dzoDSMf8MgEI1w086e1yV3MBkgidNsgHbRt8cBr7VEZVEZ2s6mKg2Ag2U9Df4yKEWEKMRHazTZ6WdSCE/us2/eFr5Ji+cmWBYpbldeYAF5dOewSsIw6Xst1YgNKBPpYgb77o1GcVSq7rWeL2byTAptRz+85t3OWz2rhCr4KhteU4R7JNcGvUg5G8sPcz2iEPD/0zg9tq5Rz/3TJTY5TPB4geSgtPQhdOUMWqXleTq3RWHJcJd++wOwTlf8fUtslwmeKiiFgNQUqZa36oiPFdn+WhiRK61Hc8e+Idsh1qGXE6tbOnVvLzlJpLdAPg07R4MZmVgsXcdcXksZ8lCDlbGajKr4hwHcDlnfMZ35kLm09EkD3z6XRCm+QHhAIeoEpp49SmNpDQ3/su4OkHwjK6sT3nIU11rV4Mytwwe8Bizdcmne5U/YXsRc3Q1Yh1vCvuFVP4jozTEwPqduAs4z6wXsqog/HGXucFLKFEa5fLXkKKqaQhkiT93M3/+GZIYwnSoo6tg8dXM3sVsT/TiuOnAMC60oTAdIT5Pzysx2ph8Xfph6ShMCEKvE03Tztv6BEb5ZvVsAkqkjOjC/2NDI72DVuP4lfpEyRl1dcLsLYcsAcr9qto6+F4/EtZ/36pX8tWOpjVVXv5Ped7T4rD4Y4/qnwjh2iUSUNP3kjgIRoHzS/21pdai+FFNd6rCdsKNNsx+b8Mpvx95bWAmmfOACXmbJpW0NbUzLh7MCikwd3YnChUnvTJof1/N4UFPBfBRePWgHHD0qDB6xBpKFu4lnZtmH4IjJ9ZBHBWyF/S1Jx8STr51vXORALENQLhu5S6mivcvwwKY7vDv2Qwn+g0UtXNEOJTocpLDX+c9LkgjnaPF0hpLV3SwfTUm5c4Zdf1e1yIMukSaKQIVL2Kdn64kOi2MprzNG6Aj6lbhIwi5/Y81jxP7oAa34/RNVnDZDMiljqL78ZxkVHr27lloL+8lqRNvNdAVH9JUkXPrkxeC+9emm3ovfFVOb+lTMDcHmf9GXsYMerY+/0I8ziGmWxb0sscM8AWciF2cEaMYH3upeDWyFNWrPhz50pJiCoKENLI7k0TqSMKhA0arffKm74spPrBm21Pq6DJJJAELzwGEDj9v/1AsQzFF2J6TAtWalk2aXmcWl6eyiS7Xkn5kaY7VU8ui5lyXWqvj7PH7jEUAf5CfuTMJhcX+CQDKy1BXGSJopNv5pBnNeFEzGrq4s2ODrTH6VeY5a94kt7tswhRDiMVImNvN7k7pd+7yu9qa80OgLnyPpreHu/6etksCWtl8Sa32vUmILzc+odlq3GReyW3r4fUnZQ7wn4NimppJFE1vbDepknBZIW5lGDYrMVJXcgpb1k1Ra3E3U+0+MaIDkabNK0XDaZP2501Qb2LSuQrK9sxYOUx7YyQ/52GUEsFG2FvKfhIVPBsBHJilhTECozLmVoBYzQVwvJ5lUs+LbIYx7WKBa4SxEVleLLd/NLZVBFrsQj/+0ObmQS2UbT8bJudBSSsb5Q6ZHkK73kw+uAgz9YYWy4AGUO6MTWSiBsrnzYrsltARrUFPVsreTsNu4Bguxi02JxhNFnpTsvFmtSj0InwOol03VAtF3uHswGUkaNUFlemF4wbezVSQ9o1SGGLDQmFoQIkrAd7GXJXGgCGbph9Tx4b1bQCZ7df90IQfpA6C+zr7ZGojcJ77hukZ4srDWtEazT7JsqPR3AEj8Jm3RiRK1gXiOAIo3ieX/kaMMFfaMeJaN4lLrrlII/WKSq8S9WOR7CpnNsAiLS3rT20a1qybJKvPCPptpUQhKyDC2MzWqe0napBmURugDAwuMna8yaBMpo55+U9HKwUonPhPZz4d4tLakGPVSNn9c5XuNcLIE9/azUxssRboCSBrRfyL9/ZHemmAsdxiTRV9Sh30kjZaqlxKfXitWRDfbgleMe+CkTovGP5UiOMp9vrjw+OrS6CvjAuF2/LLAEXLc4EA9dLOVZkBGf34XMxAWAujsD/5skIOdoxSiK+L/JXNcOBMmQ0InIW0j3DxDFbLFQMNiq2dmtvz7labMq+QSx9H3UjCRN6/+FR94VHL5YwyLRbKPx979mq7OzO6wmIKcBoaeYjwIR+V14hGhr6sEjekYqtladUmbxefmLJC7z0xyAuVwoJsVSc6jpHKdUHR2rtex/gfJIKajNY8q6l5rr70uw0w80QMz8vp7SwkrWCiLqNcFNnyLRj/CMbQHuYaVqx2DORTPBFP/9euLDY8iz3eF1AEoiPo2UaV8DM5vPLtJZt/Tz+uHv+4rI4xQCwXz1CLW1bX50WPDcOfOVzo8vvxGx8vFfyBZmTs/i85DclgLUd4lrLjtbbK/FeIVPbCfr2U7MsUdr8KyGzWHWBe8UNsv0Ta9ZF8Ri/FIbKXR3wX8CwTokwp1i+WTLP6IRVkOQmz6ok5pIOVU8rE6H7l2aFMXJcMtUC22LaDK+QhtgguQd5pj194Z1zhKi+kRzgREraWjvNUBX6LrI0kF3zeiEnZeTsga+WYqiBnTJ1qY+4upb6yp97BiH+b0eh+Hzz8crpaomRWnx+gLA7oPaKhy147kYUZzNLx9D4/pOV4FpbwTyaVBX1ED7PV5EDU4uJpx7YbexVeIS4wWgHX/vJQzJH1yECvyNyRFqXGoCcFZLHBvYCIYc1iNdrWcoUa0cnKbuJ0zVmZ7TB/xWmTqwYhapm0OnqN8IQtcl9YBzGM70eVv8ZPRc0F5FmplaVYzyMeIvIEWuBtEJp+BaNsOqnIwDIysGO9EX9zFexekWZc1GZ0IeC/ZJguYwsKrLZ1BmAfakO2ofkP/1+PeG5uO8hd3P38ohgsEVFcXmmJcuQsizUqRZOkfxz3sOBf7afXYq0WBhlhYzrkA5yCxomqphtxheB97XEBnHzqJO29DvZBgDvOw++8/h6YjTjqD2wAQVCCKHX87VjBY1Ij+L8a6+CNE5usDf4w3VJBD4ulL6sxsj7fzdq5apfv/Kx95zLL3X1hqdqcPLCP1CZp+S8Fe1grKmYSwjsL93NGim1wkLLklA3EtFOF5q4Kc8H+Yjp/KnNpmdRFCE4/xKK4QEOgcOQ8zivcPbt2/yH+qsDiFrJaBiTE9tpZu2++6su/lsAXWMc4iEpvCvS9CgSr72PWz2nSQzcGmr4FeTc6gOuXxQ7Ae8juqR6C/L0aw0AxfihFBEJmvGTbbcW2tzJST4OftchTUBUd3l9EE2yjnhs/0AAf7qpKfPk8KZEbrRKMjFgUhyB0TOvtQiKGiutopdlgXtd8gL1tT74SOe8/Ybx2nPKGdjCubU/ylHTQ8DrLtu3liunM1OkM3zLkd+TtvZ1cbY4Uz9lImc/mbHBbL3Xkwj/P4ccXR5BlDCfyHKf8S5lzUXRNXlkMw4YjOeBonsQioYS11JQJPTdnhOBxQBRpnEaIOoXgxtk5ZIFBBTU+826JdZ6cgRNOR/bd4ZwICeFlSDH4Ahz32V7lHbETZNWzGAEMpGja9JiNSV3Kt68hbHr/YXMAKiSL1sUwfDyaL+sJuMBDXS/0eBJke+N5KJxZ3tNjzU6ukcTOM/FTAfnW7iBCcNf3VfxcrhHvTL7jD4nVuZKQeHpjoipbS8S3yxlNHZ64nNHlbMJDwDQYHb6W/dwAsYqcwYuqjU36FBbMkhGJC5x2Ky+oPn/IGyjWMgCX9kPrckCAA/syseVblT+lqAAolJYG4lIf7xCzzuczYUPKChrjmdzROLCNIsvPh2RAdXk1LQTg8/AsAPFyIlR6riMNMRtgVBhlh3crqCjPzcw7fumP7bozVUOXbihjUalmu1G+Y4SB/p8iDuX8DyfYSm4MzViqxnN5e2g1QG36aZTMKemwfB4n2iG7QjOSRAzh0wATF9srfzPQqXwOOoXZpG+qhm4j2rRiKOkQJpWIUJJ3KUOUuKwD+fu8HEYuThnqyoX++uKlBkZxc+tyBI/5dzdG8R0/Nc1bSNQIeCGaRNSyY+7aUxl0Pj2jeH1aExG1UjDq3svRj+o6tSeV0OBUxuF+60bg3/vo1Eklr6t4tVWAorjl5Z8cGQmWzo19vd9l3qC10TShXbIFgclYv5P9/36YEotTb1nkGo3tcBela5SHH29ZsXGqMtJej+dCa+HwruLplOdh5gT/lPFXwxGTKsWNFP/MUu74Uq4r6x4ywpEVedHEX4A7EwIBYJaeHJgO69xNo7VEfZVVUzl6JRrRl/Bg6425uTRcJX+nJcQX8Bz6+LQwqKvZmDLogarMzfNlZEDROK+Zg9QvboeCA/LTXhpWW5Y8KwfEMrSJ4zKVmRKDmXOyo0bGtiz9wz8jWmpjhPkbqvIA0pZHGhI5DI7OFWslDhe165m+4Z7Bbsc0Zrt/RX4XRqe9RC+1lJzh1pISUFbVGMpkbwjjBpXXgXfxUcObAXBK0J3UNHnPvkIof2tqKbl7XXoOJkdl0ZwaSBDG69ps7FoDfYLDszCgioWZWr66mvJYw8v8ysFgkmb1HmJat64B6vlt0aaqufIyInIgVBSvkPvfTXRHJKHIoJCA/pvxYzkeIQItxYlesad68lcJqqx+Jl29DU78g2am/zZ9H7EcAswHXVPUYvSSfu0xyahVsIK0pktMhlrXSgP8aPte0+LXudSrJPIwsav9Ccg9V29hZiIiDE8HMTEPuv1QoR7Obv0kyXN0WLiCUaMbjEgFfiiSE4b1GkR/rEYqmunHahrPAI1KHUCtwXLsrPt9pj29QNwpt4dOul79zw8DlKCw4w+PHQmm1ek12crsPL9p3aC1V4nOnowPh7A0sWq4CkKuRbM3wH6h52ynoVpuaxr9dS0mV6S8wF5z2/Trd4jS9+ku7V69S0ky2AjGptv6mv96xgZ4ZTyjMx6eVTVU29fCTa5h0WIb2L8+lzHtj6awQTBFg8I4yIzHvXZCMCphlKwU10VxZZhtAmSAJHLyUZYNvAt7BlvDjUdDwNEAK5xXOB/eut/Ax52ULhLM0P3YvLlUxfPCD6pSTHchBINSBrjhPzzDZIZslNw5qFtxC+AC4sb2ygeTrRTbMCc3wwfu3dbM7qW7OWcG4ervEf1PbxF2COaCBWsblzTOSe+6ZEPG7Uu7TNNpPmAjJL//+8bGGSKXX4YvW+pP9LLnEnEW5P/XR8QJMt1clxM0lvpqpreM5zHLqE3rzCfoCbrX0HCm3MYMpFoAcIXAJCPfQyW7fnbEZS/ITSv2A13QggWGSRJVl5XlnwGESJ5nv9XSAG0rLRwBY2TSpEtkDdz41eLv4Ckk4SskfpQ1v9Rch85AMVKvCnTg/8ArpLVzDnaQ/TfSJprD9mypRxrNlyxW0T3ZIdrmstW84tbX8nefEY0sPFgP8m+tsxIkysCacOk2NAwzx1b0OKpSQN0AATq0q9GKWVJyRUyKHDTqYnaExeD++umF38bqMk45ggHJJBh6dfT857/yKEkbpGjWnQ1CFXJ8PH2aEr+R2XHCK6vS0+BD5Z/Dc0R9N/G9v0lOUwmOCm8eyye8fhfm8Yp2ZvxxP3cK/6xYN+ozwI8gWgDr1nCwowIYluh1Rm5hsfv5XcI2aDLMkbcY4m/AhzdtWjL2EWdDBF6+H/2nmvrVO/20X+zd9J1le0HqBKyJuDNKVfJZZg7EyYPmTpwNJ879utj5cWj5M25tmsqg8E6GjHFW7jQUkGDiOUPSCEBdaT0R4zttxzWEdExqN9yb7Opw0rwlkd68ToVUs8fz2GQEAZK95/N2UzhbNxAxDDs5wkiIvmYRj8hCLz6e7+lCAzxVHzvvIbZqxJG+IJlDPr8UJ8NA5/GOjqNTWU+eV+8GVkwYCfJKg3sccyOtQlel72g/Ak4VdsaDvYh33+HizJJioH685CPa4TBDcmRQZ0f/xmbJ9CMiPXyEG8yV+pir/bS/rQSEietNcan6F06MmI1wpXPyJQmbIyBpu36+hrbg3LZWa7fxbrGlbcEwZJ6fd20VUuwCi+5S8+j7T4EvENGOJrsAdhj8LBlry3sjMYOsYlHK2xXrNcROIC0I3uDsPJhje5Eae/QzRZHxo/KE7hNed0Iff9jK8GS8VGaXlq8pG8SCjSDOIBybak7Rp0Dy2Z+9n/yAYayzYk2FbXRODy09QYVny2wUShkGP+DVM8a9ASIEb9esjAfskTv8+jk32OF9jDLOh45SEmN68VOvn9M528nCW2BfTy5Yaf+H3At4rgxyVjzMSd5tT9YasiF+sg6cRPWa1O1DzzbnrL/JUIqJ1ITiBEha6qa3vWA0YXOc7geUmLVfxpL/ICn/BOUx1bH9cXvGvLFXbk4yoL21Y69WTZuJp2EvFA4PFwWRrdbjS0GSjD7IwsqWD5Id22pecBRyXUSJZNuey+Ca18SN5dIQ9gIhRf2sxsQFOcvWB/dVnZLXryKx3It8UGAR/DmOdCy368hDg7M2ybSdK1WGmXokdl1vWBC4MYvEqgpuQPtouTXW+jvp/c3W2vApKWMUdofL3wUkJO+i6I0qLTY7bwN7/dqw1tIu0LRURDAo9mTlaHmxxbxVJlEwUTfVjsSUWQDSd2T+/No/90FioGI5KbupE/l2qJ775Vi5fkOa8mEjwg+p6Awc4o+VV6rXUJkBcjekgcieC4YLdoe7rBTPsjXBMee/nKgniI3O+uPlRaB9DnC5q6j56DETbpgs35y2goUadni6o7P9gEGgYIj2DyIiv4SWBjWwGxVtoFdNEem3RM9fB3UAPg1gHbsOi62Zlq1mPJZz27SSZ83HmLxOz3p/rUXtqAdXhwpprQ6NhTTN1aWWZl5hO5dNAc/CAMc4cbqi/MiM6iy85vOuoQ8AkfdyiRUxRMb/npX8G00naEnNxBj9LalPH/6MRVqWXphplTmvifaXwCgBoFC7A9PK7eO5KwLgFKbJk6d0b6h/m7PizKAh07Ayz87KeyXWrfKhRWPqY4mepI9XT/KOZuTgAHPnpDIvfU3w9oAxls5wKTsXJx9zsZ7ARBNhn/vl1MibIfUNnlI8T39t1Br2AcwubkMM7b4kIP0dlG18SZ8Hb38HMepZmSShZuDjhHN8kZ7BkR7NyDIzo4Mt2pZoy4Iz7dKcdAZZy91xEP5T60AP+ZmV2TDcu1L7hKVKL5XC3NBMYa82KYVd9/NNCig/OjENNc+oNvaTBG7jSEBW7FG3PxKs0CQaHXl/0vQf6FYOtduNt3bznBZ2yG+O2mIF8Gx5YD8dxkrRVixk/qVo9Uqx0EeU1zjeKhDb4RBc0I2r2Iajauj5SOFQ49CtgRnbCkb+Gqtg8T009XmeLYTU5+NEvLVgsCQj408/3vldPdi6dvmhJMUAm/i3Kfq8zKaklB7ovZP0X6jY6clLuJw5oxx7MXL1a5vpGhJQSsATbUsvQ53VndufmA7ZlpNEAN5mMmFy0vcMtWgL5dlafb0jDzFb7wK3Nq7PtdTTePfQxn+2YVfqnzITYyOUzt6dXicuFVCC9G0s/jLE1YAmXqpW6zjK04PQPwrh6tNhGz/Ah70tPyU2BgxM1FyhnjnpIV50WsR7z6t6j4t0yilBJZtIGiZxioVcjvBrCUbgFbk3IV3Vpxy4IZURRoZ0kkCJXYFF7gYLQ8NyyE1jVGBiQo9qkKLDDmbFi6n8dvvGIXmBJUCCxtmhwN4xn0YVYsqkBsipu7wX93F2A+g1IPhn044PTc+IUrEPsFGevCP56sWx1uGilhwbI9gpWLQOBcus8KL/Ez1Z5R8Aa9UIMjWM1w3CZJzcNCdOTzxSPfJ+s9mUmCLRYidZLQMt8DOfhJ96PALnwhOS8ifWTOjvn8nEFXi8xBRF+FbHJREd6ljJebimS9AIi3MRgtKrL1XEzY9TLoYynlO/YN9ijv0FCiTvLPTYztZyCtdJMXa24tRCrAJduhxAiZWUnDQwj+8Wr4cURNO+pDV8AtYIpFLRD4sgjehKJEzseOgN87+YUDh0I66r7ghAywwUx/MW2rSkQSBk24kaUlUmfYG8kKwAwYGf2cMMeTT79BAHax1cXN3uE2ZWr6QpxeikMEYlmZO9dtguErZuicakGkr5zNLo/1DV12lmUotpA12Kyw4gxe40A8IoDTd2y5Fn3fqPEfKvDMwfTk+wp2OzQEfR7wmud1n+TXkGTwioP2e/dcOghXAu7HmW8w37j88pLWIFs6SZNMVHCDoCGiyIdJX4bSOipYeyPR4t8KL+cbegAJZ1VPYJfrKhW5RoVk79Da9njydPfgej1JHz4Jxm80YNvUzpnHRB4b00RUxpG5gq64d8LbGS04I8JwKI1ox3+FsIHpM7KkpFpRehrlIQiVDac7nzjk8Ov5uYsGewSiefs2LurlNmm4OqtarJuJj7joNMknDWMWauqB+8TyqhpmhFYpCV1yjc2SqmSdzSYO2cEr5qmGwogo93iMy7s68ju0SCeE11QEbutzL6Mbflp3GL370O5RAykcZ3KG9xgbxKwiUnWmcc378atUSv+450Wj447M/8A6UkJrVquZvIvxVDdshRwowQv/qGHng6qM7zXNrbpSEYJwiszR5iG/HeCLdv4XengviNWa0UXuWrZLip8/C44v/i6A3iB65JH2OKMBPJC90IZ8tAPxQCa3o+K9hETr76ab7J+1CYkJS1iV8JO+eSpNBh0PdlxMpdpdioOqpkejMpTNFx/oxWLxMEjsi99d5L3RvUtz8j4IJsA/Bk8mTzQtJvBeFKmuYRy6t0sXejgw/PJxFLT1nk3dG6K1BOQdrqRphRzSQjsSlnotMMzx4ocpP1zCoxxYzODcanxeaq/G2Sc27Z9qAXSs7YDBNa3RRhmJwY42HV5zD8xvFlYl/mmPUf7wx4QQPHfvTxuDW3hAbnLmiIYtYnMGcvrfBJL/znI5JhDLoMFBBDleM+CneyyHH+NlrG6GUF1nE2tjuIXbBA4h3B+Z4J3eeQnUX1V/ZNUlmLlzc90EaU8dI336PYYSCpf8ZpDLqhXF9AFoyAfl26wJmsT1+gOLtfNZnxknprhyHz3b6V7qym7Lax62KUWnuZ84uI7ekdCVXMq55m+geKfsz1scX+CgPnZlCShntvQtmG0vDeyy5bG0wbk7dHz7kOd1aTEKB4NbZRJmWzf2zI7u5yhgRH3lFHXmoh+LoFJI3pJ45v8mazadu1LL7jYpbXzvmLzNTUyA7bLw+cIcCExfjZJ7QjES0XHIfZ6Ysuf60DJhJEk/pGrGJ/k29qHMw6q4HMowupxxbjCNLQ6jwJW7Qq5nRdYymVqug0+f4FtV7Hif52WE6NPZvVmx8zZ1in6e5szWJQUWVCsRnHzei57uYh9u7neZ/xrtPueMF+5XWEHJWdRNnH+X+QfY5BbuZija7jZr97HFq0ivT7bIeZ8Gysb+WFz2EyQAbWM1gr3GBSbQNzGcciZwXoDRpa9KjqHmtfLhCH40sHyGi/8kMCZpf5Yq/S8zrTXOFrnjC7X5FjvJ94JraN30r7tR+GyMkt8ovAmfZjNh2yLnpCFXF4y7ZyVXi/IkbBtWxYxT5HvdkJjL02oRcCu8z1YA9WL3KGFuiUhtgaMLbcirKM7vp/CPvc2UPsCFr/dMTZd3B+OdlIyeDWMB099EHvSP+DQy199iW6fuMiYVAwC1xrHON4f4PUkE1VAhf53wH3BhRxmpKMhS9WJr1mEIhwklp9HTcp+GrefHqGePqZYomRnHltnU9r3UcEyIaBNdvKmWIm/f/2JA2EZA4BrcyVaCwSC2sU+kMm+DcRfd41cF5h4ywHIMhxwq3vA/4PwWMZo3iTNM1xc5mLItajk3ODe7aiVX9MHhxD5ewanpsQesbwsN7StyJZ+X8wROMA+qQ8PscCBT/0kbYDowvIv5Ft0khJDw265MYHdUGC4DKxcM9qpK1rHm//BaRYk7lymanE+CH8GRgxhbqxIJiu2iLKDMmJs45Ab8W8fyH6iW+8JGUpL8wnuKFUVh92WeyQWsC2Y2AyFmJUKZ4Qycrlme409LCmgBDTa/jO5mOfWM3HNLaCa5rQ6y3CQnBGGC9Lo+6BTSksWNEnuxfMgNc8L+MQXXEBo6+JVnLS8+tFNJbOuOGsAehlvEOes5Z3Ew/Jjntpa22EEF2mJJe7fSGTgWMFrzOCpmTdNRTrIxjoqnsabp//lkKDwf5yQ1uloDTud8srrL3dGRCa/AQgCuGwT2GGkFoHb7kAisG21iSIDfruCFr4OHwTtkwHBrQlgu7dGrO4HDbHWktEMRoLpTISlWjxyne8xxD31kptR7RYCMacY6DgMma95PdxMfbh4XWGDNzwOnIy8vfgvWLzViY3EcQbbFi0tp82u99C+zwdNfsLSgF/9iXxM+FkrRTpq58CMBudxXWRNF25OtplMswmXwKGwYBagUbTzfgdjpfAcEbePuvT6lo+W1ZjV+GyURXDZU+NPdSrM+IODxdFX9yCWgxo2WzQ0wHc3DglRE47R860pLWBXRShve1ACg94jOYcovUZaIGp2UqACeYhO6CwDCZ9nqQNIaQWUyhhpaW6yFpcAuDhA1mxEX799uLAh2VdIS5Lc9xrEBfMusvQIRGD9Y2ttJQ9M10VIpIuz9VjBOmocMDAr+C7DLSr48oqRBFk+2qe3t4HYGQAl9XZfyKvjYaYt7XoMOXExomgPg0RImIo7IzS5qaNJSTPeoorFK5AQcOvLphaBJ+8+A8ONZl59KOZttl2H+yx5r1x30CxrODRQRmM4ZnHSc7xr/ocR11MVpBvk5d+Dl76ru8ACA485E3+YvsyzHf1sGdd3R1Pt35/bRGGDenv+py9XNlwARHfrSPkehvGYnKK6baC0SumGJT2/CVzfR6z7jhLzvM6V/FyHI13jn74BUQc1AvEF+MAGY1GeqaK+ClMHXOsuR1tJVYJLc1RVKKjLY8i0mrwlHOMMVR0qaoFr4oF4IuS+1JeRtKuNRuikHwU7fQZwlf4q4WdxvqG1gxx2EPXDYQZ4Yb1UIf/WtWQ+ByQLjCvHHKf0h67422la4zpxozV3xme+aJpaO6+sN13cvNA6Yu0e7eoBBbOjqWB2kwkyzQAzyqRDGi82K4Aa9VfRgE2amV4im6Pnwqj9gPrFNHhsLJg7X0gb/zFKEAWhGDvATOLcH/LlS2YUFRo46qgumlLOJ5WEmqNNfYpSJSuqapHNZpa5uKcD6Xc8p9F0HoBjneKgf+ORq86LR8P8fAtme2cgIdLKGNlps3WCTqJekynzS3ARWM5k+VPDzQ5xofWWLJqmQv+7ToR6L87zGT6dSP8QrkpWSnyXua5ms3ZiGUJ+pAyS0/IKCbEXZ+2DE5vCVla3HHKp/1Oan4b5eim8haiiVqb05qP3afWNJ4KwCdj9TUl4d5pRnT6zY6ybgsOEi6LH/GkQmiYuONCGqdxkh9HEec74z3QiUyg8V7IgnNxJqBUlB3W3EYiBP7tniS9nl6oiTmSLSOK5bVU85XurZ/T2xG0/S9ImkH7HQNubqPCcislePYNf3jj39J2CBf3BkIqI0TEkaWIDrCxQQ6czaHPhogrCYBxqXcr+rQ+IMyc9uIu14BbwS+LVHiGLx+UL9MmQezTEoECx9CUepZ99SQUKmbET2PldoIvEYBzVnyzi6z4xjr5l7nFKRnlVGtteg7zXqVJDx2fiHuI4lUpwF6yuVnFbhccX9cIUDoJQ7bjxhyAIQdskINkFPp9gBpLZwzH49ZXzb1bm4AJzC0jwmAGjy53l9Mw9CFMYMjn45dkAlggGAUFqzuwHFJHjEbdNPQWKLR9n85wBG5A0jbH03j+xOid7h+cyAxMufKi6ubjIlNQDVY5RF0F7a9bYA6KV4ttXoEn09zUEk5eMUrsbf9sI/ZLr1hWU3nhmQXI1yGDoBYwGl2R2uTrFvtGE8kPugm7/PLySiX9tGA7UlHgDGlnRS7+6HnTYgWosdT7Go9YahcAdpp++FK8pCLb4s+2aQ8Q9mDF31yEtrkL0DOWr/YKy0qXFWKlY4ijn8Z6xT1O04/2mstxkVAZ9A5M7r53nOrGOZJOJJyLTjGjnIoPP78HBD/Y0fCMAHRKuJdk3ClFnhsO3yuLGb6gm/hnUjD8C7gSi7Ax+P+/cAjfM46MVxJpBautRJcbSkZyukbwTuAgLFYM2ZEvkCXNhtI281YBXQtHpGzO+0ZmQmGLqdkMZBI3Qb0xQ1fqMIl8+wh/9S51DBL7HBZIIK/sJMFeIWIxwTn6PD1TxGGFzbEDY5VScokOXI/chmNNkMdXS+ijVrS108m5JmPPOcd+oe3suYKX5VL6Z7ZTNTE/oC2EdSDWtXYugP3CWAp3UIf8aKemJyZTUnrwI3Z1Zszf0d6f1K4mdMDoJCEvVMenvAbGf5FjamqcaXqFCjPqiQkUF5I8JKeVrjHHv6sZxZ29Z+e/uVOM9XHi0nFz6gGe9pd4esEG9ueE1HBGD6zX0ARN7GGKX+fVcwxejJQT3S76UkyumWRkKGVZ1puHXJJo3FWHedlt8hxCTw4i3UXY4wlzz98MO6weJZybf2yaQwF9REeL1odTpwifCPM39/p8QNzBVxf+kFVvRz4uXwi0tEkSH5L2sGk2mZEb3Sz5xoKOeqnOSh6VXWdhbUAhS1P3TczGgCz/C6d9RTaod0Il/zQYvVhTqYwflqGrgk7lSMJWBqnjLspMMAJpbRpH1NwW9W3utskA3+23HS+mGcw9Z7XvnDbSmIpfaDSqRtiA0TVp/pSLD8DHFJoBMh/30q9pI6ZpLQI1JKFQT2ATFPIORm4wGl5EZLJxBZA5OTAHoxF6US9L/+QLRl15LVlYGRAWCtFxIxoHzIdr2eqzUaMW66JpgaroZk7GL6mOdDI3U0ZK2F6nnt3wZqBdTORJcZYIL6xtB/LtffgZqdy2vE6WFSV61kPTguO69MgWhk741lOgBb35OinJ1DRH39XyPwupGt/O6e7sAl4y/8F/5JmJqVzYiFd378DNmLSF+wd2MY6+vXrU4ly+PL0W3SYd/AW8ckMZBdisHGU0aSCoOgcwfgD9nCfe4o+Vrq+rV1H05Nl3YqwEQNpfc1m4ilJsr0xCb9xftxHp2aeytBPgx9UZvcDkbRgSOwqCGGDLMIyTtvVB9k4O+1RhR6wJ3Vo8r0LSkIal4OssrmV1jtZYTH8sWR/z6/fC8AD65hXqBwooX5Sp9+oUE4USbdupkR01gA2y53VDXfHQkKBz46SW0yCprVmEUiqVWtX5ma7algWMEe/K+BbIoeNQkesAdNSbmchUDirKtGZggAw6uyzndpiDzUs6H/2lQiCn/9b8kLYgmec8k4/pdbefcX/eSErKzMm9QvPIjl5v4643QJia3qLN6O/eC1TVPe9bK11rB1OwZOcz4q6exsSMUL5vusvY/QX8LHMO50ctmGHLvhG+VW9zQsxmNekGOJeOGUjZ34HJWoI/guvWgC2/GeOXGMxqrY15i5H/sKZfZ7DF3doKry1kKnNLDJb4pmS8fsk111hjJjkUmrwd0qJEhd/0UA4RXTg22uYZ/tn7wuDkba/sBJ22p0x8h5ULDa+2as4wlpvGptOZztcTMBdc2kfpwqVO5tTtW9UzIEyAW5ufMWlP7JWd37NwadoH89f8aEqRi6xEzenCcg3K4VipxQz7aRR/qQjONyMB0T9iMYIq0lXWdyWyugKDDolHjhUXHAsGnoiJQGP2pyLEMLMUPhfLY8bml9ENE3eawmlVIONLvuuUSaByhNt9kr+AXVMV5HE8Uyy8xPfrdfE6vEvupAHTNhjFrXud1S1lah7oBmAsPUQRlkYr09H5H+1h6L71CmDY5mOaQZ1jBzyOFF7F5NlnUrHV9eoVjlMonkG2YK0z84g0fQO9ZazhoJ0c6jzeUif9yeluxhMuiCNynCqSwdN98tJg94JkY5dUgmpm3z7LTvMIPx0FlTY92CvTcvYZMVsxNBuS9g3zaK1DM6EaWk8ouYa22oai4iuOKF/jn+uFdTXDApBs5xVLce85VBUQctpLSjHwRwfy9FG8xzE8zo4KshoVorrcWwKG8mgt2zjNRMYR2QqbwusYsTHdLoH6vVnthHA3P1GHYzP0NmjfHrT8JZ8agaq3e3YzVYmQWM9RZWRbelrJMkUR5ek8inUdY2reowKBe9zNeEI2/5c9VkmEV9SqFfC5l9iMWzU/j707rffqlzzTfoMJuJKU96q1Byz8KEwUrvfqaKLAABIlKpsjIZvCgza/rp5ohiwLY+4MUmjq8V9KPm/QKzDrOVaAkQTqh038WQMJa7GvENlRZlge/equixpvudAikZGYOpg0ZxbXOLD8duBP0CChw7gZ4BJ/CpAkP0Mgcrajb/VzFypJZVO+ddhqDjb/owSgsQ60Ja2FdVIFqXfsuorzgcol7/FSHoUuk1qzfD4xe3/ZQ0tJTYjgiOdzIwsY/yZtXqfyqaoAJigM3UJ69uE0+P/387XXBNeFIe/Kms4Ns2LBC2e7ynsS7igb1KY6uO+N/7PtEmjzDRmBCKegMvXPTh5fPTXYXiDrMrZGpT6g4ax0/62yBj5QbR481OwubZrK9JXHrurllf3FYAmQdt/7Zhc8evw1Wj3F2Bk6X3jFBT+8QPL9zvbRT1NhoqXOCRhWf6OsAUoj5Zfswu6aldDKXhtNOJg+VPj/ydMB9an+c5u+C0mWcA9GLkbDIu/6TJVR5Nk7Qo2xa0e0bIb5wP/CY1ALxgifjiwSXlSA46kXLV5OWbObv14ybVBK3TRIUeid96SzeyL0701IAHCXBFMfgiYTwqpmde8e/GiskE573AFUzoqWu3vL4E8Q2tAVrqGpYY5UP7y+srZ3idUCAS0R2d1wmT9LzeKRyuaE6GQksg7T3BUVp2aFB3LEffM/3hvw1ugFwQqEQqNNsytaXyd2O6bePIM3e5aRlDGwF/uzd3/Rjo2aeAN0sUTBRz2qSAZShFZa1iL7y9CHoyuj+xfvJdqVzXDkv+NnKsoopaOTzv2CxAe64i8Ex2ee9T1J05gn7gj267yKwnWqq9IBj4p9tgydRTb1gmFghH5PLDC3edbBgqVfeG+3YMfa+PGfGqRHk8FnVxyI0uJWsmz5tWFpF4BRmRKTUD9uq5E1lu2CJgkNul7e2XX8rLb7Fsvkrh6vj37B2X+g+98cDHJN8X4ote6rgYfZdink/ihE5L9ZevT/PxGaXF3zO2sriQe+fGoNCvgQuFH+VJ9dBl3vMwMYZB9dh4kS0HcjL3T81x+8pYv72QohvhoBIHksNTsXiMGMd79V925+jUmBhj/OVUaUuNLqmFYr1Gebvxi7efk9KW+RfmWwdIYFVv0su1cRBxKZs12V1Z1Jms/P9TMqToyOoJJYE2aotiNdMJLsKpH2Iu72pb+6EU3q4BHzX5MJkh89xrVMNM0KlB86KepSBMWMWGBgx2XWLQ+erRlnBgvPtqGw85BrfJJn/jz96+sPLqKbcrq+KHvgLxPYiHh/eZKQxpuaBqb5PM42B9yb7Wqhn5u9hVzZvPJweCe9VSnvgrxxn5kVm/qCn6XCDwpPSKzsROUNbfsOtzjm25/GnMvYw4vWWPGY3x9mXfgZD73gCl9n8SnF+SwjDoX1LxaBUw+VQCQ/S/KbT4Pan4aiWpSXCnSPLKwvaaFtMFy7ksMghCdcdI95M3rCYFGpOBQgya3OO5QV3h7O3V14B1rhTjKQfcTkjf+84DY9A9gtgWNgYmmGPxlHUlW1xeCBOI+VGWa3zwchW2v9I3gBdJcWc+Z/MMm6csSK1uUmQfDkd0X9GdsliwGJAI28WreOqZMFU6+YwqbnfATD7ifjgEapfU4yRPxm1/ykdfpdMOv5aEVpSwziDCyS7b1ZYP6Na4TGI2Q4abEik2wBWuxbE3E2aG3fG9eUoDXifoKuinhHY5AvY4q+KzF/n80pps819nTDrcuGRDbBhym8f97WtKC6mcPPkgi9w2Wb3dE2Pmkwz3XCcDCyP5PfA+zfLl29h74xqkSf1rs3RtaIB21VOZ0ZieX0DnS9p8MyzXau4ySejUpfKRL6i8eDe5HHiI2h8PIZLP//UHT/TOVRh/E0IbXtVVwaTP3+QVsLbAL+O8+wOMOB1AZFyE+VV3HWwfyb1ViMnlWg9fXPM2dvj/36kZcgcyAEJ8TmSGpnAgY9GEsrtp0EZIm6guu8cvZZ98CB/mnRvuKq87V/Nmupu6QSucMbLqc4AuT8s+gna/Hv0BgCwFyEA446cA+1g+T1KJw9owDIBM+vI2OElokMtNdfH//mhzeeBEaAEDjWbkCUGbm2ujgYbnM1VB9IJsO5S8J4yxJYSq4L72gkPZUty223Z3HdSTzxVLqttrTjN/nqGa6i2FuI0AyArcRjUWtf8cHmxsv8mPo1h7hEAJaTtjOqijk9E7/saZ2qY5m22VMhoqMHc1+Wu5xA/IjH0SmjwOp4QXemszZoRIajn2+0itSHUXmLpBa6YSCCTcLqeRqvwoqElKrdDCitDg2NviSKzp15bYX7gcqBmt3QyWEhgMFSqkamHIYtV+oRa5cOZ/Bt8rBVTbkjzILTTpMgnLzteqdiorHwZBOmjLHTc4Q6O7kvdInV8uAPXs+cIDV18HoHSep5iXxDsVKxcH0BHZuIL8KTOFeSK4HDR4vV1q5nycsXaM1VwTmuu9M6P9ojqoZNsOlRvm8ugd6r/vIeQN/4JyxzK3VIXS1RYOfhBWfO/VWrsexIv2wFVjuxw67N+QCp8EpSWdl0igLmZmwq6pXIoKHzqD+NG6wPvtgxqX4IVYPerqAUF35qnn7R6MDDRp59oiiBkQKFFGPCXM7m3Hqire5xMAC2Jp50zFqatmPf/PttgpLyhPT/UbCYXtWQg5AKpcmvgDshf53ozQ5s1qxZKjePp1R36HZf0AZ0JxyiNzK+FCpPOF2iCKyCpc5xl/KzCrwTj/Zp/U2zjbL/JqZ2C0hHLC+LRSqECKjZffVbMrGbi8wGkAb/tcsPnfYIJhX1J73Bp65ELLlbg2jk6Tm/+TwoUPJfvBTs9T+SnLA7Ri53lS3VZHySiruD8YXELAkruHW8+LME3wItc/YOunu8KWwA99xMCzXjwwIbqIIKEgc1NJmvG/YgPXZ5QFJsYhCtWQKSrVXOudIQftWT4eoFYNntqVSJWD0fbHkblVNtTCJ9y2VHtSZEk+mTEuBwlbW2uoxuEcZy4i9yQtMM/RLHYPlkdOXtE1mIf1Es+2fxP2Z/GhawAHTEt1L/vAPCf9twDlAIZah3UtEk0JV0mCvDxZsMTDC+Mns5VNEvt88XxhpIsgf+QXTppi+qCaz8n7Wd50uOfetTzYHsD+bFVb/8g7lQvSBeBsrVVomOk0rpncaEuUE80jSoqaz3s8DTA7xijsx7oyLCmmKaOaII4O3Qi5TjEkXMGCh8x8zEzpsRGy+CzPoSq/Bl/fZuPRnJ3JFKdexyjtd56aZseRy0iNtttiaRXcspIjws0lIhHJujtIZxe1jNv7RhDnZBjo1WqNE4L8zzOSDYmEizvU3wR3DrsvsxoMWZcMPaUCg6lvDKJN24FYukPIXDA7KN7ynIfJhXior/kfY2Iu7gYNze7clXMQ9XagA99NelOwzPfT5f7/2Az5fQlFbQIwzQXcVEXtIK0mXs1Frrvpj0ECFGMXf9z4Y8GClo9ZXmifusuSxJ5T8l9JF0Zy8bRVJHJ1DV4mCqrivS0k5j8Js8iEod+FAFhASwoPPxMNf2Fo9xdvJMLzzn559WNFykFSiRVWeWXangqLWr++ulRZOIFXW6neD32DpgrSfDkYdWbprYLlhHzRiZop4BLGi6BtgZTXCApbMcIas6UhXEO1b5mZNuth7CQnQZpPQwJb5wLi8+/xiJnS7DogFVv2ac/yhUNIi+urHhM9InRCmrDfx7h344uoJ3dEN5152VnbXYN7hXV4yUWBuRlqoi368ok1l59CGGB3M2rXa2s+lLIumQmzjGaGe5XHer5gKTPqrBnE9x1V8/n/Zd38Hm6/HZxtOECmy3XMIcdkCy9s/hI0/MJ+UDXyvD12DVcFVQy4k3Vmk7ixtVadJu/zzQan+q51aVeN9kYXlgJG9HSHZLOoChQfwyGZ/DLvxCjgLijq7UhRsmdRknYlMTKROSDL3BP3HKNF5z/E4X9IeqoAu1Taqxtm4/e/ViZJe7EiVhBNmpFvzn4eETYhoT+wgbiD7+xcYSWqla8XN9YiLpaVEJ8q1gKsVS8xyy0GU+lxVPmZMAUc3VS8QyaVQeVcCT40Y8A1QoG/ybVHB/5jgKTvkoeKZhGvWe6Da7CJKCSOpywoWSTaRfI5H+foiw8BsNeWfYVuwXotgTAahONM6Y70FESUIWBgRu4JBN7XSLaMCG3Y5/qGNKDkI/8+B+k2n88I1c7FPKn7/Q18m400wANsRi6YwFmtivLJaDQIy0gO2m/OB79Dq+Si5yTGlsNuq/0UE2MX8ZODDpu1gLkExd17bfzoTOyAb6amSDrosbEyaaXWA/h79wzqO7DNooXBrko0tZpt7rMVeg0svJPpdxw0uHoqGFdNj1QrE8TOxW74+mXAp2SOTThCVtytWutWaRjtX0CfIUTUblvwwRfr/UKpXdDu0iW+viUL8StSh5w9vDFfJq6FdPUdsrcweRZdAq5p1wCLQ9F6Vbon7YCwhS7mWSYKG9jWMYKYLnElg+4x/m2hQlDV3yn7/GHmhltWyYiOTqy5SVP48qFpm+gWFCOVzUEW6XFy/vWla0h1X721U8r+2oLv9rsu6lXwnbhh/7jaylhxXczh0y5p5lhJAwPG/Yl0NwVuCPQPR50ZxDYDBcM8SU8kyuzic1q75FTTs/I9iLr8KRrGehdgtWrqhXC0oWyrlR5qyP8dsW9bNOl2HkrBLsFv9xlxwo+aOPncH8MpkFD4vYYoMUXAFk+JIO/GYXsX1oD+IxKDzTlWLs5IDW/f8RJECga96nm/4JvdnSqvMYYO9K9sUhB0CfNbNiLPPJcfKQ971q9d4L5yuNpg84J/0/CP/V2EaD+1WzTd8ZBi3MeoY7IBGUZND8jKMRGE95mrA5gvWMJK6heez5aba5icEvkEvGydgEWtX5lt3z9FZkd49HNsolfHJknrZB3YPChO18ZIZYTqeEQOsKvSQnldvizRz3a85XYnCA6bqvXbiD3Z88vXoF9cjqxm93OP9alNRrRKo+B8g9dLZjiCYrJqDzMR/jsd+jYgnRS6NncH5YTZM9P6QrvApC/rIZnWmA+MV3DSieA46jJnNt3AlzR3tbq42d4t0c+WHTAA9QCZubpgpr8ceUUqMYEpDKZeUnJenlIq1EK2dx7oYLzAibfItp4rtB/q5FNhWgQX7DNVYMHWTrrln74bTgwnVDJUAkT352e/ihLxJ6eLFGehBICV3hcqrHKMaew3hW5VC9RV1kbttBy+XOsGAU9Y0K16rU7a9zKuURPEip/ZzBvdoZszEXIeRB0j2tLiQduD6weKzIF9KLZWuEPjm/cTKhVEa9bYzy71/mHYlvHO4DK0UY/kC9s8f3sz0jTlVviwmV2ONie7TCntxFxC02zF9atpTZQNl8SuYCMtTViOxiOaXVXl/G3xnAl7g7j22m8ehgS9n75EQ7S10YS+r6xc23reIFoRHEjGf78sgXaRCQwa11yUXkHsqRJ0Xzl1+jh/ekxXjYyFWfhaVYkRuZN3fBeo1qz2QYZd6LzyveqkiZ5puMChujwnCb8IM0UcHu8++sP1O1IMlivHeeE0lKBQeeNAFEUfVtNCugwbUdf2XNpxk4nov7RQ5QQu5uppCFRZi9AzE249c5Odat21S15lMTZA+vIOdLBjRVm7m9v8aoc0ZIYlN4HlFkekHj5hj9oT+Uqh8htTQ4SJtLaUhQWAwTq6TEhp9QsZf/fPYc1y6w6Wobx+VstHBTRyaMWgp1MXLhRdK5XM47VBx6HINAc1iIUpHgLnMjq+CyFgU/d69KlZXvGFXVRvYyZ8q7qNN9IsZ0wofl58ZxwLRUvAP540iANXvVvaCJm0pIEJdMQwul1zeTcBmrz87TQXrDQUm3vBYSp1SDUkqwD0KvKcerGHcAdR5B++mFDBpmkyANmlGYCI5ycHN2ynOrLaKKHiCNmNO87oe4t653KX6NEYY7mLq4AukizCBo6tfXaB64vAQOt2WTbJCeJWutjXDi6hzRH5znIUkKv2/4zHMiKyPnafPkzx8sncbwJyhyQplqR5P9Jz63knU0q/99oEGGVJKPsV/KvFz5Au5BbaAwJ2ul4ZnI96ACBkbRWRTfolnfWANj5ZocnBf0xiPixDqh2U8TlG27ijhfjfe+b+TPe7TyuPjQ6/h2roxO1zpW0XhjWUpGzYYGhTSNBxSDXTPjcHwEvWKydaTqaB0yQo7zRNahfMLCdge/ST+jWEqzc+g0K/GIoVEsKHfPW3Mu23qhQ6ViW+k9wUA9Sg9pHltNkEdSTT5Jc7YZZ30zGTCWQuLQx5BUxbVzYKDnK8clUb4HUKRg80A35vMUXUIpkTiaA+eUtn4peOl9P5QooIIEzgwtYqLjjtKoNCcSJvmd5WxtoFNHpu3ZKEeW/GiDM9Vd03bWKBhZnWlDbuoAPR7MX4kKNgBCztJ9mllbT4/VSJCB6R9vexAwERV+1eEHF3gQqJ/OZPqNhJgdek4xKCNSVdjaM1lgHNMjqDhBxJygQ2PZRHK6Civv3/Ys6kCn1dkU+ffdgw3pzJZ6AjrWsD4iqCVmfGXU9BVXLCYRAZlB+0+m1bGeWuxAxzk5zHYbmZI+E4qKqlDB2ZNNjF2q6gYcPlIyGwgZ0IPMDF8vRPfCVFy1IXvpIIw9XphxaAmT4j8emQS1fLrX7Ks5+ouyl4wg07j/XxDUtfiYvfPTpP2n7C9ftUeqZ0E021cn11Nh6s0r2b07VXJrBm+/LFPWXiXxbQVI8j8WFg9IYyb5srFGEJKQs097WadkT80c1vOvihO4k0Z4xVf8MIK6cCDGhMgKWs6rEQwQZmo736rvwlVOm1g8xeFlPnpKw974aKmWGI/Iidi0s88QGGBQcFDQ+4Qix0mAwO9W0PHi51nGsUPussTPYnJzpCCtgfgNYnX1YXhNGO10gDbO82TFRF1PTgTty5tkLw3vaBNpVSJgFvNCtI6m4OgAbS6b2vENxCM3S2Op8Be7B4loXxFwkxEbJy6rUFHHTUtJXmG9RbOiS7r3nDLJ9DB3ILabDiL84fRWUYdLr3htmh0U17MobYgYjemfRgT4ITOtjS6F9+OEVYlyY086WT3wOXTp/g3o0Ue2nYpieLgYaiqh5RTN2qSKGZ8gT/UMi/TQwJ3h5vw0jZOAVITKbqSFJLHEhxYSJyuOqnmA4A3mll9YqlXtflpWeXbwHUV+y9iEeQSieo1mQYyawxtZu1q1xe9SK9WHEMbH5RFVKJ3/r1Q9toWHxiU59Rq1++O3cRHt3SuPttLEs1509xF/4aQJUKEw2cUxnFgxU9Sqik9Dd4uBIlfHqz5fzlaWr1GPeUVExa6KEVZ6MpSYlJUhJIetAgupvqc6qFNBjq3s3WmaIPlvLdK9K0LJYeKv+N8uuCIOWMMEseYJMK5YJ4zzm6r3Xym0AtzO6QMGutcATETKjI0u38Ma6e7FFuebvyVGtn+PtlRUh9r0cKNjyXnPfM2bJXEM2Vx8k4cwEmnSr8B+/QY3eM6XqV2Ty2vjdzML2lazjLYMyqjp0nvtfFpvSSJ7xs1AYQWp6/+uPI5cp+p38MMqlV7+qpqOLaPQL6c87X6DvBzt2DNuxxtPVQftQU69iX9Eop3YEWBJiPtWxXB0Sgn/eZy24aCtjGZTLm3AYtmhX5FHHVCKSKpTRzaUMZF+HR85NlSSgAmtgF3LedIRQYawIJ/Tdhip8wmYP6+KZEB3zlrprZQ2i5i3YfTqhE7XikTPcrokUVUc5SVy0VS0xgd44k6/t/mKARkLJIsAow0xC3pkWhFt3ggP2hEpM6yTJOqiB5v5WMwxzACyd9/JVL/w9wVWvUe7evuGBC4pGTHc1bLxs+PUZ6KocS+lvdiHD/MkRdVN6xXdXHx5Tv2j3JeS4yrAf4hxLAuwM+XOy9G+UzwMj6dLXHw4MiVVcCeO8LyjJgzxyDSUMOf9y4+Kjy0i7Z4426oH4DfyGv1OcMbzZHAdFM6SrgSMymuXkHbhDIiWTSU0Mj557D9vxrzt0bUvqRRQTO4Qt+8ycDTGYpgU4KnVNKu/FAT97Rcui4eMIugneLv8y6ivJ/aPfZ30tMSbHGy8kBvHHsJjCabrlOelyyV49iw+ut7AYp7lkDQyaq9F1WxD0f20Hip8DMeNe9pSOulv5+rTWqAgZfrLNvfGDrez7c1fm2TDp/6Xq6C0kZBFFuohviEvlLmzwczWBZFrDRR2MidtXcv5apjnjKTx5nNwFp4CYpD3yPI3dzO/hrFwmYFEDWnkzwbUnDZt9iMFB+4nsnr6z2qNsU4UH8rPCzahoLVatA91I2QgheEHlN3gZyS31Kwkm62wf17wCWYz573qYaOaH93jl0C4cXvO1KxNYTs1onUyiU2kV2IAlcMQ4827TCag+/Qf+D2T6CCjTsl6HjMmL3w+Ll51IUNRqZRGsy2pkmiGA2sQoZK61T2v5mtMfKoKk+/A6WcG3PLbHpHYck91BH4EPLR+L9uQVkNYpo2fAYl9guWkefWGrsniBXl86HWOyBEU0v19i+j9LlLb5FDbxzjzb5lM59DTIr0tsUMT/S5JXW72QlLYQ6/aQF8kViypT8V6/YmORSRusrzirglPC6pXKxmo/6WDUzoAnOmvQ3YmkebPoZTUZgScmTsUfwA3MgTc2HQ3/iQJXgicdXkUrHInZ50a2mbfNYOg0N44Qo4pXlu4ZupfoZC6MT3n7qg/pTOgaW73PFhH6PD9V7IU6wv8Wf48ZqjIS4MBtCglpRqb0YK6Ls6eifbI/1OeCEVuTX1OlDVs8b+JoUJ19nmvP3vagWQTBPHDbUuhbov4cI9k+RGlS7IvfQ16rrvw9yaEo3rfMdgc0HJLm1rxW06c7lMXAKwqhRE7KqcoBZu/qr/vpdqTHrh+BzmpM4kcBSht0Q0P5KXtlKrlD85JHFbw17YCg0BhiRbNtYZz1Q37Kuu+FuxYED6mg3pvnAo0jQk+OeYzTPk7QDV+/7XDrSaMQPIOyYxVvcZs1Vx/yaeGJEPW0qArhCmRkMujF3k20LQGGRfiq/d4bP/ovT+jvILeLlIqFbr+4VaOKYke07kohsPd6MkUd070cQcNihpAfoo2TIUMqZNjJWiGb0v8xjxe4eJEWTAsvwzrE8L8AEuRbEzSMXcvJ7wcVLupZwjewfw5F3nSuNWeVv2bgwAShQjbLcLZ6iVG40ax+zoHglnvt2lvDjNgiKBN+I1Yp8x7ysGMmxrhVntykjToisiQ/D79Mr+dyLe7SEWHjyPHlF8eTswjtR+Q5FSWNUbjGbcXIw6OlR5KgtY5y98DEV1WIeoBoCvb3dZlI8lv6U9MSZnukDusDw6I07QAPWJ5zEZkEhqpHaEOUg5qCZijKQg+G8RkiOpDoH3kazMPT4EX476ZSlRGcd/PnqZDETnlh5AMblj1oVY0Q7Z/GgcYsdpVMfWMxf+D1tAIVp0Cv9tX7kdyqnoeyz+gD9gGiXJrF+Qpcm09jYHnsJxY2XUupI7eqq54K15YplX3EskvSGueOG3KBmQAICU78DiJT1FL0L4tXQm6n6nnuXH+4WY6dU2h91IH1QufhhyZnw2Wno9hiqBmu3Zfp896qAY02okmjgFcepZNrBZHaRIuxh3ckyirOM8A8XppqGCcCE/anqghpSVGaE9BwCZMCoboGLk0eufJSZG34+nQWgu0rDcZVsi+uohhayPDJJfqAfp9N/20w4GVfoBmY4IYm323JR1KQegpwskB7wwRScXJPuEHJDJXDN8/22xZGXYACSKkcZL3NMDOhuK/yudBDGqlbBsF27k3HASND5+nkLSF/OGkOzyEmEFFqKEOSzsmjMFZZ7YZrX/4aeaOJRwPOSSa7uflvqg0p9KdLX+ESP3pC+EbQp8wObogs9UKttSQem1BUlYZ70s0gzGR/Y4XEYcOpFcQs9oGPAdOIaALVgt9KB1dxIXA4mCQxRzygTTZ02FBXBB1qZ1tt937O6dCByUFEZVRpArgpsp3k89fxIi6nlHXoXeTlfjZuB3nOca+cNH8Uk90NvWe6qfTdFcUPP/ZAUisPWKTcMm6ZZ1wskMaU1IEGra0aUgMYnaUs7xmNZp2lM7OOF/yXIT8sscz7UNm9pvoDrWm2xH0JQp+tesod0/9LHGQ3hV/yNBF2z3LMoqIGsHzi5fsTdIi4cqOVwRHsrx+JR44x785HXnV/lHoVILR8gZdg7GGcPdP9rvCO0qs1+X6RdSKHrW4RQtOrhmVOtzMkeaad62PNI1K0+1EKSkZppbU3hdndSNCCJW2EBOG7KjPgKu47x9J2ZKjymtT6A4gP2K9SR5UjmN+OFX3SdWZJFTcaoHaOpr+HtBaDTBJxWtQ0JPgHEQO6xHtfbn2ibVJhjbh/V2Hx+z9OebNyrPTmlXF0cqeVisVYDkX2b2I0lyTdtxtIsd9pURsiy0CBUrolhsfsi52PynAgiXbBqxWFgp5MEk1bCc7RVFtYl4AELk2zMG2ILsAi/+74yH0WStCRYT71An4S9UzqqTsYVIQQfsro/dLEB8C8ZF2cKLJmSvpaqIuRjjSESWNlc3da81U9gcGFd46tW6nhCsukfRibAbKZokF/2Nm8OornZXwrRur7QMO1HYJcoyiBYSPN++illRXyBYWUC6a1i8sLscb1Ko8LKePtlcyQEwfcu4sYvGxlQbjdZh3zxC1aQiRN2Uz3pNTluHcC4ieAo0OhGeEU9OjGgOUbIDsj0bmfNSdwYZpxo6CvXGPwtdMDoTstHEBa7aRJqkCY3BrfRbDzw+/3Qi4QgArgVx02Kz6VL254mbd93TyeLnf12/r4RtQJ4Cyhx1MbPpv4NiFcds+RKZ6AbSNrc19/CLmm/NC9bLUvMOGAH1kYy4SCSlStKVxqMhOEdlVMvEyDLiJ+rK7idgz8k+shKswKeRX0nRCbS9nWXlNvGyx4DwsPpSZ5Vn8erDArlleiZbvE7EfKRFOrUFJygB4BJeQ5v4HR1Ls0EZfU59v7v3TUzl59EiuzmKGI+5i1urTX9hvc0BVBx4DTGYoYKjMbfybGMPJEWv9D2nd9ct8Xa/7mSHTWm7HOARd/hbVBVD/HipmxZFiV2ZV21W1dCYwveEj0erSZKZBCK5rFh7BZoNgm0OtZUMBVbjj3/qDUOFKXs/VTtyF6BJetdQUxxtr1lUTgcZt3EOaSU8Nj0mVVq4MjY8Gtq8LsG+PUCfp3gxbT+WpigtqkAarHcg9xH8xl2EVe3ZtM1Y4bQJusxckqbkKhgEly68BkJmEEatMmVB54zlpVAwrt0Y9XlL1bbk+m9jHWOR1bahR6GeZr5u17Y2aF3DueT2ZMUV+XW4YQl5Wy2K/D9P6eezWYgWwSP9bClD0Doa2rQUlihLc+iu7RmcOMwfLrjK8CrmoiZd4i/WodZzK0jrmTJ7P53hFhGFfWGx8kHXd3rcaXgvwnbu9FRdU7eFaWbnIr1gMERR8jYj2cLCPVwCIaDUpOXU7i+pHZN+Jeet+ltyXr3UFz2pTK3V5DdowKSzao6IympMdtcJ3gDwESZ3Z6UMMuCPOmrtqNx/YAOocQMqibL8+Y7roN5GWjyg15pKAnSGxyBDnq1TJkZbBurFBJgFlPr5zc31womJwBuKkPWrwastpslOIfF2/78K5lSjLUtDRmGpNqt4hl8+hCJYn/IzbNBDSlpHJ4wvk5tMeqp8d3njNHiOtu7P4/p8iywIq+8W9jm7YWYvJh2qmeAeIP06BR1HhI+IqFsV9LWN8OF0/t5hZpeOOiy77VEexzBshs7Y7sfKSzbg1ei8q5N9D8zzZnefsVSNG44Bq4jseB3B3BLdKb+PI1o70shnmIVHquCb4JMyE8EddgDupQ4qlVZlvr30ytdD+zU+kZZVYkUNg0ETEKB3MW0JVltPOr0a33AGGK5MDPhJp8KziWDxAavHvGHltnYyEoTXWMaIkmIsuW8BLa3oDFire0RuECCK0midw0mywZUbyCQMdSbs0/oWD/O9445sVv4RyAPK0Yzqg3F/o81+n08gq+Yfk9Udu/dLeHX7pkWorHSox2/o0Kb7uqL6lULp8fAVH3xTV4IZbZKEZOE8XbmNQfc6UZR16HaYtwaExPqpIBd4bdykV8ah9784RnO5wW+wA+kPfroJvwr1B7STj4WSQf6obdtmy3s5qBxOrR5criyWjgeN+QTzd8EMNldYtkXjESznyUzQ05azGm0YmKuc5gLiixcXS6084OF4jlTBAF5ySvklHEQAn71luxBst0q8J4ZkqJicCmcW5d6FVaKznDcqcgfUnlyp4/CsfISM9kSoYBDNMbg9cvm3h1Gi07NYVu6/k/zdkx8rbd+oqzxaDQwWtSG0kd/JcFWb/FbdhE3agnLJ31gUVbDh/OgOw2xn3rHJ10N+TOulmqFIK953YChYgUmdamxREApMeMEm6A4PoSvvcSlVGzKvKJ1aJneE4l9pYiaO8YiRjZ0WAvZkyfwQhL0C9UUuhLrKqJpJeIgwosfFqYepUd65sVUuKugHhgsyinXagMPtUqoKJsP3WhX6eabXvzP1OtW2DACl3llPpYBOIefZTHBAOzpcvDSaKuSl0m0JlGk4rqDxdAWFfngbdqzQ7q0AnbAHxYhKr6CKnIHgfSH2k06IpnPY3mpuqpU5CvVf2A+MOZObntCz4Xyz9EhFb2EEoY+K4bybDukrH2qDh5T3VGVuvJX60GrZZ0MIXTZg4Ng9nRHwdx/55I4rqJgIsesbrNeVh1mqLM8Xaym6Mna5JZFU0sabXhGNIzsZTiVf6EbuwVLyZTlbUG2v8ANaXYk6rL2H36vLMhM29a0fedQxFcEO7AYh8Mgzj7ffreRHlW7kQDJZWWKr//ulrYSoDlV3/nGRpG7K7jCCY3tsD39s0T84yz77Da99Y6LfDvPuYxMEBUUTWbxoEe2jfdl5bhLTbSNT64si+//GDj8nKSXwSwvBsb/uOTW0k4lKO5M7iitAxCJjXGPMRqMy0+c/jZMW7l/XAHx2pjdbzY9DVVAUfhEPc7mt2aJ4652q5sdrM8hTlPRiRm9JJjb8a0ghk8DxT7UebqbY/zF+pjQywjQMOkWBbXWcwp3PN9z0CgGFjPIFpfddmWbEY/6FXqJOfsxFlhvp8N7fXQuk9Xqy7kF3AsQi86iBSN0zzdyo6qjVyKfWbetOZGk1ns1e0dKUGQDIJwicOg35NyjL5wMUb2N21rQigevrZ4mq57M6iV2TmmBZddeHdaU1njO8Gu3qqX9vIZ5xCmeJxFkSYZWzVtH8iwcuQcDXI75nXjHTPdq44keG7e7vw/oBA5HKughaNI/77Qg7RMUAPi7EeuQvBDEBUDElcObmqUHrJM49WbX4iXXHL2ThOqVPpLJn4jp7MYq3hb9VOQ9IoAlBtpjQfxWyb0TO6Lda5sBdrFc/33HJOJZAemx2p91QmtNpg8FwPDEDiqCP156VCkaKJhgZEbjV3vfv2V6p/n8/AN9ganBpSopmul7Jf3PB8vax+uZ8Ql7BzswYLWX6BsgjYVYml/qBDMfcv1wBSjPqRLHA31n4KPV7GsiGuTjZBs7vtx5946/Dvu1tLZMu7f+50dZU0R6t+iSViCVHEMy8Fz+hesI1eP+7zN3Ml/YMSadzIj9WevU1yTE1gvDp/YMABEarsF3bN6LM7pTrUiFTC9RjwubxGNd+khuq/cL7d9SeAiwwHiU//u+WOZ6sGZ87zflp/ZhA3pMycVFNBfmuXWdEBDI5zsjLQr6Z74f++0Podub+b17TXMaFF7Jj6WK6+kWmv4wJ1uZhKPNR4UsTkOx39mpkcXYNFkyeoFBodFXHTqtZs1G7ik8Vbel0a7Mjq5yi6nlZ94MB8qFRa+hQoU03ochFXID1NI7pQu/s+a2FpMbCRHpLZqYC29l9G1G+tPLGHnsYV4Ktb8GohEYR2AOAe56oyud2ojCYEolB4Wxn7pLSWaeDaYI16HEd3/hyzfl3BpQCdxV8TqGK646K7drgcsz57OQUILSnXpYw1XBics6Tq0KqY0MrNZZvWkIUOPpqk9hnJ+cp8ufcAnJPFFgx8cYston+lnAfy52uIRD4O5LfqdjHO4ifTwrKrfrj4fSicdHx5lObQFDpN1oFgrXSFtn0Sx0Br1cXojogsHcgYXMQ5w5iWMCcHxhKldGvUfmsyXH9/5FFjV1nQWp3L1RKQ07Y3QH/M5Wo9wHFfE5ZYlFCv2+8WLl/EGj9kunttL3o6w7i8YlW2JxFj9+tokRwoUsSe+g/ryU0Z0f8dugniyZVQCjzzaLsbQNnPUv3qBY/iNYUqIluzD2k3EbTc7jIizCFCKfgNbw/BcDmwLmIw3cZCDGnhkUYa9QwFZBtBH6FeracFRRllponBI5j+/btOOIPK5EK6oJhD0lCHjCgrl0H7yw3vcnz3JGqMRAVarHICg2nMisLeMhsSC2vC3+WYorpnP1RdJ3h0ggEUBKmM2htDGUtOkmjNo7f0oO6ZgOfDqXBIQl9dInVmyRsx+Opqe2/yaljoe4pQOdXfImwzUIgkCEcdvd60cAhGFr/dQrnxBRoWs9dr1EAos6Lv5kGj1tJYWveat5zbqIRtF+tDrzIy54+ESVdMYA6cOZW4c5Q3WDy7d8LqqJuAPAnPv3aZTE98OBDvouvqhp53I5NQiGXlVYE9ulZ8YCHVcC4ey9Oi3gKZ2PXq6UrkoKIKxY5WgDp89c8k/ADsGd+EcdosbWC4Ev44ZBauWqYxCAkZCfDxnPLVXK3Pg6+zu8iG7yDUgR0uHLpQ+9UHY/AlUOml3RCxn6LaiwsUJMe6bJgymPS0pRfiDXYakPATzWOxHmphiZrTmI9aDhAujWUKNojRZAgpJuZcHJuUfZPW6ccbNKy4Sq2s/JjDZndRV1UGSsKwzJd9hRWrxA51TO6K9VgSP+2cg21FNFowklXvZj7h5WuCqRuMKIULI6g1cqL6rVUnohmtWY1OoAXXH9VypX9Rq7/IOeMvFzcZLwm9WpkaCg/0LlIfo4fazzbpamyn8cYIK3QUh+wVcVJtznDAuM9Hb1cz+nyh7tdNiW7VltDSvZTM3ygCMTLgps3SXhvwKJY+vK2Z90YoJbq28UMpxW/OqI92l6FLwVJoAJni0IMekQQZrWcOX8aRMPSuxKwbkpTwTPkMfFj6qwCWDQsUEo5vp1MdJGNwaMCRRBjsqpUZ3loOP5BnLacYM1vPo8s+fY3WdYmRZzYpRR/EFf/Wbwz75y3duOS61SKUbtES6wHHM9dH903Zn9QR6oYHjuwTfzLKHtZhDM7CTt8m0MIs5g4wITNtATkV+J0V9oLjrvsW4hyGhVnbdOBCK+DXt5Rc47fy7KH9fDwew5wFFcwChWxpVllelOXZnB9jQfPX2W0Y1CjRl75zx4uocIYTRgdk59Y0LhSXrh8mH9uxWyzRmFjnGHVy801FOw+TWCZf5eElbbZg3r7VjjJFJID6/JbuOWkYqkPyTYOjfAyAUusXtcfHjvgFSuQC7UhIwhXCZA8pThNCoMhMIXEmxdZZMDdyZF3JTmjIUkHQ/PdVS6HMzu+6YW/AMMtmPaA4GjiHFMPxkTj20G6QEVtqTLOyQpTglODwTTWTzzh/TxiHBVYu96Sw0KVMVQN/DCtopdBvB7kiFMKQJN1c0eCvO+fovuFb0mkzk6PL/ag1ufQqDaVxtcgA3mxxDkDBCWK6bnismAGkAmstRV/wuHwNR83dDfblAdzRXwB48SEOvXngNuTIvVnoLU5wqWkFqXecEXq5nut8VtXPCbYt+GOMaztNeYiFxT7HpPJomGv+e2wwmKNjwwtW8kCg/O4homIpw+QK4SJh080S7lGDuBAZYWvJKlurUXiwXDKinQMYbDeqMRpwDFOyI2jL0uYkhnvrgpuCVT60oRmWXXtymBod2Ed9GakPzKjLMAO5ar9L7lPx7scmH2UocEGtpfFS02LM6EWBqOodu4JC6TLWEAkyk/WdlF/G+5yZ2uOO67F00put3l/kQNqWYWvBX97i+3O9bZuw6JJCnJ6O+u6Zea1dMu5Ac8du5aD3omkONV3/cFlKOdN9PQMslQ+L26BYAjpTT2C8h6cX2fNpssvHv5za52mkED0V0iYerSxRBCgNgqRity9/jDBibRSp6jd+qayP/lzhuaaNNKMNYaT9kxxVJRMg5npC9z/QKF3bSwAIBTZqyw4R8QpaJ0rc5UuN6uimLfyD5JFio+3hIe5wAw2DapuTbXiGJA7LEs6AjKV8UBr+SeFKjb3TOxCulVkp8I66oFh84+bR1fYeoTZyxnooDNBcW/RUL+FbbTewBDHVPskkZbj1gAGx2mLbgKnmXcYPcMJ2zXsgXw9QNexsCgQuIAdcfKWOdTaz80ca417r2qI99jadjJ9CdcPnXfBeSg+HcTC5vaLbymd+/2tnMTy1nnKl4tX7SuPqcHXuGy1i3DXFIfuk9VzfZvxt5ddMa1Yj3RGkt3EelOh7HNsbRowz8LtVRZPOCBoYdk/DCaUXMyr3R0WDd34cpNLsoo/4BwcaaqnT0vb2h1WnR9k3/urOE5nG+wBua8NcfqbSLD5BSZt8irtxXZ8VEROHZcngrgyt1vLC1gJywk3FkLSVO0OpchLLdeFxpO5J5uHydnkAq5fMiK647LlOwtxQmGEe7NtFIzQqdeCW6E7hPLpwhpTlkAvubSATHMEAwZqV4v3HjlWEERiTobCPrEOUhuT+7V3OSK1Zvki9LDCxN2jKQ4CrcTLpHM6fc+kVxoiXEWxH213u1LIjh1zQzql7PheDdKGZAdRhGg3WAeBbpAFac+CAb359RxtxQYGRtTJ/PlT7e2iw42ww2wqMore52dplxL5kO0Sy8eu67SzccbrJ7jwzcHx/LTy0LhTHPeHazedq2SxkReDBvPfe3Vw04/mrxEZBs/qVVuKDIBAFIf8gq8qCleQU8iKDCQG4ZxfTrIY63zYFaHOsQ6tcLyp8bajlwP3aFClRzotikL4FKh6KqfjVKej0jn8Ts4bxCko7NPH4G5Aiy+2+kn/NzXa3J3nIxvZvK55y6M/XuANgpYa49DcuxYpDccu+AtcLRXsZPsmulO5FXpOUo0ggxuBMiN/6aujpDA2UDNkYickY+o1vkBtODHP38NSyUKhqHANu1wJ8badEleCfRnC9TFQlSxJTB+gNsDicBFhfmlSYjXSey4ugSkhx9vfj5gcaP7Edeg2l0hgWfAkc/FnJHrBUz98rF5UanuE6L1aOOPQ3XLrHoOUdIcJqhvXx30fws6PF0QoJC60iw1kdYD8OEFYdau31UpIuoeFuCXcdRlo+04m4huxDwVj2lOJDoNZyDhQ6iGEnyvj7BYzbJI8Jg9Xi9D327q5bF7wJ7U6ftQV5GuvHwDwVAJAaBELhsoGmI9qMQudhcPtgQ/qyZFUrQ3Jz29eNzKyxWCqPuNyHl74Ym5+7kQR8PxK9s5YDjLugc8HzEb7FqVZXpZpNBzWQBa/wBseKAmRMtWIOOZr2j5SdL3TulL3RQA8oG5nboXCmMK1lgSFw7KnqOdBDwRsfW9iHmzHGrnu+fbYoF+H/yNQ903DXNot5HUHAXvVXkvbeK3RrjXD73IK0I1qLFHRWYIMk7wRsqqZgGZo4hcrHCgmO/S3BgUEYVTubiaFKTANP35tOL47t4c0+t1fUHLB7aDSQR84HTx/YU79/sVZzWhbYxE/P+9iSiT0b1qFznOaOP+qL9iH6ivz3oHJccuH2qEPk5S7NW63kH82F/RiqH5eo27hiJizIzWMwP8M+G+iEHenlFucQvshJ+OlxerqRKh/+0i9Y/aogKVYhSvloxcwmkzhkanHMffgtdowCeUgDA7Q9O7qiOfDnEatBOVZ+8s41gilWCHWXp6xLVO8cquOxToVmpt1A4lUYBqk64Rv1DeEfuGriqCI34B1CjTc6V5pNvOR7nPLjpv8udJy0S7vSQ5ML5Q+rcIi9KzD1zz1wl4BeYSPkEOR13SYQM2qLy4yoemWGK63orOMl0l9lAhpsUW5HGvNcpXh5lFMi25Zjw6FiThAPASqyrCm4XU/m22y649gGAsgwjxhSzYpkiKReCB1XMxBAna/+dPaMTuNfee9zBR7SmnGJWhGFLI417upgP95zms5MMg0TXwjM/Gh2KBn2SvQSY/g/rm1IZP1Hi+NCCgiyslCxmh5pcWrq8nB71gjvFGih/CPnnCsKrjCb5QvEmLGKprvhqoXo7mdXLORlrU/X27gJV9cqFOIua2bDgJN/xTL12VV7RdFQ8UBXbblhr8cedUoqV6hIB5KUOqb6K0gCcNVh3zp5c427yASX3metCKAnvtSjhJ6w7/N3TWimqQvxI5+g6I3z5C2IFuq8nDQwRYj/xkZ8LG2zjrnNcWeBBI0/GwKwc9780Gr5xe89fWeB8Vw5BSicScmrDxiGJpwAIDJ9qmgwe+ODZpgXnPZe7wKmiGDbAqDDde1JoRLazOw/JYnlI6J0zsopCCetHHpLSfV4LJq5Yezit6g1qyN7nW4k94m9mVtUlDmF13DGCNdyweDqRW0Z+ZMWDOWp5BWNY0zJuhGXQveO8x8dSLzkg4dfAoiEGY5ho+mK+NXLvpYNuL2OtsggJgFA1dPdXAHiUm1j5I9tPhQCMqZZes8/y5+j1koX5yXkFyuBiBjbZHWqfO1UZE7G74RruxLs4gkwDK/8eqsXNYJkJq0ytcR0KPlvv4my2fh1Fk+jgl52VDQDNMHOtAjuTusYpn7vDwcwNGXrI/U6JlFL6vaa2l1Ec8YUGSgHsXbchOVAp4P6qLA8XPRDheRwfaSB8hjxhbrRJFbFRx/Tp6abgwalNstjUVZdGuG0eCFl/D5clliBuDqDDvm5eiGvPHBStDpVF0hH2SohdUeUApRvw7yxhjeUsOv5UE4i86VLQyW9qcoyBmGoLVgxRJVXJwuDPCSIhtPYfFZhgG9hJVZr2kaTa095L3kQVlw/MsyvwLkdZqpssdKWP81B0I8nvn32vUbcDN0cgkY9/7isyizvpDOiZ+LvZNNloUUddZzv3q1wV4x4leEUvnaMiNRQ2jNmC5rQFlQDikUL6n2HWfImTUNYVB+yfPwm81M1MDQ3A+xwcStZxgT4h0uT8k6S7rKlpAI6l+ZnAgA7hcyeINYRazn6Dxl0CyFVJYREIU3OIPYhxyYI6K1M+mfgcHZGnZu909bWbEXJ7Aj7tGIljpflzw6nw0vuQal1K8WTTzZvT4Pn32cS4z39YHfS7Ds693QuUdd6+Q2xV/7qE25SsHSFcYnbn9Fs9V7fJBhqHM78HQ7e8+N3pSVXbcQg79tsJ0JspJyH1sdg851mZdwgsTcT2LyyyjApIhOckoPWmjAJ/YlICK9Sbv5c4Dw49nes0Darj6vM/zneW+hpPFbvsMC4wr8YkPEpsBFjItIhBlkoMFQlQ8cNxFLltKKyhoUQ2g+fXDiegwRSwwKsu8NFsOrpgt9D2rwIF1bWtzjf6MsieKWpPHZU6GptI4wFdEALSgKs0vDPUW2d3YJ5Q578ZI0WUoLw8usrsRpuGZxATRRg/sYsBSEC4Cu9sNQrCKQWFWT32zWjuILAyhngLU+tYucT4juxl+T5Uw1HdXM0RncTl8zmMfxgwJp4fXS3oa5XmA4cZamD6gV+J1IM2D3ISbhVXU5A+UmB6h91UuyEpqtrC/QJWM20jrxHqSrhTgcrpRl9a2LpRung35mdf8QffsTj+m+opItvoqjgpuePaY1ESmLI7AZzyT/Mp2sIWmBbf1Q4ePbKjCb5rIEGF+eXS8taLY/LnlpHwF89GbLxFSyuLGpwh/POgJ4hAo59W6cc76oa1GDcMBUnqRBtFgJq9Q1bHqC/wvMWcSG4jsPCNf+abcgY+7CfTlMsgeUPeUZ0Wn0ZQnDZKBexmU1iah/XqCphwS3OBK5bdAmwBpYCoIVG+ZeNdwszGWRwQeajS7XSReRMo1ASDejFQw1HImQS0TFqZ2Fgsp3CiXraDIe9a/YYocKvPp0C3BMudCxY8LB876xRPpWI+G8YxEvd6jG48gtlcC8KrVTWHu2K02cAFrs8zQpP1FPuqCTxqfFgU+1JLTVFcJeP4PWRYz3sCm2LydSJZvfyaXL0Revee524kb69BOq45NiB+ucwE5xJ8f186J+HKuoNBFnEkPXLBFp0kTy32NagmyPOxhi9ureRLuXW50yHP8iW9z/i1jOqLI5OAa64fiiABatF07O7LmQ2BGX1EuH41pXVDTXygVLaMtctikY8yxw2AHlIHSqOhyDmiv6QbZF51M7isZRYmq6BfH9Ssn2EkeyIu2yiuzvntFCMcVVzxMeha8XwdOfzP6lf+UjPx8bbaZwGFt0eTsNyh7nrukIV8ejlo1WncPmy1GgFmEHWdcuCj0nlAdpB8Z7lTjmOeQ8cjMnLMbFQX8kf4VVdhTNn9UxhFnuhJVT5gAW6YykJhN7qhUMfOS76DZMEdlp8fAZPPLSQl9qLzx+35FNtJtdAH/CYf9l/D6CsMCBegooj0G+Ft+uakw7l2NoR4/ysR5w6o/eIsL2Jm7gsjnSRJpvJiShdd/d4Cvh/NngIyKX2QaicroF8HpZu7D66luRdEwaRS4YJ83wQ+VdN4w/pCG6UORtZIVEOuYgsEhmk1lc/Cnviv2I1GG+Gjvs5fGq3Kw3yW78JXsyvJQHqr2T++dGuYpPw+51REugSQ5C48nE41UU3XY0DZiWAJmX/ADEeSszasaY28Y34ytBkOnZSBj2SjTtyvnDWs3LdjM/Gt4obL9/UZDfuTl0fYYxJPadP6g9wH7YPN5s2SQqThzIhaozO6PdxW6xpROIe81/GWwvt4BvNhEdDKYRkv2Jrry+a9OIrOwBF4ej/w+JqVwgTe4Ja5tdMR61xQa5lIDKToJuxD77NGM6N9tENI60yzaWPd/me8GcPnI82IeQz8ff9BQ16DvnnEl6kZXwHxYonT6vpZXldLRGExF94B/C1lXpLzwqTY4Z4ikpuQFro+VdcFzSq/6uvKj41czFI1HZScwXbDRpi5n207UOeNRoWiNKJ0rLdZGTrrwHq0xm6FaQmJzFn+YyOJRtkexvXKSVHnRgKBu6e7gsP9TFEsjPyARZK2wkkW6Cs0dlEyxsoP19ljoFEcw9jGk3xHeWNHy00kBOYl+AQPueHlpZgIsK09ALW0msj2I4zKv7AkV1IBuZsptEfj0HKBcHTVP/ruX9dVwJ37wQSTJUoj7ZUom19X26y33tuuqQG9uGZgk0gb/DyWxdVxN/lf/zTZANxpQDhL4q33tHPHa0MhOrVgSPIxtXk2iaUO1hq1K5zbhRqI8Ta1868kjraezoH4F0tHoPM7PGKOm8iRCw/T1kL4Pqz+tvcljoV5XRroy3Aa+Z1excMBe9ptEjMsikxrdL86KxrNZHjUoHb+dKd5BQkKfHyWys3xO9bmigBuhpf68J/InkqEhRzTrYbcVGzkK1b2K+RHnR+wojAf0xX5llh+SkZOwvWh5CikIieLujVGbO6MRwgmitMD1+15snZ3XG07EuDsF2Nb6oj6Fem8YbfansQeY2UqLbdXjjmxWZDxhhSmWMkTPYjr/d4oZWfXKNu2dw6g6nI360wMvf6oYZmjfAfBKK5tSf41mcWRmCv03TlApmarbubKHwJ9KoVzwOQZT61tUKC9Fr2StZ36Mci84zEvKS8NIkFzCvYDolm3SVXX25b5Ry1/xT787TpHViZOVYVukl5QmWYq5bbPGobmspDY8NL+pxvWXf7NWemNZyWXPjDC5a+BaoI/LkiHjvzNeiws22kTRHVi7cweUm6eXc9oYu6TSitglTct16PvNpQHGKdg1GevpsflgjLXBDOiAg0BKpkiJW4WrfglSrH7ehVskurQtuJuTmJuodDBfbxGlQTYx0oG8pMKFMTu+wm86bcLxNUEHi9w3MmWbDjybpbPg6ZMoH8VMrylNPLyeHwHKRTKdpLhKF3CF1KNJ+ujZuQoCpgELEoHCCSK2ALJrLeUeInc79x1CPnO1a38LeiH/S5NkOLYo6N2iUWCdknJrCSoMe3k3K7bl/QsNdXJiycbZtL2XDgPwQuMWPSWTJlbF+2F6JaWllScgLQmeK0C3g4lBq7GdipwaWiBtIkB9vbuxWQ3IDstxA3lJu0nk1+67p0l30qO7ngcqSSulIv1GACuBpWSxYcTS4ljIABVvQXgur3Ol0gjQhy9Np08ru/wnNpYWZFeT9DvjmhcCnF95GllPDJpFkS3MTXpBaxk1GlpIkLr+wmMjhkhvnG0ugs68OmUskj9WQ1iOXePRV4F/PxpzOtJfms1Ik63zUzisPtp7egmEYpSxxlnZFEDYWXiHu8D51UFFFYsy882mN5h8tOm/Hh63VAXgSIyUO5XKu6PuC1Vd/DbWZEw5bPa4IWIt9gXgXn1SS1SKr5tdEjxc313POHg/lgkkNOVaiyHyTN8miaI5yb4UoRH0HbZ5di7vCtWe+qRll4c41uyz+LBtQN3JkJJJclFLL0/M+hMI+eWyknd5Uhu5G0mQir3EVTxzUnJ1fDnaGjekjXjs3gwKgRVG6sUVv6dGa6q0v2DCRhmW2SURrfrlRu9rshbzKg8mVTDsQ7E2tGfPGafVdJ+bdK4y9sh2uGjwjCSFNbhZ2nR85Do1zGVqmggFyO2GM7PlDMR8OBdpBpv3Gtjm43/An6R3TTBRsYQgC/45ZTG7eGmsnKp7AxQ1f4s1rXOCcygeF0kzK30MzFf3BhewYntNLGdy+108LPVRhA979HFwA0LWjU0HcrFSzni3uEC0wNsLzOBrFczu2yoTE1etEy2tqSg2kNz3bdI+ul0ZjblIESTtIGZ/lwxu97Icv06rQXuzsq9niVLwVyypK9/YabQR7aNsBRIjF2JY7/DMw2VBN6ZuFBvW7LwwAsm3p5bIBaibXXOmyR1cmaILm91jSGN332KS/4oh9Tat+1jNouZCnptHYEyRVyx0C0B91f0C0k2rLur/R009g8sEccldRhiOK7qpfFBo7SUt2ZpL1qxs7h0QrS4mP/PNYjoW0C0rEUv5DsFLEsAeoIzur6CDmeLkCGTsLUaIciJuRcrAKoFkatgVnn8You4Q/SU5a+KVnDCiw2bZ/CT3GWeGHH1MM3GT8txt3/Npys6P76HKwZi/deEpTp7gkFjsp70oQYZ19DL12rtZDV6+42vtsKKyynr+iUfNOYcxPQ0Kod8pNvoe9EUQtbrSImuancxWGIux6WdkQYbZWZbSZ0LnxuZg8WKCDsGJRPZiNi9dI522d1+vWVThi/SZph+XSIYtlLh1ImRwmhc1frD/tOhB6EeqmcNOfKy7VaDgiz93PlpUcFHSSyzfdRvbzo8zgPzPZIzjt7SrjzSQUp5cPqgXjP7B4qLsJwEFsNS0yn+sH+2rkQTtTvcx+zBL+bBobZgyJuWouoUcxvq3mwzaTunQBKvJkMNZmhGxUCm2+rkkvCyfuqD7+nUNl124azFjz1s79VMCjav8BRlXDxoJaDRvLX0nWOIPDUMjOJX9BL/P4CViA8PbJ50egzwG7bUFYy3QPnEzXoL3nHZPmb0Uos4l5XKl+v0t/1bxzBsqjOhSENO2W3azv0ZAxK2cnTz2oNRdW2uylLNb6u4gUh8sPzD6kwv8JZO49BbKIzt7/R2E4E4V4oRiFatqxcEGBYukYfu6STm5YEpmqfUzm587A+MQz4Q+ctwYv6UoGNtWxuQjqyomndcDQQdSLQuunbAMTrqlsmWga0qVq8d3+8NElKzJV9mbNMfiiE1Kox/NmHxdZlAVkm5ROOHn7aacjvnDdEXFUJBsNOGIZgvT9s1mWgrAjhmM7fADVYWXW6i1yUaunN+uXMzNS8ljKs3wb/hn/uIy6I9Yi1K9vq8ph2IlVRCqAcSPFydzKvQrDjg3gy925/O6v+DRaCrMVy7aXmMfraBuhetV3waKrc8PnSLMFPmOtEyhY8qV/9r21/M36Ffu9YUU8gtJPeGGQC/f5GUbs4Z1QvW4MaYaIcngp9ADP22qwT49d6NlBn1CIu+KHbPOdPXPPLcSGuc0BCri3xi3ewUoyXeQONL2GLq97uWSj68CBYVRZUN1A63LIQaGrfgxRfaSvJbsxwX82VZ95zlYYvXHFM6fTjGHoUMNQr11uAk4TVCN7g18NHdjB02p+AiFKyXxc8qoS6B3EQUjAVF8DfvOROUz63Ra6hjHRZTJ4sP8gIaSsWaEyQzexPOwCyA222gkyDPm0TvCvy3avjByfmx2KKPWjCps5cXagx89X8Dtj1HnHU4gVUSwS5G47ESR8gAWpzELdVePFkp1FjQ6RqowbcPPCxKjj1DEVFDgLktXjNuSRDKOvob4SGHKPE6GXzkpDWhFEtU5L+bPmZLGVf/gTqFcNZnucCIf83K7q6r1LEr/OZK+V0dRyJM2ytswiJ8oxjrQj9PU4MII0X1Jsv6Y14AlUZv7vymvK/exu+j2wvzSJ6Enyy3PEBtDTtDmls8JmU+GFfgFONKQytQIxRO/O6M8nyRqKdRD676unRqXkRzYF00alDRuVtrEeUzx3wclJ3xHGp3ybOatF4Q9rilxMsils3OHRQYB5b0ovWF5IweopBsELixvF5OcgMNfEjiYP5++O0OrosF++XmuDNWu1MuG9T6hwQZw80IT6YTse1gEWmaORBMggPnTjsQDvwuc7TjNon3WSJbZElnkxrjLB+fCSTXpbYIABhNjQxf/Avb3t+Ug9koGU0bpKZn62mXDPqjeAPfF4UQf+UwxxCBr11o+B+mdCOuZUS2prQfozgqAHRg95i63kzM5CCjlt23PDGXjttSP/1JisTh/b93c7wfxfpwMmohej5zykUaxbQF8apuPBLVfwEO5m16+J3x8JhuRk7yIIk9r1R99tuDhGt/wtzKxjM2iOK1DkbkJlfknazdvvBk7cDonkQBAgv370+lmCDZGrZL92NrTkVixpmF8YPDPhkna/5NTYh3YgsXj0DOKBiLmQAoyzmJgm8ZvspYDhiTcPtOKGJcgzyrg+3wppchp+Ru7/HGnZ9OKXiSGFJaORzuQ5IP3QU8tm43V38rKuZ7z2aZ9kVSac1EAk9TgFvMVPN2m3GubbpccEeo6USXWayPq6QzkjGiaIxA/sQO/kQUyej7VOECG+OFH7Yjdb9oHiYH4nv/d0J1hNmvBcURwDEVGIkNE+XTe2N8s+IbKqKSZg2Fj/aoUfbyX6T7L/ZQu6EhENdHq8xAS6XlIZ3E3RWClYsGL0DKq91XCCBOzwy47+Gwchniax3Jt7k2FIy6xpgGBLpo6REZKgFWxpFGAccCJRhjz/HrJXaK+2uu4HaW7Z+IwbbPbE0FakyXjCPekZisjckGnWe+0xNXTL13ImrF7gSER+Gy/Z6HhJVzxgjYN+AqGTMK5mncQ/tAlFCqM9NA2WCpnoxkbBIf0H172/e2kkj5o1B5bLXB7hBJbJJAzKSB76kKWsV/oJBoeD8V7Q+QMqGE7ddPh0JJO4UMf6ygaCPIZZp7MqkK+JMaZZL4+cUHDCFHUuOGUHGnc+rvJgEJJpo1XGbe7CSmci+69eOZO4hLXJmRw+VYQHOihC09IAjjSQHzg/FP2g5Hdn7ybRo/Ee6LwmSr1qD/qvktTerSpZzh8BgQP09wZ/hxLIXEoIP4on+amwFomY7I2CJsJaHMcQXaKeBUI0vvBmUBDoBvRAvaT+8wAdJW9xE/yfrxBCK7KMzlhUHfoqecXregmXjUoDSfZU1RGoGOHKsW5TFFwU67a0MxeyN84J2tyrOdtflFU8dAEKeMW5Gozvs3+lMyn5Zzgi21AXZEEfaJf6KgiigK6znpsw+SR7qMR63yrW62iwVye+LRHDxd2TmvsLOc9gGBkrep4H0wB5yCdzLe9vx0FOYCdGhQVTXR+gjF5gE19CO35O4YY87LkAETI6uTNCVPGLTStqwlJ5go5DtMIWfvsWLxsBJGmJtdUBIKP2RrXLcMg261Gcepu6i9IHSC/qNmFLGYgVYjIUsn95jbmh/PA4uKnCKQonqxIv8lsjhjJQl6L3qff9LVBuRyFpJnbijyz7CC9l35S8aq03uywWl/ObBtuubewkUy2b7Vm4NUn/pQ98DQrL+848bYrMc1QhTDd93mOapGXBpXpk+mksRjHV4GWcUCeCioy3ir8OVZlWU0ARVRMSMfvo8Qe1tDuxnoVTMchC4lrI2iLJN8clAY3zhPt0QUsfvijSlfPhdfYneb4gUQ+GhdA1X12LH7QUJpzEY5H95UmZi1XiBqqfqGcn6i6hTSnW0QaF1F0FV4U0Pp0wwsMUCaP+9fvoFmq/ao/eXWwuyWc2KQVYoSH1Ze1IhlcwwsyV5ZWAlH3VSA55PQqI3X9G5q4Z069gpNRWEbjIe3hI+wS4YKSJP0e4pr7kC0KnFro40M2uKbdyRz6iD8uvk+PTUBhgOwtHMv0ZUsmcmmnbLECYfi2U3WAlzlK6ldEYYDX5Vq5umv+OMfg8Hfm5pgoipNLwGHu++q4cB1zMIqyTUD6+HcxQC1eXt3mJFMUupfASlQkhanRNJRJtcarj+EXoRoyslzSxh65UUcr0ocqvjFUnYm4OFeAHitV3eH/rAHTLWtNYNb7QGKauVwCQRuo896RMcuAMKoezUic7aLFHsc6wxphAcGIZd0jImST2dqtBrQXdYmFBxX4MgOsu2rUrjwe3ryPUthB0tvCfh3Pvse7vpMdN51pJbJdcITPq9kR5F5lEld0j7d86LtO0MQtVrkrZ+CpqaUzCQj3h+m9/frMhEObJGnIpJpfPrGFatT62vZU5zIJbkYBfDv23/KH9mtVim43jHtdwntgnTE8UfavwFxd0uphNTiEN0OwgJ9nALOKyo2hKVs973WJyEdgLRY95hHBsJfa0DeGyRK+5z7CpWGUzG87lfCWYcNNwPzyWcS9OxvaKlG4xgEb4IdZ2bE7UO0+hMzevCcsyXM3I29TUphPfdLF4uzv+0FccYd4pmtLa+w4DB61pI9KYu8idfgLZDUg0Po8dH7u5FZieFB9dlKAxz5F2/ldw0OGIZqFsOCxLHHkyjuccFXJ+o1k6XuO5k8KwrNED46FkobEtcAWKUMUXwHK9lqNe1FcmRg82lFY8JRwW8Yb1G2hLDNXQtm9a/4BS0CQH94Q7QeA+6kEqTsTa3RmqCwtoZB2NpSDYrBEKLEa4nLJtQ5FigdUNGkAY0F4zWaP85rXMoumqBl2taef6kpl9ek5i5oelQELsH00TQ20zG2HLz90Rh8TE5PYRzysBlNeIMmsmk2yGmcDp8kNDO3pJkiuPh3NGjn9n6IO8fpUjvrEuDGTlQAh0DlItk7gbsJXIWzDp1KfzvKGGgEbsRRJchwLq+TGJFiLEg+G00yIUD4qbXYQTEEvbFvy73m2dVmZAx4QtsPlY6JcRHp4wtoJ+1Ed4Z/NqqRCQidpbEsCgBlXDBEtHp4ySojTaGWoUS7UoDufEgWZFn+e24PBxGaksGifSDwFAMZkdUHIfy2SuA7ocprJL0jFhMUv427a2kwCLtOtOzYPMUOlelR/EDLIEPOU7Ld15A/RIkFMBt9zNDYysDOKhY0XKDzbchnuJ4tjE1DT/HecnBvICWfR5huN+Nbu6cQeODCBxdy8HtwAogdSWHHGLEwXqtVaujeNSPp5NVdao7qZTKq/ECLSQM2j5HFOVoZ/lKhjDPceC8w6+LekKQqd2V8tgZPSY89ZmzRMN7YMcdUZyL6fCCH0j07dPPBOzMT+rwqh/dUBByttgw5clQMOrp9OGI3rkwxsje/fo/fgjoX1wbRNfItMCXO1BjsjiCquTmHGDBYpXq55G3GD9befRDT3xomTbJIYVYLOjg3GQAqQhbjm35KiFe7u2Q0uxYw+9S6HtxlyTmDA/sDM1+4ngf7+7SfQKWSywopQvP8U3naTWqG+dVe3l46VzWXShGvG6wd0QxJvNaunHgxac5FFYVCO2PR7j5KB7n7NfAFPnRbf17VghmCr/KgE2RDL+hsoHmyKhz0t71p3n3gE4ydKOl3lqt/vCPXFecnKFu0Hngk4JJZEAyMlqv0I+3ZRLxeNukpH1DynQJbQZvdER6z7rWacEj/tUEAjGizTxFEneNiZKH9QQDzJcaLJegdP9CILMGwPPRq/z7BMKsJ7KGVM6utjn9EdpHHOmV0uCMEG/EVDHlNUiuBMOfWZI+MRM6fAAdJAabf6uBOBPdS+wwL/dVXt9joI8oM3QWusfTjia5jkkLAHQrImLdG2JRp8DuQM/BHI12L1id+PmV8ijvLoQHAaNDDtREIFV2bxP4kUBHY4bq/3Q7kJpmToljaLlnaQwIlI9RmCy76xnvhFvOrWaxoHWG4gQ3i1D00XOiX3UzIcVVdQ5E2jfakbQ/2lmrk/H6K8aOOfrlEAPWW3nkN5QLKNUJlDMmk/hnSlRmPMvc5t2Liv3rb2J5dW8rT/UJHeqqtMjvNAiohCOMSac3RkiiWc1ZzjbcxEsYVxhz93q3ZMS7g/KbI8UP5/mp/buxXnZswDEikczQyg5sC60a6Y5doNgjwVGgRgYFfCBez3J4rrIbImroU+iY+/LFXeWnMxG9jYC723J2Pwef8sWff6FKNhvV3G7uXBwBvc/Q+rAeMuCuVUFj6682UHckiPMdbS9N8lxBiDa3oeiSP/PAq4DOeGRiSpXs4rfa/MKefQixMZDTMSMCrVy3PxQGXvQz3t/ve3vHsPdmVwA8uKcg/KHAgtqnCLL1k4sMAogGnRox/s9AQ67DGVjHyxvo2cyblg+YstOHYelVdiAL3lUpEh4itF2oNwkZnd0tBDjc9/zu9BzOdDffxPwa+eZo64Nbc4W06YCOLnpHJYFsoiD2xZJ7IpAHDFHDQqwhtmQTkIDOCRTl08/+iin+PcuTA6kB34RElEss+pp2O5OVSRdgaxD73JXvldT7dlhq5AZNHo/82A7p14kzFOke1OJG+4KYUllCZj+oCDGTS4qOXajIZUaTueFSHszuGEODrgKEzm3ikvd9+zmADK0aTTctwQ/ZePvFaYR1X18N6ktXPQWDcWO70ndmWT7oEHkyGYl+K9fVbx+ULZjof3AMZdjqMPExByl9ioGJv0zCg0o/giAgovxO2NuKJbMhWgGjYIZWgy4d1Ops1Eoq4FcE7eH02fnbn1amAJ9x4UX5PZMK9/PyNfyy0IxegDRszCeqR5zbDu8EeaALDQOPs7CUxsLUUW7/QrtUPkUHdvotrWR7hlxjqvTutSRiHFCEm6yWMcEg/ehsPhRNntC0tHIamoqUnfPq9xrAB7b5VsFgwuJ4kZUgwsuQKHI5mLwj1OtjpjHkTVk7HTQq1q9HxVwCsV9boH2Jb2EJRqO9QnGG3ODUK4U9+bjifCCIuJ0Rsgg9z9/Wu0k6nkJLLkfZOpXkzRT+8PGQ5mACNScadyqMnpaImFFfqL8WK9dnpX5v+PN0zmpFAwXj2c7nZ5WkZ/D0KKCiqbDrQO8U1x/sTZZHojbQxGs7x2V4MHSXrIXbx3yrgJagnI63UeW1V+bxs61DMlYEpU3fyiQvEl/QgYwscNtWq9TxAsoNuDSwhK8JVteihZ7zmpweLNeCxiMPvsHoq3pVPNnjqr1JWCMnetZMxFn7O+pym6AJZ0zPs3w1Bz+oS7bqw92IhMmm5FSKtqKTVrv9ead4xVidqCyrDSCKBKUDLag1uJoryoym9vJ+8h/7qOZdVKGaL0pdir/bPWko+H7TeojXHxiYqsHr48CTvNrIQqxVr0+ZcM+JcTvvK8rOPMmSzg4ctwX2KSvLEwbo6Z/tw7Yr1bDeFgSaIT30nGXu8uKmufWOTs0R4RLxFFX6ZDlz58SxY/dAoQavdRKDrTmjN3AFRZ6eGb0cWZyjgTn7WHtBGsTcwojYstUB1s/BiR0jTOa9Ubl/OILOMybeIaNA50yvUM2U0dPDqyOQEcAVkzO5Qd97+fQm41OPJalVPpmdHJahhmh5+G8zH5fipouZJVf6WMtUpbd4YKBq6RaByzTq41cZZQ2RiuZVOUW7VmKy+U9g6h4I5rEQh+6rsawzMMxdjIdFRh5hl5iinM3+WXfU/uJfQB9ZHj5RZ2uAL7bwNTIk/HN8fp2zRVfbONo1L7IzO7pb4XkLyykBXbucVPp0v1fo2/2lGnVM9hAB052SuH4jtkPWHQarXZcmlCc45mexcUtswJeuPusASkB9IeaJCZybgZjiayKTV8nnT4P4WKThhkKGn7/Cl/T7AdANroDVIlMsFBwHSMfWOuW1W7mH2RJKVdxIAcbyCFnq8YvB7AyaHsPQGfp2djmZNCgfb/JCaQzegC1kd3KoaAYZemNhMUkyntnfB8Yb527GlqXnbeoE3/qzT7dH7ZXY3P714CmPHJjx8gjV2mdsW0N3C01TBjuVzpG507lzucIys4Weq6zWgGucmDGvh3fM7boWczOhUsCfQem3R++U0EYCMZquFnyDEG1WBfgLV+twssBFujx7uz5g0JvNISp51IYoS6w6h+yhwN1+mo1y7UHfBksUfBx0Om3w2dS4M+subPARSnVaYZzN9bvCpdzJH1zV58mupBybG4+AogFYjovXdOrrzltAJ34/0wbx9vgAxzGqwDtSMdsPZsTHvDrfclaJ6SoF8tpDfz1cKXCfNFfgsakUxIzC8xWTB/l+dKmRdNrGEp3jH3n6i7eu9APobFr8P99LIB92uvF6E2vCvAMN0f2wgg/Vh8VoiJPia9LMOZy0u07TTf9GKsVOIQLwta1X3subcaKl7GdEynxKtzG+exwcIXqFm+EXCfauJDZyj18Iep7VN13C5eegx1ParMLOEyRf0BilrBXCvY11YPpSan5pry1VvyEloya4MyG1A5Cx8qGJ/3/HDIOIgYeRVpFjH6IP4ZLohkohy/8sFUvH1v/AUSrDUk1HfB0Cz4s6N4D4hTQ2CFX2vODFikvw3rV3R22K13rNyzSG6Yi7VSx2JPh1iKV1Zb6hgUK64Hnxx7dMnxXJ9DyqwU4tNHSKO7u7grG8mE5uq7k0CllcW/EM4PKtZRYoZKDh8TMZceC2ndYN5RjmxEw8TEWkYrzqr0yjw41rTQ8yVE5tXJiv+Da5xKbtLJWQvyNv1caOHh3mDs0eXDmth9l7kkjZrWhosc+7Prs/l9/alWPlxYZHCfTnB3ReMnub+Jgji3G3ICELTPLMcu61f6KHWCAiyq8qYhmh2keJguQsPG5SdxvhQynODlUB7SAPAhUjuU6BDBtXLb2U+g01fU/ywlc2BZEenwjm1TApCvMpTTxzyn8I8cOkDw++63mnAevwml2EldBcTEeQwolpcGtYvbTXftrT/rn/EzF5W6tBdRLFe2pWvDgGihdIUtyAG2XvIiAEubw4mq3lXCSTtwbv8cdziaaPeyvoyzzNeo1YRGgWFRSLIOcAlOa7TcGaeklkYAg83e5VxuS+bz6EdNLB9ibKNY/6bteiMIj/kPx+jTyX+jgZK0hCPsO2w0XZi10rI31xDQyh/qBgoXmKsKrYC7RyDIfUvB3CrWrWJy/3MSJdOnJOr8THYKWt0cUyPBqvUMAr/x6tzwFojwTHWfmqtPN2M49oaJ0+11NtG6RWPwFXqc0zVsemY3gLdJz8NgoqKcHiR75VISwRPewYw//xpyuVxahnbtol9ueHQP3hPomVcL55mJO7rz/QClESeibclZYhiTVV60WxzvzBw2Tr3JeqkTUgCjezLafE9ztuaXSb0v5SssRdVxCvlXQsFNr0SKiErCX7I7muzID6J+lzcvJC+5jPX6YyDrmJQ80By/MPOGlJt6hsF+54uDDKlMgfhFmJfmbu/0ielxFk+o01BouCmSluZVTRlxCKda3FPRbij7kyW8z4PdFpFSmNaY0FnIYgRLhAlp+6WMEda9erc99XxPaV42MGK4CFSBJH7O629dI83tc3YZjqhigG11h6azSI4PnjKUJcmTC3uSTCsfLFXh3W5EMMESCPxd78a+7adhuMKwayhII+WHNgI/K+aNCc3wUde89lPBHkgbMzWtAxK2xo5HeSyFTUzCtZCNxEGaPAjJmBuJf4nA4Mu6sUv3+BAJ9DJHV3AtQXuTOcPsU2gdZwTvrGxq8PVPiTVD9n/wjWMA8YBq76O8SZfTHggiAnqBEf4PMm/iEi1KlMZ1TlgE7kWaEChb0Atx2bI9F/lxcWR/WrVGePr4Ap1KlabmyZ5EqojOzc3pAMwD2WXRmahU2qkFTb/QUaZz3t6yChO402he4iRwowi7pP8LVcQqoqTkp/LYmvwdjsq13mHWWoec2ZQNEuavpizkcAcZnPAf8YymBN4Hl/zPR/NpqWUtNcagtCJrgWoFPyT8Q/ALNEzV8rIOnGKUKB5RGdzCHNBbl8O8H9kFDAShA8p39+Et81OgAZ0af5AUbcPiEOI14QAxW07JFy4aoFjZIRxv5bLmT0lvTM1rGjaMVmFKiJihESpZ/xmH2AiJSeUJQX3zxd2cYF5kd1kfj/hh7A3OSkM+titPAcU7NXsVrnttSb+5leH/98Myg1nu8eWTjADIx6G303u0Qjjo5yF7Y9PsyrYpV57oupIoQyozE9ZZwId4tFaJxAg6jQ0U4yPIZcDFGxz25XWHVPzUHI7pdMy8blyX8L4M/+SKtwAIxFas3Fh4xbouE+VMWqpRReoymheBZnyGoeTF0bXHu+dQukMPIIFamiuq3W127gshpZ+mG9WjDQieXC0IZq4EzdNnvl0i0iKowdJLRHpYahQpzNb2qQXSeZJrz9QsT/U7JAZ7C7ABlkLcnOt5eeUturPM3Fs5ple2k0TUMT7KtQBmN8GphC584sYUSZbUApqgACusiNjXZyebue6U2Vo0w/Qr4nKR4Pz/AEpV0yolAYX3bJ81vZ/5I6Kzucs45i0bg63zGUHtTN3aCUft49z41TgAHpLzKXXCD3u7zD6bgBfn59KCXjce6rIVWl/5Tu9GalTztpupAhdILRWqKZoI6Vt8f9X8DE+hghFXxYaI20jGLwTd3CUce8m3C2AzA0gjcuQ3rMZdHkjwhPPf88YH/dv0ccOsmZuxaXGyUd1dpexU60GVNELdQLvd/E5+mIQ7qf/bKOfmGfxfWZaU1neUM5oFNi/k9KU5qjM+Fzi0HRdiQnFjgKtjK12baV9wn2WrN5Sq3eIAjrQHvZMfU77SwHtBPH9uHRI+uovYUDLQyXg8SGk58bc5o1oyJ+TkaJqutrwmas+200+lNtQXM3qpN+p4LtV+vgnY4/cd2TQyf2JuBpiVxhJzQ1BNxNuNLi+Yt3Rad9hgjdV2mdTn5wx1VKkFNANPXEVGmPSlLWFeNthBEgQ4JAmrI7x3PWVyryPTsWqBQMCCa+XbBFZ3RuFEGMws9XsaufRZsRg9wYfb/XHX+1Ov3GfiIIOnsJabAj3pBCt/dlUA+6++Jl0cIciRoQNILZ6cKfzF46w6HHfYbNayPgEdZKAn2u3Uwes4XrOtBOYtNqkz7CURB8fyIGncxQALFPYFJ5OLDGTycFCMIp1Hahn4QpMIef3Amk3wF8BWocTA9SETzoa92ZEEr2EGY6gugKRa1tB8jNaJySmH6U+g4jLXXQ8kNYCwzZENcMimyyOO5XCeaYW8NFnMn28PUFTgTfaH75zcwuUJrdO7dnzaoJvq50rZwxHN6MVb0lT65ITe4/L3HEUgeL7GPmn6B6PN2xvBNmi9DdSyDhvUB5VS/Tev/IsM0e2YTKoCGlSJP8xEIF4YNTgTpj7k2rmaWCbPUcd4PmRcbYQdbAwAP0JFvUsyW7c9ZAR91WqAgCG0T7K6wAL/l/jzwe3okVzh8cK0goXGK+DsmWEgGNvPVzI91lJOJLx6MTemOVBJRYgkVcZlUD3Hvd9XfHTXzM6KFViXYtzAkC+EaFcRHP5SYGXZ9K+WSBLKqFp8TNb5rW3EGtQxZLJwH/TtPFFn3jrIqndmii/5KGGLo6c5OQ4kGDP0MDmNGeil6/rl8ql3yO0wpw1Uq2Gqo1zYwuNopXEdft/McqXEQANYbrclLXcrRFPrvjoDnp4hG6/gmu3k6xx4ZjcNEB9jXYPC0jWMRHEHZptFmNCMl4eWiloqsLvGbEolmf1vuk1LcdA8rDTdVdEjC7Q/e6CHLzQdGEI87zMO0Bui+39AI9DC6cHWAjk8eMbBj7ajWu+aEXu0KG7hh0qnJI+nabar+EvyP8iwFwJB1G3q4w/KaXJYwmRZvSIQpqVEQo2+MDG1SrK/Ny4G3fefDfkOsjJw1ELCimreMClOU4g2rmtz8paEipQmpWchBWW3ME1eLtfU9KLQH1Pg1cxKQezYShK5yLdRbKvyJn95BRPBoGhax5QaDpuuuK6byni5PNR9IrJ9rTY0odhEOEWql+Aq1A/Ux4n5BPZWtKasTP3CWXYlXBHQfc5u3f9rsx21GanFA/xafPtkSrB4uYEs2niYHEvy0koCW1mFlvgWCpPe5O2msM85+eeFKa3j+R/6Bs+ZgPE7ayIvVH2ye1WpiaIT1HYMeHuXM95go2pn9Q+xu21YLXAM8NJ/scepFuPiQjQwoK9+l2B27oS604dTOUtsJxOrTCp+54Y/9fQD7klcKayTQL05jsLXUZPh+5HBzIG1StvPXN7rIU9czm6Ehjq2NwiCUar59LpF2Vo1C55DE0A4jADIP77GaWZp88xlZiSamUyllBW5fBnMrsIDAshFoxip8zBdeRqbNQSDY8ffhAihXdSL556hnyw3dWtwcOJ51Q/2yjAg5SeMYP9TRdEx7Ix1t43l44b/MOyy34qoUVNaiMadj9d+QUZDW8ikyBODTzuw5KFgTKQM04RwgrWTzBtegiD93n9AluMF2cwkVGylh8JBgPvCFEIRYgZFq0I3VtEZ18ddFjH84njPWsgCgXNs8ZSeFQ7mIJFdoGv9qqalligEc/P/t3y38Ub5tE4hyCxO65CXW3kF9nN4NLriXYFEscDZzguZ7Z09TWm+m5n5xhuDOFTEfMTrlv5rCErc5VxaH4FFNOczqtVD/zW4ftzD4NcRr1fC7NQ5JFvur13T6XrAU8cVCng8jMdCdc+YiM2dzgLa2sIFqmp/NI55O69Fa0c4K9uq7nCrRROLOM/7O97QMkt3nBJEwvzyv1CUpNweZfy8t3OzqPMRfbecEVtdHdpA5MEpzjPhVztgY6e4c+Od5HSr3FWfOGPNm+ors7qwZZPxoBL0MSLHmdU/drCIPmjqmw3QA8jjefaMtKHM1TIj5M9520uZ8pdMYIuirniynagPJ27+yXsQwMyQX3DURWXviqJbHOQK6sThPYxF5LpPSYBm9+xPT7z45kntWExO22SFWOPRje+nuFEFfCAIbGQJ1p6j/9jCodpVSJIyIUcPQO0dAVFQRhnSLZj1RaB2cOQ6QaCTROCdY6zuxNua+fZ90oIfix0bkOjlsYvs95dpcTCqdXgNf39uDKVOPPk5MnjSmgpQfv46ObWlq/u1MjwFyMSJS+FG6pFTDiDvPWSu00dSVYA6mgHWsysJV1+cindcnxIvwOg6fJ6Li7toxqY1WFprVvPXuI9N1cTxil6LYxOzOAkby6bVdGbHRx7g0w3R5B6iE/GeFn7fHuJA4myUK1DMo4KBV9/AS7rC96nI7/fG7iwra5YPGpmNNNrTuU/I1YWneRVVmkkTIybGnPGPE5Jkv+C8ocZ9up6TXlH7eFxbcJEsoe+3KVZqKm4xSLdCa4abg1dgo6488+uEPL1iqkFQJ2ZYX6v5UcM40FqCxf2IhpPa85AQpeLRybi9iTgMUFq/MHVdDjqBfSGtleapGp4jn5qy0ZQNvTPzS9cWeMDGhdz9ZXzj2tQ1MAi24JjYb81w5o0MYfN3ppx9Z67oJ3J9tB1CUdptPV5uS6kgdX7oZG0FMj/5R5z8643JjPILhckuNaVBcIkkTQYdwDV4W6bWqQGzgXNm5eqvD89nZFgDkNXLW5qzti4J8jzEi3uAbveGO/8h0fzAdxUKu7Lw8CqLn493WRR3KjJTWNXNXpAgsfXH04yr8q8/o0UkfenlTs3kHHhblVqIMNEqd8BsGxjVtfWxl9LyyR1QdlkZRUun/tyvVD55mc1xLXH4cf6aGyR5M0A1QD0tn3EMDvZus8CooobJTDLkYhwmOqeEcFnjy3/4Tg/AzHiRZDGys6weq8s37pPvtLPghmFkVP7JiNfXlQbZUnd7gUgTS2UYD2FZGZvsWk4MyvcKyhpfCYJO38PqxGGeoymBvHgnjxmCIC5d4zU+Wjy+U/z3DyirJVVPOl5Myl1Jem7hXWGSQbRPcgzqrgOYZJWJsdJgM68hpfiNt/6GARcIDLOLR6hVg9mTOLZB5GNb+bYdF3/qWWP+EDTOeGFpStZ3IdFBts4XCNTduvMnLHFIT5ostNW2NvpNwR4nIZksMJbkCGk5WetKayFNZPqK3JK3Th6U0PPVmakFlhD3lttXyEdFjxj5m01nBMmUOd2un8PjVhL9WYDjMitB0qpc28IRsrc+E3bLnQlIutfzM2Apg2EcACvOV93hephYENnHwZ3u8u+AeAL1HfYecrXNPB93jJRCQYJtuQ+Zo4FtZQ92u9plCTS7MNEbyI62bR56IizarGftf45QLuCofhTo+uRXgjcnAOsPV6rZWJy0/F1UMuszMauLcfK4G1Z3g/GfXh2Jb7gUd7eKUfBi20UMSZclA6txUaVKudQpo/lK0clo/mSBtwk2COeebn+LRmxvGXeMIfk65jqwh4wBwctB5bv04OwNr+C8Fb9dFHMuh0OAVV/boUA0rZCAoNcZRKGGyHl1+rCIOJufMxi4hyiTE5sp6YnR0jXYFsaGYCAV/EWUzPnbSED87G96+fYhXblZaYXtIXTgy0i/K5nRmVoz8DvecKbLys1CwigmpFCwxv6bzmJcd4mobYzRWVxLx3Ls3cJvr5/Nkuoii8AvVBSUIreSc793ea/tCAbuarmlQ5vxGXsDiwQIVJqzUiTm4Xl2dVoLXlnAoKo11yAXod4g2vaVknUns932O1BsGhWva//rl0Gexceqt+1JwIdchhjvKGfcFuk7MMgoHjwgSciagpP6Too/wxzWV+6okQj42clYcAZsUSfu9XWb0a/5yex0lm7OTVewZGjvkiIBPaSNWXKqSdDlEu/QIKLcmduvzHSS63NH+Nq9TrCsP9vcjkd6niNARr1mvKcoBmCGO3x/zP3L1/r6XS2A6NeFWD20yTNbbreGQJdxd0Iiv9AZ3FH8QCpDWMxaTAHvf8QuhZagZ7OYOWPDfHP6Q+jWB+IKS5eOAk03ARrSHGokoUAhiRm55EqDhAutRuxpDIBW6K2SyfJv3pbZhGMGcmyJHnDOpftzTa8DR+CjHLfWKy+prvksv7i83j9BukVh+H15OWxrh1ntyUX4FfffPA5gP278Pps2OA9G9WX9WXFoUA0MrNNR1rtHnB2sndGRyAE5ueLJVgibi1XTSbCMRcxCufN9I7M8LOFwRfjlnK5KLEcB55D/TuiNNguhoXeEbJElxoOciiLVWGgh7g/yPChbBcYa85vAp4fm3xIb4ns9JQvIhSlNOc+XzwbuszPIJwVxipe2Ql/nUv1sAjkqxyMDMdH4hU98TSCh2VGYoDWjJKtmYSQsecO3wPruyAyWv4s5quWCszCjg2+jf6YoW+YJ24708vk09AkWl0r0a9LcbeG7idFNSrpiXBgJrSh4cL+sMh8c7nfTk5SqtfLohTadzIsyhjeWwrtWmpquUnfVvptkLCJP8Tfm5paThbzF2Dy8gY5XmCf0RrmS8WqlTv8j3IQUB2vVWEwld3EGIe5NNdi5ldz2s11iBQ54IXx1F7vwZD6T6q4iBFUy/+7+3pTP5fVFal9rsEzu0FwuzgcO4K3cBWbRcY0WCJW9qcBzPd9w5cHcOgfSQYNgK30nq1Q/Ua60R64+0laYSAgf3VBbT6AdqPO8PjgvWuV45KpEzVdunysD/YdkgftalVvz8edIfxeaVsdkZ6n+eUlBYOib7k45JbGfIIiIGrJtVuRteutQ85d0exqbco1r1rNAKV5bTNVlu1wX1gHukQzAT3BWmVPyuk+ZT+9l/TkKRIMzybpu+SQ8T1JqJniwvJupVWEZiTaH8wCLl36agj9fD7SyhqEKPX+ZfxQ4eJz8OxWi6IIBe8JDW7+034MoAFxu670ZpXdSnGp9R0LegNYbQKCNmUCuvyUt5bey3G2sPot3ipLD1+e2WCuXFcofY49xZIv1h6rycf2tdgmWWUa2sLUA7yxbf78oqdbRC1nlTIPYMjLkdE0CDs/3e1rNRut3nPxvdLBA2+vWg/LKvvE1OmyR/xEmsg8kIWpO1J4Pj5ko6I/Eb95QyeCldNntcTZDrlj9HZYcQvxH9uL9dVYqQwxAxV8Ac5F08Rox5hLe2PzyWEgvMxoNKprLmT09Kol+PTKCFyz40A2+0s4mVq3Kgv2pSCGhtw/QWZxjyqFk9sx1qEymlFPxcSRoBBscJI4zG0yQn/kNjA4Am7tzVNnvSWNnff8adYNSZyPf2Li7bYhvsEvZCF99WY6y2Xuk8AjW3zyjDRHledW1ZAY8jYzQBNerJ6IPcc6eG9HqN8dE9SA2rkFP99fNzzeVcXk1xPuPJnqDwS30m/oGEiP36/uz23APZfEpwLwIxBZhRF3WTmtTd7lk0qO5GgTCoSnnE7tVderMvI0Ajv72pNWJmUDXTw/clk8NVl99EQZiG/8OyFEj0dOAW5sS62orLj5HEBcOQcO3vzfieH3h22Z20AA5JsHF299TFqOcAxjUrI8xaiNTWWVqa6Q4wZQFLv7Ox7lTtt3IpOx+miC2wp7+c+nEPI+q0oClb25ipPtGffZZW3SgC66A2Ho3Ijgd1pMqj9Hibztdk6ws8u6fY7or79dEpZb8eM/OTRVt5183kHSyNmBP/RAvxvDTKnkEXZRg1+2OvbAAK1iJ8ucjguS4JCa/mBpODRIU+rlAiTGZn7cbJCAN70oMMec46jSLRa2S6Q6yoSUrBeuWQAHgSiQ4g0WvW7A/OQKp88B0uy4eTWmo9k22OMywctaWlti57q86x0fjqQOKhZQhDKSWaPUOtsyiZdH7/SHBc+6wdSCJrsTzp+zssrBjqWcMZPxr0oBvY/rfQtl65aadIsQnSPA93DdeRfOjdC+6a/4mlNflZtfdPjYIWpExIDLbw3JRw/VnJRAry0g0WkSUAfwBDxaS4egnNc7WLjTm0Ar3L771NUGl1FaQWcl5MBKTLKKUDWDfuCkX3lxzPEj9vQ1PWG3YI3/TV6qWP+blBHSxUR9Mupbk79SREkx5ebVZuyKdTKC6mVzEJwN+pT65oVTV0T077CXHnltY5ru2IsYvM//Kn/1SMV52ONqO5nR7VpdOMhWUACq4dozhFzpLXisluYtZZustEqlNW2aQc1umlKXvZw+t7WxqRAsubioVR/ncsmqophoqb7XDj3Z9waGGy1R+G1TVmlEZCk7nIt2mBejXodhkZRuM2YAPKFOLkyp55rFuzmjiZ+JC6ICvaP2lzC082eI6zN1mAkehA2yb2E6DSy6BfKFp6gPq5JBaVqyQNPSdoxbRVhbN0dnx9MmhZu/lcEZV73w7FqIVt/8NHVFLknisD0JPWXOKtYyDb4Mx9pQLCKnhqYl5rtB3Msuersb9ln6bQDdRkjgpiI084mOZEnuuHl9V8+RbgSS9YjRIun3zebmR6XRp4q2tYr1QttA3O4EfiBDwvq2i+xwWqDt8+eSJPYApYsZ7NoMgvBx2PPRgE6HVY69QAYetmRsNPJqfStBWgTC5SUkmP6Cm2owR90KdvFip7UcVvigbXmqZSdxGzxJ0gnNCVEHapGnmAvrkznl/YvzgLQEQA8vKO3Q2Z527Q29jpFC0dTzXZm1hIdlyDP9HSvMTXL5qMOcPuJlnoHbmzXxphuy5pPvHSIxzh1UlyQBRQW5pwaEbMYM/c+ZOvPMa1/71Z7bVjS1sOAFCroGzd60X5UbXwRqJjFK2X6U0LkJB9qLrS8qMjWySBzzt6Njaj759o9nfDGeppWE5nWjxqSUWl+NJjqMJ5WlvFtZTg9lPD++CMDqiMvATVd0Y8g8RnTPFBOdZg6Y9oh4MDa3revPOpXrqsZTQQBHZXHQzKyNR8JZHHg9NZeZch3axYb4KobhewNAegV5SqEaItKBdQAH+ohjfuYy2RdGCcHkruvmt+kXiA00d5WNKSNY1PYNPNOVMunZALAimGdsKEVAjI5sDBX868s/EdTexN0nHyPA3X1rftqV3xe6KVUpkHTwW7PGsDOf3pvh97rFYD4pyr0JsWYVkWNdsE5/HQSDUTci8cDNpPba93k2VmZWyN6FvyYrDlZPohHjVfFc5ioOXYcgMTA5QGAoTSNHtlfruvb5VkrBlyY8HLnfYmOCyeX5uFYgYoWttG5GYzX0khjYbs/J//k0x2w6gyEaEvViDD8L9tDBXKrdM9PXFA5u2KcqMy+tcbD6Z0HNTWgZGvK2rR3Zp3zU5m6d0OyjkbdrAlPgqNEivKwtnQ2L/YbRXWV3ixPLzZEEhqKkoC4XsufLQ5ee8zCKVRptaI9rfHB6KJVTsxk1iCWSWo9IpOhxP7jY+6wqD6Z4L7ltY9GvVRHKcFrCzEtKn1siDfuvw2hRHnROhlrvjU3isbdv2KBeh+cXq9eYpksZjRzb6/Blz6bbcChBih37TrzlDljKLbz+TvzYQa+ONreLpF0UXw/tDAZNRINnmJkU94h44IuEvfnnjxawfkRaDCZppkqQt5h0pHz6s9m18Bs/i3/DNr+Vq6Hrn0yLRYlLOr31mC8S6vUAjmN0KcA0EQp063RjdlPaEbnWt38xVh5RG9eBlywEDt/UgeAvVFzop8Oc4pzYc6au81oC2rBDmBZsFXm4DUDfH7cMdP7KiljEftmXMHxHrzez1r++Du0fQ7/rTt/RUMVwYdFx7QqTuIxh/5j2k90BAVex+MHXZRZnKF4yw4mMk8JMHkMK9fXwBRoOm3hlLrLZrTz6omLneoVFqmoIWo+oqC25Y9dm0P/oJSkUYqB5oirRsd8IOVQwbEFHejfIMpWmxMKdql67d2y6La0X6a/DJlbWyPSYeMXAto0cJM+xH4lsnWjk/wAtzzfkaTxT67bkTuS5iEBJBeidZK65Ln/Q+n/eYXt9y0Q7D6o0UKJifJiwEPAdvcMtIucYIW2V7zskagnWjZ3zD4FgnNIJtVNyM8Lsw2qjTUJk1tQvfacstNSaYcHTN3wO2JyISsT24h0EuGf4pVa1buK4DgD0XqKBzwyronbKOVpPM/0feIxIGBwiOFE27L1dLnDlfg0ktfdigLM/JRMHl77GpHc11UxYWZRnC/G5Y289sibnLmqX+k+epdAz9duIa4pJWZe8NxEILmxXj3I88UuxFUfUjVv+kG9CVw9d334jEjconswx1MvxpN9cvE5kitSNikDiEanNMRg0jrzhMteXtYLvjpV8ZWfgfKxTorVejVJdOoUNpzkVOePcF5gxJoUt6BorD87WK5NFiJYL7EYcxxypi5Y8fPmMZwpNvAYSSfOkL7iUCbOjH5qDdKZvmW5bRgXfVgwYlMwAxRnE2MF+uZzkoeR1U4pdJJxh+Nd6bEC5mbwGHSx7ROB98IepSUgB0fPnppFEOeOuLzslvAclw4Nd9gNJdL56J2NjQ3YuWt+UnFQ3hCd87tGD9YtcuBtINcci79KlmdvvM50zkaCf18Jf+zvo/x4O2TVfPIPlspHhtsnYmUet61bbntBg128gKVqBYGl40EkqbF1dBKvdChGnXjOJ1rMNnfN0UCRzcLs0Jddf7WmAkCjJn003SlVHfQ0MDDgTv2jy4l2SvTG2fP8S2ByLfKDfinIBltkRBzEeqHuP2PbxoNR35LaAGdSFqlMBBusE47V19Ds4Bf8Di+NZiWKEHFZQAPgmlsXubm0q/Iexj2mPMD/mZfy9A5DuW87wMcm1lXkNdu6IBkMdtjsUCDyjUoWYTEzTnu611eoqvtwvfgPeghU5uSbEK9xdYw9IQsM6WvRg1ZAqYQgdVYNDtfhKvwu+cuHvQGYWXPbCNZdv/wEg05y27kOaan+Eh6kPsT71/m75bK6bwGJkETe5CvMiC1xkBRO2ckhMCEvN0EHI7EjEi0ojRNUJKWZDYeQ5eDgmfym66aqHso6D+RgRv7zNBlmjPLj9I4a1+FSXJ77s28t+ROXB4ptmJPODnYiBRlPu0ReUL+Wg6AaajjLhKSqNzg4P9ycUFIMCLNW49c7erqhnOTuM+CDTqeCnbn48YPOTNfZnaE2Pw4zOjnok1f5RU/e5P3Kpg+CUEWn0GDmgmnkfS01Vm42nVRJPLcIGAjeaqytd3S/jwvLkBdmKoD7g+2UpgVGXUQQV5nbLyTVKPv6bl35DHDQkKpHN8nwrxp0vcYfYMAf4pTNIaA3beS47JI/nzt3tpf5AddQ0jAxvlyg+Tc2uQBtCKWr0wLinjSRLUpnOMHombZwHopg6Hmp3zt6TKz6AKq+Tog+1X3cbKTydCR9L4zIe0XpwZguqury/NV988GxfpTVv/Ukb/mwYtaXc5pgKrIDd11A3QZb7jXQ3OSTsmQYCFwPxz2ISVKOLms7rFWadCmmMHG3rvgBXRY1+i6N4fPQAGDprhZy8IkiQG+hOOLS397VQ2TtKLPdL1O+JNGwYcQCOBqqM0YXmm9f+b0y9HoZt9lHcSmKpkujE6tpC6YNJan48iPDqlh9KiKctGBEwS8yI5sN5ZUZjV8keTc4KVIUjpIFbfaPOWLhk7VLJVvuKnbSXp22g2hd44/3lCc3n64fklDtuGhSQih3OE68btyRDs8M56xaEsAwj4zXhrk+in3KHvhQLoYZsHrBpgZ2wEpNkLHoFWPRee5P4nSV+7XT4QfjZKVEtCCI/17SCNUAZ+1ZAH1oxdKjGxRA7iYXOPjSrsNDkVK50uABN17NRd/rish91R5b2fuACAlTSsY3SHxd+fPXp+HbGcM73lFkH/cvaCUOSkY2xX7o1Toe/X5XsJe1A5K7p8tYuTu8eLTMisTKlpDnxHu2ZzbqgNdw0EIFAZqMZoAf207Qfrzz0vlEOTBtHbqDo+/JarefE+BKbnzNczNQmBeKwoZaR5FLx1tOvPs7zjwy8aDiPm1pCvz7l8MThzj0cre0OgKMY0qyhfaf8jJaMiJspc5dE7YY/RyjlZoKkIqftG/YIHPb9h3ltVQcqIBlZe1eD0Qy+acpA53hcD1wFVGYQxqvRqF67tQ8Bo3F7q08/wJ/GBWp8f7H0C0SdNo6CPXtueIf9jZjBFNQwKGx78wW5dj86XssymWT3oM9xFWdsVIa5b/C7bywWynnZ3YJjOzyndh2QOYQ/v7Wu6adnzdKlxKXM7oIozy4caD4IsFlYyktnTG7dqpVwNT1fl80swSqfcWQaFWa06O/0no0ksdKWDj0t4MlaxB992DhP/E9l5go4qPmxGeUx3WcMWPKCiHRBjvft4FkqbTSOTZpRnoFCDiuzAIXRRVTYiSpqQCyXc3Isn9QDpSOKFlSOx+c2Mu9AzLotRbneUuhvlhT7upfNeIAbR9b1yACu7oxVh0Nsu5ylkT/s+saFjVdh82gkcjTIDii0Gu8unjkotx4bWDnagA7qPalcgAI3IHug88qwfupgy7x/LHRuZCRQE8MOthnsk0eZcjYVxCY1MEPAqfynXD7czgW6dY5WDS/hNmdzEb4WFwg9JeIRrcjs6W86OF9qg1DfsncXSLbSrRbSYGTZlZEXKbWIZImr7e2NBfV1W0QPf8v5EC86n3CMfvfi2i8NPXIwOnXsvI5Jfva5LPCocZHek6fx0HxhfYZSvVtfZbzu5qDNVREOkJWwG5HG7riYJgZsmpy6czGI6cT7jZBnHGz0gYqExZLkjzICf2odU1ycTBkNeMh61245WCMuokg7cgfOPiF27pgvIv6Fzw2K0uPC0usVEuJjxBtDPJQlv4iar0Dsm1iWNnLuCNV2p4cLkfj/g77JNEpxhj5AKcCiJRtmJ/l/d6x+nUETWrZ+omTEmfVetYnhMBWM+Eg0uVu+UT7vhPphHurbSp0pQVEdHyQFMOccZjy1DMnTo8Z41HxvkZtsdFGxXujHsV+bE15s3sdHBV3x9PRekDph9wPEaey0CRE2rNKIqO603o6v2yO9CU6e8iXRgl2kUJN5do9/5oPSjI8i2eRIXqhemvveVg16OuMuBkkjBQhf/uGGGWw1E9oECXUcQs9TjjFKhnVL55fqYHusfRjoA3Q3qCX3AjbBCa2RTWPNa33xX2Oe7ZyRzB4mUPNCL8g+K89fXM37OhV/dQCBgknD6BNHUYdoPo6JMD8caNDIRN9j8tF/jnS24Bg1tobupwzukfi7qJi0pIx23ZZulEWe+/55k6O/RqTtwxZIQpo5vMG1sTcDNTOIsX/hqzFHhZQPCda7rMkm6TOMRHcziF1hNsL8p+eyBAYVMBxRSSui4ewcPCH2voZk/5U3YfJSQfxqM+Mi+6IJ1xBZLtmkHgrQCmppUOWzAKeUicbhjjH44q4OUyVVmRczKDiUFgiCvCanFGKLsNjotjLsBDbzp6n29f/JcxEVrmS48Ks5bMP7ZAkMIrqachl3BP+5vVEaz3rG2fXdjU9kAgNJqkVTYCeID9BiUizTCFiowi5HzPch6fOmO+ML43rocrYkfk1c5EqXR96GGFWFV97qh3nkvLJP6WIRFfml2fxl6pilAG60d7K2WuMSM3qZDO/z/U5bhsZRzZK5DtVaP1KI6OOF8qa7aX7LB8mHDBsDHSRvGdEVfikQKfaoygGRHtLUxt7V0z5BvEd0+YyEpe4axYzQgDM4zL9N+8WYvcG4HZ4AliCNUnOtIrarb/cwq0HYYHmdC8vsUmORuZUC9jC8zGptHe5E9d1dy05pFaogLxdqI9wGPW8/siNyqB+9GKqHZrUHFFdkWcCgryOR2M/vDqhMB8qi7quEBAw1ga+l/MEmlwUrZqd3MMba26C/SuQxiqA0lF4RXrKCzX7f9X6/XYo6RjA3h1VEXXTGBz7eIuDnLeiaeq2J2hU7eASxor02V1oat2noc2GSSBcauSIZbEtY1ystucx8OulG146mqvZ73TREHRVH7t5VtAeeOeP7ptC4QOLufttRGvBRfwOb4SnnpFFB3kKXPkZBK5Wot6RzR9BD+2EOxrSUUstlU3u99STWkHVBbpuyZ2Ves3DdPB4SfBvdegEPbfxXN5jJvFz8ihMP4ua9Hclsw0Z9wLqBHqVYjcltvZFGKKEDX5+E1/qQlysewPHlla/o2Nny3NV/Y1M7O4n+9/E6r36r5Ly0qaTxJd8t54G7bfLfyNTRD1mc0L+BTzpuDAyBJAq/Bxq2kmorD0n0YJe+2cK0PERATUqCyBmZYSzlUoUV6lHUqIH/4147Y27qu7q7J3koRMK33Tk405mppmyw6fel4AwVE+HpBGL8Z/C11BbKV/Oz0BDhuNRq7ZirNScyoZoMR1yU9diE6SKn6Mp+FOXoFxHD4Q9unotVQ/czZcaA4O/88a1ZlMPpYp55fwxZt2Myvl1NsBgd9a5mlgPvnQs7HtYRZ9ozPJebLr/10o1dVPhlm0CnZuXsXRFdmlvVy6ow55dJqsMDg5heafqO14c5rLqEGQTOIMFdcuRLSBTYbU1nWuDvIU7jV7/KRBBOsusLQYNSGTluqkpRZlPzKTepSmTdsXBbVVza3g4LxS+fqlEyF0rU0TfNMqWTBu+4jR0iYCngBiquuPuBaVYxNlyjeJ/C5i8jXYC/ITFDj+iot7AK/rn1LaPvXa+9w3mchhIJVLBLQFSc6c/o5+B6jXqjuQg2sV9cuMaqXSwqISE+Cib44pJzHl/lxKyMMS/JA6y/y30Vxo7J2TVwHX0AKfmTeF6a/u5pOVax7KFWV3bVHXAFD/W7ZsRMxlWHWfMeg/YFwOumaf2ouDsZfIYG7wzcK8d5vWC426na+1FHokxObyHMifW7StXn5A1ZPUFs0+0MfeAtaPKl/AxHsXVcWtSeAsmClIJA+3MIle+ZnkBh02cA7HbYhiolTreQg082bh76gj0Nq9QN6b1n319/tM9lanKxQPyEJHJtBgqvUbqJWSxaBH8fW49k7dfQnruUqMtCjZubyylmGolCLlOVbQ0T38HElIQKv8E0ALuw4QtKP+MOmOBjhO5eJh8/iX7tl/qc/EQtJCA3KEvuQRgNpkPoMOak4PxB0tIL5TEYd5BWmH/pziGKOIEENI8WxaatnzO7pxFGVcj1wj7uj+keG/4RqMhTN9HLu37mhodcO2X4M2joKWyxNVXMzfZdZCPLcpcWyNq/lfD5FU13Wf0o1Eviqq4ZR2EY90kqC+Ce5dhDqyRwBAfPc2mbUB8lo9eNrkZR2257kP3kjsAChyNDeHFioxo7eSFsa7TfBwG2yu7LS31ib9icdGgKdre6FtWbKvIWGKxtdwCqADG0x867J48g1UUdqq1FTj+IeL7ynd9D2IlzHAUtdXznVEp5kmie9suDARzdzWxX4DaNncZYglb5iVEdCp/K2cm9LyYmf8gq5CikAzzQ4H0Qjkst0W6ykReCfAVGX2bbCluiaSNq2PK21B5mRYsACDsSdn6Q+s958/MwDSsN4MFXdQrVfAkcjGUUJ3MYSopBEq9AGjBL9dEvh+zoUuqOV7K6DDaSVN2VuiUcy7TP7NOJ5ZqdO0jWXzGpJ2682q4IdQTFoOJ0WnO8OE5nEbMTEROwmBOL1DKc/IL/axFagyiZf2KYIYy/aOtUq5j2jIxIyi5kZVhz8Y7qgz9ukY+ViPq3JamhQFQMf1JBMizqJ4gvkmn4CJC1KjQwSPNiDq7sd3CA+rOv72lX7UN9Y/znUW7G0cp+WDLlTBlqOt+qlKZSZ7JUagPSs7ElfvO9V9nEWPdueOB0n0ni3Bi9XVGsS72AQ2LEbZMON8J0wHp3Ia5tVOmlQwb0BaB0CNY/Ilcf1uwpGdAj7rccXMWyTJF6narNJp9P3q0sLGD2SxPz+vxZvVCefZrsloRFKIX22hG4h0dhF9dmCQtu+h2Yh6g0J8MXJWOW6xd54oul68m7p1FwHa2O9GsrNKkMQWaXwvVyfHUsZsChpeBpROusFbR7wkEXDsFhLCcjr1pCa6Xv0k2MrC5KcTEi0vU9BjEFphvxOV6KvEcbfawG4XA7C5DD6spz1cJ0Sykbdt2pxW014F6P5OoHmPi9aZHWW6o2HEHQj9r2opkehytEaZZvsulgA132sFX+/vgEZktJNaezXqynjmAcPAQ68cBJn9cngiCNZIPTcglQgcFTr2LKt+KA3cygHeyyd7PU9B1o974rsKa8Nkw2Fe78s2q30zRy8Wf2jDazVOXsP50P4Mvyz4J3uiMMadzACWYUKGpdKoClt6x6dRIrJjr27sefSk3W6jMsEN1chhwoMr/ICOSWG/X4maz2BNZO2xz+VJ0ffTdahdkIT0+t22gvzcY2ZnCynHOA+v031IQAZXYJLMxFIz9NtuFC9RA1Ppt5QfAuw4T4xpk+OqOi+ny8Y24qivA/G8D+8SWV8aOpDq4gTKhDSPKdi4J+yk4fZ0hOr7qYDwmZprU8PXxY4w+o4bREqAQLmXnxzfcPb9tVumt6clZxMV9Ma5g0mJzVnaQYS5RDq/085dSHY73K26xzj0EGNB77IDcv881DDpLWQ2/MMl/gE6W1ORtAwlC8XOOuxk4Tg4xI65fZKgw2BwUgSs6PVsGDdVRDKkWMbTlaqpkQ1UWyqkCPSAxKJLcXWRF6GsCNosiD/7TyFaPJd4LZ1IwxYR17mRDPnUMKzifhk8zlRqYPo30NNMAJpfznZU4sBemPWDRwZDZN2VgsogFHZeMfLD2fVkrs4a8Z7CfcQMmLmuuS3Uv6Gikn5YzW5BL45bfI3TqenHCMY9tjXAFtruEZaue0wB9ihZgYGo20kOQcY/I6LEMjpCpE0+ALMEBspTXFTvl9GgqX8W8SJi5vZPEJXE+gDS+/ak83pJW0jWzE0E7P0wKBjGlOjawyX8HjbShtjMvxYiDkIOzBJ1uDtkBBKHjNgplJH3iLR4gI+LXpXqwGvPLckyDuuGgDf+lx55DsFfgNcg8uAAF1WyR/olg6ojcZf+5wDehuS0CLa7owka5EBJRQryk7Yq0W0MWQamJgknHSENBp6ZBUA+YOiQx5oZE8w7eNsZ6b0AI5liniTEckOj2/Uogt8zKAuNzv/Rx5srjJaNygeGqsHj7fCDWFm0mT/YU60ZwiYiw6D3zOJ6qBToVW+60IOG91bQ890Mm67kNcxWCN36t8gxV+r/BDV4xRPdaeudPgP1MrTyWWHDZ94oBk90oHthcgRoBtwAfmq3CXmnRApsdyEXjslk/CGsVvxMMdPoTlRYD874KXC+sPSyGu3TnEEfJhkDA4mDRBF3+w+wpGsns5feM6PvW2eILMGCXq8W5nt3Vv5EcqgXRGP6MTd4DxK4b0qIg3ZHGRxdUijB1bX1jOlRVED5+fLdYwglekjwezfiihezIEyrlNF2IdQFJFUX0nNImLqZJpvimVfhSVz5+piwa1T+re9VbtCaTEbI6IjRakjOnZBNZjvAovjRRCnTNX3QHsrta3q9XCsYGEXswjhLeihfTl4EzoMBxqf2CvPMAfedPrB0xxFWwPtQ6X1vRNzqhE3pVV63qv/tMBM5t66sisYGCWyS8glNcJjyOwzP3IG+brikajbM8eB3sAssI9cx0w/SRbWSDa5n04xEwnRdwn3x1x/zeIKsv4Sf/IlAkGxiopV3rHIvvH9/VquhNbvpy+yBZRrDqnoPD190FM8Q8vlKY9A7uDcRR16NOht0MTOButg9hEsCg9MCA8jsuDIfnNnJVLOljMPNIQ00MbstKv+vMNsu+XkaT/ZX/BsLP/PWDE5b49wjDiMSbkPS7fsYsiU0PQs2OAbr7Rz7ibv8QFSUePQLfImY4DBC+8htmM6cZSUo9QU19eG5rczGx/BqnsZAKLlMcpd1DtTC/KObQaZiCnfAzabLUHY9N8y8xVZJ+QciSWsaE00/Q8I3tqd7bcYt2nor5KQr4OTZTffy6bMaKjrD28qlvNiPclBE8mno/VVjHiJC8XB2o2P/niMkhF9I7mIbaqizD+F9LTnAteHxwLS6gB0zB/y3YQt0Di6PijYfaY2uBtViHqIVfaKqvdXIIQZON3tp7/d707AcPqvFWI+gavM07zgpZUxShs1N1t1wQ6F+askwb1vuB6NArVJBHk3T1bNyyixGzdksxKTuvN52djMT+1gxn8FCwCXUt319IECI5vqrcOxxriyxO8b5L2x92cxoix/IlezLvb4D5kJGgASmVPWVtvznguLK5Kjzl+FTlL//b7pF5cXbg8xhGPpUgtLy/dn2dDdZ5o+qGdSilVZlLoKtQRLHOqXZNDPyrGJ06aUnxK1RQN5TfrrPyOAkbJgYG8mOqAcUm7e+SWBXFElEcUaGNXD1gkVWaiBzM+8oasUgMy15XK4tFGQybJV9qzYJtDC5oq83PY4fKf/x1qfmd5xq0hI814iH8CdMznxpAFgDrfi5Nq70tLIRB75suY/uUzpeCoXsfiZKQehfRSASOx18KTrDS4JIjFPwufT+Nj5oikd/JhGw00mkIzjm3Mi/9Db+rmQ2mrQngooFRTgrhd9TMvl3Ttp4CoSVibyjQMRLgKiBNp90K4eLS+QtPBLrDpZHgnytlZFFR/sFagdbSshQ7hBaqwGPdQED1uwFwtBuKSsWKWtHIVWkfa6Yi0Y3kyl1DKMZw8j79En8k3AXfmulaOv3DxpAJHcPgrc1igRlENO+8DoQ0b55um3TfTn7mVnXPUYXF1OXMpWYdTDPdOsTIf+hLoKniR5T7G7/P5jYYymhoa8W/b4OFwelJ3hUDsmPWHd+DhDFA8e2TwMF2Fb2UJ1/BQfcooPPGdid3Fy0lWAeKqfMAYHYTDXGzhzwEYWmFvkU/daqSLKhQwWL2AAN+HZjlJBz8KyP/bez+dJd/G+VvpLE+GAT7OuoAaebeJDziMEQCsIa1MHJYQe+H06IuvuOgHwaLsbSjSPbL166tTSar5DsK1S8DT84I5OEHIk5SoE+aZKTqa0I2JN6bxRxUqnRXmwWRRLzQHe7zqhPXwItAhuJ+7b9kcyiPjfBmL5AG4ePr6kjYyqUdm33rY7Od0CZZ+WB0dQrgbeWmX4KvvDNfyDVhyvgOAPAx0UfEIb+9l1tScncajRnFKw9RgCa9jfl31hz/hevRLA4u+Sw0/BySzCOrJ8eHugXsSVcKFeJgeBazn+ZpSYey52k8LzGu0CSeSvkyRA0Nq+Ug/3Ky/4mRM7qiDvrzqni8jHCQFvFvy6dkqvNIFYe4lSU9L86BF9QMWEziWyf8l8Kzy8dLW1wBW701S0+scIExH+U2MfHMGUpXBrhVT7VoQ8R0NANKS423pmEXU/sS3pmbp6N/CpBT8+a+s9ti414dAzRlteUsRuz5pjv2/TdzI+3VJBJU8fmgDrabP3JYIW7dJ48geao+oHYpBwqiQpt8kBAddTCUxh3d472CnrRBciRg0HIwEXo1kB78xEYGjefImY8zqAPSa23U8oehL5g7UVWV+LOico7THMMFiqbyxeCGW2Lx0s5p0WymEPufdtjb9Hh7WNFTAHadEnNI1mM8hwhOGRrAwqCF+/t8iZovnbUvDhdNUe17/1dCUNl0HyuGXRfY1kwR7RQ/u40gfzFNqzkV/TauqvGq2Qr2gVHrvZUh7nmpwPTT7L71KqdY5ZGnpCob+Zm5dT9t3gZoVuQ/6dT0f1V8JZ1G0w5bMKG0NmpOQgEFBkcR7twTSlrQYO/ZMpZ8OrKt6yvOVYFSjh4j2AVhWhQ/T8B3Xist5FGfrIbn+J0wrOzBcEqfZWfaEk5IIVhZX61Qg3BoRlPB85J2hlWwUpDnspOaH3cBHZXLw24P+6TAEtJxikinF3K6VA50NNLoBU2Z3DvqsT9qRhrQhWLow8r8+g1tp+9iskUkUh1erKaZ2+J+ni0Z50f6aMKE+BmRtdbXF0rbzuZZ7pf9HOmYN5/F3EkcvPbaU64sNqrU4b+aTdjRNvqohbZHvD9Glg8iwrGpzh3hCADogQOhKDZ9vufwTLoTasAQ5m9Sco91DtWcpogOYUTyz6Q1tTmEMGs+wVwjJI0vWDgRPxA7fg0PImnJbiug/cOU+/357ya7/nL1OvXW9OIv/YD9Iwac2BLiVhZ0QZGQbw1nmIXWp4LTR5pR8OIUtOFnft4qebiH+SiWX6ipDm9GkI6jAroQn4mo4fDzrOfGUq3V9iIlGJ0xr4lzYGJB4qH77ltURXq7LHKtryzfkOjl/by+X9nCTcqGY8bhJTr/5w81oyn1pjjVDZQq570+CIYpXgJGHjb+ST55BRUR29blHzSNJ8Xxhhll+pdOXgQh/OcWRQ5NqFfnu475l9TwckcLYXeRd43j2+p/fSss0a8IqB5tS5RDvT9exWMvn+tKHTDXP2EMX7DvZVLA4kkVOm2lEMnStqpxZfzqM11luzWFm7JM5ApmrYdzacMGiUx7JxYOzDiK+GR7R8P9V2+gAyYi4BAhHpHdxzzQg1H2l5K28tfXqFEuAPitjU1hIejlGUDl69+uqbZA8UJQBS3B0/DeMAVVmSA7aGm/S6iWfe7ISgkbVa7Aa0J0sh4YK6LqGl2l23jlxo7B5wtjM431jFdM3OpOJ6R7zh7Bl3Wdb+sZh1mmFMIXX4/1dmPcgwcbGxxBV9e/8Yhm09qLn0qEXxwDSgZfO6J8ue22u84ldOs24Y01rqxlzS1XZeHS3eQ7IShd6XfNBy4DcaoUj5S6u1bdLA1Kxsl4Z/SdrTZlVAIZ27bXfFWP82bbhCATGoLLY+AiKE2IAPkWsoJbqe6oQm+Qm6Ngi92PiqU/C1YZCWM9dW9LWlpVnTDnuh1LdZGjYmPoOYGWnl2c74wyn9QOjhOFrSlUJY1fnVCFlHvQrddCgE76nsdmxpvXZRV6g2VKWDy+bH1FAi8VTPb6ff7JdZtQ5FXEfvEHKI0AwqamIXCp6aaAtJVux0gt+5PrbVgqjKWOfrTbP5CfthGIJrzqUW79JyqyS4AXvSEmtIyyUc7hZE8cVm9A4rm8/cPKULNNQj4u3ptVCjYI9XAlTapWUcGzqzVc78zuc8ojki931v1QYr5iegTDG5wt6qYVZcurPpDH5+RB/OeXW0lNfQnTW+Yi/jQdSZj3fAgRXTKY11VTbzj4reUguZkL+WGevLs+hBrh5qBzUkb8VXhTe5xGh3JBkGfRJ2fm6hBg2yKhJxH5GxUiCbt762NjF0mzmoLW7O6YXd8Zwaqxlo4O+fiRk3gOyeYDBMr0WC+uuM9TpeAMrxw1xm5cas06iMn0QHkEJSThbgArq5l8CU4u83yx7LsfZ2mUTdsTjZ1hICPH22HrzbZquwFZMFXTQEQtGTBU+V6t7x+M4IXPCsjG8pNkDuhzJ8e7f4OeaqM6UPiEh321K8ntrnvhMvbiLHRCwPPoVCjxnHLPY4uFJrlDGcElgzFHDqvZFo05SmUOUoES7Q0rc6/N6rnHVMO7Xxv3JuXu91OIU7gjCeRQB96JanuhYL7BEOuhN41kXLT3FK8iEjRffkv7MhJ4vLbNu1xJyw3EIWB5YEEXg1qGuUeu7uCG7h8n3NjJdpdjsuWjaooIWPdhwxGzjRox8Ol9w6RaA9+zcnI1agspipmokydx8HXTiAQToucmWmOqeNUBPVZ3TFW8mbdeuFtvWi49llJhbxyJSUFZSJSMTvhB20uaqKacW5d5pi0NeD6ZAbYFisuIJBKU2P+LWj5go1DFq1DNzx+WZY+IYMdgdOsVm72YODryVHpkNLuO/YzBhTY3mw71J6HLQ1cpH3GaF8XA7UGGg0lycpUK2o4+jN2GrAJ+PXGYpAM5BP/VZdILarwwNLi3+Zik9sBrJ+k+mGYywhRQw6yxiR2muA/xTfWRUdn2nppunMNZ/cbfRn3xUqkPgO8lmrMB+a/GTXVN1cX3VL97jvDStJDvfL7FxExs3HSro2ZL9ATMEcppJxbFqcVDtRQgptqCP94M+Pu9Qhp6b9mNJUv1c1gXnA/UXuJO89HcbKh9Cmq7/gARzjVHY3UOP0UZJZNF4No8xDTd10P9gIYnJibLb98PjzWQHoOnWqqClNGtCvMjzgXHEHmlKUJ7wBtvWbtxtrU9isflrokdQcdKnAeJZk9ne9jY34dfS2CV5mW5T0vGFudFKBEQatgS3vxbXm8eyZo634NoJxVdRdD/KpiImAw63nGnLSYGijO52smXsMB/glzWeJ82+wfCyuRocfY+xgdH7p0Y0NGo0do54zJSTBX1LcvnqHV0nZzTnPV/xDyKBlx0a2T0rIniCN0g7ClpqOPzMjLuEVjrtH+PZJsZGUeqOH1UvMcpuYdF8EPv719Wv85r6EQE8c7zF2lvWIDij+W9U89rk1giHAp/UG1wlwLZiWnJlxPzcunXJsS/PHZraqArNgEPA8Onbnx7j2+wC4+ZVCVEgRXFVbsCsEwU/xRzIUUMAIwm4eNa0Dbu1pJKVGLUV9LaqbGMGSa0UTNLoemeYj88Hqfbn65BsahD5ZkNvMo/kFRN4tS2sUOQsQKARpP/CGEkNUqMTiOYmPigiX+In9iR3loYyowXg8cqjZBtDNn948zjBEzHxOOk0E0p6Awyt9mtR4r3SgIzkrkWikHxf0yMKhQLEnBgt7sSjYyEWkxMBvfi6dp5fQRk2tHmXXspPtZbJSXvNnrACmZJ9gZXG9CrJFFwN6kvuI70J0Ucm5INO2TDU8DGlU35vOUx9zxZjOSnMUsLMk83iLyBXVESpvPXWGgwuj+/psnexI0xmTGcLux+F6kTeQ1AOumeK5GqHHelFYCNctkbi2uq7ROflTYCqxn0+bzt/0VHn8rFGs2313UxBu/t6T1FqEBkHAqFwLoYvWe9on+Q38RXiVZDFdcllyiqLgtB+jzfCaNByPIseuoDAQJ0s9jInYsNk18CFJ63WI3o8vKLYkfgxNNkHzdEYLhA1IuMQtzfgPDMCEsdoscxoVnpPXHah9RDvLVdZYN7T2StUtircob3GtclJKGP0SYaO7ZNmJjpS3mrIujvY4cKbVbKZXM5r3pcCAT8o2gwwPdDsxsHQHLnrNUKMTNKrIKAPrE3Ha9YpBGxdxNlGoNDLtPHBoC2uHVCJ9f09gLBD0s2fIFj5lc9i52l8nYFu5rrvOrj5rZyqxU3XUV4o7s2OgiMKq91/Wtk0HRQ80Iy+d6sHhyLN67JLcLq/+7/aqg1d5BxeClAiDj5N5e2FSBr3//UwyPHbFXRxXP+OL4kGvIeUg6OsKeN65DO3nzePPad8uk28aqOj0KTREVcaW3znL8sRxZEBOagBsQYfY4Hl8LEOrlEvjbgLG4ALpmSdBB9jPGfDh8230aSxFWe3VhPdWgoJrwbQnHEJnpVYPqPfASV7+ClqZATNMiMXcuTJ9PIOJHr+x2kb+ssCOFkVEqFyTDEzLC0lxiGqimzEsUfO6mVRiqVr1lxbgfuHhm4c+aFxPnvFWOem8MQ1xuLw8fkTOQ3X/qosUvbyThPBTPtJ12Vpkfxk5hEIx4IFMC/g9DWSn8LtVGtfMm9s32axlz5xVFz/z5ChbeFKhTOVBmds7Z9yltOnYmUZWkKLpumI3POjgoxj/NIuleh3XY1zmOVWVLbq/41nsnIDNzKUx18Q/5tnW6s4j2WVWK7N63+evNo4T1vqm+LYsvxcRJij7A9/XV0oln5ImQdqSaaUL3oPhzbKyH0V66bj2tkSX0OVJm6F389RTRKz3PZzAcE/sP4Gint63EFeemtVA9q6HcAzV9g8oxE8/EeIY2+tETNYpri9IYwNOarYTqz+5mKn3beZ+XCh86SxQrrrUoFtkFzCtcoUm+m0hXCFX2ITMsDnqjr8Uz0RUesz+7aNAWogVyGt5I+T0RU/lW9Vy+ofApfzB+j77cmuRc+uhli+i+Zl+9Ko3h5bvBz+s45BhrXxDEebVglDR8jQLS+lD4qtuw8OzIlZvr2HpfPk2NPD9WhKWRW3cjqUBpARzNjP//3AaM/qBK9MoEbnHNySwDUCU4QOthHdxeACoZzJqzoQ/Pg1ImbYjetdCLg9YC2rlAQmxZU8WUpZkk7amC2f9AIcrg/ordNqHCHbbIk8Ik8Nu1cSFda19mRWtEKxFVfZA5bJc6FR7ThJlBYjQL2tGcKP++eUfZErdBXHn1iViP4Oy089SRASQDo/4Pp+jRWmTzawaaKVcz4UWg9gSPg9MT6wXAEhonK+H92e0lQ74uiYW4L/xz/HOMAbEWMJLA/9eEesvFEoKEW2vSi2i0gj0SSQGZG+dM/KfPiSHd28Ib1WWNhCQoOqOyiN3Vhs6PohxCMCrb/lCAdAxYZ91rsFkyVjmM3t4Vihcp6h/h1xJMlJujwaCUhRmCex36t7z9bYiiivEGZeZkDnG4HLUCUj6zgaKNSuWnaNFfLxghRU5SeGuC5Vku0273H6P1AJGL6cKVUHcvoGobcqgjyIi51Q9ini8zoqFc5vnxihwfm3d86qlLhhDxrS6VVtQf/uYmsIhNNi4rk97T1x8Qq7JHrjlHAYhs9vE5+LKwOJRZGOOuiXVZ6DrsVAVrAZfqr6y/0jg9x+CcTaM3a6/uj8W9dvfZWsyuWl/h6cTmqw9L6yA/Cb5bZX3tsO/op73MvN6nA6vER2lgr3dnMewoO9h4XOOwQitqR2/pmLpY50XWoeYyXkDrXtnMdvI+qF/n9a6vqzyHf0HnGEf/dynu342IgaQgiayDsNz353hHb/wb2uBFheKOvQ6/4eguQYSNgGGTwA8vmYYIiy/BCU4GuWuIer7/5f3ORje8ZQVYIlobPeDNVf4HOKIQW5ZgtG0ff0YB50nWMHhGxfDZwn5u5Exlk/5ABSMVUs2DDyNtEqxvE7w1SBV1neWx48u5w9+oNJjjoPr5SwsVp624NjTnZfF1sanRfo30bOxxoVvtNEUP7XLpyVIiDn5/AzD4Ha5RLWLQKdkCvF+u01jtj4Diw0mZoEBLtJyDET38wa45JMve8/i2+wNWMQ4QLqQSvamRUr43vMuDMzVQVcmD0TRfiTb/Eamb+5F2zQ4jbyD2nX+WcCWG0HLKwLRKjFh68doEd4aZgWDB1AWTQwxiiSvAIDZryYCgjPhrFN8koB9vAL8QG4JJd+dwmswlMPBYnoa7wiaFCHzlaQvKDlCHQM/LFnuyr3EE9VMPmgNKzIkBzZBiMZVp5rzp3Abs0KOXjsFJdnA9eJZFoxNYlKv0H69drEnQns4Y5R6WkoLFsc22HOD+qRgeTha4QuskTlO9MtvBq/RTNCb74EHdw6F5MPO4K+5646yaUECVO08rxFzt5MizA2sMt+nsF7MQgYNf2jOcNG3fWEDAeHnwQoCak70wtTmGULzfaNd9opHbvkny99qop8iTUgzgXeSx7d3JTSm17ByerMigLfGIfm8mUInr5szYrWuL8hWt50SDrFxZL9355Hc5hEG16QWC+65yNCbdDsYAgobhSTG7FGKIJUgHsnv/mxhqUIOnOpzx2QUhwb3xhs9mkef50PkUoZsMCb/yR2+eHBewbDpdBEf7otYiVNJLHfNVKyB/Uv+4XQ3W+kDpnb/QhJLuBNudWpoZvRTRTCAR3dwraq3aUzeeU/QKxQ1ABaApYqCYXBCJrXpzt3yngl60TLYigaVjwF4aELrIt+xCsXGBJelnBa2u31hOk9jwYpqZmRynkA7UFpDuafpJMBTkX79PfOLmNAcHpWGo1TqPev4NkUC0VPWQFPILdNfaHTQEXf94oxqsnJd8Wx11ffOP1zxlZkjLutDwfKPaCEAs9DnV+xcDgsKzIerzPg60SeDXmBNl0Lni+AIl9OZuT6drvC/YyDCt3uLdEHFPoSCiKFDHcZ/HJWrEeCkj6qsx6GpPGDDkmRYctzc6gF2S3vlZ9o8mojK5xzYqA+Lr3086qF24rMLhF7LqAqeCTni20rrHrpRcS32WrtDTsZWUo4IpInmTc+stYR05VWqX5D9pSZEUpqHBGgoOjjI+bmnft+Szkz/8ayhnAEekwMTNlm5CAlkkW9Pw9OahWT6eHNLLaPP+pjBXKed+4ONEySwEn/zR2nMhQEWDIDsLiPqO5qH1XE7RjRFbMrygS3wzJMSoITizKUOS3W2brKLMhAlZnJ6Rz1PjDYRnwFHD4bL1cCmD8d/x1V1XxIOS0s075aMxFymhqC2wymGIMu6VYHMZERHiFmlHLx8+5jWvY6cGJOnoNgzQhzVE9JXwEY3A5bDV9EWnLqNRahHTW3GaMGIhd3Xm8tJwY1iJJsOVxcLdV5+Cdf3OTDoc5EG2/FdAaa4W2p2J3eVIPmq7snDBaobkxqVdd0ofuun+YbfxSgYYV2KbILlbTSxunWku5To9SisQxRgxiDxjELj+wxvF4kjDdH5e+rvTYc0SG565hIUenPcQwznAmUk2SEW93lePlJ6UajyS3jZlYkm9iQEydXrKdXbHMRtE2UkfKZLCk+vO+/aaINK/7ok7Hh6gSsFe4aWVqffMKoInJBy+WUlCP1tT+he+LMZx4lb/u5CxYLL2+k+qrLzX9dxhZROtD7vMk8Pky5CX+fGIq+RO9yEfE2ZwyaR3wVVMWJL9K3/jwkETxhqCpkuOHdQJo8KPOqjQ3MXUYYaff5L+cPcthMWu9FulT5gsFCYziYK0I1jQHhNAJa8ft59ms53597Sn0bsP8sLlpWSdCLAthgIxat0kl7B8J3v2R444yDuxN7nA0s4fDAxb5u2bIBK5bgDjd4wjS500rcf7fgjvirDsEY0OtAq/N6vteGoqgVEY9DOfPHVfx1Fe/HvfGQ/SuvilB97iHE1ChsT9HBk3l15K6EmjjXLxqasWI3oGs/552KGfhhVaUqPaLCuxRolFE09Cp9oNA1RNWpUs6pGNnJkFRNVjth91ty1s2Iub6uR2AOznFzuT0mgG883nUyht7gQi0q4TznyNM4kJfRBFU8muvQ5ae/dRY0F4orlxWUEy/PMPIIEysZUfebYwT0rrzwqH0qUM1D3gL9KyCFZN8jlVvY8MR15KEGIvCuG8IfHOgItgNEdJb9ErXtxBJ1fttqryNMsoxsJQXnrF5RRNbrjyTOeJhXHf0xZqqYj1KcwsfROxL6eXccA8/+3Klg3nHk7VQKiYpy7waBZ8SBP30Dfoa5/dGdb+kRnDcZwfQSqmL9UxbJmVYq2ybpWERP2uY55etWNQ6ByyxZNm5xMHkV83aTtF0eX0W7wOEUpd0kS9qi3o4YFLO+XsnibRTcKbK6no5zqA+cMC+dni5/HNl6uk0z5sMutBf35EIuPNzwYkFIiCDbJpJ2NV4qHW8yvuLU1qJgM14TI7eVBFPlz6NPpbSuKV0aoV9iVWQKrBTxIY7MMCej8CE9WGVbySGnzJPsfe9SKwg7aqAVrEFvKTzXuKrccap+8s/b97UfmGWGwPyjs65/6uPBZkr/KqDtEu/em+SDPHTljiXn+uAV4DdYpunuuJsOp7CqqK9x03ISkkegToPBsJCERsM5PpMcSUALePVQOzOYSXOPKnj23JhiEXx0UU7eM/SK61wBlJFjgyiMwsdHuBrYgOU0i94CEtt+gjFi+eAuuwn56Uzclc3HaVEsci9f0AFITCZj4ID4ycb6C+pUTKh059sOS5FWUdCKBYUWL6M3b8Sywqjt9+qrl0RskRdler4iHJtxqIx4ZgKfQsKACHbS9qBFArDAp4zvzOg0Hi9D5M6Idcoalb0DmDHdJjmijIFb8eyjKgfrvCoctcO3qbvUp1nQd/PEr4cFlOt3qaCdo1QT6BusR/jQN4P423P2Xs/EgP9/QUakZ9fvcGiwhfQAhVdkAGhy34M4lLcedhJfwwxL2CNXirpLmaUU2w3RUOUAQNnSaB2WLRoR3/31d2sgnIOxft903XE5Q9vdH/6mPYsSaQLfqi10VUO7lqMUeaLLShgzHbSZl5p/fa5bCLIKk0WVvIhVQACnhOcCmmTqTD1Pduvsk9sv49vFivoVW/9Tep3z3dtpwReXwAP2Z7NZBsyekBjbXWesPDdUc1qc1R+46ugEXrxHYIxPfC8fIHF/hGLlEDFf/6IyvpbxHzAyY7XbvuoRLb7x6ZKjh14Nm2tIKojjuEEaEK2V0V67bQEprQLR6Az40aGnDVnJdEMgX29qAFd8RNCVdqN6oaCrtwTqNN2e2djy5JQReUnFcKesPI8Hs+ROjxjlDbHrvH0xyDY7kbPKG0csm12ORLmjJ16lzin5P1uS42oMzVobcpKXtEb9ZZXRbzOftk1VFZ//WI5XtUmetM6iUkxD+g3TCIgBuuB8a3NoLtI8OIXmwrWYcLCsWBERUjldLdp0uAHeiPrx+MrCqJo3yAXSLUIbtTXwEEWZ1EnaBsKul6g0Y0hdMTuRCSxTjA1mOfvQAi1N80l5eH5qlC5nAv18rKDcv10xwcAdQosyXox83NU/7zHRfgSoaXuKs8Y5So2ht0aMGY/+5Jik7Xi18jZ/DPi7UNHnThEGipWV+TfSiUR4PALWqqovxmdOLRInDKgKfghH47G9YcAbX8C0ZnjEgpxXMbMmbw9eXoP005Genxi9/9fZTw1z4pqvwceIRWpxDEUTrUg9yUJO0z2QYSRiFCyg3GY/UoSbMB90nD+Ol2zYlQoezx5WjJCCr2Sz4K1nRc0C7OCFOsglNbyhri+BQwM/BaFOd0JXHUZ1C2h/rxztY3yy5cVDaQbK/n63IvJcH3/ATKFoDlTi7vM0dYZcIZKxmGpDfw5vMnxp/Cf3IHPsSBnH7QqekVq3O8lg+Ku4zXVPqHTrjkU62QV+zXF9833kmtJnLJ9UY/6BnFecVXf/5P1ZckQr22cCv1SKsvolsWi3YzL6NnpdhQbp5cyP9zSDosYFO7d4GKiEA/Ac5B9/GG/hbmk/9+m6zPXnSJ6C/NgWL374m3u8e4GFiRPSjoTGSZ34k8BQGhNIazppid2a6BC7mXIuumrVS6lhwYxb8gHsNeiALzSJlHxmGyHmBwTkI1pk6ZVS0pxeIcw174Xu2J2+dOn0Gj15O+p0aRMOiJwvSULtWHtVECL2/lt8SExVswjhrRvHwqJWVWL6VrfS/RiL5mXqL57nmQDF6vh7aDPagcs0EMJmA2WwfjzIrUpjzCc6Z1csBweLHNMKTDDib1oI08E2rJaFUHFzShY8rX5lX1XGnHkgv2YvA4sPzmv8ZvCoC8fFd/k3QG26btE1M7dUU1ITXSslyDOonQMg7zuD3jH1BUJbxDihRgYFauZdGws60wvW0/sHpFeSM6CCpX9J3xHZs8/lXkbjaxzmsvlRuSW5jewXweBI0lnthXl+2KQo7+mxWshJMZJwQeR7X0+QFv2oLeOrv5XAcpL1BlzAg9tEorplb+rl547GUHPo05jzB9NRI3gZtwO27FjK0gK8ozutH5eRHJvk9ZdCvvRpbVbZUW7CZXCq8nbENPIZ+iMhSGnh4UfM/teu6tYBmFsI9kpN8KYerQR2TmKQBjvnw3sOku+pMPX+Z5wn0jNTeJHmsAMI1oFK1Lva7p4G+pb4K2oEvJgfc81zxWkyPVH81gdoi11uznJdlJP8iU0/hdEDJjhWtyee0kqY+Ax7vMteFCrffTYXG4sV+9WE/LyXNB2GZIjPNJusQJCnV/PZqnI3cTCWr7VfmTg1QyHx9juaOQPTm48XIWuZ6w6AsMW64bpLTuSWrQs9T0mnLHgQS3D3+qlWCcAVsOpHc9Bi3+nc3ppyZnd6eL7ZRlWSFrJtEWfWf/oyioJTVhXNeBHBTb886XmXbv531EDhZqo6Y8Iemntnzgd/Y/5tH/uTKVcRAe8qKi1q26rZlpE3ThjxrI30hiDsrTXRyjeelUuBE3gVywEQtgnIP+Jya0krFe5oMs9xnGeU/OCLwSsy2DqCn00cdTxC62SED4nYLmbHwvkZNlYIMjfZ/y+2UGO/pgT7Luh8QJ+cfMWBXCVfbGtu+uQdKYi9fODPcTyzhOPI8j96SuJov/FmLOW1W4t21uqglVGKkZUq4Z+TDvPzHZZSdlIV6I2j7KLZmEOpubN8BvriR4gdtvAw8CAnQO63gpuSG3MSHyJQendSCJk3MTtt+JhxEoMP8D0G1o9ijzmNW2SfogChL3x9ZSUnwoPp+LhlbKzjcuTQZO75vmNn7MqoDkMeB3Asc5BVmMc56mfuvWzQREgWr0VuTI61L4eAo4VMuFu7GcKhOp2dhQo/uX+cbLWq5rkzZl22TQGZjtdGwgEl6toVvEMAxsFyb6wDy9fWDb5doyYP7QGmBSEi/oumWNbMC3Vl+mTSrz52X/va6yp1preVkYih4oGm90dDQ7RvtdRKBKcL16eh1l2khHbc9eiC2wNEgmpd3YUmJ0uXQC4eidbq7Cp+ZiD0FvedD755NHxY6PuzkzTryjCnDokp0fRX1jy+DDd6R27o39He2bp/xXfY968g6H2wM12uFHERgH+e/GNI2POgXRpYwl8DmL8E0w92042/lq/yOirfGm4eheOrgiuHM0JJC7eYoPo3Ad9IGqv+8n9MIUUW6gKJUkEifzrzuuVHsPdKR6w1ZHUen/vCc0+fj9DpaGtP91eZDVFPMWppdb+QbeNMjXRlLM9lg2agChqNuDAMZIdZPECRqlNQI/zz+cyGHU94Fv0M8NlF/hYH88aMZ0J4KHFZdpL9098IYKM4MFYjF74yV+S/T4Tuk8eqSdAmeGiLIAFQSxFFfomGFFVWKOTqFpabYG9yDGk8piMe6M45b7dNcfxR4AwaokphUza6OQfoQx1s20E9z1aTSG1IMqFlHNiDkLdY9631Fxusz/FV3PaWfURsaXehFmsmyJ4RBMghxt0toDBhUnDSuY9HZJqWjv97P7T22B0sPoAa48SmMD97vq1NAxqaTK/bHWh0fht0zMYHH4eF2ClugGuBJKYRx4EdG6PQNd+rfJBaeTEEYN0wtFnaOOowWz2y09/Fbu/C49LwgZakQP7mUiADmQ4tSg87zR8XcXtGTukNVKD4WleZXZppqtpdwJLN1rnpZNGXzIKxZXYvhNDNwUbT5RHAtTn3WxPIBVd3O76c3iUH9yv9Zfp26sZWtDOekT29eAyH/JacZqO5XUkeLc7RafmFcOJ96EkD3NHrPT05Onx1Uproxx2SdLg4HS1CW1A77y60huGg0rvbNkbUFx7N+17rwImZySqxRV7IzjcKlp7NECxfGCJB2qp4d1fIA71hpvPfhWXCaE7CYD+BCIPKMVPioy6e/d9qXGDtBsfJuzMStEaOSdxV9p3RPECoj6vpYsZgrHRMRsg38i1ML/nJm7bCJJwGV/Iy2txS8KB/tfRymRQOyN9RQVuyxdGJMLfENl3zxJ2Hk+sD8m53mOv7zCXur5cXkfRLkDDzccae69uD0urwMqsWe6RcshOGtZHUxOcyWf2axQT8huCzLRql4X3BN80fApciwOUhP2Ey10QWx0HmXXSF5X5u+1DeJbBih14/j25Qnyu8fwTlij7o3rYX/nmefxODMJr/BJPibxY2/LWUIi6WrdCWfAkm+WfUfAlEqDrubuDLvgqoucMFhjEsJXN0f9qtvNRQH59ZYdAtqU6Q+r5YVMJ3W7CmhgNcTOmcUVQ1lBu/GPceS+ZsngOtKKol860sJrZ1vCStfK19ECXTgO8k2ChhsDMXRA8gX2/Anlz1OtJKW5/MJErNABKacWqjUEEfgemf1Fk5kSD+x3kcLZnsKqVB83XS/tnwj7sH/aPNYPCS4LavZkNp4UXnrxRO/LeY9oS+IquvpPmiLTMVjvMA2tUcYNGn6oj6RpJRSLWhcV4tysqtQVBYV0m5WpRYI1ITqk20YcC2rq+c86zKyAPvatWnMcxCBBaeNqwR+6do2fp0zdSI/QAvW4nn5LCRRBoM41/dskTXrjameInXEIW2/otCN3JT5TcvgBynw5JAcd4at/talOasqdtIo6zira5HteqPDCppT10G3ofttycb/B1CbVv+NX/ej4abxMXfQHLV8l/kYTLlK/w1YjzGk0pRThw5ONbi5FUojojHorr9rvpqB7Ut4y/lVy733yMNJ27LL+iTfFW6RzJzbvZOXN/W+jzTrEkVw3dmKILT1q3YDNg8ZGCtW3BF8wNsk7yOpR4EY4EnFN5lItDZbwowXv+QkZfcCxDBQPBCq8I4rDggq9lSI/flwZ3j6WCidj6UxSiP9nzA7MfTGIO69sPozGwic2orvtkApG7yVeBWpWMBIb+p7rZT1fb1fx/GrL0vlt8SAnD8PPVPcNuhagpsKUrSMT0x+Dses8KM7M98r+lR61bMRxZRhJzdj8m5wQ6iuAq2E68TIhKUFeQjWTgBcwSAMmW4bhXzZqiIleO7YOE7ztZimTChpSAbupNBHdqsOlv9IbYjvJosVJW7ojiAj54gCB3vSm3eb9itsvAooIf3ycnYoXdJ8jGP1tQZhs+LST6q4qAkvJtaZdmQwX+KiS41N9Y2mFgJB2eb6ACtQlW7XUVqcfkd4dgopy3aoZuRKnUJIlUpq/QvJ8SKgFaDsaOmNoBLxEtmOfsq0tBs95L1mxoy0yfmu6c9oXTUJUgaLEBldJAj+WX3gnaI/JmmRvG0LWpI2SQktrCb56imLR8uPxuiSfj9p7WenhSBh6LEiA7HjBsJTl8haYj7kyXaW2WIFsTjqw8aaqyYI1kug9wUNNEyMFyPn8EVtaffK27z+rTuRVYjCzffzvfPBPi/J6ErgTroLbdsIboJhX15v1rJtHfEvhgDzA9HMwWcTdYpQDdru5Hx521LqVmgOtt3oKsH6tnS5YjBpnt3ScoYnFMCfJLZdTtpuVIEpC1i0T9XDp2Dk+/yyd1nYffEU4XKIUIWqDDLlH0gT2MM8JZW/xrsRUIISB+P0Fe0PbIElj9IczoTViKpmrSNVgzbrWrazjMXlsnTRbSkMvW4tg+dT1b8rXeeXzXoctoYT29XgUhK+yldUPqxaED4pZ/y+UL6Bvhbc7mUg5bPdmRIwhcOHruSn/N8BXE9ON5amOjU1s+j1ZZ1NjAb4AVKle0vik9XA+yvl43VO3OlVZg/lTecOKPTt3sGnoRQSRW0xYLI0NV7paPkufMBwTtN7dvv06h/5y6qG3l5wShbEkQ2eWGFrKpSki3vsPQLoQzZ+o0KGF5KaGf2VXvUW4ICdQAO9VAHpFPCJ4DzyJjN4hCgcwnuScN2mdodKEVDXFasJQZstlXAn37jftmq3ptdww3hm/nFXSKCbO6f0sHj3+0fhWZn5bltgiGwI4oRCoUgYHtpIZoSeC76uqZiaSxyMqqwhzwuUbfoPWKbRuaRVYYGzJBFgzK4LkebvOs1tUcsqZ9ythKdOq1m1KUc4HpwCehXwQofk+2vSio363l9mWHWzSy9EETbsji9sS0JqBdOYgvobySBS6AShsa9OJT9xZbs8jW5HI0WI3/CmLFs1xe4J+QKWgOEssLQsfXGKAqdKgd4bCRhd8XA0lvuZJUxYc7y4DlC3i2oWchjE+vbuUL9hGsMORyeF0FeWMqujYRYO6ABcAbLZba0sJTm9qfo0U9xVRpPGSGnGo087O5vll347SBgcTLA8wQrv+O5VdWfvHgNtSYIxdARmD9nb/Ew4jjJEcSgiBHa2CDud/0ZtEXmoIR4E+G5wYgi9PyjRqCvKp35Nf6mcvWVoHlI9azyN/ZYiDjBaLSrxo3s4de9hoDBphKNToRcKEmjsx68gLPMXb8fxA73k1S+0h2CvhT6cbAnZFUjjFcd9LtypPsrlTy51Ze98+CmFTpqbRYsFSCl4cSugFmR1FQMZ4MqJ+DRPnbn6w/5aBwOagVvW2vQwq58So17nL3uSAXwlpKNZ4B4q2nL/rX1qr3tKKSXAG7ii1BLgSyn7M4jl3xMk9FTL926iw04zDvgHKRf3lfn1aJJggUcVGOD1XJmiRyyo18XKFLinkTMFmVOEaoyvuaUWqME9a+jwvTcRBA5apYlQJePD/X9MBFz0iRCxHHQeShNhQ4zSQv4+rnU/4wz/Dm09Tj2UTU8zTw2tDTFhd1vIPLrkxDIZ2L3WEbjfrbBKJf8Ve35mKgYGo9CAaPoM/TSZAmyzBAe34iGOriz35+u81Ira54F9XzRcwOwMS5FStMn6mN0VT09M/xCpb48hV9TNu2GTcd75fKvjMVzCoS5TEpRj2QpMRa5okY3PXvjk2uqA6cjQJWPKs++eDejSzpNVam9o92IkIAtZu2qYTp9FGODOjDA6fjfRQhaa9Q1lkKUXTMbG/8AzELe10IeazllGDoefkBIJUYe8zPTwQsBLrYHV/m0m75hyZm8rdDa13yFfYLk8bSJ7+nAqaNVMJTlaaFHg0ezv6eQhu1+MRlQzkfB8Ck0/VuV2Klk7qe0kEmc6ONXbL+Z69tLEanZ0a0clDEf8Zbq+wdhpnRF23E+ntud1WaJ86yqsRPr1U83pFAMU5R+Q4Y6zZgwtanddBA04nuYiD9aGnRhwNkb2d9HqgwuWwwxJTOwErJ1XzBCT+b/Y6cfo/wt6eNDW1oktLKdWw6Ikd6EqOT4MNovx2qav0CmJLvdafjCGS2OkWsAIKD4/m37rNDScJ6z7LLfw72eTx/UkM194pkj5w5U/AM0RAl1DxJqR6OEJHDm9NP9y+fsyLKePoQWH7o7tlD+BpcuFfrYvW2BJyWNLhTqO/kHHyropXg5A9YhcdVnHLrqptZ5JUriIezF62E/XnExDqfnBoDkpwbY24wcQjl1pAa0fplLPnGJnazRd1v1O7LByfOY3oK0Ujb6jZGICyr9vGOb+W6vFXoEpKwwmNAWycCWhNxf/DdzuVf7N6I5e2rMtHbasz4RsrEl4THfuHg8dbp9VVo1uht+wii6UyO5hybSZOx9rNe27wNTwE8JssQNrXnhOb8N1S19f1mnYhSc2chG/G0bqweDvFZT/bAtCiKduc60lBky2XFMGSV/+cOGsSQuxZpPsHJKpnBxp7N6qm3nA+j2YkihZpm/IkeSJ7hw44qHxb+9WPcqhgN9th2u0zUk2bd1PKT0VKkteF+aD9zR42xVZ96XM/xVwOo3M+nGrkZjwn5AXv8ie1vl72HMbzV7wLJBG910VPCERtk7ACuXMD4xRMstCS8bM1QweAyMeD6fUuRDY73tyJCCMQc3iOeccWqD9KugbHIvU7gu4dtDC7JFYDS5AojB2XESMvqBxAnAAEgFJBe6dY8bNeKCSldO29gCIK4cvHPY7YmQgxetdiWxBkBe8obzxt2eUotYB7BlsH/zFtqGJpjVr9Q+WqXVLQiBttetASFt3gKXFJvW+apM+AP0SuhfQZXCqmSMfk/DaCnshNNBqGLbmr1YZqh0CFv4N0rnqdkkltTT6rHBG+9czWKKAkBDKpW9sTgKHoKED/XkZi5cBbXuoSzncC38Iy6e1OQR1Lx6YKW8MChYltsjVyetSUP9C3mbi6OkgHNDB4XDfx9p3bi/1B8j1rftLoPWWJHFXCPJqgX3mCGIQ4/T97VgZEH6q6IwEzyAW+dCAfQ/WYhC5u0wkqdkMhyWwW7e5NJOz9Gm61wsu1r3jeYd+XrrcZ+9buzWBmwK4CY6WoWaBXsCUaQ33ytdazzD1ARpB7YoG9YjO2LIcEw/DsdxxFDvBQzWr3zNt/kAdli/BOq8lb1vS70rnLbXvhLD8QSrV6Pioih6u+7PDdqDR6ifJLTtcTufY1zHtQ5VSxdMMZ0YMHCiOALpRm2L3/BW/iCCznYqGXimF+mz4nA6I3X5g3tGi5nJLIBYfc+NWC9Z29AR4e2CnZHQkGpmJ9Sx29Wg2btO2ldb72kdEL7lopCcSrFw4ko6Ww2GLflnWBsy1k6/k67NtKdcclZe2Zq7bg34GFJaItE5CVm1wRGhjVKthQR3bnieedtz1laat6chTUM3af6KpqlXQHoGe+2LKM72MU6ZmPdUy714FaeNxTBs2bRxwWwnpEy4vB0xQEv+/PuNLkiVbUtDWwbwZ8wEfzlvR4S0eA9CO1g9tFoqTWxebY2m1TgUdx+oaguzSEyMIUGNG/gQyJyZUS5y8HMJw7BVxyBkxoHSspL/ABN4BT0Om7DI4nLk46NMaGDzKHiNjMta3WYwUmW44qwAyCXCY3Q00Nyynpos4ZycNSrWsKWiVE+1xMtVpK89D8AEAHozphOB5A9ZXHVdsEt+b+HufpHhy13FVZL77WTdcn6Rnt7EqHibzEvRTl5hpEMshHuXdz+P2uVrT+YODgMPd0gZDMtuibCW56fZJYX/7igpJTn02dXUstcBZDs1r2EBO/cPIOKKtTWVFmYffVobQKOjMOIIqM8564VBnX7sdi6wa8kBvrUIXm93lbUqqGJavqmzeImfHCE7gl3lAEbJCRkHS+aYaRCVv5JrrBW6HvXDafTN0G8tKHixzoPS+JVY4W03cLwRh9+IY8UhbtEYk7+XCuscEXnb/D6siVTofP5Xz8xlvj2k3VlDvUe3NMWVfIVRQT5AsojP3zlrmD2xAR1u1hvk7mPWwo2+wTP824OFrAUbFF4aUFHziHi7LxRxXbV6HmZIceoPPN9flH+S3CM7iGonlAAVSAnGhxvuIcYyzqrLSEYaQEeDAHo/LQACOagL8vwEWIwND21Hl9y+iBIQr8OU+As27C1pO1ZXGesL6mPsbGrWbYAx731T/4+nLhdO+kGmr+7NoV4ySl0hWh0v7IRH+KQUX2dhwVjsNz36kMIi+sjtqN/ZzdKAEtFhaiX6laS/FGCEOnISInO3DzorpZEObKD9ngimNZdWTra+t2RC/JiQ5+spzmwcD8OVY02lNMPspSdUAqZM83djZYBfrbOthvfbnKS3z4qrYMVlFTHdtdPNwky05nUtsNaEsyr9riHYEwa/XIp1wht3lXHDWlTY+NUUOUNiNL5k3EKwR1bD4IUZNuCxeANeRDnT9YFoBn/ltjG3HBrxUpV3XCO4SGfW+kGkehTxRyb0vsMwORVH8tU/aXneH9fynsGfTrSdGV7MgWe/IquZ8SSXJv+djU4ZW2E3NA7ZOrRgBXsE+r7SdVI4ZEO5rn1gYhObOXmzwDZh7V3Yhr+t0NxbZQnugbGnv0qhPeGJ886NYxaJUdrBT97/pyQPUl0viedO0TDM91Kg3nHgb2mRvkVEwkhTabvwSZ+/AlpJflcfaSlsvADlG1FuV7dKAZ+gvHN4/9FTeaJFZtomWWGpu5/IhItIkzFjFUBlXs65rXvC9TeoDxwxhMId5gtNkAZnM0qnL54o59jL5XM2ayieV8yH6WuLgTnvYruCV/M227hcqHWa3A6jN/hGmRPUeeBheS44kwhOs21ud3UUyzmqik0vnSpW0ru3/yJmUx3sRs9IMk29F3xCPSon0XbZHypG/QjOVA1JhkZ8s5R/TpogPc6jIvXD4g8N0dvpZCri8W5KsuZWmb+qks8sOtYJl8m7VFn8ZWuQSAwaYq5QCaz4EOx3LMXkxa5hyg2uuZ1W3y5tqVVZDVN3lmqdHp/DkMrLYkdUEm9tVT7heMi/KmY+dndZ1o55YO4x47RxYyKEgdIiRfipqi1QYgNKnDp4mabhMHuP0AHXOr4XZ2zeRQHl0wy4cDzz7WizDLMR1wQxTgTCCAK8NWt8YoN1lvadwXp2HXKWYVoyrAUQrxbL1WW8I2XSg4kthhnydq5ei5zg33sj1OS/P1m0mHulN9FQHDQD21YziJMdf1DIjZpG+Am2oDjz5vs2carK+NCBO7IR4py0tpz1oYPgshHR4U7C1h1EyJqBymBtQxcc+j9VFiWRJvG5FhCUsDmKsviH5OtbKQ2VBou6ewH6Hta56eWl0aEoGpWqlcQcbbSNKXq10kOyYRWnZ4FcYCtKGmV5RrJ8uQL7KOjmSZjupXmzy5EaOnrukNh+iQhtEcD8ajps/4UrpiRx9G2+m8SfXrrbu3X+BMx1tNqjIBqPzdb+rhIfnQWvS8jPRGh3KABLYtLvgnnmCgxlFHo0ISv0dSFNctufdd5Ex5M6zx9Jw8661OLmP57qnUfLe0EysKnoys0GG5J95j1FYRBpTPmBTlEII7WEIGDJFbwDLXL5WWpRsWeKzaEcQHcOLxkKfDpJCEpuubPfXCyFTVuhID8purSx9T0QsmNOqfmpxrgPFksqFEI2kkQqb20yelKzejWtPW8wSNQBi4KfrvxQH59AMZn558LWr8pDlAq/Lqdl40Mld77p02QOCODxNbx9glv0/S919LRD/mU3BUa3fXQFJyU4NhHYkWfNKnJbrBESdyzsoz4Ohh4kOPAqbg+W9k+nf0aPYgU2GJmOJxtGMoEZUJAhM8jZCWGdrUzhqd9z8YUSDkXTV6A42p4nlc6Q0JI8ZoMKsDezhHkiCvtlsmJGjr02BewKr2xibQVo34FyzWrerGJqWS9d1ABWZ6aNVYX6+c5pe8GrX51c2rsrPqS41ESlyyP2lTi2cyYQViOP7O7cjFbDxlFDi9ZnzCX7/P/7Q67j++qZyIrpSZ+K6Nf4uTnaQAv3DMDcjbQVyrUpdMiilWZBITmjoAYf5HkjrGYysiUBDef7EkGNyc6AVDhp048UUlo3hrsI/hyefuRe1UvflMxk2b9lWikR4rTtGZnLASFveQcW/mwnxevu0vPOKBbITtrlD0WNb8nbLrsmTvXNnqFc3wtAvzoFXT3dHp/i+2ob36Eh8l4nwN5ZkjKPULFztNbxrhrX1qTtgrghFWmqDR+0lrVpVjdKSW0W16Mt+uV+NKbhYukMt53Rr+/o0QrswYxAOllEbAIbEJW7mIe46lSGTWeG7YYEYnLFmx7b7ES7bCLFcrKxt3PhVvdc6DFhecpCofdDCtQInwgL9Tn762tHp/2w8Rn7RPDMwJ07QRmIOF2ZYDTidzapmhe2q3oci5ZRyPDmtzyq8YAjR6bjtdGr92jHG0QJqyUAW+8oOtxtBXk4NHXXYwBKBqtWO5SwNQ2j+Uf3nfkqZSA8fidEY1dX9FUa0yuMI3N2bNb3PmzRtb7bKS7Wf5vlu/zsbUJWCdVCTJgDQ/fyRiNXsHRlqoOW7+U8Xy2SYW1klS5Um4kEYYirehrW/65xzu88DjC16lJ31yUuMPhNtBPGgYrHuIEBduculsmzd8jOceeyW8KY5Mu0qmdEGmXtFQKtf5PbXPuxWv/ADKB6uS2sOc/zi2zPWP6yyVI3ch1t8i0lYgdaZQCDQwTKdvOd6MViWnARjXsiObOIe+LSBOEI7UbEbXMC1/WTx8aU0eUEeFKuLuLLPLKujlVUIoOz28rR9imdNCWdd5ETO9/8vzKFsxOBNx5LMOinwNvznh71ORn5r1rO4EhD02tB+wkmgfqFk9+W5jipEga+csE4hWr8aIYrdexJRg3//fR3VwtNsPKgzJqVRhxfFlBCG0Sf2wZ2JYAxU0ERmNpCIy3ZqTlJBu4OQ1UfEfvERlCD3E1FmY4xsBPA8YpW4f7lzvql3rcIG+mDyYZFuQTFAxCOCJ0pZYvLNOPkjLnxwXGtMw+oRp8GD0OJamYF0NU35qWv/2PPj9bliOvfQCobUno3/T5D4J1didiSEwWc9Jm21CI7wJze+gVonlU/N/6UoKPo6h/oLg1Y32ks3KMhEPUYhe7bq8e37H1xavsDxZ1eZqOXfBjKobUz2MCyUiYZsaj2X2PuK2xqmvuDr3nzKRKZRuGb8MLvk9vmTr0pIsMAPD07sn8hlduP99FdXq77ZO0Sr6O6RrykDKCdYKIHxg9S1zg/sS4LkZMNNBL+ERsQZmRHWZ7cjbOcvrn4MzG4sodkxM5jSvzM2PTXeKphdGYhHiizU34dIw7vmh75qm9YXA3vq0ULYpV31EQtmfhs2wVbK+42CSLqZVsULcrnXFYiw4oSXDGJE2QmllOpAjgs1W6T9ED7HtxO2DxmQjbZEtVoBYrVgxnRYhGHDaMDKDz/qB3r8FCUwDxsyYrOxFuuJDBGaw6UtETNO5xI3se20Ro5PP4c5QtLt4OzWfPTKsHevufC6l//Fm9cs8ll9PO19vGLfRojdILJuv449aA+pZ3c4LrHL53xoAdcEFAwRTgiNu2TLnwAgnqs1tGuIPkPiOuqwOcygYHtpNxBuFzg1T8U94mlkRJ4nEj7dem65jG4BxnIm+jmxmX+fvPpQdwAHkRcuk5OQAjG83Tt/hTT8RooutDzwbqEmg/arPYVm3y9tmPRka/MgsPQeEqgS49iMv75YlEZbNW/TDTiHhknolECkyEQaQyLVx0rFUc87sumAOgGQaEnhRUki/z/giKMExf+FssNSTFm+6WarHXB2bJAa0I9dw3dnz/BslOmyfUnB6zw6d4kP5Q2lN1aYr/LMdX6WiOm0EYYWScYjFg4TBYrMb+xC40mIPv1RY1OFP6PexqkzaOc3vKZNDVIaQ/GHCQBX8LAtLCMRPNPmOWm2VsXjp6qmJpjss5AVAYJoECOr0UXCUZorkO6wLIxO34ZdKYbtEHF05FaPS9uOVNf2LFRU2ICAfjLfynOpGSJN3v//wIV51/QxRTiaPzUBYIJS6eYlq3Pfr8E7XcIABAHo8M5yAgOBaEHoRxtSrq3KuFYxbZotgh/xyFHCLVCBt59dP1sgXhBCKXZ4/2MHlpOP9rP5Ebc85RmV3E9JS0Q1a1nwHbYJfZa6HDaRq6bah/I/QO3HTuJE2wys3nH9De7xWIw6zyCraUJVjx3cHKvK3ZC1LwwufGkgM8Rdj0r8x4jl4RxXLw/lzCr8K8/RXQcMBvx+Zln5rWTunsfnl0E9vs2rJSTlIUZgnxxJzAAbOjDfp4u7fQ3XASBf+QXY0mLu9Hs8GwPQylYRdIMI/u8o7Hjy2R7WaKPaekmHNiskHV6OfRiByOsEGg1i4CNEsrAgdxoCCZ2pG5XNMetgxlR5vzYOXjpWaLyLPGjcsPqJj2Xw4Rms/11iN0ifLnC6/iyMnjUGNTSwean+7iDxgIbQq+jBAj9FHcRYirPOdkIrPWQ2SMDbfZ1gBThgEcuwZIIQKCgQ988GaTbDp/MvUWa7i58EQWg2UIv01kU4WuVgmr5gPCZ3dWjPPgQIeOxTVmjjidHyt3gNGxW4kxmPbjsFyCcaQ/uqrwuDKLtpIeyzhhnVGqs1HaQD0Td2bjlaa7x68ZISvDLmLI9IC4VTTbcf2t73AMmxS7Ron8PlcqD9XyMGkYF/YgXprJxgA+u01L00x/0j+W+NZzEToiK3TK6IVO1a87cesXGCcYq2Rm1n6m/74ZYxF/kVbuUqWWoP0leyQatQsaEs4pWUlnzdYifyyz6gkPPqcJweMReND/uealJzJOfEiZYRGXB9uHbVs7NeF5MNH7D7PnObTh5PHcFRwh97ye8MBNdGFY2kcSMZx6oTXZuKKMC9qDBCoDRO8FYQLBejHl+U3jktEGezlUtT0/aPyQGAX95el1P4C0ctnacF97LgdFB8dUJ6w25Jpsr0AqQ/MI0fSAE9a19ZhfqVdEYQUfRCrHlD/T+6XjNmR0/yEQm/Br0m/mfZdiz7BEEQ8hydz5uqDftc3Fx2QUtwSHGcR3s/9bs/hagFTmDWgfi+Egsk4pf47z7Lst0Xjc1OC84IXUE6FTd7Aake9zN2kcLmlYMH4gNm40M1oLOQZaWgTR+Nl0wCKnJyUJx+q5X2N4yKdGl1kBBbmv5zRwSPk0yLGw0zPqD73nEkF1LAFw03NQt5BUNJcL++zVZvjG2/fCA9f5z78mgHcM7i08JHkTzlNOjXzG5aRFIgKqe7+Adh2PHtal0aMaFrKZJ5sAuVkd3VDwLxnlmyg504WjcJKzLSmekGyQ5WeDIGKJGpbCmZrhk4w+zPnpLtxBKKQONYCz3aMZOB2mTobSdICdu8j1a4bW9oa3tOnLV5ABGl5eMT+ulKEDOKBIA9aGTA1QOf0Q03LzsPOHfYvXwX41IGqNr+7LF5PIVHnnWcRNqn4LplBFeVuzT79j7bjwZSSYxQCaztpq99Ut3fshWrZ4NZW09sYmSazjShli8gEhLNrMCwz7Cp/UJ9DyMX8Ug8OPnajuEt5duOAotiAMS8BGnQaoN/faw2b9SH/ON5INXsmf2jXPQnFuxjZg0/qI30nt1wkwjd4tAIA5QxQWmQScR3q82cew3iND1BMjLc3tDMW8nw99TjTxOdX3k5st8duGJ1TcDJuQcCcsrQ0IXmyAZZWm6bpAYFfjvDUxnjGJfUowonUe6RPxACrksCjmGICbrmVDAUfB4qdS1CnE2AEkkdDCngiW/kGPiDouIH9vZaISWBzEO3JBoVYY1ssKofkfB6GYjGgSuHy9mxoWbYMVURoF6lp5avTAu2QGWl/p9Rjr+A3g/LMiTCHSm8P/ok4yZRK/+aOtSqblqOkNxANpFnPPo1briLa03qsEzeSbk7AHFeBm+YjX79oqdTUBV4Vfr5Db/Ono6431mrz8R01cW/AshD0dyDX+ydmNHpkAQYMHb4jMEtOqCtqz+JY0x6kHpMVLqMEssdazAqcRVOniH3O8ntlwL/Dej94ndyDbA8tlImPwz3g0jp6wSDAG6hznfl8XAJY85/andjXDadSF5L5J1FVnTFnLfBZaIGn+NEaKTHzZcfSb2tbTdfsh1UNbYYBbWLM55M/lKRvupxpS3EB28WXps3b1gpCgrDvaZRwzTFmXI2V7OPyQglm1olzV3fLo1dKmmnhcTV4DERjvgvreG1KsRlf2kvZdqrszlje+WhFOObSAN9s9y3PqKANA4I/YGLptO1kRjRsscMhnUg9vB6k+r4YI8eu0XHngLH8DcLXFbPkwOlQpKytrwJiHFxx/R54zlb8Km0CC3p3GNBnswB8dEU8vIgvtXn4o/G9wq/tDaIjXtDUpThcX863E1HjpzXV9Ii920PUbgBnAb+qr8Dtd+l5p2va3VhW/lBqB7IfIf5o2tMl7hpNQjoITn5MZMJhfc4Md/dkv5XMoI1ozBWTzzUQBsFvS6yTL/XX+8GP5YHyV/RAYdeu9VqrWJjrODHu5myocK/G7duP47cwC0mdhAnSCe5MrCJ3c8Ak/74VpsBobY/KoGX7897famPoCMhLuz97rMUuu2rGth5ooqOdEbNvtXSMKdjKb0H9bBEBcrgKIpuySFb1idmaQdyf5A7xwbe4tcqWXamTGkHMi/9xXZYfOo8dtBnxE5IgJ791761sY/GlMBnTYNK7ht6ReBIGjAQD8X5UZBOPfzILiwms5cHHhzfLM/XucYI30jokmXEXZVLGLG5SeSg7ZLutfWofZcCSA66sD9RTV36ok2LaTC96tLS6o3d+8t3UU7CPsO8zeVbBZKPe4J+UjfquaqYtR9DKxEobNXMAPLEOS81oMQVd7XLlo1qF3CvRWD0FV4OiO2/AQ2zEoOnqwvUrxCASL8wNEKmsmiPqhqWL33NUAGNV7vc/MlTPTE94i8xkMVh0B5AG9G4eZGZT3NtfILz1VdZCdq1GFytxYEY8BXDrivNXFNQUEO8CaDsI7Qu3G1HvbakYTgvu2nlSBaOf3t2zTl3aMRvbC9CLO84rbf9O1AYxYbPTjUxGuFgOQM4Cfc4pjeRIfHr1cNFC/EvFyYk2zgqwsBZwWyU1K5JdSfNj36O1IX64DUCnwPJVjTwuACAfpePwGN2/nj2N60hjO3gssTJdWaRMly6Yc0o8/ukgOV3zy8k3cIC7IZPHMOnTYjKmK4SLBSqKgty6H0/bo+hIn1bsukMQNaUX6U4YuMGcCQBrb5wdOysUIP/aQ0dqjlkKQ8Ns2grdpKCaLdotbcKc+oe6Vae8fRk/AR6Ybym9tuXA++a+6sLF8+L3gp0oKD+JUY0FmoY/uIpJTX3vMv7xnmAr1Cd2xcgl5qUam9YEvIfi+AcvcAxWRYZK3LiR0swqk/0SQmXbMnw2mYVtZc+VX8pU4vWgkPzeZjAqLaKdaTVQ+TDF0beLzzfYsQg5YMRIAExLPVaf3r7ZKAoAeNskfbmUJ10ToAF6Stk2mlzDgSG4aqhLrYXScNDbMudHQ8KdHpwk8EWW42q+IHAlcaBlgM3X3BQoyGVrG4WU3lNmTWw9aQvqHu0bWjIL5G4EIpyzAj4qCcj/6uVhTJjl17+4hRcQXBDY3VghH6VU5nxWbGY8u4ofO38vJtYWCGk6amTiMJDpzqi6ARiOu2VyzZorTBd6uEmpWNbEPq3Qwm7dmMjWc+4CwNijj0luMI1yEBKYCLq6kl9F6na8bGK/65wNjKGrN4XavzNAQWsVHQcL8p8kzgUq1enV/d6WOb8FnEMKH+LTjXMX+5ykhvnSpWsEq+S7nB5DRU6z8E93WjuBsU/HBib7DuqFF5Hr16nsMiMy68gaFQym1v4o+6Hd6Hl9hqRo1b/tZ5GGlQcKybtSahzRxilbIPpN2tvkw+cYd5KYUswoHK3WGPJc1nesyUGGeOuFysVAZ+IDeUXF/mCuCW5IoJz1SeHwrxprOktTVWPbHVBnIBeBAn0oLqWteoIVsGttffs9R7kZFfiVil6U2pQKzuKzFDaxP7de9xlDDN0TOuoVkmjzlBwwXK6UBzOMkJPcubVBtt+RqW0Tregy7UbJ3782h+zWvnhrdFNMjujipuVt7MHiXrTTSeWF8xv9/fXkvRdvPr7wsFtZJ0yGupw3/T4E+lpQscaw8i4UT9eOEd+B06IjLyZ6gALMT4Sh+5Nd/Ymx/+00TAixXWskqPsF4DK0Nge2Sg/KqFMfc8qUsd2qMJCTr72tQFQo5zftyHbOPCNGRLiebnK/UhV1gkp+jdf8eSiBY/RFuFHoBJ73mpjhDu9N/zjM/rIoNGfn1l63/xvW+5QLubn9qBD2tEmXE2TzoiBUDFQWeofKV+Ltygd64x4B9jo6+UOqdhTyFUi6zTjfoyvcDT4Ba8Cm2O7Ia8xZdquVcdFJnBDVO1OWyV8zYk708M7y/dZDeWTJLtQQc8s0Q2BLs9it633g9Jypt2MMQIO1GKuhDWZNLjRH3AGquELOSmg6CbfHGHFbKlQD8nxUxBkL5GUUrjBUOpvz7QrVheaAshTvRAQdFoKKhTGTiErAHkVjmWr3AVPYaXT/lhbECl+5quVDhzdatIjsyiSdG5ySvXBJLTqhNszcnV1jccdEwC7HGOOuqb5bG0oWWP41p4wRShC0+IuYKGQQ6kESawnQGZt6e7kJHPdGFbR99iChDdMBo3uZD4y9msFQIKldG6gyr4bN+/Rrcf6bC9xRYBAF2QjsJaHIgIbxOBaqHOYttoz+GDORNrMbcN2fMXt8ayAI/HTD0DYYFip8ojNGU+c5Rf/3cQQf57QfEjWlNhxf7vWYH4Y5cHsdjdZ6GwZAdX9fdjaFhHAxP5d48aMZpYhdajTteIxAc1gBroErc/vbTNLNVysuDA6DxjModk0eeP/vdUAvWiUJzQ/monrKbZuSaqEuV0jywqsP7nybuXfGpsNSpb2aogL8H/GpasIJWoRbeDCJUTbzCCV9lKlJ65KoJ4sfdbDJs0gKUWoAi5xPIgYJdXvkmbrahpr+3pfc7LTwmnewqwU1cZ841EgBNHtzQGxFe62+tH8rhZHxV7dsVnkuDRc5dTly9wMLSPi/1CiWqoFwc9ZFrSp1834LdM4cyDVqncxUQetozbLBkeEn1eJ/b/eBJtyEEWgTBPfTNrNkPdsr+GwwBL8nLVMgHqLhiw4cA9K1Ise7EQCIHIuX8YmpMQI/qB7RIQEXzur6mX3BlkQTKu2d9nEVUOW/bw2qR1R6lb26kHqH0kYVHWGQrKWn8oV+fkdgIuSROHVxSVkxfYADa2u77vuePc9pdWJ53t9l4oNdGTmhM9vqF6U7bnVLqWUp7oVOC1wJX1GyVMH6mAjRlFfjOO4YVluZ3BxncdnQUlxSnDaYL4Fxg5lp+UYGoS+Q/HJ+ZLsdZsIYuqV5ulc5Tqx5+DFXC+XC3gmp38IgcoNWhDG1FcY4QtxcxPZpXEiaYsX2rqEL20TGi2YCh6OtJ0fZhSyTNFAolXr+FZoxhqSndg0NBOUPalgpcAbn2eTWoH3Th3jj+OXFN+cS2/F927nseTRHVjmj/rQjTIAryhE58ufXCLkwijuBbvMV/OV7o2xI3pGpwPtVPY/CMxx94ear9FQp0qD7MCZlDFs89fdnQzW5yjM9jQRGhniErY/TSIcczEkUfXu3VkPYd/5zI6w49TPPh+vW1RWbW0xcH/niU5LY/gfrBG5ozBoLIw8QB5bnSHYvgo2V+ZZRE1UBDjRiuMBVUP6q3M5YXtsZyiVVHYwTproGZkGKxhy7NLcldWPKVNTvhjkNWbvfbKhE8utuxafWsJYGd+mnLUUcWH1sP6QmHEo+3g469RVfU8aYyeOPYeTy7cFEfYiO7d+ruxuh54uJPY99BAsq26BFYa4sUiZ+eTnj0qH1oDw71gNMev03MkSh+Zxk79vo0NBE/uoqMQz52RsVw8QmxNS5p2CHvGD8+dkCzKFCzJyojJIczpFwMZy3e6JossdY5qbcRASNmPrvU9NTpsIYI+0Y/OIlZU0m2VwVbQuqPRxZ66zHB5bifFNnZ5EHY2a09O4Bs28NLHdbAD4maWTs3V7sFW8INQ7zon23ZaGp53RpFkWEA2jMHIZHC6lYHdsgxQ7XrHetRH4jUQJAqs9nnsVUvOM7SCs1ANxeAatU3/r3HZBEw5VA/oovJP/k9iKaARHFDjneeLpjiaZldp/9O/vcF1oCxp5d1cFzQJQPHXe5Xm5OkK/tgvdYKbmMc7ezAtrQld4Mrpd/ssMfdi+dHUqdcqKjP4DILcObdP8KTM+NQvvbBx4vRXlDXMnDVyg5DS/VCouddfRPa/DdMXiT+Sh9cWMBWh4bBhwjvNfTZ8sWpT7/iYuglmAiU47+8uo+979ORXYMUF/b3EuMslN6qVw4Od7U49zNuRDC8jQ8oVFn6vNXrGQKwr6HX/xzdtk014M7ZhdKrt09DikExPYn4uQnklXI3HdgyL8942m2ZfJPFxf0Ffo9qACkkeJX84QPgOFITUckktza+XErgSl4Yjaq4hKGAho4J8O2Ug2Xv9B27IX88O8JJ6cAWuOn3h2TVTt7fRtNf41zDfQAmNy5iY9mhxgArzHzRQCTNYKkw7bufVdh6RTzNWNJzse5z/eUTSJ0N8ZPnEVdQhUBQiTRPp7n25Uf38N+b/jog2avkH6XCgYfzn4i0tTx7cXtl172EQrSdP8s3V0QLas0pJ49PA6vn9DUbLVmGGMD8YcsBEYlMgSeqfIXgYkWNC8Ihii162CJ+ZbMtbpEzIZfevIb18E2bkXIsoOvmABfuW2GCcflzfYTsHGnKyYcwLGjPf5lIl1YDtuBnzB9WH9IQJHlVkfOYaXJRPApreIuSQtRMu2s+2fS2pCuy6XfOaBrvpVjXiTQCwOIxcq6SXqp2Js652pJrhx/qOuHNahpN/+wyf50M3AZ6BtCPX8wcLnTSIR5ljwnlZrz86GnZJNu7fulhSm/6q6tU09oZxOhmdLREhix4TQzc9v69Jk0QfE+UuUJwkQdjgHCYeAKbQjxXnJFZUJ8C3QAms+iTDmXr7voCC9UEQTlIscpIQKJ6qY4ZYBJ/POwVy/HzcTN4HWCaHDYVGn2Hy55WoejLGFt0c0BZ6IZO/b4MsRGOfQp249Q3cjS084zPca7SUIrxvR0zDhS+FOyKdpxj+r28cFjoXYqOT0b+G5cCAl0n5N3jgvROPEuMHpsb6URwA2Dzj8psrKjRPLSg05LSw9Y96FLEIN4BPzEnHOrvcQYJCAW0iqBw2oe1RD7ssj7cUXB5cCdg2ijqCLlNULovpDFki19GuxJZu+8XblfhDydJrdiCuSVDTNABsmikEZm9Wn5Ir+gyU3Ciy5OJmtr+kc165h3Ee14RbvZYfFGHx7D3WiV9tzIX90tTfX9iat/hwaVcp8zFMF9pcCsI0SWOGtnBKAxa/yl8MA87tnCJvN9C6AJhGb+skTeDrsR9TnDA0q8jWKAy8BK0u5gaJ4bMJk4omzSFzJNVRUz91DV0L5lvgIfUGHJcljDo91FN7CEci+vTG6e/ba6J4SRqzCZ+ObDvYE3wUOguMYHQu7tnjS5U8n5QmCN7knK3cqCjOVATv3oKLuWeJeXMVCA59jK6r8VO8pvgWloQ1IEAp0DUjZ/0Lg6P7L1a8R3Uup3AqlWiZLzoxhhB10cqXcz21m+/14YJCzwBsSDsRQ33wGaUYrLJAhb4kkcUDdb9RJGpsQ2wds1ZVdrYO2j7ohyEgUUyrk6v5wLR+Qt9VQ1DlVGPuX8dIb1QtWFvmgf/7G4S8966FvnjZ3A1oXnaNoVJ83/4poLvyetCP7e6b54CRHs7BjbO1pKBDbSxlqsOP6+vTinB64+kqYXcCDWTegJJbJdsLamu+P5jv1W32h7xKHuB7ixQ9DwAsvmComrfIezW4EnueMzfw1frplVE1nlXAtxSDo5SZjrF13wGkLSagutOPoc8EqiPckG2vkRcCJ3keOuMXR9EEmJrAHx5w8aoL0KXQaHgm9pPHvcXvp19o8ZU9rHOLtymuUmXisjgX+dTVHUAQZygNFhYmUMf/21aKE8jOttiTlWHxCTma1gDI3V2AWaI1x4H+E4GvtJwTIXBijIrx8Raw7szHbMZbyHHWxXICq7itBdCfoK3I3PXQCbx6urz2ftQKGUcy4zPBxBHuFJEsPHQQRReNsciWC+kbOhNXknaCSqlt1kK+snGvdaCjbVbOTJ6GBo38aRihMDyGo9frN/CXkfT8w7Vu3Tk2djtp4juXiXv5IQfxfL1M5aD2YgmHlcazgxyM6ZaHo/Wv78slR1+lmzrNS+IJPR66rhaO4aKNiKST93RODE/BpQoeySq0zfOcbYvmg5Ia7xmUnJ7a5qU1cOsAdSZm9pg7UVZAr6UJl/c3GNm7/SlXIkl9tLRghOy1ROL4zR3ovr731YZy2AfDoSxXsP3xCOkE974OiU3l5hlEIZq0bA6aafFdsscae3ZFkWhA4+ysLciWB8cUi8QqFhLlsSWOddiq/Qa4lzZnnNYXpP/hgcl7Cg970Ya/R7+OIRjmQ2IRYFmew3jGeAPPxJRV1vS5IkWqjEEENh8sQNe7KkTp+1gSoZqH9g7HOQyuzbkiunNOlKsz0vEUkhGkU5Fy8NM6nPUuvjkioVHENqqbBYRpypwcdyz4lGwnAABtgHTUgH3Sl0ClwVhPcGfgs70Q/ohf0z00K1NfBaMV9VYsJFtT8ULwmiX2K4733gAZoPsFwzyYUfw3mtqRPf6bFe9Ki1v5apzrHnwtWH2KB5mizC+1m8BybuugrdJ0oZVVkhnQuxDO44Kx7/CBY3n1NTEYBSkEC4GsGwAplIEAESfjB4uK588Gjio3zgeFbslDHT1KcuxYT0hv7DLmmdccX7TKEgnWAjyWmP41GWRWpPwK3hmRELvGMuExBxs1Bd0Cn2mEXzlNOMYTKAxj5BtJWi7GW3Nanmoc0aWonBEfgt4oDr8AsY2HaG6oDpQYWKqIZYNvjam/EmJ1Ztk8RW98OFRVittw6cAG978rFWjiB2oqjoXKdfJQtjz/4wDtplGEJE47dPCpIvrKy8Z1Uz9cY9kR4NSqgE+w5rE/RKRUgzvazqK5c7mCbSlrwHVipmlqOolGjYUSFAFdirSKhqCZYFNEzpqecnrlAshsRP7fvKIcqRoA0nGjatHXG/FXQjtIRlVmfC5UbRSeFMEz7sXGNk/3WRI3aZsY8742BYZIKGi52rvEFDWIuAUn30i41aUHNMlCkp6J6Yc4D2XWE8kSEqtWCtQvr5VsnU73i//5qT3rr+Xp+dvSCINO+mH4QNy3vpLVE19+OHOFlsi6nHWDCqJSZy/ne3RrJX4RQTXPVncSeOfmPpIqv+oyBLyOYqMhPAajecclu0ke89/OTcNgnHwx/RHMUfTGqP6hfIBYg8aVAGU5VEdi1IfgyDOxFvCbRUjh+/K9pJ89xJgQL1UYB3QjDjmAvZu4XiW8jmKltXXUmv6KUCJEH9GNqFUx6nfmJfOFP6Sroe/aiQxnI17cJGuweeq1yQ9UK3o5Qq2K0UPo4vqCq3usi7Ia6gF6HbqyoDwNv0wyFiSjgnKZ21H4fjiRnXSLmjE+1U9lHqa8mZ3b3bYy6VxdXtFvRWPSTs9gsONkOWNjEziD0MAFtCdixSU5WNb/jd5lBADNl9zciJpxYtmLYVXrJD98LA/3YRZU3zygpuCVK3qEKFxhk9NOQuB6YNWu7d8Imu7D+UeMdJltcqP9UenSZ9uY+EZAskSkuKqcJi6JZHcjlsRYS6JCcvcHkc22Yr0myqC8lrBh84CoNAp14Y8Eo74DjwsV+bGkYgWH3ZeFMjBYo9MCI+yRLQh9xHkqK3Ot/6UK2BmuqqjIjQDXPR4FyN/Ovj31ztL68TC/h8kPRakkBMuwEb2+XM3osGxZtA+ptaRRChAjfad91SPLsqH5ddL5MbmSdkCZXJNK57zhxSh3k5ozcf6G5KUxlhKh+HFE+f7Nd9A5oGIuGV0e3M3SPe21a5z5PqgvYD04WjNZQv8D1Nj7cTownjDLPJi7BxsDmOKzjwwFS10iinN8GtP7dgQJo3oVG4y1RbpAKbmwwAnS9kMHBWCItdZSs/rXcZaUoyPYb6m1+BBpoWG2sFdOub2mS9qIhpf4gD6XCFb3iIQSxB9zslXshBsl5sD9nSJ/FxmwTFwzRwc5+4edGMe9FNQFNBLmSj7ZEd6vwSpK3lyrwJz8r9QVA2hCYPV6SQPIZm5JZLOHL6mGWX1Ekco9iQAdMGzuNq56OGEjI7khne5PrAH4ksSF1EpA1uF09E+myF5g/w8/g0w8AKVLi00NbawjS9OuwvcZxNzAku26OPSFvPFSNjMtrBwhEPxntToRu8RjF+pBs3qOLHUQ8XXnUWpq0tMIvyGZGQo6cgRQm3OFinMhp8QRLy0LdZXQVMyNPENwu31cmIriRi5Pf7MHxliLa03s7EGLHe//0tUzWgTcCFvxNOPeo4l564HMGqEsZ1pQIlyE/2QlEuKGSbqcJS1uQ6np9nNsDL0Yzd8CeDHd78pNhCEbxQnwBaGFHddY9ZkTodroqD09FI7D8h+dA7U/ogm6QtcZTBvePmpNVtBsBkXIWRa6fjiA/9byFKEmoYgdfhrKrs1CohLrTwfIWZTymUXi0dlwM2+EB6TM63GyHrcUamSBLh7QVDqz4qBbBS2BpYpr3dpsZno6mjbXRm7k1JPQpbm1BbOmVzs7f+ghMTQfw9Pw+nkxenYi8BTZ61DKn6xTeNKiTfNB1nfJ84FIy7+aMq7VjlvfyEIQQe1AsnbAqWNRgkx1+bFC9Ta0AZdOeneGhhXM1D+JVRBkj4SSdtQPD1Aj/MfGd+AdnTtcAGC5U3ptGWC4VC77svcLcqgUer7MBk84XXtE/wpgbYgjhpBloT1RxXzwiGOdFqgruKTRC++yx+3l/RJefYuaYS82cDJfX0kMnn/EPCQR9LuF3Oc1GUF3I5lFLM3HSw/Qh5PRw25eOtIJwqKAC+xKornzjBdtbd5Q+Cz60DwSHsSBRuxhX9TEC1O2z/RPQCu2Tc/FL/uRLTYSy5QtpEO3teZ9v3lOG37QLSuCA8aDGsEYO54ee9Eq+6UNTb311W2KSGtA7yWsPXwCjzPrtSA4iDSDZWxYVDfi36vma9DhdBaIvwWt4sOVI6PpXvJstErKyZSvc0CJjJTKj5nSrkJIdjtvvQgmNJpmwhQGue6Plnlhea4fCBOMCYwL9zJWrS0xlEam2DAGfgwlTlU2y/73ijXSPTwkjCCOvTOzFnWzr3h1no6OOcOzMkKh/WLZ0JC1sQ1XEeg5Gq+Kfcnpct4iaUTc0FMUWJes1Qb+r2KcTsb+NTNftVzrTHHByQWiEUr0PkUMY01AEawHqmTKg86EgKVjDDJkSe4WLWouzbOtERnpQXmnaXBjKEitnfh5zgo6txWRI9VO2BzJJH8VYbGudLukl3WEX6ChMFL5Lr1/D1t/0Talaz4JVg1J0S9b2rprJjZmW8kUpjrO+hwuvA3/QExjXMQk8cARk8wwNPPT5PmaJnI5snOakbe9655n18c687VIwKF/e3Rssa6oYbvwVH+jdYoULHWh4A1EtHl21jbzgJjzu3DC30HYddRd/6sJRCs9RzGzH8egFDLSxjCIkrkCDvIANZdjEkxG4R1tV/Oy4Y/Lv/Z9teBdURE018kfvXzj2jdSOR/l7G4tpn0y/Ed6yYZhomT1xdVFP/jpIKgZh/dPfLbeM9IdnvQnr1UA924UMD5rDBzwe7OpjpXB5OqYa0lyOerZInZtRaTZv4FELft1OAxiQXI57YooOKaW13wm03HOFLRq2fvsP7sCJe2dISVoAoapFnjsxfPKRzQ7Xn/tsFuJOjWIMTBkDCNx1kNatks7uSmfWADxpyhtJ6ruYC1Hc5tHxUMYTRPhNVEOfq+0E/mDh0pnRvyyYukUb1OQW1OKHeX3ipENU4gDNnVuPcIwwx7ixo/1ZAuTQsVXlEukTFNDHyrSqnNh2UTEHVXL/xoY73BVZsHco+5DrBf4+nXz8/KYVoAY1PNeIJtoUO3HmeVhUN+Oy/Ju+1O25H8wjdBcgb6+BkHKC4J6L70mQFIXkDecrMo46N/gKYNexwoPweu5SZHAMYsXMfePAtIQHpwBvWkFKmMpTkteMoYjLkOyc+jsd3BALZvn4qEs3ps0mI9BTEZsl5g1eeR089ZaUtGI+ilIQe4+JVUXzqE4mSTuM5xdkxGQlE5gjhhPXXzQCtcbm7Z3xCgcT5LtR2s6cbk/0vEZDAA7h5BSSRvM7GWkcrUIIouTIGBrUWOccEUTik8LIKz5C4gxxuSkyk/NAzubjWcQ4Sk72e08KcFOKbvEqDsoYFLqZwjR9nTZcKqd7IqDLajuVqbJKvNY3tQmMB9hBSrmffwSM62FZLBuodS+h8+M9KS7y4rriECTZNu4i0ipCfEQgzLwCjp9yjEbdZKR3ZsuMpzsyJsDe6XpF+k787ewhBdbweAAYTrPxQ4gDeObl7ZiImNgBxvjSeLEaFek9nZIC3xnNAX7OR8S4RVp5NDLs71AJ0BgkaMG7cDGa3PewhY4W8Wsy1U0ZMER5U18TBO3RLCVVrJU7Gyi6oZdIhQU/e55FqgyGSMcPwp5VGtpwR0CHmTtjJkKWVKDqjeyRuKsDOZmbW4WueEcd8aGjVXf25UBAG7QNDm4XLk7iueHcX4GwxK6t0kv5dmL/IFfBKT3RAM/+Jo4IHISi1TafRPqUgoJj8vMARi5s4HXnR5MnGQe1dv0xMsesVkoQUN5SauLTMZlqR2MWXoM3we5ni0yLI9ih06ZMXYQKr8cyYPDZCtcUBzFSnDXklCOxtT7Z8fapQUQ1NV0PcrMTWyKwX63r1b+B87My3yQwFOqjDMGz41VsF4eL1kWY2Z9JHzzJHZigI8YmOovYIkbDqBHSlKgVw9UxajIhvatztlwlaxWEC42WyfYdmY6S+soMjSuDF0gxeFRdSXEuUQEe+QUad5uNXjmcERuZFENQAaotGeyZ1j8wXco1jEpfcWZczhwDiKbCsmNirkfiuGx5aMWdUG7oHlHKZWApdEBaSaMz0WwzVH0v9SEvojVL+tFoZfzGaEDjZ97/kuuYZN2MzOHXU7CRGIIdN+qQvxUvpi2LEIJm5pvF5p6TV5D4Bfez/dpbA1zB3E2F8+aRL51nCKhcOZxXo4dS2Ude5FXfU1f8TgyV3sbFgeX5PLMNWVc7H+NrKuKo4NTRCX+EIYVZFtrZ2MZJyl/LET4wPhWX4WrJYSvpm3WwJt83xlBkAbzrhSP6NuP8He6YPwO7RzxEmxBwKoarHibL/63bF50Bh6FQmnIfEpD02fBzFtICUo1hah5pA69NHLmBUy4LxjhaK4VbTlWG3oLXgYyPV5KtMGQcS34kdpdp1e09PtsrMKWBkoWvlb47wGwidJsfW8Of+suS4BnYbUAeWfPwRD/m6Ig5GOPItf9DAwIhp8dZ4DhiHL7JHXwtcR4z701d+DqslzWrXjl/DgVNKo606dXvkPmd/smkSzzbnRWm8uvtg9rsMz+Nt3Mmd4ll7XARl7B8G8JJDS15QWJtav8Lf5Drs792FjaVbto6tH/F5Tg77/11+UE26q8iItlGBJOI59Ioyldnv2YVSwlBkQoN2uOWKZCewalsTdKPWRsD+ZY/VcNSVcvs0Jh8i2ykkxo15fUsKFkBkXMYSYVfL6GVvQKvXbaNtxt5lw08O4q34DRFQlhbBDfktEuDapiqrHUz3dfYTuumYb5N6xbynPxEF/IulMdcE/boKp/XjQ9PDzGHKym26B6RDLnXExXUXFMbnCUYFddKnGJW471clZj/HRFS9dXV5EtXU3gof48fPZmnhlQZvZcgszuRhwMutgy0QlM2TXubNnOI6xx67sWi/P25fYRFW5W5Xi9bzt0Yej/s8HyAGFItnFieczDVhvBB5hbpIWu++j56NnP4f8PLazVstNYPjAiHbmV3qkdM+HIZXT4aiotX/cTzlnjHuPo0X+QW2hgAmtUGQ0jtgKalxzOFeUkc5nqrFAS7AvFVskwuaaBw0mGjBZydY4ob1vJurgG9dtD77gddTfJm8soaSVNqTfrZhlcYGVxzDV/mw61YGhpcHy8dBGZVdJBm2Rb5TzL3eFIIPaEWHbyyo6op17vJtcHOnVvCMFYNrq3c0Bkdzk8ThSVy5jEbr36AZbkFCr7bH8WD7WYSiw6xe0UQbejgytIMNKHa84JiycXIF7PHIttFvSKyJ0D5CNI4QvCl4ZYLt3r7N0qxR3Z9idhw6abCpa1InJ1Riolsbx92GqkbwbOqcV9cJkhGUlmiswb4AKICE9o4QflGthacjRY2xbjVrLMnxY//OJR0XP/Kqsb8GZW/BhhGrJVD2r7Roc4HMbqs8DKI1T9Rsh0BBwQZQjMQ75nFrfDOyafumJPZz/1X18iry3mLhp/xMEH0fEqkpLUsXPu3SPPqeHhYqCCexUVPSyldPhtHJWYNmU/5UuIlalGPwqZ4SEC4Lsn1Np8VKZBj5homI7RfIBLBM3W9/JWRpGokBivY3T2bgjHKLYKB0a0fENsQ1qZ7BQnCDuZKZJxTZF7oFpRauOyRgqCmFYvfx+IY4mMyRTR/y9FNaFvXjBd0wsg/oEJMx7wLAdaz1azLwpqyF6x+F6WOhfT51NKrgW10Ayu73QjG1GgIrbkJSSVjRiVsgNjGEutUsF/f69Ey0t+ZpkvqC9OTpDUlf2Fvw+yrou+3iYF4lz2vNe/7Cn3E6uTwQAptxsIyFS1rbY8Bc3s2tm1CjUOfGoiLMLiU/bGWJCelTgCF1dCWB1JUNFlXQfscRt9nHUCgQ8t/POfNC7z+84W2Dvn8h58tzj/dz7Gh4aZ1dWv5BNhOHt/kF89UUFjFEvG+dpCA7hFLKW2X2WnJTKvNW+4zcf1xnlRhWgwOwO6IVFB8tIPaWb2yLev0Gxe8vGjI19DpjLEi427NoSWEj+IAWxLWh8/POJsK38dGsUwW3RNv/KuXbUdhItWtNi1d5hl4symIE2vvvJ/J8/rQQBNpNQ+Z4qpYf1Z3EF1FO7n2zAjZLuxcqVb5Lv8nVHntm98ZfQlkCZe8gUFfFnyAhT5+59re4bUWCSwsLpW/vT3qe0GdaioqT70x9hysMXAsMIPchAr9M38NET4CgYftaSQNUBrgrhhEHghmAsNCLEqvfqwJNF3KB62DeVCfe94MInPfB8eC2HN7xZfesFkytOj0NuAaJZYPdNLqU5YlUN0b80XLHhveiolU+AmmodjDdj+CsFBX8682t2jOV8g3TREpLExBFtEwFoxiuyOJY5wFnhb7g3ScI3gfAM3xWLTocivb6Q86f58wZ69oGpVOBCx0tFSXFi30FpLr3+Iw6/Mkixoey1C+DlABSibrFIu5wbSO4c+fDKyFsxBmHcFnSX9HUef488lfEfjZJTgKWJNmFgcFD7gcM8/TUBtbUfyv+Bf38hIBO6qJEczh4BWojtrKl7JTCV9ytzB8tbsPEMzic+y3PPT8WWIqN0SSHG/PdOfku8Z5ZEbNBCyaAwWXMOhK+WfOO7WOQOCUnypRXMSXCMp2Sc8CjlHqqwCavIbZv8JIZ9WAep4Js6nxuUK+t2b0UjEOk9jMvgUX1dD63OJa/rVngKsb2bEhZBHpauxCNlkuoBDzW98NaqLBbnj+cQncfCdkOEkaaBSgiDLAEJA2xzrGZDz3zdwa0loGjWgW5bsRN9ACSlpbvIEe/fNSThzWRss2GAUnDPAAou8RBHzmcNoyHsz/Roz8eNJ5V7xO0rT3gI09hKNNWr71eVmmeCNNZs7xiqFLIK1YwGBD4wDcUaJJ7KsTGqLb3IQcFFMkYFscrW+ElYFRXPSt8UttnqxQwdb9GCwDTKzX3iAB3Ua4OnulGoUZTb7WycIFss4EJLjiKHtBvdfRSa2sNjqdRrfCwGA+rnAHwBUc2yDYCQayoTTAKbXsXqmZXQO3FZA3a/ZBzuEyultICkeA/bvUAkdRkwV0O1Q2cYnBBrEjumWTd53mnLLevUJ4Pwvyej00fboGAkLCOcHRYA6CY8HfyWgQFiRV69RpHo32QGd2RxEPBW3rG0lJ7RzcPPH11ADrQm/KmSgxDuEp5RIYR2vN0y5CzXFKw94SCcWI3ybSIBsKrgZ4EYZ12YPP3eunhFFveRrTNLtGCkLzoeAJbBngmrYBrcI0q80Y4+gU9gm0nCmkEn10V6xz08SYfXSInoxpoyjYwO7/MQUp4jqFCOjA5mYBZVa//IF1XbsWQbV5XSdG6GjRZD85p+cV69ccBVc79Vkpu87NKDob3mNJvwHJ4xSTl+FZ8CuhiH4Nh4ctz1XDN3QJlSt2yu2ReFeAl5ObZYZ91c9bQ3vu2qJ8w21GQ7wbttpRPfUzyNpqhtBfg+LuFU7M8AT/voIoKo0c6cAZ9LRQ6jlATGr+bDchoqhEbLipx1mKHq6OpDqh6nPj3fydT2d8rEPQp72pd3OryM8j7nTP0o7bnd/kwF0Xa6zl3HWSk29pYGYc5xlHL4HHGGFUMvMhCGNmo2rwK5AFFw0dL+XbKAhBzPOM+czAy54H5PHHQ4yK+5GlY+mbOCjH6PS8r9saaax7yQVa8CFSL9B3tK+DsCHTt9boSJYMvD3kKNhkO5QzqvDKgekZRrzw9EyRf0v5DF2KrGfzDZtLWQWD6YnQ73GIVPh81pWUv2UiOX8VJnw9plq3m2pXxmTCVZpvNGZaDqFGguOJaKKvYjjOMsSTama+kVJkFYMs4YLpYV8IiWefvbV+KQSm5pEXtNeUvj5Pmfi2BztVwsgRUOmnjfCLS5hCgmTIKiIrdLRT9vlNwO2gh4rejcjXfvwVfwJTdUPNaEWAIfQeVFxM6beTkdJX/NccjnFkvsz08qPKqHL8hE7ijZxFOh/+DfU/AdTctnChGKIj2dk9x+Zs4kBp+NHE6O2X//L7lsm5DYEI3sKdq1QtVfPg84TJGb6UjOu4uW9XUnQ6XEegMIsOvUURpOtLt16KixAJw6E8lPjbIwYt1iZzRR3sJd1PuziTis62GPiK21ZUZu+AA3RDIkCkOjN802smCSYhukb3WEvq3q8nN4YG+6fh0KanypFwwR1NnuOIS/JGDGgP7m5RFSbQcS/TYb4hrLPa5dk0ryqbUQ1J7tm7rho4yr4Br/QcBhf4NLvUkPsEQ852p1yUpXwpXOKd4AEnDPfU1yRNdHnFT73ZO6GZDSvqmO4Er28/1wFHHsJT8zETJb4P5h0M3jjHUQgPHSyG5BxY/SeUQdZt3EHB8mrgpFgCS+PMMfbeXO5ruviTNINK8zjarZUfSSSN7L4WjTvKZogkOHcVhoY2/1aI1eclcrCOXOZGcRrTj+o0N9DE/vPg0vrHi3StjLW+BEThXuRLSmGCsZr3wm82UdIeflOIFmEGIqPUV9i9+uaJIsc13xLldrqmRie+BY1KFyOZ7GhyTHn0FyU6jqTzvkgmIzEmmNkt5P3Cqjbo645SHAGqg9yjduIwVJ7RCknO07zUaa6W7CWSv4J4RGx+WH7MlFpekF289ytzJeLd3QJc0VuFkLDRZoZBPHlCoRnl47X7p6WtxhKOBcNEUboAsnyQtulBhxIi/msEdWuv4CKbZ+78DFR+JzUwH2y9UkuqBKEQNX7+Z5GYzL/t1M5ShPjFp4cJpVr2h7RZO1M8ULc0HOL3QOWi42xcY+3PQCFqB8tD77bA0Fb5w7Bu1c840uYHy9J/+CcDEbkgE60WqblSALoc3OceGgR8tKt1hIByPCzix3gtBF5JTxrcaJtxNlECBPwgJgLKNQ6BVtGf4nsBhzeVvydSVk8XZZ5X6OYWtQ0r6BjfTGOXUmJWwpey+rpAIjDWzejGIRat/BtHGX16eAYHKil2vfloEbw7n4YrEOtM+I9y7WUKavNoeD6cRm2x1am3hRYEpJpgTB9kfcCJ8/QOmsPulJrxWUEE60QHn2m3jSgmBBO9I/o+OMFfZ9LZgR2pP9pG05Kc4aHq2cIA5wzo69HUFpSc2KqtOxqPyU8KeMokNlMiPjLiqdM26kehPZ+ciJYUQ4hCQQhtKM8Se+5ExYW4oMv5TwwX+AAEaSa2KfyCuWB0l7BfZRlTtCmVJ+n6Mz8viyoNQcIDJlMypAvkiAopCcjWPOUXvkAAN0L0FoK1hJbdoUQsoUXerjZYhrbkAPlSfaiU6yMA9C74MbsyTwwTcPkYQ6X2ZXeyLwNW+y6xX7FzAwDEa2mrlQ+RSjI2pfODo0XEAxGEMnr/n7SjEA3qh18Yon//upQay6BgfGkHWUMNgxdiZbA0TkwRzEYECQ3OfVlgLsCN5hmYyWn4mRllDIn79dfiZgQfK5SlWoe6oRVHaqjjfZ3D85cWPPBh2qX4u8L/80cP/9mrle7AWNhgXodHpJ6AYnPHg5w2Q2g6Yi/io32WWX1WaTDmFi3usH8noB1ox0EkQoxWImB8Calc9Lf85YTxr2GzVrbksiGhHbZpN6YVa5DxIvZYwLdcCW4jG5I0jH5+1ceUsTyyL4u5N4c0BSeIhznxsP3nuu+/RIBR3pKLm1qsYWJTwDovsdAgYu3Xk6GbMWs9rHzvCaJmB1e3lAklx4X/XC6oOxP7ifx8/Zcu2+qfsRLY4TXz9FK2Gk8mUOgFg9z5y3slzkAdS+KUQDv6BWzIpydt6fEgXd/QVU9xVhi2jhLBSs9NmvmYeicwn1Y2hACcCXh60C4xq1/+Q3PqT4Ig7ahgKEk+uZnEqu4aUbQogMSeXoFOHM/KWwpzDTJKUKliT4uEC5JZEH7gYAMJg7JW6wTXugCgFjbkthGrXxsduXP2hUcW7p3NCPU/K47utDPVBiRSWWzxWEINB2cNErlvnSlycg5KjjT0DxODtpvlWmoEE6hCEKpN/dFvX2h3Ik+Yeotc3TsyCqYnbj9ogthhIRq6o4Ys4sxmFo1tj7hQgGvtRlUQ9fQzJBghse5z05iDCORhsIGjwZoypUVIYIS5VtEWW6KQi4+zgynY+hdsYmJNMPmEDvkIcirVBc3ygMIg+zVW3thzzBWKJmILHdSKAlOfZeSLW1H/d0d0FvRzISVwd+k57Se8PKrm3G3J7p+CwKcc0gpuHuI+eDIS47yQSS5VC4v3zhv76PMBcTPC7Xepok3z8ycwwqdnDIcnNVUpoGTRkotBfwCUqn8oOtAt4MXtGwk32OY4M04jlc204YGQJPYsIT9xS9nOf2uicreISGcsoAwQwkl7uw331wPjgxSLbOsdaxQULtYoqY08k2UY2f8xM58440/rVXzdYt+du3MAR81SFiBEo4WaArOxafAmbrU8KxpWqteGQbnEd3pNEEoEcpiUlmU8tK0/OQaBz1ZQZFUpwW7yEzhctO0dqW0XWvrofJiqDrQ68wX4oOklzfB6JdkJDZ92p8wda1k09XOzbdnTatVWmZIIL2YGulFib4fl5KmiYPaphv6pOFUG9KfW3bI7wNgZWTP2yNmKs53rLMzwFvDgVQU7hogoMnKD6PaPzvCPU22iCM5ggDHF6iSeqtDMmwE8gvATcGlY7Qfj5yCuimdXSIs4h51TpDke9WdKmSnog8QJyd2HFBjDIBgjPbToFP4cgvFDtUyKON1xTvZEVFgtdPiSD2VFrdWXIFBo4a3POksSi3ZdjEb5Xezc9FJBuoaP6jpsbM3kqcD4Wkq0K4vn8TtpuJTjGrLrNM+ZdmxTEB/xnMAK+0r5vLkidLbvusCxSduI5sLVmn0ZN4orqUUAhrfevE4XFS+YSiMQBYWfoy4bJM5lonSQrxxfjGtb1MpdMpihhdiqup8G6dyIp3G0JPfA+D/zf9xaQSPv3tuhwbqFDKzzgCKB68jOPZVeVE1WRAPbUN1JNaORnafzVezOPfwFANii1d6+orHeDPXZlsqHyzzdyrIyBrS4xJbaDDoL6FjWTcUr3hBRpJvsvzeKfGMZBPZO6xTPPSK54hFMh/IdHW6MUN1l8fkzqCT3IFuSCqfG0u3mNQy1QGrVcf3fpel4PSSXkmDU538W3KaKl9iQgMdgO/V41d/2EaSa+A4vdydNA/hYCH4pJAbhJ6ZHZ7X4d5zUpFH/+INsaDNqvvtPt5NQyEGRN090dacL8aVCQ3UifmlGrbuWH2NK/Z6SuzGnXl4ZuIBtpBb8nvJP5r99aLLOa8bD07YHbt6RcGGGk6S3Z8AWoz0c98nM14axcj5FKf0juhvoaweK9Hf9jIolH41LR5EmH9WZ3TCuYizEZ773FXRMlE9ssseH/Dm6gubI497ch21YsdBJ4J1KnAVe+BBqdhAHL+DUAwt1FWnWbR3mmy+MloV6tvSF+WECMxZ3wJLaWiPUGpkxfkM6QhNj6N8l9YucCXVWhFiaKRgiR1jYOq9lCoHCi/l0RkVD01cLCMbIcGyIajs3PaxXT5O3fx2hn2KgGjPVY7phBvrd+npMbD3hDUz9WM9Bckff8Pro5mHdQ8yd0wPldmK3FR6L7PZmCSvp4k4BS0itGMBg3aLYhqjYe+yhqDJaf5Zean2aAqKaeqEJoqO823Ey66wzNG97t8XHHMur6Py8yyqVfQuVsGE8y9KQLEUeEbmuxqFi5ltpoaBq35nKXEczcvoUpdA8oAnfevhP7e6gi/8R9cUeRCeb4dg4GlX4rJtmj8l5yAfKVH2pngkFmcdpxJbT7epOaQRmUhTTrLwQiRhMQ2JvofIHjWWpwPReBD5uWrPv7ZojMzrZxLlGq285Fvcbl8ibPgiN1Tr0XWL2glcHmvVXjwzXbDHmC4aNzMHbgz/LoCQTE665YsbAQTOYvupxe9oJwCslWO3dFI1+WTcsLtq1FHVGZAJDmj4fNQwcQwxoesa1b/CzQq3WCXHS34LxgIopRu23X3pQF3wKOQF3fD1RMhq+ucM0VKLbL8rtjmIZizPQgqMYkdMCPifjzBzME/azXkTY5wagjFC2E3ef15odWhzwwqPF/mNULoChgVJgwQNynhStHCK4I03vyi9r7B6FlL26u64rRYQt30R+6UC5wG49liJ5ilPKN9thyaoxahxcGNCdai4JxE3k9O8XCOZYiaQxAog58Q9bHjtp1GDMkwUKR8fXy9achnfW86PaEFxTzfpgdkGY2IcW3ODFuF6v+5ClXa11yxnh4AmRNZEgoHHeQ4s2ugDFkXACi99wdHAQ3YGJJgwTPuG2KKymslx0/ILXwTEcSVxC7CS6cxYF12knPPiLgvkgoHoswBkRz0ciZmL+B9qpjEVbu7eYPnCb2J516mhfZE10YpIGkHOXgKZaZj+KAFV0MA2gIz/LZEk5Sjq6jRRg2EEAFzV7Dg696dJQiD6XgbPFq0tM4Drs7u2W54kbl8g9MA8EXOrbn6QxM0w5GExdhCa1JdiHRMkfG5XinPMFwXWeg/DUePdRPm7YjqqmLq+JhavBBvFO0Ohg5hSwKzRNNmQ9sNuEHiisl8V5vdEeFUK50bV0yNZYtMBinZ/5BhcbPnuUFxEicmxTfglnGmHPmk4eJ/YqTrvsbE65MO14oZluzRr9FfIDkqkxrHt1MHUfrC6RdXekNqEJIKsvtFyR4zKBQlQnAo8UAqRJtloeXygf2LQtY/1xpFnr4plyPvBT2bB6nLnhTCy3iMNdcxp6q/5KUOhRa+mb2INx3asQwOFcl6V2lxjF28NXcIMBzgRxvKhfMxAuOdMjNOhoADG42uOOfGonK3wBfC1hRRHpq4vtEwz+Ab9J0e06IyIevF5+KeOahmgIgF6dnwYezdBrOlckUeQaXJ1fZF9dHXLkcHWAHAjACz+WSqL/FfBCGcqQ7KA/r3bva3xXGibsH7gKTpLWmFQkcEPXzhRI5tu9+YT0cL1dBL8U7bTa5gVIwucpJQo5GAGnpgQf6a7LngdCt4H7KuY5F4MTdf1VXYKvpg138NHvxobJJqqDAfIyLnQgZBEI4jorwzQ03MzWYIv4Xg/deSmgXMNV7eLnOvV0ZJLwpDAyili5UGfhMDsJ0mufirsdshtfD4MbGOfCkbfrgGz+AgXyEw+O5ThUcubbNJ/xFX3JkJ5HkBbtAKaQMP8mrN/Llrwxa9m8hUyldYMg1Gw1/KX4tUOQHrgrJg8eB6et7ZU/CEDjoljywS62u1I75D5r4RfbafZ8iQ3zDHrr9zysjh1+yY0mvNAxh/D7lShfLyJfLYo2TgSIuLKx7OJlOHsr8KubEjRBjKxvU8kKW6hV1MwZPCI2/SRl5ACgLLybhW+mOlcgFEX7rXSouUNco5deBMMkUBQBJhnHl6Mpx8anCba5GExTah2KHXmDEAG57jSVWzffG4i+wA0Khczfd159FpLc0Pg9fnJuKtASUig/ziD6w+OeRGQWZOi0/2x1XHiJydhCenCojmu4tSCUPvHk63+IW/eqyZef0H9YCiGOCFDrrXGD3oUGYhtfln5vumBwjJsf/4zz8eDsH02shq7ct+WS0Duq0HdJug/fbRbf1/WKjZBeMOJSXi0bAG/OlJxgpblazYGWNaHQnRUdGND7hyzri+3BOz9TiyVUJLJ8JwGnQifq9G/n8CdA52ZSGMXFZd83rUD2IryJCwAph5f8JVTZs6KvKaLhAVb5ozgH6+6UyWiWv33LCb/hk/3laJezzn99zIMYvMiYvKHXkmjQI5XUiAu+z+X7h5D7zzbJ7eS21+Rl6XoviNhxYYbAw6Bu3ZaeEwyfcHxsTB1l+EaX867v4Y8YJV4I+4TjUOkLW/CsUwirH5XWwuEnXvaVHNFRq/uG+iWJNZpvgYZ4LFdxWBUXqC/JcuoHT/2UVLSnCT716X+VgYJIzgEc/nQZKTE7Co/7XdSV8tN+N/qv1alZZiP7+A5c5Gj6vApMgyMvSHk1ZxmJC9ySD9u3sdZJ7u7KYUYxL6fFxX82+RAphwWwMOnrtdir33e7l2HR+qSPp5tuTztBh2BHfaGrMWZklfmKQcDz3brf4EYU3An81SWW6gVmEuzI7j0aRfDMzYECPSpV1kGPKjw5AUAw3nJM6B1ngJMGxcFOzfFE5P3ifCDn325vK5Zuw30z9gGkVaH1yICUHfDcPr2rUlRtK/2Xq1WNfL+a0aifDx5tW7api7fp8zvDAH9qI24/M1OnaZubcX/eOmhXKvi5u9ZUbOhLc+8ZjXwSI11oxPXjKtWpPcjBuj+4KKvTt0IyT4cRJjSubpj3dZb6CvKKepb5nwnSkFJ83bdpeCTG7ESjnSPAQo7rbUGp8VGpzjXhwYdrHIKRmkndRK++R07njZub2yEqUvGR8A2ps9lSimt6Np8qP5V8BACqhu9amZtWYVw1PHOVAHYAaQ6Txa3yPwVe3XROE+l+Vt4rk35u72Ev7S+ZUiuCyf0OS9joI6O3ZHdgRBCraX0HGCyVMGr+0eYhRNyZf1piQLb4gdM/gLyqK9f7lTngB5SNonguJ4zoqV2IDkI3Fpj+hvrvKBYg3aBu9Ihuf2A6H3s4w6OShNkw6++jsIi3CUll//OK6LAFaKKujAiDOtV3nJ8IgXUIQjWin2wkM49BcO9wX/gYhMrrkSXdfiGJxuCoRkTx8EZnqSMZ36ne7YMjtQdpF6wXCvt1xf11GJoq9OcS8L5L9wQd3maQ1ixQuNS1d1u9MPzQ3lhRBuiEotWtBNCz27edhkwF5Xy9RSdHkkiWGDHYDRZJYybHhFDb7cEBXdD3xjBzshzEjUdO74w8RkBwdvPKNIZIFyCZCs5Uznw2CRm3IeigNRNJMHDLE/tEIrEwcVmeKeUzYv77xdm43HOfcPDPZ4nR6VqlleHz6rfmfkcj6kyafFb54++KMdSvzeINdewHdskZcTFCJ6tQauS/PpkyR2oPd3Kkr7FBZq/xpWglg3/I/ud0IGmI6lKSGQ9SzjMPOqBHP3XlCgKJ6y9R75sgO/rFn8ZOCeV1JoW8lh2bxE3ieL38PKXzOuN6zy6MQ/QxgiJVO0Wz0VybwZIt1v+yIzCSJoRUexZdArNl+MDcau0lvz4kK2Ly5aIussps9SZsU4zHmFiq5RgdCVpsNQv9cKkeUY6PUktRoliVqH2UsX5AiWs1xv237lv+uYIl7Yu0Hv7rxrcFnh37ZjM7AyrMIforxP1dOO85M0EKg/cFW957oT2gbZ65GnViENwNkrF0wz6oAANxtsLgl6NtsqlmnSf8DBInwO/Lvk53Vr0TAgzQ8M8RmwWSWFtiy/SnVmF7MrC5CeNMIv2fG102PVesYbBLtDDMLMyvaf0PMMwX+c1DYlCq5oz4i0BAyszHsZ2aHikSzu0SWT2ROzUTdO9iEjOTQwG1Pgkm4jecyypqcVLVEMC99zazj03F3SWOWqiR7UNKcrSU1Qb9sz4SM86Aca3SkaEk7hi+gPxgbykij2vKlhGcQYiAl5uDeVjKC/Ltl3x8hH7mIbVzhMwxZnNu7RB5BPw8ClRFTkaXwh0Gol2aMEIAgBwFizrmDCymw3JpZwceHHR8sUw2wrnda8twLUBcPQ6HfhWDyhraNTcvQSl20jLopkMioYCgwhaZ5T27fHYb6T2f6tYnFSHkbcLryBm7vtqNgXn5hdhGaetyp1eJPke7jdVkhAHeEyfZGx8HZVFqTi9sMFn1WgJceIVnHWB3TLAA2I/9PFfB52FD0P1AK/AIgOD3DwznTk1cuGOi1BhxvKv2Rt+2wf5RTfbbgAXXMv5Rn0Os6iHCIblNCO3C5KnVrrQ6CPS1IpXGisfBJXzXqWQt9qtdsVx2LpMA3itYUABt3yi9vLT/xr6Qp2tx0VVy1a4kOKxgF2DVwS/tqL/Ek54R71o+o6ehzTeV1YY+8aR7G+RWwr4lGbzyFlPDo83b5Q+qJkpPhl0clPlcZp2+CSktg4JhQgyBT/3GqLTImotBptdVc14oqVP/Mp6nMrj46npFZ1uwbmC8OpF8feEDfXkBFw+gXPHmcqC52TYxioLTbFnB0TN5NtY+wcZ/AdotKs+vz5EexRQpo3GI/q2yJoKMcTag9VJ+Eii15s17lx4qGfwIUkicKTcIPDIJ7amesw6jo3Xk+qkCN9Uud4OWVk+F6EoTFaWOjELi6L5db/BWzsYtbsEKZKpyFHn5rfasI7DGiF0VFy3QLxEFdxWk8khCEwlN1xTI3XNd6lxZWn9/FHfCo9TQtmiU6H06xaWap1GdGGP3d/ILlOixSee+5Q4DEG2/sDD69PkJCxBuov3h4dMFZ24roJn2xPmB0QfAMjrGf8PpyY+OysTgIyWJquwlC/n5c73SUlDa4OGjg74FXWfjkRQvwmTekZOXvhy1IGOZvU8B8nr0M1WOhATJEdP0KFr0aNSmMfTbX4RLUwvxIRGtOKRdkLpFqILOuUWjCgX/DxvuAVFhSTwjxXoWr+xfL3k/RGpjiXSUYbARGxcAlaD6l0wTY8BcWCGd6vPVu74KzupHfl0vYiWwM/ZbByzoV1IoSA1xuFFUuaBWxAUUcPndX3t2J7AWRw8X+C+56zZu45GXJ6RKkbRpSli6qICbQRgBRzAWJz6TL9W20u9O6CR8JZOjdT0UY2f7oXmSRJcRteQ1L84lX4ZEWWbr34KBiIvNjeEhcD9dL1rL4MAYelZP+o5/hBqqZpdXyY+kP0Gk6PJwcjc+P4CSx9Nnwn4vpXFBLR9dWjau+0mIDDfR2z2Hx17T4oxA0gexvFNGFgSpzGMdndnRi7NsdV9r0ltIl4o4taJqCXF7c0IYWLD/7E/sAsuE2Bthk8eJHhBYU8EC2iXtQbfHHj0Wh6weAX5lrL1nzsb4/9TMUJMBbvKrXeHCApyUZl9/LGZzLscl55KbfieCy8CSdhslNtqVF/aPQc/xju3BLtrwRjCae0qOxA80n554kF2uSIk5wAv//yn82+jyUS+U7Mw261/M8+D/5IiDu5RMhOh04uGQRdPJ3X33zXSPHn1p3yhz5cSJU6ty9O2+5RXerxTSYKBbybW+V5p/QzvdCfDPekkHBj6a1PqH+iWQWToz3Ns4dizPN+hnpAScbyNByvbVzNzJdpzwBv4vv+h3YBmqEC6Q5Hchk53pPlo+H16qLAHbjk3v5I0RYOsRaSLZGqYTqn6xCrW9jrv0aw+QcsBRAuuVLZj3rrMce1rCBgfXIFznUnPq6hl/PGWwkTazaB92GLHQO/xSMJv9JJ+mxzqXoy7OiPD8HPcSh8hvvRIpQETykOLF+h56bJ9UPRFoKduy7wsvc6Xah8TN6Wp7Z+lNl7Fe/1TnhO2M/7foH/Ntgib0zghlTyjpCz/5FJQlqcE2SJQ3yKqTuXaQxdIEInmeI0LK1BHVPZifJmkSHTTYaNaziowhF2H/ejfISrrjB8nkCnGopg4yW5GDmH8QcPtvjyyPmh32oFun91d4a0Jvzo7+Jl62WHfa9Lj9YYIp9OQUv2I1xc7YkrP60FXQ2YulwawdxhXk/PWvH6eD8fRnBwAYR5UCmqg44GOuv4E1Ut4vvRk0kz9Z6eSzid5GnizDNFz0EmWshyw9fT2TPHmcCgELjI4mGCw430vStcN8Zaad92rTUfxKqXs7qSwu8h2jE3PX7ytSENU8IQi5fdXyZ9GqP5LSBdnC6m8uumUN+OvcRRjM9gTLd5FDXMFY1PiwnLNOOx07grqjqED27jHeiOTh4pHQANdYjXkBCr1Lr69WkOwung/4gyt4+oB7b7PWIq3MB8BS9vElkdfklW9fU81t4aun+6n+CBK8PjaDGnS30PJkJp4MecC3Hp/k9yBFgu/sryD0c9wcFMKte6stMQJwoM9wozrGWdNSsRxxCK5gBBDxjF4L9L2IyGKd50X8a+cmOT7/psCosEejVFw944OyaOPpmqDA+kyFRH9z6k4w4mQtUSTgfp96weYrcmm0GrTcfGdwnzjMwTevZCAqJM3cZRTI94XVHqSb6GMHnC2lqXb4cd0H2lKyhTgDa26lVLYXwy4QAclPCPYT7Y7TTRLZqeBYoK48/H4l3cqOm4fpUuiGorCOlZG0rRbYeK4L4f1DoxfPqCy0xsVTxCqMmUzEi9hGIN0h8UE2euaCmsLfxISmoJQAHBrOXSVny2lru2+dPiAaBL987V7DFo9y9NtG1wIAoKZA4zOjFnmgykveAy4eUAGGDN+HI6Pgv17y5ZFGahHI3WKvpmqt5sNVsNnqo7Q9nT+Jr3wt39c/gsWdRyjcjjda9RlfVabpe3KHrkn28xdERD2c5jSRn4StahiifxX+fZUyq4FKCSrfAsxqFSsgVUXzOYrce1ttHURjSkddvouS+OWAScVFPLXii5yynYs3wsDLwHXiWdrneNCgA+zv+JgE0QOmyuADAn1B4fHrYlMPzv1kJqQyPS22o2oNihaavD2JxJdQEtdzmFfUcpqz/MgX4XMBk5Ynz5RbG1njq9qy/lVCEF1OpFszgVweWDj1YZd4CU0IapV5HqC2fZZlMj38lglDW+N1Uugmzjpy8KVZNA6ziksPV8n2eB6xjs55BQWB6SMvLGhcgT/NEBoNJO9t+D/nAMma+PGNzuRCbc1MT1zsRq+ViCvjCCcwyV07PV7L5LgMRGe1/6yXuE6iuGhOUlCCiDvMClb1Cg7rhQpu+MgzIPemOW7Z38un2vSAorGrPuSdtOIb+N+0OajeZYS5aLLPr0UpTUQZbzZcPVxKAUaaPZ2S+JI+K8nlfwF1tQIeAVzvvXO1iXOk66uaXFJ8i/YOxwFvuXTj38F946mkhdArLJNyLKazmvx1phTjNwJOnyOikmFrgBzhbN8f+KYK515srk4mvGVD9viFb8Z3VBUVTgmXhdkS8JPzErdtVpRXCkeY9Dv7X5BU4fHxOMqNkJBfbWPf3sCXNEfRveoNj95hQ8Y612Y+7kYABp96vJFdLsWfuaYdfs9hQxHqAb8FD3JP0OoKfiMRg4+F3FyW6H8CJo/txDwmy4m4O3rc9BuYafuXJYMZFCeaIsGUMB8yg7qatWjTnoyM+YfBGIUwLo/xgpGpeeSpDyRxlRmaZohiQ6/MMTQ+bMCTliZWeAHi/Um3gOHGZb+B8ks2jBTTvzKXAHDzymBUDTrI8AF4GqL6eLFTJDZMPS4bzcNwMXwe3TqT4XLZjHWNXtv4i3EIln09I0BTmwC9Yzax1kxkLtFIkTYnpkP93gDU62L65pbrZWRSWh894ia66zAgen/camiPLhQcchFBfu+2oWkRxXyhJ/YwHHkiGqfLpmbtkOOqKtZk5HQRvFh8ThEdpgvXzPF6P3bVYpWS2V+3FEVEEFAkrHrtWlqiJAdldVgz1H9I4zs7NEHFaq7oHxfYOQymp+Eg8AfmuTo4K+vbNIm6DJMwGQfFVZhU3J6l/979zryti5zMQVecBsXxr54K9Zxm2j1SrNY373KdmSgquB/JEQaSmx3aKMnrPmtU/CL5fV/4XaMeaEwY1lSQw9aRU0r63VQegiK8x/0sCfmYwh0J+BDNMgoJXZx6LC0QACMTRHUoa3skrWbSBNHwIKeCg7J3Gu7cfTg+nxiKsvlZzKmF5aFEGQgqszGc0llCTMuaS8LPoPv/TD3MNMzXD2XtJCqhorEg1e/FzDSV+JgZdQawiI1yyx14N36Tdoo537oKhgcT3S/srjKCygyr4OhEFiioQTqfWnZY2WmvHLLgbGtH4t2Jo5Y67LWN5FgRp7wYXAZ5HjD4Nv7wxbpnAXgUxu44scHdiUmTBEDG05ig15LkMJKyFCZvmWTfYUtHDkpTNZMMTPhkomzKN6pZ6a7kc9mTN/0QIHkH2Anj9I1mfTuPNf0muuqGCWyBnes8UyqlrWzegB1AmlWG1ByVrnX98v9r0cX1DHUAlMQuxntE+eYgf1lLNOlgTpnypSyK/equyWD8M3Zlxr37cCs+ejnMdxpO1xQPq3ksUi97tuk/MCeKeBC+oayX44mNEdjm3vpgl4skUEfsmZ8yr1fP9WcR0iraBfe4SUIYxUj7HO86BnQo0mnL9nsJXMbVW8HNwVgAK/btHQqFRrh2g6Kk0ke8F6+mZ7qDNp0dJUDgJ/PUqjWeD4m3guD3kzg4sBp0nNT0Gafl/xL9KnZ8z5e2/Q6by/JVpo9HHqLYYTzYQwlSetSNVtDnMjTcpTonJ1TIIxR/9S2F5eiKkfpbq0YmUGW7gIrgFGu3fIllqweYO7w2gQawAtssqBEs3tOOmPZxhDie46ImoOmZNo8l9M/cUsoJc8sTwM4zl67nO8uLMDAqxLT55p7PI+ZYluT0WBJCn6nU6BHYsQqBdc41OtBlGXteIKFT+by41W4xO3xVSvSU1wz6Qts2BEBRg0fLwPyLm8ca9xNPKpKC5MhpmIOmXZuNMzjzPJ70Pdv2T1P+d55Bk0Z35daBXH2r3Og9zzNGmMNQUz9lDtS8jjMFYJ6az87JGH9HE/1edVYuI604posQ/MGOyILcC3Idzxtmgl7v/2wVKtziiLD+xVxgiUFNWmFfTOwodUWsFF5eTzpPo+dIiz8YMMlBtE0cUHBtoKN6iL4JYdVMXKljghojoHauToNiH45xuAbVqIcCD3y3jJ5v+Rj7TQQ/vJiwkakt709lRj5NBHYVcB7n7PFVdcxATupbQ9qzmxbCX4XFFD2SoD4B810VUStN8L24QnnYdZjJcdEtUrz7Kd4bdtBkaYXXAFoCFQQsl7+Gaj1+XWuppf5gQcugNhCmb2uEbcCRoM7Bd68i28rj6kgcuLyxczSqZOOf5qrnf9gsmJemvlh5cJeiGvER2S4IRFsqRos3wURuA1xFJaRPuQOMhz46fJQq8OcQoZ3EwnUDMX/OkPD5ba07a+fFm5dhuza6zDrvOrUecTUJEMXjaUkjPMVqqmzKjoYG9OYxtfRanInlinPrpTfQHyG+7NDVGcN22TB0b6edE95Z/tyA3a4rOCJ5jDvqZVYRvXJMtsjGm9cuKTj/PPJzommQtyGUfK0Igtc10+QKm/mNdh40QI+ibmRJvznTiTNUkKtS28dvm29C/M7nK03opLURXNqq+AwUPQ5Kwt3oxwBUzx+ZOURuU9aGw3RAIR8OmjRZeTZTE5hrdGvhj9WaAShDT/MY1wwv0HhvFADtUY0NBI64SyrlaT+VQ1bsyHa19i/p2ag9ULf50d6MHSn7RnBilceiVLtzzOJpq5KRZPYLM9jkyzXTFBM4Lq3pcFsoGv68mBg0YJKXjAyAJxCOjg3hxExCWQFNar4Q7YSi7PQ3JL/5U0hf6xoWPA8nfoXgy9xIVyfXLeTFPvnEOnIyjigBL1cCviTHUrIPiMgOeLoPGZmQnK7vqi7idOiwn0ekS5ytuOObwS9SbbsbYgpD+TmMf0rsX02wbdZj+GQqZ3JN7omOH70Hsg8QFhU4n3ie6CPiNnPowTZTdSu1vWQ5ceBDn5i2WNKSU2mLsC/6cX4xNzM/X3AbcvomC4KJmeoyYRD+yyhb+XzGuMubMa4gSQ5M5DiChPuipJyyT41d14S8pvJsSsLI1x1SC2+WD3Oq16VaLzdzG4hdYb0BATrXgdauzhXzUPA5H3yxzw1xEem7iJiDeAymRQiHL7UPzuvHj5QWIix5ptb0EHbYn3NDQmSQWLBmHrO1oRTXRXzvaOf0K383wla8r7rBGGjLopQj9ObyqInkPRUqfOgE6qwHrVajlkE8NJboXj+txJ/Rb9nk4Bu7K3FNquRJF8OOoNOVAoxwmDel723ejaom9AKIxBOwEpSQxJmNDxg4hRNSqH4OKO6yjGSd03L7SPYWeIM3DewXMFoIRiUXI3zhNiRdwZqz2UQLXQ1mwtsi7FOZtEwqentZVKrQr8L57++wY1+K6iR1xUAFb+QypPlcACLuViK21zxg9LX9g9gewxALvsu8OIdgOoB2J2HsXlo7coe7zwV0KQ23J3HBispNnelRWZ8UbYc+CeOWhxQ6sjXNACQn8Xd0QnyDPO0WDKn1RGBYHVYdEqhDro8FxQJL859eRdA5L6LympmfCLV+4baMu2fMP9jsOQkEBrf0NOsSA4vjFzIt3/I1m4jeF/tql+49nynmf1StxN8gNly5Z9ymwbtdoZZSdnNt+5xk388LZrFtCId566JRm0gtwk9bmZ/NeCFqqCyT9lB3YDv94E/SnQAbgkPGDZL7hl/9hmXjmnGSNKibyY2SRJSOcM/jK/qo1n2JTjcrcAF/+7OurbzbnKFS1+biyF84O80bhx+QrJGf0Eg8Op0J7nz2rViw7FYoEhPRw4SCrLGOa0/m15TeT78WBJ8bm0MmfliQqAN3iG3BfzSaXtMe8d7eps9pTh6/yJVDspKOZJcIJj4eQSPcc9x8BmBJBm8J/QFGreYGKW3H1HOGb1Do8uJeIIyGyHqVdE7lbkAcpTViV/GwJoqtdirpxcOl3NQxWanoNCAOMy6n2CDPzcQosJSff1XJXwoQbgY7/2zILC51Jnl8xvukQsm64wUpAykET1ShCOcweJEnZT74URy6YftBbj3CBWPeCeXcmmOGNfw9PWgI3pwrP0ZzzRn3y46/7jHA8WqA2eWEFNodtB6qF/+Z4C2O37hpKcc9CmNcP6dqLiCeNJRYpldYYBC1wLZVW7bdIvSAZpYvlXp/3Oc823CzH5ugfXbTqWUxdhevMb7W6O6SCgD68KSelw/qSI2cjaePMGUBQ2pOIMc1G4dP2y8oqfy3MfAqjsOtb6RL/kawGJVOryJBamau5S5aAHdtzK+VBY0YTLnY/A9idBeY+KSf3DNzLslOwSHjmR0hz1UcJmj6EaemSwQC+EO4F3kOV2HsrPRRLJyAGK9aOX8xY2w0g0navDULEYDlUm/C087FR0U69HamzPsL9IfKtVRNrvEQHiF7B2DROdo6gw0Hw7f/rq9Jok3UDZlSKRKtSQHTXfIiQFuFaaCbj2uz3OxE/8RNenYSijknoafOoFH54ytYqWjH3a+Z4jh7KZYm0I6tcNQglbccJjXD6HxQsUteeFESdwOs72wfNAx3NI7yajGsLW3faxteYJ+9FT/vu09RIOVa4g+RUh9omy9UVgqtasgrEGC42RFsZ2BHmiQxSkrz9odedY8GkHqLbnaj+0iliCYRkKdZE3yKD0Vz8TkrU3hleClUX2zreC/kqpa6mHzLj0tpPoWERAoYfMFKpOII4cvq3YysY30dTrClrL1g9jisfYk9e1NuFH9gGNGGBoEQqFGY+ScPjDkQuDT7xUV3lbGouC9xQP5WiiLtD9UNSq+v7nId9Tv/vtSCdpkcZr2mJ4gg0IueERdd8mBSqc63VBV6GXvzPWoHtMFjqC/6nFvabCgn/XtsWHbWYXfaAirts2FICYmW2GVp/SlZgbOCAK1zSeireSSASUrgD5Ky+1zbjo+j4UfWJn43CCp/vSq5IFHH9bqwYODQgEMdFFvP8ocjD/BeVoqOXzNsRBLUeEiOc4XjfOf3mGyAHtuEDyrSPOBqBKlzA4ULpWTlW9hWpgB1b94yrQsu6wKH7M2BmWqHRBOjlmHF+TLZTyNK4+XDeHQIzUxCgKZaaiTthI97VmW0LTuMcm3u2F2e8px/mxTw5rS8zux0pjUw+tzyxaSFDxc+xt086ovZkBLGrpkhcGjbC49lQPL/kRKxf8aKiRgTEtHZmWi7/CtuxujJ8mCTVPOc1k6ZxWizkSg5ulLhFjKiChyYqfESkIs3w/3JbYwo9KF6b2DdlZ+rt5cvAvjKn8PhT1FPCWp+VRatYH5gPqvpizdutzoJ7hQn9VGRkwKwY9B8/z2fFgrhPfMNFW8cnpYyKb5gGSqr0BsbUCWszMIurp4jHpyefMuKgUeesKhyqSzSxKgrVJD9suLOZq4P6sO6iNSt1a8NyY8mRcnBgn6lN2IxrIW1lqYgxZaZqECZ+TDwyFmnfUtl/5chIBJJq/8GRMzOyNJx7EmbqX0GF9P9GpxRdE7RTWy+RkreIMoHeNX62zlPAU1FKFFfL+9h7ByPkWJ3+BaC8nSsA4NT8Hl9RtgGs6TejIHafUAG4sqEBHaXZsCc/hoMhR5ogm337N+uXgriuwznk9TCatAVXcgFYlu0loKnSWNLE4n4HX7StQqmAy296IXcHmN9AkvZXUbrhXlaoul0iGxQj8VtTdtRxypwB1OuFCEEgAWE/TI6VPFFk4imFdUIlFxMKMN50hEzgWmonQ+WE+SMiJdyN9X3qqips0+H2Mmv/jPkBPUeBZWMU3KlVDm5re5Kqz1sl7vgcaqkmjjaTaLA5tpNjtK6D4J/N6FxKyvRfq9krqGArfzW17QpuC3H0WFlzEWgDlxgQHLzzDtI4g1pMJcYwVqg7MUX2nebNlQBn853hp7aJeTaloqqvwQVNYn2kbj4vnsg30KJkkH5J6MV/Wk2oZboJ6qBbAgICoiqGnUCjZrIKWfvWRXU3mocpsOV35Tgdu2ow6gAFgszhIfaEKEBsDhdiS66gIWXdWGbA6vgy8qrtXb16miCmJdl4RWLUIxytUGvvy12tHdIcDn20pCBlG2pFJNkRLv7FoATVxun5WF6Uo8GASenek5gd0rE3O+qL0ArXIpFfDdvENmKVFtK4gUM56IQ7qH/QqKNFk7GBLH+zvGhs/prBzcxJbmzs6F0gzYrOi+5BDwA/XmRD9FfZFs/VFOUs4KxXe8JsNJG6Mr+YThwwJuB++9BGfmppIhUvHBZZ59HUUpiaypkgivVGMyrvxHK3Bx8zcl3sKvqUMuQlW9uZxiIN1QYepyww//Fx71laZ0yHRMRuBggn8EUXNpVmHByH87mo1sDwQhaAkgLKGmTaMlSowk2aZZStzKK9DuhfEuAxwBe5DCPJdVzJY7DVu4ZYdC4jv1CBuhbPppnG21jAOHNeWyYGBuA9N5qAMRRghfB8E+qyO/7lS8CMlbkezalsreSM0I2uE4JwfeY3kYTUsZxpR9pEfI4taxE8cCvqdeHxFz81WDHOOGfGymrJE4XZNxfLtzqD3hJLA5tpBwNh5GIVPoot7Ml9Nwxfx2Z5fEbpKJKknn4rWWmAaLh8h9BAInz+LwtJRy7iLsOoRzNhtFpc3HnwSoQ/vjzScuoSxJazVdWLS3ctOR7LAwb6y1JbadnXvgLxiZGlZDPV8K8pEOBumyO8AMQKkxT5emtoSHLXVKZpPmaFefBRkKqzlM/k3gl5Gb2ciuUXXEPZxCoSWp8M3S5x6pNkTsZaICdayNwyqyTm6xH8xWEvzju2LihIr+Cdv1rpl1dUAeN9DsFwUCLaQKTWb4rvmpWvMp6Ue3pXUtRwxIk48CImWjFKMlJI4fvPfND/fb7lujIlGy3auK38+wtY1ymSLXIiZ0n0X5HLps6A0hSzY6f2vrCZWUAQ0RnstkyiRrl3rxWLgjhKMDVj6VCBVwd2TXVpsiBVCwXvANPzOFHCEg7UnDSRDcslxzHzyiNGpsl/PMn3gGdPqA6gMGyVIdXeExlWdlwlE9yJ140Q1JDkJaOdZZcxX+dwZT7P7SGTVoYcLX4x38IgftFRyyPfJYJ/8FJoE/Kxw4Y89j5QmnA9g3r6dyQ/z25Anzy8uHVngU17OOOFrx0Pwes5ubQEd3s38YvG5Wsva73yJuHAtXIGiDd1OYzG9jdiUzx6HhnILQExlv2E6j9ucYYOEQ5YW2WAeY9MdOQJCVpfuKPn5cHHkOxTXhq1XgpTudbAaWitprXTYyt6CJ7PGc+MFq1/+3mQ96rFyueDou5Kn0uNN+7xBF5sQEFkRqhZ0MxrHRVgl45mYdqEBTu+y7DZzuFiZ99KFGEUQrEf2seqfgSi2eXDud3vzZn7IUr3+Z2Je3iE/cfK+ar0P6IsDjTjkiT8OpmMJhnO4ER8vL88TlX49fiHRFn08RsS24eFE9OOW9Qzx5jUB5woO+J6c8nA6ojW/fdcwDTxckXMK3vFa8ILCCD3fP9LpSrDg4Dpr3q+6zYjG3/nnhmCVUZixoyDyNQPjiLRaIqOHLwjlZwjF6Oim94z6e31i9UGiQVB91ePKxASu1ZYaf1BKwcviTo+2Ybcvi6s6MAt9gHN8lrfnPJXqHBq+CG2ai9ugCuLMtDIbZWd4f+d2YTkSirowjL6XUn7xQYXvWwBtOoQ8EGYPcwR6PxIw0ByAlLeJYjA2S43wnlZgNLjGeJ6z8XPi/texAVkawvbz/vjthT4RyuXgQsHqpY7UuA+odo1WOdvCqPOJ6LnQIZdw0WWXTVRtHoDd4q0cB3k0RkmMGYxd74iRLaMxNyP3zphBjGPYc+/GrQc9HTEfu9SgkKfin+R1Y3WiqbASmmCDtOBwPERrYhYR+UlIW0d8J3JLnKXRyqxMb5Ad519bunaT6MMuopTXeLNgsgJsaho1AcfhBZRVLmiz2QHGECihcU9nHnGVp0/mgpoQgSx5pmDzXQBEvt8iM5qsFNVv+5VbrKHqX8lPfGsZCdbc5zvGsmOoJs8YhN0pl3RKoUzIOnw3kdOFfAbZTbrPM7p+KA7OE786T6Jrk9Ashr+Zppfo8rfJk/jr6soJxB2YFFyJgME9ei0Cxj+UpdnWufBI4fGwxkUSZmogEURD0qO7ktyMoWv9ulMxlLt+ksWFdShIhhNXfoi85PodKSVedTsSimsIIDjGaNHgFNYq9s1rhGNMmMiNeFxzIV818q9zCWN8AVsa/QgoA1r0GzhpllnrCHdmSfUfx8waU/fgp3nsyShFKXyL/bH+s+S5Pt6oVL6uQZedeCc1rG1U0uwx1e5YSO1TT6txyVmyR+2ssRU+9gxuDerCH97N/wH9s0lMXF/f1exfuIHxUz+0F1DKOSjlQxfFjUrt75l+6aWkQUKOC11bA+rxgMqsnPFY5cYmxg8rX5AUE/388UQQnjCXbKhEdS/H/c/ETdJXYZor1mQPereAXkNkOHn/odWB3NjrDgqnLk11g6b+7FkVQ0QxDhATpgLv90IpQShbtqdb9jI3mZ8l/xD7sQM2L1gWFrEbwD0yPjo6e1WIPLOBp3clz6FaGUAoQJx8Hmv1v+RcmIyLnWasFADG+9VlITPLVcXjFlDFnS2EUSCZ0WpPi6Hj/kkp46vCtBXFMQlhGI37UpQIrVbrIRf3wGHTJBK5NctCr+hnCWm8pdwsF332DL4+NbGdwyegQIoobPhBNDvb1Zb/2bK3C8hQyDG8+jfspcgztDHBKM5hC3rwk/iMCiPNRAOqL60zretdSZICBArxSAvZf9OfIzHSkXe/NOJGnIELpEsvlp55Cjm8dogCzjLqy0EkwdX/p3dItOYE1oqpF1/TAibhTk6LGRi/TQPrXuCgM2dQMbNr0wnVNYEKQj6JuF+ichLvytLXP/UVJ4dx2ZhYGN2trwTqAhDjwAygDO71WkOoFcgqGxduJep4EJYSmG3bQKpRNLtC4CWETUtctY0V0QPwi3n/NP9G/tvE9Fho5CdOC7YneiFaSY55AikamRyCY1TJGltvwiMZzqiMzRsTn4X1udQqZ3MVXtBrWApqq3VmS5pAaDQAOLHDUlf6E/OpY2TyY8x83pHABbXTR54b1JtenpdvI4tp15QhFUbqOPc6SfkyGxSaCl9kJXeaP0bDKfOIWWTU6bjyIB9YmlC6DGXwfdZ5/tbxg/sap0XqO5g7gHi8vC0xQEJ2GvIsMzlBVQd3wQGnhyR3RQXnC+ykcVKQCuy6CRqA4lrcEFpMPE4452HkqnRj/fnGfhXDt700sOZ3Wg1m0dOfFDo62Ky9Lz0Xp6kYXmy0EZIiYnYiHb57E0dP4a1XGkJ9/QdbROz70+KT4o/AJNEcBZwTJ37KFTqNWHwF00XF3ilmT6TmklnPy4LL/YBtSHYghJDPAc3BIPULzLisVUWnKVURjv4bGn/dtflTPQoZhesI41EVyVx8lyqztIAeg1BpoRlLgL0tK1wsnY4nmIqrqGL48NelhjnIPNGJktIqY3dNnDtAYvpWLVEWGFDsp64TKM9nKl1B8TKifG/i2Kc39t2UIEmCxj+XjL1IJsnOJJ+/9yLGcVCXV5ug1gILTsYLfikDh9wWHDbVoBxwrGW9Ty52PkdqqqjXpNQjd8WKy/0jNMGVe/U8oU343aIC2b0VGLyVIKFwDGAt4vYyuJCXh5FWl0yqOIbs5MZ9PruGqOSGU8R/muydZZgIRUObWrYarIxUABsbwDdoOsNozBpy7gqC0+IxWIWfqjpyKNx42cJxMCBGChZ34Hk3nLplw4Sl1v+GKnUAzBv3/tw140zMHHNKKcJwT+ehf4X742T1H/+qdd1CjnoE47bliUwPhEMOBip0pv3QPsoTRwzb0vncYcaqItPxDOCljYGtluAf9nyLCI6GIKpMtQgyID52Vh8tSLBMEI0xexmmPx93XzN9SuLn/J2Lyk0f4qyvMQZPuF8UhHPArLCjjc948hrjahmP7pbK7esddD7AmrEesOsEceemdftWMQfR0gV/U6bsBZC59edaNynOEKFxNhY5CAPbXNNgogOoCYqNWAMYwNCQ6xaGs1G2QwPGNJbQGdMQYVMAHnqrff/X8yooJs4YxSLZVXxQ6iEkyOqFLsJNT2sPkVvj6ibprgesNpLJiyiybmbGlnOTXNDopjiFe2cdvqGNdL6mDhf0N31rOIhGLS2HDGROelh5VvfwR4WNuDRtRZVnwQD6F0Ed9KahEnNLWoRVHszSyUTz4OLmOfsi1aBh5/SM8Pu7ryjApIce1jDU0UylUYeEnG7Jvs2olbz6qMoqDxhtUV5+eAu6aa6is6jMWI1j8Eaj1Zrau+/2Iffmnodiu3pi/oAqOpKZfBI/mdGxRfFCRqfGAt3q+Hm9mgLHNxnnGRPIQlVoVdxW+QEj7DbfitVei1b9xB4LyzXI9hgPP5LqepfAEv1hj0jIld9Msb6wheNeIMpogQunPqud9byLPfReM0PUrpam3h63Mh35xsAB5zGPtT3i9Q2qE+keuts2aAlMCSGw2xRq+6bVfjpOA7u3pqzMGkVGwZ6JtVHYWEnWZT0z6ZXJtxqtJd1qzkGHEFIda1gaCkIaMPy6vwDCEGWY6GbW/5fyYqCLZ1GYTSjKvwj06Mxta1h7KiOLIxKBW4k6s0dgg1iY1YxG6uAqYKpNzYahgUR2h7dl0NabgUUmf6fVaXuB2pAHgjU3waQYeOGCtNAPihUs1pkpqnbxuzX1TJLdFESOjSOnUD35iSVkSRQ5wZ7pUYIQ8CKUZtH9e8eWjeErywdck6Iq5j0u0vsU85QyJa59coSy+2tZCbdIskEcnAWe9tPiuD1qPDsaNRQl7OPt+WTTDImGOeAUmqW/Bgo/ViY1M+JHTFFEvRvuBKzup+OKU4k46h2r0kQq87JP/BpibTxMUQaMJeT6EPniOnls/orbdd8ed+u8n4HWWnEw8xzdnsKd0x2zqOGKNiFvCxYuDsvvb29Ju5S+Zi7z1cfbcwMeLWb/LLUGlrDQ/2365XuOME7UvIjnawA/RSQpJ2/xX4Y/kXdjYuNhgtvqQwINXIIID03OJ7UPZ662dNuvLgCX65ocvXn+0KTZRCJt8Rlj/WV75r9LFPXS9lP6mSC2kZAnBcPvTxYval+vpXsmi14P9IXzg3F2ti6hFSO1RKkpwtyQmTbEGMbeSiOeDGMOTak4z4TTRrGaC9bZjG7eywLml+dlKllvuZ3hAFCI/DzPYvWVAaleAgNIBP1AgPLpZNmLvA3lqDM8oNlcGvaX2SvJE+ud8rfAnACOelbnCklZ4HXbK05ptXvizP8QOgcCNMexZUwCd7Is6DUcXkXQ4b9t/5ZYlEl+VO0idMRP4kg8elt3ZPhCTCRPfVvBwLW6CSnW1YN34/EOFyOfSxq2bPfnhJO/uH0m1eT/zgcexGcmz0ETHqIDzOCOV0L4HE9AlLy2itTstqEjbF7KLMaLRVdkGuCA3BHY9uSqYETMlECYnT55QHLysx9LeH2tBKe325fwyFn14lqfIq1NypZ+3T1Ww6f1uGFBXtekmNv6e5+3+78R8idDhHPIsSiuwAHEUICsVUDIhDf5LBReoQOMFJ2zQMcskOJzXbceeFAcXW/A8qPNDZB59gU71YkDdjFkqgxDeOR/7fBDCnvi8dTYIw1afQEbF4r+9cVYn03IOwfOkm0Y2zcrnEEjbFE1XbugbtB4dMD6UPVkH2NLulDmGmxmhenyxiOkOajKoUXKS/vkX6UqPBp4ED04mDao2eIOirJQVwNbCWy8Cv+tiNNfgHjJm2DJ/tJD+Prkt2jY85sn88fmnYcPhfrRf9UpIjX1uT76cDejgEeIk1usVXvTQ7mINqICH8XTxaNGBKIMPoo59SLV1EznjL6l6l0HueluLLe4yEbsAET0fDgKswrR9CLnPWsXBemQT8NfE3tPhiI5WbjTYJyPK4Y2fY5SKWIhzPea6rP/wp4fAwEEWaDb8vuOv6Ef1ytDI9UCPCukAI6YFdi88VDYShhvJRBQtBoozjHqdmR6hAq+VvAddmdf2ju3RF9rW4VChmprUmfqwTjeSehv7Pf40ejlYnVxtYgV3D3GbjWPX1MRcK1BQRtvNOqtQN6SNx0yy0/jge3Sf0Ow2LQiSTpEVOKzUVBlBNZpNgDP+HAEkXMm52QghWx0LhyYpgjovwkE4EqmY3rDL3rM54wqW7nWN+ddTyRTNtEHiklI5xb5ZjhGGDZAYyhoLo4Z2lO41XfGpEnVeCA/FcQ5mwWQrydW0DT72WN/l96/ksFOl128AYanU3I5AcbE7o2QcVfeFHHdTrfu+vXIb6jbfDGM3WJgpxRN1QpfiPLcopLL32k/Uk+tETdvodwnnPsmWXcUhvZmgfuApO7pZ+IW6rraK+TMqSh5tuxsk4kTWZVdfODzG9TdDlVU0gDQppI9rbB8vp7wotwdHYHbydUDGISFlgk8mhogQ+/KsedwUMyvanYBaRFwxlDSzbHbtJ3V08JlDPhPKHLXTDbk4AknF+viqL9kk8xXPjdu+ISXenyZ1kmlaXhRmsmYdAlKAyUP3MRZyxj0lNOg0fsoKZp1IbMEJ40uCCopbRDHb4WDs6j4gm+cKpa5JLlNF2Tqo4wDMP1cNxn6754zPoOzdAnOsPWh7c1FScGGU7xGcZSXUM//gDqWlxD4B0kuzXrSAkErKBmbDkmQvqeKoYWKo2IR0DVNlzz0xYEpWwUFBd48QeFT0cTneVEahU4ZHkt4iUs9hHRpu1X9ABaObZXVJIZ5hIg8gmDzw/KehADN9m4HDJ791OKmJCnwootOQWo35aVPD1MiZjZNyXRNDlypZ+S/dG5SVxebKuvdqpPpuwzxrxnQ5Svm/wgqZOqHCreKODw6PSpHQ1GDO0WzXlw9P2PXLALKWAhgWscRYveFaw8X3u+ZJiU8CfIQh3D3Bd5wa8595mCkzSvbEh7XsSSqyrjzMKwXOxED9Rwaxxek2YuiGPweu4x2t5rQXiG3eBxkq6S1gLcUFxuxhJHPJS1fGQhAKpTcFiFYzj10l3gogDsKpW4pw3kPGSIbPo6QWxt5mHWzDV7ogkFUTK0zbMeACi+T9LGJPa2CfsGIFB8VeTTTdmbo4DrdvKfg6DeL9zK9XWC991yZzr9wf8A/kErUrlNEzN3UH6croeL+TnSw3VtbPl/sIJLLXVtk1kOw8SG+2AnQbkfc3YH1wZCgsm6Pt9jxEi87YvcSI30sZ25Ac7gbgcc1g/USNNumGLclhtPhxxTSDH4N1YrhYF1bkPqOMnsNas2NjoI0Gja6XLIRHNhN1ATQJj9FnaY769Zv4l8jjjNc+PNKPBmI59RM7/ukIRbaMdY++YrazJfsA2KlQoRA+kfkMMTIAiK52jd1RSSs4FUQPyQcoOBYg0o9eZOnOcInxmaUdu4XAW00AJwZ658o7AP/8slxcDa7DYdMp8chld77WYwSRAV/9uxACV/qjDkO9gnEMjb0TTeYNSAjFBU2tBwlupYf/as18kfrxWPyWEqGVN33A7AU+grTvLp292K7TTkNbJmW/2JMSu7OLMELnfFND/J/TXnuJU7SYYiT51Y8RSy0X/yWKw5JN3Wvti3YCBQwqqotz0isdf2RAeILrquvg5nHr0LhJkoP4++fAgjOD4In8DeMhCbpl+Mabpz3z+pYF27afEFoLJoHxFLHZND3Ni/sSmXy/OoH1l4CDz7svuc5rvici3f6xl28mGUW4lkGji1vMQa2eARTRLTpL9EqU6oe3PNBF6biBXOX3OJfluQRJD1CdfMX+u+LY/z6RZfLIFpnrXdeI+knDUITQuZ8zrCc7t0iKDcu9dpfzmPm0HPeqWngYgJ6O1RaIcYbM34bZewAhxiuE+1epHJMZm9C2wPoMPYLPBVVoZBxoO3J5k0kFsj0BP0ZeBmF+m037k0p7ST8wACtH5o9ylistV94XNVvSbepYxv2fTqyDSPEzCfiJwPQdk+q7znmT74hItq3OziwSc30HHtoc/P0HDRyMRAo3Qc2VioZTOOXtUvnK2eEQA9Itp6OnUW6npH2pU6S6VR8X0fPKyaW6o1Ltm1GJoYARFOb1GMhUhtpBhtoj7173sIo/dVJt5ZoJqX9PdfAEu5eYyUvTwJM1z8nAlqdu2q1KU9IQwEYsIeS68weqxjZTHLpk/doSigeYN09LexJj2SFP4MyY23QfwexZTTc80t31aUJp6eXatZEIjYe1UBEtqSfOyHlXqLvzEX6jemEes0vBBCkbaPSVLhqBlCFrAU1zx6ys1w0M1lVrsxNRr9ShxYQ/2r6egn/U57Phv15YjDcS9zBlpm3/1ohW07GwW/hixNu11w7sqTbuZXAdfVJe5xE2uo+gPU4l2OedY0Ktc6d7lFd7kZ4xnlF9Xx8MwGf/MiPyNixmaZ5S4X+UMj5Rfo40GVeUDs5nU79fXzCB55fkdFhPTqrsyFIlA22Y/qHDvfX8C8MDDnN0B2A2JzTDj1CI6hbRClUWjYF4UHy/8aMlzrrrApEVm8e50+PGTdErBji5udNqsJ53MxaYjgd81/nlaQ+Xr3iXwcrx2UtrqZzSI1ZBcFj500a+jSp6z8dIA5bgGm8+oxt4y0c/yKqUh+WaUjtJehsYibzhvDQ7k8vpmoYjY+6LiEujuTS7WWYRFUDuo82Kjl5kekQr1xbyRO5rlA92UmCdjwL4mR+1XE1jcg2E7B3eCbd5iusrF4uDjMnCpXJwpgrVvR4KjLM96maoS+AvFYAcieaydEBhAVOQQ7QzC59f1735T1kH2YMUM7o+pED2ZIL3f2UvKjx+Xzh5w2KDqCJDqZeu/oxV3n7XbsIxVaFefMGZ7H04UdmX5o3TKWiOzuoK80gOCW9hX2lgOFGvOFBoFhYN7iLOB9huLMPxlzxntXdeaFKp6MTUpnm9/cVo5cL9ZIwGiNW2/2aVRZkWsJ9ksa8mLHyTTMCLk7RVtRSEhoMcerr9xhUI8dndZXuQBtPovxFvLdO2XTFTIkZeL07OEr5hE4ZLzgIdKPbNMPBrrs15wZDXCbR4du3cJEglcxrf/9rWpOGh6XlNYK8CoSByCiQZ/0GjqfC4+y8Mt2T34RzFDBWXwSfDMpi9J6rIC36dVyzdJXgJZ0H4pYDJQkH4i3Ph6oN8ykskSVfNVy8nxEi5S6Gdnr4RxA+42/wk0TBtpERRv+0LVFANvYO9qJtyYa4uUkTwwqpwrL4o0AewX+jVIW0SrBWZJ9+m0dpjJjkYBHEhz4anJB9aS2p54U4yoJGfMj5RulkBxVlc0hsrfzdMyG7H8sIXS5Xi8wKRBQnadKEAfLnFfGcK4RVPJNOld7Gxo68AbNP41WlJXnjfhDV9XNqEcPudHtRiVktSu0j19HN6c2J2zIhH64zv9i5bfZDzjv4rPYdDAPM69kFXtzUJMonKIVj+gWw2MRpoByIBSVvW09Rk+RFdE2dCopHdTEXh4cddf9E4byueVvPuiBO5OOM2kyWx8i2Hsi5DTfGXDvgjy2PWETqfS1yHMdQWu1cOVpExj2X779vQcb2Uc2PApe4LItdSEUAh1qosGGKgdxitNWeeZMT0mkl9uu3L9NpFhd6vvNoFCTRbhDdkaxxX4e+LipodvE4aDjfWP7eEbQtArndZuaMRB+HykAzkMmYa9Yj3ka/O7OQUy65bktQFOfWATVGJrLmT/Nn1H34h/kMnkCo0qFMVgd04At7Th3eitWFEHmwYEPyW6Mx3Dfx6Uq9tL0SKR7QmtppGCQJSVVof+9+eoTDa7hQciHmdEPelwHTwKk/hdnTqpTEtrXOGB3fsQJl72QujLccSyRhgae2TVQpWIpUUpmkSjrowUwGRjB7NgliOOd/0cFHaxTMkyJ2ka4Bvu8Ma1n/FOFitj965aUPLq0hXMeHtWVEwyomoDJ4sf/LtXIBkpltzkTgduABy6Xb/tUQ9Xefl6Y294uGQ5zekwYCiVEv9Dx00YlJ4TfDDnWS4VgQ2tuPaiCEU5CE7F9sdsJ3LoLCzqFEXzdNgaAcKgHQDxS2sOSff+JU9ap7ySf7g++7+uKhifiStxtCFXaLr9TQy9TQWq+Am1PDK0IyLt8ppIBziWwVqEVmPybC8F4A4dgm0NeqXTDpSlL2iJH6OADUWhn2o5snZN0X9+0WGMOYR7gS6e8ZfhlCI63trRj4RJfK4Oq1J/POEyb7N7tJtwZ+S+4ALeoxBHezo1o8Kuk8Q0SwcoBeZvUWUyR4olNmWa9UYDWYkIx0hQAuvkp7k55ZGb30CK+VtC26xHJPMl0KbZXl6kk7SI7eQKbX+Xj6lGydyxt3rlX1VIIq1XDHV8DETXrdGJEqdxoY7AZRyg8O2CybXnh4ELrct33wurY1IZZmTIOJFH/dnFHRFKCc5XiuDX2S2i/40Md4LMKh/IThaQ9+1Supp8MuQLQe3FvuIuTofBa/PCoCstqTe+QzPy5Mw20itQciGkTEga3Rd5sXxsQU0GwkBJYIBW9bbbiiptbJG1LquaBy7EvIfln63DBRmr5FSdudt6/m26TiaDfe/1pNZaNmxrRn/Ono8U49m+FnggAhimrHlPQkLu11k7KB8yJoj9iIoz/YTMuqqPwHZgUpUXClWCIkNChkxV2qbKjeuJ4Pngju9E7qJgn3O4RGe461iXZj7ECBq5REZyuYkAaGXwI7QMQTc/44zPm0Ppg/hLGFn7pZSmGkaRwiAUABBdLkf+VGZJc7GvHWCy/sh0FO2jNGTj5gYeyh3XRbR9l4Kg/P8vwu8bkpY3mlBwGzk9+Db8aLf9NoFwjxoAaVfnG+e+mBPKms3g3LPE5rp0YH41iF/UfBMlcmwaWByh1lhTVD/YvnXTjkhZXLuSAhuPp4j5gi67/H+67/IBsbIbuAxwPTqRMF4YWJdHK0mBAxsG0fFgWP66UVENOSnDwJ5/G3vE4UQmtSTeJy8m3E9iLYMgOjurgOiJ46+7lkFF1df/Cw31xLNZ8goBG2MfiWcOYQAtKe+086QUxwXeQuXsRcWXhJIwQOeAnbJrAMu0U/5a/JLLUlLqw3/uPcsxD5nMYSvOm4X+zHcoMC1V75pQ/cv6C/qbo3dUwh0+FJCTZU3Y4OTXB91x9IB4t1Ncm7eItLepzylkkhuaJ2Zz7t6oG0AI3diSBff9kRkQ+NHHogjPH4hyIH3ANCJhkJhiEf0PpcTZNR3EJYU0JrAdbK8cBwfFrBU2yqmu7BSenMXYPo9tqJYlZD3ObeFeEfFi3e6kqvm4G6hHdjCaaGfuy8OlBKy7C+Oe4BSjmIehFJNk/6oUis6NHBxla2BGW0gF32oQfK0azLlHb9FEMhQG0OfN1olnIxGzGObigN2xzKXauV+bzobKhZrSXyyky5fCGKnJ9nyWM80TvuqL7wMXx7c1W3Eia/kMaxEhgkTCXENteBWTVeurqdNx53x4SxegpNYBJSGTRHN747q62LSY6SfRmX1YFtVpzybr2gjWzSwoVBvu7F2yuF0sGJ6mnj3/dqH1zd7sdUFA2tEnxAvXEGagjYNMzlQpnsg/JdXOp4LDxO4F5VbWD5JrbKYfbmOQ0/DKHTxliru3664lYPzGZsPHUUI7Jj/vKJwNMVk4HZObLE4I0x6TC5t3sNTTUKyCx0kHlwLrkWEV4N2iRCYWYdxdRXyaSuRDLpblJ7YwUDq5fOtftNU2+T+SKjPqSHJzGlaTzcTnfqWX8a5Tv3mYkJ45la59m1MWUiR5jpGJtXfh88wG2My6wqs5c1U88m/1lwt/HVLIzXk4b6ssKl2eJKR3wqTDINHqETLvmHNK7e5GUMIMLqfu6TqIb3dHevTR6HO95UjXQAla1i1rucVjizwu3WakzCuPHzikkbXTMqmVysQoLYjF48PMavPfBY07jbPAH+LjfVtqzAXMNrjNyMU49AI7NdnbQ0xmfaT4vVoSOFoix/+lHG1wTPJqhuQA5DYaNJAV1nm9COhDjBHQrv5F3jXc/+okds8ieUvm0YNz2t3oEl4tSXkwUNKacj6AFvKPgRoIn+V/wIToRCsHMw5an/ff/efZSc4LwNe3oFy15MtiJ+ri6+3dpREYNYep2ATRwXS6IW+PgYnhfYoVjVQv7H1t85kXXBjPQl91E0iLbOKwnFKNFlFL3tjEZNqEgI2ivtI1g38G8jksnynf+IOTSWHDYVYb/3qjMYVKP6Uao7RuUe32RbfK2QxiL59CNxO/M6h1Tedkayv+soDW3Q4IyX2u+SWLJpDEfh7nagfds1RRgqfaOpoAo1Ttvo9nM04boRr7435JGxZBCdHSPA9sOOMQ5BwOMuzpw3FKGMztgKRcA9j8JOwAhJLy0IqGctiaCBvczUOnXMD5exhY/s0kofI4bz0XhIgJlWaxWLbGZYpTDacMJavV1HxaBKxNJM0FVySweAFM3TlmZOzlu7hYq/95OJmYTJXJDcS0IekL5J+XmDtsIhL63g8Gt8U6OMwhaep32X55goRsCtkVKadLpiE73114WW5T/TM60I6ZKGryx+KlYlqn5H7mHoW53BemMP63cAiD5Ba1Ui/xiqemI02hOTIWcT7rTCfAO0wiJfz9nmRtlln6LBa8plC+NsnT+6DekNm4q83HplD/L18ySvHM2J8BbZFZYU3QghnK81eV7Ajdbfe6msAPf2YidJEgAQFD6L+DNKgeGAK3Z3DoOfoZFZ3yL3a3UgMl72ytFC/ZYNZIbfotMwvEJZn62+swrL/Pyr2ZVP8wjgvYGTz/Lz8YB0Z3zjxLrZIpJIvfJRXc70026YbLWfwzWwAJSr4a12U2Oe3tqksNAyyG1+WyI9qzEnGH9+8HGo+EOOPYjQC09ShoX2lso09HOEHi6ERA2IuDMPcWipKLVgrhNyMaw5vVOA0/KxVkDtfUWH8OO8c/OJAbQEYM/wvxBtVuuyNRh3ZYBHCDYCZlq3kKhkOLQMicSFrArGnRkMcHCHdJMFoW3US19LyunPuU3dcAakXNUFP9jl0ftCycOT+fdaf37iAPOGb9KWst0/1+TSd8iQ3QlWqjUvOhC3nRXjc32a7HJYoR0WrW0ozaGC2e8yk7QaoHGpUeyduHGuBoDC+rnXAHbv6xNCBN8nIUGKFgfwZFTI6OJf7xO7Q2cxaUcyeLEX3N0i93LQFz9DUY0SUpu0oBOvZcyCS9VEBr8dIbrMmRJgV5AbmEwCXzg7/+mZI8UY5507XxOzJlL5s2jG20Yw8K5wxsXRZkx+Si0+Qc9SPvUXWIZv8+pHE8T0D09/gNzD6mEShgScvZ72MNXdXkiG1Ze2M2nam9dZ60/ZT4t/tK5qKSVy1SeJAf6IYeteJR3A6VWF7RA+vDHBO6sE3CIKU2/mh83k5WaB62gMM1q42EKWu1mOQQ9gWGmLe8Zg/gElFi0lYNB8pAFU2+COJyOdYBAcVcXWg19d0YLlUB17dvOPw+QUthWWGDH3WEGEj/7EWdSFbisxE6/jtGSlDefsfLgR5xHTLqBcqz3r6JpevA06UnC1oCftzpkrxSTPf0e8/OvScP+AZlp++f43zlPqKzkgfHmtNYOXiNnc5WSTzPv4JPKHdaIDl0eRUGvVIZjXFtQmjZvL4joGZ1iXxcZkXdScTlbbSV1Wvmc+ger2gct0QY5qs81B3dRQM5fdGxGbM4mZIaporAszIPpnz4yB6vZ70KqYC3vW0TB7nm77mih1wEOiYJI/OucnplbsD/M7/IG9cLJ43cwny9f0uNBnhT83Qr3ZQWogJmQAegOS/6uA8jOLa3obXvCaSv3n1bayU6vEXOYOthFHHsEwGgcGbSmXlWfRN7XxZ57sTWM0CHfbyDhPgZi0+0h8QPvTboFfkLKRd8whKCX+uQfDUfRAX4JjpekGfbQW7KhNni+0Ca38uZ+TXjJKCWYpZ9urkGZD9IvwgtUeGbkZptGu5ztgoZmr6gFWT+EQt5CnyeJ1nCsxzl5Q2Jj8EcElxfik582mQeUQfDmGON63Q06u99NBPnktkmIcrdERKq6CLM1Lhg5NGES8xiF9TyHNoMrowDEt2669dc0mfnRdeHRkvwNU4ThvB1FKlLygBRV28IS8ooDUnEmnRiFf2MXTrTyNyFhR3hkHtMQSn3ZTHPeCZcrR957jxavDcqQVV/g/o3vukuqwkRHGULNeOtJHq35zZxQa/UL80WdVBEz1rh35PhXDMKVbPf3cUjqC1COivuk8pM4/kRn3aNA5L/2DhNCB1VSRFmwaVTKv5MGfG9G2P0p7pmbQ2bAmhISn223eoe3/xAevxe77wMJ/Y9t5HduSLut1o3TPfucPzr3Y0Nxe41pcE9SMmO4bbW0TAMPMrnFSsG5mDZbBeaPWGQxKpq5vWuhXvrVJCwISauUOcMvbKK6i49LwNt79U1foBTvaYDdH+OkuAqoMPuLIS7ZJ3moELaDh7ll5Gp5uFyatkCKj6C1vYCwstr3SKdI6Y8Cqaqjq7OHBTFtKPu26HtD/p1SgM2RSVVb0l/8s6okSJecZcceGcC4QFPpSsCgIN3qS/9AqHMHTm9WxqFGq8XVEtwF3GzzMYn6N1cV1UthepSt+As6bPTAIekWedvGHZa78wi+9HFHAYA6BSZBautuKW4CEFh9vJZnnS+0/XsSy1lUJhAKIFLg63zi0kXeoA+vXakA9J6wZy+vc4/xhMeYirXbUxCwBYgDed+EUySJ4TkeHJsDgZUEYHolUgPuZTi4aXCg7uvAWnq8WC3aU/tnKyMKxOGCxpGgusWdakgL4h5XXq9WYK6Xk4BPQvUssOlNyVntFTJquYKol2fcu8HqGrhAAK/wosJ6ilz0eIIa2JzNOlfGFw6PgT68+gx2XzeQzjjNfjTnEJOtmo/PxlSdcJlttJHha63RgIyb2J+kM7SYuzZ1wNdOX6jndo9s9CJBmaKaaOTCat95b7GZC3y2sy1+XMG1QiK/qNkurdlqxKBkoEm+FxZknUXaofMzmAvdcqz6Md4DR4noWCZexn7pqnKOMPyDANUfEXK6qLm65N7f9AUCoUtrwip0fEU3G0FU7WL24wkUZSwkP7aPCWz9l94ZXMvKNiQc/KqfSNVpKQyfPCYHILqxI1hJfEayflKiv/siqZPNjGz0XL4YzbvwfMeYg1uzPTAlGSjp9bEC1jOWsL9kB2+RYQ3m1mDZZdBiNDqiQJMoHJcbevpc4MQl1/TL6UGGIWQKgEaPWHUcEEXnXxjHljyCS9/Yvd9f5O4fWGHHSS+/1NP/DGXMqmrQTcYJvi69d3Kedy8T2JJVlzU7VZIvFYAiQoX227PGtqn37vqTZ3q/zkr3ejOsLSIi7Ssf6LXSLJPd6aJM1QocOZlzmYlAXSBxPFj6yYqpJnSTeh6ALusrA1W0GkPqQhR6SLilXOBNFEuov4/JAaBcVKgptNFv1F1w5gmbO3XNsK9yu1PI2/sXQijYJJCCOV2W8nJJtkeYgi9A4Juqe96daD41cIwBQuMPAS0t3YylUJO/PZXkDIyRvlxdis4AedGofQ6HZsGMomT9WiJeFBeIBevsixtOXYCdH7rwTFxohsWhUFB1UKKRaDAGG6XyCgqOuK9YeaBSgj+p4Exhz26iHnJtuBGT6Ore/1dpg8ABASoUhZ7ufYZdON2Va1D6kWMjjMpDzy8ChNwzVCk+Tp/8uEiClV9J1e4LOVqq+fFp/3JzcRvtqrBvxwp8WfLOawUAA42W3lv1TWuj/YZmpYAG4bzphptBN1yLERIaSyM7E/fFgOTzCa5tMi5zeLNzpYOAC4tdPmmA2WfK+Xwy6jjW65ogS95hWQsXhI4QJwNO/tAjP1nZeVYDYFVw15mAwkRtKq0Tm8QZTRkzb8M/BuC9Kiq6y5SZatH/0k2t5ifXx8pI0ImF6PndAwpVEt9D2vw01ET4OSDB+4j4NGZUQr1neHnlwCxChaGeR67YPyqWDGrQ87wjF16dokN2y/aJu5Uh+ZPguJVzuVvmGKOPDBi2DpqBu3LCVsMw85fXL3gV7P1qnpKkm73FZjmzfiqOz4ZQTsDNX4c6SN/MWbKlAsp99M98Pk8OegVXppDP9tmJFQIT9jQWpoicgqQExfOuKSfXI1curaq3QVNhcQ85qegUIDyXHMgXuIhn+dPtrbhovnB2+xMOAKunahb4PXestMHT8Qp1oVQjmSOVe7uRpM5QuNTBla5ExQQcWI8wP6FPPb5B/J+2nYC4wtwrvATHU4ObnRRDCAblqBuKA+J12tk+rnPPRDKMKpVnHXylnRFKZhMgEKRVQ4KuRkIVwW3NCD9QElSN/mEQRe78Jgmud6lsthYa5wAiXEpbUoGop7BbuRZ1YqybWXRKTi3RbdRh5yyukjcZs7Xu00zFMZm2SF4ZFUDL9czTLyOYuCQk6nyGOgeVLhC1lOKOB1leVDUaxrG7pGsWEvvUdIwFzGfhWvyPCgR4q0KZJlsLKhPVWl4/RdRcrpjN3LaiHfoD+gY5uKk2WjHTNeZdQvs+2DOFnvJ1+8Rd4ysJNVW7AszzvblEBxkrTkVSvnyGQ4l8typbbSsFnIbFvyFROApaYdaOKXGF0kWFwToNlrKaM43QNHg3HWconY62sUuNbolRGwJba0PfmivEJL5nOerbOHOVEYiCvWQEIhAt1BrV8uvN5q57zup++1PE8R3Qez6/gaEauZ7qlkIOoayhQgT2u6fmlLlTvOOhuzTbDqojZBI3XyPPyCrkVxp7NBlepMTuX4SGueaTgsMqt5Nm1xBdiI4ZBUFLD25x532U1raaqz8OcZX6bAUdvUIntAMimWm49QfQJw48YTeRbLoC+E5v7TyfTbqSqsfWMhtbRqkVp8n7GoZA0wRI8ULLP0JIY8E8y6LlFdDxNcT6EnMAa5jgbHuu94pyX0U6MBC9RKOIiIFtESr5Gkjx+Eab7Ehh/5BjIub5LGzD9YX+83ag1jigFfvnbVdXba6/0WfR1fWkpOUdjwi5ej3Qn3o0MfB/+uYBVyodga4EHV2Sjvy9kZIc71fnoo/6LuCWOcMJNAnkBjyEcjHwhIpToWACZDfQpRLbJebexrRUzF677R4XD2hoCR+9gYKT47dHDn8xiF8Rvy2V1AOsWBZAFaowpfDabLLsdXKNqu54PQ4qK0WsdZ76lY0PdESXJN32OIVcaASpTcKBEWmbHb8Oy09qplU07I1AuByRl/ILSpCraLl9jt1c95hwdv4kg2VL/5dAImwcq/RtTOod0S5e2WfyW0yN4t6VoRqhs0hjDjKLAE4oiGVHLBBqPQYnwkRRmbAR9v5BfRr2a7i4paJg6WICbN3kDzPP1h2NdwRG/7aOfom1RM+He71vZ9lbtJihJq3JjTWIdNeaE4eXynaAoE4FtAY2UrGIQ88tFpxagfNLRZTjbjOtvQRZ+9MQOBq+sjxn6sRuKbtZqiQV+AssurSI6vEzCLUDVeSSN9RkcwBvuE/u6G45TSBVNPxbRrV3ngpEjQPT8kGHo7xPVjoDFK79QA5FYbKLFPTXzq9LbAc1/WGSMmj6Vzbq8WqwRWuNHVBU/RgUdw6mBHIz3urmxPzUizfYnx0IddHBBVUiYRbM7+6Fqf5vpHc9wRLdIvXNAwlOOevXO2tTZIw80Yc8EFkETVqJ+EBpWf3fSBpW8Qe11SWY+xVkzszNUigc0F+XdZ9ryPmvHDgUHhPFzvK+RC/MP1TWqWbZSCGFUScXmZJh3o9hE3RZP1drgIKrSIDJ79nmc2s05XuxgYl6zyac8z9mJ/mhaJ3DJF2zp6UHkXiwo5DiS3qSaEnVQk8/h0oMI+kFKM1WfFEazgCme7qM6rRKWlhdGtKDmpZdawNIvRdKXpU3HQ5J3k4+tWsdibMaiQsZ2HuBxjTpnRLcd3E04cAsfpvjxQGxU/hwJCWCZ2lc4GiDIfr7I2ObNu3UsQ/4ggqZmR+QPcxB8ZNdBOqrYWVUMRzJl0TCR/sGyWnsw5eaFxofaKuynMFEbUm9L/yeU7nhm11EsrkM9aXpEDbU50SFdWXfN3bbvu5PQHj538vvyhfqvXiDoxrLIeqXDlE0KQ/D8TsyVLd1Gi41GCI0ImYKmmDwRHkDKydEMvrCxBOOIXOFJAU6B6sb/mmg3ztnfbMapDPffWYjVUpOBxBFCdJShADcG3L+G3+Cdbf+kEIIAlLqn3Vh8o3KZ1XBs/5sSy6I6jRJ7JfRdqrvVpmnCQN+q7ChtRSF/9Yd8Sy8cNGeeSu9Q91IXNSvfQvBzy6b1s+BpUqeAV9RSjFdfuvp2Im0SxJx25xFsG9KtZARt+iXlXF0Up7QslRkJVPXlP58I6yBNMxPGxwVT10nPk/dkIoEshtN1AplPRDFpLx062KEHJ7+qcSDC3dZ3stQ7PaMmcy2z5u1CN/O8Q0gYSMdSeGdUhfRBreozup7Eyb+1JK31LHfnLOXBdTxQcHcC7SHdU6aro2/dXf6JLYJ/keekMt4vZmM8kCQxcm76OmH84K+aVwDI30aI1ps0uRyF1y2MrrAGgDSrzC03ddkr6C5RwORBvRr28No6ESu9vF7uzYEmwnxX2D8DJl4pcGyao5J81ZT2bxi3xXkyjH7PI23LufOPTXWnc1Th3swBpFJ9pUlwnBFmzM4qLupsRJ/P34EleD+sRHEtxKIcqwYMXzjXOl79H/OdFqrXwgcEVGQeymT+nCX6jw4Mfc8rhlRFE3NsFYZXRsuw4MTp3qAES0IM5VWR8T7gtGDKEy6UTl7wWODAw2KDyh1KdMH3TRU2dtNBQzTLDa12VUgt8uOiwT/8ljUxFAUXd+lCvUcicrV1O12xRXBDaUpGL1oezmX/WRBfOeLL2HMXsqbLx4nFu81O1xW4ZLVHReSVDCeT4yeUym6dOM306HJq0YkAqFY1LiTLKXY3iWNI1IOMEvU7yKM/V7DhY6w9s3Y+pSXy2Fp0HwCnDb+8tHjrvNJQTjRHTgIIg2bZk8C2SGRk1qjgDmPHfZqB3+jJfQcZO9ojU+z9lJ3YhTQAvQdxL3CatyMJ8RT9KYENWF4Hwi2+fb05e9joeZ0k2IUDaGGjgSJTOTZOd7+dNbIYIJ0bLR8PZICvAxTpkIawHMRqUUZA/n3NyRmRAkilmr0mUwqKRTfBFLAIY3GcS22jUhFcSZivt/i2kXIQZwij9/XTM1CthUTeqiAmUFggp8hz6+aX4AEfiUnwoMk6aX+olZsnTlU2GrYBaoTqxKwfl0w/dDGkcBSjsNuPiwyc8ww9NOfR0R8GLveXXKBGofxM8L8jNtwbTToxzN5rpCn+wi31QDMbf/7p2RngFX6Jqr9tgQzAdV/2bW7EoUdzxjO0w0KXkUnoT3vng61zUIxPoErnydmrlAFU5xvwKbXCmY5YTnqcpnS2N40hQaBoMXzTBFRCmNMY2GtwfEjsITEmTKqyOtt9RNE+tIJiyiUUB40Qjt1DyuzECOm3yfS9U3LAGlKqjk96MICjlWRXMAeQCyhxBYN237Cn9PRUP7jBFByEKorXrAcjOWunQq3tZVLNDbwRbG8yTdZJKcWmiSK33mHDTzozSShbo+MQfVBVDwBEReLaMTT+ZNoHGlj5uIUow+WVUdK6NZkV+B59mbq2TlyjHFvUam0PXsUh6v6wlifLyV2l9tfKK6epjfMw8QPYZca98q11n9atR/EEWRYhnZngYYuqYFI5sj4DVUy9e53oAGUujqysCfKjI8WtvcvE/dHJuYRPxf0O/eyDgoqVhdDCdCSMhJzDybd5LR5nB+dFm4YYe6nqwSt4PEMJhrbTzkEGj1vDRs85m21xkX+qQMw5Cwh4+XvOa8Q9Uds1eUwUYOdy7jBo+Etn4qK1To2Bdlhfvz+V+05r03jV9ZWZkBWrD5iK3s9SPaigplLEaGbooVhtUohYLwH8tIciS1urkh4nAMb5+mNbvjk+0T/sLOH656Mth6NYGhu9P0R0QEwK+gMVQLsq3OXSPNuk4nYh3b4HPdXOMibcMFirEhTjDGmCLAlVTPDq/h0U2KCofph1yqMZCHlAmhzkmwul7UbQGwwb0hXQvjr4s3e5dqRMK5++Gryur4gFZcevh2knDUV0dTSNp+GtKwVM4UMQjgTcG5LqNuAHZYueN3Cfedvw0I6ADXMNR/3bjalw2atQBoJLvuiNeqPRLYuwYRwc3cUXzVg1dwea860GMgcgIDFFQ4527s/1Rgsd9X4j8lGdMhDi6qtFRBiU9NzXHyodxJAE4a28HohqpgqvUdy5tnb4HDWqx1Px8p7zPk9Y+yzUPregTUQZJp7Qb9FeoHAU8exuQcfL3hqDjeqqs2yVpsxrXK/bZMn47fCKLIlJf+vKZRXw6KLsuvcH3SDvcFl9CvkVjsvdSbNxDc7XP88lvfJOZDVLBPGf0WWh49iD1SyqGDoR2XOL4KkgUJXbG3mIXXapOmgdSixavo6kHpOl0wsr2qiAd2pJXmkE8Q7p9KE4EjDrjJZMcePm3RicpsVFBEOGNCh/i8jZiGcR1/TzKuuI7K0+Phru3CUjyGR/5WM0zGPItDb4oUYYEXVTm+pRc4EKgrVq6Qk0wUH2a7JdhAPk3zl4Layx2QzwxnmwPYNRL7Ka+29Ar+1dBCthJBnxtl4yGw3SiDclm8vqS4tfK2f5Rk1w6bevEpDhBBiR18zlImyQ68UpNMN2mMRVvLnHvOI0GiyJ/u0+NjeMOlOXrWES52Xm/ONrZRymucEeFtmA2bY8j/a4f1p9vfH0WX+A/Wrx1SrLijVMrGZHten6FjIS5PdWZlOUiNhQlHeU2Vz5QTeWreu0uiiNRY44hQzM1uz1X2v72jwUHqhTL3En2tkUfuJOfmjNErlhlb2uWo6ineCz0N9va75J8GeqVpdFoMhNw+toBk5TDmlFb9/88IiMcuYAIm03r08o4UbxRv2ToFsa6ktp2MhtZpmnX74+oKPzxZK48kTRozopW046DsKlYCZfDR+Kq+Skh4kVbWMOTku/VSZ92JrF7ALfyFxt7lgw2a8sCjsJuhuucWtQbQdIU/hkH6WOVjWuSdaHt8Z/JnDyP5HMv4X9XikKjfN2N5j94l58CWv85wG7I5Bk+kubXEgjP7lpsg7HeXYEb0vmUeJ14n8MpU/vWr2QGCIbLdLsr2EmYN2unw7o3qP0g0+gcM9twUUx3bcRw2V2KJ5UQ8jsgyd9sd7hP0/dh87oZfycv941ZbKuOHsVR1+RGSM8af1xJIxRMKcIhjWzJus1l8YD58tG3Al2OMJVyPFsFBTqqBlsslsmhwPJZ+IIX6o/6rTAFLiXlXXGCQG3P/gYj5BhsF/LuHQeAR1sClDI2zbpARnNVNSMMPoGO/FGpFCHW+l+IpUBLi8caCIq7PP3QlbyMuCABAB3mYDA/jAhwA4XyjSWv7RsPKXhLFeanQBd7UDfNBgZ22YOVu4qbuAVNPcOS8EETA7IOgo/bag+kOmdrVqZeXjEBuvqo+st85Ex0fzjRJBGcSFAKUQc4bSOdHBaRk4K2AJWKs0DUjh5bFtIeFOsdw0wJ3Rncuz8Cobh0KvBKikJAaTD3ji9v924BSVMqbo+MiFRyfC8uvQHw224MeIhhbiPt2RtG5WXJk/Dumr24WI0vIuS5GQIUJ/ew/gAnwQwqs+rhmnu+q3z04/Thn/K4eadcUyfrAYPhMr5RggpR+/xhG2dncjGZKUkVMi7BSEvW+7vdGFr2wZSZGAcGacXISwsM9cOlcTZGIwDNhImpshriqZGedEOXlQ6MQbvHPRlX4JRMN+5x+q+FirhXQ5IxdmaCZ2LBU/9kedRFTy5pR3jmEp1g0C8Y6RcuaYJXNAl4OSj4uZF0Rctw9XYXv7Wn6fiIlvbCMQCzXBkYIHqPqkQPWUU/gX29j9Y7qldkkfRtR5fK7zrKH4Udp8eSY7kZ1mo8BUNkZV+AnW8zxDDTTn1EOLK5XA9ENYmcT6tLcxPPADutuTNFzpsRId22lRVwWvqW6HTJzyP6GhvPmcEq6zrMprzWEBNLxEXSEIf7eOJtwczoPCX/ieEDgo1ND2Y5/7bP0esIV9QX1ovF9I1fIflN19062UnNlYL3zQywaDwBcOuGXOc2Dc3jxGEPkA9xXpY5AZd5mozdEvf358BP0+n8yczm2SnLPmjtxt5JjtJQuC552wVmnOnCTNL/CUdZKbDQ7EeeG03cl+pOuEjgu7wvoipP+Ufytf3ZQHwVWQPgTwwlN4TK6dGeHafoaL2u71ag0KNFWJLLejE16C2wsJPWa1PGhARd4uIyRLpbs7DGRgExC4hgj0osjjyg13INA6T2Y361C3hNJaL5FYYC6ARj6pM6wnG7qTrjAWO7kiXt7TDCziQK1fbkfBc1ajNUJe/FQS8qPrx/1ofCLoG0AQuyp98n7vodAkk1ZOC2QRfiRu/wBRFyXRcZBKtBAji0/Ub82Zv6On/Z94IvoYmogb/8iiQU6GrMRxa760fe+9rVAQUAjDCHxsWc64EYyjd2m6nsJ9SmaZHdaPZD2bwUnFWOQgjHYeoC1TXYlTu/tN6ZakvtHxCiJ70c2d+L/gM1zFcrUT7P3ZyrVuvnhCoM+Nt+qHOfjwwYCsYh2KWuUEJoAe8O49V7B6+JTEPATF33wtF2NY1a+cp+PDbxqTrCxi+5D45m3c5R2J8J3SlHxEsgkroIwTPVxMq/yghFk0b0CtnLzaV3Tjy56igo1dhEZQQ4CgfwIabSPNUxUzRdi4hafh9CFrTCrSRI4TgiZctnQdW6Dp0OJvMiNtNSAGjDeb8BxmwPrcSIpa89k6djeJrSiYCUvdRvUslUtWQiU4Vxs5llnqc/Kao77QYdZI29Lc8GTv52tTy7uUBXrw4By7t33aSyuWL7TiBEsJHtjINpGttftAtJK4acWCDJjrk7VPzC8cRc81PrM9mSv9TlSmMabzLOvkKhBY18gMR0EAMpzZ/r6kr/vIzdP0cpjKYnAgz48um1YRQHlnnr9w8h/n9mSuBZ4YfzsjwImBH7hJXZEkfkQhgqpD6kuOQqGumgszRqh/4YjiFBI4eYTedP69P0S5bqYZ5mXrXCDBI82tmD2DN4mAnOX5OzqjbGdGlXc+SiuoH/SErTNg4pDBjWFJc+lHbya340BTJC66hJtWTucqTWL+2CCntH0n0YvA6yOGycn7nJlMpQixcabohvmEuTs4aW2pr6+k0bhZIG9hReZPVErXcrdG2WhyytoOBYoQKeqh9kICe5deyT56HDd3c/4uPSVBy2EViBVXbVejLVim/peg2iYVTokduKW5Sj16Z8OXj09+bT5z3zo5XUyI5tFssY5k/Vy3S3bnWqhTPtOBqHb+9J58S3XfmxdTVCbz1q9N16+FpXAskHSpSIjwCunZ1J8BnfNreIVi1OTQD/7bdoSpDNiOPf1hlRXt4rYw+HyINdaKsyIg3Q67jXqAXAs11sRensKp4CHd1AnXIRAsvnhS2//e6F3m9OQ6aQ+r48lyIf/f7hGf3w5PW76ZgNWbI+GlRhMTW8ZJcbXn5yEgxCW668rDT6TkZSKehb/V+OnaPzaGUaORz316txwqJraIW2wv1VN296LWtNJZRrvdssNu+sKllQaHjSxYDYAMIf8M3E7XAl4MOVNYhl5zn0LZ0h08MqSBjkuoP+n/aTRfrlfQwcVKQpmRQixaqWBfg4UBbe2wh9Xx9OcLwsAKsEpAOLWEpS+rXb87dmj5BRz8OuoLpbJgU0xc+nYZKEvP25nqv/P87hJTSEJCEDmOse9bapcmXQ0CDe5ggpaEbo8uHoWTa7DwhjsKkPiK+j5LymftrnbUsieESUA3Wqz8k6sHBGZTenZI25yL4r127gouVPjlwRGv0RHn9DtdpTeu/vaS3sbA2AM0G3HRYB7Jv5Ro1YKWw6/kbnbCH489qMoASCc3l22tCAmwVUsimYoxhvkGVCoVwMUYX3QaYTG2/jQ1DWWMcWzEVe5g1otYxZLHI2YYwNw/zCzLkhhi3KvGY8ycn+B0b1f6g7DCGAswA5Vctgs8o74kzZ0rp2FM4aTePAesgdzAifjehAvqd78HXlxT98/fKG1OZddxkZuL6cM7gQny8FqXa8FDkoc/DYltSiLfb1tGRm0BYbaCtAl2UnTiC9YPCiqy3xW0H6cIhQ59qL4M7lW9xkNZCwQ6a7WzTBZoihAMAMyT/QKDDsKfb3/7TOTO1HwpUZHixF+N9vHQGIpwsI2XEKrGTKsZDgNCkaUX9e2UjVIKIPU7GM15gwtVGrl5lI+b+MfpG38/DI6yfldS36k4NZzDRJcQen3S17xIeb0l0C8sIVOhymL6eayQQQT/1CcWqTNqnCucfPZ/3Bn1dZQ3H6IZhHhl+YqAiRIOTj/cHv0pIHe2eKGGLYAoxdAol8EJHbtdtcOSIi7dVwg73JlPmlIsgX5UcWwonQ1VpEE7fJpL8+QDbmdkI+/oZ09jBHSTnsiYzFB7NksWRhUkPS9jI25eiSPb093eNNe9OFQHKuCmZpu3MThWlccyDSuFZ1/7JDgyVd0h+d1DnvhPHKXAN56z08DjV6Qw7sNa7XhfvHI3/QmbuBWK8u7BBhvmzkd6nqZXFNbMVTky7LALDdiu4SB2onyIp1/iaOkPqjqEp5mwcHhsfBTRbMt33+epAgSYNzb8jwxpxzxiYE+tlMRj6fGmHddXRQS73wx/n5R+eAjrKaylrQ/K1OPcp+Ir9J3/G+L7Cvu9sSMKheY/fN2SASCqVwwcSp+usM6ja/WBhygFqHVhqPqDZbKNYNhisxr/COJODvgiYp0i4ZPCjIfQXjNlVUGeznAOEug68OQaDdnxJI9hRRGbVzM32TUlFdMCy0/zdr4sT9W2BfiQhVtpAetUmaMBa6cUZWRhjLJN5630909dHK7rTyIBAGKGbLQsD1f2/9VaciDVxHy9yc1/LpQEaRHSEnsc7b3Qdey/vACFTxBPsA75Q/gs3yztkDOy3XOVQL5WlIEVbj1kgloCqLR8ik9wD1xsqBGazddskhNW6EVgLt4uYK87qV0IiQThzYV9Z5f43EMpXrzzjHJFXRavfhorJoHU3YPEGsu3rTOkKRlgXJhqJ7O5eRWTwcWVEiozYggYyqK9KYc+gS7ev68NmHlcVJ+BEfVaexE0H229+RQMTMmmvc4nXUQVz6sKeNhHZBqe1yMglSlPIkiXpleQGHDu3f70tqiU2jaIVQ1JufR+Ak5m8+3xkMzFqARwCgX3ibDhNbhtfa75/93M0pDkAUXExBBWC+Syu1Uc1ihhdmq+h2YUWJ8/QTQywRF5wX7Vilb5EQ/roIPTxemr0YKoJDmhAaKiJmymkWLHjnnrQvsqCZqG4mDLUqcxgklCjNGdXUQovSLE0jpO23B2Y7I00awfDupmzUw9eJMc3hg9lwN7Ivfl9GBIclxnLgXlaGGo5r5c26W3xabt5BMd9CZ1dfQIn206HWaZZ+Y1+3BcIH4m1B+HomhPwy09mrge3skDe7V27xuSquO1ZNrJN7LZODQmIynePVYVoqdqGxbHC09Ig9nsDA/7vrugCAlaD81wfUuBccmlnI8SuYdoFB2kOZY6YVMfucXpnDJgIFjdeA1K63T+H6F8T9iuCsq76OF+Ij6A+TA+aF+Slv4uWlai6z7VS5ntA6iXfGS/Hq7SgWKxJL5Io+y7B92hEx78PJ2Q1MRU26dc2JtapzEh9BYnRP7VfGGT4cEpLf0+BmkytRxSU7G1FeZRH5liW3hlh1eY3yTco9uwfJK6rPRumpoAf7umWRXyzblE9YFM8/Z8wgLtgisSy8rG8PWK+AUjaCP+OryocqnTRVmiQ583c43rSbheyihvrOxcoxVqvDEZfQMsbCtBLK2LYvjYQLV/I47rFnjNUQscXovMY5NynfYsxwQ3HSZPQHMY94RWpnVvnGczAdTcVKnsPW7nBY4uHGL4x6ue1CorPEVM8lQHAARabHn/8GVJ+8eLyTS7FF7uvTCRQMPya3ejRIu2wfy+XB1bNY9PMP7PBQoE1OVf6ZyRgexjMOaS9gr3RrrhLbgIR3nv3etJfzII8Wrpb7y0AOC5ZwtJAgwTuRVK5GgxVPsupxs9T4SQjQNONDlbNi37q2BgPpOtfnFBhVR17QwRcrKz+md4ixmSoOt3Z2IyTE0cyUJ+ljnLq/JIUVQ/wZd1+VznRfSmkNloYDjI9K+gzMIc/l5qSMuA4CDCM/1rfXOr3QTXQ2P+x1RUuNrrlBOGLXeNEgJlsSFkNtt+w3bnw9wQHHYjwFHI1LUSIBSrqP57wLZt3zo8Bu0C/C++DUSxxK+q62JGIre1B/7onaU24RxnxWzMrqCP/oILrh8JdNEIeznt4jEW3SxM5Soinu5N6JBfC2021RN4iN2jaUWwnO38W12yexBPln6PPFRvG2E1qpfee6KOCI85Z+8cJSyLa4sSkLAXZ+RHhOnbMdgDL8siXES96CdK6WQ63VP5H6DG2d+7LjgOL4ButXoa8zSZ2QKsF33h7mmn0BwPIG8StEfL+TSG5Duro5FCMEKBIHyFVg0IjZVnzjo85kE94N4JTGQyXu/L/FxctDua09It2Swbl8b72GiYh3egyeKrh+S5yh/itEgmr3+/x/4TlqFVMMz0mYAmGCcSCZOSU3jtYs34zDwgpiCVjNuOqsFm5CFEIS72RysiyM4+LiKczUlB8B6gJ6+66lQ89BlgGqC7Ci0lXnHsbvhNQTNAe8akI9Qd/dHaQ4gQyUuV1cIISnyedpgWnR8h3U+Zg+Wzpx0Y+dPrE2YftcoVw06NjCbuBFpP01rJnCOHnEU8AHa7Vs131ZCzMyw6fw1npm9Uq3fA1dQdPLHPMJUZOqPCaRZOVoLKz5n66LhMi1UKNIsgVl09/S2TMmWeJbpw2EVdEcWwpOJ+VK7xN+AuPPdRb3MbAxNyIruSwL3OXPY+vs7mlZQcRvgJuba5DgZYjzu+Yt+JCvhOVI8E9svF3TzLkv5BZEC+Fo5QChU4KiJHf0l82qF/gcMqRLQ2MMW3E2C2bRBDimaipTEfEymj9OSoyVwnU9EuqOTi7QXDDBgz/KbPjRQXQhn5qnZ6qDPWzzwo+3eMbig59FDk5zjSWafupgVX74XF5pAfqVNu8X6dza2J2Di5lrF8m2OzLDoDC6ws2UysRzOAN9ysxB59C/IffUJCcwvEcVql5Lvs0dYm7l4LjF+8OtJeSKXbH5JLbNBwabdwl+qkAyjHS5VPJq2jB2uIjy6QxVutIfAt7GQAP6yRAatR/sl2bUahgC+CW8qYLNr4nBXKX9p2+QDVfHKCrVJ5E40bxLVN/UI1rCwqQiBy7E/r585LD/eLsh7dLjyuEULIZ6MytsrZy5rhDrD4UmG2IMNPYffPtkmLz8EGW3RzIqi+O/GpFGdyFYPohQJdPOdk+Uus5iFV4dPApM4Z8bLfstn4gt63wsSj00CyqCilt/2bHdAVqT3ywYyT28M3ilzwvi3lFn5CEC4InWYSi2QRxchsw7KYnuRUIAwTVDNP83JOmPSnMlH318aVUwxHejBv9CiME0KQ8bXRpHBJ0dSqvSUnFwCcHdIM+EUUzHOxmbRGmmTblCmQ+35lVUIZqJ/+laXPKnZHDb56vZ3Hrh8gLkGpHixqBQ9dwfUyHfoBGw71XYa1Y325o0ccsJw9UkO9JszoqKTOADj+3ov/dvjJMTtQJpJ2LUFRTHzDhdeobMiXwrdx5IC09cJnFsxgAqm8lJt2wjWJAUwtnJkbj0lRH8Rf1gdjWWABFWX4D1KKHKPdPBC9dVV9Ggmj1r1xzxANybBE5o364DASpH6hWmbgVSwLC/wWaUlkqZf1ipfQIHpysznUiG0PQp6Rd7Y+AOr5RGWUKSRrA8ceDaMZGm4vTro2HVqov36FYTTGBxzJJ30frodykAaQlo9jR1O3TPYv6/GenkNmS93Zrlfrhh+89QzEXBZDIKr4CtFiDJxJcI6hUVQXce/1khpyZMdlmFJ+gpecQA5FxQfZ4Z4ImDtVbbBJoiuMTO76P7Tc1Ta7abbNoYMhWHwz/49XWoPyS/NLGkhWGN/DMcwBqiqyjszVeSIfc8tmQ2erhJEBlKBMwajmJe9GiCT+aXxdE82SbHz0AXPefLe0dpvbWy1Hx1QDhkK32Wp6YrBl2WLQQQzfjBdgPxKjPnMYnojn1Qf7q15wNc1s3/TeK9J3EpVjEV+g6hexY1L3p8hPkH/blOzgwmD38uoFA9ZURDBwhNdgpZKl9+3nYWV62zCFxv8IRl/zrHteScovW8ze/PlkjYOGRWgRXq1fK0TGeBG1j4hw9EIs31zPROu3YlcMt0/MqkCewqxD6X/jtwKKiRYtNnXXYdosVmItnYuJtbJec626xyYx/UpuokbkxcVE+ptM2ECYYEvzuChyVp1CBKUDD5BgBVKaQ2YqQjHc7uWkeoDmS7ZZzR8WyvyZyCUaUQEVFXogktQGDVpnApLdiotZK9BN210WQjQPYsGc8m4R03E9fddHNGXVPNj3Kp8uiXHSHA7t4tM4WxrnnZZv7Q3Z2wu2b4u3/UG3fz2r+ACKSiJw6kvyNYfp7s5hdEsh67bKt+IwJlklGt3TC9zyZeUWEpV/FyKZ13SRBGuiCsffjWa5Qj10lQGja1vlU3TpIdfRQgwhaThfTki2zg3150Okpd7AsiJiBpSzPpu/mMjjZvZvEYfygW4kZXsv/ry4ik6G+NKnR0pNhc+sAxctMwo//gr7kB6MgJ0dlqbWfCaVeXj7ewEP+dZ2W2Eg1M/a1eKFmO8zq48z13X1sWXLtMsjv0RI5snzHtir8skWz+TL55sFVEBsp2hACh0tC95Q0qFT0LO0XxZJ7NO+ou4LZCFaB9r+p7Ik0u1qADqJ2Jo99HIAS/wybe+Fwoxc7v4o5WcTngyO6Z2wpfmGWtWAwpr7rlZ4mgb+lSz55XADKQSRzilarRXtGK9O+k0HWaE8rDR1ytCQ5W6sepcgAEQ2smJ4BVl4fM0qWWJibiUKOdVJDkzm2L2Kj7HjeebmwOpmFARzG8mcl9ZMvHwTRqUPe2DOVUhcIPGPdnTsVmvnIgZRVHxiDLyFgGPnMGSbQY5NS4c1Obmt9vleKNyVwWNwml7UrZIHU7BRauqVrEabA9IKxYsyG83zPhxViXPO0QRRmn2zNWVMgy4HODtL09ptmjhjeI2qID17DEBtzkLtdmvcXy8F44Smo+XiT+BWcCLsE0b99Z239cfzI0b9y7gAfiXcbFPXFXFa3SAjxMyfruT01rlGN1W2FNG+0LJ4Q4DmXfzZZsoXivO4pqtR4ihOauZqHrevgDA/zak82lNE5eiveoSrmo/eKd/qszdLn2LA6niFmIhNw47GZCBR+VQBX53TgXmuUHC+pzHYCXujGFPFWK8hRLxIpQ52CYl3zquHq6fR2BLlDQLixgPBfD0B0VUvTEe9WpVKT5MGeno1TB5AHKt6jm+DONUUd6VuCgty3g7yZKWAci3N8oQVzggo9oew/rlvwU219/Wo4VovkRRnK05Qg/pUNJKsNFHfyv2zfYCMXooNyE1SnGqDnDw+tuzAgQYYv9I9e5SZQT9AXtB+I2YaUoKFKe9XV0TTWku5lIKVJHjTQjfSFwWjIHu4jOaesQUXhLTFPd3/GDhnP9LqGY3cMYIIq4xgAFwrbIVEG16Z+6EU1vG05Y4zGdwAvS3ld05qgrkwRsHMPSsrw15bzTzQOvENXPa1tVxLElc3fdPxCKkJknK397hDFyhkJ+vot6Q2GhIZv/qEoAWzMGg7xpTVA/k2xCLpeqTtQ7IlZC+Lz+J+hWdaPfbVi/GrjiscTeRBNtO/Ux7gibtm/PXl/OLW7I7xdGdaq5JkPFguDp5SY8nB06Iop+lDVeCgblokAO6SC+GWpqudet31KwXdIRLTG+W332rwxeROsQADV2itRQQfkxHpKi8gEIPU75+9QdwheFS0sEzj2dj/c308DitOFOXdHF/ivcRQFn8/FTAa0KTbwHRLjjvnO+0wq1A5xH5io+5c7v6Wr+HwMQWhUcSCEs4/IhTYxsF0YpU/hwiSRzC1qY/X/3Pdtq0Ec+O7bPy6WGqLszw99oMT9UyZKKIE4T6ST/6MZ4rsSILYcv4CIt1gXntXd65t5MRsbm/grVmj9lL8yTXE6V/U9fstO+YhpNsO+1josMA7kHgVkAEYwDujHdjOI7j2y5WBHW1PxAK6qtG0m3PEglNAZAoRrxLZOMASTTGqTZDYQCOxUtJBB5CTWDuaax0/9F54+d6Tuk9LEFrZeDrRXluXwvvidhYdp1py2N1QvksedkZGJ2JxvcerY8VWgJDLmZSL9QOX3K4kmHWJIhy5EEx5tV9XG0C/91o5i4S6ElWF10rpTVKo3CYs5MsV8/Ze4BEK8HcjcGE+J1pdNEldqnHk6IczvaIWmx58oUSPGL0DT3Kt74sdhtAozNmBbFeKUAgN0gbDQH1bBhC6JsAxLTOGzMSYiYhc0vCJWXficlI7ItJtHbpE7JK58xlIkUk9cYYF3KsuVOS9M8PcIrayVSjDIdeq5im1tl95yiKhBkpFHu186+FusWVTAsT04U/eVqI1iSjSFNwmIRKjQ7Cy09rouAi0cHphzzKzA24DZszi+TTGOHJDqeIpho9nSstyVTBH80PWKGtv6AaEVHiojov5/rliw7KWIQKsqtOH+XuvBkZxmiOI+npcfkDcWLxCfl+7F90sJiE8fhvCk75kt4L17NG4bTO22OYcvl5icIS5eX6weR1/ELetGa06Yr/5DWKF3vA8ZuHNGKYHAGDHxxbbjWqxg/GhkxfdI4n9mskY7iGtMrAaUVouoD/Z7ROJt2l9JXZ7Q+pB/C4DuvqyyYyTsqiPKdpwRDyB28Io2YyETUbTwnwWn2csyddjRuwsKUou5y5F/dy8ZpXMP8GoCZd1E1jUPah35zXdjDt77FItLy5AKZQJMhWIkHMtgwjgJLX8tLSvfhh+jsVjct9odC11+FZ3bqbq6bkcuCtLs+Ie31hBrNkjH46kZGhQUgIQ5Dgvh2dgTAWOMkQQlgbGXon1u1Lh/1ZoLJkj2ExyYwKK3/ZRsg4XqWaioL+8rThbCOjgLjcxb30/cxZgCreGEhguBrMQBriYB/rw71A3Dm/O+HYtKQlm4QZKtSKHnMwipkF2aIsi3G3Q/XhNOwbmZafxPBEVwlTJ6f0OEXQh4US30xdcaK6pCxuGVytsRSJpNVV+ChyKPrEGpnWRJmcZ4D58RVx9LKGscugUfXG6l2cZU9LNW8xbruzuFbZSOqq2GQBgueHBbqiB0JkODmhFiAP2rxEklEydY3E6oemNrKQWE94419dBOFjIESGFkTDSx4EiR4408pcLKHz3HdAWCT2JrjhISKK4JvamD9mfp7FGAT9OUFGRAcNCjgDJO53i+Uk+KBjViZeYKTP8QkDBK/uBeyHpG3C2wNxkWgt+r6yqoDiV/4b95LEzuvB7L73VXhlgbDEHf8UIXUydM+Qu+3H/dqMNF4UYmAEDfTHXc6Niz/ypnpXhHrsnVdReRe009HS8Buf7BDlHl246trlfdarsJBM7AuZAebigsRnJ1maQzAF2Ybs7YfL0m0P5Fvm3XSTtG84IKQF7EIloN3jDA6OZwY3lZLeOttDy7EEANXC5GfOpN+dkwAjEaU2OyOYld7e0y2RWplNqfJbqy07+kBmgKpEHjBxKPciZ4/3gPgeiS33z0yS2n3iILm60D4z7O1PswOqgRbqrvKaVSe+6foqKETKqazG3x20dNUra8vI16Iaj4zJH7q+FSobZFzkHBUlJ0bmBbBPXngmjXynHb3Tlym6a2jB/c10GmNj/OW6i3CzL3/gjIrSCUOo90vf+22YtVEOHVjwfVCENaAdat84OVlkx6xOaugAuF3OZlS9FNtMuClgnmHsFKTqcy9mq58LqV9B5yAGlXCXu7v1jaY0/ZUc3fuWlGOgTJPUTRkZDpliP1sHKAvyPBZGOmcQrl3FRt0VphwYuUjIfI7rEcVWGoivz76BvzQZfH3UP+J98rpUqtMgQBEZMME+FCfE0M540ro9KghVLYFxUVoE8AdWxQBUWy0VbXJsDAatrCC+tPPuUgkTuV2kQ5qeirrqvmiNYH1vqD1X9TewH9yR5Cy7B5tmaMfZR/pIT/GJeUV76wTzukyNmp28BkSKKb1LSoKbnn2VmyHlPNP7A/TeAWsdHRu6BWDmPdPm+DqRjmgOeVmFhO4W5K8PZ9L7vcybI13GlNx7+N5g7JWa4Q5s2eQZdjk6afGU2UX72sn+OX+N8/bP0xwUsgFYH83LQpB+aQAUuBGMyWjH3L6dFj9DLeVKTy/UC3WEYHLB2WfwUJJ+aZKPd5SsiF7ScLeH59Z7CZp7KIuBcAlFVtI/6mhShri+WtFvUUUfDAJA9HP3FBQUr8KWoxWLU8zfERNcLzbPSWxbddZM0z2fbC3Ajznn0Agw6cjMFOttVsJ+7w1TRbcdOcVcvbdQDfS78sVDAdz9VdyNfBqyWFyD53atRsCaakVHYhMKtOdT4aYdo4UGSFYuZCZhyQNPo+zMd6R7xrFwZTunLQcsORVBVq1FAzGtbvjil46sGuO3fUSHcIuAzrpmSKd9kKMvRpNT6DZDDFshT1sRS5ASQFVXeI0eB/8XR6q9mI4nICF5/SS2KTkVM6XVBU4KAsf70EMj4ZDMh9jhmWMEA2WlmJH+2vi48DUFBpHaWeWVYGe5h77lafRP0mi6ssV5DuW5Xhi3zR1zD5RwsT57qU23XH6U1ABmjw2wyLDAPyp/axc8kdzEhwiXssJso1lcSMpLaeicPhGDcWcdaE3FzU5lKZqJ7MZCvsPdVG3yOOlpKhyccwUcj56SGfBKFzHMPsrII35R8xvQy9CxuAAzsL+x7pXC0gJ+gD1RlKSViZpLOAx17Oa4kA58X7KvC42ufwi1Ujtvfz2yK2wZDcIIfMtMUuEISkMlBDWhZj/K6Y/t/LUY8Dzw+ixNMnVWGbmxhsIINXgT690zLxRagtHl10o1OFH+yY4Km66wzqC4w8KQjT5uoBBnZOyl6wACSmEfcOJixK0F5FUl9Q7wOTM5CJNYUE0/X14jCyGMcGMAv1DSXL71FuAM7tvyk2G8H734j2nr0Tnu+r+R9GlHNXyXPjEFwvMBCfSM8kIwoOUdS7emq2Rkr2YUFctvXa4N6HcfsC5Wotm3E1a4VXuqqcZelx+0BKo6xOLqOWPrdpFWYVdI3FkLIadm+z69wStmiQ5mp5eAb2kj0W8sjAB0u/Ayvdg+zoPkQOUx8XtXQWUmqjiU5aSNuwyE8Z+z6knsD/KAbb0zbdpzE5jsBPIlCnOyWq7L1sUc6jt5kV9VsErga9PqbxblpVh4dRYyPCdBsKPU80/LIVNlfyqBbihuiPBQMFhKZ6gUz0s9Gnf7xRvQnLhEDI6XFNOy7JVy3pslZajGPMfWeygcIb8hKz0M65U4/Oqua5XuaYvzAhSIQ4pXk3YBF9txUA592UuWbfmrbkqcyc4fa2ce+Ohzr73zV/kI10x7xj7quO0TDu4SaCwPeeiINLhK87J/w8jseV0LKOE0TDN4MRSEo4h9f+JkdC8c+VrMyMideMIATvVHQb8f0nhGgRwEHlMsTorKeGE34iVvxy4teEqPhYChpItMjJiI3Bs5/L4RA+LRfGtawOfQwBf0PqYWqBpdBS9LYqNflh2GBGHHNCvVtif/cD3ElzteGhw0kNb85ehaPwR9ygONy8hGLxiqqqCj8rxfzXyV0+l54b7NLCFsyJZdAgHL1e5FaAJCcWPiX8MMabrEbnRcmbblA6lmtKRI+4SjSFc1L5VjPVjS3Hn2DKKMfkvqy/jUDLbpNbPJj+AS9JxTY8EPZ6VH2lWXKFDRFnQIOsyLEJZllRiGqF7QZw4PtI2LPBXDPywU3yULlY7R+UsZS9IAiwd+CoQINgavngGjM2wUcKZiDVKGvkax+QZz4fA0bajXwA6J5PvDBH3EWAcbCdLmx8sUitCoBRYty6Ol3xON+/Nju+tTov+r6SH6vd3dAkHO+jpqLhOHDvyKJcI6XKxKShcuEDk8MKsUXrSb1eo5ZyECSPpf1lXnicomBuwY+Tj4KBGjY9Mb86UlPyquozFZrHxfjoBZGURFP2hahwMIVK5LiQLWKtTrcM+PdAd6aZTU26HUo8EaXGnk0Det5zlikMoPOtbOeZlEkhdd9/iQgbsOzif0iuYSwoFLhwmxkrd4SpHDCdfSLgqA+kblxjvlySsliLmkNIpiZX8Ux/VlqdpeINiDmSMrK47XxS+DeCV22b+1wtloo20MiWrMVhU91ffMsGy+D5WBo8IHyyjQfbEeykHR4huBmezBnE1SzWLrT/ZAig1U+IcgOxQIFjJOfmyAkpsANmMGp7TTVC9eSWIVNhg3q/0PGYs3HtSi8xOn5cDKWxfdFGETXLq5w7SB+t7rbDqwXbyfq2wFsnD+8/wsrM7MpgkxxAsBaRwI+jNNjn0CL8TSkWxZR8jg0elFHgWb3oQeQelFmQbu8DA7sSiNOwUABjQ4j8GMpXJBDj8oNLLKYirpX0mX11JyP+sT5OKLLLLf+kKxCgiuP7SERNmURe92O4E+/sXnXqDjcVI8RlILj2BToLAPxaKv/3LU3pBaponTtlFHhfJ2vQSLdBXVUIb1+8DThVXsAynQE4KSyEdHAmuGIayphfYtIBw+m+DaRZzbE4n7tVJLnubZsqKv33VDAooCQGY7Qv2/tDb1/ON44od1mF22aOEgOT+ab8X3Ti1XIbqU2snap8AVhNFTh+zW9iV1rJup76S9YuZqpVpa3AlAg4Ig1VIo5H95jT+JSe97VKblIBXh/LQTSuRBKdVYY3NMoiqjNoXAHDooLwdCzbswyYxVkq+w9QszwR3m4JHonweXW9xYWhn5Tcu/PWnYNpuLYWs4Ra3ts658QZVdi4Xy6SdcmNPzzyR5q2hY3xujNrogkqrY9tGbJhv8P6idzGOCTEsmcSlKjBoBipg6ktaQtALtUEJRma33fFUQ6fjT19tLq6v59RMig2BFCOa/zvt4D916s/xkHgmkdnsulBHuzzfPqDQ+FYFUHQQwrfwgmRNlP8o89dHg2Lrr//kdgaSFKUbvCBod66RUFucKCf40Lbv9mvBONXGvdSidTA5qZiGaN8JzS7Al7tcCg8HL3QIZusjTQCvc9g6Zpt8VnH5xR3MK7v0v0zqykZvjgApZH1hiYY718U3mMOanrvtFGLaXO2JTpnQjYCaXvIYUjP6QL4462ymSq5BRzvruCHmdKJ10aBrFMgxjNwpIkWhgkS/fhEJprZ4ck/gtvaHLdNY4eRUaBUj8YG0fo4szIkBWk+6rHSG2IlsESyxeizqdKauXs76WhD/yvH2krLLtF+Lr6TnUSnm0afrTouhiDpXCyIMEWAeLq3LoW5hhjojM7PAzUpjJZdK2EuC3Osujma7LjHEI2hKRxRth4iIsqdxge6BIWD0IB82QqXtyJhZZY3Ak4csY1QBU2f4zY9H0zrD7XinSPlTc4o8olbzQxY2qauRd7wPnkFV3KCXJ44w4nKuBSQL1e5O3CoKJvgQ/WAlVeKEvI5yOsxfl2E9wjAMa/q/taPO3a0LMZZftBu6qX+e/gjCPv7gG8pQhggnh/4d5fzZcSlMcT0ZmJRG68ZGn6eMj8jwQsZFt6NFk/Jo608H/rfB3p7+if8MFpz86OZfA5/ijcftIfb7OYRsasU4AwXvgXvEIA/lG/zNGb08gfnzKsZ38+UtVKiEvYYxMB7h40TPrxZYscb4MiIblPFgRdss90Hy3Vhaz+69/vKD3tBbK7W6Lw4pZ1oPrM/lVGIrvJfugJ+PLWp3JeyAf8dhSoJGN/GSvU5d0+cPGSYzdmhdvxIO3qc9re7ZA++MlUetBMksnQKcVLlXI4TGoDUVQBNiMhx6/NpABBYvITjytckSN8M0DaMIy0cddTOw5TagPVHD3khrXxpWBTOgZRRoOn/oaV8mQFXZpDRq3ic298kNWTYf8faspCWjO1doAVUcDrQW0edwoKutZSEKIhB4rQotZU4tu2pyBAqZGKLR4eOV0dC5nI1ZLKsHpMge+WAlKHMByMxlbkG+zXymOidPbTjXSMDqPfLYXoVO3HUjlkuGxCOIICQxj9aZGP4ID66tRGzLKP3XPbfvBh4FsSVq1oIrcdS01TcVcTBDbEcNUob9xaOMj1YovoF3zX5t4EKFT/fqb4pzLGsmlUX3tnkwTlqlUkDLagB3I66Tg9NIVIffb5nqndwjXD/ooBqTSbpp7KQIj5wcmjaLUpwgZ3vaLBVqejC+MuLGCtkpBDd88Mh6Eqh/oKORDhp5N5/dYwQrBQhCjaHSK9S+OFt6XUu3JZOM6oZQvkntuyEl2Ibp1hLX/SiXgNeO0cP+N8yuBg3fEXx7yyd7cSTkQpHBscv0qeqNlnPIEEMFcRHiqWBzTx1z3v7gBv1wY8OtXlC2GbUIsmEQnKWsYBV2ZWbMi44dB2ndE0Vzi2XEyOJXDQHbfLC7+gnf8RuAgxIWw1jp33gcUAobwdyBaOhqbH1gYcT0CnL8E3rBNzpEBE+TfZtYryfYnTzRWFi5GcZ6PQjayImaPl+5KP6qZ5VNnDRADF+SoW5QuF1CgxARayA32nWymiLHaUwpinIKPQDoqKLRqOPulqGM65+EIBrHOGfx642b7vFB2EHS4pDvWxDtNnzMiGKRRWeiOA0UsyOJjJnCXg6xukBr/aMFztQ6OX+BNNJUKtOjQvdgb8aI5PpGGT4E8Gik8Gh+9ms5VM1GhrpcoJVA/Jo0DV3FR5mmBSqd8JClH0LIm3m9uhFltPZ9x0Ocfw8Htadu/ot/kvsffcJIseLO9zdKcOx0kBej8PbH7TAilYwXheqkuQ12HLRkE/unKfR9pXcVNMK+yN5bkW9w5mbWpuNumpHJXTjU2sRRFUHfDfRc0+NoH8lDOoXn3FQzfhUoODyYoiVw786ydMzndb0jnLXkmihu6o9DpAaQj/dp8SixlaBQGGTXfSiGBzDWDpmGlFLyNzarzG81Vyk7bzf9doryXKrC4tgu1gcXXB1Gje+Ww2aytKHvnHah9jIcj5W9eX1e3RKz5199aOz/6GP8FbrwZ+Anwrr+wNIQkNMoVQWsjR4h/GmA2PKiIfBYKDZpuCeSBPR/4imcBxd9z2phP1eMEvE4Ngo+QO/VH7iP4e/MEbCBqpvpCDlOiP0PzuGGSNHok0fuGZ4E42BqRf+iWceK5DuJHNQzfo7KWdmctK27sHYzD3UksV882lBvclStenjUv3Eh6aMmJuD2S1OSmK/WieNcXMN87LMohD8b0ewGASqdeEFfLup7lCGnHBgQjeEHIrptc/8TdUCzfz7weXFr6xvotbUM24CyHXkvEU1kvuBkYrpkJnAK+BPaZGFw+nKHjf1MOxdA2cR4PNVp/RzkxSVzZcZAnRieKt0uDecpe6IBDphgWYAuTdUPahgYI9GNaeInB4lKB3cEbse9L0Sd/WIatt4ODV/+wFJJaloa7Ep7XXDnLJLEM9tA1hg9BjqoZe92chcEaomwEhkbmsxY5/HtYUFngQdsgdTcOHCodqT6WDHqrM41s0+7mOMwgwVhdsD1RDfLipB7gHi8q9pFpXiJ+dRxLCejwO60Kgf9OZyyUZTo+2Ee+K+2dYSZ2Hm2AmJ3AbjoEUvngG5eoFfl+pQp39zVrgrU8h+GI4KT59m7FcdlxyQWG22gpr5JIhg3UOCK5Q5mkF60UXr3AcdLzH9/3tpwnmJuTmK0tySGnQbOxtqF2ZtrgnpUuMZcWBhmpiALqymR5XNpKEidUFw09toxiZhvwidvAG9VzE+DgKjk4CM57MHnLXacH71TwPL1LVg/G5Ya/TgOATkfnO5iNsJ/TIYEOEXdfEbK1rjGZSSN6AHMrPPO8vwkih1LLWUSEbxxDA4FwtPqJPGB5kvYKPrCeDaddZ5p68RVcRJDiTRuR9DkUeE7RWAygFLF7+Kp9gqjFFalrCAHUn54LGZybsPHqiq6M3M1AJ2a/okk2m2r/CtGlfJHVgmMmX0hWDUrw2W3RzFU5FUdxEsD7i76Ww4dF6uiqVdpzfWz8eMRkGdcG4bAFBuUXNiydeRPIjdvyTsuNGTHIRIhI2gIcBnsWlkukx6pjFzq5qQ1XDXxiiNX5uEmJtDSotLX9AEiR/6WKC3iEH1PmXuOJMg3iQlwPXuv9h+ZhvskJ4NmTtsssXKB8RfwFcrXVy6aE01NapRhT704KANlCNxkQQMpXtjgERfGVKXvEjuTjwWFloItAlQmxz9rbjl8DMwejaHdznWzoydFkNqkKpRrPltIk4tBnAi5/tQngqx5PhNn1StkrQ270i4rxobeLJzB3FwcoAsT3Anb5/R4qM7Ilv2UZ6RSFGeJ2qhZEvVnHdre8P0Pcbh9b6yWOsP4NrUP69JTeG1usSoa4NM/wyzxnb6vOPZBkXrtuoPjq6RVllQqJwsKyEl1youvmbYAG1+rujlSpMGGybbnXdt7QLDv/6PLqevd+o04SMABojzx4FWPVH97oOQh5eMFcssJ+gSdOhC8uqctlNVTGQsCTpCY+rco6NiI6rqfe25BCapoPlC8CON3Sfo0Ee8v2Jz+7rlEId5NDkQr4nhnQ6i9VsKxwEHR/+7ToKGpZ4g+gIZBwjmYYwKYsfz4ZF8+Zr+ZDlq9oi7Um/qGvK4EU+/JNDHbK/F1K7lWLFYmj1it8Gs2CEwTRnqZ5Bx42wTSejotVEpIrXbNXoECYdQzubf058Mhg/bjg3QZiUoJvQm1rvjOvNy2NgRGtnEk6LaE6zGJ0HhdKxEbV1oPyIUFv8umrwNRMGtxZCG2rAOlPYP/fp0qOzx9zK4FwtQGZP4tfYtAgmH3EWc14l1MR3GU6ZVq5WDh7d+YTEY8X/WoTOrjPrbXyFe1QeXVW3QEdIcDLGB+HxlCbHUrBEq774uNoy/GECtgHjDN9EwAF2rYsVWt4gycL2eWUDO9USf9oikuB3jUrn7GUC1bXd8CyR6m3NdVsImhB7ZUbntO/hw/OwXHetSgppqe5NldWQLowxI3U+3ReDZAG4t3Mgd39NU3oo/dHRBNihRDihtdVLcXcrOmRwSuLaobtYkDGSTwR86Iqm6NsF5+xmJMqfKxb2+SPlMnOd122dgdYI59ANvCdty7sU77MiuIB6Jv/PTvRW6vplcw5TANsIUxTHVdOHQrgDwpqGwe2PUk/h2V1XiG7vF+oN3EmA2DBTSB21jOYIin33yFczzbQAu6C5+/p6CA4rnS5lMn0TiE+QH+imAVYem4AoN4EChdj90QziyIqL9bdnSi3Ni7RyA3Upl2ZVwFWYDfSOG+hJ1/X/HUzQC31X9yx0VsknFY0LAkGrtfGE+VsDGmfFvK3T4hKYBvkSHkwBmBaBzVW23Xyn/8RY+0jDbihn2X8LDu52lUOJIqeslOeWSNwGhP1mGjqm7BpRVlRsd0Wk2clrG7vVwjfjAMFCVEwDtYTL68j/La1aVxyihOgrjRHFPa65j13jV6JNm7tU2B+IR93nbm57LlMsBSm+59FNHKior70x/0k6ihZhzoqSii5ZROtjkznprzDv0eX9JMxzmWcNJF84QS+LaMCqzte39ZhgAHfoOfzBAbAqix1/mqJlag7N0tm2QlCAFcforl/2u6CcgaGgF4u5JvDOS2xE0MNiv80UfmyOR++kyHq2CWDbXx0pt9cmMxamouCZSwr0luLt+um1BI3zmCy3sZIL4Wv+zbKnp89AboGJ5IgdAERg3lWyyD20QqPApCqTJLTUBPpUR93Px7Uj/lQKccylx83WnGDlDbE2JQO2AeLCGLIIa2GFjZ1qxPZlnrw3ScscLkajlKkqallk3S4qnAPDQWplk03EsBGudvzz1lCMd1jNa+3iSHYFY0eZW8GJeGqRebB1APIhQNdA2n1fC8uZfgAw1xhHP+IfHcwXrRpXAwz6rZ7rtWBSDNK2mgr0RTX90W87Ww7Q+TgkPAg/GbM2yiepVnncuAU/oijYH5jvkdk4mp1FG3wcmW6ANwesMsULgJtUMdqW9K0m6ub9Q+TjScMJIcIjmm0YPfrI0bF7qoxxYfX0rAkJKVaQu30y6qjhlQaa/KdAKTGhfATVaV95GDeNPEJx2arpq0UiPUjPscQO2mBtCb6OrZM5F6uROk2niiDMKl+VUqUwVICCgSN/QPciRGnpeuS0ciJUBBD3fbJK+p4E0afi1+bkm9KuDjES8NyrSF+OgillHg/7EB+AzZ1anUYkSsJ1mgVBFobwYEwZC71tx/XQmFi1hFFJvzDu73ThAjZs/vBpGTJi+fu96V4VdjxMaAIWO3KQuS+TcO7Mi0BiWtcvqOq2DXvZFb4CMy9L/lzuxwCQ7D7TvxeTiYE68zvcqwvTgYGwgY/U/79ZGxau5oyXlU+WiQ6ksVDV7bt03TSdQwsww2NkEqHOzMfEzhdoO8UFmbtLg6x+LG7mH71cmmwf2WzPDbYcLNGM5ajJTiqb0yCJeJJCDuWpBS5Uvrl6uHm74UlChq74SsZqvjoxKYW4tKM2uGo/ZVrvOkM7V7QzfziwtSZOEK4SFKV/LufgEfjHFCotnwj4vgeQCkwRyTfNG1US0ir6NOVOcM1vOqLo744a4dNIeheCE7SdFUudJeYCZjjwcNAeQAb/bxtO51Fc6YmKeUjePTGZc/o7tcXPHyTA9rE1ONXm5eAd9vPabXIZtujiPO3nAfZyPL6SAz4qPK0rmZCQaZuoI532ejNqp3bnqStB6X4ysrUVm7J0SMt2XFztjjD1qAsUjwK9/ZCcdy0oKW5qepp9Xu7IkMpBjh7B/q3M4+7PA2KAtWGa1ui5XmCNM3QxeHC/BwU7ZN+HdE6Xs1AQJxZ45uI/Wh4I8o2Cth1ivo5/W9nzXv0TWY0k5Bnjww8QORJPhLALYb3hu2dyF9yC6M7rosv3bXeo0LcbDTA5s1fY/E81G6VYVszChmAnQNst72ERsebHklFRRu7YXf4OyIhJvPH4X1jpLsob7XVzkczLOesR0ZVYOVfNzCeR3yGd3ffqgpbxbHofGwapig7E+1111EhbmiC6J982CkJivfaRDqndPCSc2mUlCmr4afAHItOyzCUDm2rmMp3HD44O0drUuIuFD9vhuCkBlomgtXQetenvRYRBAvSNYPqiGEfLRbwCFLRubcE8EFZ5//LupPZg1Kg4XXZxOHPkGVJC+vSnPdbHUP2rNUr9jrE8AoPwsACq1vk2SBeUymxMreG/0NNraRJnXnxarStxOz4zTHLvpaORZw8q7rjGfVBiGkmLm5H5qxt9k8TiTKw2NWGq9cWYXvuIW00bq+QLdGdRZtFH+EYPJkcsu+O4sKC+inflHmY79dnDCX8a+VQauBN6HhblMSvdOd+jJcNzJeVJGyVkRs3d+CC4DxlCtb0qs32LznC23638vFRbqqFOx8+1iKgGqEipxHnnhWsb1c//3/ob9zMvdpn/kaMSQUd2NJ7Y+PNuxhfB6iPq17GJ7EjWXfV9gb7xrb6RjRKH0r4Mw5oiu/zUwnlvF9vCiY1X/rB8o8Q6DxK3hgBOw6Cugb3CxPrD+CW8zf6cXUF41swukRsLJG4bGU+YOPa5x89Nb9qvuezaW3GyBNDjevq2lqPgAOT4vRC/oFynXlLz19PcO1R9PyhltZ3HBc7ayiQutaxNeEgaP/vslp5MjMgnIBQLkEsyvCQDlaJA0VmpRR1pl9+oimOnF3L6Ezg+9urvCJpd2HoZ9EU2A+kKHdHQH5T5T25KAguW3i540sDvcB33DHl9WiDvEUxIwyRULK6DWYbfVSKNeqf6jIEDcfqlZeYPuy2sFhEGxuj4ikJQ942koCNPu/1XS5dmzC9cT7n9dHaw4UzHOm9kahniIHiT5T+fnLB+rJo71B3hbpCzIEj5DwPhFCe4Swni0Wm6K8kjZug68/s0Q/vW7ZY1N8sZvRzZWIZbL7MhH+M/fBIaUPR2ijMMglEpCukb78TlKh6G1Sn9tfzNNHg42lzxW6gtwcmPSEwgvS/boLJ65ZpUPbr+VVAu48RDNULqQIjORvXWcLbzwbhLgRQfOU95aaiWfDgCyqDYMo1w5q4QFAY0mfWts2itouONXa/3tihVerzM32RlJfgAi3vilaKs+yZH2kM9+WLVxSJEJ55Th10gNsGS+691hHApxsoLohOHK5M6DMYtd2jUgSfz70xkqbUfEF9U5dxC1JDGiya3X2QzVEB9tQGt4nVr7hanj//Esry4V/3Qu1dmtoB76zr10RFVEZkl6/O36Fp8i4Z4DIaqN/Ah/J3mG8Mph9TjkSuWDDCZ2W+89WVlGQAVX88XYuR4ntj1Krlb4Pjt926M8h9kS0kzu4fkdB2hHmy4REuL2BknpSzV1H4AIrvHCk11RJ+V8OEC33xFc6WL1kgzgQ4bqabUE1awGm4DJwupwOmopdnYx6I2lCAZvXnW/z9gBgVbr/Wn5FK0f1UiUXTjZgnZ95jsDhLJWJsEab0lHg+/VK/SAhV2gYhcExA2PKf60oqtHzFPAq2N142gwcKjyLzA+O/+W7x+afIRyd92X4mFH0DyWGTDPV1jV21a+BIFaihlkaf7qNlBWxdA6VoTxyREpWXfFnLFIKcMDjIhZp7NI0+PG2qUBl9AzDSBaxKm/N5+5F63+NbPUV92J8CkeugYKyfpa9OphxJJ9v90m6JHR1BDVdo9tsHxHGKdusyVLB4x3dIcf6qemnOl1iusvQoyxfLaTDWbfgOFe/GECIx3iQ/oAYqXK8drXudBTcvvc1WdLOKx4O/+dArNd3p/8K7J4URP4bU36AbpDYoS/NrL1vY3ZUY6L0//BywtGhAEEylcCp8NNf3CcxylxfYZrkVRoc3wA0cMjQX47gyS0oO8TUVqmu9M3sGF+rdvtDmSNIn8k4kQqhfWzVZE6wl3oeOyalUgiAd9ZcYWzKi4UU8Z3OJ+j91QcoSM7yxmSic0caJXHv/FzL0lnU+lBY6SLtrqG8UALpqHNAQu2bAT4iuAJDeJmcWYUV/S8+NZ394rn2tE1MB65RYgDC/Mz6jBl4lDldHWQkxgk7nKZWvMH4hzTk00oOVANi8CpIOoJ4jmfgl5dHbgEUCfnrjN7qLD9JY4DIJ1nCWFfdRU7zkoIEIVTL/BYnsDcJH/d3XCqAkFKYiBo6Cf0nZuqOIv89rlkFFfphEKvunhX6UkTbnKFYNZimKPZ5aqnyvrvNgG9mnW0lWgND7M2jEHU0nrNKyglMdOn30kQNni36c43PWdctSOq8ysr30x2V1wOp5cyXC5rZYdX98cDt+WjISDDhCnrfvDFykIvcVt/Tbig+U2xXxPaE3dGEYCWHSDCmpuXKBen3uVXqJqAVIGQZveqb02RD+3JS0KHiQfV0Y722mwAOQwFcKwpf1OtQ6NG/xhmWhURPoVrySUmEcAmOU9EjFUuGErR6iaOlMYlUpMA5K0DHPoYM95flSeyF01wq0tvMdNg691upevFDZ0WDuFrgTLEsoAdAy1Hh8yaA/HVfO432M9IjRFLOEDUHW8ABWT8CmGs5ryxlOg3x0C8R10Kivi9ouvB954PT0ybwBM0KcAcTcA1bwiYGG/92fpi4c5mM/uHlbsEoEc8HljEu/pwL0F1DVI1xFkkvzK2PM0JGiVtZeOgNI/zd07ikc4o4LKRZ/FXlm1dXuzrWDPKtrQ2zARgQKrjLwhTD5kb97LhctXuzGuNHwD+I0ftJHnPJxthBie1qoPHH98mhzkLxyAGS+S4mVhyHm9fNYWuF5KRH5vEwrWi817NxfhZMzRSHA9R2wDWbbjzvzSA6U1SjkgmLCLHfptEiFKKejaFJtNMaWjhhgagvbAN86KATl6D4INQJ9wvhIn68vn8bczHZjLGEWPi5PSPdqRNz0jNvUfB0cyibkd5+fbsxR5MoUt+vWFLtzLLc2Pxqx/Zy/+t01JiINnZs3UvplIb+ewKJH14BcpRCEv+4H/zOpL08nsOQ69v4KVoToZMFnki4NDsPQBfYSLOZX+jSuSLz00D5pbTQumIJ4ffz7xE0Yul9TTgKNEVZe78zCDhl+MsrhrPhdE+t13Jr4W1bY4ThVDlLjjxlyOamHPEonHVBkG60h+HnNdneNA2fGz3aqZ/9Xd2OMZuggStXh7ogc4uimxlTkDY+9z0RFcsQY4DOHFNReiZepb+tnA5ufSPSRI8Wl6EfUCdDzAljxYIkB1++UQtzmsgR/fYETDnaZw9/kqJUbd/dLeeijxNrHIBcSw3ccjVaDPW47pkcq1Yj1ttvTTdiHxpfTGMQvEnc7deYsCTXZ1pqJgQjJlD0x2UUpLP3AI4FxgHoGQn/E72lC560gtwlvXCd5uLZXowjjXAi+BesIBD6xc7qJQhxlTjSA6GWQ9FCdf9mn7kp2TjjzgnecdRSQFkEo2fak6D2MLIYih2sdFP1Y7ltTaY4WGXl+KXkiivCilvFmlIlqchJVTZiVG8Y5jNgdGNQ7PU0btrccvivIEcCDwAPc8WZPVTNKPTitbQiMewhg1Cri3Yhuz+aFRTW8jm0ZrvzklZD+kiRXhtaoBTCofMzXo8ocZIT9dDg6GEynlbqGFzzLdBh6HN/hQycf8b3oGbUucCigYvpZ/qtezl6WYhlWxJv7KaGZP3asuXvrUKcU8wWLCavW27uUe5mm0PvkAXkFzwUAfG9xP2sCZRcvK6tkauFfo3oJkZNnSgCilBrNJLItWNHcPY+4Vv1Bw1veF1xz7hBlxF9bwBKxjvGHoNxruSN9psBo03JzbHxjPV489dIYR8K/Tl4D7o2OYAtC+63Cphl5+TVMa++O7qOsVGgR6zGpdG0dCa1tQ1pnV4MSp1qsNNqOflOeVR6oYiz+CBmXLYV5GhahbVq+gbFB08KSLQcv8mnEQk+wbcWSv2NfdkhgFQ7u+5iPc58FTRCiPRwLBOdK4MrvtwmefoxkfUexYKPdhkpcI4RyXpESt5iafuxxsREAI9GB1673o9PJcTqjzP6S7eXGoSgkwowYrsk3ITTFJGc1y5WBKdPvkZckOJBg0DfEWzRFW4S54LcigLNvuCLDAyjc7d+cX+qhka0fspUfcPEE0fxNew6Nvjxw9WFcqo5X7NRmBRa2tzCnAnIvDfENEO4kiBFc/PY8+xpcxYV5gbyTyZR3h3bxDz0Q2wnjheB6kAcxXsqH2/gahxJN1vD0IsYaKOiZ0bLtLmp/xUDsC1TUuIdmVGmgAZG0KWzCXO3OaKbZUwjteTZL/afGOatHyiw4J47LMgteas2zIm1E5AQSk5d6ipRo2hypYEDMAbf8XbxF18b+CeEUPXvOiSQ61lEZ39Dl1eenv9UY26Arxy7/wd91nE1IhcF0D5ghhc4Hl7niXapjSnq2SUDiE+E2HDZDzx1JwJHyI9iQD0EqrFpdRu1XSFxMJBQ4BpaKOj3As7TPNx6yz2XcEOBjVdLDLrYM51+WzboUvL7VfjE5SbQ+ER5pG6i5iL1f8uz2L8ye94wknbt67iqeAMisBduwx99GPlBdGdGJbO4wvwn79sHhUv3Xn/ZX7kjOr4d5ktcpXP2+0DPfL4MN1he+gLjo6lnHYf86e59ore/BghrjPduzio5bG89GlvwVXlGotY3/ehoYKFgzE7h74eeuA67Ch7NU9/NdOYBW/FpewFxLzFvr6uinLIEERow/PA3ERtyM1fBqBqK3WHju2Dp6vxjTJC6OMBBdkY5imMsg85e2RPykCSosIxNhlz41R2PTYSpp52jDpUefsAR6hjUDKK1/EDKBte6moT+UqHo15DmXTkigTHV5MLmYiapav9fDdRZI6qeNJLzrZzHus/+x64ei0lo6RByRg/1FoORxIrIVPhI7xj8ouoUFYMOQgaYP5yRlUR3SS0/VDw8jV4K/Ahj0hzlrVgrWPoTzKwJUsE+jdFGb+HOPEwt3TxnqadwrZZnyKnxFrHv2LJo59fIdBLwkpcLyW7YPHd6bOSA08tTcbm4a/XxSIzRD8tXLhC8ZdPOt0842hfTxcFUJsWVWJU1xQG9+Bwa5UYAY9UCFlGwYXCXxP/FYyy+Xs2mRscGtTsQflQuXX+EzW/e2PA4LYG0YvgVV9f7HV/k2FGA9WmhfJmg85wuBqVWL3gZUUm1FTBfWtwW4IV7r93iSAGj5iwqMqqhML7diu3iAkb+yyNkgght9oPlwjoZyjhqutAFYJsvRMNQizgOSP8hQbrfgIdOQGPVvsyASf49ZWIjSujH4JpR+90VU7YZessb4XZXhnrLrQuenQOWv9QRL7UkEo1lS7Mu2BO5lnwSJF06oV/TkIy+izkzcA1Pn/p/DDiJi0GFnPhJib/7BFhVjOuhE954ZdyCUiXSfd+aymZJL0u0WbG+vdxv4uOs+TAjabbniC4yq5ldQ3zCRwsq6GNemSyH+fKWvi93QvwfaAF+zA/mHy29qw8hX4GUS631J88GpKdu8gkhaAGHD+TiCe0jc5T9im38BXtnb2WUqkz1xEjmv4Ton5XfJV1MGDYgXAGSp2Xs7oKudlAERPRdm8qrmh4JaOS8n+iEtafCs7c0gCMw78eteYt142lLPxoa6h5HiBfGNB9yfg4huPs3Jy2ms2ZmWurLz5l31Z/y/vf9wkpgJeGWf90argb66fAYA/8jYu3PJV1+C2fftGkTY9K90QJdNWrU/va/109iT+NOG2sDhuVQT/qefB2Q8IwsOYB6UTUksZtBNbsIAp8UXXOB+HW55r5vJ8xMCw6ZIbRCobRt7dMCC/ZX/KM6+C9+I1gbO7jVQuNF6tGrIwJFMmfBkpMH2d3sRU0bP0RPZv4Cy8rIyZVcxgI1pfTgli/Js3u2MgSfxufQ7O0WHOC7AAjed56xXALRueGUDKyGrAntGk89tbQlJlGiWHEB393CtSzrZ6X0hUmSzt9d/OmAYkeuoG4MQvr5Xj3cZzYCqYiV3EF9bUsh9PiAV1JFmC40ycvqWUYleyWIo4WatXbFbxthube7961BbiN5Zjv2fU4OX18GdVr2HHKMHfcGMBJz47+FNdzasJoJwmTEBwBMcA/tJwJS6jB8abfkyePjsOvwsrJKQJi0cLSvAbKtsuigCDP1i5dmBWV1MudGt068VdjeVjrG3Qlp809X9M820GkypfcbxzIoniERBka2JJqG2/Nu4T6EqpVaCWnb3WCoj+PYTOnbnSsFXncp4+L6uicIN6M552QqD4fbGFEd/AhgTxcYVSyPoefwY4/Mtco+rwbuXBLbCEOhBm6ZQQGgOGOgp3HS6/dfPYKl8RIQKIv2kiKPBIApVz2MfpMf8/fuTzoM6o1KtCwlQxr7qmTZpH7M9g5d5prTLeAb9IcTcYt17mGyvukfyutIYHW68YNTubmmeO+zhsHGpi3AvEJhRakRfLW/EYYp7q9BpcJNUTE0sISQ1W27a3K0ieY/R6ZmzsAUn0VqLoSV++HZg1ezBMJ8aAZ1eiViQNR7vxAYYtOKVSv33DjfLrJKAFOHNEgRkV7fMxf/84PZHka3ixqeh9vHtKm/wfIwn83H+2ek2OfEEj/Y1P4GII4AIAGMCgunbvh+C7P7uiI75XUnERJl1d55Oi0+IoNLoSC+gowO6irHIUjcGgQ8YQgdli8gRVT4h26GhAiZGz6CGtwhup6YCw7OOqJJHeuKpdauZCSOdyIFciU9N8yOPh7Uheuo+LFAINSesAD2k+iOmPZpUGtEvshA3rK+SdLEPqYsPNy6z+5Vlg/YzQioNcd139nzN4OfmXZJPATxM9w6f6TdxRuoofxaOSJ3W39uFDr931gf1AyqszDZXqJly6Hwm+ThI+GSlXN68uuVf2nv7Uwx8Mb7RJ9l9RsS5rFmNmwdYsdG7Dl3jWHM4eODEW0Lmfh8lNuiqcZlxwzORvZop3B+1hooy+4dhhsS9WKSw4XcL2oDFZu30EH8/4jp7IrEdoOyXyuwgHoq10Cz9DiGMkmxxXsoI9N5tz8TCdYf2N11MrwjvO+tMqssc7geg4Cmtsw5VNwHalrlWVkMJM4yUBoakmUFmdfzCGdh6/D33kpvJkxK+1eJoalRFY//NZr3dwSkkY3wALo+bgCBaxYdhTVpomY6R3pkVvFC5AJzjK/WPpj+jfMUu2DiKP75HUO4OY/GK90G91IkrFYLdiap70Mg2AiwIPKKkAfGhqY23hVipZxI+upXQSwG2fzHQx+QTaoT8jg+HxA8WChuWdAM5O7iLZbeu6q6mtGSHyk3hbQFPR8ogJqyBTrhQ8iJ+x9fx99Wxyy2luywHZwht3TrA9vQu2mN8sfpJOvzNs8YCIMrLBhMlFwfHe+Aq/W2Tw3l8fX3/IW9QeD3bfBC07WxYTnL11L7HEf69LPJAQqPVYMBkSs3aFRzOBe06MPFCcJfthu6tZr1xV3tRdQmXp+1CgABqhD0OJeWYsFn7v77LYAyy3HWCdNAhSTZI4H3IlT+skJ33UnXN+WIwSerfHcjeZIc1l8D2tw6en6mb35ZKqsB/IGUn3wH3BZoniFEhFt9v4pK3/Knu85JjN1roa3Ck0SqYFhB/IBrcwkN5EHObFktiIjrBgORXE08gBBqhWeU6GFVcNZCs8wNyxp27BYSX9kopeyNaRxMK7gF6dZU4WNReaCCOccHgzoAWPF2jHSE/q2yz+6gQ3kGHkXQK+Q6ETCOhSDccLeSjX853BON4Al2VPlwd8txmDPHkk1FRG2vCXOR8X0Ihr73j0geq+YrlioVg1Azl4o/8t7fEti9JmBogSv0/rqVtYzehF7DhpNCH4vG6uTf4MfsuLb+ipvQohXiPeIBKrGrjXvaP3PECAplImHUX+lXui7WqDnoApv6yax0TCmLeuPSkMV2jfu2KDS0+c82WIKx6/JW/0D3aYsQIyq/ZkPd9J4bov0t1T44ABjlKqgAb8plAjuRS/5SZUm6B2GaSZGdyQyiE++il9ey5WAIiH9tp90Lma55TJy08L2IdYMYuwXsOuJJAersbitHIJB19E8kIqJE5CYvJA37V0KU9QZtnW12zTG3OWlNUMkCcanVX+n9qYyhtJCQ7m8lWBHlKvN2ynxto5bYfut4/41DpNHD1yGbccqqZc7z38FAePU0CJZ5xpB1oX+qTKjvZ5U/Ng7rnHvSE3RgvxmartK1/avN/9sfZLTVLvj53v88CmSJ1IIEdyQQC8+n6ONWWcvWgvQ2gPbnegstQjY9J3uKaKTNosGZRFVs1/YLMZteESu+OxqleuhbvkCne2vugMk0cYTCaWqqnwXS0d/vY0gqzOBPa4DFB9OyeZr1kq5nMIAr5jGdeOB4LMWwdgKADyfoexSaRWsCl6xX4emwhGXPmQu3+neg3BkgJr14cH/WR6sj43thet0as6gADH66AQBsOnswwn4Lg77oVKqvT8oXLl+GBwPDj+eCTZFh0qMByNrsvrWj6zR85DHPn9aa56OQ3x9hC8VgeAUiuLldWyMw15o1XvyxR9XEXA+wtGVZ95uN6BIue24i2o/rmfWZ/MukwB+XZjuuEI/eQtzHiZIgIhv+QE/BUMXraxXK9RQeqpGfKKtsvdxvWENObJ3S/XVfY3w6gamp7jn1Ras9JuxjIoophdx2ULqw+4MDK0i0kx7hAiBlwBxzjRiPCbm/bAm9u15XMcGMZQLYKZEHi/slnXgfprQP6T1R7piAZHzUNp/mYSh05q0/QzJ62fkjeC5TgG/5ypwIW7PQEehh+KrTAvbd55uHGqk3+uzyx1mcR4VW4FM7OxdnzpgpW0emEXP9eIxbHNih5Ohep3qOOlLyOaRl51r8C1vJG1QHN9n+VeR80KXvFeTWwVxwoUYXHvLiMGnT2hjD5lg4E65FSU9vz3eOel8sZu4czdM1Lhs1J+k5ATu8r9zJuISWNiu2sD+BbXHtlwhLhXcY3qfekzz2eWjFdrZy+27TL9CzGAVyfIu4aBF7yB3lC8Scd25SYD9h5D6EDaRfprHxCbPNzU+0f+EBQfwgXAesf9BjWMPNN/9BW3+AQHwpLBwozB+jWg8pkWv8029uLI8o+1rJhZEQ0Vo8ZxPPqWfkxkZl+2wbPiPOHnLHN40BWOaFFRW2L1cv7+hOcVQdFJoVfLbogwur6L5zyspGawn2c4a+XSsm+IdPxmMbojTQCEUV7K2CzkqBZQfnW5m6sAu1hG4Es1TXH/CnBLq5HXxyssjwI7IkzKIy7EH8j02pkWLZI2g9BIUw/40nNjveo631tyCneG6iT5G95AnZLZGt6LsTI+BS6vT9KcELmaObb1z020TpHpW86WKsiC3pcotiR1yWUG6QMVFvbohd5kVm1t/N1pRmHmrXJo5SfQRNENCHz+gt7KOmNbHd5Bgp2kx/ms5SsAVNdsYhMRGZnHpy3UWLYN3NfBnbOQKy3NY3h88UBJCNEU/fk1pLsHnxn3S/Ar0LiKqRtgs7PPHxWCBfFOuSDxekyCF3oMFSnH7M9r1ZgSsqMdQHNe/dnnec2+J8s90PTrVFRvZV7DrZXr6iFUIZLB4m3PVP/jJaO+ItQavOW24aU30XMTz5e6Pi922TW9BF96goNxKNEA0enJoo841fJCetQXKztcjP9xmvrp3EIwkKpaJoyJ4FM3h01zvERfCzJf6dOFA//RfzbDA/Mcfkv/ND4GNoYWSmry349XNlEJ797X/2KhI9o7OdJCtmV0zs4I7HK6V67lRLvQB5I5qpzbQOKUvnPgv7B9qJKZ/Dljg/yOyTnZUbJ4/CuPGBDpzkJ+jh3ffFTAqIdGjU2xycaKUN8sz/4jn9qzXbFMrNw6T4GhoAQwOvG+j+qNcwBnLXksSTjYl/IC/LPJaq/rakcU8MXTqVSny763mCS8l3dHoLu6YD1h102eLi+Mp3gbeGDKebyh6YFT5bI+ldDHqErG/vbIuMKTDffJUtVxitYOz4k2e+WbCm5IP5a8bY0N/lcHdpIaqBRGKvmNSW8RoiJWT4J+NebjVs0RueJ0hLlm42+R/4KgpRAA1dWzk86TRXJX3oAzXeK0DMBZYQQcF5ecH92H6cswZI3/yGC/NUtId78Zb2rOy+nD7noxkWdI5P82BO/YQs56xPLrIKPKJ2b/YcGHGKRKj87KxgTKUJ1jx+pMz7A8fBIpzfDZzAqzKCIGUjK0+S5OpYQKvVRMgIsf/wkA11vr0NByHiF5BzR7uBD06Qgoncp25Wg1pqVwwSXvjxzGDpAYyqh9EmkdukYVG9svzqYWkz5H0ONcWIhQOGM/SPaRWkx07rDKZNpnvmpEnaSdN8dZ8RWd7zIOrKv90yhpmO0IbCUSXEplcixkm+e/iFE3xtLRD6gBw0lbDx38NQqsiCQ+/m7ylzMmcQNtOwxYgZBrb/FmYoLsmeejWScg0LWAAf7MXMLybusEhlW0sjaNl5nsFdHPGzpHEvYT2FECXDph++B7m3lLbPAi+SAiQ6C5jtMRWKJtI2xYKP04fetd2usssvKOMEDpV7aj4mYSZWoIeWnHo/UkFfuUZCeSKZMqEa8/Woi/W5K6k5Az9AFuJZ4ElXFhD7vNX4g1wFuAv18ifEyc7n3cmet2xzUMH5n+REi9hLC3nrPhEHar/bTBZDGg0bMj63LE6CTxfTm2+zjaiku7w8RHuz3bsHGnkPoT+5wE9EfuSKgeMip7Se7mPP0axsn58tL6pG3VpMpRj7IA5gVuZdbP2uZdW+d/hvGW4/B5iUhUCRC7nKZpYO8Gg0/8+HSJtGdpEXLpu954RDYVCjs3GtfttsP1LQxB2PJbrNtvDejNjYPbpNMTYrcx+n4H09V0XPnjBwWnpX5V/MvSSYprAGYboWKiZyzicHGEhc3YE6DAXUzVIV4yhy6WkvVvAy1NaDlXfzTlYIOdLUQmLMSv9ofsZJMRxxOpQ16eDO8RE6X6ZfsbJ4dUJiJFJVX/X2O3vFvqVBK1JFbw3guCFntKt3OcXZQN6kyOgle67Eln8Mw70nVExIGy+Em7WrxCR7OjHS6/yu/s/hCnkpgaMRhE0w7PKYSgAX5LNEFYL44pCPN0aELT1NGdp2mDzk+1k1f7yzHeB4Ge07W/WL57b1jFHpdNrjvgsybb7ooi82R/BOJ9Vw/isCzU2yCwZU6hM/HjjAdUeNqR0uXoa9eQ+CuFpz4zDEWTM7O/7NYy74Wsb5cVhW81TsAGG2rMetCdPYCB4h6t7J3XXNexq3xRvsCuQaYEgWvMk2Dg4bzBzyoxAUHMx76LJ83NrPin9AYKtYh+m4DLqdxsm1i2lR92uHjFTArb47nrCvuf8bRL+Yz67YDB/puObY4MOT0N6C9lZf39iaFSpZTkp7Iv1z9Etbpw6IDYTgUuXzwiX8t/e3EzKtGHkJYq5RulvZqc2xGLXxziksTX+qJ8IzzKXJLcpPyW+kN5dOQMj6Q6nwnEL6x3Tm90a8/LmrChmkzJEUDGiQNjAW90eD50SnjqHm1ReQlg203nX2cidXsl/SF41B2TlR+nGwFZt460wdtjrf6SXvzMyWnCxBxGEjxoORwdHLp/CCEzRhianJhPUiLgyPsxf3XZ7qDOQd9xLI1IErTnGpbXkF9SEdcvPJyySCuwd+KDLBy5RrUfeTN9YUdU6iT3eMK2Li5Mh0CPQX4ijVv6CfBAMQqOPTh8NDl/LGe7OKjq+9eLcZ07M+id/GlzhqLkrE+Y4G/emc42r4jD1vyCW2BO1Wpu/IUKikrdJPk44w1HayuqDtnHiUmfgOejBRg9ZHur6RSpcQgvLKfvPPXLfY2wMYF8TKdXmOwYD5ilScWvtZIOov2DUTvMBHhinfrHZAWIA+6c1/G5ty4IsNFXLyat79tJ/RPElF+54JfbOU8T/+w42XqwztyHvFqjmTnKoolAYHGVLEq1hXlfC+MYug+2dR6l1DwRdGAkhxGUjAiSMixFyRzTZCyvju+l+mzYRWYAam3zwoZpW1yVKzjtQK5tqHVqCTgrj94oqXGYSdUHz+qAU5+PKuQ9cH+hRokIVPIpLw3uRgiN042700H9oe6nDpp73aD2vi9PhM3CJQ8C9Kew/vEnPDtHrDUHFp8ToMIQ8dQPEuOo4J7FEJnNzoAf6XNdrbFUGeqrD9tFq7UTrZzvPca4KgqfIQCpTmAifGzGwrPTZB70wjqkOkDkdTotoJG+phKYftSlA67HCYj1+UBdqacJuzXCfjBR0u3Bfj9UeOqlfdzTkBaB0OEIPNUSs8+Omk3xpPTdj7YRP2zIw3K/0yME+/uZoW0CfoVi2B3APLU/CTlxZ8Ee5t0GLK1VjWIT6Rk5j+uKkkGubadO9VFmuSX21Cic/D4vhm+ZcCZbBPxp8lcKlBpgSdlC7TbuTPEAQd6/K87ayrS8EbuZspOr0bo+15jXn/TdOWHhDL0fXeV66uG6meRP4/VZ+XcUh9qXzQkpeeecm7t7GUtvJCV7TBn9QgBBT/zBLvWThOV2kq5ulDU0zrsBHfT8HYeNRhK6s5QVYIdSlQ/T4/bwAdp3qErYgXfvEF/U2vGbdemLksPU5S43f2WkAiE7+hJNPjG4SKLCtErnbAazh2G0kV8kNYuZy1PcGTqIrtrwf9528HVTNetl4cvHXNSzsJr/a0ngEerCPx2cUyzBCbRKGH86/LagClQ+H5Wy0g2SXcXdMZJJGO+1GUwrM9cvSRzv9WeeKTGikSwci0S73Z7sqg6XM7ulBnDR+ZRy0JVsXNiUplcYeqC4Jw8sThtiBKKlin33rtAI/d/U3PmAvqefhGfm6MUwh8FygiXkAc5QmSQQInPlabqrFXxavtcYvDCCAAfISi8sj/+2lazn1bzqFAady4s785QgSK2FuYGvvjzNLzYdFPfhtOLVCXMl13jhv+DC/oqFYJLtfEqwXAAYHSOKXQAIkbNW7cDb1jxkCsbgmf1aiJZKltFujVscDGtdQoilK88k01bsPvO3GxjFVk/UmOlEWhuRTa64MhJACjh0ZpMC2hs1jROY84cnmpjSF+KlRNgkiwmoGFshKV83zryKs2FFqb5QDmL0k806plwBxlmJ3nk/JPRQCla4RhCfum0RF73Wtf3s6FKwonvYsrnzParMW78rp3lrIWRE2p7ZFRMqlNHrG+e0j+G8c89wJmmaIGXBGaXS3K+YddWjilRZhUeUNB6VUbfbFXUgoD3GTNDEkakjpDkXRVM3vD3dGxl+MKHaTlp3cuCINozIiyf47M1KkGVpXRl6Ux2It4LD6ZvsKkNvzViEFZ/SmpCh5I8gccnfYYZUnWJ+RGgs57ONxZ3X8c/a+w1MAuuZjEVMyW7qhqs0BarKFez+4513mQxFYIq1hNmAGRWfsN4fF3TM/gXuuNjnU7WtyFA5tKXpWYTKGWcB2Kg6x2WmTxvwnzIC6MHwc4wKO+Ll7lTRlF6VU4zLM7JNMk76UMmikAQXdUiBmWkkybJtR8XR87Qk+726xUe9cTQIjED+9zw8ZqXazHuC+h+z+Vqc7Tii4+TfRo5JwiDCdRDqHuHDrP59L6VfxRfONrQ0gt8ciXyegTTOkMKrgkx32TgV5swhGjnp+kS/EfA4gBZtbjSOYm0zsqcPMSYvVsWA9jBXQ9fTU7TK8IvdVnOSQLab+z86HhyeMS4yn8BxUyTnHeoM/LUUUmbUamLMaMHrZ1ZxHJ68UGzalYQapdGJjJosHTL6evnhpmrh789ETZ7M7gibhABEhXmHF7EMfokjaDjr5wiZ9y8e8xdPIhMKz0ZRXOzn9NRjtM+x0O/rm5iNhZJI9a8nCenLe7QgkCCXX6yT1c1i+WdFHyEIB1vH3OjFL29RXFyavo8Z1Jw2BDHnQlsE/oHaAOvwGjYKPxEj+8nz/eDGV/APPDHkDKjN5I/LnH4AKQksS8wLYA/7rjYpZvaxsGYR7gIghKaeEG5kwuC53CLk23m6vbFJ4L2BiuPauvaYVHV3bCwZO1yi6DbBXARXadrg4F7AcA48BNEgxxHlhcXcztbwm+IKpx1vxaulaFlrnmLQyJtZ2DYAqLY53xob9ca7gqx2frXYZUFPvKdo7mD45yRsEZ+ChLVWUBnak1Eyt/1hSIYcrD38V9BxjoBsZHWUEO9MqZe1sIsOzMbCqu0Y8a3yYheBezUzdpOCU0T7RrHt+gPHy29RSbXQ498MDz26vp9DIcDqnVdxjLN+JPmGa/kruFsx6pDqUOp470RtpKLgaQzxX7vRSmhlYNcNrJ877SWsM3Xz+IJf3VNK8CcyBDzeyC9qY0wLFLvzA+YEdjAGMMOmxbg1Ua1XBdNqErIZfolzFRA1zsJ2UAnkb7S0whQgbCkt04/8Qf0hIb0qRqRggzRnXnFoza0KDYec/HVnbEG71PxN5xPGnKvGcXWwkofBR7MaHqW5GOb6HKl7jpcjiC9U5/UkuYj+sxC2FRQJByCOwtzbWlcX3KS93Abw5I7ubfKqD8APSCoLUN4Q2g2DvzPmR82zVBQcumvqAnRGrpr81IG5nabLdvUHtz9YFh2nBoyPApzNNHlYehp1RAz3Xh15PtbvHnA7p0Rs5scl3VDxvXeMGDrEVBDyYZ3iwSZEapZmJJAZAMPxWucYdXQkzasb1vBJIqsDIbwHAJuy/ir6Jp0V9jM4EUw7NOPOvt4/q7FlhvgMLga9z/4aOQdshRK2QMyHQC2Ivs18LV8CgHZjoSonKxPlyopbljtJOP5T8Ypq0li2r0OrBkEchlmqB+ipM+8it/nKigB6/toM7z0L0YGsdaj13x35+rT3tQ2meJJpuwYOBRdgOooF2+eR4KJZRz6YY9gG6J3tEemQ3QLOaxMeYk5N7FByhzNRGlkqn5+DQ2oJf4EwRkhEpCt8n/eLPj7wntq9aBdKIPzClnUsQ9M7C8tVsmpmONy+jEycBnugN4QfYUDwvBCN2OehMD2kjwnA5GXrl5ug/AvTe31MqryIA++Rm5VyVDDWVfk5k+bZXXr0wQRBw/ME2w81ybmTaOSLImmuaL9ViUAZEzwqHlXTaQ/jLTqJEeJKDcwir3uHHRTBBt5bSneo11q7dnqd5vAaYFIUPbVnwCkgHo8mQivIYgHDQLTdrVF3unKef8KQNz8AGa3uKyhQnkScG19iYhM2LvS+CiuOBKuek4l3NegbxAjSVC80Xh95Oj0C8x8EaKyR+vcHu75i6ApahAHxhdST6fJ0lBzvk/p4TugeVMsX6tOcpTVNbPEBUFDbA/UJcFL04YCJVfFOqLhdSOExrHNLc0o4Kv/QiE6vamVke9NbGmAlbL+sEa0yhMM0pHt5hqV21Qp/wacxj1nQUzALnSE6cjDI7KaxJKLCpX0VrrbjanDTFH9cd1OymaEuF/ANqBkZ194tHc8xUgyXK1Ou2h24GsIi10mrGkKla70cUHj1stbKKp1J/LjnGMwP7ybllp+1ipMl7Q3wl+WfKquhmXLP5hUZClKIMzy3XXKCYs7a3bYo8nSpfAhreKigO51/jg1WVWkdwvLNm2yLOXcQTtfO648CnnUpeHSVXsb340vwJlrlSmgOLzyj71qPglnJLDHy76m7+P9H5RcBze4JO5pFecD2RkoEAFHRkw1aNDQynium+6UBzyhTvfgRw7lMOJlKdzP+kpUwbSBXbNoK1zGkghnoJKIC3VvcmxWsDcxOMXGLa+Yy/gqfHyCB2F9GO/907hqQ14rOUGrzL86d6BEN62SLwKIBL2T+ubnzHg9VmgwmLa96XAlWBca0Yg5hsGKCQ50j+yGzAuC2Ug3HudwjsjDDV+lsGkSTzmSB+B9XdxH2BtAVXIZ04Wd0ZEClXvKfnLN5i9Ce/UO2VbH+nOidAfm1J0OTU3CdjLMrBKPAJxupM3DMxVUrWJ9pea3GJU/fgKE9Wv9giTfJunLQMg3u4U4RsdYYc0TWHNV1UUW66Dy5RrMIHy1b0vuKnSskoyruJBz3y/D5uTQpwgk2frCmWYDnjEuS7VFmfgZ3Md0r8NhTVlfDFIjSNU2xl/aRFkwo6/xRoLBG7hf0A9mYJgSFsqNgHVY/wReg7s6PeqRh5vXsMsdjWQlVz+FMXk9EUoigzi3X477Ymq7A0tOiwOa/73lDXkWfjD5zKzbMOGJRkBhr1FWtmBxIExBjwZFPEjxSl3HijUFObqIyHEfrxAjLAT6//3lpGdnjNJFTIv7dJEWqiGQwzYE7q/iTx9W532RWB7vgKD3cNITbg7hUIQ4o/Sg6HytjONPYAatOKFnKSmEWeTPX5BKuJ5QyfB+iJCXamLLRkC8+2Rru5pSSZHo71gRg3QKOHB5lGBV+Xg8Xw+qTTb2N2uDFeKatL8RMVAC/VAJy1/NTrrBQPfGazh6upcZdXojxlLIvFTIq2g96fLiHblCJiqdQFsbPDKXuu2xoi9uNykFbrxw5dTWg1f3Fdl/US9iBCT/MTLPsCD7DN/GEPGMMadQnvHb7QqosTPo/19m3VMebEcbVzg4RPEhb/aAoXtgS/j4N6RcyMXrEd3mKRrV9gmR1wFA7oZ45WYiGvT6SQc+yMR3Yi22mOwn7jIIjAUnydNzxXeb/Ue3Zd66SikUyMaV6eMfinHqAuypc2QjmhfaQcKIMc9rIuJ5ym8Y0cMzuYYMx0jnrpVZIyC6ZI/pNXtVGl+knRsQeXPa6KWKtp0E0eR/BVqef20IIfXIiVoLtRCfVKs8A7b1dzhFUic3C/zTPY68Sm8R7AvevHnuU8lnUi8dnUSaBQTNYdX2SLyZSRZ/L1a6pbGZHuJi27dyRahH4+5vcWjQL9cuwhiPBMPMV6M3wOlt0/m7Dg2IDRzz1FKneSxwyr8nyX0nWv3AwQs8mp/Z29cdM3ENjIpaUz9RMWPFtXOiVOWx9Ai3LJwL99ViTuxwYtTpdoA5KO2531DyBn5VKReRm2t+OzEvfB5jvxU66+rZ6RSb6I5KfE/zCAnxMcaqn8bm1x4SG3QPpvrt6Vx501MoAbh4ZYlXiDF9A3kWFSdBMCSki8iZIXJNFXK3t1uP71M/hhIzcSUZDO2Mtvrmem0RaKu2MeJRf+ULQJdTibw5V+Q5RV8+pl4SlmufkKapYVPY0qlgGepcM+eXjVuIaxZfj5R2cXGSxce7rQYLb+253RTQFO95AilEFLd7kMuW7EJai9Htf9c8xzliHQAAlUGC6OF8shUKuiJKC/1brdJdubJ7j0SEzfnV5/F316avBr88O4ueb8/hQ1twP24MyHGUf6Q92bcN6oU/f9fv1Bf6rtXv3jOjd9Tl1OTdIkZ6zGwyU0M7+8JLK3v3/WQd2Pg7ZgBCpw9BHUeFgyFTOkTZZOechqKFo0A6Mx8sc9DYvlDSbks0YG7Ob/87D2quKcM+soKIDP977zLc5Us7HhcBDUqdz0KZTJXofVHeoOBlG0lg+cCKwPEN7ZzYYSr31hjSFfvLYqfY0noZGzEiumPv6C/bl15BJ8f49b6ha3Sj8axlGXGEUdbFU12Is5PGXUzEhY3rrd0dJWIwpgvEZVBneIL3ewdkDE6SVvRry+Px3ILEecCU6WRHzlkmWCTzSn4ym+rjS+BP9eJfmEQJCx0vzSG+N37K4lbFBJmuIf4We3ONr8PxWm/+axIFQcyky2YxeYwQ9+YucIyTYoCxMk547lI9uXgyiS6seRwKLP4llfkHE+y7EJw/lAyN5wtUxyvWOAKUdGX3uysZvbSLjmq4aPyCl2xnz5EpvgIOAyMZYGarsULfPKHjgKVT1bGlk19z/RXPIOt2oNtzJ59PqdbNfPAVpfJ83/VmAc0xgtNT5uaDKKjry8Ro935RV4x5GCjAojrvh4i+VXzPTsnGUz/inWpEpWd8dhPAaXC1+zqtLeJmnoYDmY/6Pit1V7qRJP4g6no4XYVR30SWMJ6KcNwd+VbEreLlPKJ/tiL/NJeAgvq17JKJpsWcprzavScOO7HUj6dB448ohO44UNXpNrKJG3BYosH0pSyyxwVFQmZySAzAOCoJ7V0RUuQjIrHndXSrbGMwgaRWX230/w4r9m7MI/qG1SUXnGQCL1A80sR8Hu4Kk3IZSKs+M8LD9u/EHGSZqu5NVaCnvoAYAph23XGJfnFTcECEhkvJEkJcxsCcYleG+38eOnsRaezEinyZR2QNAtbb1RtHGpAv5tgk9WfF51Mms/9iBNJ88hMp7JiVXxxodvx2GFwio6lrv/dBlygLlwNPL1exXLGepv++i2fLT6nZEjC+FFMutQ9tmKCwUxhZ82sVgPTemiphXPs4AmPz1OmR4hEBDlW4oBIdcRANrfeJ2dIgUtnaoP4gic7XpjwdURsxciV820S20qfFlrgIVG3Hg6R625jA/AoA+Hg4p3RAcR/0csfBIxApadDaQTcXYQsD6IzWHZgcqzykzj5rjqnsGuGoNgq1KpeRoX4sARQ462t9uZAUd8CFc3+QqPpYYByZfhk7CEaWgd2dhRjMfKgtKiYrTfPxsN6sF1sWrB0k+6GhpZzwWL8Vsq8rEpwh2vDVARVIdUkJvn1br51RzN18N91dNxeI/JFtXCz9vbR6XJwHPk67Aeuis62Np9Ir12L3ifP1i0lti3wIRJh3Esa9p8cchyN91x3BgSuGoVBcGM+IX+tcW7uZb7srPNJvX4ezhSbZPsuOYJ3L6V84Fp2A1E0E4CzcWA6d+AC7bBDi77i6Ys+Lg5127N4jiB3D01r4r1oq+DjxDPySCBMsslBFawF0GDxDGLcZHjdI4T9sqdyF5vGgWlLylrDIL8D9ZELkadNVAwUCO+aLeA2UadgTFshraUiPTGkgW69e15TTdm2m132zLQPPlm3bV6fwRr6jT6CPbn+EsNld6nIpWIfHLmoA1ZjI6WTHe+PQl4mfr8GCObQ2lG4nsw763iSg3Zl60PTkm9jB3oxrc8eP49iE0TiWBSJZ+tJckFYxBOAp7H4IBa9aoMdB5KnSMOkHitIyXXO4XvC/jRKdaS5GAmSCs9MHklXgBkxRjuPAlVOkaHMfuWecgYyhq2EbaOehRd1P/RkANj8uwzpaH5rHOZzHH5Owni/+GwJopYKQDFsKPKKKqhQuHP0d/9iA2Mct3h5xg5iyb1DpL/ai/7dXNYOm5o3AIgc9/SHT573Q5lmUgz4vbHGFIsAzmuBwy+hpCv9OGSdCxXUGR7XxUwnp1ks/28dhmDi/EcupoB8ujuXfEA2TvF4v2w/KyvO5EqTJdd+qPoEAsC4CIBeZwgiNFSyvGUQo4vL6iL9uQoLdBaTWkftPbhTKwljBemkO78HGne7AE/weERVFCGpFCirH2sUIqTgKAd4ILRmwuR6daB0LJIfgVH/OS/iUtatEg2T+sZEzL1STIyEAuCNATV7IYSNEgv7KJwdq9m0gwhD0FC012iPqG1WwbeDJA9bahERsz2qroHC0C3rbyArkVGRGnAbDf60YSfoJzTyRVJovcYxkhnNlyIXev994AtjxvbSMn25jbcjRP5QKGwXiNtK0cAxaKTXXAphyQ3pCZuMiH52tZS/20GsCQNi4xl6p4mCLfhjCIHdVH83s294N60tbQXtw6lnh3ruUYi033g5mzohhaeCbNyO5akDki0Lm5dGHNQordx4P+Lulcjwfv5M6Ti9txu4BaWUGO1tmRw0BOG7zsf4+yd9FQLLb/LTVgMvWBtHa0ewzeSZlG0/qAE1YcuXxjNNL0fg/uJLr62af5EPK4ZbFqQbgNm0MI39E8l73Xg/FLWO7pqbhhhTH6ipFECL+R5TsIwWPVUiMf5phzCjBJ0Fyy9S5BKet8u2SWcBSMOxtg+11H+fxXFF4kQaRx8DNqnvTAAkjKfOhn7g8cMpDVI77vYbbSpATBEXaViZd/HK8hnxA2llhpFk4RCrwitjzDe1Y+aJDbG6iH5b/jrM4Iw5LtNyiTb/n+FWBoAoUfgDVs63fEtODbkYDoaeYBOuwBx4eTIaTNF4RXG5l7dXznpDkFLLS2yzDIL3j6nNw9i1teQWSSlHYfjgNpodz1s6iFriEIcgb/6Y9MY/13R5bAUkiqPP+8RMPlNC3MqLHEn8ACQUJWigmzdm98WpyCZ5AYUyi5swmK4RY2/aHCisC/s797cSWYtiLVS099l6dtQjltAAx2LYL/2gLFKiOtV6pl8Z8VwhoSPIAx4yVU3ZYUgEMByewFSSIy3OLJUpz1EAY6M/6cS/YSot+pWXBDWgMFNXUDFdhT8C6N/j/GL2YIgJ/zi/qJltQ0A51ZXl8+VXByqP7NuoOrDbLMBoLKpkkZpHHExUgmB22BNwH55uLdDqUYR+fgUeZYlhJU8fPAjG3CqZnSTouK5w9GfpvX+8bDGkVbMWUgTsI2DuUxPnqqtXthLACu1SRxvO7Y2D+tE+3JeBA6f+43kbz5vquAw6mmpssZbXgdhoEQ1n2tEM/8pplksSP/TP33S8WCyGWiRVBJKrydGdNMW4ToyOksIRkYGcAcgf01igs7IyetcMTnm9ne6KDD+sv2tUMjG2HL52UbXBsYKAQELyZTl8OP5oYZ/RoiEtHTEN4wqIyu05TxUDIk0cfEHiiLaNYS8CMEEMTm1RPB2A+OSYxuGVUegdO4pAzaiK0BYl2Lp/60R+aQalxtNRhuDDUr2jDmAch0ntnZ0gYRNLLTrcCXg01zfBiCuuOeXY6aLHukSnqwsDHth+MDRaxA0g/d0KQ5M27FtVF3KBE39hGrm7bAoIYzCsiZhEe4M9U9HSgzxPjNizbMIJXOWMaEglC9pLcT24KGaQUCFwfLlGlx4/P2+IK9ZiE2WtVNO6LFy3pDrO7DiSjaXU8ibyTOPw3oGsfL9V59+Fnj8COIc9+FJV3fFhDfAIOUFpQSRH4TxRtHamGyN5MzrVZWTrarn5T16WVScnlktLB71xIsAW3F1NqsySmaU5WW6CRSEbDik5S4yc1QvZUUsd4CBB8SSPae9sBTC+q+1M1qpnr5kh0Ij0/61L02M+NFCQe38Y4HUOelkG6DWsGeqRYeh493Oz654bfyg+O3PIwukWgmMfAtsZoeWs79JGG5hhHQjsj3rS+S+6eERBxS4GJ8VQNF4In/YuLaTphwbrPm5tF2cbW80opRpvU+eLC8k5hFwt8Q5YkLnEs3ChIPyoaqNZ0OKMascjuAnJn+e/oi4GJpQxfYoJW3HU75fWRaqTL1IdC1EBazC28JdQw04WAus8xyiYgTyE/pVJTcfbsd4YOH6vVPlZukSxEB/zK6ei5ZN9orHXeZcC3s+5KYiSacWSHcUAL1AvMKYND7zP54VhZWkdxZXx1wIarPtM8vACF+6gmBg53xcNBmo2aZiE4LbGLm0WLnllnmSvWP9w2ZF75ja/Oja/iU4fmJOPf4E30BdtymnHePAffLlnvC18F/nJe72mWLw06x90SmVyQe/NSn0e3kxPLUGxuP53N7OrMPUpXHH5VX6BDASyq/d4votl1JQ9ilNSbg0kJ0m1DH52xlxz9u9r/zusXNW2P6zXxnBbdgd4TVqfxkZyN3YJCJSnKgo6uSNujsA8qpQTSHvu/E07u9AYSML35AE+ADxFKvZXo9W+TU0UZ7fl7rkiG4qS/DJqVFL4wKuAkc2MIaDQOajEJj3brN27ojfomfDwl2YaSBn6M+KohnNtnuh0d1vzGlgqoRokiMpp0FUmt9ZxcYPc1rLcEAjMd2uz+Kr/3ELs4OjPxlx675lwohza+Z42hUUa0FNKbbONyWFBG8Iagt0nPMvowu+8q9ac3lbyacUG2BY4O0sj/VcYrCm+3kfZ8cuQ108X4SEZ8qczXwG5MTBQqnBncM4C+tNgVxbu8aCEXby6VWaHuRyll8YqZ5ItIIYIPH9qa9ped2D8atX4IeE9Lb86aNVpcLHWe/e+f+Fc7+37Aa55yPBzWN16qFPjkHbfYABpC7HJjYFOyzBokgFHaktBn7LMdcGN8DOHGtczZGX3tJk9QHg8+2touRSa1UBrVD+Zbj4Hsmv/teLIKWWnA8oZZd2z/dCC7umeUc5BThVMtOC0YIK6m7ctJmvtmyg358pG5Vx36RWxFQYV3/gBJ5aCUOu+e084zu8jfHiSAiV7PkcU7DRXrx0wDaDpj4AegHMy+DLBjeooJSe4ZohkV5OtzDj1+Mvje8bLpygwd1ackgd3KIPCfDBUnHxOob8iKUQGCeUBFEJGyIhOlT+XAMEu0UfTOynNrDzTbD6rwg4LPsn2pJ46UJpw2FSj8Aeuj/gCtc4i3MBgIwU3XGk+hSzpO5j5siOPXd/ADO4/QJ/W3bRLAR+PhcqeC6ICux7DiUV6lGAdrwTX3REKp81rpJxaTMakDNPCbGs45z4l7ZqFEuPLz/a1VcUQWpuqnqpFlR0o84Mq+aOGv6UeQR/gho/DrWD1EBvClaSMF7RmjH+CLzcd58D4ZlMeF2IUji5/FodIVWYxaKRkOHdEfAnQNjXXAX+RHgiFa7FneVvorA1yWsjHZsogtBRorC1m5aKpMCRToem5hOQ7DBG0MSpqB3GH6QX0UAbcf7hrZvbjSLEov9EPbOto6p00kuiljzGcF+svTrF2aieLKfeazAMdIZiR5XuRKHmAtYhaPjYF9bJKQbIOPNZ4uoyYiDmfWbLarpfqvqclzNVmpj1rFJbX8KvDHVieoox2srKi4uaJhJWvqdrk1HjyQ7c6DbUFrKWOetxDKq3oomH0KcviSjPEDbRmYz20yn2HzWvV54zHMUrt/ncBtiykTEdfZkTyoA+eFoLK8TqOCKugxSr9MF9ka9ytDk2EYRx64PNlRpJ6lnxNWk0NbUFzPIN2A+VH8qNHaVMSRcU3XKhToXl413jiDq1yimAw0EhCcXx4wSki9lZhkMRgDRUz/TUjGXjjYczCDDl1tKbx25JTH+KHd3Hepn7OIfE/j7+X5uM6rTfthoFZwU1OJW0NYABTbpTPhKvGT0Usjp3p13lLdOHTSDm/57uqrQzLnXUrzdjTYM3sqP9X9+McRGJxi9+zSPF5cNHPk4nPDWGrcbKGxkqKz/7WJGyyS3vo610Ul+C/JeezDa+J+E9O5m6BqWL5l+lrHIqiLlBmrHosm9EaI12DbbBWqt1aqSxedqvVSz+xS68TIIMJem3mdT2EiAkk4M2QlIdK7pjX3Kdf75rpinamoMAuVvgeIbM2QaTuz78efNpuPOruvacU/Xjpy2n71iYgCtu+u5stfQcrYwXJQLU0vyeYuHmhQXLbYw88Hwb5fR2na+BvlsdOrY3ksDWjwdFn2BZAaklN5lf8YhAxCDFdAVwWPjEFpHhJXWqQYYSKeTTN9/JEMg6Hq3Rw55CTzzLWA4byGqz2YyGJKNfgXFCwyBASj4LcAJ7W2RzxY9nGmQUCOI4b+VfN3AJw3KWVZVLA3zzwIBMwdnp0QfLoeDE3UrPD/yOf+apOHkXKCMFnKKVpjIipHfDcOjpMR0kcvCR7BODLqzyMg9VFSUUrZl/5agU5IMJ9kzmDM4NdpDe7dsM5RQfmGIF/zQP0kQwF/JdWtVGI4YdX5jfawMMJCAf4/iqv/6IfW2jAtThgl+W1uQ7fW14pvsBZg5sZe5lCtJ4Rk0zSCBGyuzIQpbld2uWsKTcTItFFQDshcII0CAo22wDv9Aym4qU8qtS2fJ0/FPEa9FKCU+7Q/7sBgQ46ROzc8BE+tiXO/JJX4mA1tIko9clxqp0aetNKnSWCfD/+XCwsoVXf0w9cHX0hYbO6eBNG2kAPTfc48DxCQI02v5uiG4TfPGIh4o6FLQIGDuQqZ7bfJ3IzCoaik7xtv6N9I0uOjecm04OZF7nIUK3WAZdhbefyPUCMYyxQ1XG7Jw/VI+4pd2YIl8SHrKNsATu6ONodSs06ZOSLjzNZZEDEGHdQv1YHIblRsDjPnAan/ZGZAKlHH6GRt0Ctml1I1qhD9uXM0GI//KClFSrSeRMkE8i2uCxHK7BO9BCTsbvBnAOvJ41J6TYjpboukGHwcQnNEyVPVfWCjoNWOgGBQKl0cBjRZjz/HP8noBcDVR3bJ2hiH+f5QU5a3/W1nwtRmNbuvpI87XmFDYn9+wePn9L76CixNAiMdMG5zIZNRhLgzwdyIxFoG0DDYVECDNg/KApH5QPgO74YUNJEc2z27vVjIoy4mbZk3pUKaIGpeNNaQGVo01lwoB+OKEm3T7QX2momY7Q/IzYb835wfgdgiqal6qRS739EAY2NBiqa8paK0bgV5bkZx43hflPPhR1WEOglkH2rVfMazuNeoa++JQSHUgPkv/KggWK1rAZ49OTP6Bo8hJxELFPZL1q+B3YGbjjxS9foY/qWeIIBQfVctSySmLdZ+b5dbFpPj2G6eF5Q/8/ptc8+tNyYkq6JCTgUFOHyRMW5JbWPg8tOdu6aWgtysoXhZBz2XGMkxppZ3/RD0IiBKMGHV0PqXlEdILq+yraP7krc98umvs7shegwcH/e2M95AIS9AvdiGhTK5vDS/MWg/3hRGKvGMQr7ibUCwjxEvOcHe834DPrMwHUZAmlHhYME1GupJveQR17O0JRsy52IJt3XNlkC3A3Rx6jsOXM5kEcf+96VASR/rXTiuaLTBftLDE2oodY/f9hB7dZB5c2uo9IO5OnuCeogt0yLQ3nPLPY9SUzETR+K/6i9hOZVX6t1jFc10+I3vY5xCDJ8saANzwxi1DrNDOZRQB7zmQtLoRZ4LBZ1BV87Fc2aeKQmdu0NNIkfbmn4GBJxhOJ5uOyBq4s1G3jb+hZrljxeeIFnNwLcqsMU11ofvBBXL91JsYkXiZc4QfGmHx5WPrhbJ8nVIt6ijdLeGWYPYOD2W+oWDVotALhRMhoifknfmSHWH5B8xBQXB5vkduxxn5iboHChF1yS1/Tzj1flMn1N0OVqTfVjThbGYkVmgeqEQiafnNSZYV5H3vdnnJphomw/tOpdTaasETllaif0n/HnjjE+127/DoshZ6+g40iFnX1jQZAg/hRyfavf+nC1yNidfAxVCN4RnC+TuF3bqZK3V6rJlEPQBwqBihARl4Rg8r1JmrAvbaN4VK++DfYwAI+86jdU/AaZu0jW87a0pm9yUHvAZZuB56j8OJRJ5adfZpuNaknaP5M0BpKgPQEeY9osd/ysMvQVSny19xCdE5G0kidj7l5SdEqRnOmaMoUbCz32LRmqq1CRhfceTmBrWrafZaMJACfPE0azLJVc4YAkjuuQ39A+Hu59XRs++Vu6b79o7Y/sKEeeNfqWJB4KoAnmrlZZ5We7b+NOkC2a03WrGJxWpRhjZkNpeY6trg1V0N0rNCjpu8uZBxkRo8gDQel2qyw0wiwEY+SeKmsVN7Jk8YS9gRtWeKew3QNygl8pHPxXqST3z8MgTzH/rdRM37rs2h9x/T9EnY3i6sNjFpRsTsbkSLrRVZ9TL60eQ4l87zogAOPeQI3G/XaxZbW1pyeFlV9tquM4XNXaHkWh++GJZfLYgiUrV/qrMXWVnzFoJT7o7axnvkvXlaDfzN3JTwabJJ6I4G4yDAFJQ3KDzsT10TUgthPlDLQOC6COGuwjbq4ehfkji++58wWZmkm4fAsg4Nw24QL9P3U73uXbl+KTaZG0MHuUdMe15WoIqaZ/fdyyzZAgXT7g/vy3q7elG98BM8pxOlswmEC8Pxu9IahRieAu8AA9+ybGBhdFrTCVmQspAw58akqFLjLLaPbZ9YNtiWZKnMwAoZ7T83CCqsZgtleoBAWTo6qb341iY5oYbFizP/s8iBsvv24wOEGjAnvrU48kUnbjO+E2mLW5rCnh6AHQGs98lxHFkqlb048H2/17ypLVmBnCRRmCV6qaJ1UE3mbyzGDuhtklmNbrfpE7qKykwbqdhD7ois27I7Mwl9xQfozffYzR4yvIaCjH6gqc1DaSvJ41FqMIy4ABMl+BFLaAB10TbtYNCxtZRMQNhHItZBYwaJsn8D8L10Ixw8gBhZeD3gQ3sttviXutBpzRguZByvT2kIvWxszGhmDD5nBxXq29tgoEbq9aWXqOLyAaI6tYKlUATJ4zzX+gJ8Hi9tY2/pVHa0xq5W01dpyinfsTtd6s4Ka5bGwUiHUzwM6HoA5TOl26vjxtQp1yySDVVftZmC+RGKDBxhHUrsLI9w7OHvtbzzy3j/mxCZBi9Ci0e3kZjuQuxqwpRTXo0S/uSe0/h679j8cHddgJhT/YKmyEa6ZXn8reowyzCA9LSyetWiIOvLvTwH2Lbi9e/OfUf9BJw8yfR08QpIQmhFEHdN29CTADzKUU8r5Fv3zCuPgHtjsfDfUx9oEZdS4Pl7B3SEts1KLnmshd/wiFGiwJoC35dy53yIyDQvK2M4VSvFO81RDWlE/1Js+5vdPXBXuK6hYYHPVgoSymdMW0LivOS/P05/lhOtmN1GEewEGlmvaI1+ldMeHzv1TqKovn939vsuD3Kgi4E4q7P81A5cM1gSGjQBr8XM+u70b2ZDoepr7uro7byVgbUkDGWwmXQo8nQXpEBTErfSYcT0LctcsoU4eK1X0KbpAm4l4jY057xuNbTCYH6K4ztS1Qqh33nIOlEyIOY0F3bIy6MYjzESjmb5jtEGqCHplcoqDuVEcORnVSG/esBOcFVDa9xOv1X+e8Iy7ibT2JbRTpnEal5wiukHvy4UFeQw/lx4M+ifOTeHpZtZntjCAQZuxYFWAHLs3Eb+5Zizngocp4gNSUaniPbljA7k/ugcSZdQPIJf67jyKHJwu6E/FO4h0hMhBIbnilwti6cqTBSoB4uyD45jl+a4qra3dDIwJfuYd7UiqU7sYh8Bsmy4sjnOFqjuKRtTkRY5RNTsJgoJmUd75uCwWWLE0jOth1eV//Ey1jPawxw2FuVK7CZ0e2CMapY11Yk4HMAAjVJflH6tHcD6FwYPtnD2sOqQljKPGPFXsE0o3T/EL2sDvZCpdBI5vYd/GM9jy3+XiCNbOomYfkKkxhOKUD8UGtMz2/pF2dXKC8dplYVN6yJZ93x+hqcZU/Bn8+N+t+IPqQh6QBEoj++3Dzt4dt/c3sRIUyEBib05R9W5TcsmskIZLTDEVLkFeKRh3OU/JSyV3NhkuMXOngom5zpJjWXR7T5sLC88FHidoJVindwIZ+4rckBqnf7B+y8lrXyxerMDfgV4wZw8uv2m17f8rq3NdAQ2TXC0tacPXbD+KVCZxsOpYQmlZ0lnYbwP25utcpkz8fESML3lSkfHfzVQWsEfRc3Z2JSaMnfnhWaiyRsiMwDWbpUifP0Kk9toYv+R7jZQ60H1BX2JjeAeEYLolRygnUuX4WSIcrgG1EDWvnjl0KAheIwKxZ1O1RIiufdPpjHXYmyqafxzj0IGrwf2ScDyRFe1DRbySmNUw3wbpySV3GVTt+gObD98oSfw4RjN/k6q357Td0Pb6cVlAoaIFtRjPVZFPSPJlKfc7QbHoxbb2JZe2x0mU5J9HiJDaOoT6ydIEo1dnS5q6fQlF407MROX0pzibDOAWJpOPsnbIZgtaM9PgqmxfEhb9/bI6gFWcao+8sKsrK53K4L1rhfQLTnRrg5Vs85KoG4OquVA3N61Dj0ze/vdrU1CXt3z6bfT7HD/IEw6HL8Zg1VkNGcMCik/ZmnvN37eARVngo9VKn5HwpbAfJQzOHu8aP7cK7LVuR/GobXbPFod7SjkF3hEM/rXJ2493BDOgCPUhAc0UbwPc/ukcGiV4uOBKVin75JIzguW+3nUCNzN/E0BlelSrrK4tyktjRO2eCzzED0t1OEAksqzdrXinh3ach78tN85PhvE3XnNT8T4RUzjb8wCk7ynZCLqtRLjtLBO1NiXKKSNjflWc96BDqYqbY7DC3ARAzIdKcVtQwtv0hl3VWtuze6SN8/y8UG6G0vl8yWBn1EbrysLo8VCwZGLtfMtJuwJdTKm955nCjbpZ3KJzkhgg2HXNcIEKEhp76sJb28A9E7/7xAxaJj62bdT+3QmQwZiv02pe4Uqz9XlFZNPsWSWsUP80ekKxyBlwV0Q+Y18orW1k3S+m70ZKOcWhu4FQcI3L0tuCnSSXkB7ZnL9RYl6zqQYzzt7yu3qD8g2yYXYP6VstKt23+zR0C1E4fteCE3t5QxMXxrYPId7Dn3KDlWHGgAbWy7ZC3DZuoPCTiVLv54GxQTx1TN47uAoZLLCpD3rRQ79EttVY313Op/4oXL5R4EmME5N7Klm3b7FcgWgY6+b7byNFIvPOZ4u1p5PNFBMSsOOE95kx5POzrN+vkwTqm5p5Q5tDM88986B4c2GoRgq2wUR98AdhhOjRNwXAt8AcqLvvdYLVeGgg4ZCnVoL60ue7z4DVVFzEDS0aIyrMpKd+8dTJ7aU1M6ZG0Ouk1jM4YAsVUMUKzbVG4J/FnKfq6Ekiqez4d9T+ne7ef4aDa+urjD6On/tAi8jmSQ7gipvcH7Q2ZQexLoBddaIkCVUhGLZM1kgxxrTi7X4sG3/8yOGMoswKYciIbRAUfNwVJv7xXn8SJnynd/kexCuIyECdYrNcRVes6jQbIq4IzwbABGQ2M4PLykPqZem00lwt4yHhp9ycsLOaXkp8Zdy4HFMZ1pNqe2qQl/XQvgR/iXVnS/CQ1EaR4N6JXBc4bCKOzmSzkZ3rauDdZAVcAKwUa7cGb15hk/+xJBjkVxNHVWpVEu9DCo0snBz3bbP30WQHTtlTEOIkBF7HGQ3QX77a3eM4viggcoutBzsPKlblcjzyUKeKmsvazpdlksY6EK1LyS+NgvX5r5tzJxKlTBTJFrejmUxZxOXRWukc0CCnpU2xmSq5142fnqjsbKtPktltv8RkH96BMPrdpxcuGsvidC9sj07vWTgY5JV2gouLeZAaEnJMXfXNwXYp8zRV9cadvjickVLnVcl5LBISdhyQQr8sY75MaOA+68gF7lro3PJtTcQXiZ7hb4yqZRQn6+kewwbGwbkFRCM3WxxU0RgIlHHFB/lfPcno6Vred2c3OyG2E4tLZOIAWzu/5XjD1vxnm+U+dw7WBR9qztl3/MDUv5IF2kVVptbAQC8pMxUgQRzRQ+eNAfMqRSUldjtwA7RjcvOzYM+ENIfkru9CZYiNnnCcsR0f9vRqx+3/aJoPYNXJapfl1qAybptQ/o5CayONE/NKz9//POOfVhS5ko1dFwQhjnMy3t2eF8/8OB0toXk1lLAt29lArwebSE1WaE0Agd/WcF1gwSbgI4peBWUlgZYSnrDtCxeBW7T+5NMvQL19VvG5XGvmqhlc0fmVqmAvOJHrpAoLqfNaLIq+fGv17rILH2ce6uRev+1iCBaPBJqTbJTscb/HCUoTC6iK5M5lOo3V2wMJiZWoeL+4J829SCPwcE6bx3qFR5biGvNQSmZNvRGDC67xJEteoo6hdzhKHQUXy70fpugoVfJofJiJLN/DwemgKRnmQ8pZQ6k2AQi/1SVWC30vRiwIP5BbGvFzejU2QnjfXHLXmhSch8EJBSkGDLXrR/NYDbI04vFpo+7UkLQhQn44Ivo7lrzBSHvWLwGLkHsDbv0NsreDMrFuNIdEeayeXtto++ekron5sBnzqcZmcsbkRT9txpUkZNw9ylBe4Ht2tvdcQdGOOzWYPoVt5sygU/xHp+O3F1VxogGHyKRVT6p+e4lcHnh/Un7tbsX01RvQVmsiQneq3kWX2TkJwkIX/qHgXfW01l3wLRkYZX2KKI3Td5EEDczaNLGH/HjyQIwHz57dJDTJqK0ClMpYNRiZFxHVYOHIhlq+7l0Mw/8443N4fDt2vTtdXmJ09GfYeFjVn8X2HeyV+QeBUszBr/lbZGEcxRpuMr8iPWMwD7eIUP/Iazmu1ZasY0sR9OcQHwK7CUbIV/UKAKCre2yqioodfgVf1iDoPyV3F6yGhkIX/EKC9O2u+yRBMX44RT0/xBSNYgkimE66SEwNETm0amjdyfomJZUgfwIgq6D4wHSzVDVPyKW5YPPLqq6jYMQ1Rid1zhZfC+n4n5jFe76kX1seJ3bYsCgPrfnaaWsVnNA0KxWZ2DW3DWx2Ac6R3wrHbu+51YBQwEwHsX3KHGdFU4cPhhRdhhnm46kU96TfXTINkpV0zsER6qo1N2raMHshEC7IkHbinGPzW8FwiUL0oIHJ6SWX/VBqEIfJPl+0BrTdzYr1qkVvuNi/Q4QuuizgwuLXq36ekS9t72bknGc2BeSXmZ5UzApKPfWFYX6liAb6kqyMrO0xUz5Ya0cLobvJ6WPk4HEutE9HEpnq3dUUjTB9eoLdyKEww45Xo8ji0jOvHEe2vJGUFf3YWBAm/WAr6hNfLZFeWm6a6XUP1NqesWoQ5gSogZBZ3/Uw6B1DHFF8cp4avx8Ou9rj4qZ9ITnoBmyWpCSuYPTb9Oapy4VFrYeI4diJ5R83V7z8lF3x824BOvlcluweChTiCPcCS+wVczT3YwW85mOYpYmfTna5wdRXagCXPZDShKYjgguJdk7sFrKRfDKXTM0NZ0wmgZT3ZOLz1joxsQyJIzaTi2ybfBjt/vPoUrYuiAsv/ZBWSuwH2p1Spa9VEnqjGJdPNm114JU/PNu5IkfR8vm80PDgNFnowKmXagEAR4U04lE14YwXxs9d4PCOtwIalE/moyUulzlbwv2ddwcjWTE1lUCJzSZK+pibNkR8HGSTSnGa4RDq5hebkh7zkqB1hMrs6vzJidsUoLsfU8LsWcRbyf2/40e7TX2ZJFdSazXP35gtxH5ZH53pzh/M/MKeHWpxufg3F+CrL7MTe4saKfS7UzbymWVWFrC6fLP/YtNg/u0pHz2yvQiPjXwAodnWCS0AdT+s81J6yKtzQLXG+7DfovujIR79HMjyTLKcDR9Jyip94dx4psgKqbBHAE0Gnr64biBTbSIIZoId3hy52eEgvq9Ge0G0ts/tzKSq0GIwkGdtrGhj/fhds8O+dm94G8B/L44xvCjReBpAike53hWlKfOu0Sje1SHKtrbWb9dc3gZVzcErE+JnScZ9wb7iVnL1EYTZXtZgeaTmf9qj09fNj1sJUmLjcBOPIDNLd+yt3+yfUn0I8EProfiXiYoAJosrAE2JjGXqNzcR/7+3y5Y0dyx23z2YECR87MfavWlJiwXnCg5OXfxsXyvNTDg0IBJae600NzvViG2sGM2Yo2FlIRu3KKCRfMR8AUpArMbdGdECW7TEe0BuAfTQV9g5djofxqah5EitsZCy/QTI4ns5x9BwJoi2zEVmCNLRmMK70jGgaaqukq2ug1jojSqF8++P8gCuOe3WIAARH5OYlxviFqMN4gfY2jbCkoqINPF2YGlQ+5pWxbCT86jh7uPgvUs42B4hDh3WNU91LKzLS1S499/Zg0XDp3jLQebIa/+q9WM5ezZkA+8OlOSHWhCCrxR2RN3gowawfbUSguDY2c1t1zBg4C1QftRSqj8LzTqxn21KFoR4FQ5yIIpUQ2FNPoysTraGyxLH1NPnBOBpk5zPSEXcLlIZlvXaTPkEsq44SZV3Z+7eo0V8fmzfvdbQCIiPZO4HEPW+YDrSRs+3vSOjrGDgsTllPMP5C/hHpS//hEHokbRfAe6XX54ck4iIxby3RBxl4hq+Sosv/kduV9uUwVR586TiVYMLGweTN1gyXHmZQ1j/IRIl6C7GV1xdw2mRQ26+Qprah0vqYVtWXmmGRuvHOtdiQwDpLk8pPMOTX/tUkRWTdoS1AU0WbYSHdbwK88DC66qPqIdP8BNS0H2B3V8n2dxapweE1+AQs4xNwa5K7zGIaTINPY5T7ZpqI/xvTB/644YXrhXHe8xiDgkxXetQxoRnZfvGUDPp+Ty8XiGIQlSUR7X+uRPyFMD53K59Ny0VZ0kjKksXxiWrT1cAbxvUW8wp90rOuF39r5LXHfFaaEKhItffxbiGYAZaVWzsUlI6xSYsuXFC+qk1T8F5E1zhJnEX7cywZoVTlPldn2LnPav5ZmITxkq9S8GSxLT1V056h4g7ZkGg///eRf9HCOO89Shw9uAksnJIECmOnwha+PoZgJS2PSDTaLq6vyKf6PekLookDlNUAN8jQR7Ll62tvIP6/k/Ws0E+nC/f6QbsHgaxvpie82pIXqA+R7KadQkxiwMg7AfqPNYpZupwFDGmN8LN1niuRKcI7VYfP3GLba2oi1M7FaPC/y6C4tSBmf0QeZwQxeXVlBOdL/DyQJvZvg1qhzkba725NEqW9IwoaVU1sKi+eu8ry9vMja21ox+X7ClKc/XVfo5uKwTxJKQn7yZ6PQxdWdMWri5WfOxLvcZX7ZYos0uQ8olDRYyuE2m/SP04hra0Yv4wJfnmxkYrCzh+dFsXMEu15V06r7fwwjS/YxNz5jsK1Uf1i4QRNHgmgqCJ5aiwJNWTueiU9qLK/q9bETrBq9FiE1M3lSCybPeCHLUUcFoLqfAmSiEDf8PxIQ3wX1VngSiq3GZ80ESdAep0f6DjxuBK75HVFu/FyAal90lgJn0tMjyGBdKW0LE3Jdb4SQO79kPu9rp0flfuE5NoZzUnkzOG5G1dxAQtxTWkV7CFz1flPIRvXqVdWTA0lkyQI7DKr4du/WS0KWV+c07uYOwglwutAkvcfx7JQhNB1kwrtOfD2CYV0FouuaVnw4qWxt5+h26roWl8P5u3D4PwBFr7kL951zVVEZ9F0TpC+WEYHw/lEETtwcO+CJp0HzSVomVB1qvPeuhwfE6YZ9uHr0AY5ZbnbxNV7wbXoWyaNfMsAra7bNbrovWyct/a8WNPHwEzRMLxMjOlQxLWS+PAFk+iMICV2+rezSv5nyHL7aW/R2SCy95T1l0tAR5cJefRUNkrsbt0bKLdRUoHQ4Xp0kNZ6qR6pdKVnGvr4y1pB//7YDyQPayurDvIpZX2KBRxHv2uafLqHPipYsTIgbgLJl/jTh6GXHd5KbMr97+NxGZu8Zx2RIiqxdyADfgRNpnfDsr+It0vzEEyWKZIgmwXs1tYcMTgSbIlgfcFcI+Zq04ki8oBTQlvmUi7MsIuljxsVJCP+vcrAoXHhx8GaHagfopFFot9/AOnKH2Crnmg5rc30Bo2Ctb/c+ymOh0GzWNtAXBs3yih6i/HqHHoJlOAkiYp8f3lDmN3sZCl8QKxoUncmxMAOfOUYLIHXwz4OLDaRAZ1Mc2kltI90ejYUvxq/47ayFAFRzZcqJCQ0expFQJNsemuSa4IeAQdpTYkvSSM+ZNMEQE/W66IBha68cgOHc2OntIdISslzybOXxBwLtcprPEuoZMi2Dlzths59P132Sm9BOr2zGFKbp4eY380jOmwzUg+KcmB1dhXSxrC6qc9hQn55x4bFjpPBe59ATEDv4ohP7rWYfQWcY0dTWlkTjdQaEBxvlVbnPK0kGTNN4qQtWC15yokHZrvy6JtuxzkUJ5YQWWA7H1YAHbK6oxjsal00TuIswRe6Cs4J5MBSGSXr0cU3H2QcBu9fsGmQruEnh16pNmTOj4rMtLazl5hIz3CVPh+XUUUcBxmnagtuXm3LPfSQ3/L2SVrFn+XDh5D1KfTH9iRR3B6R0r/p/cigFAHLvTH+qf77a3OIfUxaPfPJfaDaBOWm31Hx73LwawnN6YDfMdqYmhuxHXTwdlI/O2LKpay6GkboUp7hjRQdrnboygvfxK9MMdSEVaVAXVj1p2jEGBjagrWXJhtSJKaNjoYUTN4yJImAj6Y5uLq1n7qWinQALjjI6tvBN0Bs41Jk3zRIZ5PN7xzIt0BOnCk+Bi1L6bJdQXm2mu+Qemn+6q3tPuyesso0FE5MFn78BjaykNBVntkoNuLev5F2fG2NzMs6npFHXQs1eFkfDgFeduu+AfCPwAULLPAomjUbSXCHvfxRajuhPTmLRCCC7XQxh4jeK/9igOiu6g0I4k0xhk5j4W1MruMcsPpNPwZlwbnouoOakVCGEBVHOBNpjsoZmnkYjYlDn4sP51tmJ3I9WDByAw+SJ/Ua17cSnMxAap4uajsG5KbrdgVGbj2bV+Mhjwrtex9vg5WCv+iKzbyegmUx5m96nKyKQPpk5ed56j21IRT0XQZjB7eNg1I4b4qu6DwF9XBDhgC1a3jR+2zlbPDVU5cvrzlKo0vgAmgWdtWJmj7Ir+Dfl6w8f1BeoDOIzbFHspQmI5EhA2iIP4nY09umnsY/NEutrqFCga3ZAbGIbFIZWb3ZQH2vTphOqmRlhzGZnBOWyWX8Ny1l7t24tDDbeBfq2V8bHlN+wlr1EZCOJzslSN64pCnNo1993TDgZXNKkg/wWWBr+aqqF+OhS38+UMwm/FL9vdLQ29Lc+FZLD0OrDUrsX6VvWVkHhbbsooiWZICVBsUosdvvtsXOeoZs3YF2BLB7nfvEy5D5CzFiOURH4+LpKDe6yEnOrEm/HB0tm+V0ta8MW7n8svU0M8p60hs31Lgel2htwgdTpHB55lg1UK9/q6scC4wDCxYvGhVSOlZdeoHbewFjENyQjqJsumV0glOxvequys9p9UYfFcK71qQM2tL80zitQC6QAg6TFDWIKCzQjT2x1UMtwLrQFT0Okhjd0A/qN5p8c8f5nEl78qaovksVH5z2N3S9Yx7pIABkvvDgE2moGoa48JXUYKyQj48GvJ/jKto4TBxM/sWWH9Sr7Y4XgRGt0qLAtmr+g3+bWZT7vHGYybT4C2PIekE8y6LEVUXFrn/SLHVfXK4mNX7ydRxPcl+3fXzNIq/3ciDh9Yvo8E5eOPN0E8W5FdmGdetalsg9XWBTMRE28GOuTVE+MdmC9uBky+B/H91CDZ2oxcn6a8UZrWBcxQ+SgGqdUhZcBq3YGHGizmzbbt02JHOEKP00cHwcUbIGg+Qu0fUQsSOMSrLQvPh0rHr+uB2HCelMCFFmmubPNtyd57Of16AlzBSS7dLTm8AKrudhOm3SkhnKnx2b3VqPJzAuQICBYcdbW2+ng8f8QLXXB5WTP7NZfuzZU6UwHP/MUI1HnL5q7SlapsWJhqMgA4WFG1WezshDo/iiwWJliV+feK+iecZUN1eV+kDMwIo16vtHeg7qFpyO/gZeGt2n4tuznqpdlw95jnd8HUk2j/sylg9b0bVdPEUO+GCrKbDVTEQ1z6nq4kmaEtUV4CDoCuR+3wkB8q1X66TWbs2MG5uefVqM8mLO4a1904QwtxGRzW74IQTvybIqC2NaxqkPJqRhADcWGn4RnjOnj5wd77Iu9suOXkweioqixysoQsgjnQMW3OsjsK2LSQF0a0hiakNw9gZammGcdruF+P5JpX566mlCY/uAD0Pu6k7X28fYb1kbt/DlgRJ/VABELzUwCfsDb4FYlTallLxtEbsAb3I8Jw5J6gY+C3SFqG52CWbSx/gEiAqX77FKc4MdYhfglgFY7+O1CDkQph0/Ph6lNiMl/FGEMPV9RVNEVzm/YKE8qiPNyUc6hwduoQz/KsUkjRSfbaFuNFcpAFEHHuFjk3xHEUnCdL2vvdVEmBNqlusFt1uowzsqcZVg/VORzxVEpcoybxq2yRxlULcg2QbbG3LWnd53pfswufgUn9mXm32gHtjoO65a7fJpEpXoRnTXypCB0IiFOG3IqRJxW9TDW+sMLbwtxaxY9XxrpdJdqIULBzZgAFCoGEqme0JWCMC/DYiq/t4RYtSBffofwzv/96zhghFQFIAzkUW8xxwedTBTOlWDUpGEN/qIv79KDY9AXvbMMlNNi/k4zhMUAivMPyBwPjuWW71X/vxExAwpe9xKtUhrGHB4wWD+hySCrZBhLxPDLcqVZwfPPU+NdWaBeGPWyC1ixGoAPnVF9TmdR6xHbp3zwp2oIlX7c+ZxNHd2puLcLUV6QASxX3+/LEbGsrDcAzBnJhkFmG3+BWAMn5KOxZ4/aKpAfWfxb++2oN8VeeISWcj2bsPPTuDIWHUwaAbaDb+6qHl9/WqETLz6oWMBUb0KAoHJohVueJ5HBpCFdlbFa+kKP/OomtppVqyS3n+ykdXNWD8HGCm5W76QkwII6yq+KwWCLRlKzXrUyfrPIziHlG/DtId/wdffkkb52Y3vyrZsBWBIuYXu6dH7Tr/REOjLZ4ZVTsvfZUcAv7RXdPB4Q1MNCqRyt3pHGHrgUUtXGZtqvvUsTr9E2kkZjPF5+dtXsrHiSU9dk8pgYloW4U/OgKHVdSChvuKwzKYttJ5Szc++GiHL7Iuhm0+opMuS0Pedt2oBBjWwAHBYpgl3B8yKRa7gZUuL5unJJAr9HkFPvfyia5D9xl8Es+9cbwJxq+Xpl7uJIdN1aHdvKhEYyBGw9O3mOtXWYCqg/tnZg+vNgkDIuGO2ORTLRI9XA1dhuPdxnAYPsZhy80Yv2TWoJeNZihiDZPaCDD0kVfjAcrKb41LE88e4JkPvADSZFqqhydhNM6/VkvCYZpCdFNCS+xnDLm6HJkSe+0JlO5JuAZFjZTICVB0+tyzHpfgrzdvOIsn0Ur1L/bvpioELozKhIAH6eiKJLXv9CR3xY/p46nxBnbfd8KdYCconqkTr90MU5nzfj/Pf4YMuSN2HyGdQ8aFN3LvwC+QJl7Jf+gG+BHCub9RatSndBte6aKMMFReZtsJYICefi3BeOm9ssfz5moUf2b2L12w2YZ91yP19D7yCrNuefUJEOhjT6B0PmTpYNe5WXTk7bRcHe4X9EmfMwg68PQ5NjCszWcPYyeTHYPUU5U+DKxO2w6tkQhdzdWTEY7OGhEsOq7h12Clt8GGtRJZ+8Kv++howK6sAUb+mj91HETvSmyPFxCAOudi2vG5IhBxSnSxTflrB+/S95a5XYShWeYGatKNh50rvpq52jLXVAZP1IReDatChBjMkICvouwx2ieAZt9nEIpfxtkU0LoSEOwsdZ1PrPuxMXxwPxmbdjJA6AIy5EOB6fOEqRNbNR55sv2gVojqwr0ASdPVhXP4vOIZ/FOw6jltuOUXbggTs/uAoxJWwd3PkvYtM0xtFttSYPi99xa2uL3EGso9LWgbMFfh6bS2NCTmak+erDPiQkntmmgcOiBE1rREFmgkTMfqJ/Fs0+V6Wi73kRVwge2uX81GGZwcoEPV2SJiZ7KXHBg/FetITG9GlxPZcLeXn3e8OZlnkHhEyCOwi9zAGGcCaus7vpnHoosfOjhfhvA/qrU3tKNP1mU93bk1+jsS1VEH+cA5/6eVXUlgsqZt+AbQ71GZ+sMPRoPj1ISeSvbtF8ypv1Xkj4K/XOcUZUfMpoB2Z6oHizr1clXOi2jlC9vQVYHIuhlHNJnZ0zlyk8GBVe6fIjeR2YhAprT6c+NTzRsh57CBeFrlyQJUZinYL30kWvaTfXR/eyfPhNjaSN1VIF1JGz2t7XXPTWR9neX1o4CdBaeVTKCrXF465vbD++/nfhS0u6D/0nCcA8Wwb6mZ+sFYE5pfzTDvC7RWoJHVemq/Mj35XcNx+I9Rq6/zNHz/PDJWEivXfgbu3vu+l1VXIZ/rwpG5gx/cxwtmOjq5GjT4q7jRD+E3cOsA8n1j9593hQZn4cIhyznw1SMLBDd16dBEi1QW1PEt8tzIVC2varhkGpNdNAhhsQ7El/ChMAIoXUF1SPCflFj+p/oVB4KRPME+Ze6fNTV+3g2myDl3gcgFq6lDZeOc8Zw3rR4ou/FRjkloc3r841KSBCyS5Zycu9Pz8pdM8Pf5LVKczluxAC9rqB6xBkZgcBcDQIAxyiyLozH2PgnWSJeiSnxNiKsXQKh14/hEwssU2sKvv7FE6W8RMEi/cgy8pt2DLGAPKENhT/TrZtZufq6vHatR4i/LUfGWHp1hlKJX4sCZzOuYQ0xRXtrcshdj4Tx0P4l+NtwHTg/LjBMtayNFHPYmb1zXVRAjtnk3XPibEovCwFQR3glAmL7p7+p9VvfxMhMT/YnE8dRBqqCCzdiyVATX2ZKIMSMXxnSiwiLeOv5YaKGyj0SJhk+BQ3uQ9uP0SFiSZPElKknmqQA5I0J5zsJMEwMh5QtkE6tS4Dek8YeOnTwr1+sabd3OPhRA/OQuQrlPR2HiX0vRzFZVGezrdfeP1Er/o18viS5k1IbQcMtVWY9nhg1A0SjQ/9T8Y46nNTTDYTCDFTpyiBlDEe/LOsAuMpDcPf5VWmUY8E5MNUAC724azjj/vBRylznF9AHKGCraA3Rk1KyhKxWmkXEeumxO8bbaHUGzboSG5EkCCY4YGK/HQTM48AHnocBQ+lD0nnqMN88TTOUaLH80pofV1ID1cnlGk+qZDTdYO4hnBg+OjkTChbgEvCd0GnqRXK1K/7r5J4ecsjTXh2xmJQG89UXUtnALfrUBiVOwU/VXFaV2ZKtzyTX1Eplkjx+QXjikNgtG9TLEfKF1Mi6LwZv6ccpof8cavWxxg78z6WbB7we2vf9q62DcgbvGQas2gyVbZhs4Ak6++cZ469fASml+ELBr9m14TUs6RpVTuTYuJiPv3+4lAZjfWCTplTGx0PBfe+KsSN/cnr9wGAaTznJxbkd16pLb0WBvjvpHLzrY2skOTEYIzL+FciHK3MCtUvCjo/HnCkQAC5ki3F0EENmicJlVe6etJqELsJ3f4GqruM6dMJpB62N2ckv1Z0v60nzda3SdFjF+TLDGizKgV9EWTqf4NgB0AnGXHjSchs/wGM9FTIG7cKzuYorZo0+SqtlDXc8lKTl1p+AIc8BFUOOZmNW9M56VATb4x4zxjNjFqsTjCwREVU+c1ps/MUKvmCdxA577ws4+kiPG5L0rs4mCEsc6BRfJUUbX21FWCmJxfqGf75/ZGVyaCnTZuFQ7mUmU4TkVecLawpwUMq93xPIy7oEBgeDbZQuU0n0lReaKIZ2jcLyzritzLB2PHvtg6gyB6KQ/jAlgtZSPmNol/NWtM+ttt0EhqvRprwbAFZWa/YirP+JeRdR0n5sVNaD3Y5bhe5rV9dP6X9BLmOHpzf2rhRk6GwnzFCA5lJI2Vmr6tJCvLxS0wbxWqXzABuAsu1J9ME2T7kVFa2zBfQ5T/F0yDPTknViB0ZLGWG0/VNeKcKwq6tBC+m7/9yxDKTSGsNU8vGSWbWkUVqCoJAluLQpwv1IKX8T5me8iZfrwAZyGUS1E5/LQsjLwaidt59xq1SLlhPdbNV2tgQpXEF8S6kB9Z7NLHMU4MOHTNtkmGO+8eqykIfZvGQgnWTxYXPuyVgtmUXYLQtB4I4zBS+j67TBCdqtqEecZsIyqT47GPlj/7+In8fgwA8qEd9A6nc4icl5GVQdtVMXBD9kun9D72cCfVy/1TPpr01Qh36VRTqZIrWFAcGxSMoLIL9yJEOZuSqk7fbGmYmPwyJn4pb9Svhp9nCwMT2fQrPzj7ewloNrzLGgvsMzA+kSfSgO1AksUa/h1W9F3h20Yxase3royxWCFVsJOk6QrQTc9XxQKWYo+CgrL4mrC84RmVUPz9IxgTAG6zqJZ/J5XU/EdFmBTmn0la5rZAgANWPwIq+rHF823+Cr+ie4pg7oP+UetmIVjGwE8FryaKlDqrm4EXWrCmka5f5Wjz4e6qCjyuN0Ymqszc/zwo+UEmKdONPLjdTwsioXqK9J4aVUaI8Ax/mVinOUfjUMo+INyDWAu0dUno7KimMuVNEi9y/gsBPrAa4zWamrw0D21YKEgN4rxz45eyBsPcOmik/MTKEyvlwRbVGQmC8UG0jcya8RMx9K2tfeNUYYcQtHEY5AoAkvHHyavlRzmC+cLSLiZ/9TQZjya1b/f6Wd1PyPrMo0AMtCuGoR40ZG3ENJxk1KsUKuMYBLNTwN4AYHYZjE1teCEqT16ghj1kq9AFGtUUd4mY9ke7kgmfNAcdjw2YGdTIpNdcGacaXkZycaPdwh6ZFD+Y9ryaa+1ejz5D6O7bTv5OOreWHFevf84hs9jfj72jqUhvLvrOBzD9TKHvb4JX8MaiEA1Vqw6duytgjLaSyYqI4LdnDGzo2h45lkmW866Iqw5P84IQJt1FKibnDYW/k0ALUq8SIKzSguqzL3g+DKnzLtX0KjUVgL9gtfIEpOR5tQ60EjHbvctj4SDkLjbXL3uv4GUbz+Hjk1feTqfdbkrrsX8XYo37r/BqDQkOY0fvJMqDDESrqOQV4hEXl80Lu7P5QNVMN+59tvo47ZDaQo9qRERNxSu3wAvTX6C1TeG/hP9YevBAcsaVtVRkRToxPc/CyrNvPbuPhj1iU8XKCbnNPGurGSPZksNg3VyJpwaaBVMVT3izihax7VTqjDr97drZxmjjK3VWsaG1rWGqpIUwjhYv48/6gA6Uc3IoMNF1nc+H01QHHzj2Zysw+yT6jHPsMFIfo/qSk7MBbSCg/Takc7WujCwpcPAFgM14MST7DwTpDli6rkrsOr9Hrwz39Gc6DOeJeZz+gNwkCusz1kRMgON1nweHjQpzrXMRaVm4AALt0919EDv2h9MZd1il65Uotx6qmBtB/UIIGYOMv7d3iqCsRxAi3Dr/2A0uP9vm5PVEe3HGxNQ2TeoegZ8A0Xz/Oh2cdYrfTTPji9sMGw4Yea8Avu63ANjMnuyV+oQS+Ea8hxq4VHJKm+RZJRafggVWBR+Zwk8m8R9KX7Yf64RMmkzqonW4WF13KUThO/upFTUdC5epW5mmwEiim1KVf4wOjfIWHyYqKbFdG43BI8/gmiB5ddEa//cxSL4PFTKvOFMSqxGMcbwhTOCY2ULeJmLOY7KG/eoLoUYAWDwh/+Nvu7yMfd2Um8AjqkUAYtMSb6SZX8tC273Ka+n3ftYSjvgxGAQVOvY7qLWtcdXVZrluoZTKKhw7NWdh+9I/C5RGsWO2ZfVTpJeQ2aP6FxqBQT2lesvnl73/BszZnQX1MnlQim9TFVkfaFGvJJBsQNV+WxWjcPJdOU/3MRbETbpHoATta043tn9dnBqayelAtlnyVUelPN6wYUJOFpOkwbdoCK6HcSwU0c7rwjUksFIeAURJdukLBgcqOJT3TrIqF3Yhg2iYJ4srxKDY32pQHlqnkqLZIhMDZfFhs7xE7hyOUoyVd30YU67DHxtRG4FmG5e9Ia7flJ+Vgh/pauua3Wfyoc1F6e0nK8HbWkFcMyIOjzbAyrKOlAsDay1v7GAupJqZqg1SdbQ4KD/FFHJdopMzTt9gUK3nGNSKTfaHe2qNxtgGB99/aLnlFhd4MeUYuBnSXi8t5Ef/ibQEGNw0/zVPCmAj3doogMINdWaqvPSEd/B6j8x1dntUsvdZaEAF5SjKkAmG8yV+mQgNDQfbPUhnSCwRBsS4jCBThqQnW8/BnJv/X+ECM+aSaYpDP8Decln2NeclXlzC7ag4c2iYBLDbo6/lQ/7rxJEPM+5QmVsGZ8jferUpCzMjieSSt+tDwevL8xF/hkv/OuAm3hgRuA6crqdeUIGc8/4hHqkjV9iaqxmP9KgpYsFw4lFs5sZzGBPRy27cwesUrP1meVXMYFEALC+14ZSELt9Mbxm8pOhn/DLetNYD/fbmsrVsXrXV5Deo6gzH0fH2WbfbDnRPPD/rF7/h7KdsERvOfYWD2UI3DgOLrcLA4nL4MgWPptE+p/Qdlwt+7cLKn8Uz7uo+h0uR2aliVGwdu+Zs7mSsnBnj4L7p+MDoH0LhnbLHsHcFqWElS0JBwh/w3fBgxWMsFcguNwZng8/LzzBNQ/DPzE4tRVpONiONFarCcamRE4cvXwZsUcoGV9J54FqXFOPBEoPaoPyNrX2izAklYf/+t0mk0ZmyMMM2k3T6pvdbQ79U44OtEyDnHUCa380RlcaqwmRSmHPyYxtmirffn2Gv65d5bR2SMvX0YH7lofbN7P+gYmdnXxX0baJzTneJ/LSvJE8jccBsJCL5vrGkjKK4blzEiiWVTOAMHeTzlY6E9WSZR7fRLWIryjyH3SJ/YdW9Fn+Y2tnxxdMytlflPgFabD7YVk5RLjAoDKjTAaGZNJkqRoLLWJ13tZL0fJSGsr/EAAEwZ5KG+k5G1s+GyX4V7OzKYIK+vIDJicXdiczyTzHOq5NCGh/FtqBMQckm9uKNJ8Z8B7fxFccwYLpX5rt93CWgPUeG0KjQT0qYawwD/WnmrkqbXBT8y+tzvmH/CiYxsAcFVrbE/6iUho/GHRPNgKOuKQGfv+ksjW2/9WIWenJx+/ViIsHnP3K+DuufINnJmfgG5sD0HCCLfdH9Z5oBElP1uZzlodLPevVkyjpYCyIqs4um5rdpVTmTTakecrpgrZSRz/iszOb4Ov6qPtO91gpehQeX/7MUegCYI+z7K/T/QOYm/wTydQrrAou9QiyrKjxQqlDPBxH9pm9hSFQi87wOLTMUSbgLSKKndgNU050gpSCiIsqAv7dh5xSqtg/pZ6VUZfmRwzYn9RNOPd9n3rMnIayM1ThcdreBr7L0GweDkM5XumM0mnMLdLhnfvMZhGBi7+1npWF4JFN59zf2allSdDtXkdlklDzDEfYN+nYooWoQ0RVmP8KZHw9tuChz8aTo3JtPELqAs3J1ymfY8uVMBFFRAlHwuOeIwf75MzBC97DSgq0FbzJ2OqRmkUtHUOZUCh4YHrbfiNWWOUFTJQNmubFA3GwIKKN+XS6IwkIBCKXXkbGiFdobt1xAa+hAGA/DaczSBwx5sfKCYj85Yc3znV3MIrwXBEjykrIiO6s1OsxAoxvbqPkO5vdgKeq91IObjXcvgLkmHaPkwvbsnL+zeFu//T36+WZqf5rZnWDuPT4L8bCQstPceL3k5LOr01Tr+Zra14Cg2hskMgkajgxEdtVTL8NAZWp3dfIxL1ODdYXTkgih7DxzmpcXVfSOOxjHW1VsjHx6rld4cxJ+Wu5GbTfgmVgoZm5957QAKd6nK1u+UVmYqytI4TlyNhWK/eBNUX6Swu62LmBjQ++73jJ7xHl6JvEntH4btcbDP08FPQq3kgAyl/eQW91UmyXqSFr9solP9dLix7B73TIR6SyY98al5lwhcoNciaVQ38LhUtqvCR1gl5MdNy7HjiKYEVrT48AKP3qSpiWZVWlDZwQCxfZkBJAzpsFG2jBLnMdl7BxC7eXGy3F07EK+PsDaHBXGy2vBQ+Wwdytp8bhGV2d16CrLXwVW8ol4CzXwX6Gf/V6QLDhUYzYqN+2xIsOl5mgKjFf276B3Ta7eG3wPN8ZUdqvtx+ngDRw8CNwT4fjnuPTaJdFX5HI+Sg9WH3JyMgaRQ3qeQQqH0Nw53PhL4UZfzPktPUKdh/0lAOCbsjU3p919Pu+pHqQScsiFu3lJD9mbfQUMS2wPdvCuwbvMH7w/G2dhW20CSK0+gAK5180uxXqRsuX+iAq1DHIBksi/BTjBdzFgC1E7NFuCsPDsIh7vyu3FMsz+VguPFyOpaeb5gQZQZXY4RYpYlO4j22N/mJzSKkgEYa7IqmMzYhxHgR2PJlvDVQg0Vgq+ETyiJJn8THHx1d1jNlbV17FAlqTVA8pMnF1HksYxtD6hBXsFYJsWoxpHDxsmW7WLO8XQ668sWUubB0Xq66qPOkOisUoY1k6paX8YYFH7TCBW+JzS+LKaw1wm611hMPg0lVThUPRFzZl+Fz0varQXQhw4pg9hcDvxApGEGiLMYeK3CPpXctZwjhWLNYMuiI0um+GlQ5O8XT46FP79fwaEl9ATbwLIM1Ag6h3F9fW4asMqejHerLFQvDBpZKfjm7KbwQDTwyLP7AYuKt3/H1z0RkPJR304HtBQ1nUbOCAzE8+HOsq3zVC35qtjbgMiaaqzIgMYYYgZRY/OOutQRHTxDQMg6wHtfnfWPT+3q37LOOmt02XMP6lgVsgE6WAh/oHgmEG/aDt38JOQN7Fd6l6NnnQFcuZwegGTKnvQ2SI2CuaoVlh/xdN0/KI8CAOY4+UMpsSZjvYl9XRI6jmPOazwAUudiRyCzMCZ+qaWiKmi580OUf2vZnpAOqe4OSUho3Bx0OK5TW1/PxaUstabtwjBIdw91UwO6V/68I77Z8rITAEn+SD8ek0pM9hsbHyDGTb98Qee1pOfZlvVo84Gbr+UuZ2pKmnDTdgslCnSV7ong687nKgYRK9DUjrtJbZuRMYHRSpKoi68oMiX6YqP5Afl3dIBD2EgbMVyS3ayGcfPMamFp42NcuRYl+eBGFvWxZ3Q58HSZlqG5rOfQLv+X4yRZjkgJy0ll0y2DIhX24J4KgJnX82cSa4wBvmg7QuPZDqi98RhkHy+75RBuOWP4qXQEeFBJOja4LywHFdXSLa4LWKe6t49e9v7qHdP2j/JgkBLK8wZTM04WwKRWmyd/zzb+Gp4/dxAJvXmU9NLlJhVTKtbEBU01nFBLe/2eEOfxf4FuOxCGtxNuz1CCc2M1M5NyWKlm44ILhvZaAmqs7enhTu48+5bHiLoVBYq9ryXHKt6qyETdvyZYAkmpeIB2CGvh3ajeEphQgE5IjrNMeEvdEiNSraXRzqtJwe07tCY/XxjUuNSgyZx8UFYCZZFQRimVdZpVEh6hY1+QYPcGGa4kTp4zKAttoEbqfzrmqjUThMzuHVxeLD90CgfZgAg/F6P1duPN5QKZ6JHI3XrPQ4bTTjYUsEqa0nqwHXlxjOH+5rQMybrCbLDI5yUUYiCdbTNaoPNEk8qONP8NqIy/+3LT04HuLSng2/RYmi9PV557UfKJ9fb5pvJ+73zem2UWiB0BTF2Thd3mT57/HvoGPr1ZEs3IocxoQku546QR70MR/pC8N9LAsSMnkVOghY1qCQk/0NTd50cL99iObkDBjhNpOSCiHNh/mc1HwIirO4t2GexMsGWC0E+iNdNz9ktM4XNwT2mllW3G1TzVGlsvp48Y3Bp3cISuVC3i/oZ9idWAF6a1u32R/xccyuzWBcc9RsUM/9Rowdw1o1EFVWS5ZOciRTIVsImUu57ZrirSom0cBH0iN70/FfHq5hAxxMOqKaXdiUdkaaJOYB+FOWdasVUuIpb8ztB535by91tLWYHEc6YBZnI3M7aWP9p8tET3tR+Gq2vcewd9tEB92dEyq729NYEhtuEd6WMqMecWV7nMGQiIpzckuVChmvPZfr1euSp03OuLiNOyPtHemPsbNEWhz87xEsGUM9e+/ERuoefH76xzb0T69vFxAKyIztZraX3fp6Nu//1vAVfi4QWDL+ogU4k4PjCZsVzhiWjP+64lU8i3bhK1pAoZ6pcQLTSf6AFeEBi+dPy6qKDwwFd5Tfa3cvZDAByAiR6Jtyjs0I5w/Oz+F93JolNdYdmAai6NLXPYfbhjL+7db18b38HCTxd7VoHX9dyGsNo1HtXerkPfw6CRdowSs+xuupgxzFzS8EPm/aYo2IZcQmpE79OyqMN4Ydu+eX6hJDGg4JycrZrFP3Rva8x/mL5hrQiP8shI8rRvZMeT2ErmgfdiRuh40BGR30cGXDprHyDU1Qv+Bi2vot+3r3Fsn+cXcwUSEJlS0ZIUYEXW6P7ZzGD/aDHzJY08UR1U6LVGbWzvoPQviFa32l0GXkYw0RAtfeeEES3uQX8Ni0PqgXgbkQYu2DF3hN1TICT59V3etxN7/bcoeOm6RlBP/92EenzPu4ihY4a4PB6Pvlib+AIGQ07FG0H0KvvUf449I01j5CMMQRLF1XRtw1oyRG9E2feAN+RMd7as/UlRhvng46nIKWmFS+Ya2Jf5IFq761t7hTE6VCx+PuMm3kegnfSux0aiAe4dZtMYCeVocXirWzC7TWlQ42VIfWi5Kmz7ScOXDKUf5RedXnvs2o3uIMmZjmilK/1YoXXJZg0foMLKmCOv1CKvHSHcFCfUh8uE/ervoNVFi8fA9kA4VAQZ6uSTuDmobIu7ze9KqgJHwgD2u8DqTJVeCP/tjOYiw4WgIX6TXh66IZP7fAMaRpaXIxKinVvKhTNkp0rP+JfyFTxQiWwLorefXwdhX5+UZbDtay79dmHQVb8s0u26vS9scN9wgvnk8mmBCEs7T2k5e3qT3kpGx9mk8BBQ6b+SXbVmjJYlINFFh+k7TVifxMNCDQ0Owy5vF60ilfSXdnTUkfb6XuPyC9QG0wgZs3p2+WFnRpZq3VHksrtcfZiQJVXpYkuSzufke5kcf7BgJM/3qUBU+aycqUv2IJTumlMPdyHSG5+gYQYBDtjFKUy3CHwjE5aea3IHjLyfF+vaYe5ufSf3JnQ3e8ZgLIZmlBuZ30R9SCVDtbuEa24P0duL7CHXZ17EhdXaIDCzh/dBJPEcxbauHRwAUIFr7yB+2MwBY+EwnmDP8BDnlF4ISRTPk7zD/54Ekr/2qOehtqLfdVoo7C0Qtxk31nTjECASUOVxrUx4fI8gyJiainbofzNMobraW8AJ828AEhaW+FkLqQYcrDN/ThaA9zgYeq3bUFldN//GdgCwlFH2N6k6rHN14HKs0OdkcuXl+07y9sBZln/Akw7WT+7NZ4Cw7uNGhtc+fTpJPYnN7xbYYRhPmgIcERpLXPjhae3DjWzLlqINa5n/ZyiqVn5eQEtPNQdu9SFc+feC2VpkHrPAB9QsPspRBR3LoETILnUDM6mkczURMcz+lHsRNzb9CLKkJ2xxLQgncBnL5CFfVR6+tC33f6ti6v0MqCU7Q2+gHf68C/dgwChwTylpgQ4UiMZ+/+IidgK12n4F17P79eefpbmma+DMsFzZXQu0Vpjm+ssxCJ0eBKFYxe7qVj4vSaA5jd4M5OpJ6aNQGX1KXJYvJq887XW+GUM31X6t3gXV417tgy/NzlSWXxm8jEP1DSyyPnjSp9i+BMSwI0FUOHXAOlX3LEAm49TE8SJbXtiPdDJ75dgMWlZOurkxa6Y0zA8th4NJ54Be46i81f+R2CrTBNjWWTfcP25GRAOQMnGEtdJ2mLx39fpc4Eje3QZ2q039bLVL/x5MVfzBJ2hYzS/9Am1JT/ZwjSikvZ8HrgPnddimEP+KgEM2incrhf9E7TfOyDKPohDt3IAGzdB3AuCHY1Szide/AtCmHutZ9CrISkvK+YnhH5DQr8/WJUYcqtaZHDwRRIq5YF1nWXseUXEPBBy48ui+vcw4dHKZwuiemk8X0HyOJyGzBnEd8wi+pzOfY0HVV8KEa5Mbb05znHrVcscY9YD5JUCfKnNpScLuA1hMjQNq3eHyI01lAy4UNxsFD2RyE8VydBp1cSZDcLnx28Ch6LjvrGRLhNNA3X3VkT7srVFro48Xrfcv5qD2Ta+mFF5lYhBc0s1fUIjiMYMMIQPw1oYRuh3xHmBnvvd4um89WAYstIyUsLZUZcdMO/A0yHSfYEX2U7MiQCWzXvLWdG4M1fO9OqlQUkmwDAuXVimufzI6VKITk1+bgXqty7fTbdvDspLg4RdWfEUj4t/u+oZ780Y60fY+BfKvfohpNQYT6DsATEUHDSYIS02fd6Bg9bnmkT+MsXJxweA4d+2Q1Mk9HmpkBNIE2v4sDymuMPXpqLDO8pNBF8Xn+M5A3lEv1P6F5rHtgp5KE/83yhRinuwThwJ4vS90Pa/p+KbbhMx7n0gMW8EuZ57BY20AFcGDrurcf2qziB5+Z5DBCVQ/8TI7Y4pg3KOarDK6jtxWp86XTZjE3aRLr60gnraM7hyxEJ6I3OHOog6YR1blPYyxLw3Y4o51WGcMaPJOpu9olnLFSilWfWDKwPpbstx4UFlqdfg16p46Jkb4uSfHs7c0euu7+b5+7I6JFbN7FQrBdTwAMgxKUDQo3ewIaV8FDvWFTIxVcuQ+YUHqIRqplbGpi1JOp6DwWGTFdHDeawWZKSqKkysb6kkqpBV0tC7Heh/01HU/AeOdbAG0QBFUYl+941XOf8cF4Kc2E3Gio3336t2mqXpSBky4IBkt72GmeFq5Sa4FonMhZyjiIaxSrN5XD4tqPV8EalqF3XYptm2ysyB6R4E58z35qcEjILXPgI9k1rA0urLt5myuuHtcJgudazdwRYhjthAt3EYEkDBbodaY08OH4a9LqZysyP2NpJpknaj/HTkMXFSQDvBKQLJ3m+aNFlUP3TgE9VC9UiL1qv4iZDcCicyeHye4mHearb0QCAVFqrPTdJNMqOOPbJ6H0VRhbxMhhpz6CVDvR+aYVKkg4lt0aYMkUFLzwfLZvdD3Q3sBVMGpbO1OtEVT1lSQW8XklryxcQ8irifjZV/sFNYPt09C3lR+l8QVCDfT5FuhtVf0NMZj3FkMM5yaHuIyPZXWwPZwHwvgVYDMd3NuzvUjBi9Lgwiv4+CwaK2h5i43gu4muMZI6FkMYIsUm5JP2w1tzrj03LhL0mAGEsIMymMh/wwdQNNCVfUX+CsiyoUZfRxqH3RMbnrMddJ7rLkeLHm7G9snua3DMJp6jyncE5IQ83hfDiYLzZfDhnn410dD7VKGEmxIjULE+tTodOpiJlkS1J0S5NUgvPqu9hr0wvMHpDjKqpzfs2sFozN8Utqo9OA/uXKXQ2BxAsyUbd9klV3J+YYiDyn6q8QucCrzPMQe3P7IeiJ806ve8mKDj8m/y/0LkT5LmOGZrV0H1rDqpR+LDsSmvdmd1imY7FEOt5vtVsPGohKVMZf91HVnyLE80MHGjT1pxOZN8AKYK60xChtINp3QhCdymuedfH4WOIbJ4OQt1YSYLa+kkJJehC9APtdyklGQRsXGsni3xu31hmK25YulBJKu8P+V7Eu8aj6idlEj3sdPvlm51zzXE2J0agur7GVY2w9nocg7ioJ0q16GMcRxjCz9hsz/0WOJ3PAqbltde2QqAMxhyWDLLsazLuIkXl1xNwd/kzbVc9l953giKnZUmZUSYmGEyxg+jEo/ikSJvIOBnfmgQ+ssh2Byo7dCqSmp40zGYM5IN6L0rLpLa7cShTeF8n7TzRgld6kWU5fLAw3Z0tbMVU8jDW4cyPhEWCRp1St++wXjg6tYkUIxbl4SM+cUnWyrTWDXeP67y50qpwZ89jj4r3Ae/AdYDLeM5I7s6SWRKoiiu3vtrGYbklVYZsF8ZD8/fI1B8F4ATsxuFHr1c7prurerSvRTsez2lxfc21njMkBgn0pONCknYzZvYy7efNNMduZTPtdL0ac4Qc2hLd2qjXItjicQrD3SuUEWrs3mPmsxn2eHx7IRL4nVKrNnIp7dvjoCP0I265Wh/FvN9kwyxnVhfmrumRR3JMXlgkDU6LvLYY9vdJlzdq+PDmzVJBnWOAHYvOphuOWDsjFMvFJI6dSBI4vvL92opacjQrj2nG0wpJu/KLGqP87tK7Gjz1e2CjAaMyVfeYzt2A5hD3MyGdgqWZIPcs2rUAy6qU1agZV7ZT2Hl7KnflC0e0novSHPvbbnN3XcwA01xErRSt+PzWeLHAWP4khmxGlQmym51s/WqglF/Yx46w9N/zru42CHlrZUVzQ7OMQ6NieBHT4ssPzRbbnLp/ndldl/gUmYMfc5Unk2vB2RkaQJMfMXZGWoAu3layxfiW3T5k6RRiwin+TD565dGkgY4/nzhwkU+szlJ4xE81lDrkCmxq8dinHgjWdCtEGLyvLO706LtZsiYx9Xu7MSsMvHq2A439Ojm28Pbp9b9HWkTV9seha+IR651/wW5NM+4Sqv79BDV5fP92Hr09bbOyj5F1lg92R6zK+qbCfhG2+vhZUPgG4W/DCvZmDRLb3bL/kwLp27j5qh+UAjWr3mNBlAyOiSnmRbVWYGj2+8mCpBBFyCPt1JcfyQmh71IuEDzlis5nur4OVPaaAovX0dj6vQ0QjBEiMhtb8JYvlSXZObibM96unknWA79ejhOpGGQyG9dd2JQZTcmb5NwnpL+hKCFUH25KbxPqS+KuEJ7dq5q6WaQj6zg1p+38ShMh5Bq31MHVAyIDJ3k8KbrlTTHkJARJFK9cWwh9TBNswC8RsX2e4WINLe65SPS85TBeGvTBQARNs65sjp7Chv2aNhl1HiDpB5eFV/GuI/NnClGbZVmvrtcVg0l35M8M2wciCXSPDX5DaUujp8nxWPUWKnlT8Ahd3PxgZX8U1143Nv8u/Ri0AgqoKWCMgOhQhDKx/apa8I+W9w/yJQhn39L6zSKmVHVeL+3gBCjhS2IbUwTwWLt/Uta29VbKiSqym1+y7R0bgSgb2Bu6tcArFzWbm7J21MhB7bkvlVq+gXiyRi2/W71PXxVQLyTBDtr3haQ/HbtnoorfZyHW5Pg2ZP5ii8+KuD9mfDZJqUxcENaxRbCSBFNZ3XT4MDd0rRDYG7v0zbgGlQxPRUFl6l34EYSEzFtEcUV6aQAHIHiV9d3e7yK2gFo+maZODNGncRmt3n1D8oDjdhk/1TyOLzT/wjw7WIlwWK18UdaZ8GalCHlklS4arypp5wtpcx+YrMOifYYPZvgYdngqVR3Fsiz6LPrHsXbTAqnbdp/J2rWylTuAfDq+afZ1EPsOr9noMl71QKs0Z70ETGXqMNi7wehrbqNCA6z1VGRSeFrp0jtmOvit9CC7dO3fnpaLFNKrGWEu1J6H/9LNgrpKY4THRTZB0W8du2zrr2zPVGcBrhd3KJbct8iN1BFZuFzN/2PAboT5SZFm1LU01fIB47ZuuiMuXtfA/HMhHq25vUDzp5/cp5+C/85H8rRloRuTAeb+4q9TLKb+nydQ0pbQM3TI6rE3thifrkMuUsfhC1rU4i8RJZklWz8mYUQ//4x4dzPkgmIJpzUqeFveo3TCrQaL2BJLQJHirwQEbSu4wLaDi5v8wAy5oE/Ro0IaCHRl/9oQzsopQ66e6vPluEiU9jIToSYZI4bWsqpXFkFa7mO8ydgL1kf0S8dYUOwbBpJTuMMzJtwXljvUytpH3OyFrKtCTtD3/89WSLs/klxVz/QIfxungMOdmtqESp7ZCVQK/kfxNvy0JQEvDKu3QEpRDdASgaGg3q3erL7qx/3yUSofrf2xgWMK+gRmmrhtN00G9v74woDJqusoZ6n3tq0ZifCjWEItpmqKv/q1KnljKUU4lhmfBN3dwGdCiWtzCfU0hrghgIG5fcnCBoIUlU+xuRIxT8Zkf5hpBLLITTmFhJ2JVLorSo1vswjoJv90qUYwVvaqnI0o9s6FpOEmbS6/oLkLPnOW/tpC9/R/7PfQcpE4mdFpjtbAmuA4FOpCAAs1Z+layrAIu+D1kC1yAJ4HCCNTA+NjVMbNOiv4PnPVlDtCNNdv1kudIEdGuEE9+2ZjbSuWAilu24ulghyKE8AQ5EzxfGe/Cfy9JzNQQZxOYb9JsfCUdEv25jxiFYJePK+jqSDQ0g3dOWxhWc0hUKFB4PRVyjFMAU3lesMzpv7WJcxCsfAqZeSUa3UtYBjYLUcv5uBp51h9Vee/7P1yrdHk3X7yWZeLSdxyJXsd8HKCk9Q8wctXWIYKtSmCJuDX2tAh1bxyORIQB36dexInhPkoR4LeArunYEWszqJwGE5VBuE+CttjzNOxAPl2l/swfJR4XRbTwRRWAqlj2v5zw3U7KXplEOuLzuj3x+/4i7sIZ1NRrptt5awntYYp+FxnSFb8DMT7cJhR7qG+dn2Z35lkxRaIC93jt6eNkg4kCmIxDQUnK5n1MbyWD+vlKhm1n4wrT+bUthTC2/EoR11lmPBdpyq6iwyo8dW1j+yG3J1Ueey3o1KB7dWmYpAy8JCl7ph+84K6MufX5WbaeWfFs4JHI4QU5Gjni0+bX6YOt2QKPbppiCHNZzLb/q9AxNiGoeOERb77L8YwW2WTboweWWBHESs7QmbxQE+iLoiuM0wv2wR+DTSRRdsq8eygq9kjA/58DOZwqANNacls6yVYH8Ut9A0FOTndLZ1jKljHlalljfCx3Pug2qulD1iFtTIdzqVkPWxuzMlvnROs/6LoxeAYKyLB8gY5dRvACJhfaWi0O9cOSqVZMFg6ePw6d5fAREwsPgkY143aGrDUEYYQ/3bdRYvAEv6ccMiN2NTuBi6/Z2t9lGqFQABlrv/e4+3jSIafSAbnnNCDzbTJhEtW2COLmbXI77N4d64Xj4IPCxMm6N1yrbM6j6EB/NcNZc/860zwCNQECwldYtnFosMdeZ031SOQuNnOxgLje2JQRaBcO4F7IcBe/QW7d6mRMyu5U9z+Cfpamiq7Gg5PtYyLXsq2ukcYxdhGdYStjRuSg439l/ksHch3Gj0PSfpw4GRVjvY7Xxd/4QFM/v80dkOIAHzbTjlVL7WvgSbF1YapXNe9rFV9UEkNUhbvJUhYEXaXiNsKRaFML/mVJvCcs3Kxwf28edlUmA+VY5kb4wDb4ZDiqsdSp2AYRvdZyzL08vZldSDOBv15j6IQHoEIWBO62xsKx180OyNTCr2FuEz6u4Y12LGphMKNVcZcXSsik+ZBICEnUIdqLOWTkD8H7u1YbBKEWH1upQOedZhEPXV96Dj/Dde8giP5etdH1c6vlgX9OCMT/PZ0qDOkGMPdJ30TU0y5Rwh+UOXmGiO11OTQ4Mj0ySE6No1eUGBX0sS5WaWFAazxSOZ1uJUj06si6qKeIDHD7wutviRN6PYrnn+89BdbQoi9d0T/C5245mXxtM5BExZsmD4ruC6Vl1JvIlyNirXI8t4YHygN/viSaZ4lnBXmLs/bPyZMTc75CeYAAE3d0w0kosJa/OkbYbhus3svCO/U/4Pae5RAzy8V1oPG80B3yAg11jTeIL4kyV/gcuRUXxDTY31UPFsnzAwhZnOcAz85PXgw59Hc6RqPvMuVlVFn3UHi9g/xY3IVWasi5z8WWD6rAVYBc1V/4KLszOCaSMVirdC/VkYLEcST6DzzMbwAuxYNcChuSlncArtkryYTopJIUQ0MUiABVKPfMwZWnCmuCc26rtcx+B/NzQUrAIP7tXpoMh1gz0BV8MqoWEF19vyUQ91fK5SM8hWYqJqoD54pcDBLM+ixl6L0TSXE5zcl00mikcw977thct6EQxAQV7NNJrGylwzXQFUgmkxb11NQ+kyizBLY/Em4qW7QQ0MS7RIH3hGDDnKNr232qCRc/c2BDSJKAxA+Zjr8Q+HI4hdaCGAyY3oGG5CIKhxsQE5wYFU6/3JiOrvJYA01tperxsZgBt/iOChq7Xf9SpCaCJJO8B9vpGnUHDs/94J+yRZtcvqS/O+F4lJGTIby7sXlPAVUIOM6CRiluFsEhXtfilt7GhVhSDN74D6Ijpcg7H9FlNiIfhLh0VzRtRXf/GbFRDAaTF5cG09orbCeuV7+26yHZLfo8MOKGcPrupHh+BkxngNSNWLFRDZTH0YF1yDlIJxvqLNH4rwoKdvkF7PAfjJvvMAbBbbSBpgNmEizU+kMoIcxr84r+rz13yq4GpnCK8LaznJsJwMtvZLscCtpc+aKtXk6c5jnL4WYATTtoOZ5cNwmV97Ke9DCyX2ijfwSwzwjC73NYm1ZqEqfiXJjbKIejXbo8AD4YsroTcp9Tg44daDW1WCA7rTx39Kb156S/YGGvRcho0Pk6GCDITHveJkg95AIA1wGXkHVMYI1H8+uGr+EG/3sdY5+qb9AIR7c+NKmPFDEYUvJ6NpNwH7x+QOlkE6rc9uPYaX6jR++p5lA/Q+5qxRmJerJLTbOZ9iE3yjU1hvO0WaLEHOcOj584FBb4vm5CnPpLnPmxuYTmYc2Fbr1ZwXqPkkBvRmSjxhMg2tOKjCs0BJ4PzNvASXr2Yyd3GFvpS2mpzHDPmYEqSJpvQjxJRH+fNojCSJJpHYwUjVuziLiBut9AtwGq2nWt7H0Y7D14m3DLRiiqxJ37CFtBVZEb8WMhJOkk7GqghspGtKLQt8JenW/qNCdF2c+BnDGes9v4RPvzGYZULf6IxBmuso9bcp6gLeDSSkymUZk/TOADaUyA4280zZGdyas6rjRgDuQ09O1YMsFDlx0uXaqQksdYZ3aCDRHKgVN8QbmYCAcIyDjGcC8e/OlaIdV4gC9QPKOSBCrYsADAISkRsrIOJJhBu5+H+L1Ydpdwgd4yw8BvReVWkfAkKbtr2zJ6+MBUJ/onArSc23tOWe/KSVB4RW1BuayqIunaOZGuf0J+WxqYReC6jTO5wmkivJhYqSnQixaG84tsPnI2VZmBdEtqQb71um5B6+/zyOXkPCuXIlZT+xAY/kEuBrVUz8LwNGKSKjfmijMkcpE4QIPkfcCyyOyU9a7R2bkG/bVNanjS8mAEO9V/KZr7q7Gc5Vlxx2YO9lAKd24q51C2v09uyBoXi8QhUBYLAkSuQ7tjgrm9z27N9L7Yje//CKYlX3j8lX9T+0nUDtQ0drlesf8BIPtWw1k1CFgCj9j5qtcU6zR21irlK1lZpubB6fGFbHh3qBX7e5e5Z/gnhW7oIsaZnKtJJ0qFIBMjVTytyjtq9OZizSH0pPGtOFD7oOABQxXMmmEXA2xoUAJwSopvOUoNgu5px/neHTdivhWMZbARUXEYbxh6OSGgTut2gGXoikVRrtbZ8+i9VNIPQl1rneIi6PBj+CA7nPNOQJg9x/WIQsK8lOdqS46HjKSk59hIDiDYg3SvDMyz/g1+2n8VNOGWLcUDuB5Uk0bqAOWRIlMyS7NS6bv0hF4HEyrdrJMJ/WgDETwJOJ6KW8O3TgbxkxndnaMtCwCt/XVaXCaRKXkXX40Yn0SCySP2Mqte02zz7HkLteasGT1KYHon5dKGFmqAXXuDjWbuZEP6vv7G1iIYUKtCfuDltiiF3G8G9Qedp9/PIuc/uScx/Ab5Ph3F+iUP5xh+VBjeU1NFha8SVLH7kHKzmX6ctQidEjGQaQMUWZrX1lNaNlDxk/Jq8RSJngN/ShHCOe6ZNFoyEZiuidagaYV8Mi5jfFToPuNOkj5mmpaYE+DOjeYOmrWhg50m6DqhNypcPkgjkRsWdUe+rxXEaRH4VnUNQY1iKcM+pU+9VX6LevJKeyyjyPnrBDpT3RBi4WX9AAnHd7GMXuKne//DBkg9yBpnx7PbwAEWFFer9mNaEsOAoHIESKNMwwsuahiM82k+PwvMzgCFXUAaB8I6Dg6M+1QDCr6oIqjWYbY89AyJ9mYJEiceBiK1BjVl69ewod/awbsoX+e6rEW3PQe0g8IZSkWvifSohNwY92sbmWxvnk2SOmgCrWPOkSXDRekU9iR6yEDDDm6M4b7pYnH81E4jSitirkBbRU86OTy5IOActUhDACGrtQNIlrsckoDwgExy6BvXT4h4ZM2IRKB7eRVp2K8Uv+q4mdwB6ocpJBnsn1mRt1J4Q17cf+6wOkw9EZ1fw6sdYklHeomkJP/btZNtzcTa8t/YHrXFngk3LhN6qZnncwf9O0cTIHJs8vln2tUUISvjbS/ICqqsRHjZwNFoRscdYIuvfUbdxMFWzQgxMUo9ueadg5Np1TThv4X0h4p0FVfxLPJFCIdqmJHyvOH8B6gfWjPOEZF5qVs+gCrYcB2ulba4Qxpa8f4s8kPeb8DZpHu+yczjNQpSq/LZrnbl0QgW7ImIvff/v0aGuBUkACIRUm8PC4j39rHMOvye38PsEu5wCAMjdmludQamfCp817oBGGSt0l6eRmIrqXH60qfJp4JM7taRZbOYKZhIAVt5sutHSDAKHwWBXHqhW/rb404qlSdX7XzbHl6kvNl7XjmA5U5vi4nBh25YctueTjS3DslbjePaUKZrfW5rob5guiN+gFqdNGkH+v8wwbAduP17FJE/vunmwMzJoxqU9gGff7Hd8/4hUJOSgyakdZZmuk9E13xJaX+kUxUJybuj15OeOmA19XYnD7UFkTGqsz3bZxSnCri5bgMGGcKydeVBe6XpOtbwo/Cts+HMVES4a0LaD0HUb9PyErb/esmMzX8neoIGs8fYSXskjjBuXjHtJbJWPhtY4OB0fRpNubJWC4pQ8ofdV4Lis/GmRGbz92HuHVOxxZtP6ifwQAGV2RHqV3diaSU1XsPJTd2Wzjo+DaybFKDIT5qBZC/y1Uog/MvjFuAqwhUM3Y94txrXmLjVCEZh42OTmRIt47zBF6fMOsPJPFKMI3lZeEhCM5SFYwNfWPOu3U2UZjGPQegUs147XYFU5aSWCp09bcvHpa019+bmlyH2HfCQpvBQYckMPM/Ogeu9bncMka+U+AEATHNZ632OiFx0xugN4lAKTt2AlSYArxMbHyZJQFU8JXn1xnww8/GmmOPZ76kdawL88jMGP0W5xrOYAHMBGNnULujrCmdy3gR6+jQaF4x2CK33636yMmxru4NSInbawU4GqRk0ojKZc7m4/YneVuR9E6qyHYSPNIa26m2yakGSrNCzbB6pFeYCexhQyN6tFXJ4IcE+f5K0Eqk+Z0x0RUudAGnH5xBQiN2x05iIhwLGJ+f8O2cyRH0Kf7tprsHZEpvMehkYoVDFtuvNbvRrK5JZe/2wpcGwJi8dd43MoHrZbqJlu+k/T5G5e5967q/FGnjZ66jayaYE2sQHcmQB7cwZ6GWSUC6v2IIQ+CGrlNAX5RuuwmbOzTdmyaCQGcnVQsdjHpgmkCloPG0omHJPMqyQdrKUYgjDHgw92OInbIYBvVvmeQdwoEM5ML4QyBlXFV8EDyz3wjOA34FBkKAZOHEzsca8BHewLyAVUD4O/XnuFjen7GAcBOQZcLZNYhAnQELter/7IA15rMdE+RJ7hL99N+jJ2NQZyK5z/BddQtKtcD30dwHs+RN8WRPHVJ5iKPUMpQduC92Ylcj8R4qmn0v6O0W/Zt/9YkJN5QKCxkH0fH5zORVNq3O2yQA1Yny4S8Zrov/0EMUK/Nq7qkn+v/TNR78qxb+gxV0EsSkmRLgk4Pt8npRZ41grMcM8a5ApJ5fMmvQPFII5PfV8Rf5ISaLF5bXbNJhfrOPHsEklPpU9YbRY2FjR6eJWt5lEhssMT01iTq+Pz8quYV5dZPx/DzjKy4Mh5DLFbzYRZQlEuo7Xta1J08FkZiBBxkJdbg+isw6E7BV+mC9e/9TcBzS5ioyXx0K8LKPOD3Xom1fZOz3qph9KGSvDwUa7/kQGO4WlyxBPjbFEndcH8yxCHGi+QbWCbONrv7sh82Hxm1Czzz19KXgf8Iki/gbm3QVA8pbLqskGIoDrZMnl9t2atXzcVonxLNfr4lYwpExBYPCHbBaUdJTX8Qs7YLyotNrskWAxf9PMJPa/R8NoNbCNCmX671+YhM5Te1h+Xo+HgTfHuv8An7diMkmFB9t1bXm21Eihb/mLd4aJMV9vNIRZLjUWK+UO+s3UkM7bHPkkAn3XjWXZoV57CFEJZ24hoRoB0bcgi1tvpHzlUz8wguEfHTu0YSg6Eo+stGY1NNkDbp84t/gVKQmVfvPiVgYJt6gxRhGdrC+zovnKYp0oEd54bKFEs/ZpbXiHsflujgBgQt+QzA85y2KYqC8piIG2mFkkffDr7R6mPCN39mckKVe75qchTaJDu8FmBKgfzvOLdsj4eoNcos+VGFJVw/jw5Syno4GvGitGJ5bD2I6ChAUU86ehUtOfJHmFehhaq2bDo3ryzdYGmbQB/+4Px9QaIMZWGlUiSafH+uqJqk1FoIM8vghbPGuJyMpdJlatcb9R080KQdTjDwTjuRcLU+K9WWujpBJF/YJ5MNJwrhBzIq807TOlG2Ft5nDrI45pPkLBePb+T6XJQFxPA3mYpHViOXA1ZwsHFS9eB3NV+8S+xcGCeGLaAenOuR0g1qCv2uB2EpvW3Puu4x8/dYjksJeHt7ot0e5oNSVrWsla1j4JrN3L0m5XxTJl6EgSEuoa4hzmj2MnVXkibTZXZNK244eOqglYa7o3eDu2QR5JCaltbv+T+8j4U7CpLX4LstEU4JB5Ybm1NMksHxu1SriY2vVg+9E+Vc4o18RU64rD53Qgg1vNvkWnrB4oR7uIibvlXRLGSB1Ec8/ixfSsqM8JkVcSMDjeONEQxvlAWcqk5R54tHG3DZ0OGcX3k1H5NF5xDHMNRqCdz0KzqjOuzi4gNSvV6KXiGaFuaOfHwtO5Z9SOQWL/CqOVJ2k9UAXe5X4xQYPaXRcx5P/uywCOM72LjhKRd93a7JGRhBS1OUl2EtHitjg276RdcHEp9HJf05Ythqh0cYwq/J4IbIpxyblaESHXa2VQz2AGhYkU51r+gQALa2ldBpJ+PWeQ9bsST7IZJ9skVGEDzDmVhlsVqyKSys2uJP7Sq999tI7HZ8xqAk73cZ4WMWvedt0ZhcZy2yU4IjIRIagSB/s+K50ET6E0XIe0AYcbpngHY+uWEYoW+/CWDdOcPH8PSdlfbRL18821oHfnI0dVsdK6dok6bJepooUvpBnP9+ssca/FksoFlic2PVPp68Apo5x2pP4gebP2FPdy//kcn8RlULQeW4mZtjlTe68HdB7K7QWbAcqaYotUMUW4hLeQiGci9y50dw84lEoEUFbc8MVeO9l9U2tV4mCz6W2cx6ijVKs0fCxuI1vZLMKMp9l5XXHK7YmhX2Jq4DIeIA0/+qMK6qTD3Df31gKDhQKuQ+y5flnnPuBdf1WJZmjI3KCpEobQ4bfTi+GUMsBI1R1vGHsS+ONdXRikvC2FX8pyEmTffxFoQQaUDfPgh8fYzZI9nD644TLLXTJp8zVvf5hfkAqRgR6SIzhAOKoLJPO2qhFac3HVWsoMQtr/sv7P+foThilKbpAc0BUhtWhsGB3QBK+5lEaEEKRX4nMaa2MbMmuRdAQlCX1eIoVaqjLpQ+LVVCDoUAFkrC0/7CLfX6QhrU2iQoOijfyh+da9M/B6aQv8iwVDMqqVOcvlOB8N8b5vbPNNSgt4NvGh5oPMpczlBKNx+oswxvNjipTP3yKp9jsD/QGrWi1SdmXHgiXMzpkne7CzRPn8C0EQ/Mjiy8Kgnxc+UkGkxpPI8M9JU5sx7YeK9GSQku/1uZH93jilEgV6U7KYuGjEeyG8DcCE0g2LUEIf+27f1VszYD/d+dVreqrEgXpbGE+1mP2i7q6yPtNZYRonJ5nlmQRHTlla2UgM/fQLvRyYUOirNAwgZtXFWzWpK/nmuo94h6sW/fJtZ2SNP2wTnugpCBz62GSnG0l0+HU+CIaUtFuMSrdp59kh4MFAqD0XpxUdRooV30rRjcl7/DoY6oorVDU4fvA5q0qOvOsN0tn0+sYVEv8xdBs/xrN9GkVYKlrWkJiFPTlfmh1WH+GVaBscCeluGHtYNaPabqzEoJ6zkdJ8xAz547f+uTJWvQZ5UfFtsXqDnHU2SH3ZujVOfk2PNluesP7S/1BRC6VUv1aIvakOVf4IVIQg/rrvkWIBqdEjDHP66dyqNdFKZxh0d15oEYDnwdCjOUQ1yJRgsiD64HEipu1cYn1qrkSraMHU//tVX9aSbthUuSd1QE/XEubitPHwKoXyZmDYzxPD8Qm5Fh0tBXNeduQ75N4yrOYqpUF6f/ztIGNlEQeLM+/Huo6z5Z48HwHcah+bZ+vHTnAqnYr/W9cxjB2gYnKxAtBrU8ZUh5j0RPUszl0T3R3nUHcBTJ79urGlTdL6YKQT6vzu//VZOPEZMHnbmelbulFGkxSgrvr/XVrZyT0uJ03S6kcKLPgYjttRR3DUGfdkH/miE2Y0sVg/z2jjdgOosJEtDyqWlS+XyqcRZF0+0IgnRk0MukN/ZYHpRMPcxpBqEWc19TNEClroPAvaGntxF+py8l0JH7WfvZTWbEoVSAcipyww6RANq83sDbbKIHqbIKKTz+M/heWU3Yw2/A18/tiuFKGMxeCA7l3RDl/Zs2+GQTNJNhBoeOt4oaBHMpo/bWzSt7iSktUsBXz3iaxcpRSYW3Igktfzw3q4JMalbUBBcGbscvWHhlGNKgpE9ncjdU9G7yeC6FrePbRTJYiWXc1pSqGe+Xvk/0MLZ4U8aqDE+c+fReL76vv+o37FrJ0b8bry5ddFv1sNv2LIOR0YryEk6JNMNmIp0jb/qerVDbZFKBGdFqRICtC+/FyXUnpCbq0t3m4uFhAwbbEyzexh7ABr7uC5+XXpuEf7awBnrhAu/9ok42MCIxHpzC04+Lx9wafPeQStVOlfth8uUGA5AEZhy6VFSipZ1Vwug7/wYb6/D7SYF2yUYBrYFW8+63ZOh8E1iG8Tn3/C+xCYlnkgJ9051y630kVhdOzyeXqlhwHyJNyJYAfDfiVr7OGO1CPdI7BgEIHrFOSNEcrY482yVT9iBaLVERH4hBPeSARoGSSXoN0pT/j4CgYRYZrNubEefCK9ydJ0XMwVQ2LhVHNrIZfOEu+o7zmPhW9Yi2/QUcQevD2hcNZ9La9Qo/G6hiuaGxhPaw8WXQca+MjbUfinZLtbsTMKlM0QORS3ixmNFmvDO1oKy3H6hM+dJbHo86CXOxzorfpRcjI3V7Kodk2u3A+1X1RpudFG9mCQ4rs56LPtBrCyC1dTG6vBauTk7azxlAZr4bxhqa/XroeJoJPwEGtdAbXEVSxK3ijnoa1A7h5ZDZUNfaOi+yryc64K7yn6OjPGb0ma1LliCCxe+S8HO8dQ8AT40BU8cpyKdUKJlTfHe5sjOp/TzPLoRvua2Bd0fX6wbTWvZ2ZunfXvYLFyuXc+u2zuOxrdu+TxOIEZW+rdAw2Pz/RTB4GIsmUpvgTUpepOIUgL4YaY8Ladul5J4ni+1Lh/xb+iArCFBTDIAshAsF2N/t/aPRlaF/SZn0Wzo9TaRE4Y0Tyq7tcOEhBrQe8Jxz2tXGN2AdFRNCMChFy7MBHE4Zr0ETw9XnbDJxiMQXimPTjZl2XgkJ6nMWWV+0NZKedqja7Ppxr/7akRMETuvopMFJZFe0z5lLPIaEgDvC/3BoHk4Y32F1ZqxuhYOvHZZnMw4zDiotL2814ouHcKxItGbZ7V8hoHSkjWEFrXpvplr8DhMlIL7v25tGWYPsWWaw1NFkRQCN7YKGR2TB+mb5F6gfCx1JOoI4dAdmIjWadxBNPcq7iQA515WzmxdHm8f0r31bTRmCEdg36GF5Jc/mPJG5+WgD1HAa99gY+SMv5oh3kwx/BD5FJiMVLWGQLt2bSaPotmzCrYnOVPKZhz2tAJNNTZMEpZ8aGCy7ZsdN0CuoZCu5qFCeHqNChg2e6uThYklIH7y+S5MMoNjvof/C0nONbLrE6FD5jJ7nwMtKy8sJ0a+Mk5Er+ExV8i97omzWhEuhLt9+re4EI364k3dlm+TP9Gytl3/dWyxel40Ao3FXj0MyHEa5Q5bglIM3fI/K9ZBBI7gik0BA60tqK+HByh6DO1cFlb2NRjEzl9ZTB5FnvGCsw4G925hg2f7Ggj9KiJpQ2ZCQszIOmFwkDRNRjynYRUJlyxxOKKyQGvMxfFcA9zVGSKkQoO6jkoUinX85fJACqyw6rM5y1yrzHBujeYzhKPIWZB93a3FrGI6Zpm9NKt1H/Ig5HJoEqt+92+jAGFJi5y0Lw8sUTgkCnR9MQ2lmZRIJIDun/saqy6xh6kZMTb5Q94QAgSlFmte6leqStPis5q1BPHUKc6J0eprwLEVz6E4+NFfUy8yj7sQMkUY20pn2LRP0ZEIMPEIk3d00VE/7fz4M/wwzx2iAWwMuLQahH0rbFB5TRZscoVJORNOyXLaa5cfnqbXGg9T9N1GI9h3QBVtjeD0NidI2nwhiTyY7NbH54nnVGy2UAehabR4k1AoPw+I1buE7jL1Q/ZEu4IOv1vT76g/K3U8zKuVHa4ncvUZVfpl3T5nOk3NLHzgRpP5HUge7bAnZNYA6IXnoPwWn3cDU+jtAfpcfJtVCz7lkADbjMMd6aSmWy3vA2U5sJKoHy8xfc0/k3yZYU+wzLz1T6c5csVGXf3KCt5hMXTMxBZF5sgwMIWMX+/7Y+CNe2LMCgiSuhm+mpOmt9xyrp+V5O1pPX46+YjsRkbYy5mZ2paoYuXiOSB3FcMua/K2eseov+CXQTECmQx9Z/1pTL9QpSAMIRbvtS1a51VvLTonTb3lIzLk+2A3rwaPujeikSmAS8bU5qRpRyhbahNsRzQ4HOxRlDEMMQaQTBPNA+KuxYiaDIMRAqXI3yFSU6ZSMcIyMyHykmiqkoQ/lbRiNFWO5M8FVHQ/yBd56yDBAPQ+pYumKsXZ0t1t2MOPQTyLduA1hAVF3q4QM6lixhl9B1GBPXcoW3bFaX+FsRe2ZQVieZJynHdKUL6MvOocLPvc9qZFgB3g1aRaQP9miC0GWV/hKAnAdbsLEi0sMYrrCyntVYFRcVmzxrS/kUGts9QltpsrbcHBw/djb7HAO1nertWJYQoKWicR32zvMEkBj0ywc79k+r2b5QRGoXFeJ2nyNgZ3vgvkH67rRaQLK0liVfJeF+Pd3UIMAeV3Qr0NcXVIolp2WJ8q1Hlt/J8M54+GAcJQHIs3muWB4Wd/BLqJUggbMzqe6lT8Zr94TUzM+9nflhXLta38F99jencL9NUCvp7b6ygews1Xs6b4P32WEaz7cF1CF6TFSWJ2b/3nfxcyRUromG59TOmJ9+40I4M/v0iiK3FHqqAHXjmgBqrZn6m3ypGo418/+316pikMmNkO/fK3UqBV/4Lr4qKk4Mr+mxWnwCxCtUWwBBI7f89O8YRGkJDgJXnR9NOYFPm6Us6JpyT247yt5xCgQ7QneoaAnTzyqiJpgzGaQNsoQqftYHHpveZA0wdI4KIwew75/C+fTedSFsno0KomG/iv041Ir/LY5KNYs3JYDEVUdCoiqEqT/izGN3MnEJpUhvnIvjz+L/SrECiAMYSd148yKuYBaIUD9Mqy2hdJJzc+LwjRKwNgu626QreFxJjiT4qJawlewyG9oBDlxSEF8MAOwtsVq9m6Fpp8WqQC31EEXiauW7i5xL+ZhNWEwsYIcc+CsGmundUfZmEZJ1rEPjHQKxau8zpwOrfg7ukJ+KJNm9ab1nFM8hXAOIRS3urJnAjCs9Whsv5dOu4wp0m5iKpawFrMaT+8dPd5eNp1icrlnowVVg/qubGc3NQ9yHociduZjdrr2vJ/MWG1Ef4ezB9vnNcf+/uT/c7Gm6VY+NMppObE3CRKKR+6J+FEg+k2Y42FxjWxwdgYv4FR95JYKQwARr383sT+VNXABtRjEgt15AFDkDSAnfIMsUyFHHsm1CVPghlhJMfKjRKpXMEn0ut0lKSJbtvuSGZoa/uDlxg31A7Y2u92T/kvEuEDtcPsAhJ5fQOWkQ5wDlpGPvwGgOSoCXeTqE80MSYQAtg6sGE7GqJvyBMXuK+kLxbu8dKrebUsnAEVu+nydSe+Gg0azUr9QxKFp8u0vbqbjsCD60zw4lGBjDT0jKGKinNICxN9OHk5Jw+ImlZxqVvU1J1iTcdVwsUV08nO5M7azmKbJL087HQB5YXP+J3Ekcjk3N8oxeK/HX86FJana4FMAp9bQuT9nuIfmqkQt7w+j63mZN+gd2u+GJKkQtFjiFFHA5joLIdW5JXD04G2dbnvayN+kJgdmKbcF3kycUNVK/0WmY1QXBC+p6OMPBo/1fEPMmkv4e9l8x9MOe94ObYGWxJ/eSTCKzc/nVZxjvU+cTfl4X5nA6+w1t4sRvYN63QKoUNQhYlWS0bibukRkzkbd10vcXy0LmQsVeVOCXrJUBHK4ljb9EZKY8AiQnyIrIn5Y2nJT6QyYvvOQeW+r6CEcWEEThCDJXhs26HnIXbN5XhnduYlEjlbTAHlft0A7V1K8taf/kR4IaxjQRGPot8x3HFAlGpZCwsdO9moKTYxFctNpoMrm9M4iT/YV8rmds1zLNUbxLQVgMG8GEIW3PzFdhWw9aNVnPsKVaOJ7p9dtx13HWKIEUvEo5sfdPhQ9+S8ntAxEPRWHFO+gsOOe6M2PQN1fboh4N+IXe8vcuyVFvuCN3tVtxZjSF50DZIdQxrStUaOIPuE9LZTXcR80EX2YC1lY1ih2ax4QgACSTD3a1YvsRs6f+iJ8r5cG6Pkl07DGM47BWGTNv+Er2xFCUFHUbg6vn7wQHkiTfYYZbwUsCjbLiFjxodlt9LT16cPH2ZuKqX0MeBFm+SvH2zoUeTtc2u/UdUiwLaAGtCegkJqCwCDVqIxtqsZxYh583Jzn2HgUxY+9LC1qbRiBG1TD2F/6JBMlha0D0An3lKrWIHMu/HNgKMHpn1OT9353y6uT8Eq/HjYy7Vcdk7g8tKwlKZqdj75gAke6g5odNunAucIapDFbG/McHaFc/Jhfaeabh/X0/oVJli/dowAM/uOYnKt0xGACIwaMEWwIfClnGlDsSPSFfjM+DGniDKhHyZVeu2x0Ot2SDZUNrU72/TvBXcVzCOuuIqgrVDJ1XiQSeUCUPf7E+uK3Gy6X5LePRbkllQxvGtq0aCztpXshF0y06nF4rZ03/iSnxqaKeQg/VG1qCYrj1xOg7dM8ahXHiAH6USOzsvtPVP4iDgVggXeWeSDe8IcFLELGMBa0TJOzrtmAVsBjyN+S+7e27GpJELBG7Tq3TscXtmxIRtnNJF0LQrJBQubySQ9OVRNhyQHl0Qy2BUPbDXlMgBg8V9Gx8QZsAOLZZGW/FTwgc4wKfW4vNv4CweLNhinJVt0HMGBNc9IiaXNCokeHLAFgJpp1AlZFOfKfyznpcn1eR5tuKqamE/x2ImxSl2KFA6wBub9s/28dn+jZw3/u/zifAKvfmcjUKo5Oa8JtaIN3FeazYC9oamieicMq1NGyZZcp0d7UnEVwqKv261ipP5YHOgNYXk8JK+rhfxipT/ML9fviTTxjrwuuzuD+zGGVA9AK6UYjHNxI1hNPg2puT5TuzAKjAFgLIClMcMMW8INfFLwTa1vsdF4iV3XkMkhv1MOuypI8op/SECBiJl9vYp0laHsgShIFQ/2BaIfLLiqNPU9qH4sVp8uwacprVLexfQdc1JXmN4dyvnOLDU7Fday0Mql0tkaktVexnnW0Q8RYN2lvQvL6S+nii7YYUUwf9Uc5PEP6DhTL6xPiWTOMWrHuolfcHVblF3caSNKQDBoB2nWnBC0wOOlid7Q3FU7/JCHpo7a+nlx6isP45gJhZCooNwnZh5uxylrRmvn+3VZnNRyrQ6TWapgfdSAtQqMdmHlyNHS41hiDl1wr/eSevT53vzdGPdOsBbag67AFNLy4FG+OmTgPD1BogkeBOCw6fQuZ06jWW7KGIy+WuOSIMFaQSaoS62nnrQ7nbhSTsFHwuGp+b3oXkiO1g36FxdnBKFg0R6ZVt5Vejo+vLU/+m45yvjZcAEDXB2GIJvK6zF6ZsN+V1kfA9jo8KrgUjKw6Eihel2uj2BFgPmu0HaXQgvUfwYoPiycniz83tScHyW57wtRORA5z21XDDOp0Fck2dk+EKvqi70nMCZ0kChDGqG31t6wZ76D8emYOqQg1YuuTS/upmabyv8paYCNCNh+dLCiNj3qGGcpclEtzQOVMyZ1N5BIqKNA4TpYfQT98SyfbOZ+EMWhglY1CO226nSdIYfJD6q9mW0BOM8d949S2d+pdNHSq4EuSchWm+im8m6guJNQRKfK/QdIuIF12st5umOODXNFE60lMeMLhp3PTep1MPCSNgxthAeQj00Y45GPXRJzXBO8cNZSKhnLABdMj55iiDAF5ilyXuQlJfJcEeGo+ApqHRzVHX51hxZHlSO4mblpTV5kynHLW74MdtzgR5S/a1ZCFBwqgXIor5sF0cdlELik1ukrkDsawTTVGR0b8HWHuV0YgUVoV8bnCfPADVM4BKMNuuSUeTJtkVM/TF6eArPENxdhIYptiRpCjvPQfo5NFLQRGt3XPNHDoucFux6KwW4XQuAlGa02+30rFfznNlMmlqKkDr7T+e4LVH0KE4Yot0gafZ6JdcxbnePC/fBODZi6oIB+JnpM15Wv/Eo8BgcDKsm1hE+hokPZcRP0kEZeyhJh5Jnr5IAHFWTi1iyNHsvxT2cMMT2JvKorFz0jrNrM4G+ldWxzppB5W+CJX27XFC16IXCUWWOys1e0Asl3WhIGYQDoNgFtTT6ViIFXNAD+zE8AqwYuIM02L9vuPrL8ELTVzo7aVLiBjP0v5+0X7XDjNYj6BBUTohLCJgExZ7NSUMaOCMH8FEutwT0sraN3qTSp/rRoY2MwYFy0KWEZt5RAv+A+NA3KpcDNMahg4LEiAgB90yJWuwpHeId+hv9HAUxX1HPKBCD/2LTZ1FuRnL1ikYjhvUppaHJDo6cTFy2nga8mehdbJQ69bsIuMwlT56+AvwhlzT37r5AwU2yIp3J7vLvC6/ZS9nslOqJVb/mhdC4xTSjFXBFwXh15Zz/XvXXSsyHEPja5gwp5rNPgncQdTZbF/KoMykVBL7EGMumX56WnwGLP3nVaxUKjRMjL2Tu23BUJFJWAP9DnpOPTTYh0Uyj3Prgq1FWDzShwZRJVOTmHE0GFnLj4q8icCC6Lqbq+eljU9zSa+Z6hzKsiS/GTtADV9DqoKumP+d/0c75s0lEfmLZebzdKDIKgIG5KSAjuR9TgwVDEoL3eBCfIQ4nj/F5+UPfl61nyQqPhBXNDY5k6ulw7+XQh2iCO8Cu/EJpp8NGGAn3+15kaScHMFSOgCeiSmDLB0/ZXQwtEicoL0FT1lktYZEHATGb3cOrN49A87muLrLu9gL3DTpiu6JADtVK3clYJGlsXsLIsvJD07Pnv8HAOtKzTt4ndlidERPwx/Mv1hkD8K+isTPyAsBdcqM6XbJb+7sIaOiXfyJdz2kpgBa7S2Zo5BJiR1k+LZ+9n2A6kNAf0lTYCmGfo9a81mOtE4WJjGlqOTlcDL3QvUXS97aoe9WiMSU7lj1fbk2e1OZTYYtZlj2Xt0h7UJbJhQ/CgaNkOdApjK+T1lsKxAfT817KP4Gv53tllPLgUPSsEuCVPK265UKzPai8bkd9ulXCngYke5ABCAO5sr/CcWtLYFpvXSwzQ65txqOk0+Qh9VVMV7RsPpG31AW5IQwXfVKfxxgR2aQfdW8uKUVQxp03Grpc1ULye/+rHQs1R5wsEB4bVnGZdjMLTPKQKDRUJDxVLQXyoNsAwm7qIEQzWrzNhGjvBiQ443fgWa3Ixktx2LCj5EOrKcp00M66XNiL8AUP/gw4Bb3dAfxBQoVMBDkUSwV+WPcLji5OlC7cpgooBwMktGm0yYboYZnthmFH9/89cQBpF88lUjPqstLQjjUNZPJq/BO9iY4F4sjD1kJe2x/63S1T1C5TOUTfWE6VIfrp1ZfsRM52bvGy1U0idZM3+junRZRjLtqItiyh4HVQLU1XHRSwlOsUvgn2tieX8YVJRkMAhKoW/Cr/L9X/qHkLY6yd29hABVXhtyN61UrZdZCgwEKSnUe8uABPDxmTGvy2F30lK4yGM+0aqKAd594rf85E9vOQop24Yx5V2aoFjZA+iuZoOBjD5aml2uAeVAXtW7MR0ZPk0bqnavKLnsXP18JTcRuYegL00KLBynbFxwTMDD5Gnie1qvPXjwRI3CG5+LNRHmAkld02sjw33dTDIWGiobOHVMGFKfB+W0yYRJ70n8UpdjHCJ4+EVlhvZCjWps3drIyrJ7nA6YKA9xJ+uf/FPfAeEh+a9fPtxIxTJRzpmkKvkvQFDimy5wRDCqjrezPQ46KUefk8/mUMOiDx6678EQ+kd9isyTbLWPwvW9sdU++iULkNX3HHXTES12a+5F9arSPhmBZ2whY2s1MbHpsZv7clJr0Hi3w8Lfl5yZFPV3giMz4iJc0rkpyAvt4LWqzQCRmC2lhYk18HeJ2vtK24s4eYQyqYokNuD2PzQdq5Rrh4OK+Oa6ArZBxNCSUFGr7mnZXc4iJYazqbnJd63gq7rRRUhJYoNl4PnCKOYIYA/UEFk4Mc5jUzRuj4lbK+ARkOHa/JvN93t6lFK1BKxkUgXkcx9is0VcPdc2zO4AZIiFC+BPaoQ7woPj/M9VNudKEsmcTBQeSCAtsbSVJuNdZGWCF62sMFBvTvV2awHj1UsD+SsxG/DjgJ/e9f7PzPO4t+IMM58KI7X71cqBmv7d3Pr3mLWZDRriIxt+vaB4dmVn2ttzz6z1/9JLfC5o0eW4cU4U9g80OY8aDrndNcDjCQdotZ8+qF1sKrlOzHS20dd94yOcOI86G/thpd0huHi7YHwxj0xOuMCoDfRoY72+6xAGZXGZcnR5J1B4xpzfOAzFyOgFtS/m8bgWVFSeHU5FCYM9VwG3wzbskilLxou/RuEy12oWtciDQ2L7x8wyRkMPo+xcAxTGzGF+uNRHjS9nN0rbMlP/YpCcEwQwzupHqbPjE2dc7zcB0Pe7lEuvV7DjYj3ZNC9Yo6u+jhzvMNnfHoOqWOEiztsJdb9bYDPty7GxqQMy2st2V2lQUCBmuDSKtFaExJA/iNtqPKJMEBeJCQD2mS+6bgkuPoqg1ZdkGs783HMeo3xUSqhRt/A//YG91l/E/sF2dcONYdIlgIIz7Euwy/MMuiStnIFu4UrYw2tDCq07OOVQWR2FTwoVqgwClaPU5kcvbI0U7MVJsdGiKTiMGWpudDFfL/vOsIsQELKgC3FCDdauWS/7I+hOSRjCu7NzHrXTbtwf2e/8jov1ssoCdrKRb0avQ5H6oG+Tw6moNNKNmvidtCw1N7UeBxH8p0EtExDT4xf6HF0GvNCdMY0yyQow69x37jcn9XcsN09daQx1+QTCBlwQn1a6B9DHdcYm20QtVNQLyHuJf+7oNGKBuBi01X/aBzka4WKfRRYhV8nltLZGwtdD+IjuCFDVPo0v9CHPjUBEU+6V+SWg3gvcu4IdS23K4LnuPwTXy4i3yq3jeySgkmOA4GtTs9nLInHXt4M4yuAgLYWrYsBBrhv8K5koWeVszIJbrnIZ67aFtqdpjdFgIEVRzSW7HMRABtQFYshYFWPBdqmWZwfIpANvlY2UNar+i7U4dPgVJjcrQKNvPNL32+a+z+MVRb8KsfR2pmncHulj6A+n5jDFeViQlRVyXVwyVl9i2FqEW3+bgurGzIfNbtmBveD4ADjH2w/Deuc3Lbrb/Td72Yuq5gA5aTFz5YtMpDsuyIrwWzyVMf4DxiEDWuxiw7F4cfl+idQ8VQnbSkmuIkE/F1EVCWF3DfD02rSBceX182TIxpBfQDFOf34c/Ef0dd+FpIuRD83spPyka/QfyNLDrUn6qNS5hoZDap8y5KelTm8sntJcdUz+izCkFvmewsZLDUGlRT0ZWvl5hQs2ugVFHb1GDFIaNR/ioZH9+fiISykw7hpYrueBslO1SjxCvobUdH0KeHnnsGN7Low68uPQtwdHqT9VWhXgv2OQR1inKy2xKs/1zMnhtkalwaJKo9sBU5JJU78kNwwZ1AIH5jYkyaVv5Lr/KPW5WuCMkLbIo7aw+AXGNEvB5eq6rkBds/OUjAO1nOtyJ9VtfWwhDH3cjgRiqAyPkJuHgkCnlOEO2DeBVkEukZIm8FDYQXu4IE3A5uQYbZkFsacZsAI8ML+l5v7fUBwcnzN///P57egE7oGV1MVrHjQ1iPMQclpmRAA/SZGscwOuV8WDKe4qRJEtl53B2/EK/QJVdU7yHSSJ8lK5NCY0SFdhhClLFj2r6tsg6tXlFmWIgC9/z4gdZVqj/jiGEOPwTPzVG5bHj2dw7PUcf1NrUta3tPXav1MVTSMjaywZZ99DRm8+o+dASP6tAE02B9ThMAn8saDt5jrb9C6oIOsBCLpOZNPY4K0Nc3gs2y+2416Cbh+0vXIDx2Hb/eKR1om6lDWxgGWxg8iPlqyfDR6TPsrChbfIxstE8UM3tuZYf5oWwXAsdFNKPUf40jL7RYjRggCgn3ITSTMxTecjfxrfSUVgFaXW5g5GIiIs9Fd+8SFzw4B20BWLWJq2euduqYIYpap6Caf//EKRRohX1e5NVJpjDQdKwYUKxjLPQrrOgfbnc5a+LNyI04w/MXIsb+Vkq7sKsWlMv/B+QJbNi2JfPsDXZPc+EB5AejfpFU6OmDx6EJtk1G/ojE59eIHsL8LiYQmbrudUXULsO3gJnci7B6TpYHs5g95Dfa8xFo3U3NRPPjEQb+SszH3G8MGl/UdZtp85G8e6wXG/ks27kO38FjtQJ4HsbGfNJKhpyG5HM74PDQFChwXszQtL59GhaLWi2HAv1OKbsad3M1EbL1Alv/v+DEVxzj6Rt3cy1o+RgFjVy4Ju97g7N5RQakdh5DilLi4pw5UsUBTUIj4E2VmkYd5nkNCNQEXafclBniFC8g3OmzaQGW9BYpqRQg/nAyKlLp1e3WJFRTyHJKYY9g4ZKg+xDkX35iqdjULPoWdHDSIyLMiDGefGJrIajiKNNb6260u3LjZsOz+4tN74AaL8DI4nfZ+cqxuLCslPezExJNUZjh4ulAvuIhhveRO8ZtBLyTXEJWEbjUixx9uHndTjSfsbBulIMXeyL7vTSB/sasvH7GMsMiUgF0oby8LQdeKTOGHzTnrQDFkEiq+1sPpU6Sptx05dZHTXRHkRYjeSxl1S2Zo/q/3elSmJVFFyEU30Fwt/SNMkK4iii+HkvVm4uZuvMQFwQ76bZCQIWch6GOCXpVkJ7DdpoYuem7xnj0tquvR10m9AvVf/0xYp/CCqYXHMPXoD3PbbvH3RYm3Q9DcwgM3DK3teWqLr2/14SI5DXABoTzB5mzUDzby599XiemubA13zjnLw5ifBu80NK9BDbR/1bcgv/LD+Dxn9XAeIj9hMVmPmjfjtMAQpfEz8bsOFw0t9iAEIPWYDi7pRjlXvSpqHfPxNToI0hHSnrsb8SYuTunVyTt33Sb2x6IBKoYLf2ZVNZ96TfmHHCSvrmLorgwRXKqN5Sdnxz3Lhw37bsYJlzVa67vjQdimk7Bx5t2UhWE0HYUh3df/ZENTeP0OazWVsfMqjCM9gePsGAhZg7Ltp//fqvGEfpWHdb8oF/zAKttYmEZDLjhSPmKZonHbeFOlzlj62ao2VpO9lULtdvKRWIp5EaDdYBJRDj5yquNJY1i6W0CN5P+uNXOaUZcq3Win12LiSWv/AvJELXNB9KLU98/7KoMrIbVk0iUZXsr5NNxpKeTC2dRn2eoX14XBx1eEVu9tHrXOPpbjWxkMsgNRQkmtRRDuFD0fkJzqneElg14ZNyf6uR+m7x7R+TRMZMKQQ84BAHdNhQCKSlpvaNaczsJKt1mLpMk9evdqm0qqY9p6Mcwr6Unip1YJMIPWLPIT4qEKzAp0asaZ+Dwaun+E4ZpKWro+vKvsQsoLa29P2ZbG8+S93mlL4y8MBXHeoy2nDk4pDM5irRnobktl+YP+YrQbWS8zcVcY9kWiJLGFZf9FFuF3tg9saApnP2c2EEteeKkZhQ3dF+nREStrfNvorBVyWICL/YvWDzjUMPijjBQtlDTPlkuoTpn7Tq9sMflBMRBhUExA+/JsG4KWBpI8cwLTZZIHToCDQE26OZcWoQqbv7DV7/CC5ricTW93CeEYZjY8mXudEJb4axYJ8KWpuyLFLa50Rx+OQfSriauBIlKDIAaMh2rnLsZYjrPJW4VmUf+zNetbHWcTPPYQH6TnXvAYimTMsTqOand8lZlV8ZuD3LBzhEsXoiO+HFAGyMHxvxZQYNq+suEAy7/7wlYd9fZ5m/OdV22Nb42rhwsC4O4ibPt00IycvthtCceGIpOcPf5NAawB/41U2nLlp4CFQwPzoUoVOMod7c2Le/UcjnC4aipcGpNTK0OrONu+lDQsqt+EKYHUb/UGETV+2tyoaL0YKCLg9iMpJmIeRHS2b57iZMjpKG5GV2yklmCUrOmPPCuyHChKP9lt6FmnVeFdZlzBzZ2Z6QAvisf6O8SDt4/s7BfX++UQbRJsc8Xl+Fp+w+pP6qvOXwusNmttWc1nwREx+ZbbjaZ5HouFjjxmf/5oVlFr1sHi7VVjyP1EoQJwgywUOFWdjKBhfk52dmqsl5hiPz1Vq5pVuZ7HDpiS8TTA8EzQSboCQCkDsaALOnmJGizW9OD1lL6qdWY/UwPOpFs7B2fC4bE3SBe/8/8YtenwtRwU/Wq1FENYhQF8BhU4yBkGKXi8mSm+ONe589pnwy9oI05UCZJDtnzH3oXm4YXWHfWH7Gj+q1ZAKmr7V7Py2OGBmGfgKT0yFXOkgKqw7b5kQBvEEzqobH1Z5SIYJ1rLhSDlGx9UV6HTNmlrZ78kamHQUIaWK2w7AlE591MdsMY5ZYtv5WQkxla/KQ4D49HwZ6imGJPqOUyc9ZxFpj1S5GufX5iYPEyIcgsX3d22SbLcjXDw8tkIL9ah0X5qYNomwcbSm5S0Nrq3YhY+qu0gpokQ+yrMauNuc76gmq0Ui5Q+aeWQ3LAZ7XCw4LxLqcJimrOxLQs2ztcyoCtVxRrJYoAnimbIgXt7nDBCTCs6BnPDInUDnNzEY5ON57fd7BKvOWGzG4LCAqv+vFX2IfQJcQ7lcuo7bWl3Yg5LgpZDUsH/qZrxbZdSVKkxo3epUMdA9MpUYZGKDBtOMcTt7/KZBZq5N1qINaWiKUNXQCr6HeBwQQvNWF0D6gekDr4GJYx2TlzQSXKZ+4cjBffVrfbN2BTXTBZmlowb0jH59AXPoRJWXz4G9RzUdVnQSJhm4Ok7JkK5abH+PWAdCy6OgRIPQ2qcQ4Lb+58Jok2t3CCOai/piQkxEzOjK7BguuRZrwFm+ENFdMm5UPzdWxs8x3EyIGNoIl9TUFTqozqlgPD/43LRObzeWOw151Wbf6Gac5yQZvmtvmgJ+lnelZs8/UDgREK6RKb0QLuhYFq8UPXDWDDrPJObiJlxaQTTXYy+lE1ahe7WthzFnl2GE02RhRu4gd4lPj0EjCgcjVzvPpwODaIKo75OLJ3/vaKZDB1fZeZJU1y6BgH1JWVk7N/MyzaRknyi0PdkQDgQHw9YdFDYOAycWS3UdOetqwB3Ydf2LwjNwmMZ036mFSJenmD0L81YmimxBT5tZ3yUyeN9Dbp3iXDXR6I0p3OJhx3F5k4Vue5GcTMlWP/35pz/SfoftQslsZ9GhvfB2OahLPVADN6uc/8Q4VrCCEisPlpFlE9BiBmQisH/f/x0elo0qb8F8lEcX/wUv5yBYVRJg+MMnWuNdTbYOIrE3+DNxQWUnZqt5JSWG20o3teSjL0xRLtW8kE8QRoEKT3zDfFRefRPto9xH5NvTtvlydY0nvaSSAeDt5CUnxLPHOsoUzOxS6qljp/8jarklSfUaDv2KAFnlC2tTM5CJVYC52aQ9r2G752sM3jjgfKsteuV/uvyOqSfgYOxc5wkrMqpX1r/rY2Cvi9yJOT7zwyZ3/MnjMbnlmSI7ESSOdZnes6U0pC0stBPUxNMUqTdbq6XzYFgdrxQOT4dL/KrdOd+6ecXGlJ5rtXbraA2d1P3sWLBokiq1yfnnL5+SHcSFVp6hlE/FlYdHFEGwwZIB3ueRLIUgqHUG5YT165nsC8jLsNEBJ4Rxv2LBbgv9YoVYFvs0gOnVxZTo692ro4xVMTAfs/Rcel+5fh2omO6LyLv23DgT2CBwigN0xn3sKY7cvxhDGS513ki6Jsd8YAZ5jeG0wl1jjEfsbr7fYNOf94MEXIwIafOeFQ4NeBCyIo0NMzo6KwV7J+VufQGIDw0yql0DICmA4LAbTv5Rjif08S+3nEk8YIx3JlelB5p5A88X6Wdha8G/S2HMy35VZfp8kIdLQuzRF4eeg/hxuUiSv+b7crc8zpv0wGNSqmCntJIaA36RUQijRv3DdQ1IlGrYLtrnhCx01uHMXCfC4OJilrL6DUoYxRDW7j1q2RnT91qzcnA6tvopRqTNpqUO97LrikB/Peibaa3TzrmgLFazgSC0c6JoDg4Ykld2gvmPUxnYsCDGPN9m98sDTdw4oVdP86zfAFfKEesgKsQJb698F2xbSe2GYNtr4IoabnEZCIzXWapqFF/14TR73U1boBSTbB2183kHpF5lD5VHD81kK+DVLlUDc+Gd6kLc6cuhHRyvQ3uNOaVAjC94vkgSSWkwNfli8q7N5ZkGRSTGd3o2rEOEAeEAglHpEaZI7dbV65F7g0LJ9NYb2Akknjzj0pADalpZN8WoVf7uCriD0RSBVtCpO3HhtbC6buVjlca8R3jvVfuUW+Z7aNts5KF5ecIbi5/2KIsalFfGqRpjOie5BsZp3y+mEdb2y6UCm0G9H4desTgy1c8bzza+P+m2vmSwXSJU4/ju1HvZLbQvJH6Ok8Rd57TChkEmNgbaQJOlox63rxRbh3WqhXVdjVyuhlypzMVFrNhEqZaeV8DtCxIV583wzo2D2cM1pPtYAQ51brY6fIfbPl5JIoIVdZ+ergYdyrZ54EVA+k5FDtj3HCAUtlOmR2G0Mac4JpKFtuHrJ4ssJOvc8S0CP7WxqbDZCrcvTrrTKiEwlyoz1ib1R/o1AHP5kKcdY6mXH1eMqPK/+ho+5AUFHS672n15EUCReIgPmgTVrxuc+sqG3Cphtt32qkddaAxascpc2shGIm044K+UiRI8k8zixSpiYKGwuWEd+M9vanxbEh+qvW04/pjK4feWHYxqauhWXrefhw8R1z7LmaH5RAbDH9qGxe9YkRdOsbcseYxrROtNab02kBsGcel4PeO6pFyILZeI3NyMZ1PoaRHnKKauS6xDoWTj80+Z7Xe2v/Sxc+qMfifUI283lAEvKS9Q3ZYWfXAlKv7seF3PvhjMq8/CbKgaJOCVpSquUtF8LITjkWgdzduJYgQnjEVAw7k0aDdinERfimO1oHX/RlhMikQlWhLAxet7x0j0JJFftcXNYblfFeCIDOsOk/4gZs2WRMSjLe0blo8kUwsgpjXH8FAawO8xFUdqFYKd2nB4qWOE/ktXi2mSYddlNN1/Mtidb3/YSCaXyWOfF2sFsATM+KQsQsrSVl9MpIuJdcYEHzeE2f91rOaDR4tXMjSW11yzaPUY4S9aODXwYfvAPpla16K/3cxZ1xQyA40CKvkamQ9TcF1YmmJiIspT6CFNL7Gks5fYCT60lRSaGs3+eERE8MTu1ob+re42pWolKUIUY7N0D/doze+huhsrVgRRPizopqU+hRDaP9Ef5/n4lhoDu55fYql/Ti0FOEUZsD9xiyBs//ZCHGFdmHvav1AY7IOeV2CRv1oBZZgyKvzj9hjs8XUnLLSZXOi5jCiafiHR2z3AO7r4ooOVhH4RG/eypc/b1IIjb5+cnmj7896SSFKr3gBV3LcmWmBAHdCKrcJURcOH5Ax5wZggrnyuFf6cuc5P5TnJqj7azGd3+udb9IUajbCZPlmZl6VoaGkBHbW/Q37HapanMDu5FziCuVaWqnFc7UZSWHikbav8ofgM8LaPr+tzS3UISu+JNwCmj7qRd2GheeQzKismIeVoNLVLu84Bxex0DnrvpD/WfjSK4fms7oh+MVhcyLYwcc6jU5/vdwREWNpumvMnGOb1p4aaZAPEzDQF0Z/kt0/VY5jjgj/umo0RP032KGBbYqY/N//+IWqerHZNlKZc6QAAocqCiLMsGdkZtVD7G7d+tdjxDdWVKVM6doUp97D5r/f+L3gQuQeE2N45/Hpn6k0rIIulkTO/ZjoQzR4LNqhlsZ3qUwf/XA1lz2ueGpP5tOPsCJhlIxm2WaifhbgjceN2dVe0YSOd+4HTTP5obEpcd7DhaNuJMzyleiN8SdceFdty0HLnobZx8DOMZunAsX5Xjsee/eXZDIj1KvwkBqKwzkZaQf3QSMXdPj7piMf2+ndsujoPm1ySpyAJ8L43E0pRCvJNn3OIxXlOcFW/x760roJppHKuMzlgTNmJx3CWo3uxtaXadsoeJ85uUSv3un5+VvpHbt/C51i8CSsP+76lyfv9tVHpwvbUFZFFB5xzN36EtTn1qP50AVVJ6wKUsE1SwuMghB2YYsdQuhZoYhiWwfxtIZUCVaxM93DXdXq03J69JRGgIjfezHEeVpOOpZl8K8KIsZRtkEPIJFSloa+vp+EWtMidKg66aOkhU4H1yynoJBXH+VzBe7H/6fUJfaRwgB4ADwDs5u3ZBW/QXAsaRQ3Ub15cOF9lCMUfoT38dOetrdF1UEummQhZsCwX9H8/7O/GOe42Lh9MkyEEH7QLKQhbXEXOaBYfgBHjBbiONaHIwTK/+q4o/TtKGNbel6fJmOxbD6H8ryi6ep0pkh1NpAxhQ31IyUmmvrEE5vm0hZvIpindT0Xgbd/2sEo0FN95sbHyB/aLjEiKhLRKbNv7G2SRqF/HVjJVhmRcNGIzP79VWYFIBwMQw/5lMhRALEJa5vCXdMw2MugRqTwctJ9EinJzqXQt9J3X3cHP/ol9sqJqbuUOZ26Ziu5mnsjXneXYpY2D4Jl5dXbB+5nseZRzpFuOzolydwSTLS7Mjxr2VHSzrxMMKqEcBxy6Q5wYf1dMDm84/fBpmzEFUcXovsBQafoBu6Ec8xPBqC8B4GbQ8xRufDALEBr7weziuQfpkVSxZxG0zsMwUKgEgFNbGTFimINcyd4bU0fLIMYsWuuQd3sU3qc2EELLqnMsmMXUYQGlQcCHzMlwuE22GF9TUCwcqX9rL/LskZhqxo/Ug0sp4+FW5YBi6ZD6uOswe2tNjc/y7CE9EXwR3S8bW0xvuNr1++afVHdE0+MmNtn8nLs1d2i8R0GX04VgRsttoyyhVCQUZurRIEg7wpssovR9lwrr1xtejaqTRKL23/89a9dlBKZqJy35wxV2hjoj0Oq8DoJXrQVFhlqo2Wrl4XexJv0RI7r5dsGs5pDn9mICfD5jIAGOrwlH5U7Mqwx7T2FlKfNLVHB/XlZS8v44z6fzPsAFideDdoHJoQ24AVdq8cXNAHUkJPFKVaR5kmif/BK6ixa6Kn93vvyVP0Spm2MM86ZMmO3mXsgz2fcDonLwKCW2jSd8o/1hXt7vA0VoM6DcbwZDNs6eRu7ZOMMNKJ/6wX6/Hk1527L4VYj7zRgvzNgc5hwfWo7KJmOMy25UDTGEDxL8KUpkSDKa9vtVGfSytu1BY5L7SM4vSnnETyG+E90yZDJrR+P7x407PG1qyzXEZrUZBYMnMQ7BlIjCxHsr7LAlUmRRSTCYf1zFhV2EWQm4JnokE+dOZRbBppp7CXF2669WxJb4rGOo2nBi4yOBjtt6oazlFbCo/gdtPhRpMAv/cBCdH7YYZ32qX4hBSc4TV+gbPMAxyhaJPUdTB4zR10TherRn5nudynK5AnuutxEtfT+DoPpilYKH+jzrcnAt3xi90SxVhJviYgBI6+PN/EHXV23IpV9FYgbmBaPiUV7WjMZPi93j75ITL+c3GID9u6IYwD5ZCfAsFqpzPxasysNGdpTw0zp5tbrdUvL5diu+6Rlr8YtPTAYoYaXiAZkBmlkx9rh9jxn1kKFkAHZzmKnK3l9g4CRuwa7QiZHZC4VgeIaWfij6jf10q7foi9UOMhcbR7P1ZSDgQzegPFB2X7dxFTeXmI2RKnTiSLOpNM5IIYxU3F0skwElI8wv4UCyGSSShfGIBX8Mk6j8FkdUffcd/lxp8u/d7kBnjsDaY8xxX3AD8VndrTORfXgLAewf2hB46bIHG2pdok5rHtiRtWebPa9CuosQe/D7JFe3Yi3gj92EVxWvLbBcQHy2Qgr7biTAqiihK+JoqL9u0IQwD+udGqNdC0fUp7aPkc52R6NUnlOpokdDCE5n5vTwPxLDjp5u9haODdZQFjaVKfr3kMQ1XpKs+Z0NZy3DvutYv0M5zOLtgdT7/Ls72q3q6P+5nHRQN65uhqNTf5fK8DacqOYlWgFvIdVSsir7lKxLPsPovGHl9BWzA3AeRb2y6XmM8n3i/7c8RjJ4OpLwXTSmUbYfy7jgNHW+mfPMcntidM/yYKGo1rTYlMexQP3yrRvSlqrXkRFTNllmdAfin3fENjVVbV0SIeKgH7yI6IpcZ+4guTfZjv3bT3oIkQPTq0sMgLambQMP3999knulymYPA5LgrwLOBpRRzN+VyVoNwX7Sf6mnrhml4qPURpiPfFUpxlZdVkl6j+ZIvmJl4PZWJte32lfLPR9x9GH4AAOZZNUp4u2O7nNx7q791RrkD/9TSUCJ1XKtmxOQYA2kX9kxBkYirpRMsZyBXgUSEyMWVttZZ7gqLHhRd0CWxXVRRpe8faKbc6vwl4fM5yx7WcwmMhIx++9XomjZBvXF+n7RC4Rl5ALuSuMDzzsbPiD1h/LKKLMNa2yUupfZToHJQbFHJye7E56IdE9RaY07byEy/tZ3qaiafSgX94lJnto17gyu0V5m9iMwBLsNUiuYs0sH7K3vhEPVFEfcaHfBL382FpScpA6NWHujPK9pTM7CK5l3vfUtdFvA13p5hu+cHjlVRlCU7ys99BjCzaL7gPchBPOkcxpVRRMHQgUfOGzIYyuOOkPzP8KHA9a9oWyjELbqsdJOIg88YQ4UWgp7ZlYmcWxwVKw2obxa2zmtATpP17MOb+CgRC1oeGdGmmCwagaUSVQFh/ekfHGERZArKW2SHua1Ludlflal70U7U5kGlauLbHOSz1YGpQBPAlMunj22vvqkQ//BtpH0QJTY/aJD/jDR9SqF1H0gi+h4nH95vjlZ/q1n055xzNqrgpKvBm2C9dJM6xGkq0ehaIDxy2+ranqe/XpVvVhf/+4jgpw+fyil3oIrazXpYLcpt5jcv30O+1d0/fzd5XEmt38cHWfiBdqv4k4cwsReGANBPF3wmIQmdlU6aWxHIikCsxKNJdcurQzCGXu1gY6dRTe3VJN0avieap7MMMVSmI7F5XoH0ka0QKYLytW8V1XiHCZP6SElBZBEH9Df6uMgsl7E2btI/iSKOLIMwoNNGYykwPYyrYJ4zLB0w3Aemp+rPDIs0KY+Iqwb3R95N4YQY7Y0m/1XD9/3l578hF+DXREpvVK/Vwpoj79ziuDSKwKYL9wPLkQF92dWGh9MRRcgsNhKRzveKa1TTSr5b5cQPwA3zFhroudiCk+o6uRYHssu08anTV3lo1rqYLJOXDtoYpe0Y0BSuB83dK4IUn4SjQtedXQVyIBj3C1dbxBcySVzti4wyh34O8yM4mEhFBZVwIbNQZv7GWUKMGSE5Xh0RNbPuqOg5XCLxy18hxw0+oettTJQiSEpGsknL/L5jiQ7KRS6DDQPB9x/SNuk26KQ/zC7nMwM72gVXqtgmm551YpI/enNPaNp5BdpLWCQNOlMtBHvEGRsBcJO+8+iFnSVSqJebdR6V7GTfFry7BJKhIgrQ+GK2GzgvcSlI6aACqV0j094yDcVWJlpplwweI8udyUt6s3hCc5zoT7AWDJNbo7WVeBn3okolIt2cMcHC+Bb1Zsd98nAVYns/3KbvBGveafeoEqqUR/B/rpPaVfUuYirDYsDTfyKONvLXZqDiAGcThXNo0d78+aCrYC4Xj10ZvYBrGVxvOPXnMZJM4WOUc4micr7aUGJIlc+fsZQKrMjD48D6pFNzfgAK2gLu5G7YoHlC55JI7WHhWgL86Sp0T4g6pIMeqCeq+BLEwQz8i3b+9h4v0E5hFH1nOAg5BOeVo80zcq2NaaFuHmNzgZ6udKxXYUBIjUSQYnx02qnrpkvYaMVY5Dfsy/AdeDM4hnZZxDhpG0btpbmK+LwsvqkddeAG5+zizLH0hQ41OHGvRInML9YkEMnL9tp2Ed14HWJIYJhdM7Y3Doqh+D1cwl5e18Iq2jt+LA/cQ1LrQSz0Q3nZtwhktASl5yo+Cm+aquMJcI0CdDSeEXNXwmDR+TYVS2/kTCqglPugor9EgNdSI96KbDs7G2n8M4uw2N7sxDiKGkVeanAEuK4qN67boc4RpNxYpdZxWGcXRYsGfXjUyV8LvxptHk6ivd4Zf+RWS1y7Y1r6h8ZjvhYI39Y5McGBfzIvva5WeZtDlV3MkZ4UEON2yLBYXVQs4s6TWCJ0dSG9U2bTcws5a1Qi9M/PcQwY1fcQ5TtrJBs4FT969iWxRcBpwKZBjqu4DfIB9ASUpn62l/26I3lMAqrcdA5YHFATsSrLF2KKuVm/X0JdoKD21VIaf4fBOTtC0jE7JUtgUtd0OiWYwOWuoCuCCIwCOMExdzazM9i5he4NBB03et/nHtCdk7eX9Ad0/mKqp95H/XPaQObpxoj+LytcsMT9V2yI/2NPq1oQlt//vKMcTuKi8tIvwNofpMNn0/c/UgZ/lgqbNtZIcXdmZdCbFl73xXXJj0je92j7+FojLoYQcnuFoHNHGG1UrOMAhJylURw8NO3Ghh+v0nTAztobcZposZNbreyUSZagEXsXHhnO1hx5rD78SWKoP7/JrqwqoQOl97XpCtLoMkjhSD7E8OV1mfBay3uVkY/XCym0gRYFpSkcGvTTcwTpPPZSj9asQCEA2+YTPLq//ECXOEunVc7YmPdTwehtI0CguwWY2rC84+WGZDWidgnFPCNCGltfYjWOvQIYGJcoAwT+8c7qeW2TMB5JUViYPZe0KsP/lkzuuigmLrSk/fJ1Uoqs8RmRo/cgbYAuhZrKo6lVSyAE6BWjnultU8qaPSfzE1aKM+z5ewVB6LEWHeUXaAqIJKHuPxGhtP1yyPzQliIGd4cZTKZGHRad6uA9bBAQzIOcaukYd8diS0eYfhTb7U0bFKoNdupkRweABAVSUXLfmPs8OXxXVToSc+mMUMLXf4DfpsWAYOj/mImffIf3C69RjAtiX+ssTfCxHNga36QYMGHwtTsLAdaSPWm3z3nTWU/igrARDJnn9zh1xOsCCFBWbbfxAdfJT2lvPIEGhL/PThY5EszTFR5aM/P3E3B57ceryHw1QYJwS6NAMsqiiaT5B2iGdhnEmOZOBhm6yZ4COlCEfaR+GN1ZGvusNArAqaktlLvDmyJYzeIqsragzq4dx0VY+YsJbg6GMXfSpis4b6FTh6KpjCdbdswc9HpHnYSzNCfqLRzePrkGtjxErh4x+EUQOFiy5xsWqd+SVHtl9zCRfChoFuMX4/8eF/TTcTAb7TO8V3DFuhRI4V2paVqizIF/KymXQV9qaY34z0pPU+EkRphlMcmN6kCEAePT18sBLmQ9xPrsLIoncdG36kraE/VZin17rpRIbD+MY80hTi7V83Uyk+E9yF476OSK+taBw2KjpUwo5xswAfxFnIi2dckGUzhgiYvVYNoh5Z4Yq5TQb56fewIDvOTl4odMuardqQzspq44fsBzZeTjwqQgItIecr8vc5y9zV+BUw23MToWsf+QLlJqG6QHskfEzLRz+mAaMHjfoiQDE4kmiBIx+J0BMzF3atBnY5Ra5O3COfXreTBYYJEq3uhxTNLOMx/3Y13g9oEKrj8qvkAvU/IiYq4F4WwiuxsHwxm3K3Uv8Nv1qGjzOdrnOVDPTx5RAAZSUwnk4A5vFZgA/P6R4pC/KVMFe3T6lVilsp2hdZxwOX/cCuoJq9yetBRvxi3pjS/xHVI6Nwnp8rz7UAtr6pu5HoY2VwbRsZQ/VJR1aveLuiTRrIisJtW3pYmXhY/vBcI+rFiv2Xd1Irm/wDdAkhjl2iSvNkYRmCjfpW/fsNR9KRVKy54nFEqlrp25qDYQMt0QZtCSsfR+x6LYnspCvJs0k629UdIECFK44EZuP1MaIythD4ARg7RSQwAXsuKiGe2d/ENbVLL/wrV9olh8+pjPEefN6qskERI7+dR/foIJEdB3MnV6lZzWL2yoYITia7DeRiL/oelCm6fcBVQYKD0l1EJcZ/azdEvEzJ9g6mayVWQf3RMdIeuj8jjO4qNXflgJY2v/FUQmkGYA3FrF1S0bhwD/xzsvuewENzdz6Yke/juWKU7q7zWP2bCwZo0Gamgpx3IsyCPrEJI9W636G0rAOqlHyKWRAL9u3IImRsXvfKG/rb36lOnqlGU+3bfFIJs2OOuMLqC4pleNRiU/WryK6wajsdEC/MCTnhBQ1wNksw5Lm+/0d3c7aUuze35L6yXl9jrd5o+3dK5bLQRRwIq6sOyEstWivMy6TmDj/TTZ7oFZh0nK/fX6QN0U1tjJU/GXj59ty6maI52v7R036fGghXau2INdp+UYXyHxNrrRZXJuaRYkQRwE3a0SWyQgbVENhqC0LFbC8RQd+cwGnAbxq8cT6sRJmPD7YQNavo9zOco1SNCNhxFYHfQyG+0SAkqbKIdPYopQPw7OqZCCGvx3FdXbvyEN/Zo1+DsWqvln8S6aXYyVguLUA006e6GqbS+WEkrZkxPYUUy0NzBkob0ChwVv9hCqlBcjFGuFZ6PwjMylWb3hGwpMDebOhzeo0fL/R82Cr4f2WrQcNNvHLyDknRLiP2LOAaGDxJOvkR3rFbgMoNU32CqF3btJg20w1UnAuJBngVDCw8ULWiiaEEgmw3+13tAz8B3Mn2AxC+zEo5C84q92owxYFo2SHUYqdIZXveTJfk8QxmFYxp1K0ifK4qfd9rZfNc7TFc3jq6CyK6eIM0WoAtmM1hP1JDmzEJznfnTR6NmU7/k0vuW3hR98X38IGYRXxVXCuibBAYK6X2HmCVYXaOoB9TgckQzUosg4HVFnvRXdxbMYEqZcgd2hMh60jYtqM7inAg5+hh66j28V/vwafd3dKIer7IqBmG7idUIgdpF8QE6IUUSJj2oVz+z8IItl1waT97H6rkN3w6HGYpHUGTFOgnCEXw9UIq0vBTiG8rbgHhOvyX/jgSYxc2n0ZcBLFBnkuT9gU7QVogdlcIP220HOl+XpnIFlQC+CTu3WssGBWZ0bSYvPEIW6p4kLk9MiqVTOJSdnOKsneBQk3j6d5UF7prucm4lAxvmkK26rEP1wBVubFWANuxki5q1ydlM34hLOfBte5boO4E3tlYwuoja9wMwCzmMKx545361fIjUoYXpOQjx8wod3r3M3vKnfJNjwVcdQAt5Zj23PMLcpqstFwZjJz0JZOTtBajRjAA7fm9wvhVOoHs3yn9ckMJvaMSo7mJPjmzw7k1AHt/utgRqYSQgLJkj2hb6S/qjl57A8Axb91O0JsOqgul8ZyCir53HQL+qcfk7wVKWibVavUstAafOqpxPYWMDxCTGApswBBQu24ovTM7IOTX0jIv/YOQuM6tTgU6Un1CleIWttNs4KkZxHo+zL7kjK6mH4KyhVIWJGrsI67zc+UiTMQb8kV5d3ztrC/Yy7NmvUXuqsvQqXX3C+ZLndVZhvoNy+JUgQ7EpeadsI2iyT8vW/kw1tFrgg2/FEjoI2BywdjGPvcIUxo/NPNVYiUGJK1jcU9mwp3oFcYfebC9HQtPlzdoyWQu/JWPIdSCvnBI+n3ZjWjmbBJkH1JAvR1wPzO3Y8SU1uM2xIAk8W0duABr412vZOZIDHMWubNSzNuo+wpSPKtX3XFTuwI22BddDchcieh97/1GQvhtQB0gnvu7y/w0VNifUiPif9SjumMBD+mgk+ILQnA4DJY559nVO6qwabzLbdx2SZnHNei6lu8HKHI4rGA8wnsoxiNe50XqxULuuBeFoQPA0VUfgxL9UXKIEHMpoYuVvwaSAXoqUXFSYn1IynfW4wzzLS/fTMuNFj8Eq9cjiSHFgsd6Y1y2QN2ohlcpl2AfI6tZqBPk2aP6WwXeXDkRdgNFUgFx4vHYLLvQ9Ps7EoG3MWzZxMlDcq3QFs1c3R879ui8wkskd64hJpeprmustKiZMeT/hzb3yoE+8TDZJV3YL9+UXNS70AjY5tx3fpHiTLGnfwisanRMXm8cvU9Pjr6nymncy9g1dFelXjROP42XhmobOtoOvT2I9fPCMJs3ZCd2r8jznc9nH1PxKLIiAalqy9pVGEuZP1pMpGnZ+sVGSKjiyqeQtiI86pD9CYo/NrHmM2HbVfVNRxfXuFaiUDmG2Eb7TYUcA9qQpGXrhNHSP6GbkVeZs8SFF79dCFvyDjmdysCBA/Pdd0jp4xPTO7y87fu7DRKCMugHEGqYqxCk9QS6etnirDYZ3uSaDPg1Uuy8/xDATLdSAwyMCZ5UlksYzHBVrcupuAgYdl5SvkSPre46pxqhENCQWg9T3errF4Akrg2LYyWvwOkt7MEtsIIArKoz+J4CSZzTfKLSTa6O0lef8GPN4nqctHK6YK7C97jGCLsfnGASLsZduXCd6a5xLPAHcqOVPm/OlFAt/Srgco3cJUNk3lezvZCWmb4xo7FjeHCSzQcXHB8jP5zwzXZgEScwjGtNt0P2qnDOuYJfzv1njkb8YS3zEixVhnm5ot4ZcEuggBUt+BYi1kTFrUpZ0C9QYuTCW+3oZv1clJ+/C+aiXE6j5ZtxOcKD3frU/Ou9PjOJqdm5XWe4B32Rlhg29kRQtNvE89VVfKHunRsNasZVJbTfreo1pzD6Qj/xR35vml4m6rl1dZ//tiwcPQM6DzGBQDNyj4LPEIMtg5AMJ79lu9CNiuMBm8YpsPKxm83jgdKBRxD9Y0dCnz674F5EoajzXkVTZkfe9FiAvBnxt40bWQeiIgDPiTN5XbK6SD4Ey7DVLrBrZ9sY5GNx5C6XEXMUpI5qsUdBrDYX5GkqzbB5tuv/RPDy5pzvyl+BNuhzZLf7FKjb22rlYW3dVfVF751XyhfP1MbSMA37ApG6hIoRvVY2f4/X2984ETEakY8qaLEQAVD+9H2KJX3jPglpM8PbETsBAq/jTqEuew4QYDQ8Edp8t9i2jeMOIJ7tbt8ZAZVn7XJ1OChmd5W8fEhwu9GwvdvPKR8gbE7TSXYAiau/QvpYcpx8WZ1mHYQDggZL2gue3xElsQAzcwFa/QI0fDy4vjamCDSG6oLMTZBgAWTFUh2KGF5YC8OQekXTbuAJ5s4+5an3OlS7N86HmTKj7PEzWfwuMqlLCg+MikcFVvS8QzdYKOqflBUmfPDFWlptoZpv0ik/659Nep4lEMa52odSQUCb1zYr4wa5z4TonpgPybIhe3mgaD702bPDyEXpbe61wu12v1BwVfR9ZYgOVLH7R9dlf75T6USG+7vyJ3kmkDEk9XT7s8Ue/xo2N+l9rSSueBk8FmhSs9ZhXI4IU3UyGx/6yafWktl0amM5xksqC5H0lyAWwCz+61ArwFvTLf5e8FJuYK6mCs7MWxHUbH8jeyPeBFTH5JI7aW2XJzDA36y+8mmkfIXkZWrrA4X/H5427+SkNxDDRc62uLwa5HO69Nm9dwYrbJTOvzU79wqw4rghTzX+rOrbpO/8SDocwJTWBUc5I4aj7X2qgLNs9pgrFr4srwLNvNZzNBkngTHLrZHcNd98Eu7eBDJ2Dyef2Kf85boU8LDA0WyRTWtwORkcDhOVmKl1ijWeS0J40hcHCwXHuXI2cnmLolS3J6rZf7akJGaR8PZ8XCEDtzW0I9hiyvAnEmEas+pBjK1wzz86kHP6vQ5cuUQihc/2Tj8h9efHcmF/N7pyeE7HN0cbt52kO4yQQzWipEJcGaZtRpN1x5JhYBd5NW33N05Z2m9/JT6HW1G9KdRpphBUjNOKYoiR0wv7Rylr+yDGlAT9cQDeDWPjnuf4woNPWpP2vyRd2pOGkI3+FMG41FUAP9mAz++IqGdJXW1LxgNiuuj1gcsqs64Ins6TM+OBYrpmVYYNYovttuNcHDAKq2/4/FXEWfV9We7Er3njc+fhhz/30oe1WPFPipUd02uzTJRzPO6n0DHviCMzcXSRT4WSJKhH6y8jqokJWVoVbHOps90/SV2GCKs7MRj3Agu0hnzdXFjT9pKx3wMQjsf3up67y5EWun1VKPQDdvAeKblZU8EApln2LZzBWRLV/bYP60Prx2qZP/bKSHCNRn7AxbTbEZKjc5FnRdXKETlTgWwl59Tgh5VOSer5a5LZv+6KPzqRZabmoOwlp10GO0rwoRzG9BxAPNRUGTKoXgj/R9ebl2ceRIbs9sDtgkmrK/JiLw8QETNKFUwGL0AD68tsy1ubwAXEKFk7SSgpPmCMS9/gHbmxaBY+sEbxh3WqWAD2WQdaerk7QUsIV2oPPom3j3nlT2M5RI99aUD0CDrX/AQ/PBwXSofjXJBdCtMd1bslDM8RiXv1SyhLDnHNG7D5dqtLselNjd2753Kkhg/mNvyUus3zPW09bZcHf9Cbh0/g4Z8oChULceNHkgWB4lSxnGW4e9XR6IBIBHY/wmH26wsnqNR+eb8WY/SYE8bSmjqqssTvq++MuwVjGQFku9Gri1L1ridA8aCNs+SlptL4cs0oI9x60ubD20Mc08WPtgLkSJIw8dwyhroROr52QoJA3M0Jdo3pomGZ1BhbrQw60/3Je5KRay2h/GW5txjZAtLNNH1GD63LSQdvwo5brGJX6XGMsK3doEFofmy+7QkWJXrlKftWN3vtANK8wr9+c8YchIDq0NWG5OSU28+TU5EhJOA6syQ2veqXIvokHDZC2UvTQmLCe2tPk64sjpeQgWzW/z2l71lza6wnWD/NskMbaOkxEh8/L7FTHxWvnVD/7rpSGjJDCEFQ4fOQSanwZKbiajTop6tlYgeQAQjVKbP0M0n0He9xgrCO/K1QPz11fawKMxktbDgOtBTca5Fpb3uaF58s4AtHtYPO3QgTAOMObGh8knBQ2kW/wfU+sqOyXnJLM38MPwYXFLYM7QdoF8Sm/eHI48wTl4vqNvyLCsoNtLCrDiL9Zivsiarz4il3ZEhoz9TR4tGgogpxuXUisNjAG8hDlMeHQhKBh1jDEDT3dJvNKHIBUGwAXD6imygDIlHb6VKWNuiHey9+3HFmawN3B6bs3uEWRjvtu6vxr1lpLIXvUac3haRg6uE9QJznoheOK51I8x0AKU9lsm1JDxpHGVfDQuwXi9nWq4AGZ9/PVrGCRmKafdFONOkzmJQ9kzbVjizaagB6p5Eeg+/4g2BsW9gb96VV8vlMsraldrQDNl4cE4m3QbeL6Af1hf6CLyLe/BbUfd/dLYqXe/NKRDv6ZCqgt1EOy5aHNDnRxCJtbWFiFCmd3by0hGvxq8OUE0B3IqwzHKOxh42xwwGz2/2eUQPj0j5mAhBm/0ZQVx6lCyp2+YQu3scatZZwF0H899OhgSywYlEYQ8lSgRCTgi9a6Olbs39iXkwKfXsVrOTdEW1IRUos+AH9C8Zrz0Jj6AkOJVnRCD9b/emB22WR4HC6T3ggsI/4vp9b7VnvYtZQNlbs8lD50ql9qPasL1Rlo9UIKtM3vQ/h6blGVwMPQYG+sZLCzMNskArQGkG/39qkKV3yADSJ+UBntrYlQtr9akJlqeL3BkZnVf4skrJLwoc2W6Lja3HX8HGovxmO3QI9fm79PoAEV7eGBFglhx1By3kRc9ZhZkdUH5U27xbhLNUU2Qag/bidZLupKZdUMwRGqWSNaa8xhNXEJFKdAQEH0C+nSVQTTNOuSvq/k0HhUYhf2q5k4XlhM93DUsYoluF7KEzF74lO12YXLrlpYx6eKBvRhdymDC7okQj+1BxN5KfCQ6BYQoNBbz2pbHtP7HzGQDWnNjIeNh17XUlX2cIdTxxiYcXGwbIObJHectFoDK4ay4H4A3gufRlKGM1OFdCN2mW4JBVWMI9OJFkLSOcx37QhavTUhO0mk9pfn7lGRuT2OKz5XMmOuwl6QQ8xk3R7u/npfrUVZfPVJsxiXP5DGFic6xFVj17sBQuPX7DDU6rEYQzuwklvUaN7UAZVLdr2O4Gj3Oko7U2SS30wKledid58lrgNpOgpNnUtGpkuFFc6F2U7XZa7006Z4mLdDGr9R0zPYPm7hqGlZhHiWxJfYzoCvkKPlsdAoidPnrdMw6OnBWb6GAqvYHVyPYCwauFsavMV8fCv8y4BTYFN3ycD8XzQWcaxm+Gh2YZjA+rde8ghWGar5n8ViqtYaiMmn92ixxMFJI3V6hAD5NzcYCxIcPNhqm8s0/rF0zHAx4s8qCGRDL1saaIFMyygcFluXKJ6pjPgZFoayoYaeWcjNGgScRn8+rMep6gJs1sRZGLqDGh5QriEtDs+e6hR9TLP4txHZadMk3hG8i7o2ecDKYJKko6Fpe0NfUTUu2V8tGj/cWmPJi/HR0NYFjeH2l/vQdVB2uUX95+6puwx3pGmupLbg4CelccfYV6fwYE7pi1IJwRKRFsEuzO1M62Otz79XkSWT69zvmMs7838sjQEpMJCZg+eIXKxp1Fj3lIju6Q/kF26fykPPEeHG7etu+LZ25HTB1ORsIvsi6SIvgkpzKOFfqBNllDclYf3pNCY/4h6idKtbinokYWkDAFmlc6akrCWJx7KTyVpkLAksu/lMy02XKmF5RRdSxxoHqRlp1CVTEM+Iull6st+FE95WWn7RSaXegTMviW8cROj+cgwYFipikraN7zzVQ3sQh93zVkHWe3/wMiruyDKft/Q1t2dAh6mkD8/AsxCaaAfen7l9yo0+8cYiTcx3D0l3SSNMEtft1Kl0DmoeMwmsqyVghJc936B+BNkJcx1YE/EALEiOULhQI+n6QbfHEBWwxGeDsREp+tgcc3Ca3sZKeX/bOqoyJ2oQyX5BIkBJV8OBSoosz9NaWh/NEHmn2eHDqXXRXhW7RltsIDCnhJmH9bf1F2pitJujhn6Bca70JQtS7rhTeH8JcYrlDoNY18aDcV9EzAhPsGIa1h/7Q1pDU/9NP3TVvJQe1SK8QdSF0bdC6LC1UiO2ejQ9+TLFQrXfMiQSW3pIUD1fZ/krXatUnyj+Wg/WdlgsZ7aGm+vTQumEQ0JWftvkqOh+AnKI0WrXmlPXV5fX+IzpwAtvjte2GkJG00kekNN/grS7U9r5ArxRl7ErrFVKSBJAhNAao1DzvXEPXnPiCtiptjplBLhxUrfmlFfdLG6AV4hCelr7Ya3YgEnYAZ8fcU+dwUciRlIhVyuV3N3FKP31xOndy/ag6YhePg+WNFiXELXZB94HaGe1EpUYa13ph17tkjyIplVNkPE0NILJwumg+M0NBPw9L5tF/KhOjuEkKb5vMkgFiZ4CAyqyTGz+PzYhu2p2UIZsN4b6P3urnsdv/ajU9GHmnxYReNTN04NWuzDJdm8MqEbZRcNWR3Cxa8M0FbTVP+mhpQ1EB6JZl128vBj11VR5KlIBSdsm2oufq8XIWfEFUsEXbVkCpbwp3wjY/TLPRLKdmlrUnkmDcZQ1iYlCzLw3k2j+tiO2eGxwWDaig1+F+W4nKxSJELert7DRLuE7FStEyIu7R/Vw3WUoIgD8/SVwd//9wpbEEvYFg1Zf0vd7TElXS+RucZOrYxQCMuiuThNIsfDq/Rb9w9IJXPcZ6VkX53SSNvxGzZMW2Z+fqMoOiCmDgVcLFolNa+ng5qOQ/bQq3RhcbjeK+L7c2mZjdutg02wbY1yqcGwsE464ELoR+H8owo92sSZPA78pTXWX4+0qxeZhpdNyL8dafFXtujTqRehs7dG9nGy2vl4XyQaZVJQfalpf6OPSWEpE7vGayV+OkL7qbBkV/5isECEsfDI3CcgoV8mAfE9tXVT8QstED+HNo4EF9lRgzjWIxJPtSCmlDTH+Fs9OC6/c475UHPKnXoidtQKmg/SBbtWy6j5KO5cXW7y1RWcD8mfHimHWS/wWc8n5TnXv0RjL26GGx6v5slYM0RGE7bfZanilVjkGHDRnAFGvZlc9y4I/SviBkEea5q9OvKPsglOkbuKJJkRL8qxY+4ClegcETnhr3rLSWMzMD5Su3gWLBY3d6+fM2c13SZsg3EJMC0pUTSoqSnhzb7B7JsMuR6SGiuDcQt4vlQvtOeaiFjY8bW8sxCUlD+gGkQzZzCTijgyEwI1mfXoQRMy8Vo82xH7mMqlG6eCjtgiAAY3B3vb7rL1Ja76rCUCrKOadQlEdP952GuwK7fM3EYdFnRkRO22FNl6bvfxIs4C3/t7xk1CEY2exwS510SPbH1GgQHLP2P5LIaKCiJKZIq66jdixBEJHFYfij7kjh69/eNTaCREAsNdq3y3w7fH+TXgrafl4nuO/8XjETRRKTor4nb+BDEWDVp7HDWsP4PTRUR8V2VL0B42halZ+ZfqD7u4qol+AnArBr/BoRnxcB7MvmIvoiCShhL9iYuyPBKL98htYoANI3//iI6K4WK6F7II9v0pu38OrBFD4yViGv3u5pKwKDpOFVmHzKzPOZuPglYUWiEd8yb79iVnmUmGyY9nc8dofxoDnL1V5ixrh+qqFA3ruTXHXmibT8KylcwRWYr9UbFngrPCNGxobFsZZCKGtLxrIf2jeRWxrSe8w1KgE8wrUimHQKhJ6FY+p0s6X708DUodInad/rN4R2MJY53wjySHRwm+QGnWykd8ZsObwAH+3YIIzUlepef10VEmOHGvmeaem/dBwPxsSuhht289hIVOWvqLCxVB2HtbpGQF/tGq9viz3OG2UwuCb4IAuJA8RinYMou09rFZzZWMoLsguHNPXCzcp8E3dx6Qn+kVxiWv5JsKOfqdOKMPxmyySrEqshIKufz+BtS7J1811uAaDHrtyyxZsGVTVFMwhkNrqKlLjkqTVQWD05Mt0fCXOssZBJoFk1+9b6Ftw2t31ehro+ib3olkDhTdqB2wkerxCzWTSHITpOz2s/kkQkAE603hsHZtNNFPu8giPNJmlWNNznkFi0s54rzXPGS2uh5qhw4nTBxSH3I86Tyg3q+q1rB2nHp5i8RtAeBZTmwyy5g5BHR1bR5MCTPA0PVCeYDRg0oQSYA6tZ0A+j1bip6/bvELRNn/Bcv43cGuM5JkrP0XDk8VVlPl3Kxcb2IApU0yUGb4h82CPsvEf53FsNu8BXgkXZY5FEW6Cgp9r4C4ZPZe1MTDF1F2s+prWtOVqyHPtH/CnSqd8pSfNIVVAEczRRBwGU0cQsVzFUhsmM3AYuL6+u4lZNqaeWdoWF+HQKxZhCrcMFPeKlT9FxgCwhYovhm1Llm29FJtJzMBclwy57ftvalTYjto6wquYCEZG/T0DVHlIWyP98/dmtZlzkAdEKrZl0muP0ZCyXUBOki6iF75CjvdHzhV6xIIxjtsOQrqFlNOZipdrScFPVgcNn4N34aEK4Y64jdmlfowpF8iyyUnEHJbSYlBlfaf3phqIS4qwsX7CFNOwKrCAZS0AX3Te91jewbfYlZe2eONeCHostrIFFtzRCeRIToic3+L0q4YvItH4uNzUt5x/wtf7zCusKJ8lGosDWjNEpTP5kS/zur8bkLLgrcqE4qLbx0prS8xT8QM0s0acRj2s94jLLjOoHMEX/HRSE1Vjy5bKno0HMwHFsiRBM32I+AJcccWBlXWPNczLw247NjkzOohrHbePj7nm3OKm/fLvDldjpCUuwpPMUjDiR/co+uB5omehulfmzaTYf3lBDhszgL9GxDht4TqpwfzoF2vFgyVOrj2tm/B8++0jzDbmrLNX8ptPCMJL9fUP3it5jPKLqMI5ORLMWX+RFjvA42w9R9xtrH0Uc6xgHD1X5RduNQ2UM9e0PuF1Qdgm0oZTyLP34b5dXtmssnHFttaavDFFvnTvUokfalOL3auaOsI/HZHurZPnbwJxY5O29xoegbNE1mvKISwkA3T8392HxPzIB5Hx7RLirBdEUEONsho9/1ZZGktlRlSZYAHCok/aUjUZGE5lMq5ijhUZCYRgU4wbQP+1qi91ein+btwbdU3Qp+yezHoB5aVIvUMMQEAoPWfzDRqScSxVT+RFibmKfX5pskTcVDlle+fiyTp3RTHK86xB7g+yTKWCsZlgdCaCOyp+NlwrAIoyrnYIbz5jEK57nGUfCTv2ZxjSB4d5ZOG+x6h8sOv4iXjlHCSUwYr3+tfDmXQI53YqKRBXvg4HCFCspSlSEwj0SPKqHJ3iqBH08iP3eeMDQD/pQhzRo/FWj+LuD6AAyKKKcdi2K/W4hSb3i7XXPrsbggsgRFvJEMoP4atN/wwnEi2zI/Q9z75RJukcug2ZnVSPy08p2GQYH870WTmmInmA0vP6t9nQdEPbdC4DxOLMHxxZgLWKPBRcbo6VTVmbQyUsFVfYxBOkNISMa8nygbM+JWagT0tBFHv7xC2PD83UUbcT8di1Dp4gB1NGmWRK0DwzTeCHgW8q5q3Ayw3wlaBmh3p7jQxQK7QC7xhJV0DbOyfv8z9eKK2qVzUYq9vlCpe55Fw7wutLM2RZJKfuGECCWhZ7Qbh6EfNoQhyzh7Kdr4daN2IFC3HkYqrPUjywYGXdfT7Hx0ZTqcbaUCaqfIVRB/ODYjm7YwaO0ME6aRV5rlOHY1YoOAiPebrEd0N/8CscJ3c3TksrhDEJqd+PlncKuxGgOrqi2oxaYL0tA50LPCsIIUJKZqRyIrMFPrrvi5wT+9+BqeoTGuq5DOkdakuxuoNofmDxr+2K2CvBBfWzCtOewu3jgyjNObNS4dZx1IHDmT7Ek7u0C09cnZClc3bHHvU0Y9PcEFbiUGBN2uORB8Ft8xm0Pg+vSGBmuJiBrP26f+l16bCAYrNU7HXrxvNlnyJayAbVDD9PxaYd5PISpPesy6l7pRcWGJEuMRWgep3P95Br970idbEUOWvKng4PYDpxDki09Cv+/ASyEIaYzY5dk+hQYObmeavxKImgLY+FFlm5QkeF/hnRZBqparBaNvqi8LjTxMoCXC9sw1SQKsn97DwhtsU6RBucde78JIx9l0u/MMHcOHHY1qkEx6fN/5U91fxA6kuG9CZS4+zafcF3jJXPynvg4NL8AHJKD9LostDQXW0kz5hveznhQh+hVqCkEn11mmE5/7adKoJ4eaZS635qE1N3I37EVGYOg6oSodEq4O3ea9G4gepzqikHY9VcEEBWywJ7nbQ8mByRc52l4IVdV+ICudkB5a2yxlcq1D166bcuAk/wgGrTbgmQGjfMj+sOLmNH0oz1K8kQbWaOIqypGnSXFfwQBeZaUdCfzJgH5KR4cIzMbn/zkIxAdBD/Y50sQlb3jm97KWUCFWA+rLLHFX3Y710MXS//d3SOlj/sIQ2ErBbirq7MGl2DIZ2OWdTVJto8cwLoceAm6DvuPkDHo17/fkU2nxiwT4ULY1FmElSW6cvfem2+ixd6k1dt3+s+wYUj063Hc1+26p/ZVPsYJ/mnoXK0yAlzfWllYAfhGA+uKiGT4AmN0Hq3iilCuM7V02Y6z/xeUn8XjOVsF6iEevoLmMot4tUjw0aqcIEuZLPv0uxdctZsQo4EvzFJanLL5kk0fuxjRSadwY4W6llCkrqwIzbDsTeN5sKKj09MKdZqtmqlF3XLCHqFxczx9ylfTNQTtahf511As4lQB63MXKjmWDuoR+Hv3g1yhsyBhYCwouCIJ+dk4KQoa5ZCwmHXh6lmTyGTYoSwR+0gaH1ygRdijzi1hEx2bMd2x4fhyzEpOOsF/BbHTon5D2hvuEdSHp3jhkevZ+FvYRs37lkCVi0TOfA4IhUCiyanmIGM2ekAL1hesShkga2j93XsUbs8tkw4XzMjZQEW6MlW5NC5uWSr6KIOhxOc49TNbDwAZimmh8oXrW883nqrCIShVHwklZztk/E9TrmRws8N/LBGphI5ZvZHfwQFMWciuPmEw9WQoC9KWjMJKaWOJyfpDjx1Ffgad60c9+UN6pQMNGrEHdkMBqmzbmObdyk6uL2QqB0AEwQJwsz4ALo0Zgjjq65vABYEzkMVfpyHEfIydk4fKU92c7x6g4fyU5IKuXFHmuWu1eOTopHktxofTo3qagX6P2bdX8MqZiUFS2uJoP1Z+dYwhidhdkPIVhKNcceVYukqN5LtTsTht195fHcvPDrxbeMmw+m86/huaBDDpT55hxNv2OHqUkVVCe3emHov6hrtN4ryfcw/23RmRz2+yrRXxM/ooLYVlF5CdqwRf7BcRszB6pqBgclL4nwHIiAK+MLeafnYOCylxp3PeskJtO+R/ncwHaXJm400zo1j8HfVC4oOVxD0j8knZDJ8HA/ggJvyLF/byp5ncS1efcCG3tC6MyU0VNJCYNy4J8eNVNkV2ZsojbUKjiUAmvKHwdHojOykk1O32Z1PXHloeGHyimiKFmPV5Jza3ewOCz7FnWeym/Uca1+MrOJLAcEkz/2Oaws6hkUEY4zPFY48BvucIdkX/YrsefbEhtEiFI85OQ3Qc2zSUZc7Sul/LVeEodkxlIWy7U7UuY6KYJ1MyiS/JrFS0MVjZ2ZBBQtOozlO+k/M2GEzD95VMRrisZDAusIVJIBRVQ+xSZheuRR8hXz0CQjMqNMMoxpMCsRh6Jz+2Xr7adB16ZLdAeAE8On19TJgEFncEOgjj+I/A34Zmuel4e0RATijPvK7rd+l/bZ/vyqel9iNl7Es4M8dcJ059orLfF7K4YVQgijaBf05Ui+WGoxJIkDQxk5ZgX+K8RDNuZf9JRQFZlV5WCMIBtuZeBbYNQrIXsdpdpqDhik6jaVdO9HHkZfRp0uH9Rlqswx01YP0GgQ/AdUWllu53Z/+ge/5toT2170kVMfRKST44d7gjh2/Ih4inkZt/2KkjUBhReLMJHqtj61cFrq9Ika7z+ceCf35PIHxaBy94QHYGopvCnxDUgg2CsqeFE8suDXdXszwDaw791GdsTYzlOruHXyIgAwK5PF8zvuosLzxYAMNq/oqlMeVupQSJQMdLgOZEXm8VaLKyXNNt8Wz3BFkbejPGAMeEMyW9owlqnSOdZQYqclK1kEd1jI5uWpQFpSuHLJW7kD2YQ+Y6qXy4Fexg1Fg7eGr7LddA5rZlFBU0U5Ce5pl+EJRCtgXiw0813IDyTD20zNK9Rx3jg7bGxnipCqrhZWtHmmnR//sZjkPCG1O/7oRp+M7HWjCtUPjqmuwmVvzejFuKs6ETnRm2a/ZFW+1ZYbpGFzER4grbaujgvmIGTi3hxIU6ORqeo7xXHhOtpijOJJLOG5+WNXwc5cpbKXe1ihgvBubdwmEbMKzd6kawYxEx2N6qvWIVcyztcmDWJ1jRikoQLbrYFQcRE9OVInW0716fKg1Ya6ddviFoDm5sjzB7cRqYOshm6mdttXO7mxbofa5FGYh8V4/2QTy8tpaKZVIhM+AXnOoGtsb1ST9lTimeg6ur/kBL2C0qJg5DS81yiGJlRDJjzij2mBvjxTQSwt5s5JpkUo6fO2WNZq+K69Sw4ZHkbJ0fcoIT+Zm7gGRsYrUtvpPVXp/9JlDRBJOwbp6Y7CI1OKT4gie1cM5shpova/WJskIZggLq0tY6RJqcmXgeI/TW0Eis7J/inGQcXzValHFVbmEuEruC4EaBhhH5SGxqIbd69+oOH2RM6MaL81CittdtVmTtjt8mDAxLjkClt+2KT9Me2+CoJhVU8bFUAlX7DbwfP2SxfvS1eS1EKEixhSW5dghRn/paOHMpZpA1Jcs7NIXD5a2nqSYApP6lEriWrZEinClnz8rvdF16RbFi0ythdmaBoglHNJF4Mbx/dmP5MGdFGIfKd8hVl4Kdl5z3iqP5Pv0pROBBcWNOAfZyumRUNxR/RZz16F2n67Rt9nx04IFrARBbKvHnUegBtwrn3EUuuTp70x/uVKyKAu+7Y8Rj4vzFjgLNnTinSqSfe9BoOeIUG/8rlZCS8uwzS4vtKEpXFyGRi5KzxjS7nTLWuM0DR5WQL9ywlJrTEzCu5OlgLLU7TkFvN3MLCplhUpL39pQ0oKow/z3a5PjKSq3qo0zdWVt2h8Q/cgAWdBSlu/LRbEfJm2bIioXdqfttu1e9chuTtweaMbTxgkq/VLz3yHWtbgfBaVFj/khF0KYcuIVnuERhI8I1+fxL8KFl3AbSt0EGBuJBEqMM8cAiJg0aT7YyjKSzyyUCkI1hQ+WFqVajF6Ux7dKnWOdb4Nm1V4x+BgOpOWaZVaRNEEH5jVJurpckT3qaDoSXeF7vCSLC27i43L72rQCgHJfdE6ucpOf08u5NLmp5cKQLINWD0xAMV255+7iSaKsyvrk2G6te8uL+fzPNrtY58JeazQ2zHeu8zBbJW4STIemW9KbLLf4eImiFZHVmZIyRJ9nU+Fec3txH1qMC107ZTZVEzZvStXchKEMEbdVNkQXrMszwRsqnehB9cFsCjA2LimROPxNiO7tVjSavfpkf20S26KPDbGqLE6ey0YUyEcrBrmjW2m0OJ+b4mu8jLl/vPKPH71Pn6OOJzeEEvmMHPFwyvnbk9FkxijjoBMPA0Fad12+PXZSIaaJE0gVtebmmGCQSo/mzTMAaAyYf61WxjdCkp3ygav8HvlRRtX8FIH+8Dpq6NBwOI0zjyNeCDq39/AI0XKtAT3MBTh8kx9iP2ktogiFnIt5KHxHbzQ473sDE6+q4CeusFJmDMoLo0qBeuHA05XmZsJ+6s9G/8u+ez3E4YUVYG6n9Ma4pz+11R+oIY5TRhg4hNieNAABSo61XtLqk5BIRz+lk1yR2xUzsHTPLGwpC3R5TyYLNBrMNR9HNWo7Ha2i89UxIFmJMfBUSX41yMDgfujHwf7YdzeyM5/Y0FvPS0BtI0xdX8eeI9BLCAmn7a142ro4LcD24aoBwY8qkJNTdUOUDYDUfTlRqeM4jJAdCPB/Kr9sRBXEzMfveOg5VIUCginWqy7CBFwka/kiOUtFeIMTger0WCwL3q9o8k7vKpvg8YHuam7MVmo38Ttkqvp++eLCIwtwzHft0yMI8jk3aXYPXP9Gq1zrnrqrmNgP4fhQB0KUvUiNsDSsRxldJM4p5C1bxRabJrnG9GXcpONoB6BhTqcL1QfT5BeFKvAxDlRHDqW2zpUM9JwhzTi/j/pb4Uj4hpND+b4rKotG7BQO5x7jKLW28AM+DZAJR4sf26rGOd9zPeboKqPXjrMhq3Gu0NX8hpWcL/EjHhvemUWybqUiEY2yrHytzvwK7POKcfT8yFJoEdmU3l64lep71DI9Fi1tQntucyuyAy6b3utNc+N1EK0Ohcsp0c3H7Z4iPKUiaHM1EX2KYWBdTaqVjLhfEM/Q2DXPgPnL46u2F5/GciWPDxozGepUWYtUyW5APT/OcDo4fEEXFtVsguB72/x6AcHwSxMcHnvGxoAAFzfFILROzwX5aqEe9i6QHhBxI+dcE56rl9H7Thv0+O3Hg4zWqg9tirW4R/n/xhCL0aajvsWmeLngMNDDV/U8lb+dvuzucAoLevwj9zbcpXuNPRCS5bXy2A4dl+mUu9Mzz7FbImmr16D7nP7cwIXFnP8ZF5jK0hSwBd8w8X+HSMkTEiE92wgswtekN6D3PmP/TLH5wbBHRZByIIXYfk1Uuxo1CpGEG1hBZXu7PNIfsPtj4GUOXPXB2S7Dpq3GN0qz32ua2ktsHlhVGhrx/fWqB9tt4dD4TLHMeb95FBN/0UiDrPccrRdUiICxcLUlMAquA0jaQZmh+5aff6S4/b1PwMSVxForimP6BFGQBenAoEXyfHWEqCU56tt7nZAcrU6N30AoUVWkxXNonO5UtFKn0OzO4PhVHesv9yhGeNUde2/j3Pr7x9Cakxw08PwMQBrwG8btpmcpGJWglC4y7S9l1HtFOZFvBsQSxPM7g4nbA2c8lZQqKUbqZfzJOZxmez3jEG6DOt+5CEAYuv7PE5euy4eo/i9MLRpMZx8Z0M8+pE22vk39G/P9QCFmZIfuDEALEzVidk3GpvHjupUVoDADOoPMpg/Y/UyErgeLAiP0ge854gSVeh0dE2whzNSd8+x32Vu5sy6gLGBOpKSluQXMb9RUeJ0kEiAZ3M37vOkKKxTs2gWhwnVXCjIkWmDNn+7ZCRtHT2YD+hWzX35CsxioM2B9kOe4tPyS4abtU0J1OzJQPsEr3+JUJACirE6ZitZJloUiJnY7M1FOmyw25P+6XZaIwP5MDgjQetsvc4ziJgH4MOZ93o/n2xkrdG3hf7OnAClHvkSl7yYQZijrckTVnLWXncQTKgiCcrY4++8iKnyKE/QquJr+RBGVONjIFN9Aw3+zOW+sJuRA0mGzTlQqWwB0hZQvfYHM0ttkMpAMhziMjtZXNDREHUnAQnN2NDyfSRz1mVoGc2Q21ftHxrb8oEAhWzoVcAEoZYTjlT78WWeUODG3fcsW2xG07PKTVPEQSjZM9/qt+ac647KA9NkJ0ZYzcVZE3fRhew05w93AOQYUeIWHbHkwAkKvLuiPCHiymXoW9OJSLQZ7xEsdWVveItMmkplm1+AbRt/aV6IWdJgzqrTU8C8A+tyAYsivJAtCn2vOHwbU5Igx26Z0ObryjI9UmVjwnJqYIJ82y5et/KRYLPWpaGMXYNavWcwLqesmHrLcxhisVLeAjuS627tIR2vjNTsNniNy5bGncUSVLiIaJw1kLlUCM0nSw0PY+lS0W34M+3PWKFBP1XLIU64dMJrDyHQVRokz/ee7NgjJae8zdFFoIqwqqSUUWq8MkWHWacnUxI2w/mViyfW/PlswtjYepEymuk5xzzwe2YDG9RyNbubgGojL5hC8xXR+dKJt0Gux3Gg3Dt37Hn1JFEUlSGojrM21MTqy1Pl0Y7VSjSnPYD8wkdtncvTUnEK1rOOkNk3I/dxiv7lDDyeoeroB7+aNtCCDo2QgHmnj7l+RwhXdTYT76ys+i4L/gj7Jgnx6csJ01OJYdK9WqYeHUosSQTvic3uQp8CQdUs65TDUbs7OLom0+mt9xt+LN1efef+pKsG3zyyueSnWXqjTsMhipjQfTap2WH6RaQCiDZV42vKebzLrTod4VYkVRdpMyxP1Za9k+r5OOxH0i08TymzGlMB3RpRNtnpc6tEarhIwtPenEHqT4nS3QdWJAmWem3WoJxPOewyOzLYXE8FyCMh0NipYN/o/AieWY6bCr6RaaTU1hNKXJJXm/1XL8M0Xqc7idEuSiacJuby2dZh0bwavW1Q8y/up/WSp7NM+4BaCdmPuDnYZjwvvSedRUWKeHJKfTRgYMZ/z7081KzUd4Nf8wTA28VIek1+xUxgQtB8/ZiR2VNSA13h0t9FIhgrcN1rFRbpySDZsi8A+Tr1LHStlc6fe4XHGyJEzywV7gQ65+Y04GGVWj9JOtqrTtI4wqV0npzhWqGDqJ/05toW+5vRXKJ0/w4FqGjX6z61dFgicxNm+BFAOtyTxr0yaJ4a9OmC3x0hSEkoOkgau2/rc3WqL95RGsMiI6nr0wDjI74akoztwUSW7kWADfeoRwTv/cTzREJMiKpIJ92OGLtdPA+T8x5nuZKzLIkGxGkCmG2PfdqNgHMyI1AT4oY6HNwIH6AQEdRfugbSavzaxlVB33s54ikHKvse0MBBx4IghUVKGfNMxpdh9QCgNeOCb02RMBhk+mdYKq/7LO2UyP8uXAdcIVCvhaa7CIHg0mILKv/R0aKNx0U1OjAClxq/G+iZVSUCicd9tLIwONxoxnGEpHaeyhDa5FVGghJy03I3v6QY1vy13gQx0p2+m9veoA0B3GtdGkuMTU2WJ+8pV+cQQF7JH+srDOU1eb0mT3SY/fK1CdjGNmxEz8yB7OQed1CMjO0jp/jHk9Bfcxe6DV91L2084mm9zQW8Ecv4KY+VGc5jkdaDe1BtEyWycd2StGSSoF8X545evGsEVZgRsSpZG0A51nbieBHmQqwKiQG4G5FTUKshiGzzpdzQVH/fecMhq6lHz9CVmPw9U3Uzx4dRfF8IKTxwZDqJVI/KphcY2wb0spP7MnyU9Lfkj9kTPLhE3izTwSOZDDzWNTUYOFmZTQgMXa5gU4QNuApqUAf7j4vGUdfDsc6DfIvqLkMcdK7BPfWsFUj3VXNBFjFeaQlelpdWw/uEmVCFsXsMYCwCpHhQf+KNsr9TJ7UXTzaCrKK5OFOkfngH40QPZvRval4NEl5A25vj7AVIVOnj1Gql9cb0l5hCUaYn4zgYDyAryruG6VSzcjxKz6AGLobkvN9ob6UgsY+9/3JiOc1duLKaSPn1Ne7qkIEIji5h0DZ95eLV6UXC+T9K/J6N0vCz9sTwUKx/hFhGjuRmL3GIbHnQ5JJ5gnEzHaj2VGFleP0blPUi5PHvAr7QqtWUh1O3lGlYAEcIZWO9nihQsWWNhZE0fGnp8+OUw8UhLKviJqFLSqCuzDQyp3qzaVHpJcTKVZ+Bp9GxBRSHYaSoWVkry1TVdHs1pp2rqSMRcEu1HzkITYGou/gnKaPyeUL+/a7P7HbZgmjLaXOg896uyRtOC5LcraLyIdMQ6+TqccdPpSBJ38UHef6F9Ky2KwM5SGgRhmTJ+uJ5h+4w9Iw4ZKURTaF9Gn5c56WVeMxHwwdyGjZ5w7ESKR66TVwZWkJbPV4n5bTFkdOXrZXCTbpSspWUnPQQnbJh6g3kSEJ642zFGnSdgJNYMhfjusjyJ3wUfUZJDsW3TXFFpGxo+HJf65ZOz0vm6iVrfhoai/Z6iXVQGVMiQDlzzkrD8kzHqRkAwmm083FN95s2vW1SH9VNPGlb/LoENbn4tOGhUScLp/ZD4g8un+IRyml6fh7As/KZPAEaROro3Id0ZV4L4u4FYf2HrqZWm6ILNScOsbJy1CnxtXlck59qyDVC4OLQr/rPY5DE1sz6ies5P0mKTX9gIMKeheBRSd7ClXMCweIt3irekVmFVbAShbFv+Q4veT17g/F9igK4WSm86qLnlgaIgCTvJ0tMe8sxi18CdLED+oLGRpFn2f6rEFmL39hhVQWC4XVmJpumo2LHr9JzSPU80Xuil0YlZGBNglHCGS+7rrTc7w2QyT8elPX+sbadplgJ7GHU4burgJ8kKghjN1klMAYyaRDVJ2d8JjIa0iJsMfT5sKtuR4KR924zxzJ7xBoPpIEuTvWtxe9ghXH5fkHODyOK0kHCbz/5lb3854U3hEVeBmxOKwt4WshX11GBB0VANouHs8kNRbbnZhGY4+dHk0M+880m9GcHkHHl1bRHXNseXQfm0R/CIc4lN+10DIQn396iEfivwvvO2PAExWi/meHNgW+/llErQhEqhAjxSdZbsgD7pU0JEtcv3byOAXRPrjwozbNVkqfMW2NA3/FQgDhiTYDUwXt95Snujd/nZvcDC50jiKWGua7oFKrM3SCwsXcAYRFG2esTFgxFHzr2u+niIlPfM6Xl9Zj3n0drlYZ+1FnOTv1nQyn/hpug9LIyC2qiwuZqd+MQd5CbWxExlcutyT1rFR+QNuPSR5Q83FpD6Zpyv+ESRjXw1m+q5kclA2p3Cxd9eoSFQSIpY5kvGW2/5cAKnvv+TaLGG/WnPKYe0PpXifpA19xVREkOxf8nbTFxpxMUQNOd707NvXWmEIBHpIjKh2BzXnGTpZch1DFoqTJEEBqHLeae5c1AIDwz3goVeJx41z2T+KJnCQPKF6VIiU6SIY483mKgYXFnY++kxRBdhrF13r6195nuOWfVobY40Urmcg5IvHYvws9ekm0nNEj3PluQtDlJj0miuxSp0jGN8NfZ7rswHCe0AlBWrnsWHoYwKY0MvLyXEx5qnUq1SS+w3USuEelISeQ9aA526+bG1ERFVd2l3543iSRUDdi6bLDSwlNm7pbsaULFGDZRY7+dn2RF+OvR3Z+RMZev4SCoESC8O7LbRiR/TYPDgRgu/QA947Pt6qKsSUeS7jGwhuAC6wfT6trM0GEzvcLR0WEcCthJTjaAszrIn7ppZqkcPtVPMWSJNFjNiao/YGMbzR/qTWTI7brhEw0iScIDATCULUlj4I3W9yMy98Na4Y9zRfMYTOe4F8rT6X5NVTXUIo3aiCPzKd2cDLTwmKRrW82dj9us6an5Pl9iSq8hsoDurKFYKpgm+wuRjJk/+v2SHtwJFFSATp4XrxTr39jQKh7qAeQE5X809Bq5KQfcTPKHdxuxW7GbQuXFzvTcsk2B8o8JJGGk1+GdFtp5Yt6444Qzym5UdfB5u4YO26Ew4SnzV6MuDb/yW8LeBeYGJeblIr/drSIntlegv+UHZB+0yRYq4d0NmTwGkJHsSqSop2ibHK8GnsE6RxOyzidbj1fI7iXz0fqpo6hETH1ll2pgeicU1yoZd7QeJsPd646qxdf4hJWxeypVHj/1RNbFpJW/2LNR166i+wvq8xJYwOwoZwcR6kDEi7SUUspFS3Cw3Ev58aEhm/5ipRB5w9/La1iQbC6WWq1JuftCSgVWAdM9MvDjJUgl1pu5dlKUP6c2ut2QFVX8W1yt/aFOdQBhSBuBRa0lPtuIJ5MIxXfY8e6GbeUOwcPJSC0HvdiKA601fmZWZzWcqYBjJNd0V2kGb4at+keJMHlh1cS7xAtyq+YFFT4JN+UiTRsgj9/zO6fZobesLd8NLJBNqWk2y2UcQ2zfDJ6iSn4F1V6242v0GHDbkJmPPfhcV7zvAEm2NHz/wt4qtzVUacgqVC/ueagBB09sIQdo/BR2Mp2KTbkD1aFC+iedi0x5n0DHMJyUyS/wApEUxBSWfpP0y6vPkStjKaKX3qZ/rftsInRly9uJVnUGi3d0iSQ2+imCKhV0xglQiiboBZArcshqJD3t/Eirwknxw8v25+t/F3OnEcBFdureOUTuXfyh+4EZQW5SWZbgbF9QKkVT4rk5Tna2FrOSqipd0Py01MoHURdz9ZenIWWPovVCXb0dNjVCTQyUc/jFdgbaYWOhDfjZG9Xj5vt/Rq1cME0oViLrqT7wa5ORVvSTd7TnmASux0l0BF8bYux2QVRqAgM9o6bcERVyPkGXcoqgIvRN9aAxzV2t/MsEf0sb0rDbeofdLloWH7wnRDh2yUA1ikn6OpcU8eUy0ADCnZfd7BB4whzEGJtb0OrqKKE13Jol6yCIb0ie4H5vOud3ZXPCjUO4Z337LaGmH21vc5mLd7dtmw0lpn5yuzbh2F2fDlsJOtjHDwCYoJeyKByjbjEkK4/8qUFRFmXCFMZOGSnSd9+4Hs6oAlEsXj6WFctRCrECeiM/Zu6Y0LKmUbDZZiUl5UIjwtHwH6GfgeE/JlxhcCBMa7KtRdXPSgAUadQlpcYTSFxa8le8EhOFOZ9V2uY/vbmG8aYp9wgmV3wkwwLnHD8T15ll0y7szMPaLuna6ui7npAQLL/Ds2gBJ2e83kVhZyrFhJdkVjHy7jBcI/SulG4Lf+kkUmh8HjS5klveI4lWFQL21OsjROaENNcEHh6FsocfXbnVVdp0iiUy+1E+nZD9u0p0E0Ly/iAvrrMGgqiHOMuo7LzsER9nrZc4/rdrxDsmbYyh1mxHn3oEGuBCm0Apc0Ctm33Pj0zk3/LQ2M/2X5AJDlvdSgQ73WbA0w0E0lrtzfAxh/jcD5b/Kf9EbCLNcVhSuHibCvsAg5Oj9fdsluG9UGOOOmBPAuo7MakPd7lw5h9uP9wJaM2CDOKPcZlOg9/uZV8OsW28veEgx3ncvRI7lFOC7HNHjmaPgZkTLsXeAidBMgI6tIV5OMEBxkBLKi0hJf7fs9eT1cYdTDJxYdPvVLUfe0W6cbeV1i8Vv5FTeMohr1/jkqhHfUjw0Z0dNpFpc4c2/Upz7zWjgtDWmnesJnv01yApBcfDXITSEteQub0g4RiiMxQt44C/yl2/97GITv+iGjqhFVyDpPqvm9tzqsQDyDkm+TFiWUkUtPyV7pfBryu98nQyCsVJV5tlfSwnPg0ZCid/62iwHi58FVMGZD7f0yAIAbMKVTEwny6XKTbRYD/PsI7urrCD6jHbxfP8MDDnXBUkQT/MWveYEWv4ApTlcjzy5K/V6IyqKzH+yHrhFTXCylEy6tOlSfeYmjdUYbLySn4XDjI3RTmoXQuYV2qkItmx/NxARViqMsWLh8F9Sx/GXCex5DK3/fFeNGwwh5SHvceGvs/Kl3ZJRKYWADBiuof1HyXbcGCcitY0nLXUtGhD5BPbB0oc3UPZaGB1YHxCEy8nOyLf4flMXrGz3obh8bhKCjLivbMDibFlSTDVoKwOMNK+IcnXSKD0wNPJlxqp7R81vJY32TgRWctT494XJ7ZocUITU81erqFT4MktmSbbNneQcYBv37wVtv7I8oAhZmc9ca3yKSXqEQ/v7fj/NSAZFC57eXydPcwKPK6woroMy0oEayXA0L9eCajOH/hskVR8KYCv8rRxlR1ChZH6ip97ZTZrxFpg/e+JPbhBxP6SvxlbJLNXUDmcjIrKlIv2jWU4xG9qPaeniO22yKQC6ldXyHpVXv53/sLVf78FVCQIuH+zY/LZVTfdAxx4+lyJx6/dPK87zBKA4XN9PVhnRILkX8265wdHMKqfUzC8NL+YvMPGejYSd/oEti421m18AUf+cxiRGm+xnWjZv9y4xaQyR59F4Iootrxsk6K/Xbce4YeoafuExtZMPnJUUXJnrcwBZMk8nrdePcL2tysMu4M47VfSkxvG3eD1Kor+Hr/sPx8sV/0YCrcW7Yf/sx46raSEW7yNAPRaaIWCNfWxcHxRSXjU/A8iBsHFZgQ0IdG+HDmR6sotGsf/QzomhmNt5jNLjkOEyM8XxZYOM2Uhx1hCo/yB9pcssBVIdYpStfcJpJA2HVzC9mnGDZxapMfvCq+HNDuXFAAOi8FHeAJ8HzrmxEaDV3uMZjWC1uU//NjPKl6i++X4bTslnOBiQBNlZdQWYT4Rq6hzslGIIdp/zy1B7j4HZd1cvG4x3vW/Wzt19TSVJRTVFrffEPE0TYb3xaSJtLF9keeNbFcOw3gTd+LCodLK5UAp603oOqmyKjJP6F+ILYgp0Gh3GgDT0PujhPJXZWqJ2ornooUmRkY0FO3RZVsiEay/4+ZkYlY6vhYJcHEoMNEfZd0yVmbYssxuDo2WIB6RAlLFHgoNXup/sIL6F5Am+dmAyx/UIulcRdfPYg80PTeCyPTJJ7DWVACcZRJ/YdT1Op87aXhn+L4qWsOEoodX2+jZqUAkLxCx0E6x2kgtWpJoHVa3CIQmRgHTLk1eIIWsv9vGjzKAWHiLXaqMfHPZN3be/PkzmbLl9lT6mv6dPx/OyACpWT9jOJ0Llg+M3y19Vo7SKal285vOqeKEDMB+urjLUecpM6KtNza9sOum7t3Fx7CBW+/uOMOHqaJhwj6QQdyVEKcjB7Bjq9N18lFBnVZxs0a1ScxfqrUKqTyDoiLNMwMEIl56wG04v7qFGG8dkcX6Au6c+hq5MrtJ9f0x/6TAIv3Wwm0+z0DrI+CFCMrHgs0vaSsi+PhFsBg9u/VKLf4VKMPaMTma6ZGSCeET8f8lnBOAIVROktcn5XSGargffdmOeXKxiXT6QC98EjsFjDYuVam2khfZzh3pfb27Zo6aKd9x4IA+ju8qIdYGgTw3HYvMSv9eqpgIBcqGAsZxFxDzOcVGzkqPNPpRJeLTbc57o4W75vPffMbUgQeyhIv6P7JkzbjWBuLbnyJl0qQSsSDeP8aqJgGc74uAiY0d5ewGWV+RqnrYDG/zm/SO8UsU4UdIWd1g36MfyTpvCLNuRCSK3pP4w/l45y5OhWkUmYQGZM+8smX2MKci7uyfbDisRFMIvVjaFFz3aXTxM+ZvR9hE9pyMEleSSCqSUda/ldo8UXUZ8oDgRlHKNr5ZhK8p0aiUw0Rd5BXOoeSfmJkUbMi4ipnFlaiRE4xyB8H/tq927m97ZK1zqMs05eJempx74sMu25zoskR4FtBVUjEclKNxzsj+sy/TY2i1f4tDWIhTHSP971hlT/UALnDhLefYCuJEuYNVlLkrQAx9VhK/LCwttZFNQds5UKZhM/PAcgjWysbQOxSZXzTA2E1NAjwlOMrJYGU30Onq4sTCfJXaCTYhtGezhW4olANna6Q3Vquh+1buW2jdklgCYuQvEAhc/HQg3Sq8aQBqHN3FewCVoHgaglqaNPnI/RRfsY/w/W6TlZjc8cvVhSN11e1/1naMRh6pNVp4LTEglioy+OnlAemJMgoRQ6oAZ9XLBuGbG6xfb6RBlUpT6ejj8TpymNM3rVz5nKSuVXfGGv4mltDq/HEArcvkSn0MOB4qXkaoPypZWApQDbvYHcmtOsq9cDRM9I3qy/UZ6VkMFFuVm14n4hA1k5UNRzZYSfsv05IZGoGJ0Hht4eO7rRrQoM/rKZAbAFxyqaS6t4dOHs8vqF+bBTBJdmb9TZP7gsBmgjOJliUwEB0yvpk9VQpwXmS+JpyX/NlJ7kkHAicZLmcgyaT+hs/u+r1U5V7U1Z5quLmR7DwKR9bXkhL7bBJOXNLmN2JT8udpI6QAVi8sJso/yaZwznwWV95WhJRuDKemmGxgrEDZSqfzVukkDDaXtJ7bMP6GOkaIghb0nLNyGnLfyjhSGO97Q/V+cU/YpuFLcHPwpRX7k3wvWxVzoQZ2FUG+scg4JXgFgQHaEicnu3Lph0cTX5nBs1wfYQlysDGCxRjbCTmZ15vW99oNyulPC8MZ5alO1AHuK55kZjGJLCGqZ7pDMFWqsIcyJp2vT+dO8jkplP+bIifg23KgISpm9ONy+qW5qLn7K+MV9CYJQtEnL8lDkMdOOBA+VM7BvkpPsRuSbqXhJ9EQWuyK1TuTqKse6jeWs76x/oBcr17tUozenwXiKwALuR+7J23zwWo8TwnKIkWdGb72vi3aix0TF9gHfuldOqwa/o+WVig+A073IGTixcUDhYWs6+DeiBIcxpFIfa1vCk32sVc4JUZlmR4OgBUzfji1ZUGKl8/yoktlgLUsRBlRRbI+SE/qM9mQsz2zxOB0chWHoRnqhN8ydYIDvmWc5SaWSkU8U18hEpyYFR6TzNKw63Hmp78S5/ClpxWvzyUsDElZGiphFDIqGp6GLMTJLzBnSUJ5Csw9ADYuKagLKV2iDtOfPNBtGmMZvRhE0fYg5xJ9fQWIaCqeSZ0v67koc4q14ACCAogZn0iQWsqN7YzFUIzF92Cg8K+yaICAuv/vCImLxmzAabq+mm2hykTNeL5yuiu7WBKcwdH/0U0FFWsx/4b7vWrIprubZ/Z8HQV6HGVu6b2+TCZjELvyKX2Mx6DndXNLQvPrlLutb2frefHx7r45Jzf9E0TPjHH1kTcAgMbrh5nTwZgy8RB0jzGmxFGXWtP+4y372TSMV4+BWicVRwgAmFrKhF3RvK4ouyzHBL68Hj13FBhlefjT3CPWisaHsBcru9VZd/wkGvTjA+276BBkTD0mm/QyfM2K1jwUhshLconQD2lUHgVABRcA0OMYZJaxCEJMQjoI23Xm5XBSB1KHVnxBesARn6ZR1sqY9bVVte7t18X+Auih0p1iCy6cjBODfhle1mBQs2Y+ZEoZKrfNqLRdn23oVC4MBiDwkpyEUXZzDwGcWuNy13xD0KmcOE5FQP9715SFdzu0g6+VocVIyCKhrbKMiZaRSKJJULa4QFcNc3WZp8fzvZlIlH4TjNS44irjEArIxxok69SwcvsdLIhBNJSNBJ7TGr2dcvcCfZCLFo3qJ0EOD8aUEeZBpJxL0r0bmk8cmdGpACLJH+Y+KEsPdbE0EQG7BUSnsqdL0unty9zOchEyiSyGRN3ho/5xVoxiTrIN5HLSrYNvIyCyEHSNxDbmeZGsmhJMPRjSeKFcb7Uo4m5leKur+hTexjLoiX5hvXYtHv3/wbf0jG6AwqzX6Sj9fp9/FU2mssYTDxPyI1sRxaGCTZY37ZothaqsVbWf+PovbVSQG3KvyPbfdIDDu1yjHTpMuwYWYqiIXOODvdbVi0q9N9qcMN8rFU/HYxEcsSQWC/5Jgvme44f9KERP/1fJcK7J2MYkhD7FV4SfqBeavzPnYjj0oJLrngytSP+DPQAxNj+te7+x+42E1/9/cXf0Gpi37swVc+sqx5+vVwYAz6/Fz2fNpPCg1uV3CFGmphZR1uG0x1CAKydq4n5HMaDhOsgUT2Ur7Lrt3Lq+VU5SUni0q1itbmpWfqf4IVkADAYHVlC+xhAl3xrS4kim6XvqyCFSYlVm8Hyk7yuM3NRYdtqoUfemRDEm0C4TNf2/4xfSdgzwqwLAQ0Q9tuJAUbJX4HfKabcGoQZA4JdXqARsiB+BZtwBTQe49PosNIvVNQ2MMAQR5x3YAg9doXZYvkhbOjyZHPAVjpUxmBWGkT+DL9g/mCSaThyg7Ge7poM2QfcQhKymDLi96Njgy8J+R7urnOiC6etR/qbLnmL+HNa1g5E/9ksqcJoEMUHHvRBg2Z4u6Dem+2w7MvEcBQvzrS7Y37vIviUV4u4HhEuODbb2P/EOJjswMc1IB9zuCV6W0asmb1DgFuYKX1nnDNwp0RP1HN0sgn6eJkANiCIZvnco1TELX4+zVxXtZl1Yp9rpY+yQRA1kTJpFCJsIjHdRrujbRF7JCWNE4cBJ9+829/vfmZsuiFB/OWrLxPi3qtOi0SDMUEQhSoSfsLSw/WwukEKUgpQpR3N6SoHomsc5sEhQ+GFTgXRetk1genehW3w4ukMSoWgmfPWvbNAON/DVKQpqQ0BRUnJYmWZkduaPi63jNGTSXND/1M1rN36iPYucah1O+nLfcNOgDko7gRKHbqUo6KUcLke4Cd/BNH3VCmpYBOGsC64emeaQE4G82oBqPKrQk9tqDHWIj+0fAqHJNU8lzncNc7D8WnmOEKByXE2JzosHJqNB6GTtySSO/FpT9rvAxQFAoECf88mRIfliUqjT8FAiw13OSz10LzlwCaYVIRCsXB2LBLkjvYAcUk8UlVKTXtwFQYhNHzVHoDlq4M+6pQXyWUiLuLqJT3z4+6ngUmidJILjKa0sgEiU9PxuL6wEIHhWXyO7EGhQDmJh4KEhInliEWKSVK8xVBb48ddBAIeZvhwrxoS4SpZNa+QEKoKGZYRuNUcGA1eYEEqIxe/tR0h8pvl5UeFlhp/nEqoHDsryPjAGBTsfB+Ir/Mb6Hfyoi6I+vVyRsITNLDK6LBTjxk5yJG8DJNVDm0xFa5kXJ3VACUYY0OludmLrnGEX/DaOP25+WUzRpA8R8d/mFfRaWPghx96uF5UScxN8qSI838wZeH515uyxK2j9HLNaITcYb1J20DNUF2IQWBQn5zPgu+Gi/UFFIdyiLqztMpgZzXb4jHga54hrqdhHSX088G0xJndK6OqGDW2ukfJ1m0xQN6WoYuTPndHEGKy166r3AjZjmWdJe8YNqU4trMQi0TmlGNfzVWXyu0EYt2XambbgAogVQhfWpL882WfYfKtxJ7yp84mJ9kF23TflqhZIaZRLUolsM1HkeO04Nz+8G13t72eCtj85UWjzjFdkChoO9JhsjvrE7egt9b52pIDMwtp6glJnwS32IGeKVOgfJmJX212xMwsGijbSxw68t0/zG7odER1V1jZI4oNcobJYMdM+MgDCZ77u6YF8WpEdiNVEwXlhG1VKQiN9c3qyBSxuqj4bevN2QVjqMfM6qiYytqk/ABAfIogEkWHkW9Yn/v89IefO6jm4ZvSBXXAfm6w48BT6eDSb57qrq27e33Hcp54F1feL2wRU3kzjxvaoEXggpaTQTLzheRy+OVUKu06yRCp/crEf/2CrW11skVHG66i4je8IVjqN5cLpUJUpspMTCHlpW4HaJAFRSFGjH97HFa0L6Dxp0S9zL/A7kW+43+0hepkQhrHqg2ODJ/cnpZ2oqEHBI7S8JJxgHKQH66YZgZXxyfgMwMD8RUH9G9fSSi0Mn6QGRQtT579v7GkybxwzOn/NMXPD4XDlayif/NTiphi7T18WKDCe3SAw+XARK/5sInA6KXOBrQAJXSy/rqCLgo0mssi/Tz19A1Rg2CSoMAARpAPFrQVQkxagscZASd8c/aCY+S+I1ADzxFxrRIVr8h4FjeYlxqfXu31YmDy0WWKxlTh4SReU7PhJdGZr/qjKzx3IpCZ7D7sX6Spfz6EOeSUE0dZ7C+oKZo3FQQEKUMI8DyqPwx48kwmbaxGZxXQTmBH15bEBa+oktAyBLXi2r7W9JsfySyDUSmpW6GOmfccyp0Z4WJ+UbFLhKBYLK6aAPqI5CHSPzsQeRNOgHCyk9oHFjgmGE1lH29O4S5qYKdiN7S8U6S86NAKQEGDokE26/CgmxZctFPl8xPjbr8pnYE55FPZZnI28Wmp4m1caRg66OtVi7dzZVLPejGMwM9yTcNL+YkIqiO7DqCokqg8KAMyqq52ZLCgswnXlPBD2T6YXJpwOKUzHnwg6u0mqx3IH4zcg6aITsHBJ19jlWYkCxHURB3DR+XVeZKT9CT7/dGp2PmXtjQHyvy2DRTnHp3yOyBu8xsn1AW6BvlBLwlMjC0CcczEjysrkousMD/IUN5OEXM/PQ9Hz5l3uMZHbpi3HObEa2GQ6rVogMLdhJ9pLNH5b8OOYFbZZvsYCZz1RoMJ8zUPcDybNGC0mKBsOxVUDjX+Jm2ReMxm7RhfgIDqiu5uWJgJK3HQLrIBConQ8o+Nr/1oUTGXl2S1TaogV09Qb146h/dwELJimi7yrmnLGwsYkeb/y6ERB3dFDY/yv0jR5qyXfbCmObTH5WTDUbWyGHjxXBeB1ocgUIDbeq0Cism3K/xCcqv66ZxjCKsKkAbN00V8jleNXIHZFI8sjg/uchv9chqc76avD6fXh2h66B9T+ga8vyHLKb/fhyF1hn1+zR/hcaCxCFy6jhUUtz3/VlLCuKw8D+TqpGcenf8d2pVMvipp0QtmNi/wch0K72dyBOjw5Na35WiEEkr3YrbgQmmZc/5wxMx2UoPIduJsQcMc/zd2DxR8P2GHeQ5Iua9Bj/Gb7kcki2BOEooxTCZ02N0URU0buUJz+1dfkT55kzXztU7ApRY/ScDoB12iT+Onl7yhUvSpYOQunAAE82+xe9RJJJTGXWsBAM9zF7zvxkLalvk6V147Xjj206NdOIAT0W+Pk8xsofg6F+ZAYZpFGojc+dd2v2Tp/wPywh9dfJF2ZrMR8LUKJtatgSRtOGyJSNIoca3poauNABMRC403yPTb6vnq2cu63Q6GCPZIwGsjb33XJzs9uYunwb3YtA4Up0Z9EZfsjHuZQkMjH2h+z8z6hm3Z7dyQG6iHjatAODyAIJcAN9Kl9HMdrzRBcJY+hZJgMC3C6saoHEJGm8pmFFJFxLPEZpbWGNMsus8wbaHTdSMWB1drOnN8lAafqIilpmJnPk/A5iQIw8GTyjPh27rNbnpXOJ+VWGfiO36jm9J65JNXMMtJCltX5x5oz+oRZQ+gtNB31eXsTFp7ivnjdzcGy+D4oxwyOpVDPNgOb0NwsmKrfbtOn15a4ybyoHHqBgrl4NUSK8lVveBMXSLCEWiaQEdN3TlV38k2JwIPF6QkZ2O/HTQ6JjQBGuObYjLHcMGuN3TJ8gWER2No4mqqKMQGe/gMyXpNKdeMCTFQ80Zq5H7bfctqQdA+aeHU19z7emQbNFRzVqn8cGTpFLcnfEFmNEy1yvAs9GY7YplB1k26y/Tl5BDYmw0TIL3guzQ8Je6LUW56nxEnLLontx7KMO07iuIlRIWRNTSAoY/m77jQvo5a8gJTxcuaMHH5y0Ig2SlK+B9JNRzdV1QT4/6wAYc6SbTzTO6v3UR39S4I9rkPUtCJ5MfVXeoLpYPjRnsZmGhFjsJTJOorBGwMjqpUHjRKUTNImL+eiM7INLUaJz3RJndcdUGgU3xa7maZZcoXP+7XFg6iht98Ip3udUInxjg4imwAtMQFh623e9jlOlut5v7hcdcvjj76tAaUB295Ljd4X3oj7fzkiVdDPXTZndqw552WQOrPdtZqoOITwEAPoANtoj35K8+tgbrp67A6sfxFCJ1uDyPkLWJDsy22kdIbUbJiuiHbGQcknunbqTD+uiWqbJsLPWP/PYyAo8hBgTgjdspN9sI00sRCwdVnnp84NkNQDj4N44t8k4y+4j16nCjGYcMCj0+z8dhJdq2Kty7IaGF+fJWiBdCC3NJlhi1pIUDZMKjXzCBEMjnFvTytFnOEFKMCwsr8sOQh1wYXs9lbFwixa9cjMQffWp68ku/ge72uHTiuxrbesSGXnwPLU8EBH1tHYRZn567TcLrvrPvTwFN+2oqoFL5t6IFM5XNXReN3MGbtzL3Vnovo9+MB/Y7bolB/ZuPq3EysgeNQ+1Gu4uPbgdQO4VkG1kYyEAXfkO693nXufdKw+2qAQKNhTmTw1+fsYQyxsnB6PkqNOBAab1d/stI5jkp4Yq6NbHFCwhd+Gamgcvj5YznKav1UKuxw1iWvQ/qtDhZEheFyy96qpYZL30jsF0dIzKuqZI3SNsLFaAyktUczjfFcJX2g7Y8nXtrGFN2d7n0drIV2AATHnSIBhkXppT+KTeAJAGyRLrUSPUlPYd+PUop0ZavveA53hhcGEpHgxEPGFM4PGMnhdqBrK+PMmK1LZT6i+kr34Wmik0ilW0Gk1fGszY785JSjDzqTEhNC7HeD42DKMOYJM3fpHNAjSLciHORlwu6OYNGvaSpvILRRjAUVVzMItF0ls0sYPbf6q9uhL2udag4uooOfE68NicB8afw8+NK78NQ0n1pfhPMN0kJIaUVw1SF3HOjAVQc1dHkanXKSYXTjOUl5wisMo/do1nOOX0nc6chru/tcBUnNe7hm2ViFG0wyFwrM4LmeuQ9BD9ACqk5vrCWqBXtJL9+IkNg0PLUNpcju592Y6/6NQ7EddMyyAKP06/nPOBj9bBkw4QWpJx7qlTsB6MFeZXahw4tGkSkXU7uVltW/vsRVn8J/juuHqcYFWVyr3CDeHAZhq8taUHP/CwdXZV+1Z+S2bxiQlhJqw0KW2xy5QVeb7yW8T3RE3TG0bx713yEYz1wal9knyiFcju2EodBFWSTFbxJa46sQGkfuv8qZ+Tvx/B4OHiG69BIQLrQyhR3rxrxZ8YF6A+uIqLiNYjURiXB4wxTzB/omUXzsQz0nCeXLE5guf9v2KKFo5jg2/udtCsQ2vKSRf/tn4z9iHXKmewWdq12SWoaN+9oQL74UtZg0pcXDqGN/3EkRbMkgilGq4FAHdEEBveE+aUDrMcgRN+pXS9pJyQeSA3/zBq/SnL7l7BI31yA+nqwRBm2h0zkYZl0qoPGmj1lLl8sYjoa1Mq1mxqddKGP3r3/CaUDd5R01KpbS90JzQhgSXxa/BLSuxcSzxFwOPfhRymtmat+SJ3r+ahqQ4XJbS2QGC4vYxAe+Ldl6XdQzLGTvjSlSo3He6/Yt/XYdmtXVrgznUbJpbCcbzidoZxn3+4g8F7sWpdd0zKVv+2lcBh8R4hFpsSiiC9xGrsd6NGH6AEK+coP9ASTexOvzp8jOTzXpedeY7CPTdnTaE4Wtts/Vk7nR64JZBzeBFfb97aZQljBhde+Hney8vNFLAZYSMEy1YduCiucO4nsesaeocYFXHn4oaUyBrBRrZNe2bxpuSrStIr/SueB5tD+pbVn16XvOfpSwukW0LgjxbW9KeKXpXEGhEKbqhsLaCGZqpQ8m1EV4C2E5IfFC2+xYlAWQpUp2HYzpQX/hRFvk++AccaumgEzlqyUQe/N35KfTI0bdw/DKDnp59mMI5FKbn917v1joHy5xzvOkYDKfYVNxzc9w6M0QsZQINPno/t6cl6rvpvdwBspdooEpIklvPBnxaUzQxEzpflDVCJ5NOJ1rUWeNEsHUZJWQg9I01lR/RToA2l3Khnf19vhVJblq/RoAkXE5a4TfdHZFIIn8zXJqdSHI4E8AGYAAKeuirFM5Wsu0cU2MC9zKAx1pt5H4r0lJHMH0yuCIxt7dBQepGRdETRNy3imHRZHcb6IuFUl3XAJF6Ei3JmOwmMVfltefICoSof+x8IPCPw3kF1D6PahY/ysLmK2wPMkLGgY7ZNgw9B4OD5GCXeXOtRDdL9RDXLhaYV8845qHyruo5OV+IyoeM/5VpPJWU9AYwjqUbrWcpvpTnMDq93aNqdnb8FXKTm/3ZnOHXlM6LcfpZWBHjKYVBDSwK23uOTfTrDkIJKhBHgo5Hd0G/mTF0Cg1rnYIXmFxQFz/TNdsbqjjW5DrwEN/IpFMKkvgUskJ2z8eWv2jB5vdhlpVffl80ZgZdt4QFeqQ7FsXJiF04KJLmAi8KPEMKgZhy1w1lw74yN62Vr89gJ1LmnUD6bcKQKxpt/TOEP2tBebQvlZ9mUluUMLLZ2/qWhsOFH4REQqw2mRPCuwcaKlaL+I2HWhUZ+84MpOWrXY9GIFStoIrknc82R0yVlf7G7uDb43x/Iomewr7YlbwtJ3JZKT+aImUf0hstOZA/7214vN3NCKVSuGVhIaZqfEebw/DIeCklXopSXTe3JZt9Vwd5z6t96RCqVJf1zu6+GKCAB8EHuLtxcUdClXut9UxC5dx+yb5nz3WAfL8MT/ZMur+KHpn0HZm/VaTk0bl+cY1+bJy3q6POPTs2EA1ZyR/H2fub1C88HYcqnlCerqhropg3wQbV08FVKQDv55ZFCHz1DPwHCBzdTWz/IBAJ3FLyfPb7kJNqQ+yb7Ex7wiATLNP85caTO+1htuF5HI413mmYBK51iiYNPXxgen1ssv01g8uYq5dMy5ETKzR4LodfCWs2RJ5gbnoTI2rFrvNszA+Dg6wOSmprta+18VkKGRtTn1QJ1ww+UfCFSF+pBNlaEq+xfBsoLqyGvGRXjSM7qlUMc39a37tWvjuWPeEyL6gYOwvp0FW7feDPd3FxlQCuD9VchszP6X12PuDZd+/uGcN6BRT2fUOfbV8e5hioQv8TrowmyMHMLimOOwSfTlWHjoqwseMdmrKpUOY14pr7bda7HYoZBUPxUt/+kowgS2Sxy8qYo0dNCreruSKu6nuAl5o0GIs+XQeObv9CHoRHnoeQdMFA2boCs3mhDsuyTnVcRz+aVwnNiVYcsOcAZJedVUWyiPimVDSJMi/qOl0zFNVt+nosOt3XZ+Kwr49Q6+RpdoLEtUKD56MlGO0OrSCNpoRbpFd6DpAi6pJ8hcGa8FncWaSG2e0TAZGQJDnxf92HmTvo6WOonc6CDJB16xzEMFsj1RpVsGsWAt3oP+Y7Uxv8zuBhGrL35Wm1iaYf1I4mIr4rKM6YJoHONzF0oAl+qdN/WQrW7zyGap0B8qiu9T4yqn4NB0ZZ/7UXN4Pkf5TTnOugR6TJRI8vTcgqfga+9moV49oVnbiZutXnTMT7XdABfcKk13bBdJkuH8yinU/k9B+GtqQ7BGZFMpqz61nxAZOpqGkEc2YaG7KlYjpT6lruBYV5l+3mVOYoPW6hHILJpzYBO1qEZDKUBoBQEthOl4d/YKlzIdK2ZO8OLtcilv3c+tPWnaLpdAIwYdBsfpi5ZkS8fVlV4zTHRaJLzUJswj8AmVT+Mb8HVzaITDu9qahUrhiCLaZe+y/umxVZEAlFcuG1ir9wvVcTi/g/Va1pjPtFbY9yoIpala9qIKwRVlr2+NNTNRkbjLC/LRlR6rU1sjlwfizF8z52dyn5kckPpzXkm3koI8wOe7jCVkoaJ2QHkhOt8XAfBdqRpxTSPoJHS8XteX7SRjJVrfPFZK7+LkXHF7LkmZ4x0uUnaBOogJD6/9NliGC8BHnXkheHrMc6iEOz/nTrWKFsbe/iDCaC43iq7T1fGzthT7DHJcp5dUNbmwGGEA/uZnA/AxzOzNoWnVgz6PMVhytEk0QTgl68GFSW9mZwYBcaa74ewNKBJ4f+Wq9SYPbvTQpEY+eIgS6FFCdby6jBRpq6KpFCSLHdAsIue2EZm8EE3UE7Y7LfhfWo81zcrQnkDxV5W9USs/XINjpe+xqBnoxh6gNG1AY9X/0pFgI6EOgVt7rHyEMUmQBn1+CBx8Dd28SiH02XA+lTL95DT35KZLJRXSVzf1+3jYerl9yFnDnYe4TLm/h7Zz7ZlcLkAJNlkn7CnG4k/9qksS8PDU0/w6OY2ZDS+sjmYmnKEcHad3HJbpDbmy7PUJkhR6oARMQBAvskfbUn6ka63W7bMYt1pf97eYHPS9AMF143R9sbffYGl6BlhhNcPToYbTKLQp8vJ+KC3GHZkCc5AH5Tq0uUZ51EFBeOyav/96XX7gcwRSe7Yx7eNMhnNP8x4p04P+2MOCQvqZwQr8nI0WWOHe1+eOj/NR8byS59DOPdu12+5PizIu051RhdS4tLDpz3mdtsZyUyoiMvOi1JC8DXK47Pei3enSy8gHO0a+Gi+27JedVm89A2Zs8y54KR2XNM+pswU4Ig32CTDv0QiSuRBRTs38dp31/UVkcGpqdhaA0DR7HWGuFmkJdGRPgVgz/JORqAIF0VrEuK3J3S8Ol1qLgQrem66G9m4YN3/3RKneK01DVjwl0NyEyh+VTwmcULTQMvoHmecF59W8tvid8Mg5lSrikEHX6CwGtsIxlPObVebmfVJVNaUPDl3cx6zV+ddAWjymcx3wnns+zO1TAYOGAf45XNh4ji9nOzZKgc8qlkTWdn07cPHOynccFKEK6TKHr4BGuwDK9biPgs6MJJrGD+zFfedf/WRKqJ7EnwbzRaFzk/M6Ze+XIi/E+hJBHsnLGVafh1klXEKtLoOfH/+ZRjdN+1NQNY3lmsd80KYbHq1PNA0dEnAD6pGkgb77jvTpXaV9yHgD7UHwrmcG5XigcKWsq44Kk9/RPBsCijHptbxU1BbImjyy4zWCNafz4UNJNMR24aA85sAas1CcQ1QTs8L1mj4k5pw4ECIDKyMx6FGKf8cFsqcQrpkLumWDPnxk0tZ+lmIx4oSv/e8MjKLD81on39cbIuGlkavUxU2I2zDsz99QkA5L+87po808WsFNL43x4m1boAvRC2uCOpa2CqcUAe+HlLherhewWhQfoUaWgbmbTJaCaz1I0o+IHqLymK5IQymOu/OFpZTNlvex0bIHswpnMDt8tCVBeLK5SDvvQCg2ksfz7HPP2IRn4RlpkI6r0saSqZh31m7p89JW8sTaGJMBVr62zDJpyVaChqPkxEgWP2sfSslLB8DYL+3MSbHgEEk82DmKuT54pHU1jQPswW3G/s62biGA4h7Xn9z3JoD9yVcWUyA0cSQin8/P+Gv9Ll4Jju30UhFIL6mjdIk55rOyI5/aEgL7FBMgKtQfn1Z7tpgRQgQRg0flGKeadRkzXJ5oOsYVp2BpST1HflCJUwvUC3yexGhrxIxhSGFd6LnudgmRPgCSymty7ZFiUSO/e8QScZMl+FyV+JNhXYo0AOj1aNc1wdnPlRoFGNwqwR6eBoLyu0COlKzYuPy7OLos/XuANU6sHCwJHVnEyCMpfZ/POtri4QPFGHoxQidnTY00rc7cUWeCAbL9P+zQ85XKzpxJr/EWXoS1ZxgYsVpASndOyOx1JZBIKPATRggUf0zdIuU7jTLvLcOfeyN0YO2BynjWrhvvzvDyR9fLoauxTQm1wtAB4Oux358BzlgqmnehuFofqM4IFFqAa4RR1Nn6rLpv3Vv6nr0NrfRcVn29Q9Y4LOacV0AfmfjZrkQsK+W3BQjbMoFJ2Gkt5PKr46x8xMv7ZiNDitI46fNeSV4f+ge4iE0TucNKmc8l2qFK6kaMvsxqjkmW2Vu8CSt9WNB9TRqJxBvUM/1bbfumdRvox79NusEf/uyw8guZ6jECFOkAz2IAvEeWKAuo6pBzOyT4x9znEz9U97pAUyqBkqu51ICG6/HLxRGDsn9nnefAA1Xxxq2Vjf+UeiT6pe2nfzDfIEhVfs57UCP+fg7vmIOdymwmr2zHr+b8KqI9Rx1pO/cQ+OUcb3bSbCDIkrFWOknl/0EOQRJhhEhEjqe1QP5KzyuKZ5kdePKOMS3rq824KQKY+HcUpf3DqwPtV4KV4SjLBujhGHf09Tf8VIYinjxbGlqNckiIbzo0KAnsjDoD27ITSEYMSmeLpoqr5OToDs/HECu79eDsk+4Ym8NhG0YUnPdRbMUTA4Pubf9Gx5fphqA09kNyav+WM/dPC/jJi1/hO8GjwEW8glr54LMWZ3C1uhKUgeZtrsNmCMWZ/zdmBgKTZNRoYkHZxCPeFhDNwFybwv20oRJSc4fpLIIWzg+iY6pbaXSKHCmjvbPQzK2sbyN/ECg5mtPg8MG/CR6JZ7DuSyRemGNgBJ4vtYxYS0br5JonrF0OLhKzoxCcqRXbP1jdRsrAqUhY3YAi+QpBcn5pUHQo/VsLFQEfkBnwOJRsE7IE+4QP1OKgiAEGVxt90ei5GQB8HBLGXnidcBdQAblJf0/NeAq1Pn7C1MgpBfMM3NSbWHE5min9kDeKV6pXzyPSxLm1jW5KXGU5YopAXEc3TQWM6KM5Wm2efLZTA2bvX89sfW3tzgnyhBpipCWD8BmP1yvQub8BJ7Ea1h6vQtA2kaYGf6NpV/4ic03bTnbiJ7A/FZxYd77nQ+tIE5Gk4P6Tec6Tq9vpP7tz9BRI9fFseY71ia32dk0QhGUK2eJbnhOBKVk2JcqYhGkaA9SVid87tzvdcT8Vc0cM4ngoDh2djgUIjZ3pGYQ6Ns6atjKANaICj5OtpgfdR9j46v9MWZP3uaYicrPX5cGgOTUr9UkVCnczuRpUxnou4psLiyQyTzgl4r0+MLX4HgdBdjOf+D6oZr6pHEew2kHB5bXs6OzS4XSUZmtoyeJWaCYZhYJEc7KuJ4JBJ70bH1n7Qubh7a1lMj6EeJC+eUVILAbMViej8u6snI6QbU7SnuqRFHlC2nNBpbz7i6ByI7w+Fbk6Qxu2e/CuRtZzGlMMrou0TvxQx+wqT4RRu69ihtAYPMi1SqGTygOE2z32MZF1MEZg/6JRg6xSajfL6AwMKDD6y2bKHB3Dlgy6xpWzN2FaUmpQl7hcghrnJduEUwNz9uq+RPP8rJg0JmUduaXS6cPF393Bj9anagV4Vm3viXbo6GXjhcMg3BsOzR+QGJ1PmujbOrd8vNeMVrwLtcCXV6dJf2ym008B+XnBE82+be6FBqGMVadVoHhBcU0F6zJYXgNusO9d2yx/uVdaUzzXvctNTvn2EbW8il2UV/fYQUedlBvMFttqEG8xhFnN20LYKnTSPUpbqSsl+z/HHnu2gzcKXQLkWdLxxiJdt+ahJVyQ/OcaTWnMaPidzwDYptP/xdamGKgEvhunRQgt6mD5cXProaai1MySBy+2l9JjOpoORCtDhffmeiA+LllDUegDqRL69CCTT7palOaKeuJK9n78C1ctq7x9H75G2RzsNqzKA8vBMeHoezwGCZow6JkU9D8+RF6rJ10QQs5qhefAcJ0FpGSX3/ToaAu0sqhJbGjwR+LnpIV67N4LVDsETkkUw/fCUZjXiNL0p4EBV2i7Zqv6Rq89IyZx8dGWg+tSaJ84UsdTrv4dG8rksf8wj8gSAn91h2pAWeb+MXOOLLturIROk3YWYVdYLAo5pGt6eHCdp96oewh0i+wVHhR2hMpZolu44DFMxB4/7hcEPyXc8aovSR+J7gH+P81xpNsON9emEg1Uc2Zu9KnJgAjUbmUbNT/3QJ8lbIaKiFauvVIG4cn+iS8IMCDOOQEPaPy3tgVO0SIlamINT31WPovznIE5oyUngCmP6kVeQvXpgnZd/LeIiFk1d/jvP36I0MX04ZTknNsJbbdnOlm4cnT6yCWNLLylLPRBBXkXjw8In9S1GR/meUdIWWoIJuaywFNIdHOfwAXINSLG5kcpue1Obne0yQtQhpIoh6+Zb+MG10olOHzYUobFt6rCSlRTtAju8KcQM74Ins1ar63XA6U1bosRElFDW24QTmWxFigGfzIhgHE13Wskgy1m4PCUe3XxadAgTdmFa1oVzVGFKnUSZeqv1VW0Vm2a/5Dh0BN3qqU+Tw6j4N9oBEF4htpNWw58yc1mah2m7VoJw9CYYpZWnR57XEq9YlsYe40ak7SicIDfD/R95g/Mnr9X1G/xJjK+wgz+ap5RVRuX7QpjUx7E9z1RZDa5XLB4TOq/nzIvuSqeEPCxD/HjBfmImZz12ZBGR0TBGTYLpeMjk6Qp6pxnpaVqLu9+ZjmPab7ISQtyoxMZQOSvWYq7fp6gQ8B+Ymv22iTZGfVy7CCql6JEUUiU8ujvOFurwwgVkByxDN9SS8iBXUGYMCNA7zlajzJXauZxJZDPZoxTPPy7VX5lQ4vGNF+xcoopMDVlyWDFI9+mRvrbvAt5zq9zjLoRvotRq/In6TbQRx3aZrS2/BnxZPkgUXzk0d92Bw+fhCQYJtDHBlBN3+bFhZOz3F8/D7gbPRsXUxihGbAPxecCtn8pi9yZ9I9jkHfhDrRHATYhd/8dqakmNWROqTRUsplMgwiuHl9HKz/g17iDICPQBHk0kgqFCP0DCAbfCi+/hayyk+n9HouoI/7Wu1IyMoJX+ourXoV7+64MTDFBBZhONJ9hhGiuLYpWlRR0hyr2QR7Wm4nuyQcmvHgc9Cu4/IQKEfl1lyD5oD5/I7prbfYY/G93VSvs7ZYl9ryQg4pi2zxqQjUsP01YpCr3q2Cd7zzT0calHVQ3Z6rhZ0s7Mwa2cQldXyOaVUHqyWabbIRLXWKWALt+RgUZvPpoZixtniHa+JOQIGKJQbvPhf3ndwHED6idNsIDuyxVhv24IffHv1uqRUtaDqfTjHhjTcM9a0S+4zYXRQNCH3StsRXj5/zwlEgs3WhB3eFiU51bc9Z8poMN7ytKZ/oep8f4v/auynpYfhOM37h93As4ZHw7lJvt0Zv1FAsYKrYB51lytRDXx6h10xeXMM6L4SYZoggtxNEzuU9RC1MbCiuzllcYzY2ypHwjshFQ+y04QDXx9mzvIkqQeVTqNi3vuLR0ZXMlyTo0MFB7bnYPnEoXKPROCWZ8OUTJHUoko3shZa6FE1mSbiDUNCm7NZUr4LHiI6+nMgImTC9VHh3OUUe5nkjEFAaJAfFgG5ebEx/E2Z3du+2ON29+kGq1201k4Yln5Px4Y2YrUgdItA3FKxmcdA5FFrJPGzVRzUXnafcfoSvNGJliU/WFlD2mQ+t8FxO1/ojNPJMVnnk3G9SPIhRQBmj5grOvmSi1sA67jfjnjOcgmVnKWU6CS6S/aKpP1KGusHmgBYowwRrRFasjsWbHFygIj4U7cXhogLOiY973ayXp8eiICSIai8m4WHavi4RRZf9+2dwvEwMjJi//pAC8GypNmQVCnaqUC1rTG1rcgE0xomeJs2rfRZe5UH1/fMFOQvEe2F9XkXpxKAkws8JDuZMxntoz9BVVmy0nN1a2Ok/wey52pGQ4R5xyFSYmMckk7KKjHeNnFrywC6DOWDG7j70typIyjhGkRTmurH667qFP+jRkHLJavSzWbsZyNQgSPciKFA1yTF/gNJAOi6yT4w3JHDc4lSpSMGZVPVmY6ZyorVRq78Xq+KcHf1nTpmErutdq/Yi3UTGb9svQm4ntIZsSuHVj6FUjOXYiIo4Qpi6yJ8ko1NhEj2K9IKT2EbGyFzSw1bNkHgfnrl+kw+KVZfAIWhQ7DutM5++GTIoy/lm6a47vjg4K0IeDGbkxPIPy5/neLX+5J6VcrLe6/sYsrHqppxwnB4b6RPRTU42IPjd1s3wRnJwpQebmsHeQBADy5ULqcfveaBKrnL1Io7YcEyzbLpH4Uw/58t6tFelWWcCMzjaxFErWnB38BpoEDwzA1ybPei3cSN0B78G79ioo7fOayDMiIDw7PA/g1Ti/lq8Uq9pxjYFCmPKd6+04RY7Yt765H0QjsWqyLcPcoAfA+SqMg0WdmoFzf0yLI1GgH5MgyD6+/o51RU5Vmhal3spju/dUJRvG2kzYYi0thooitW1i+Cqb0lfuIWlGeSJ9GoSif+cnUvyy/VvOaw1PzGubqUk5W0gakAIw11QBZI8teOY46KYS9kxuKbiDQVtka+Wu389gkgdIo7OAI5qFeuNIYDVtDbqzX3NPiNNRbL0gNnqhOua3deEJTLOrMH9FdT3QBili6tzyrCHCpRPlHgV/pXxsFb+J8xl8Bc3skS/1gyqz0jZqKulXi84cjQ85P0D+xf4LcbCvKRxInf4icmFVf6c6vSJNCtloIdWaRrDFVjcuxaV7XqKst3PkQWqiZmoMoVmLbpTlLe0MY5wTtf67ybWaF9Y49fPdcF7kgHXp1g+GkBkGvNg8qsX6HMBQW9p1FJxW21NCxM60A/k+QVQBnZt6bXEYPVnZqPtTbgEeIhtDzwk17HQT0bSgD3gg2fjXP5ZjmrKtx7dBo0A65ptvjqzXeeKhpehJtJmmbK0LvsK7nVakQW6B8QzUlVEU63hLtTit3mei4hd9dTwLS0p0c/pXJg71egWpRyVWq9wao9gIMzgzxvfo890pH3S3XU1l1zbfeGk12WdYVdsDGkC599OCogdo86j0rRUDF25P11B66rhgGWXz280kBJBrcnSWvnErk5xeZyjiuI0JMSPpx86oPpVTCZRrqlpH4+5Nb51dNG2hUeCc+kS50mt5/lJ8ug7KLGpqTZQT11j4Nq4F9GsLi/3DCMDJBabmwloe95d9wC+PPCQ+QYoZzEFFxVQtreKFx5rt+XDiL6LHB0qAvT4cTIyXOv5T0hrk3q8mZpD6gjv89ngN8dq+CHW4VskOGHEGaImFXOX+1k8+VgDf6eJVp0pHF5Z8ut0kMItrm74ZBMjI9sri2MKIkcNeHNBFcYl2DLg6ZeaGmCkwt3JpBym0vnUeI4x5rTWUEuOU1FMr2RurnVQ2CZI0neZXi33/5SxMzpVQAXkJxfCSKXiCtjyHM5VAPOprzpY8E5+smdY+ykGgCLpPzpOPYsxLAwLS3mlDwAQJez96acgvUoRsR/CJSYzrMU3OTrldKZpcTtvXn5V9w/dmKXv/4Mu9GuozmfrSJ0MsaKynXQEI+vlprye10sTst7oa8Uhu7dAshkt64sqrFzYg2I/gPh6EvAzlTxOQDOH5LaVllG6f9NIG77V57Jstd7MqIhAwYitTInIr8401OaQGr2pr2TrBzq5FRDn0DfvXCa/PwmiPKyoMqNZdbN55yaQqlknzoZntE1mr3CRP8RblwdrUiJq/UlPKonuNy/TKpE/sQIbYxw5CypjC8CKm1mggsylD4cf2XaUv9dzEcqWWml+OIYPQyzffw4uPquRGXg1HOXXGhhJ4JeB+YH3oplsTaQZ+QavhHCaIZx+jXs7Ln7jKVX99JALWdbhNKfXCc6MkbzO4jODL8bRLwpMDU4GzV0RLEjfju4CoWfFwhspXObsxIntyUgvLnH6xamOwN0btbVGpSMoFPbmsbG1ky0/6e9vP0wawXCfcyK/4fszE7esEqZmbxWpiC0c4NCjgzjtWijDenF4jeoHH1yUBmwwcfKN3Z9ITuZ3Yr2FxrVkbZGBfejMKsNkwfZozwnOkepvB331x7EVDOStkx03slzB84SjeW6NVv4kV9wu2qUjrRHZuQimtj/U9MZJW4hnyLQgUKz1l7Yr3YcKw6VJ1axfXdBFXxfX3mryAqRDWIbUroxzorYovhAlq+5rxJUmB7v+aq3ajJlcK3/w8PUCBKd9FxJ8zDbGmJ5zKfqXXqziDdUZeQSvrd54V8FNlItqxHDPDzYxUxBgawq980airVVpcTU8ZYPz0JFjeEd7j+arWBcH8A4zeXFpMKoQAPxy9jyKodJPtjXmj9GfGdMAzxrvLuAV7jREdzRy1PqROTsRcsZL1hBMcrsmCQJ6JlTcNUSXD0HgeThZqCBSxV2oKof6W/lJ7/qV1P1YR/JqrVh9XFGK99t0awGRjqgcrDditXrq41ZTn02o/6pFBmw906197qyzKtzIoODlbmXS9ehl7VUhopjTjVXlzXWn1+H/Wb75N2Qv22qClw8dp4FgzFr7uVj0NmIKLKa1qMF+afD7U/Z1WFf+zw+9ROamC3zql0vYTAB+e2dCA/pMPH6iODP+n9hsp1Bresss/T+nwwXThFG4LXCMagqE9v3Tzh0CV3KfOE5IjPBgyr12Dwq+JqGyRGQEKb5j7UjbvZRTY++lVeidZVp5SW5cjktGuqXA4LPnBCsE8D2PPa3ZuLENSOlGYiGE0kO2LSFofSIJlSBzF4xXzd9K/hlblw3fLBzS3mF/QFAD9ej4hzTAe4XYT3wldu0K0iE4z9ODmCmwr5wxR8efh3loBH8WTt9njj8uzUcQtxqhCcZ4EnlRI4fTKIFkIuYMGZMhAFKZl2Zy2zstl5SulqsF56ZeG7OoZQX7BoBD5+/oBZmu2wF4SDzcywJu9/SGe3hJqlVgdRkMFrC3QL0mZv7ThOninlqerggOO42xM+Kztr7iYKlIWO3WR4wgh8MajMoqZzAyZgln5Oiv0t47JckAkak9GWogDAWl1S/zp5Y3659IA+LKnqZE/0rIINcrCQLyD5AjuxIm7GLDpwu04XbsbSiQmN3Kr+pkmue75ftzuh+FaVs8HytXRb1en5gsPaIXHlPVWk4RuuDGgqdyq+DauXFETsA6F+Qe8NtcWLC/2BaLiSEr0vKcOQIX7ZrMERqGE0bkDfgOelPEY3FcNd7y6RGvfbWf2J5YtQuLmpdnfnsS1iGUHSDdaxlB4jFwlyfreqhTHEb1doQi77mupmQKfDbgkNfaJB63G90IRei0YdmYtDNat2lhk7hLBG449T4mmHn4dKIoJTucho8dUnnPi/ZXiKoblAQlNXXgt2KkHuqH62e20wqrhGxgml3YdEqY4JtOimAEvKjbWexmV6e6CyOBxscGQC76FqsGIJESNnThnieBzbZsWdmhdpO6Z4BfyULSDtVZFRvl0IZw1GbV5chZSexGGp30mbZJiP/wiPXdQVErpRgl75BEfAvArUj7DmtQ0LnTH7M598po5EkQrQ3ejH+CGmq0jALzWWuA/I30ZtCL0I1F6Dluv0S1a/UpdiOIo1qrk1Cnc+R7ijTQzVHp3iy9jo2/2nHXRrIMg6I9SId6+cMEZCKIHS8YTaA6W0uYaegHjuaHihyrAkWqkXPMvHZ0jyKsCRC74PLwJNuKqe1+wSWjMevu+QYkbR1PIquNrtOCORRgf1RP5ShFt2ytmrzO2mwTkEFKUdPR1ZIqIZA/Tb93QL2+TkiIprmvtbIkf16Joi6Rw2kEJ7PQOtcAN+S8NEhH3iq7WRIAgLO/g6lyg4Hw1iNHkF1TYadbMxxfUvDzWGNxfof9CUfBrRQpFNPaRlVyK0INrPgyq9pX4WG6y805VoheoB4YYohi6GHoSLLzLJhe+baXBTmAQJUjlgjKahozXzCPJ4981qEmvMCK/YPqzoS206Ba3Cf+tvPGRB7sQ/VCflwb5Oet7Mx4ukrprOeWtMT/rmiLA3mutbrDC7Z1VLMWiBRe+weQpbm96hY9kBf4Tn77cEuxcbd8vnLtOklXRHhLD6bENFiS6U5sFB2Ahl9qP7ew2GreoFPbdGYCZWEQzxEIULvhn0JeYz2nHo+/Y1WPGcHtGCQePBPBrWjKNThI07dspdQc7U/XYlUKuPUiRwAaXt+Ek7MPsQP1aSR3eowK5n+0WtEfkSK4YMgqt8WcboY1YjPTT0AF+pYBaT1zuLHvoAetKGmSAAxcU0m2+n/3vUl4GASZs5GACxhSY2ZKUdHbGLfDCzCIqDFVhOuCea9VYvUV2FRBAT9Mzz7w5y8MRyB0MSPIqn9l9+csuakNaAS9VFERC1g+XedGCURb2bu9qcKW8onwWtDCEMzzkIjafKocFcRYaJLUb6zM3Zr+UEgOYEQ6GJAWLZszSXi5MXWVbSLlfSSD4ZIQwkBdA+jK9d4rTD2HiIxpuZG0dWDPSuCzqmo6Jadn7Z515+bwTvXFHK86/p3APuEGka7gerd/60C6A9GhtTvrZNX+CO4OLydve6FzjTSoYR7Nl6JKP6sZ0OFvXJBe+4WnLwouPsl6TUVCNKzmPHZQPy1cTji5/Tuj9+UOhHSu5KvEJyxKVY31kQ2juolvQlLxG035CcskgJhJGbYbkyZdRcLGugvpf+YVUfOjodq+S96ZsZtJRQZPePr0MEr13Q/Jj6Z0xN92LeVFYYr6XnniDdysyKesai7ZSbx+Ma7OEak5yivDqXSZloTt7ZFFXsiTwfbztVdq7uC8cjksSFRZGMmNBMR/vswqB7bg9tYIXZWmqW8JBNV4efj2Os0cQjdKwBwbBW+sJOGGNEEqUN8QKAV/smp3OaEMAaRcOx2hrO2Q05occcfWW8YW5mVeT763XcwfMFoDbvW4tvu/LCHyGQq30CNFKpI3fl3jtgMpBEKCjF5hMSgTWm/FqCnRv9jpwRtbmKt9nEAMo0M/af3OYBPVzO3FoIL+QThkJxrDQfZ3K/bs7x/mAMioXG7WSfFs9D3vlbaOnvq/HH9ziqsFPULKeJN1LKbpvlkiuvumo5B5MXqqjekXtr6U8eUYKbsoJT8G4l8fP6BXv1uENk/Vt9Ogb1BvqU/uM+60RmT7GesJIeFcZHMfKbeAyyJkl1ZkM88Ybrc5+uiSD7zDTxwHC66yKJ/ZTdhYtuygOIHnjFnRuXE4SdA3fubbiQAoMxlBPTPWDacGXLtCXN+8I9ydExQiQ3zfIpHfuPtpbNCmj7odHxOnHTvxLtNgphVJaKuHoFObbf6oHuFbGQcZX6I9+Iw0AMa+k5nJAPxVC7uJap8s6GLJ2eMbP6AsGGJYGH/XSlM1wI+7SjVP0p3wPQMFjSkduq8UXZnzcKV8f6e91XugeBtfpM73D87grAHFsdeuB9m32QxEX6bs585tn7ZuLZpWX7AruxkxEhUGqEjoE1h1k6JigidUNRee7C7Vi6PP4GGE69xEEPq/HVfxl0c7udUxuPHzRN1gKrLMSZnEZC9zOVllDyzrkvNQHTA2rzDJYzCDHWRN0CQ3eHJwboDsipELqn3qyCZ9nIELVpNavzqjHsF9Ob5mV0qA6HmxIZP7h7pBrA4EpyKlSvwyOqVL1cZbYfmXLRwvzcuDQ9TSovfiwGdwmy3DjA1Eqj25aKZA3tpCGB/JJ6bZ/+M6ccLkj8OZ+x362OBwEk5BmcMbBDRF6/FYKwGVJjzoPSimOULtbpNYDbg6Sd08yWHSMXogahHAW2QQXJHt5QJxkyYCTPCC/pQfFLFuzwMMFiU+FLfz+7QFFH+zhCeKRPCer+vJVcGs0hnYJNiCqpIj1AfEHDUtabTBiVHwM/+2fP0Tdjto/KqT4BG3/xXZ1H7aAmGFX0DkFWHNuZWRM2i0+ZE9KVyly9K79EyMqrhihW167+4Q5yn2kkqq6P0hrfsEfbA+AJRsW5QxjmBH4C0Eibph+vge/+k6+3powigsy8CgYHLvCj93YTJ+wsBaPBaaSJt4o723W3CrbuMgZEbNcR0mhPsEjLHvdrg6gmLgeK6AuHPfYfGXm29X+PnHOo9ktJyJmUsFjbUqB3AYHBa87Acml41zbq3Vg7bNc+f5RKGdClwEYb+Lz5cVx33FLtvO/AcjQhR6tBQwNUeuSoWqtMwKQao/7RmmlYUSfuVD/DavkqvYmhoN7sEuOEd9aIb4grNepf7yhVPubx6Guvuim8C8eVtBN82NyyV6u6uaVinSI1sm690HWYxUrmSNtOCFCvAxwnszkZowA3VbZhD+T6g0xMaUfl3dXw503gasovqleetYJPJ22Y7nu4wvio8bN9JxzC5uIQvZJxQZvGKQobsU87wG2XojSOGBEdrz1v9J0wXttBGyiOEPxwvyEv2hgAOKSMgboDYnbZ0DvKhn93AeMd4ob8zJ7HfzL31kMS1hSXUSiblD+dSmiah3rzUnZSrlTQnwcKIGDkHdubbli64OS4dNseryPahrB7QtFWZk9e67EVbmZ09bKMasrGAACOzezazaevSY6CtkZAaCVhfOjqBkMcW9otQ8/lWzNW+m3IUVZllCvHB2M3QkaCUm71Wzr2O9AYpi7okHncPD66Gs0J+Ec1XOuRBQ1iNg3uRr+WvuYnf/PZ7nmCMh2Mv8L/qpifqvz145LGlvnpiir09anvSFNhRzEPxt63j/LeDHKs85qKU/tWzGhghCj1z1NBUeF2fA3828YUVFc9abnajmyBLQ3JPcCLGzEp0F5AtzWSKpktDkPnZ0hhS+egTFN6Y1/62Bb/gOxgvkdhBVVOb/5Oe2wlKGiL+HHIkXcn5DkHuuiUUFiQ8VgI+v50pEMHjxXfDc3VeaSoa18e6nsExQc4MdLPxTPkHN8Fv1B08IosZFFLn1niBY94lyGdL9oxMXu2KHp6uw4ch/rErIDCo3hiMKxIqiAwm7DZHq9TY4KxQd1Rojg5wNboa9dzVtOL5oryuw1CIX9OAYL9KJcubod4ayGKaxllrkx79rTnxdzV8ng3HUNS/r4ti4R4ka2+D60ADIOmQjmdRuz1gxLmtM2Lmnyphm/mK9xjZeG5ccBZH0uvXKTLuXmV6tWaamktHwzciwJVqX5+FiKI2CW7hD2L5TuiRw9C0OjX5ZPsVe8loqnTuDeI5ToUqxVuyIvoUlvt2o6eUx6/qiVO9h3e2ZJnAIQtcghrvviwY/zlTNRGBkGv7e3sOAz4sdDpu2QF9UdRFRpHBNzuPfJ9e8jeVBvhAzAkfNNdoYANkdCb/4F02Ud2I4NF1QdzDTyOlJ2tz4nA/Bpoz+KRnzlBOcSBh5Efo3vYr4Xji6bNFImBvUOKZFg/UbUrPQSfj+kgfL+8yHblwLpMhmMm0ZrN52eay4psn7PGKQCU3vjbmNuRsw62hQhC5lY5BNHgCLDzRXg7yyCh+Aw2EIUFngod4r2yFhPZDeg46SSWW3zvsr6objwN3ONGqE3joMCOmrhEliD4fhB0zrdF6nVDTFk+4p3jpHoxnRg3bkY/Pujd2WA/mdg40GIhyX5KwMsende5nNmUQPLq1gTDsCLbZ9uStQAolz9rMg7Chlew+/420ykudIIqjtdItJAAJsvF3C1NujUyv0mrw+nEVRURU6t+OfCJO8X9KzosPEBO7vuqLlklwnkXl76oi5ImdJQux1C9o/7kkXxEcr+6khsw6q3xpuT+L9+ic5/z4UXbVAhda2cw5nPSoad9lj3RBUzyqLLArrVP+s5j7FlzFdboH9kXeAtuAmUi2tLTz9Ry1fu1zidOFQ8V8fDVsNPVukzK9vm9GlkI8/15GY6Tx8Bn5FNw/tIcjRGSuGPsWhdIiQjQ8Ilb9KKg6bMmQMaSmiGhR4VU7lOTExAIwm4r4voEko9gV00GD00Ph28ShzYT0VdudYgoGzI2XoBSoYL60+Xfi17xGUsO5kEEmnfo2857QZ+ydVOiaQltCwCiFq0Hd3dm12tppsLOhnBFE6DOegVc7Dm271OLvPwzgFIzI0fklTgbhWCdCYeomgKGHGdrhdK87S9XBeSg0fXO2KjotBtV/g4didvlm8xQ76gzVgyIRbEOXQbUKdc4n2zRCYptVW8rF8mUGQ4TBw3Dg+LHiQyauTPf93NSyItAKSyoJFp/HGSyB8ivmI3kmfsJe3XlzNcHLVZ1niXx/G1qmlC2T3dwWen4enEmsTVYe3Hjl8UpijoIJd8Cy1BUtAaSvASUdU46uPEQnv/cHerjn2grBokMahYGCKSGbpsPca6zjviYLpuPb7j7I3l2pRcX+0n4xG7v+F/iE1dRvGCy6fk+IrjQs3z8j6Iony7E3xJ+5WvqJ35zIxEBBoA/oWKsz6w38DWsgMs0hQ7PlLTE72Vfu+EfXyAJL6MN35bYVKczdoSFQKCKi3fLj8+pw155ty/S8q5MMiiL1vBm4fGpXz0JjjlFJjJLIv7Glasz7xE1tWT6WlLH+YY+/PmEXAUxft/ekaWrcoIGRTPa6hxmdufuw6rKRIA0CKWXzlNC7cY8BdeTc23T8zUUw8iuhqfErK14jiOzFvRfYVLUkvJRxCkt6I4V0NeasaGeVqQUwr/jxWH4EfJiks55a8JT0SkNZY/duiovrXPZ3wfYtgEgIOIjsp34dkGvzVkahNmC04B4Do5JAu/B0HWXTGCJFjeIMyvKgFZ+Lz9r6ggDZAAcCweOqymb/0kOH7egAmw0tNjZIP5YN9ORLKspYUQxW+iUGG6u3c2JJxHtoUTWuRNdVd66AHubmJtRVL9TX20/L13iyq55H3J6lPYFzLQHfEzB+xGeprnaxqTBWoU4xxEjCZQMK32XlfIlEm5uKLDjAzWWZxDIegA7NwGtkQfORttBCJKicRlRd8BIXjLryg0yfYi8VNdDD8wdBAl18wE8L+ldU7A3XkocqKc6n6QaxT6mRTS9l1qEE7kkCb2kjGtKw8vYmNDaSlHIWB0lVkq3hEHJ4ghh4SZgxxcIhHJQLUVpJQCwhgYBYZKP6PlWrcH2RZQaTetYxKBWhBawO+j3H9UiUSzsO1IYP1BY2reuMdstilcAbVmR6Z/1XhN8wCiLfghnVSR7vVqLbsEvGxCoJE+ZOpgpqgtBqEG4xRFSuBb34HUQaxFKGlKS3RktuUxr0dKRTYNyOT9TmguqgR51fs2EANQTxlKFLYQ+kx2z9fg8PrNa259RpHIaYqI8AqzTVhmN8uqYy/BDWnAlZUe+27D9nVXssLew2t7y0dhPIluCcn0+/GqCJCvnDlvmq+ZRdXgx1/kbzF7u5UcVommehYlkq8XTVby8IK2Z8aL66/1tw+NDeXVmcHsJXxUSHV8CSIt282LKRi4yhC29hRAeXC16J5Fk6whmphRPD0yKT8jiflnYm7nd5HjQMe82+Bg+HAKP2WifcorvNStlYhYeqz2DI2ah/3IHhxjIZtNWEo3r5jGZ8ayKBv0kyLfUI20MBYW0N9SFHxFZlBVsEj4U+6GSckgwhDALlRdrGd6vTrAsAQB8/g6Cd2Fzll31TvfXYCjSk3ACqElCCOG9uv78j5/DUPsZybXcI0TBCy5I1H5Jd3C9b15KWdWBmQhTHgtl9A+batkbls9arMYzG8GVyRXunz9qJwPKniok4Xc2wzQ6M+oz6armFkK9GhzF6Dh3IW9ObFQKsVZ6qUnH/s2A8CgfxLWVI6bEoclxjbhl8K3ZBa+zxbSAngbtk30InOaMKmoa6Cl3FqjWcS4aXeQ/l6oUfceYf7hJg/xHJBtfyPWHjQMWEMB6tsR4h+kuK+a+vOYqkD9rRPkGbyHjTyIR4hQFmVwl8sJzMZ+i+vmPcP5tjk1UFlep1DJM/tifFYWr+gwWe2xjFdefIMVGCCCer3vmma6HKQKBHWU1W+kKLFTztdCO+R7P4dqNQnd+8fAC53woCo0DvgxMy5vHQTvebZ8DNreu0jadKOl4RcXeuIVuCPBpjsfGgibEsVbLrp7DhE4bC+jam0OltFzpg21n3XTiokiYGzR6yQuTc24RB1UzYX47uFZpn7OQ1Fp89J2FYKo+/biCg6ay7clZ2EURMNnrYyuGUM2qBfutEk1EVz71a+cIJ0WTGRoKWUUni1qQ0Q8jg4Qhnwbcd5cP8TQ9QIaMf1R/Cp8NaoWV+I7nv6Y8UoRd7eip5MAeVFROyPnerA7DvD/RgHn0iqU5RY2jycYs3f67UJTS/kI2XneXvhPDbn2++5lrG0sJaNJHe14kUrTI3tRAmGwM/HDyR3q3UbDTgtxAUVNSuTgzWjFJ7e+sb/2lpXm81+U2O89CWhVpkgDAFePLoBQlr3dVKWoCaJ9jg5vsTZ6kA0MRWc4YfyeQF/DC7wLxDshFUjG245ZmRlIV+jdomVIFGwiAUl8CI/d7Fmp//7IPAOH4u9/F7pMhluqyhCs/0rwG7J/6p2dMYygahZc8JNMsB6eozH5aak/CiUNd1FuRDgxTIE3FDbojisC+zV60c8TlxENR5TaLw+nfcQDu6gix4Su2HIwQQ0mu/q+NNx8H+Lm8KojMlrCjBdDPDNMMzK7qDGT1BY25+mqaxFQXQG/YGQ95kBfh2KmFWsNOYInk6wXL2w5DHCdejRPAb+Tf76vGByxkvVygpobSo1Xg1LEHIztgIH+5KR7/b9JCuciEIxozCC4cmx8UhB7Dvw/Wv0rB1io+KdaOiqAQBVkOfQSxBa6xCLljqlR9FM0L56bCYgmZ8hwfLMc3V1LV4tTDpGTOfprrIgLV0oGkSCxkjc9xWF6E4Iajl4k+PwhEOLlkIRfpW4qor29LAmsIP61T0I5g/cLPS2Go7LagDCRw71r+OOb/M9hW6IhKyY2lBRptBtCDDkZK2u4ZXNvojfHWSCoGJHvRhD5VGmnF81PjsgvDC87bCwrTatVWQtlb1yXQcWMfG1yEOmbslh206JzsmHKbgRduJeO3jMNPD71MkkJyoeTlBze5oziLtjpgvJNixMYYevmQBuyS44nlFCwwKcidNov3cZNKVNuEC1DeWAV+Ntu+EzjQzLsDl1JMa7G8RZ+Njg+YjK7Akjie5TbHQTs81yLXShkzR5sPSYj8eLKhyF9fAdQqojU902HGv/UXr9wsf4aLRF1K0T7TWETNWSz8vSuNEWZpla1ZfiOkmFbKgoMO+dogc+N9BaXP6AabJhVlIImZdacShO4xIazlNwTv7B1y9kzjmXaeBZ18ebXcO+npVoxyjWdQc20OW08C4Dun9onLU0zf9BlI+thDiKK4PxwfAYF0TGbQq9PXkn0Fr/Q4yyi/cQRn/gQL2Gsgi56e5HSFFTac1sto3GYTr1ARPO7xw1P5o15KyPfczCNuUAYNCWEgpsNa1VLHw3HszT8rhqMd/Nybtw/Yiv6V5Cht95GQwvUHUQ3OkVmt6oEm+aOTi6FGqlD8L6G/b0/4pGaHkNRqnUpoQwP+9q/yF8D8Rw//uHS2l131sdaXeNdl/K0Pg5GZgAUgE+BGPg0Aps6j5uM+iY2ugwxndSHEe1E97UXnCGIm+Qi6JfZMMp9Btskt4tUfa4xSZdUpXsns5TjWC9z8aRJQTqeDsiHg0wgLL1JsQl4LDzUTuTaixnP9eJCx+dTek0g2fjJYET0MvvHHothee05XPxPL3mPFPq6wTrcn69YhnFLKN2yFpY2mqY5KQX8x0m+W3n4Ec/kAcPTQ6kRJJ/5VGt2BG0cwt+j6b8ZPBRulBJD3UBW11D+QmJIO98qqQrdBy/srDSJFxViP1Qm89SE444JEnwOzOIsiUXDSYi/ll7GxanXY46N+Jjt1BpK57H+KLVTMFH5Slu5IOaBGbTCIr4N7iAtH4pRemybrofc5MGi/ZAf0EuIE2ndZ4FhaouKd6Eg9gNzXuWb5yrS0kpku2RfsfuMgfvAzXIU6bNyBzUc0XVvPmPXfUvUS1vv/Frlq6SxBXJ32ouakh14WzecvIbdRKkY0K7RGQ+4XUosuCYVvLdvxeYFK3NR1MXRnjcYNpoOa+a2X+/GNm5CVNTFP2wO+2lnNSw72B3lxJhVHwFKe6U+i39jDNCgZwqzIcEuCYkk5rhg3okdbP0Lwj+QKHznr4SSGMevaE7Doea/sR03IUXL4VlOWKCnklHBBtMpbH4s6iOP8jVtD8ZAiTd9xYUqXpkozvhPGBq6ADYTuOUe4PpZntKQI/VZFOwPIjMFNYDf7a5/YQx4Iz3qc1f5tkjPSn4HR7ri85sYbgjkbtBP55hyd06n2bNgCyaJEzNVS4nK9JY4EzB0w/AyeFMZC5MGBCRvkSjGqGyxNZKeov+IwreCxTiofVEGaz3mJz8cHkNFJrE1rM5Fzau9SbI/PAxpUMFi8oNzHZ2IjmbfLD5TK6hZgGI4zXWRjcmTCO1aLbUREPyAR6YpQT66BsSsTv/HK6DaYsdckshZDlN8qbr9FXRSz+/qspMd82qmP+uaui0cqWjOQEnTYgjWhT+APrY4Jnv+7PXFmeEFM07NRqWKzUPQN2sYm0f88yeKEv6JasGLEkiRd0BMLxT3fwRO+1A0wIJ6VAzWL99KmZnJFD0zyeAhDC5Qlw6lwoL5J8nQ27C2ypb1ULuyamlc5D+qH6zzfH41eDq6je1yB8sVz5p6AMTUTK1+uHvAIbuyAp1KNDvvJznIMY2Xnl4s89pY98ao8ML5l/WcaJbyzy1RiwfSMQILQf/8SqpVRelKuth13I+cGcDdD8AsH7WmYPbEKbwRxCIaLox9u4QRg52CBR8alDEZPZgRYwvuvDiui+5sn4GZWjrkrmp8FqsYODjKbxjD9NRx8z1HZymfa1sVAU3RaG/E/l2UmM71WxjLnQk+3+hVIMHbDWq9tdjH1tq8QCPAlYXulUCyIaLNAbSWnB71ZMqDzCTKupwOs5IxDgpfwbXzxFipsCbPpV1EnvotH/pcrdp8Pg3V9q+4+av6ebm5CyBJRvRmd2I7eCkhGvt/c3Uq9OVynxFYWktYWhVx1S88SwusXeJ3Kei/tir4aC4lE3Ig5TNGwTbY/RbGPHceUrIbeBp64/asWto/vAy9/JFwNCGXsq6kFjvyzK1hDSb2CRz0hAlC7wAhLshf+Mr6QmEnmCkMBMIlLHVIdAUPeKrQQcbi8KRYAj2Vy9XdKOpPNLQ2dQPcUMzh3k/TvFBmNoRv+7EN3zNJodIPDrjla3u2zQFzObVXgaTNti7g0IGdnBlyiN/Cpc4b43MjO9onvsKjZFZ8qmmFKITvoxarYcbPPZddIqoiejiG0BWgCcrac9MaLvgGXm8MWk2m5W7dGkKYhfC6Wn/TvanX5KEdCqttw5zADWg+5z+G9ayQxN5VIpt3fNh7aLp/EOHfLFQoZTvdKnBEXpSOj5MrM4jqDMLzZ+qRe2D0t522thvcerVOhS/T+fOacnhPczYTNQEomb4BZnZmQGSD8oA5wHWwsb0b2xRug/kX2gtxDF7aVeU+wcV3wnwq7Sk9N3EtqA7oA0jbBOGczczdX1wbQ8+6eTAhceCsnoqROmV/WXeqc1gbzicEzGz7Ca0RyOyFkVOxR8bXJ6Aj9z+jsXbCQAlxAejEGSl1eC3eplZ5sUpH2TVTIhiM5J10V1gssWJLooIJobo5heroRQ37E1s2kpMV0sIOnoxcWEr0GBOqBJ2K9jiRUHglscWBQBYbwTozx1meGEMWRM9tIoWOEg3MJ/DeITwaS7Vw1XRgX+dFKxSOyle5qW/U0EK4r1279iteFxyqKXeiq4Xgg9/EhRRLofdRB63cfJpHU3gVEDxVjugYPZryIWTmuHrClhjZNRowkCQ2GMhMplz5Cvti0zrkabNi1iyxKGl5IyKAAXz+j/Drz36uqodPQ3S+JGjjVPloP+uSvkzP3ym3NP7gL6LTXSb9AIzABvKxolfTtyCA9xzmSIxbqJuyXGbr7jDacqNPW0jZqF5r4OiHJJmPCRyK79GyVlu5Hlzxj0eJQbxG3r3Gsl5IV4XnCDwu1SCMvK1s9auFkfWrIbYW1iTJ8bCBkTBd04Gf4jccCr2TmcdI9xSfrZ5zwRX2Jy0lqpfD/1J4XISn6c9xsheD3QcE3usZBwG4eyzvdAf9eV+tSBYiRp8NAJsynORVSBYzWRSrEJ0zp/K16po5tFplPzMxqTEWyX/vweWOvbsVUBycuUUxQCRFlYrNtvJc4kk8MXmOLuRGU4aqHs5e7jx5eXHD7371mMEzPB4H8tNGW+HnhkxpXEZUXphlv77deOVk7x7tn8tlfFBW8hjTMSA+wjntNVcT5ZCaNDfiEsPx5IyMSZupVGXMYnIqqXfVApL9/ZTBMMv/5G/Qme8hcnOD5wI0XBTy73qSlsKs/TNTtiPBfbNxfljq9vA0Vu9sdD+aGa64Gtq7wY5nCMgJEeu/KBhlRpVrNHm400zKXB+tR0rERcTFgCAjGLfVoD4jYRUEGLnHNdgdC6hLZDSLIYqVU1eaXD4hxy18yAf8RHQ+69Nf8/p7FpxdGsnxpHYHbKZNfQZ6B/+Qp6U5ukCeoAMutiUbNGVR/cvSQ8PvjZqyDCM6DnWtv3EO2MxvbniBP0Pu7c/Mzrhvk6onrsoSw37pwR2x6AbtkOZ73MPFD4xeX87eFtzoQ8uJ/c4GvAyWrOAEqcoozLkcK/xn5MCtzAJko+0xNtsy0tBoxY1NIxVy04TRoW+4E6NkpklgSN91o4y3oQlUByrgadqrM1PnsyZtoh+DADHlExq6wQeNwXAmq0tY0FTqw5LOSkXLKjqJYYYcdAk8qqfcyJnJTSrEwQ4w00eLlbb+4FCah1yEYMaRzaUKLmpK3dL2joW/KkatVNAXLr8pz+5A3RW4x6SBZwS5wbU+SsikV0Mhet/xvrd63M/CgVxWgbZdIxOHk8/aD+18VrvLvvwR/ZDjBL2FGu5ySR7vh/PmRxVvl25trMSWreDaw38R9eaH1P8v4HhJq24hXMr4VlC9WrSZ83+phmCZIb3rMX0hhEHnPiV19NzSarGoheh7ywLP0ScGFyDhruXzlmmU5hOXcJJQe5BZlUmU41BpiPngHFbWPfRYCZc/do4FKfg/K9O0M6GkgtWP3PPOu45QU9iS8GFlmed7GMEuDPSvtO3h8CFZ4VCN6MPEXhDKOvjuxALEFnQMp9WRsHvUpHo1vndSDrjgei0JyQXw8d4u1nFQv4a3nYkiDWPGvmGer2GIs9cCe+nmyMiHiRF/yCDdElB+JPHTebXPb03dfB/4uxRkf95hcGDDyUuIgWaQhCKGP7RmTJFvCWFwtyYuaGj6AcM8COXt2NFv/7Dot0l744lw76z9fGzZG96ZoxuzTUA4nsyMvTK7rMAXx0bD29wcups2kIRaysfyRya/8IGdMXVq6Iml0h99NWwityjcqgn0+ZtuzvZ5KKUz6oBhaRAPTVmtX1tD7w1qsr970rn2NP2+H592B/nmGTu3+uWvTr56yjAeZumR3+8GwK6Wqtkm3pQFnXf4UJlw7C7zvKybR1fuQbmfrOnyg5AwTnsrboxOmL348ix2wDnYVjXZV/byk+aebs/cEuKbLLtbkmzPs693Knv5EgtPwQY49lhnKZqo4vpz71JPN3zbpZmNt/AkXEtl/x/REf8V3NU6S24ksL4DT+1aW6cq/ZAu/X3z3pk2bBTXRzi0pVz4uAObru5X1Ap2gReTZtPmTpQRz36Bmx1WoHnR1SlZzkLjog3FlcmP7u6ZjuLytloeoN+O4B2nsFto+3VfWGvWZjaPkvpDpCd7xQ8Nr/Uo0lIZ/02K7qiFAlJcH+PlQnzOzQSECVK+H+cYOB2R1JjL10fqaScX8idyeVKhDP6UVpcjzdLFYZpsi7My/xVwA3X5oVmlOogWaq30nz4cnXR5Qy/x3PGbkBVpvpzROzDtfSPQIrv1iFHh7jP5TDuXF6JgG56tUlIRk2Jw/MPinpU+fCxhGFZFPoqOs0ykqlB9tfKdHobI6naqKb7FWUdbPuvLhNPxi5p4jWdCXvbxBh9Of4ZDgsplfN7OjNEcD/UBjrT5HAMD83XJQTUrvBkvLD2W5DKeDkLiZ5B8ebXnotBBsO/dI3MLEJN6aeVkIEoMG7xtMV75WbZytqghC3zRew58iI/8ZJRkSH5DVkTQ0msnppE+vdIIsGDIiefcnzJz1hpF55OwyHvQrkfgyeyZyjq2JKAGaIr5MHZ3MiK/EKaGNyBMcduMpYX9hMPKZr0Bk8suYWiXEonLE8TERnsvmG6V5wAn+b259eSgdXZU4WWICpUE2Qhy1B6jnJ15j77BSUOwaT8b+VQ8xihvmihi6tFDKR730PvYmfm8fwx5IEQ6KrC6wpE2ME4NBfUmj6ydUtcaaIOgvIvn1CWBq6js9S2HNxq+gOu0BGOX3OjxTE69hTlCU22x3u7kkg3X0zE2D33FFWCpGeSNKjbGqC6lYTnybf2gH2F+1yhaC+WmDzPNCkC0uffv4z2PT6hpQoeIS9W3uXlMzlK0IJxmIlAMy+EK9FVwM3kdUOUf9QrBnAmzDDH0cKQqYAM6X4fVPS7IqvSH6iv2OIFM3zu7maWWdSQE8fhnKr3dRzsdvF7Ew0kp0T0wKQE6Akeevby9gteqWzCUMHsDaP2WuoPT01GAaLBYSDrJt7zo6yfS6oGmg4QwjVhDZpkPIawYBxrg1T/WCOIJuNuoY8zwNLiDwMKB7YB+aua7DqvPs/Bfalxysmkl3J6heO4nMqMiC0LQS9/uD1nGegwGK3ZepMEzb0l0nAOYPxdj6/0xCWEayJulHKO8Yc37mo9bh7SWQ7sWXvjE9aMQslkUbXE6NL9d5/BByad9hLXkQp1y6q8JaccYpl9lXZ35iw5rJfnu7IaPDKlil7QdWHVzBLPWqmkX+ynPXIYWcikqb9dh65EoddGu3SAoDvYKmwTmVfU86R1SEMusCdCb2vz9ln+MZo/3AiajS+E2kT+zM8YBFLoAsIdukR/wxEvyhisgk61A9jWAHk7SRNJSDajYWRnQDE1HiPlff9l0d7IM+eOMchW0Yy3e0DcAa5OUpDILEQDDKauZ3RFk4m0LKBFuKnNmmIla6G33FUszjBmrwlQ9cseSVPFTClOKTpHR+GlAlybMqVDMivkZNKtXdQN87wSH2LKOMOE+c0zEqLsmvsw13BgOH4iP0GKwFgRiSeGZTByTdvKxiuQus5kCn/DslNXGwihUW7z+7ijvWCgyvuALUy18IQSK7zihr0jL+c7UXywGlLg1SOXGk/DSkIJNV9kwqj0eD+eEYH0E+0xBir98nVT/AT7JmvsZKSkhr8slacFtQ4AGCwi9XAVLQ3jbPOdu/b7YKlaJuTY0v4QoPI5D5T7M0yaX7JXRJjNHhMCxLHDaSMrJ3KQGE9zHdbNMaXdqmcQFfR90nZVt9w/Xb1EFQESkhO6LSpBYKPoyVMQVZ4N4vY2+/Ws1PAUsKitbR4VX/hfmwLxoyqTjhyY4rgONreRIdcAwJF8btIPU4xFB6LyEaKHxmZxf8i9hzC4EiGMPf3pRosTsOx5gbVqvvfHi0bj0vx/GhWqiOvEaMIYX5a1TQ8h9/m22exqAHpSYiwzBA5Z8O8G/DTVExLPzXL3REgbZ0ZXzE5fhRE4N/o0xSruq5joWwybIr5LmSGdl05XV9vPR9+14XshMlOQrUEvack+I7dFto6z+HYIeDiFNYIuKqVs+4N1F5yMCPi6PDBMeHrxJA6ZJCv3arb5fjbsTbDajL7MH6QXf3oMU8txfGK2BzIid6A3iF4WL9/H5qFsdnbHRew+ypu2Z5qnfbiLvlCx8Nyv/dfWvHmiphDf9lKGwGF/uZO9toA9AfqmdLcvI0kiYz/516uDlQGMILq3W/t75MjVKEsAijIgEpfpqDtVK7RCOrykQtI0mHX2Pvqyi6P4ohcdf/OuFMQ2VZ4fbGJux+N+9vhBhdJgqVV9/TU43X2DRGbj6HcQHZgqXEcpCEjNqcWRgkA5lBruNMx1oJYZBCuiet+Yo8OIIam/HB5qHdJb8VgVz3mBae2CTNag950eOfdpbZCNcJVH/oR7cmJWkB+uiZQwR+kHzxuJLkqLJt10qbuc9zp/OGCJJ9tWvQ3JMOIpYjjHslh073mK9UiaxZiE3OWeF7ZjgTTpKONLWIpD08sWbU1lvjqFZwcC0ymL7GV7sE6cZ6QURDwZRDpnWFW+X/YVLwfZ2Y+kJrPCkF793knUg8CT3raC7mVsJTuRY7Ylwt4G4GBLXfTvVa3mj0ALEAO4WaEVUggv53TQNLu8CLAHkvyRfbdZM4vDQcVP3l12rVgT5xEIGrvvXSz2LgIE1wvq8SdKDQgoLjYiCV3XsNdlcPMX3iUxbMEbHR+itCKTLJR5dW4YdN4eWKj0XiAwNvSLo4copZcml4HO1Qs3pS40qUrfDQzfuhiSUJl85lFVpTVwGmEQs10J+S01NG5oscU5so9NwWGC0kYq7Jf2tm9nqhtngp444HSeEOVqfNWTE779GzUlrEonwLm+cO7N3KvfC7Zs0EvoWyIiQkX6xX7pmmyIS5GVD/4k1wtYgkyhr4WJrjexnUn0K06W1aO5lm/+6gsOxAHGvUTy9JRl+B2Z5zU5faNCewKQqLwhmYyG0k4UxrBtgkmukkyj1Qjc8teCzYgMipUNeMMM0j1+9D9Q1NVX5hDlvk/00GSd+8YuyBlIyHMLFReD60ycD1e62pZ4HiurAIr6Jtkh1+GGT9u0n5OZqomr8Sx1VCnCAgHbUQlJdhpQ++HgTToHINRcb2bROBTVInQMMASUu4FzRawURgaipehqAxpeKonpQow/HdmNohX/fxud5peKN5+WrWqSw6igN6i/CdywipNTQ1e22aDldPv5dw7+FGRgtlsyyBWInNp8scYjjYmxngyQQ3mbBbcXSKqOaEJ78AQ1X+2mKhT9QDzjfeQSoA3f9OMVbHB/YAixh4/lP8YOPF0USpk0k0GRY1K6w+mUHs4BBGyOPO/eWx9MJXVEni9vMAquKLY+YT8cFvZU2/mlEVeaP+ytZznXv7XQ1yQu2OiIeU4ptPFIHi0hUuzosa0dm0KF7QxbMcQZzvVlP/QtgyC6KzBOtsyJADp6hGEhxhSpLoav31ZsnT9HZpdZ+OlAggzfYtCPTfDYsC6H/uMVCnyBtZHxyyNwwHOBAZ3JzrUllOXcw8HqK7xUmJbJ4zWNCtzr7W3TLt5TXJ5rU1YaFLrfFnJdkb/gmsmSdZ7xZyy0s4lFG4SHKSQHnSMJ6Ud+NfOWoRJcqCByQ2y4uj+AkR4g4pPOkQB2hK0dL0XfxQzAxkBKx7uOoM5NE0D6UVVcpY7kVWiCCWsnQlmxdZsdC42H1FUUe7asKalLpMhOxPwDBChzuLC2kpdV6ClPCruCKuld4KiXiLoOz7p4j1827nwJE7jXs5Xy8N2jT5g+MrHAVRuilctHGB303HJ2EehvXm+2f/u8rV4jplvr5MYmD3oOPh9ukq6j2jTAdLI/QQ7z8QbJ0En0Ft4/ys7vhySq/JQ2ftwXeMgUw+Bmb6/t5RaUe4w8Z/6F2+faoZkPZcLhOvuytQKlcCDhAcEAR+UMaISyiCxRjayxFZXGNec/ZuKWkYD80JIHC32iiR9er/HIpzjywiCa0xzA8eu63w3OQJqR/B7FpLKFSNEX//srJZ4TOLap9utTcFEUgU1eueE3XTYvU49+1szZ7daIYOMwDVqOWc11x+00BJqG0W+1jrDlz/AVYXtMAbMC7ZDCgOFogJ8Z85ptfBKe2jvn8mO0pTrt+SOUCOfs/NmeAc/nOyfOAI9+iEqzg46UW/i04egIydG7g/gMN5zpnWxuzwzigVR7VPmj8Vvh4AoyG4ePDQCl0dfXt1ul+X6GhzuVIBdGBa7Su+uoS8od+6EMl0zcq7PfpRoLbrdUMSPEnBxzOd7qns0KCLZp1Is2pgIhf7YWYkvm7b8IPAjO1/9KFMBnXJaIXz8mUJaUWaGHQJGZlmrurPVf+KosJvRudYHNrFld60Zwerv5KKZA+9aInafHq71/GcM2zYzYlBZpQsP8VQ4ZUGUoEkfS4C0AZn71HAPGxpepqnaNzcqxSByA/76ktfYTT1uqEohGnIPEf7QJSiWDovv19M8vd85jwhxIYeFcx8AktW8PlN90sZUWkQDFrok03TkkqD0xUG2iONK7guQy80oZ6noVLLx1NDtl9sYoiO+Thi6KO1sqFU+/hkq2bWzlEvWbJSnK468EXXricheh356pvf4klu7NTDxn8gg7FpN8XbcjX8U4Yn5x6fmsKTqqxy+3KnBg6xfTH7Cu+HLn42yceW3Hp1PqlIbJYWvbp6WK6yEmJ3lNNAHGSWcNmj6LhCeunk/3PoEgRd9hzBu0Xuq8TbYyOM1ZptE8/up6lICC73f+WUvrOVanjBvL+ZTETjFFT3Rssc5kEsX78eMB8TFAiM8Is05nf+rdpml54oJd4fQEIPuC1etCsFk0bJzrPr5jK0gP9JLvWb9Sxoht7s2J/4Wi3wmRdEF4DkzzEyGOO8u2RJMq0aDmGXW1EhKF2WEAy+6GJupTeAGPUwCVPF7LgAo9jm+joQocfGwcmp72vROxgR8iwU4hzshcxrdepljFMGpcDhIobUPL2fJkjl+yIyqMCXqYBp8+9ywzPu78PU+O0UZldzx9E2IjeEIA0SBnArW95utIYICJ4GPAvoiV1fiqqhz++MgDVNTBi9I1Rcp1d95+aiCuFhJ5ub++f+/yTw84L7xS5SBfzyi3B7EYW2zI/2ShXvpSchIYHvZ/s5B9or4z0CJOJHUmiM4VJurauNzmRpQpAfvgeAbCOBHDSbUqNC6e3sccuNjQByTDd0K1Err+ZxwhiYl0gcb2tt2+wT6Rxvc0SkjLnpO1V05E4aqLtrinaEveVVmdFc5q2Rv10bkdu8hJ2aS4a0PRG8OrsAT4wZN0BfexnMWY8aF7VNUWml+seQeTjSDl5a3ie37gv1OLdki58PXaGmPxvbQ+nNfRlfjRx0t9HtXJtDl7YXJP3wYItcz2Rpi8Ozz7UIulDlD7ey7xYRP2pZ+0AmM8M+3hTqBZ9QS0pSosKZpgavy060Ia5+IUY6DHT/L/FDDOrmPnof7eX2ucPLokk5N5CzVdUfYypktSOoef3Qf1SvXFzwz/w9XhSuuq2dMlRpslMEwwHJjng0OymlDhdvzf+ndjs7KbFjZkqpqRc/3gInCYpWQGNXoK9gl4puDmeig0N7WYkwMGBoVsZWqTh2VwviwxnBPMPshIGTolAO/Dnk1eQWbvPP84BgkVlhW11T8G3AshqppEzSX06EgkeoI7nsYPvfXnRGuA7+Q0yor45LLzEw5WFnfqTyqJWoZ8RRmaDXH4kiKuVUdhGkrfMCla7tInCuXbdWukh4V0nLYSnSMDXeLlz4BkIgt0bel5FoKA5uOYbi7oyvr6qaU3BmaHsyT1QfOLPFKX9gaPRwEZFxjqzQ0JKb8vEQM3pMPag7PEpql6FOE+t+a4WhQZyU+zjJdxoTSEWQWObOvZ2CMGgsQ3Mh90oXKFP53fN8ho7hJEXFYB7U57CKAwdHFx+t7RfWmJDVVxzGXdRjyz6sS22uzuSbpDybCiuai4Puvoi6bV7TVotWJXr2t5T865O5jTTJPl8Ip1wgcXddDDlpqPRVXtvLH/04Hp0VtAg+27sSa3EoM7XkVTU4wL0b3KSMaxo9XQOHMeomHP+ew1nx56W3MtoZhUpov05C+ZAga05Qoqgqt8NhBHNxmpapb5dVcxwxWgI2kOVemlRzgXRj5Kw55n7maXGx9qYYUdm1nFTMJv11R3Wz8a0r3I0ZOLON/OLCIsUSw8zFSlbjEA3iBcr81NedQ7T8AdqZ/E8Bn6BFYltyV15DhwaqeeQt2QKeVYZEF9e9e5Cq65Q09F1vhyLMpQEOExlZHgGA0pTKgJXFWOXfVuRvHPscKffvEp8DQtJLls/4bp9GwcbmxKO4kIGC8inhoaT3eBpvswWVKGNaLy0aLpkQgN2CLaqoRjSOP0I4sV1AUkrjnjtcv6G1+ulUrVCNPhjJbLVaZuV36HOAMXUYDZJMpiAwCokM0Gcg4vR6ya6uoel6/DRvsNcO5pvJ9f+O6ENiOuvsVOX1yYgufBiQgEieaOeqzDH1S2Uj3KCh1MBV/ZuIxNMry/3kNmAIChcrRF/3uqvA2XmWSIjgW8RhrFUz36RIO3UpgH902qh0u3eIQmcMVLMHzP3VkWNeTYyxxnCaWlrF77E5awQ3oFzIQdmnXu3XW5QusgpeG69LkNir0c1LSCzFqxZLdaqfHgKm/SwkOCdHTXLRBFMBqudA1Se3XjQwp8HLD2uZs1/n0be99JG5h2U/Wg4e6DVS5i+OV7/ISJNth8aGfm2edKAiAkqGIe/RIkTAWhQyeD4HLoyVsFNBxzKb5Q6bf9s5vkpswXwJWFvx166LY/9eptUCzP16+iHDNlokMRzTE+oe9UPXCrg0Ly+kJPmqkSQwwFI9zUMeAMWKpysH8/RF4x6LySrXs+heDyfzmO+nt7qdWKD+VD107S3zZcLhgXDBIBPDV/yMP/KWUrBCwD0fjsXbH1GPkKPbvZMaxa5pgFv6JZ4VLmzdTixW4y19ytlCoOsThOPoTu+I4/ZFJs7xswBCtQqyGdzvOk9ZsheW5pWnx/5I3Zv9gbE+HFP9AsylZ+IHdBstOpC2WcRvk5RjTq5sqyGEdHGsAXenCsoRJImTJEdSEpEKXQ/+aChxbG0isUdocahyvnODzEKNbql/gS2WAaVguke8IAwKNV9GX6mugDEQMeuipqFyfBXjGAhS+gXnRQYuj2UqSOwYj5prWrlXSzlumAqxZ3kZGmgniphnB7H1nveeLPdZPxA8xQ7rpr6jkFQ37S3VwvNB/SOZCRORPh1bKBdtWZRRP2M6zhUE44oJRE2gSobunZ0t/b9Uxp/wB/Dp3TUVFL1znafm1T4dQq1QjjoAvFoYCqOzrpDU0gv8pk3nSwXKE5iO+luqlE2svfWmgrbnOug2WRXok5b1WRJHS8eseEDldRH8DXsnTwjYvYzjBYdrFcU1Vw+q6JkUKyYDNWKXnJTg4mQTFn2tyts+Qb+89/Yd836XGuuDbPkzlFj6Fvle96qEBrl1H0WzzmwtMiytS0ElAYqLmnEMRLEJavKfU44fsYiM6hEiZFTPKoDT2oDvNA96HkBS7H2EhEM2VSD3ss0j6+UiJA8ke6q8Rj68TYZEr1S0K5RNw/on8zmCKYL5uhuvx2sjoPQC59oud6yGMb5M73Euf6CRKFlzxxNo3ewYJghqBQoLO3ZwFGP91eDPa9M5ZwoNw9mJKglrjcGoLsMWV8T54bG6GFtEKVTOqmB757MxZc7xZ4Vlf0NbhWAOrGXtEpGKDRZRxFIPK3dHmncvOovsBfcQZYpEz15tVkurLyp12bnFpCowPeqnKZPIZSCU43dM/1BeSZNh/D420+E7qlQvtdxvDX/y7J7zhDUQL/Tj6/rnxnvwV6wSwKAlMUj5a6jzNJyU8i7PMtH+Ewn9ZUPmpmry3H2RgnaT76hxQUHFlAy4oXuWmVOZcfHS34ChOrtqCziTziGpO112typ6L47QmuSqrnmesibtgW8y9f7ZJQ62yhvRDu3KNqzZDvYzXn1cCw8kdOa3hh08Vgqvc6O8v+9adcQwrgEdofEjVHt7C30tBf2iE07zw/CWMsMBHQ8RQHVsPNX1VyQeEtJ6mRtCA/tDoqtMqGbKGINbibYFHn3w3o5ICj7vloCSIwFEJ26hwh34G49opq1ZOv26DXrIwh6GuHELBjdQy0l4hrzcBskpyP5LBj5lQeJ2WAttU2oF/78NYZnqoSKXML3T8iSD5u+Vde1UHZC3tFMrUHDoOBlZOgwYm9iTGkzt7inZetoQaXaltIQFlICfBoOkIwXtUMDIjYeBKElOipiR9UYZXOmmGF+Kzx3g1qRWL8YEIZ9h6RxKNC6jl2BroZ2mZ6XbKqUjSwHNKTbA3s9iTik7Xb34+NFTsFZesCU+f2QDAuPO56yKcjSoo81b99BNWnjjIsXpIMb5HmPFHEZmMo0QaYQjSNCLDGsiCBSN9SHCRb+cGnRmTcMr9dZmp1TrIKKrf7uPKy4PXb8hO7/+X2JkLPWXYL1cfpYmQN9NO/gSptTuqdLxErSAtNm+lUZa2urBG3g3rrEszPPuIALDwLru77z0R41eoNOXyq/3bbPfpieLVJcCnAYAiB2kzBgYMPx91cnPnVjaT7A8DWn/zD8X0z4eTTc75h3PPv+gAakVICphBhQiZVmMHnqKcLujcVAc0cnKzlvbeuxyTpnqA0y02vNar+wHX/eAWeOFYzTIeJyCFw/4qq+Jk2ysSPYNkAyvlvn/OcwOaelHiyrdtBZkE9CU1RVD9YubzenxtKjb5esPiLbd/i59LxW1+CC3JHDRVDOi8+q8YF8JpxbnbGPXvU0rioYJiURU+y1QqubniEkSelZjhdplxlZmfhQ8ngkwtayUNLHsYOcuTNlmMr/EYDQq66OK//GgMHgc5yoADYCLyU7Y33h0iBeqLSD1izKWZNNKbjAF9W1Zt8zd7yVQei25gD/LOM8Vpgar5iysGEac2vkHAPgJ1jK4AE/CbiQVxOltLG83CIwhrv+pF2vz4pwbQIIXg4fGQow3qZknj2AkT+sz0Km0vAvND0nAtPj5eM48b+fr9LnsdvBm7lgD7hFE7ab629z+8vGwGBR0sHuN69jIIgwVFBxO7lUbdkgiVIKZ7HdqHwpRsmwhB+Au8XG9hmHhBAzfeQEMIT91QFgi5vTwI9iuoQUJkBT57jjY9ihlXE1hVvioKraTEXevOtDXjLds7KBQEgFpeXrf/lnL2nDPnHsOHG7p61p70MMP7obOoRqxy+6J76dC5PPF9sfeteW1A/fxwVBe8qQgdgwBv6w192rXAblbhcRRmWrLIsFkcZj+gM1Zo4GZkkeFWfsMCUXMHP396sbIqtJybdMGwmu0jGgE82WsRwrT+0fLIjtyN8LKuJLVsJQTE/zh8hLapTHuHF0o//ooqzcbGDoZJAK0sSfMtb/jYFkD+3mAVjNSTPm2sMaBB5r7gqGzDQVEsWv+qYpTGCzV1cC3+clLzmLZ8qzcRUox9Av11WPLGNTo37uyhlc67IbPtb8XDNJifS/WqJioJU5Lt4eyxURVsTIOiDd3saXqdIDhpM8upmh0RuVgp3Jlq+PPPrfdgwUMFQvp8c2zmI2ocCDNUxyH/4vduQZvvrNI0z++DGR6gxsZda5PB9NlajEvAu+4uHoKJU0fSfgvVsxvMvPSw3b6hZWFZzkWPsqFfad4OOi8aWdT2IYSEFRmDJgzPwiqsh53kUi8wpwtq1OPJYfEzdkC2G/3Ib3WtR0iN+lojBAX9sBqErb8OACu9nnKhveO4YGloefe47ZKmVCVh0jKAY2aYZ1lwyFV5r8svBV9TxidXdwWJBZ6BqeZlGBxFhG7zvo1Q0Pwup0SGECwLiJgLQVhI59kcHK4RPcB1UH7GRIswZ6K8i8bBHc7W4t/SnMuVwBKYQy8GNjV6xJ74+dZza+uI07GGfE6kPqxpj5fT1pmmLg8gE2nt5N0thZrvNsd4je0jhJM4HOd33Hix+lN/oOqhwhhJbks2TLjsDWiLjHCGxQ1Mi59EWrYB/eGv78UXHgK3ShhuLn9VR4CNrLIGlXB+PT/ZGw12ESjgAUkWPDXMQsT+CUxa3wIQjWP2/E01H35m6kVYGSsz5wGOBeiIQgEGoIOHEIR6W/fDSAmHW/qqq6UH5uUWQj1jzNz+ePU7vjHz3zMdmJTp7knZ990f852sReOVpZruBK9muW/kE5IIEkL7zLNcJB6fNwsI3vVVFP4WKMBHJHdzfJEKujYuwPdKpYrYPZBcqEFr8yn6ZTOPyxhyyd757Ce2ZuNMxZi7RJ5XG3w+FoaH5bzwb5RFtpK4ztS4Tvm1NxwbnU7tCEYgaqgi0S84OetM1yJiyCMDnE7u8uaHF8aBy5dgeMMEtQiK9J2AHbwU+I3C9BDdo4le7hucU0/YWdjxLtx+dPTgwn74uGQ4F1EE9JS2PoG5mEjP0B8QcvIK6JFb8jWnFguvI05aaIf9J1MtYNerZdEwuKFmnId0Z1dnYjo4mdHAvokVABbxmnL5ZnEf0PMrLh4JrlOYzINEvZrdd8P2rYBVx0wWjggErvDtwC7mMgfjItmIF6n1u1DU7GDRNQyhtFZXj5aoCFbsRMrENPym8QkWMP4FoUVmk+yYsX+EZkpwtpM/NRKEuzC/mkvpH08Bn4vmGu22HHOgXboZ/cuiEAwuSPVlI4qGh7OLkqLRlt1W+wpet3fIpzbG6LlIrUujLZMxZDBzEiSyPrGsQU3Rb8s+lGm9n7vrjGLDKDe2Zq+1V5MRmTSc22BtKT1IR3SNvJfcsDVTU89FEExqPP/G/tcW1tWyE8rIpiRHQ61/ZMX3rYOJKbnhhEPs+1VAq2W2Xkl7nwUJR+ojRD03jKw1NJtMWysO3+erXrIYd45qt3dVvjKV0dGsjWuumM8o/d2sks5Szxkuf+quvB8dZSMbRcNxLsMpiJgDwQs+aC0p56ITUomubqkSn//P1V07/MMpTDkq7vI6ACl34T/4Iw6DG+Mfw0QD2AtmNGZguIV6MlcyX/fo8uGNPsZ17Oj7w9qJBNobR/OBbTPJcfRpb28k8+7/+AN04IDKbJgyFBFZ6YLYxDMRi+246D7qJzvweDOegwp0FCZ1BCpGwk2sY9VxOxId90WL8uJeLQlHjijif6LYr/RtwJOFnP0mVVio4zIcp4nqOMfizX46ulXslx6W4NJNvGzvdDdMflON/DBmJN//zNe5KJ5hwOrBkJSgFGsPYswf2Wow6+1MRmUxgFdz+erOr4iAVgxAUjDA3Y+G2M21d9fYB7FIgkTI9IxxmbtOUU6Yccwaf9eLZqZoul/F/4x+phacPEtNvL04DQ2oseCBHY487FKOOTsfDabCPZNqpdPIxoI0FgoOrCWs4Dc/aNn0upNcqxM6KNFDJFNsZnADQebFaiqShM3JS2q95ju8PxzrV87uFJSi1Iw2gpd5QFvqlq44kQo3PoQ2TTiKNv42FRFdIzBldzrW8oi4Tz1BN9S+W5HBhCxZ43OudceixKeJ+HUwm2o6AYFDgB0p3nr2Uk897whmYz9BhaObPqzGkSs8MCiJR+V2+DvSCsIR7XaPBtG7CsYvZX25AIR8BAeiIJVO3bWh37Bb0lNtR5sV1SeSK3tSblOn5TgPshefM3OWJWYj39h+09eD9NzxMk0uJu1+T1Lfn5OSec/sCfJAbG+pjKnbAos0bQ6o7a0ZKQTH8uD35SsYzdfU28ptQynrq63mTYViyCSItmSazRqB1Pt8waK0HSUnWTj6GlJ6t9c192e6pmq3F0jXkm8LQoQ0TvLodnVMgTYsOqujbHHN98c4K/mVpnDnrMXc3kxXM/gGFmfzMfoBaqLxFzgwUsz6Y28jTXubltU5HctbPz/8bWDjmvS/QbTgYmh+2sTwSdC448Qt7k6FSAAj/49E8PhjyNSVUSEgIq3re8+QwjJhuPnLFgR5t45AwbH/fgFdrkrhS5uOsbK33hZoQZN42Gupy+X2bYBmPKS4t1v5KmRwk4kK8Tf6XvqpkfuFHuu7AmD0SJLLa0p7+hURtEDHO5noX8K307Ic8ccsDgOT0tF0QTSSUjh+Omatus/vKIj0sql5ZSTPm9lvsTvbxE7KgdU8uqwd4QhS+khjnRD/Y9P31sSCcN1scUt0RaTyk+Ikre6VtMIehF2QD44qGeKCyhiLnsC2cNWticuo+VeicXwm0cl8nV9SEztmTadd7aDoc5cQAYG7lIist8JJxXM384H8T+6gPXJNU7fnjnhHHErcMJrW3VbsizX05zxhZDGFQLE+X9533Z4kTYg6wQWWAS1tx9sKSu+M8AazNK/q0pHggV/BV2ic76NRQA621OOXo5tP/G/dz/o11U/JZvqtx+xxthO0alt4aTcqfparUjgJ/X2sPAlReEMtqveBTWpXcMU0dT/Dpt3JkluA8Q7zG98RAhZC2iFJdVMiIfRCtlFCftMwgYUdtU2LkYCQtksBw1wyJga1RHktm6wuYGUJTkEex7qWaLih1+3ZY52XNnbT/AP+kxEcKKFPYyYR+BlxsOVw2cdVJxtLkVM5I32F61zHLdmnKd9De4XpdERxcfyLdhh2HTAWFNXb2S8/3NPfqzS3unXNlyAsyxgVe3DmZ1XNzdAxRV6R07/MrdDKY4big2Og8dUaEsRSCzCGUKXuUr4yUFIcXMKZ5Zre0dUCAl2jITrpyAazdOvdA5uIplnf1SlC3JUiAX2cBVSHWjW3GyAfHqhc0c6jGQmBWo4dndj7K0J/oYPXX1zO8k9rpztgYa2pBoMjpgEzUERVMtjvKE9x4th4/BPDW5p+7u6GB8Ja5UCKSpOTDy19VVbI+jCm5uq2FGoCrtO0VLGVaegjoZEOdDy2yf6KDM4DRGU2XutVJVcEt78Vki9qiocyFPsnLMpkg2xD0XnycxqKYF2nm1zOvrQFTuJrh+tclisqQ3zHXcDJRDw0VAz5jen7d/v4L1BmDhKpbXD0NS7HivDqYETwCgmVTTGQ0+IDAS46lmoYEAiUS0xckuPCn2WZIn8bX2vKf7tF9peEk8gQ85+ACuensiR6hv1X7iPZjOa2sXh+5Ms3npVxaw0QvjlKO72TvWs8nCxsIpTc1WZR0V2Rc79NTLnAfHXUbpQtndZgkT6g1B78AuHYM4BHCEf/Iun9ChmvfdHkJ51OLHuFjLtj4ajOIH4FWpYpzWGiEYMvlx1tvnPPqTprtXO+UVNApY4h9v7dfASh/zNR3h79zp1p+6G1zZSNBEfhaq0HWgcj8P1poTWMMZRN8CFiYm4CZk0gQLsZro3g62ziS2VuEqXP+10Hlh5RqDazBTJk/YIj3Sj1l9rQV4/lRVrOul1QK+qTWhCb3mcqReBI6bLI3TFbgYWfpYjwg1PqO5V3IYiY33Msgm3tpc5k3Wk/N6J/nizM2T7D4YWrSdT6YAWMrQ/sjKDipZ3+uAo7ysLf3Os7qXy4fmmpODZb9J7OsMBJRJEnsdNDw3XCJyIGt2brLbVXDTtgh37phZBO5E1MkjZfOoRGh49zMES/6YUlMdgTH/kKiqSNXZmNTPQmBAHeldfh/kJyWxi5pNkqa5Oy0H7yEP6YQTVpsnUYInEoydG+qdscYZj3TiPoeN5omlVCM8U+5vkSQte0YkxTek8R4h+GFMTguFMiDurwYaml/bMu342PZ+5ERVDfTbUSiAwBz7Dyiu/APbItvw1d6c15HdPhYwnCRTrugJL2/heirEEHkgyly8Nduk1DDVX7qDPxi1+HF8zdj9z0GD+4we+R/ZzUaSN8ElmBmt219KcUpz+xx8yrdEHY0b1WY211Fh2VkqlldrTG3UIGdmROBKrSeLrc9Z3NFwnn6ermulPXQqMR3knrF9pkUbOpJyZxz7jYkKVIgVezO0jJy0lUfNyE1O2beSuFW6bea1ynGtQjh33Vh5Iq8XmuQU5bfmCEJkY1eGBSAd5joKIWeo55DfpZId+ffuyLTvLr8R4WuZHSrfrVz77NPdE45cYyQUoRUP2lgOmw67rotaS8wmljlOfjg63ZoMoR8477PVTzAWcIBdow47O4I0ZEkP9iT/jpINW0UQSXCGZknEkyXtqlPqmSUT+kDLz3/PqaB3I4STl3wYgw0RaIy0Jc1ZLiLcbwfqRmEZOBJzVOB0dbvlQHrzxhBULkl6fhpS4vh7jioh3vPstsJ0N91CjrFSOBUo4CIsV3nBAwFuNQqREgPjz95t46Nz4XV31U9DPRobKDOQWbHehtL7WrAgWvKk3RK9uFAoggyEXT5+Zrz7kXYX99yVwgfbnIOHpzXpuiwJ7PdsSs5V13l1N1gaSM9I44Dz9o7viqBEx9xDOEz9toZG2oteW2HvIC1NMKUqvj3Ezz393rpOhqCudRcNtOBh7kQ0akzVDAfWO6I6jYShKf4Bfl2dPOkUJCovn1IiDKCH8obhR3Wwg/7x1UBXk+432quglGZgKsJadvuBDflSp5mUXFsay+aLtzZnFdKgJzb5PRidcsmU7f4hpbSJz27IwcLOLe8OpUXASne1wYPQEwHgaJPPTDtqn+RkUiXx12rI3lghrzo5UWbVTzEgTV217y7IV7iIpljc+ExRcKx6W3YPrRmYYhLTEW7sptCAnZ4z/WOHzOSIMk0FG54a3W72nyy5ZNU9e+bOUrcPKeZ2PSxtM0pREZwdHR8ast/V3PdKrmmVDM/QES7uQEGzuIAFUq1WN35yrKg9jlRpYZYbSUGFjgwuFJSK4dTqhxHFlP7NO+lqV5q2H0HDBl5mCUcDg28694CBf42lXcijBGVhtG7cj28rYFUtvXj9CI8Af+2dUryu6KnY4W5C8F8OZ4UjCYXyLm0tjy3P1AJ++3kKYB700jWK36xkFDV3rOpqvZdVL66ebAG7r+bTTUFyEyL+9ZtLxvakOzK704uCrKoCeJUqXiKUup2QrBb/eSXmXqeEd+X/HHi51LVxn0jqyTEZoQu5KA5wK1el1hUWxm8dsA5Xl71DBfoGC8HYhvCiuaBp1JASV0blsV6Jop07J+u4grbZDW9GmFQAgzCkEY2Kqg5Kv2e2xmH/LKz6ddfmHCtVZu1de2V9LNX34JWbPpA2ikVueyyVqWj8YV0LRQU+s4eookPe5hZDnQE7VXdHtPwFKssqgVS9B4RIHuptcudj4MP1t2QiHe254Xnn6nUZ5WKYPUAnor4weOlOdicbV9kg9M0wCDFIweeS9r2HDGoCHBg1jPZ00vMVYY2gF1C/qjrnxwJCJl1QB/hkeRRScDPLUVZWGWj0WLj4tm/avw85n9onTKvYsiKM75B9eR2Wz24MR5hb/myXo0auNtSh2/qLBGHEXLIQdY2a5wpiIjDwl/nYdbyLX7MrArWUfCkIVe9O6XorgCcWgsuAFKjfafnrEVUCeMH18repQapSATJMzu9ZJ+yfF6yRhr4YVbktEkzLaEzWzLSSip80iWnjlNwAfXhT61ZDdycHKg/7U5OEntbX7LiB7j4sCKVW3ifGa1mKzGaQ3zcGnzYDGqEQ+BJ5rAPDMGXtOKCvivRZXkFtK0XKEOk8Ez6T/GMbhj5g/I5HMzmeVf6bAeVTfWWcdgY2M6Ha0ghFjWhP9iIanOBxz2mmEuCLpZMHDtIBXzSF7MJcZ0PNdN1AGZgvxnbo8V7SSOvKMMJIhrXGmX5x4wrB4LVs2oJHjcj+aTO4wh0nR0adPYNqOmSVJmeHqpx1LwlLWHWWqI+975KTL0dvcH2mpuw9Ja+k/KCEvtZBke86/XMft1nDTD4VFie2Bd+c2p4cSmHtCLLUir8viopxiPGYTUzVQgsbus1ZQ7zm3MCqhT2aby1KiPqyeB0KGZhUnNzO88srXOYl8qhdu3pyMROBI3DSlHQDM6cnAbPUgUWmgRjeL9Xds/wNxwbwqR76L5ErwaofiZAB0zkcIz3thvLOh+OcsBj4SH/OebmGUNJHol5IVvBToQdAK2NDnqIWvEvzEZFh3mvkv53JmiimczFOqJhvTlWmRWfrjrNJSPw/JDKkNc1ku6UXK/SP4JOSqQ5FoRbJf3fhLOG7IzpXQXaO9SjXhT0b3j/3QOLmB0SvDaorkiMdU9XP1bAUBcdVrQW0wFWMsCopPT4fW1xcEUu15W5xNF+QLYBYuH0TbJ0tNZl7vAyPyBqGDyhrk07dFpwNg91YS3TtoDdRQl0aPD9uAkea+l3P295TzwuMJ3PBKBKCtWIn26hubgE9jhIW9IyzX0Gx0ms4anmJB5BUCEbeKK/ZPR0Hg3J5CjZRCgCpLA0JUbz4Zk6ggrIAe2oNtIU1WbGclMuptcVGvEFIo3imXTvxWZSKEgNAqlVZH9Y844/4Wtf45ppiVQN5qJ2Y29qwX4k7D1dHzne38sYDGBR9Q9OZBGK/4PZlWhEYhQ1ouXepyYH1XcooadK27ZIa5M67SH3vloUCjA7wTpEmlApFET4lHYHAlXhDPybD/OaOg+8PNbwk0FSauwgvd5BnLKGMezXjex7TlJBW6NFuSjvJzhDOltBy2Abxd39/cVcJ34qlkGIwo1np1pNYZmZgrtUhXTgFpX2Amwz0bcAq85mHx90I0AGGh6gnaFpSiJCDD+stVADcAnFRTmB/YxwmIqsm7dYYFduRFN6BqzLt07ep5PmNwtbscV+qrhFF5PZC0jIAk4thFoHXMhdib+ATs9mL4V+wJmVd+oYhGR7bSEEzzw6+QudzF4sMqAp+1c8WM+eZ5kDJa41zpu9U27wW0oN40TgiueON3LwzvuSCon6cXwZVXIrkLPYrgKQ4sH6tRwIfztegWj2KEcMiTegGngw+mXIKRQHrebcZGr8929GQd9Mt6rhLntJtTtQnHQVWSPIyKDUrboODSKRi8ylos3FgC/uz3xtL6XQtT17kLO1lu3+vjzl8OJ05+BrwtGvI3ZJTZRfil5S34hGYU8h7iaBJzLjUuJXUNBiMjDR5tK9Ng/1qn5vXVH9hkddZdty8ES60Om5Lpj+F7KoBmDweKvgFUvLMN3aJt4gHK1+OefcoV43JTRTikkqOjb55d4snCeyy2QccrbKjAU3XEKUhiYVlE7Uh+r9k70sW4GYYiq86DhNvBg9ys2zN3BHRCZ7Q086iwWn/4TmUp1n4RY5S8ics5FwE2/rQVHuIhcQlg/kCPV7RyRWVW2BHQS6mYj/ULUe/gLg81HpmUR5OFxbB7P4Z4D7Bgu6LdyR2Avix0qxiKIrm1jeGuxGjNApf7GtdolZsiedzM9SG4adiIcyQF93kngt/mbnyDK7fLC0kVgzADpaU35End4a3vJKQti8Q3QyzK54VMrfav0YNCVgSVeoSobLZcaQn3lk9LLRF5GlbeK0FqKFUBMzWduKD4LQNDuw/+fzSJVnqHtVThjsY1b3DK8K/ZhET88l6jLQpfopfkAFwjJWiMDwuvB/ltvUK/QhwxF7fuOAQrqyG6YcQMrraW3g7r8C8WIfIiNI7VAFNprmrecixNH0AhniEqxXPapLD5lcqZvVc0exFbP2o9SR6ctOE2j8An256z26gNQ6AIdoBG4qopXJYREOSlsuYx1apnxS3mlxXDWdL2WZ5LOa2yWZ9zorGnwgxYW5WPE5lq/PkAK81op90o/CloGcjZZtw6Ss5S8j/ecMxZn/BDKvQsi93orFSqYqauOw6GgqQZU8YNNu4hYaJglHb86ImtFDgb91K5a/XfT8I0++pBk8jF5K8a3cFluP6hhGz5w1xvVHjuWJCyS2juqaUl6p1DDrdXfP4W/n8d6mxs0UxKd4xPFZ+FSOziXe8jEihHf8v0TZKm178/wNN0Xc54rtH2ICPSfKbT7pPIuR/p+aqhNgM3cz+I+2HFeqvODLvZaPceF+FN6JO7IE0EhW71URxsfGXvxLASvGlnMlsC3cqcq68cvIMfrmghd4ryJj13hMWTk8G1bgCTzMgzzYAmZ6dzyJ+JWROkzvg/yz5l7AI5y2ZiPO4UxuTJVGeUecSCz+Jz/Yc41IjyhqCxL0FYwCuARGmEUgh5myr0kCF1RTAz2l0ptxgUl5qDPsqZNOgjqjZ4IVOtKH0b4n0WusGNebQtjCFVr0gWQj/D+kgjHi6BJ0kpTIPrXGBicHY2I6HYovwqk65LyyUGthyibotuH/t11mmH+JkV6egPOG6JZPq5Nq40Od2ESHkuELqP2AiRUB9Z3Nwd28SLasrVEcBE7zwNYtnQmHgJpwKJUe0lZO8D5fBIrUbKJMvQPkGicTEJ2iaF2Q9w68ZInXSDpLY9ntndyTJ+1Yu0pNu3J2tVU5uNekEKAN87zLYhy0KWSN/pB91DVT0OeObL+cjavnFVxDSr9alWUjLGXMZiV97EuVCDPecmbIVmEImMhd/dSP2HUo28pDX8GEEanspuf2ZYtx9J8WT65oGlBCUHwOFBhWwMIHmwPEmOQCB5T2ocFv9tT2d12LFBODNpFGLuhhhKzrsRitQq+7V5Qzsg99iBwNQpUHayWkJSnKgHSasjfYrcKGCiUOcWg5do1IUUwxegaqh8cYZDdYRWID3Esz3eC1Ui5BiPNzpEaUgYJ13HCEOSg0AuWjpUh5q81ViRaeFF0pJuDqZ5L5+pFLWtBFsw4KyDcUrIKX6MyC/CKsWrZrHI83DgKX3B+Iazei05OuMN1hZV4BOULJYFrbFW/FbXtnDDmxlcj44OCJio5doIK5ubB5EdljX9dzDS3ubf1425SUZ/BLeJ9kcXIZRO61M/Cynks+YOKOTOI+K3MsoU3jJfiyunRAfbTLUSRRi65sYEsbeLwItKL5PtDL1vKialkYeBlC+HSjo62locdRB3dS49aIr/zBLcjFwLYbdAT/Gpov+V3MTD+H+Ukz3+FIFjiJKVU0wTE3oAzLoDhd+S+8oxK89GLJAzp+cic+LHavuremTPoYjKmyUlRRqPAxGcfAOIm1aF+8WZuAFqC7beNpATCC6QQFH7Og9A0OQTLLSp128NK4H0eDuqYa5zwDmvJz35i47FrRBgj1eZj/v+zLvEsjpskg+8QQ7rx9L5D5PI/o1AqvgKoev/IuCknKKavDzNNhcTihlFz+L+WkzH3QdZThwo7MDW0TLJyyKkFHUfr1bNWCkiPi18mahOhxjAOk53FYObdKZaI+ozPZ2OR86WPF16PjD2+qp+o4L9gBaisNCXTHhJ6WJemOtFhJqwBqJrSZNJYDIIKDEWYw3/TYQ5J3ULuu561FHuisweiTQNlANOv91zUEtO7wm3oWRMOAw/fStermsRXExSirMAayhn4Lxl9/uiuPpSrb7EnxcQ5kDNKJeiK+I7EkzRWACaQ1jMrZEV2AaJnESy/l7vK1Ql6fRKo7rZhQ76QTxMj4eyzmhDiF1ei2576BXZrF4Zk4jJuZqRfuyfZPvzdDSTXnFemSV2UrwgM5ciQuFL9cpZKLqsrO/JFhkpZnIJ2kResXg4+rw7w3OLCAw3ZTB4r1hLAgx9Uo1e2CvRtPBTM54fe55LcpgMEEySac6iE/pZf/wERAOVv/A1HmmvCa8OJILjqI2Q+o3XDtdy2lwu0TYDpGeA1krgycWf7nVqAgaaWBLcxEJCTb7M5UxSrwuO/mjoc8Eag2pUtXCEeUbsLicxz+jxXt2FcbtulwZMIC/kGMGoXmkI21a2IoE1JwEQUDPN/ZUoQth016TO8ZXeRu0fS/knvdjL2d3dxBrBfZ6IyHkrFTy4wHK2uZ+ikXhpu6G2KRzs0uifyUHJ80+oOH4QVWPdpvsKcVvdxdF8Ty1tk82yohME5C4ln3iHC4Kt+EMviAnaLxRSOdEzs7R35Rj8pwLNe1Zl8CNaCVB63btzRnizo06Nf60ADa2hbaC49gYVMESsGPVGpyLGruf4U6b4tozxiaekzm0TIIzXy4BWMeiNU7hf/tUKFXEuGcZrjYpUAQjqy3Z9AFyejzjrVBaqLvJu9pRQHa3cyoUpL2sqon7RkjtMatYfWcUpII41bIc5TmRdZwe+PCpvZ27FOCEMjZFPRfVBhezhikVepN5NJu+yRLKAKCyZ7t1AvOggTdUdSn1NKLzPAzXsOcS0ZFmGGl/Qbz39mm3gt/Hz/YyYLCYnj3QTb3Ma3XWXyyXgwPzv01u5d9k7aa4ed1ZFHvZgfA7ht3e++rnzBI1E0kygq3ihwj+dL3V0Mzx848h9b3oE+J2jvFEppY+3piUQVwK2iM7DzMlHo620T/Jw5k4FE16B1ckCv3xNONdP0kFqt2PIOIJfxuZX5Ab4gg9hKRpRFGjuSpw9YEYcqKT+cko5lr5eHF7RRY1YEy2uMSAHi+23JrHLktMvjp1Ls4gJ48j6HwoUvboUx+BoS6NyR2py3M76SakdX1XWNceeuXB2fX6RI4pf4usb0IoqpGP06I1WcFYlp030K3AhhhFQ/KB1LhdRJWC3ewkl2BP8XnxwNACb4qU1WSQh7qhxWlNII8Pj6B7YmyoeqILR7YQ15jnM4LiVjdeTAvhweK2hP7eYoZTp333qtJpdZplkwYky0pQehRpI9nFPHevPbSnmDKiFnOao5OXReMF4ffgqxeeyifXHkIsVCLz/QXRUSGOyQtdkrLPkj0c9g4VTeAoNPFHIdd+VPHhy3Idu79rzPxwE8nVBn1vjCNIbiOHOEKXskOVDz5w0ZCCV21xoJUtUznQxqu4a0PTvdPOOrQfgi0gyL3vWaUWdQzkKeHKPiaMUYxELq7AG2TniX8mFZGv6FN1LvxZrUBF1mQuZ58cMpwps6NA7PXP6FjZ7Og159UUFPuA8uP2T3757iNSRDtkt1QqQgOTe4oxU1MnW6WVMLAzYy2LO8WEX+Ft6At74zGEFrbdgXDaHkUtREOAceyLopok8PUBHm9iooxPqXOxuGxI598WkF+3mesHL9cLaax2NwsHKzgvBM9pJZJfKeksYCekMI6QqdwnTXvfyQrTs19sZRKDIS2wRTtGJlJBDPXtq0vDMXkqpX94R16HlzBB0r0foH2vm5Ei4ICLWi82ECbZz83voWjHTXHThFVxH+2a2AvOuZjbWIzLf04KUpOXwv9xpU7tlDGwYNkdQtHHSS5qxUA0bzJi3+i1RpmFrwRgjRX/vn9Efj+jHcspm+sknu2QF2O7UGxs004kCgRJ7NXaD3TBWVy2JiDC3bJx7vRZG/d9jt42LNfWyhD7L4u8RkyIpOw5H3I5IAGhAC0uRmlYvcxt0xVk4pKLokGd+WAWY3C/a3e5BzU4f41S2CadtD6ay4jagcjoLjPmpGOZY+SMp2ZdU1OiOi7V1vzER/p7zCKjRJRlj+AcMIUWeyIuTSfpw8LK9R450DL7TtDpW5LzlqFvQOBK99rMxykk9JkZykDDWqwh232XXKwKXzTswLyiACk6TlAHqxxbVekgDvdRtG6uc+oUHQ6J1YpC3T2EDB3Z5Zswuj1X4wO++UTt6yjHv1lrxZEvcO/RUuxP/dRymGf1+op9zzEUeCz1sBCdXwY8l6jLlQ+tDun9RIwWwLkLuYVJhcqmWa7BKWI33znXPjRDX9f3aZHp2VcwocoOeWq2mKkRDUqJbE7TyaglyvUV3PjOUPamb5il7/PMiacTkYsaqtyEQQtt58TVEa8r8BRBWvRnMEQnXuiT+YZuPx+Jv08NKJvuBsEjQNWgMmVY4ZVKt33EZ/f5vOtm/96oXgbtWBdpVhNP2ErzuraxYoo3s9vtHyn/DQUpAtkOjtmaEOoDRCIIe4JZGdy0TVjdK/5SajkV6KaFmUlPi5plshQ1P10HfOqNO9jQkRLweHf2l6BdDu3V5W2KZo00pgT7j9UdQia1tjjdMvfEBzCMYRHvt2xLhmeiTmnH7C8aNJtHQ+yAp73TskIxnKIm+envF0VaQqPbbd62VmwBYAquNZh5guEC5y7K7MZW9HaRCgXXCN6nVq6+WKZ9xpxNXjQr+mQhZmSeMhPORWjmibOvXrf4aYS8Z5pGxpCG5DYljfHQQMvqiY0u8PkFr0E8bBNjzours1ZGOYDpMKoH4D8YLcofXN5ktKeCxDqL784wbssq8Wle1L9UKDmL2ouAnFLMAM1ht1e02RbOstjGeY3YgpPgAlRS/pAMesKayfKv8ql4WcjywtCKxZnLBrVUpcIQlCLpOQI0LVrq5EgPt1X1oYek4Eul5NVgaedebLk3gLg3735M6frFgiWSGB4jKQYGtKcRQS/j2U9DHFjew+uEwUiDrFUwKyfWA/LVDmH0EdGdBVeVcPJmm+4QIT5/Yji08lNMT+ynG1PiJOQwUcyexTtVl1ItbTNA4sSOIrnPmgvlWwul/bV14Gz7PWL7haVvXhYwbGsFkxqlOfFkt/PvfckXUsRyalmwwBYJ3Hg58B5AWqUohs4/OdQg2lUH5Q6jFnh/BdvYC+lgDHvuZQoN4k35bfRF0NMkIxRCyN8N80NEtUiLbYiuVMI9oQc+mW7ZAK6HWXG6Fnk6MF7MBH/ARw327QgNQc3A1NjgUa03JZGfRCeYxhky1onCZjOBJodQ22iboubJZqNwTVYblamIJWaMjylFpF8zqAzmIGckT0/IozEHK0vko+Y5078oNVJUXj16+NqqwQ0gIrmZ4gB006wbccFXbDFc/3jfXGv8azCiWq29Z27NdiEKZSxmw0Qwc+MjBzYaOlkzqTzUYhQ5P+GjT79HKP2I/TVAjZoAIlZRpNSCus9g9Df8jIwR9WVNikOTYJorlA4L7UMBylm4Eayg3v+gKHukP6OdJhypC/TdxLVih4G+e2Zua79gRW/2R7qgk0F8VqZ4WRpxGL9UM49UZ6je/PdLEBwhmf0GI6jJj6LZwROjvf7l+dSxr+kq8SmDGOlDToXhf3eD02vhXAzSA3pY6jdyAKwJB86AbpYpAqiZAdJYindXqtbGWQMMz2V/jST3D3hVAzqBM7ELj7q2tUoCsafv7HR1BR7XDvrkQ54U8TD70CGHIZO5aIWXACbaQGoZGioP+t9N2kjOnthqLRhVUDNtOfuBqZcZAKYBApmPbQXS4eRPcjkZOJkO7Z5+EzybMJ8akjXGDvrFodAYVsKOoOKLMXnz11XccoPgn4Vmqjn2Aied/kXAAD+lhq90sdFevDTdRuiac2Hr64ug0zrozapf+cvfmSwAKlg/pRaiMrZ3DPLlbzVANHG2lBLBPD++LCRn2net6fdJ8/QmsaUYJ8YoSC0Nnc/f4JhZUo3OagTQNy8p2Q9Fk3ThOCITOlmktlNPjwBOzC2FNXQAPqj9PV1e2S1OkELYGcm3cfDprW2VUwmOvR46075VU2s9RLdpMT/fCgVq4ZqwnXIvGI3/MV1fxAIqU7KzM3QHUoUbw0aIvp3IOvCwnIsqqfz6cWT2DaKqiP0mCLJpXrsv1zDuf0tlGrItenkNOJ35RkQOdMp7WNfR7xCtTn3U4LL0vLLzw4UZBgxsiZ1BuxYXj9fwOjvC9mDwxBIvoLHVuK3IcNOwuRnZcNA6362pdycvDZKByUaA5boM7IXk4/QeAE9PdKNJYq5Hq3OvOXJvKaNqeXehTD0jKP40SolfQkVGTm8Gp0wt/oWzuFmetT0rO/DKD6rJN8NDg402qkcuPsp6yjG8z3hI/3Lil3Tga45E5hoDsPGS1mLX28VzPvzLVepGAL6vh95GI9t8GrPCk+XuCzup3asrXeeyw2a842ZFnL9MPRG2xMgw+TnU6xHAA2gRKU3GEjRpmtXwbxoUsOYEyTImNpIRCvu2LsGdFNriKndpVb6E+CjIpVQ2G62nfM/n/2r6g4Pv4kvvPX7zPnc+K+8LiQc8FdeA/44ueKim8HdzV5YU/Ewp4wvRpDjTs+4jzHB6gTjGWTpt0KkAESl+x+DpkWS5GVylpj5tRsU4JH8bm+Mv6/7o7jNatsSzw3FyWPqTYVS/AvsvvlTCFuC6nNDPfV4Zt9Xofr1QunxX5ECzlBgvf5ekmb4sY3ygqxR8Kc1/KLsQsmbOJwencKuT+yThdv7YG8oLNYDdlsQn/rrU+iIfSASXTm7zEMGF7qjrpO0GSGEmf9cDGX1dDzLc5eInspuPivCobs8Q05i1ij+5yoaA9RswqtZUMjC1EdQQlZpfcypUcVnx59J6z5nfn1wezATonvw3F3+NrJJftYxTlmnPrnkzhu6uJfeeEuHnErJ82XHWlXWw7n9daZIvxq/tRa8ClWUj1hIND7N0A1xC1H2kgLNMBdXDfC4PGVheNnMSbhIr41eBxRBFSbs9S7PkYcQH2/x/zerhjVzN5Khf5ZNi0T/5XEv0Vl0bhQwRKoY3rMBFk9P6O93H3XxUll5v80rAhVyWHZYitRAXGr5QZZN6PQkj6XgTQepp2rJkdzpaEcIB2DW6uiJQ9suuyX5hCnEUlFN0QiPIRRPfobsXXigrB4la7f1J6tmq9AiNuDNQiE7FgeP7mjXYllrx39OPmHUcBQMcJyNiPti2B1k1gE7kFkq8XAxphk7hc/QQSt4cJj8JG+08n4X1jz+VeqvvFQJadMY6I/3RocPB6UFylho24HD+fX6Ehje7pCL+rXLgEoJqaetxFCcbYfqc/1Rw7ElhFMEV2oAIc0SpLRPsbxhxLZ+qRuNV7wwQWdyWURxk/7vDELtjBk51lXix2KGS3cajet4E5ZOZY54peb9/eZFmsKq7fk5E+wdDt1tjFTESwlGmLwc4LgzR+5fXxmZWG1QHYPBkEVTtg3wUZ78/d0fa9O1OeI4J7BNBHthENf6CakxIpytY/VZ3RHUL7gbIzbIkBeINgSTswwB51En0kcHz1JREmwlGfRlBZZUxAZmAQyjUPnIw7zDqrCGp7hpZe/p6mi9oHObgW2N1eL52xBAGvHOm2+HPg3vsJ3B14CGK666U7L1VbT8PNwswIjk9xQ3+a7ZoCadrqd8JTgAw1o4qrjUm4r7nCixTJKt4R5gPNkerpqDa4yAbyg4uTTe0TvSJ20UXFviHHZxktqzsc1XYa3FGbV7xT5dGTJPxJZmXFsNh5yaNbRsYcdozW2pjEBUelMksQzcHQqD7oscllgI+qn0kq42pa+UO5EmprubFd6ohRCJf+E5jKOPwFHiv3yf+BAuhzFLKLBv7sWK78UQKqqEKint+OKvOFNHO9DBFsjfiylwKkUcrn2YT/97YYnA75DJ9+xaaqbkV/i29x4oCas3JO9jDXullaqhmASq8wZs4kAqoUZoKQ7LNhmoQwatjNrrfPDt1a1lhCknSwlM/DBaUajoDgUbBPaSgPIHGmNLaWnEnvNvzgjILez5KWBZAVBzCoPaFSIKB35pzfiExJVEjChXx37xV3P8xBsikQVIiMOOWc6j6+orRKCUMkJS1R3XCpcKJqyb4qVSvOy7M1CM6WhcWDQQgPEjlyFFhINBYq5ZdaudrBUNRY5/B4Q2Sif3GyPEZ6LrZxN1nDh/pEXBMvnWcWxoagWJSP7nbiwsBnlUNBNoXLxbqSOHfAgciuKBvK5hnF5/xzQbdWAnOGHji+E/Av3uALU7jFUWTvlprC1/qSVz0tswIkgPn6CkI2ZRoVe9dFl43PJNKRIH9f11Lhs2h8NeB9iBkgfa2asaKfIKUZmUkoTfc6MJ4dz5P4v9IZ6ppXYnscV39eEo5B5jm9V4v2TDBYmVEtxxZONHyd8mOxtmGGV77Z1pi23Wz45rkeMvPy5CbytLgrGZdEuLihxR+JiaRYru/83lc/NTJwU0G2zEdp5jT0vu6WulwblxU1APibKGaGDt/WQC8fJIu30TdOEbrkrBhsIV+wVJI6SpRMAWfg7MATRYxu4fxYsL+CbTbd09W41dyMYpJ/dlNj6MQMT/U0Q6yJ5lU0A7fCYhMsr4JyCeY1rMamgePbOs1phH5T1P+2RFXaumKjomHnfzUmEdkHK51+EqPf88LvC0b+JyWgJaa+ZMjGULQy2n3DKIJMNX0S+aIT+y5html/EyZTG73pfjF0MtOTlSNU0JmmGMP7izuubOZw0ohpquLuZGzR6URaGLHBJ/RXd6W5ngLhW2ue9OM80YMnoVWS92j8QSEuflfS1LDB8hTm+DPviejeh+1SyqQNvsgj6awhT3dAy322vcE4DdbQf3OtWybc8ue40xBVNAfksRxwKX/qWP3c704CNj03udQlAjVzfjdzvEdzb/biy7s7n4AdvQo8p+P+SYcZlu3+CNx+abpFgqd+Wo59fLqyUIwKwzFac9AasB16ncelP1c+exM4/Jh60tAQyltv77CbPF/PI70615WeyKs3DQBYp2+fq8znycn2S6oPiAN0DDA9cuSfuHggs0OE/9Asykwz1pMr44v33ppaYTLubjBsmnstDEwFhB2e7FQTGDPoJJiYTKHRlLbymIt08rMLn4poXVOYGh8hQBfUty+WUg/dJ2pjdlAtCMuPAqLGvPbnLz4a9/a5sfffqpoMhmSTVUOWPxXSlgCeMJMsGV3oYB7CEmUBiWVluy3WD0J5XowZUUHmgeDPMJDVey4BHzZSWI1A9A7ZxORSHQ2A3Ooh8UzT0z7KYEvOsgk4Jz254hG5OkjphIwyjg1TkDiXdBHZ+F1eCFf/EGuM9n33S63+U92ESr+m6iyLCHLr6EoR70/5t7cp4MukN9sog6NzuQhpXiODK16UDVwnceLrVVA4GM7n0n0ii4nSrfui/r4lLrv5Mv2xtx8LogkFqDz14oqK71f7PkxrrHqqOhROH7LDvaRomT54GBU+isEyIbMcMlsWwmOWaFg4FdfGMXqNFFrBg2Aq4HvuKxIIx/Dv9uTRYjX1YrW0cUU6mmVOoj0DbPY0/t/DbH6fImWYy6uCrincWalPBhiSXYSVypAZEg9CpYzxO2Q7BSAuRhSu6/FIKNxP2rtTTAaEx7yc4kVPbBRSv6nmWMZPSgO5vyqvFzcbyIg5HvdL3omxxOVQPZdKkRUaNzk3sRoos1oXOnWDujxgIW/KutfC6Yj7nTHpNOSSKEMEhElOnq+XR7iSSNHtGeDbFIDeGp52BMYp88xWhhnm9luIAKtT32zrZDF1HZajRY8K5H78X66iJd2azyURLvY2gD/cw6zmMzGnBkFLyaOXUUJmP+E7HMrIndmdBbnF7AWXAdJrbRKdltJINOCCLE18YL4VztThFkmSC9JjZ+SH9Om2VMvDE0uJ1OmAEmxOcw9otZvvSmjtevi1iHCW2sqKLt+DdtpkKNgAtH2+bcwIpJR3s61fRrscNKDIu+fnNRcTml+P61ypzRVSKCQueSH3x2YqNky4keXK+2eg7NfBOAykdpaoSY43PUVVWY2SwkHnBLLFhcQlza+aPAsvxvEKYuP+G/q0lRXDisdyhQBWOx4dJh2FJSZLKUzzSovdwYGxLFpdMxSIQqmtt7Brs0qW/bmQ9tmFNxiqmBlYyPrMxcx6O7zbnIEhFykVUe+UGaa8K/ZxLc6HqR4J95EWzPh3fMoCk8N1ydBPVG7fz0RP54wainyjj48oX0ct7beOAmw1+tcQX/hEZKYfubzow2hNXdwUQ64VgUM5DnDUwtNyIPdXWcZP6XpsMSgSw30iF6ZqWfodBIHPPSdIZAAerTS1c3WTrGVfytW26syjLV58v1nXSf4FTZrOtK3jsBrLSTM2ulOjWunKZ4Z1pc+JZMI43UvCKF47yF57v0WUUtaoAHrwMxjf2Qzt5PLi5jzp6MxVd3B3gynK7kFEUb4ngGFVTAcM6U8NIfd7Af9t0RTbmvQmUhJ6mIShiBrGw6ZlrbnznBBgJUxNO4auWS1xYfMqrOMx1UY+ufsCzkRfXi6DpXSGBIikwpC+5zmm4vtJHW099fA0EV9EBdHHR713mFpRwBuCTvwyle/tHO0BZpnUBmS8eobILZeDs2X+k53K2v+YkasXmBye48DGTk8UyTBZBkFLWeWgxqheGEQ4n/SCHTYarOJKUTaYXxrWg9O53k3lSNcBnd0URXv97j6uvgaw2DcQg7bkzssS11MR60gti6vwiYoJNfx1hk+QEcSA5K76nETRcV81wS8XUqCG7Rxygg7/15Oya99mZg6zHVisRMCAHUqPUH5pGWmAjhZwiUpTBLQjUGY8X56tIDV7qYoL4cKbZScaB1nZk9a3xdDsD0tDK/LG3MJvFcB9PhsVk/paQmtYePM3mfdhiUqDBzyqnm9Qj+gZTq07kj6mB+QXOQZ4letMpJUrin5oi77kbhREDBulwBykk0a+eYtx+iLwgBU4VN18rxFj+irdh7u3gwSLIDgc0fuUybVen2TMOdYW2Ns0PG7Hx9sAJQjwz1f9VejJIh0jadKxF2jeGvuhZYLTwr0BARyiQgEvrbc/ZKio/dYOW95IBG+OKXvhH1kkBJ30JMvx4eBXS4I0BT9iLPAHzvVzWJ+dEOofCLYG7OU6pcHSPYKvzJRSj1RUH1m9hXOKTDT8C7FuHObljIk23rF2XcaSauOAOJpgqMLB/zXVjKN/Qt0NXTrl6OrZw/VYuUzGd/QVIEGn6MuVesgyBZZuhL+w6n+8NfUpNjq+7DkTSB5s2qTbTxIAFc0AAZipsuuXuylFwkqhmOEQXqhImU3nXIkejwVk3pVHgr65NFmF7rEhN+bTHYm9MdXlQ0CgKbl4IeyJUjhw+GksyWBMoG8C3OB5vSkPjMAsWmVIO5kKXUPSvgQkZqs/cJwheBGRJYKdqsEflrc40GowLGFgob0cGaZ2SojhnOmQfm6mlxN5Gsq5SqqeD39VgKQkQTKPSM7RTQibu+yNlqX7mGo5VjM8IBSjuIkaJaseW8ML7vjYkt1dk+96lzjlFCFRmGpTHvPukkUQQCpcTqdClxKDP2b4qgvuemXJRYoe092VgopiaC3C0mJdPHx9ilWe1qWe9lxmC1lNiNFgB+S/hAXwuaxjAQ7zGQHcZ5QtnPloxvgvJ2isv3gPXgiYsoMpMm14s9rVnXQfGed4vkUFaoxnHuILBV6AQvt3o4m5s727lLkLld6u46CzPvCho696X2raxkRUzCLbA2Dpd/prY0Ge95ynVLypcEnAwbqWTDC55RB46iqQEfhO0veYalyZ6V/M9u/4O1nbav8l+he3BbYh3HbMRCyrA9BbLd88q3/cxHVRXN9BldZD+Dj7p2oXmCugRqHakiRjQZ6kxd1jwYP0OkrWy6JkssPvCG0umH/n/vAwhPbvkP3kIXplf19BVC7j8RWv6vgTsXelbUCtPgqnfmNUBwLd+JJ6sMXVXDXEk++jPCP7jO+cN/XaCuBjvgnNlvbA5t8/2SKBG6xRVQTpiEjGL/n63UX4I4rZBXOth7XzZQurvAbfi53E4nnQpJLK2bp4FkNI9KvD6R6GsIOCliJYluDUARp2vV+3RwOOJd/bmp+cL0RXMYVu+gsoZheQA8SsQ+REHyijpLTO+fH2uO0RRylEqEYGYTiIZabri2gLhYykxDFbmAQHczmt0JAxNAP0BBNMh5mU6CNNM+ReXE52FtKTnm89Izt9O9aXnSZjMg6ppBtaajmrHv3piafqkfXrySo4+25y+WeRauML5sg9SZD65kBq5CBAOcqfn8Hb7rPMVv7h5ZRw4xP9Erk3KHCn8R6kQKUnUuDP2mPA7xcDawUgQzYjRLvkflsZiYFUw0MVlAY2oPbHYCjj5K8RTNt97N/7kGc3L2Ff4FVjfrw9SZ4ugAb4eCRVZURCxWdvV1y+4bDzK7jgjPxU5Yb45dXh65pcsPqSWnAE/lC2yRZdkeBB7KHgAvsxqh1q2Ja4VJdx4ZpGwvIdo3VTV8p+WlUXWWeKgODgSZ/pEMBM31d4tFIPeJ6J1Y31Jca018va7aCPlh1/xIqb+e2Jg1yZ9l1Xh7xIeecNVl9jxN0cdtOJtfNIf4R53+ommmxk62Ph1C2KTyjvX2LjlsMBkDHPWITVODZSS1QqjOAG6a19FesSlEP0xVdaosWVOf17iEd5ivGd+N9dZUVKI4stHVawfSQ2UpejUcrQ9boS9Y2DLE70jRV4sWLDkIy2aXSGy3O+LuzxOsIsBvXuNKc7+CiaaVssEAzQLuMivdjlHsWPb+zX7MAYMnsxyBcwrKdQydy44SUKauWAohl8Xc/hyn9Fdj+PUFRbM1x0n59fiH7IzVNRFh6zqETowUupmd7x1SnHl7dbigy9MmtDzEnT7R6J98bmOJTrlHXG5rtL+fcLExsQON4nwzKI3bDp+iPlFAV9AOME8zDUeAJ2gxPl9lCXpkF956njIoSUe82+Bl00VU9KPEht9N0guBkf+hIzKQagpt0lrY+WkGG0DHyYMop2uSBG4dPbh9totWFqRdfUs62Y05CLvn7uzCqsMl8F8Gl1nI9muZ8/InzpsDWjJlMBY44y3AGphSq1OF5a5bgqp+qm/bEedHUqzYzC/04efxMbNTiklncfVuAEF9waobw+tjMyPFE7+q29h5E8EP+CPYVXFsLrelZng5DaXkARPiJsWcRtJZC695FsY2leugUw0gxmNLO07gM5suz04iksqj1bKu6AeHil+dGyEAGtQufJs52XvnQdofmDARY3upb7zAMfF4YG+R32UusJZf9TSirsM560gBAbQN+RIznQ039Av7kl4nzoCRBQOShiv5Z6BI6TXUEfV1F5p8VWhvxkt23AIxvkapCY6OnNHDZ3nR5qQv9GO/Rr+Pv0LdVio7t4J+AKRja83ZeTvGsrJRmHDlseMYYeiUVHBLj0o9E5zbMNbrgEFgOIBfvedcrVOObnncqbRWTKJ9mK77MDLBe/tBsJPylavrk6wVFhbT9dbU4klfV8FbM1WDFCBLxhwlVhOLwnk3nj66Ld8iSfWjjMLYb0tzPDBRiJz0bdl0k4yuJlyx0uJueXJiUjx3Wbu19bmEvcz1Xh35qSr3qYtmeuJYeug2Qv76RJ+AFfZrLphLa2xZ50U7bQ1hcBtM2pmmzsxvF9+60fNTwndXNXG4/I0BkTGjrk7m3Zc5LWx/lUil+tv/7ZZUdbc96j5Fnuz3kSBHXMq8xVCI/rzHOQIPNOxrCQmbZsYKkBN8qa5LtLhC4qJ/c4IlLr+5vQ6CWGONK0hU0vmeXpNvYhUoYz5qZK/4hPt1/1RNdIVWGkPCY2/JVFu0peN1Ap2ZxaoNhMqQoZEaiJtEiGberacok3Yn2yTItMCwX4ZKC/MdS4/67Gjsr+fEAp3ZD7OT7LP4LBljgRrHgRdD6XhZnb9hWb46Rk+/auWynQZb64XiDaE98Iw7b5MqED31xhsdVV5KSfS+/aDeP6LxDgY7oPIe3ySEcXLFf3QL45p74Am2mlh9dVphEBh0h/9LZ4WSlZURM0ImUjwXhfHqivRM01f2Zhngt9S13lHAtApHAhoCcnAKmRpwThKZf7eKEWkfD2nZchun5LK5b4e2JPcx8+lQ7icyPZ1szaFz+HNFpfr6Sy8RiEfGpDyltIYp4nGgGk8x46IQna8OWZ8NzqJxlCVUg/wY0iuL/z6kmAWocfExNZMLLY5HKr6DcdLV41g7+xOtV8GS079wZ9L9JNBnYWholBAI6jBllQhNkO8ApnGHk0iu18kCjHakRz/FWzjsdNfEhDNwfY2F696UNy3XMQsBEmb1cC5d0FtTUwUSuQd/5DGZ5TAwnTvh82ptw28cwkLcCx3zBdpdxuN/3ZaEupo0gz0aMQzumXe89iDiWQeovScucqg4w3Hc72pVfDeywQcIBCU9H4kD/pIVSJDNKiBsRBjz/LwaWxoT3DARHtD8HAJonhebCADeBXazQj41TS+c9iXkACrROd913cKOU2UTn4hBWJ7Th7YPnJdbmJxpDvOvQj3zULKMC9TpMS6MFmLtFTRGxrweVrE4UNOR+7M3xlK3/8NXbm5Fdv6gtLc2aWP8NiKGXt7BG5AORze1IjheQhzc9MRAJWKAXW2MXJcislCasZVZwDBY9y53TgCOD9adIWOwcoqmH0lxx3OJeNO+jThnk03TMVVHy+2ApZhx8jTNbUjq6fHOSfpHLCPspul6M0G+E5XmEIhuQhbviY0btsierDXZz8vCTQgnPvZ+AAik28SrOvlSM6fqdiYSf2eRHND6oZPLC6lWWktdnwZifcYyRkJSnhYB64g16TRBsS/uUf0NYJSpsA3FKmbO1BE8gt6QTMYAIISe2Pz3IAPGX6NuPdQ3je17ebvqjFgX1b6VajYXvM2PRHLNRVQbT0bTYSTOjNoQGlnBY1/EfhHv90c3CAqeZ5mp+nCrmUYQbRS1/cOJT8G9N7JIZhxvuvKL+mXWGaetQQOcVgS5vHjbwmbNQ3TLJzCdjC6tsoD4c0jYTcrhWR6JLULJSWnO0+OSL55vGavLK0g3EMaMYERBDxrVi+7SJMyiqNZl3cQmKvU7vhXJ2e75eWa4rElS6VLEd7cOIeCIwxp7GEh+xmRwwNLwhxAtEAY1vq3ydN80HxK3yl9aTfnWpOVpKlARq1f94P17GCt1b1PFf8T/0lLsGgvRGxqpaa0edZwvUSmqQXTsUgqZl/LWoqc47HmjQH2VOMrQxrZS5i0oAgyBWglQR/+V8wfsxZmKodu0xVYMjg90asrJS5RN6nuHLYo/oHLfoMhmyZpx7tgw7zEDDhlD0Iack6jbvR/0W2MkE0i82vWttAI+AikZjCxTxNH6EjZpBwA074Jw2FS0CoZ5V8w0t9J5lQpEHdLYAJBiWFPeHvWNeso8bkKH3ZIRmdiDiK9JJG6r5yeEvrd4CHQmPWC4JX0XkIy6HaA4g8ChU0bHqOAdhVFW07iXwvF0A9mdMd8A/HbWyLxgU9AKTpbA4aROFPQ9dCY4O6TsPeiS4qGi8mwxbKTtP6nmQje9ZQD/iMl5uwQcKnQ1/W3hvjnf82XkPqkQeIAPOOsmxH/qS2KDPDlTWwvxv4NC+XTbWApu1rHadPE1eC1xcn7EkiOt09q+W9Nz5TWyZHUhv3yNSl1Hz0WfHCmZBqvcKDb9+8WmVBWMs10Dh0Ep8yq+8gE3VZuknOdmw/zAFCbgP2YysjHG9Cf3zPkeBn+kSRaRPReLh2X0nNzn9pVmZiGhIIhY6Zb+hwu6Cacqbjva/1ep1XfMnHntJRV80ZZYglSixhGZ8yfGX3lq5FpzcRzjPAw3NpSnGrzhlYKz0ZmtvfgLXjKSRpTAUVpNLAKnyYILKPCENiMUu2AiyBCbMhUFz4olppmNH7Aq7NprcWeUW3b6NTGz4dlBqVSBzjM7hTqu37Snd+lMzPThXqS71Bn9FfgEM27Ln4rssXPRKXuqoa1kLMq9OTnZqeleKKiDDPeuxGA12VOoaeuXufcNVyOr4j9G1WFKJjlCIt6gjT1uwkRq+z2ABDwLxOTTrikyzfoVGlmP1EC2ExXBgpWC/jNMkeZqTHVUdBgTaVLBT8+h4YnNONw+F91Jc2ISclF4yYpkZOz0q2zrPxMU5qo1tAkcxxWi2BcyQtQNUn+/NgsATH3RzRLHkf3cgOKXV8Hsjvx2UQ32yUdW/u3QNVTbzBA1Y0BaaqnctwqjDLpJqDXpQT1VFOLzaeSolS6fQqtp5O9Ko5FKQ028Yjo/s3wwZemDTUC2j9rlRw35KZ6+PErS6ZvTAKGO9yVOdF7Pyu4aFMKYuESMbw3wMiFfxDDIE2JzFxa5l4CgW45u+Y8A6HpC8QYLwCx/evHwh1apcrkD13x/l+R1jREXfLQHEoUtdSGkLRO+9/KkvlqG2udl19iCaQX2Szlvq46QOeyvEOSocc+9urqatqYSVlTwwnl3+l5BjhvguFhq8F8r4pbDW/5LMurgY3f/04czGXPIKDc0yP3+b+9Un5yGfr7pz2B8UAaA1HVKY0+O/GmG1zxWVAzrPzh3ez4Xn2Pqq1w4iOGQ6F/6fixUZ3jkuHegU6Mr9Y3KlUL5dHhlrH+040QAWGZziUdR34yfJAGxRnarQp4G1YJpUWVKx9ABL9DhGG/tP38l7JktYgXJaRQmmfKYDvePXb/2tdt+S4LwFPh4NuCi+x8XHdr253hLEuO6H8stJh/FbeqTxSPoxaw4rM72gF7EN0uI6jk655nHKkTO1987zJ1W+PndobN5LIYbc95iJqBWaoZVj1JmV+uRmj5zWG4uv64p3sZjqlr5K/GlO0lx7/fYhNrMllfj1BNgjUMc5Ptae1Kit0lwThIUF/fIVs0qvh5PgLHrDSkWmxnYXwWcC23Os5uBKJaeQh6dFdzl1pP0I2Zaa0uMJhZ/MBYzDKbSahuasw/J4SCb/KpS/NzTb9kGsy0Igt+2kLAs6CYBxEnQN1Zdck5dYsKCPzs8XDNi5MKQwxC8RgDsr0cWG0OCS7z2+H2FIotTiSJ9L7XBKjePEBqQr39IchFntjIfAzVKz2s0CkNSmOt/e+eX6ATk8G3WTaYBZFs2XkHkWK+QVfgAW4zVD4iL7IRBS3xAkxK0fBHvOj5ao+GX6VSSZ5gTN6b4ERhCo+evZ6bDI1tDx4odgPLrMHr0StDVQ4yx0RdeRQdxvcwhCz/tTzwz7Xi4KpSdtxjks2acFJJTTqqi9qmTxsjn4bEWH1tmxFTRIJ7U7KpwRyAnDjKoTptjySCPNXWcDQzYu4c1KhMkZ7AMmFD/M23R21Ysc2AYM8iyYk9NqIijwTnDvfIXXX7VKyvxCAbNkgj3OnZRN6NjW6/UNxk3EvzzGkJoZvPRk8NCbNoiP93cgwMfs5YeuyKGkKSNz/ULCXwh47QM7m9XbHa16esJ6YkvGYMePVrY/i2HWkQum12FF0hvwBkwJNPTk1xD9UMMhmHrvHRZp420JMHNKUwT7868CVYOa8zbmnb4KCzOo2Nm7ovtmcb1B+R1NDTctauMmKgEv5jEGN5rf/hBwjOo3+s/dYud++mJIilxeVSJrE0KR0GWcIIe11VAruyA/tm3A89xP8G6OlJUls+46Ac7ASwegCE7+XnbxTD8vqXULOhjopGHcy88N5PqEVs4xMfmXYJjncN0ndTKLwN51c4eUEJAGsFusEXDwyd00IDDigI9uqzdhBw3oyMMkGXxX1/C+iUgWM1oE24l5DWGNv9KwQLxKFYKS6KSjoYuU/V72kgBxL4uG8CMlEDeUr4H3KJv4aW3F0YF93snzykVlTZ+vsANhfD/dZWNeV5XD4lb5YluuwRTAz7xWPFrrNc4BuAqp8qSp8cDG3/WlQg6J6oDe0S+/dw9HamXV+4i0i1b90MwUhGFcyQdV01j4IbagA5ti4+P0rwQbXATmuK+MKY2X6vUB1YQnTx8IV0IhvtONthh3Ug8Mx3cPeMeNhAK7xhZIDSkuU/zMIfmuPwcCG6oOabaMSesg24BCumIR3MOFExiZw2UwXSMs2DNg/fbiiyEh3D+G0lwMuRG4dBRjHFygO/1RY3SC0OFVfOaztLm49c74oAUN8e38iCZ2GK1IZ83JfgUQlw5HAkVZM9F05hXJa0XcZHvPlCSPxLPHOH/KYJAg7D5+sejrBiTYh67KRBNn068Xk9Rb/DaYcC7dcPV3IIAYsPhNlOWUV/PFDdhy6yeot/5UltU+IVWMDMUt2yutmyvgON+I36Sw1CumPcrI5BszMO5FftbdTEtM2uVSvMmfRmr3TwK7AnrY23K5tvcJ/spWuuiGu5w+C4YdFjeNyFQvzNnq83+R+Y+7yahjP3xFIq+KSnDmEI0c6aBGQx9UnIavaNmEwBqSe5lqWIRNVqg1rMvetw+nY7ANH47voJg3kbed/wuDG8rzAus6UhAydBf4GzMym1Jl1/jpMIulwU1YOCWqGkrOmbdTp2uBqnt1dTvoQ0QCPf180hMwPRjpNo/tWvL2D4hsbpWnaNZ4a08W5bj+CJgExOj0YYVV0zyTPjpxmkrp6E7MPL63wE8rb11KchWS6ASJcSzpMc9T06raWq0VRB/SuA5wIdIrzb7zButqgSXckjnoHUf0DGlU7SE0fJkEq5Z+4/kn0IHMXVHHQFrQTBh2WJBzh5aqDI9yj42BLwEtfVZhV3c3lPdOgsjzbad4qqrFA4wafG0VDTsEhx1vFpj0kOmBWUvvC8rQGF410IQKSEdQoAkS6vld6jJ69KgAmSTjWq/59nER4UVFGBrW7l6YA3WGxW9YgPKhPOu7pyvoDFFkgtgeTn6VHBhGm+QNU1XLW49rhSB0MHo3be0uDiInFcAXj+Zl4OmLJk0uFfHHrOSWm8NEe9jq238KyxCN5SZmeV2J56qWDWgDx57kxjyD1lH2ayll4KHdWUTtHJ7qL9tNdUa5FST4lQVSMJLWMo9zOWDSDwKy558NV5iIZg9xKS+yZmU4j/FfJs5UwZYTiODrXjGxYzOAt0G7Br6Nq0Qow2QLvS2y75mxujxdkIhzyE87taq3K4OO/T5eyltEiPwizOmFm55yb5oQmBb2/Wl6xQBPenL0BdQq9lMnTxR4DxqpcBMheNlJG/nWfa+nobnBHHbZnUVujj/5EGU8H73yItl1VEpA+eSRAFJBC+z/Bbtr56T+RY0pSCoV7yWDy3q5AXqrpn1sfw3Q0N2Ceuk+D9xcmzxmdRndeXcwmTiZrtjCpDXCkmTpH6L8apR1YFL783mbJK1RPcpC0jQ+Lier01YQtCIyU2Ytq7LgN3H3rzTRG5dWmtJayGANpbt2brS8+C43Dhk33ntzWUbi4dMNNMQ55lgPVbPErzzIKZRa9/I6MSXbcfLSRTRIhoIAgViyxdmSl3w/4cfIa4zp0/brsUlmRdMBdqGNf6i+U3+2DGlJQl/7v0BAYP4Y+PIQnbc2jKPuSMh4ECKzUt0YJIaJQIqZtvfczNYbk6apnFjuOddMyqyy3G85aBMhJF8l3/UFTVieOKsG1SnmmsjAFf3obiegPdj5/vf7DnYfAK2mOJrBc4NZqeM3wykeh5b8XADFkw2kA49sJhlmwL9megiy0BYrUz43/cCZhchRUm9r/AETtta2/RHa8yrx2U7Mv1Weh2dUC1mN8MokMzilyoXdgBPyFZU3k0bnV3cmL4vZYkNE3GN6TIZsY7QuucQUq2GQhdyrNtSluhlSzQVKHcJ21150kdyXlGsk3n4Cl9VL9IdjcoUuzEvqBbtahymZV6U0cC0NXyFm+Rf7KDHy1CGf59uwX+Hjl2gqc8ZJxotk78b1IJzr2g0Hk3UuKaebg5XFWbtyPv+oha20wt0kIYFZ6b9Lhj5oZQai23D6ZOVQeNahB6vn8E55XwUhigcHm/DWRYTvjhq8u/9x7nR1Q2VAmiIFAQVFe91s29N8k27l/lGEB7xjbQYBSRiJr1oIHmufkz4kb+Z5MEzCQ2CFcaxaWyb8i3Jbfj8mvfwSHp4xFfDp11kmHndtxSRyhZkvcIk7MwbmN59wRbBqR+T6rfNFBOh+/IqnOgg/3jrMvoo7F4bkWEJpMN4zPKghf5v4vnf9RLd8R6Xp9GYsasdybsGg/QWC/jR7x4ekSsqbhxWoNPcrL3idG4LbajtZd2/7NjqMD1L5OiCQtaBmzs1nqty3VD/kEetL2TFzwuG//zTrI07JnuOckJvOgENrzKwUIGUHk5jj6Q0tlyGy5tja8W0WeIaCG+CTa5NxO3i+v/vYDZDRf91g9+R7V5FyxKf74ZhEVWVShwL6pW9CyoR35gXeptRz7RwKOxa4itsL+zWmeGvV/ZKQaDl/sPGmnO2R7ZNSDoTDAFkgzUD48IKm3AXpOCejl0NlYrsbH0pMouLtp5uxVN2YtWaNkJNwyBsDBnEa794sNk4ZD0qNlgHUwhxMwdsBLbonw0C3mZeFDvMHLIZhavlTmoyT4HYr8pGjNnRy/j8fbj5iD9P88qEoNYixMc7tHbnUNHek8TfTFfe1foIwlNjqAjJBB0sdvk4eefK0ghEBfCR6MoFO1j/T1agb5tVz0xPwDTfvrnMConjshlS/H4Uet3M4q1phzyR3IVEP+IpIw0rmmgWdJLRxsfh/3LXpRZKcV4y+2GK4rVmVL0rLR137UroNm5UJ29E4UV9+s2h6KN8eyFv/fQ9FEJFd0vJBvUzj0jUUb3sSAgtTE3lbB4GwKDYJuhmDpZpQPDU2xdxgdy9ZTNkbBdu4bMCyak7w/JEs7Uwxz09tuVdI2Fprq9Xhg9LQSukhwkXIV+MqFo14cUdIKBC9vPjwv1/C+T/uwq2s+JMim7zz9PQWHVvAMujfbRB4TEZaGo3ZiCm1eYZsd8f9uLcHOEd/PCWxfYu/K6XuGb2UHDBQNThsztTlJgnRAtHA2DmpB7l6Vb7VQU1q3pU80HG7ENjyiNifarzED4RjnerQp/muOKy0hXU+otwZwNEPPZ8wCMs6CQBXt3HjP/4U/IJFPv3B5g9ZWaEKoYugnrjZZRRRUNxCLB5TiwVuC2NtIWrwzfZ1hzSiqgeyFYih+E3AbGeGimV/x+8jVtsTnwBpTAZkDzTk99sJu1hWxovN9RqVwPrdBYzzagW8DZ4RghBVp6DEdXgbNkrU+oQGY82sFF8hcs0pPuV3/mtNz24hJM7TPcBN8uYPHpRCL4Uo8a3uS3cZLudsNApAVHy51Qfbzb/nK7ltJ32+ts/M+BpQ1+LJvkn1cSIdtGCf+LmTUnvNWVhnfRkJPT0JZ56/h43g/tOuPJMZOqjg8gKJOQEIVfEBFN5C+tijiByoLDbbQY2lDEM32Y0uY+3YfZiNVE2XQmJC8NH/75sVGce9HFN6u22trmN4S6J9kChUkqii4FIjFwZ/CHwkFbpgubDdNgLytC+K5IsO5e8RrxX4jDQBCNPE41awaST/u1Rl58E4WiqAjkLyZqHHy2VxVLAd74sFzFbzUwiIurbNuYDHUwUFBeFptJOi7SuQjtIkGuACC6miWH/Ie4UkO8TeyMSTuSQ0FR+EaQ2ZrFE76jAK28osnHMzxOQhM7DHfuhNxbi9OtzKUk6toVwS18ZQchN+p5LNhKjwghSK8oXoZ286fTWFPQNwOPLtiTzg6F1OS09NdM2p+bq7tcm7Zr1zR3xrvFgTh0mpHUmw+DYGSqlmr8LjcFLfuUtDahzZGg6RlMEugWME4BmaZAMb3v7gN0XsXAkleiQcB5Fy4HGyHJ7vl6oGkF6c++5Al/AK+4XLCgT/qJrXI89LoKt5eiR0wEeqRjkU2TLOw2JNRS15cCU7pM2VXYWhURbn3XhlVxIFT/pZVZ586IdsJ1GRUKaIRE34++kebil4YUSDXxG6XR9ix0KbogumuQ/d5L8X0mjbOg+4E09d6Bef1tvo0RAyDLq99eeocsFjezsq2RfRlUwN+TcdYHuH/wL+olheMJLVVqwXKqS7Ynrbm/tUvYARgp9A6iqxqUOEFA94qjC8d45nhRklkNpxMGzLMbh/hfMUusKAJjry4GES7QqhYyEDwYkxCp848eR0c+pEN7HtfsmLQW5zoWIL8v6KVADS+YpbH93k+DiMQ0/gHj2dZH1AZ024W5gXzl2yGa3rrZaoXV8E2Zpebrx9HFh6UbBXSSNBeUEitdnKCfWlByzfJQSkyUDA+H/+DhXNJOCNhFREtTmT//SPhzjBeUyKiTmZIEIlop7EU7dd/lbNG7CwTRRdibK8O9/MfjQKNQqZssWSpobVGubkwjU2uMOYdmdMfmnQ9JSc3uUkdT2Gt2agDFULHpYFwj94vF9Z1XRwrDOjOnH5yRXH7LHJQe5Uhj6qRJK0wLw8kGFjHBohoDgeNHP7qRa81MsC4G3WyXsVNZZwW1LKBaRD1mmLHqoZY3U+DP/1R+03Yv73DjJsQyddfLFcZ5Z1HRWHcmpsJp9MzkzgpOjLlIEfk8cxnuKiVYpIIm/Il+GYGIejgNvugFwEcPkfyTMykV0Q68NNtl8nn1LpFP12cHHdk713B0wW1UxoOEvgFdzQ5q8kXXyILmtd3EDcLhPg0ryCBn9OvFir23qTpgZPLRCnxEoz95X8o+4OMsdEUpzqns6nGclqxjr5r3glzEDrB7xpqle7sBFHTe8OsC1mECPiYM9bq1YdeECDWZsJW/SBtyI4X/IBY/zL9wjHC886+Sqo5MwRHuabADRorkFRmY+bxEt69kKOZfZTiahZCEE/6JBN3ox5mZ5RfTP1hqc7yORyfidFsTVQ8Rj1StRTiJg65K7/o6D6iNuHfzx+DAmbKU2f82qgG2Qp1HF9c9F4zxlxXOYzyhQN5RSAZqpDKo0RJOcDowBDTCdXncc91DLngcqZ2/ycOHTzIxXV2HsntB98QAjcA+3wUh9r4lI7hsygjUwFtViTAXgSTGcuxQoC2Kix2XI1tFG57337tVVSm5IWJlqS58iWCZgdK3ueDjA59o2XLCwzW+4tPD21dXxvrVxVEXM6qxG0hedDDx8EK6fa5VgTtO40H9xheVnX9te6gutI34kaN50egj5khoMSp+a58BWhPna+MEcS3twlNtrWjseNgumuoCNdVH5oyX8bwcjm/yCbllFM92WgIP4qBhY7NR/wjMEDgErFmHLduQkr9wxO5+/gGptHLbood6jsOfiLglw5QkrhiWiiIs6RJBwENnDTn2BC2/4tTPSIN4OnkPztswmisi957hggT/hI1mM6pTWc84fVxReFC9MirQ1EdB+P9/ddyIJTJDysAgd0vXy76NDDubxUF1VMCyCrKvMON/qXRv2Ds5hvZqNsTKxSGAtgTzXxZYXBrsX2Vvg5YdotIi7X3pV3FNhNN9ikcMld263PNql737uYXVhERy7I0njaGEIX8ENqvtm7rcyix4N2bjM5GEoyikWMu9HRtCa9h31Rr1+kpxdlomZHE/k37z0eS4b7kdBaSECxpfrp8SFID6NzMc2VWQVO2qlWaCSId7dEFgW6ovMBfhn7AsfWopEvRiWPjg6BkIhrM5GXKy3Scom8YNnZaBDqFBZq63V5O/uzsI6Mt79FuMvLOcNkRxsXJDHH27WrCdkYfdj9ws35sQkRJX/SSL9bcIAoR1DXhB9CwehQXTbrE722zcYWLUMg+oTrNm5/fNXO2VfICznfTKYvRJXY2mT7K59aWj3b3Qoosj7ellkSyN8Eubx8BRXmN5C4c6pMnFRb/UhopIPSua77+bE132JeNWIv4FcUY1ReU8rHjL0ygWvI5iGkcxfqUPVK84krxIQuTV8tQvQY5VhxvpURCUC3AjNF3+Ohg9W7Lmg+LAh3xvhfpu+Kd/XgZYvt96xyhn3HbjSXrphhUL3Hqz1aoHCJU9yMbscRf+6Htmrj54vtfZ23OSkiYV9ykTsD+iMqqemalhUw8uA4UI21s2RUZcvTrRgLCxid+2t/Aobd1nIoo4qL0I111V0XYQgK6rmgoQkITQzpftRcI7/4RcFYSllhxJZZtT35kfv3bmMTKOwkn+8iTKRbJXTKWVVGUJ2skp/JCreH123exWFvkiL/28GKMC6zk9CQu/yfZmNVdgKx/5S0ftHZcs8QiEw5rqMLrKbAfZ77aW9rYxRE19x677ujlqm6cHuZR/dPG6KycwitosufkI74nuLIIeib21tNRlrKiN9SHU7bbcOe5alMH1vYjL7R+mHE2ibfqw885tKf7xxmOP/gkvol+bUxlRSfAJyw7ncEEEP6pYsWjZ1XPB7WGErUUrgez8nsi097RAmZ2h4R+xTP4bBJrR0RCeR5G/h7rjUIx65xpAl26KOn6tfjlt1arcIlOTAJEaE62eSYMUBjJxf7XaM76skbvsraVE+zuYJJvOQhpD01y1++822hypgVhs/f3UFb12fViGgjYODXqOYpZKQ5pf6z/pNFFqtfm7wF2gYXZb2zPsnzoziSiXuWi/tmo81stG3b6a7Q63zzNEic6cvhzETVxpSq3cETFIBRlVbn12aUd5Fk4rgLk0tLTzQugcNNFFbG2+ao8XFe8aHlMany/aGUbMfiaDClWPgYJYFY5rUvo6cfMzpHQxK+laJmNPBKuclMSSe5muKJimoc9NMRKBQr+Mk1sg5ziDuV41Qrxdhr3l2o26kReBLSmqJSo+GDFnghpGkQLAg+NTj7u8XDla1GT8IsJkS+gAxpR0Nf/C+2KfgmDT4+VKa8hSkjuIg2ld9ytm9qEstCCzIgJabm3opOt4btJ9mgy1Bh3CefbPX45rQOuHRjQd82PF4LrTvkLcxRf5WdRcOnAf6QDoFHadyhp8BXBlwMZdo+a7y965lvukrJShFJQdzKzATl0b1qpeTUWUSyHwqO//K9V0ymVS9RgNAIIvFcGoLLTMxWyl5ZYi2wSTzX746vX65vjNYm3i5uL09LK9cn3nn6ifc4nRqmfa6KwUEHmzV7iuP2gj83KnE+DJXJGeQ0tUxhiUEKBal3MlnIVegspU9yNcOTTNqDUd/momeM96OhItfNHwkRGZrjVgjxlvpN3DTaNDLtSgJcq62kLv+/GU61M2/+IurC4lkGbjiNZJZxzvXgfZidFJIUmufG6tkzxrjrjBUC2aRrBIfjnsgGze+zeT8V0ypl7VvK5ll85fTMBfqkRgnTH8e2E/NrayjzeEDQdIt5Z4p7vhgFOX9WMMG3cDZ+oVV6MhWEyUPTG5x0kCqoueM+PKax3gsm5mL0dcH1nLBDgMi77kfsDM949+8ei3GfBcvgSQMrbbCSOfs7PEWOpwYoBl+Bvu23+k1XWtYprAzqQGcaT0Lt50hxWg2ZOHCFY8AGJ0FAX+lk+lRo0GsghRO76dAA087JDem71EJ/kKClrCAxqFC04E56P+axfJ02BRW5SoCiYSB9n7Ng93HFEAWHGLuENmaLsqLivs8IXEp/kIPe2g7WxfyPJZqO8uewTAZ3cGGJfRR3arcj3M7oIsRCbpDKC0ckFvxrEz5ONkI2Qnn33y9Mu9KyhVGqhqYaIUOmXFGmkdCFhKhpd4NPOIwdHvX5tld2ufE/xSsYcMdDgi4I1pqOPd2g9czSW1NfzJ0LcxRcvYrt7Jbv6GH5u4aDEkkfKCqmYkEOdHlnqQ46mgKChOUGq3EB8mACeKp5XA+Gi9RCRI/n/DRAMx4OK0Jfv8wcfSNM8lh2igdkcvBdEX1kLUqtR0JfYhNASeeqKWh/98bco/D6iZVvS+/UOQtgGlhjs7+okUFjMjAiNbTur6fIU7Y8LUf6SvVvd+o/eTjHP4x0x4PJeeqiRnsHaOJlmylkg+EcX8Lb3am2CbfKqH9rCRVSheI8yQ9bljyxOmOSpGNss/J5gW18Lmk4obeQ5j+UkV+0nx3fIXtOek8F0x9Ui9g63UgRqDX7APcvRT7MeBKDaSc3bOrX1WcnP7Hg+jQRprCFdklXriTMBt2o1uTsRoHcY9hb7WjT8aIXroxnzMksfsJnlTgdarsQRHxO+/1PL+SXJJokdrUAxva2wWadzSqjUu71wy2JYqP4c8lYziLAuYILYBjEG/bQai/Tq7dYcT3PJzqzZ5MmJ1as8NFJOSE8ut1VccPJ8DL+PQCxwx79bKLTcU3WsT41LYzjrhno2ZUPcvTJoVN8zxF+EMV3eA+Aej2i5QpMwvoZRKpudVp6ny80Grzw//Wca/axw1bpJlcvixDAvenrs1GnLCK8BSdhAu0zUbjVjdQwETpBe7s3fKy4qVwQmZz5B4pATIkG3o77PGnxAIGfg4BRDoxw7t/AHW+68iUT0vcJBN88IdnclMucUL8dFOAkJqL9td6ZzsEdZ8ENksbCoFxog6nVsMzJAZwakLRBW+sYwwQSpG7VFK+LfK7LG+ekMRLlKqkx1p3nfxCHlkFVw0Cl2Edt+mekSc0UnUn7zOB3RXDgH/FAFqY0t2EcfUBsHhzUha2sHs9TYvi/Wvr9dhYdVevllwOXVCkmfVthGdvCSUuSSdoRNZkP8//66u1fko5ug/8jXbZspyW1WvLFmNh8+TXKnLtXneZOBJfkBnNlXqttvdbAafKh/UpvjeyN/Qcl6AcqfUup5FLalPq47xdmEBZZaoEhBFZ/Rl9Ya3IqBRjE7Mkn3aczGvWpBNKCU0aeN3NjqCGr1OTBMDcFVNBWVXtR7esVcY0HFHkhA65lxz1a5i92NG96E53wmFqj4GYLqrDsM5Y/ydRnjkXZh2dYvyQ175NfWJQ+/Bc5s3sPSIGWlDMSEiyd1MBerfnaB9kNce0CwZMOCYmORA2SeGtFmVBGYziFLiWnyiSGYZMWGN09HIwhaJ0aAnEe9XyG3AZnxXp5rBmb8RvjkXJhbm55daMo9rAaFwY1tc0wOT6arM7h7wI9l8IlER3VKqkszso8O2vQI3oiANWB7sgZwoGn993yu4OKrYF/eYKdG3XeTHJfBdiiO+LP1wu2ijIZMQFlpaS16o7sqCGbRTNlgQW/34RHl7QBXUV3T86kfVXA1OyMn4/RHrqNtYipDvl3BIcjVmaP3/2WhEOZOMhs/D/a9orHp7vSIzgoxQMoWjWQefqnXzHV4SA8vsBG4rFddxpVg3rf4G795I7of5TiFJlNr1EaxtX/DNrp4WXUb2wsY9zJn19pfjXLwJ0qrExyo53hdENlv/xWDfxbiwUQufaxoAnI0o04clYLbvX4t817TSN8phMsUYJfVW27KG34yspi3m+gz8eOHGwR/VyqLn/C1ugkgzXlVeBE4Q5zepmKH/VIbz5pcnaS6lPiqP6tjMAQhNqSxHVw4ycNPluhPK6/m2nu2PPawfbq56PzFtEXhskCbkXrYpjcFLPfv2AKdkdOVIy1KQS6wYhelEkhM/9eKDqeD19svFWqF5HzQIZKCTSS8rFXrqVVip7IL8PQWnZMFvNIzcs5yZvEy1kEAG3UuXuaQmxh94EDozDFzcKeVcmn5Gse70x8BVHTOfb89mX6yaalfq6RJtcJrysmINgDjrodSEtWlKwUCrbgDQbDEnv9MHazfV46hS/jTU/pPE2G3omh5W53W1vrMJNfmSj4kXeA+8Ly0K0J0k9slMjYreVo0Wj0+GnBNR8+nIKQDbZ/zySDJVR3YWGb1LADCOAtDL0nUP1P2RuUvgBtG/t07BZ1uPsc9Mm2CnD5ELTpw3+A0ONcI9RYX2cAvIwaSNnYt4xxLxfwVAuM5qKZu2nitGp34FqQf7ywzTXoiN2TlIWSC1Jh+roNYNFQcZrIoaG9445omPsasoKasLZsFlAeHVpRQ/TTikQ1Es35syOoD6nzg0CXIWdUC6EGKSbsBlmaYqMz0slfFMkDNWsIUTaDpEbqTRSM9tfs/k/DVKQc2qZdhksE1/Tous6LlJRnHnvWQX0MeiYhOK+4v2tsLfMxSf6jjOZV6RNpMeM3OUA14naLtoAPJ/6QbLdN3AoE+ciGffEbz+BvKQHH1iuq5Jo73mZHtG3IdoezuWOtT1DMvrx0KQYo22RnIOBGUjBaxFdiwBQkHLjoFaf+Glu6jL4UsCjRDK2mbUWbNo4bHmk+A+w+BHuPBmmRN3G040Me/q6s2BSFknS5b/+64rGknhR5/YS+zdQnNDfg1bm5o4nNfcMHdwKhXKUdqr3XiY/EZxPQ4RxpuhiJwHWHVN7orWIwiT+d0qf/Jzrw0bApbGfNuOX/dhsPzNF+f/F39e7GhZefMrj+yqqGDwuEA+nrERRoEo8f60Q22KrCs92WF6dnxPeUcAqrWY653V2keX4o11eUic+JJsKAlOGIeeTngozI5vGwNVpCzy2nz4aM3yjteiwwPgIHw6RKpqORz6i6loSLu1cUm+4QCJb0MdpPt6+7B2E3MV37989IkspqLXopE2/PVFtKhKRbo1O/Ik2B91aF4mh721R/AZlQcpYHj7EEynpMvGavIqQMuys9bPNWG2hImjtF4x90CeAOLPuhbWvZIlmc1srqqwkfuAiOd1oD/D6vzv6aIp5kCu+a0EWVYZcgdaDV1xJdHVEBgW+PQ4wwaeCumbAjHg5NMTcaUYJH14FSDFBZd9nfWMZUPgCzUGl+OgYTGdm4HkPW2YOfbUV8WlnwTaNIusw7E792+ljnQwm1eEx9HurXGu3eM6w70lHSovpey6dISeRkbefB28vS6Vlw23ei8HzivAD/qedUZQXIRAuKF+gw994H+8CwRm5D9VPXh77h0RBEEkUAo2DSi9LdPIavO9gBUz7ssx3J7Q8MFBri3uDG1CsDD/Y8yBqVJgNfGhFyaQq9ny/gVq5fmhxppzq6GSScPOsXe9ZqqIlKBfhKydrGl0Oi5q2pu8W2sfWHArP2pWK9cOmRxnKFTlQ1eQ7C6nbaMA7/xZfdxkIqBp8HMH+rKj4SKGJy773MMNUKxghY+nGMNrSnKhTHbXfaSNRxIfYDU5RMq2uoeBux3RJWTeH4yhTs8eavGZwGSe8eEVB4mEV2SpoBay259Mm+JrusHVwORTtlMwtmM8ihJPpzqg99AUAVR2D26pKJB4cplivdTymbGqJ+GcSfTVueGlJLIBP31vQH4cgY0/XhHW4B8/mzSTDvX0PHjpbbJ0WXgmWEybQdNMoRYtZIe3ui5dJcs7fzg8FAWI4eORPSWghG+K53vS0+eVmhlf6l7pJAn1jeAFVwQROLnkPRsqCNqo7YAIZw+rzsgfdQsKL0uLjdQJPKho/O1qWqhUl3n473ppFgKc6OVUYsZRKZ87GYHxRaNgdpTDE95s1p0iSHRGOpLCWYrTD9kfdgz3TnbXHvJ2v3NbiE3VRghn1qD6/3LANq+43eB2eqED21otxlSbMO7Ti/bILYEAkAx+OatRoP3KcpcWKXaAiYlBX+LdktaTaFyjYBfPJQCtWUDtobQDzGqxEpreD7WpB4bI6wOxiDKychH4//ar87zkJ5GtYfOUK0zkPug46U43WPP8J3yUm4VmmBtBJqnLOyWGMfEvmif2kAwIK9IeEHbvfbIKgNXnj3eAOx38jgA58cOuND4hLrMD7Oo+s9fWb5u+LU7WtDLjTRQDL8feV65PX0kmOe2QcdBBFUEEQHjELiFZ6lAemAXD960R5G0rid/WPizUnkpYF0vPC+3hO1xQRG/6ckxqHS2eeNxRo2yvCio+Db9+s2ch7kvMGcZyxTNRuWpo8yog+F9tH/Mhq+4+72OobKs/TmbJfl4V4WQB3omOjBQvup13birrGihEgxi/wnzgtfviP+f77xQ29klNPiDAFYRL5nGtEciaNUlcXsQriPojCVl4uUjsWQM5lMVnH2KJUFpx0xXF449reMmBzEND3q4K+OQlw0CdChIIZ0Cg8STqQzeR934ZYfjsTH6Fa9BDIwW7z2PA+dpqTiT3e33MzflsQLFKiTzfWQE8uNUyA1E/q8lGsvF2cF3sBECbl8fD6TpviBc508TmLZBP675iROa4gt+9kRGzEMj8eQm9teCGvkdk9WpbnIZy3oKyybD3IvU+YGKm7V2FfKIrWs9CFxgnzu4fypjBO0RvjsVsl9fEskJPnIFGYJ2vsLg33O4X0ZdbK0BZYPx3X7Vu9k/2XfDZEOmsDOSreivPHuVKmsvArV6ddvPRXhAPVLVYxCpNf3EFQUTe7XeK73ESVsGIECsxd7G/POX12p8Zte94Yq8pXNv/nO7KNKIUMPb9P4B37P123gjHd01fXfPWK9Ex6uAqN1fPczlLM31nlTsdjoquRHhsBQ4JbhiDlZq6eqAeMuE2Uy2tFhC7Hr9mpBSGt0yste44SLzuYqkAviMl2cLdHyVvjr87HuMouH5j100qXryeyg89CA4FPomQJvhEvRGvpRjlK4rvBTWIX4ejgthoTjiTVnK9dsCi0Lw4rzT4v9cYw1cg49WHNLOTsH2dSJGHhSogarvK4FJ2CLIMRCsEth4nvyWpG7J660foe6maZbqijR8R37fgZQnwmlvHT+Ud78pb/YF3OW0/uLPGtPmUDswtQYp7uwQXdbDTJhDgqURs5ZlQn5NeHypdtC0AOWfB76GEhKydl6ICpaybvDxjDuriC8BlNfWfMyhubkE2/R4pigpfIPVggglB5HMjJBBrHksfTBUaHQ5f3pjvZfpYPxeBbD0v+A67yzQNumw8pttYb8K6d6fHEcvwusEgcG9TrdqnDkMSbc6ERZNaBDP3dQWuFD2NfwKUX/mrQdAxY7FKnRl8HeES7Tqctz/LwaUHgzRhLHu+uHBN+GDKnFy4JVuCIvP0csy0UXwa4mAogh9wLBmLI4TvaNxE0Y192lMvrhh6lEFbLHfWC1rvIom9P4SOj/quizWipCnrEBRGQzZ3LAkyhsPNj6YKY7AefzTUvLH8tjwjgAG5Gy4FaVZ6JGHnr0e1Wl8rJR0WhmpxOQCmdHyVpS6nPqtHbbjYZ4t2SZUX+yOz20XpegtNiltBbdjkTnYHld+LRBuew9utuiZEpbMtd3wfEbkliCqUAqX74LeqBE4UbZK1N+6K3RBBMHzR0Z+jQ3BbAn8R+Ow61YpVAao8x4aT9FQFoMXKyFmtakHHHavkrbvpt4JgyUULRlJYGbMx2QcgwwYioIvn2koYkFbOBj6NvIMOjE4gyl4u3gtd3N2ZEa51VPU9jcbo5ZcrRbJw7pjZbtzanp+zQWKDyg+d7fp4x3bavVO0UH9iW8xTQpeIpKSfgugPhOtARxjvBcClHbdntHR/Rim7SEkhJX6Y59FFOwer8s5zDCLWDFmijz+roAun2QHLbcnbFj3BKsP7MO0uzYVDccJpQipoZvLyd1LDRnWy5jDxIqdDuAcMlLMed33MPQZPL2MXLaWE3RoE+j9I8wyr2cUE+iKGk6hG7MEtymplIbpGlBA+dCnr5fT0Mcws0R5pd6XdhSQaoR8z9zdF6/m8/lv8gMEiBPI66QQSrsB7eWFOdrnj3d3w1Nl/kIA7R0osVO4c6RQ1AlnKfT1VFUgOBpsr61AaCDX9Smzvbnj08TzxbdoV+vK8+ahRI8QKFfc3mdOj9aCpbB+FO1Jt0Sgr8tIAH78XS6E8kFF6NMq+ZsN2J+hIFvcr1huPv2RV2SY5RGXRBYf2+BxQqNKlLni/hrQ/9R7K6H3v96RijStUBGGEbDzLBO6K3DNC7mDbEs3A0TLmFLG3ul8qmDSkO97D8I/EW9dS1dj/W1eBValN9B7uFhdy5OQvYvyaa+vB8DJTtpsP4OYdrIVptcPXog8NASkFydbpQO3hGL8xaY2Th8c1qqmynOYD1im1dos7oTpT+lA+cLyc5t0g52e09ZtjdG5kD80IzoxJid8bCemDtYL4c0fkBOM8kJZSuqtX0ri6HQqJ8fsbJunRFE2LmpZtSBrTDDhf6W+QhOJo4NTlU3E/s1LSzmt+mGkrCA/HlyhV5w0QCuX9BssVW4I6DLkOknLBQ0Ri+Pn9SMdCDIDPrbKtnP0B1zV4btwdX0BnHxMc+9qmk7ZdDVuiuLxiQqJbPVQXlea2MyUztlxK9mO2xuZAUeBooYyQ6ab5k1ITaPpNry4yweHn7TDv0t2/taaWYImfWHaaB0GNaNaujxaAmRY9TItphYJJptrAwbaEngoCAaSr1ANXRfGnhkb1Cp7UjBu433e829aA1/08VomKbnu2u8IkHmYddh0mdKPLcfAuvzE7qIYMpMlWTonf5gMvOfVl+WveKB2LCt+IpojtxyS3+oYW2dW0+/nAML/kA90obVwyikhtUweXcQDxDkO7Rjl7GhdjvhQQu3vkb78LIdvXkKxnoXuj6A9j66dseVnCy8SccIl5Y9MTEirizKpEO2koxaGZ9qrZ3JJ8g1yCWmB2J48/W5gg1m0zKOAp6y+ZgfIRkaLVJ32kdqYKYfH5oP16exAutYAKKJYPosWHhWZs2hPZ8BILnWjkRs7qUXvtvTLka1wg7ieU0rihEt8PlmaEB3H28lMxS44l72Bvlfz3Tz4nFYyrRnDbk6IpdIsmkqGUTvqle65w8nikkGTP6ry2//OPQ+XXbkXz3z9ZaqcdadvlUDJVyfB5cFPwF6PnZ+mEMrGWi8B6Qte7SGuxzQ665STfGiEpvDNBH0pSjTbWSXx5hQewyvF3otpySCvTHqIhmhwQNP0wbKqecZD16zmlDUVKAMvnEDVwjZk+PRB2D+V1NprCN83D2nVmQSwhVKT9KmmQvhyV+Ggf2mBoHZrCxm3AQnZsQgAthTn9eJV5IZPX1nlmzx2cKU6IL41iglmQYoDYB1SioVOAFoE8GIjdNCdhJl0whT82RV4PepnX/5Z4bX/SO1ybG1be4/7VcwcWrs0+xOGaRvR10WumBm/TBFiN0zpNyJW/c7pS6M6Kte9d2oRl82my5fGComQyzz3DU0hPutHvi6iUvrbDcoRJCn3PN/QONvaoKIJ9QYqSeEQopRjEsfsRjDUWnEtsOvWInnp8xHrZ510dIQb6QoIJ+3LaKppth7XVRDbnurq1JrTDuHjtWyRC9rARWUVe4QUafxYZGoO6x3zjH/3DHLL/mR+70I6o2i1U43Np6LKGOkn5qcW3k69SEsxpYfIapLGmJLQ7LfDqDLLUN9xoctrNxay/fR/Bv7hTrjLRLGD+f8qoOMxd48Z4ku0rKvcVwfwaJVPM9gmAf7cCy+C+r0Np8ktvQR29WU+cmT+Ml98wJuYojvpB4Npv+ch9nxhg8AgQvbOA527SPcKvKa++PDiapMMKFHIRBXFS0KKGifqCu15BPl6QS2Mlx6kb0VYBr56/RWuC7yJAuhjIeqT6lxaAbtXnk2TOLtbCuiWByDh+CW1ap+7XnfiH4oK1F8J5/x1jBL2Phf/oLbQNiRVDCYpVJcSvFhZzut1PGZVvdZd0Q7eiBGgeCsDjUOci62hclnlC54PfEU4HGjsQb0xShVViFtRAk4OND2WTVP2LCpLy5lColYjiEcQengBord/yShVyj6VC7X9gpdxUGujZA8472S3F3yq4K8k+8kVBSX+8lvsHYqfQK+Kr7wdhbGXDTOK6oTMXeSLumEtcCoTBqd0SQMZbDCrLhTJv5WWdGgfrFN1q50kyre2TUnjuh0lWGdDcT5eDLnm+NxTE3xb4Bf2hrDyYXhxIZ0/ak8W0LqodhIqXZqtsaNR1+VDfJt8zC6AXTvi07PkxppAeWg2W7lDp6e9m1w1Cdhvz26uT7NMdD8b6kePn8ZY08lr0dQgRX8Ors6q+j/7z6c1bGobOA0Dsgyf4mG6OgdMANH5FAKb9GvifDEvO64x1NOTnrfYU4GVRgN4GgfvodHQB8hqn2g4cRbgmAwM6EWyQVALv/z8T9GTGwH0H6xcjidj3buanOiuozwnGZdHeFrhHjVX9dtwMsJamtKASb+B+dH2TCJZ4CKP0sKdGaaUlQxqUzBSliLShevL+zmQRERcUpae7NodLQStgb0mpzf7PM6ZKVjWqIQGiBBshUuQnpNl6Ojk9YTiEvees/1Zz56LsVN84Ct0qIW667Yqsx/wd0wMlAg/UCYouYofp2Gpeg3VRbF71/PTvahO1KwJP+AKwl+rwjdoEkGWGXMZOW2OWGCG9VfkvntuYv/2HfNpm4LoPKLlHs6vglpm/3cUTDxaohKr2TBaCnhmNcBRxtiktFaPXf6q+igQ3fZp1B+WElsGa6xokpWoX1+NxN9g0k9o6RiLiCETH0j+tIQrjR9bFyKNXoErbNTBQX8XnI9haFvzP2EQZu1DAGVqLJmOrYpLU7qai5kBVW0D33qPjoe/9ezysfKPybysJsTferlMlAq4yOF33y2DjN6JsejHdGXzNOMysfS87y0hUZFoAlj5YtLUqvCl4OjQMJuAA2W91cIzChrM+zrAipeLxZ+8/OI05h+4dqTgiCWQjO8HCUNWztlbS6SgXQtmjsWzIO12dN2x1KbxQX/rhs2lO7s1zfjOA6372l7RZNEn3b6y5DIWpwCKbE+z9y5kB1hA/9VoQTV/40oR8h2e8aurvGOg5IV1a3DWbGUzJpQ+zmGfihSPTWo3/Ygb0XA1SOHBdWQxCNTYvpYbNAmosCgSq5cd7HEpEOrUd/dy/2ymBqIGj0vJzJoIrJRyxutattfEfsRRMWW14uKxd19Ie0ftTX+fV+L3d1HbSdy/pUjkqm9o/RuAZfHDsXaKaclEIBZQbJFXF+ii+Fg6gOdhGfXBJgPq5KilxL8A9kabtI4VX/EpjEfUqnn/4Nq++iMbhlzqq3Zc0j9o0+H2GcS6NO15ju5tEHCzFfGiTyVfBEyckYm7czUC23d/MdZwTtze1cjNqi3tT5/i5yN2OIjPbjB4gKxAIPXRsxcg16JxrYi3wwXpKel0qAZ3PlyMSe7A5N8RculJR2Ppi0W34OB23Br3yQdoopBeCXwsj9rSrHBg8B4OaL9PJSr69HRPP/EgxS43GdnTSVO//BAUdsQkOz4VDPE/FB1VzwyEgUGxuvLEw46RyFyea61hS7vv+zASzAFpUpCGDZJDC83cV8cBSz5qJvh/2H5ME/5C8lCGEpZXSwUtbUZRYL4xh7K/nUSJKGpOUderKFtPscfmrVVS5WHrBejI1WZZKpugBcf87UC/i7rUI+CjuT71Jrfxh5e7CONcIybeK/nT6Fhls70Uo8mRjvmRnSBbVhj1P51tc43UKkWUHYunp1XoMFY7YMEETJRX/7qOZpTycug4JLGR2bSbsgccVIeNxEY26HlHaZZRYAP7UFyyej9gvSokE1oYNhtHPNAiH9Gku1jUKtuYE3rRTV/aqhRGLNWtBIjqQthe/xb1DVPamKKzA+tNfEV5dzk1A8AzYPCdWCU2fFMpMKcVSYezHskJxCoW4/jK9pskkNkKf6eRocVsXJDTIwaPAB7zACLAXPjuX0wXCzUUybX5dbrLMjFa0OQuPJWP1BZIyW35qQ2s/nzbzg+w1Qs+p+++7vzc4Bfqoj95m05FH8moO9zOF2OfETgTiz1eaURglnNQ8WJ0BFtjmdpIUyJwVsa1jyHUfmLN3MiyKllXiRQR/KVc539oSLrSuflybg/3NgtjjAv6OBjL27vkWG56t8SmPH+4gFYc9ybRDjaIpN9jbInAmwzb3pi/oaEDClICskfhm5f9b6DikFmWXrpcW5AF2TeS4YuLH4+v3dDZHOVGA1A/vLzaNE/KYGDfR0PBGmpoTps7UwPEleIwJGEFA9llEcq1anb414F+YHOITPr4pgAhvEcC1sUPi0Jz/+pRNzzNJJA1vAwFq2Lbs9kLe2HhoSjQICw5OdQ+Tam1MLWp7uZpg6NqJnek7t4pal44+INVQJGCAJVEqoTSLgfdgSu4xU1d3rIcvbiCZXi2XesT0+GbQMSmNbaZ3mn3MG2yFu49RrN4zM7+cD3S5MZHucJ/2Rxegrf6kjai+XUWar+vNCKJdQSByITOtydjDBHjf3oSu77Uuga96/yn15BRn0n1RNRxI1Uao57Vc2IHQNi+7gs4SZM8wKVKyRSdq4W77Y0mJkVb4s1Ty3PIk0lSGkmCRkrmSVEysqPUOQvDIagecea+2joqwRuMrpIm0aCIy0eyKB+vpQRIqT4KUZUmIp1vkJTq9kuKMOD6oZ30Ii3SQKTlhFNK91ok/T1+Vyc+WV9h2F+dXnyNeHq/y9eB7Y6iGFUVJlP4CUxI7+L3i+wfpWcjMJ14ReaQ8iz9Zuqga2RQ8cTWES7X5UzihFJ05NBumkvbMHyid2cMyF8jdDDWU1ePMf4FS3moPqDi/rpia55qq6j7wa+uP4T33PZG5+oqd+SYP9O9uISCH/o9NnJCpCXBfXyakc19kwCj+uUL3HCspO4MS0K37MWgWHnJ7bd14N9FBn5emZqnZFWyMFr6MUG6ac+1C6JUUreV/NoWoDgpwUbr2/efU0GDunAroQ0g0ChA8YLzVb+/JkN5kLwBv4Fd028ivY/m3q77L6PSiHt92P3K9tVdBZj4R6ASgmLdQlWZVK2CZTqVxM8q/BeoAdnU39z827spHG8sJYMAyE3RVhljnMzde4LFIFACBNreUSyCJvwqQ0r8Ubtr4rcAAfq5yZBWq6/V3LW0zTWSNAAdRFhtApis1J6X5jn50gWEsnzbq3/KneP7LekwCKi5aYanqsSYOl1Tvz37/U+N9teocI20kxcv2g5SnfjOKuxq6Wxqcx1jHnUWNOrC7xtNKjq7pCqN4oibQC7G3R0uwUH1hxfA0Qw/hCJZtV6zW45XkQP3ykW0BvBoWGf2cpxZsbcyoZ/Rojlsjc9dugInU8l1XqtYfsgeSPbsJpVPDcGHOoL+zqP3kQu6tJDNeQnpiYa9mYX3AzaBBlCdqTrq5iWKChB+4Nu52R6wD0fBtD19VS3s+eIB5AbyME84fDPKWGHbtzkKivMMiDjkm8XPvnRhB9Aw7bYbhlG+Dcfmt5baW6SBov6fXdfOhPA4OTbiFGxFYgkP1fVK5IFCBoBOf/PWGXTsbtwPU5eDPx89Cddxv50jOVN67JxcXljvVvHC2aizjqGrno8B/hBM6KFT3ezl+XfsAQuujJ7K05yFcDvQrqnKFU5IlNhBR6ErlRc2NlxvsYAuhtEF2iVcxU655ILWw+TZF5duXrKfXPzujqPrFGTjyFSjkFAh/ZTPSIIPDIlghTUZNE3gN7Tg30BNxyhYIQXUjnnGgYjT62HLGvWKCJDC9yuAP5+1rsb0fdeCaPS1Vkg68T3pmX1Rj1QbDopxTs6pVmxVsYHn2d6SoLJt6hU1CZC8hLFJi8gmiiQJPQDRLMlfG/QBL7ymRVjc4okkNNUR1+sH8tsZMdbEoAtNoCPkmVVftHmWOBl3r1tkTVtDmmvH3EhMWxzxIQp9iPwF8htp/hqc3b7AJqcdSixDuuHXEh/ehZQjdPLyB3XUWK+tm8zNn0V8id1WQ5aKCFX+x+U9w+46+P9laKECv78CQW/ZfavqhekEF5dOxsGAy0LHjW+1HfvZy3DuPi8yAQmqGGSYy37D+9RtgNdwjyXH03+co2VaW21h5qypA7UgkqDUYmLZm5LUd0726eorF2FBlrsm/gpVbw/V4NDVv0eEncvMZFf6WDd5gG4WaMhTi167eXssaG5erMsjVdSJlhfOEyKyTjiiDaGbhN2cOh7rTR65Nsn0Vi4QirPYDWwsQ1cX8Eu60YuSEXVC2rwJ0gQ4r+TGI6RHQnwv6YteRfPOL909K0NaraeOmrpX9KLksbiofLKmc0sTxoh2h7FUWwup2ZiOIh9X7drCIWGf9w2pswElejqC+6T9tN951F7gA3zUeXhZDDtoi/MxngKY1Wl54v4GLt9u5pigieIqOPI0Svt6DSTZKCxhG0vrZA95AtrAeEbFhCwuN4PBJoK7CcT0NiUL167VclKO2gMzXvaUi+vjacnK4st6zIkuaI8IqJ9EiRvqPG10wSBB8AtAMbFwvtdcSZoJxF2KgBMQr7cBmka9x+1yRMvHlguG2i2eAL+KwnplojMKU3vlqx0Hv9XfCkq6V/P8S9d7ZVXB9fGE0pw+wPHiX0HYxgO2uIyJG8yLM2cTAAYKme71HGqScypSVoe8Bv6onir0G5535I6wqWwBEJ49bWEC6+fLybDmz8Ss8c5psjpUEsLgbOWsws2vYgO//b0O4d24XIkJL56eIcAGJFd2rt6WqUKj5hzBXLTsYlhbatRoYxc8EOCXQg9PSl6YoutXx2grljUtNP6FmHOczLArV3x9Lctbxrg7/BuQ3JQAuyetE3Dbzu8a11S/BdENYdwYSpzl8Facn77bABBu/Ep62hLNiIeAPuAjFVolGCxpGgXIlUGAJVFORnnX2XcGyLIg5mtzPdRDWvOxBLCmcN7hqr2f7Xvihgl3f2CumjtL28e9NGyo/ACsUczWPnFjJnRH781LXRan0gOO2J/GScU1Zumi9YKpWuhy1+BQug8C+9v5gT3JV0KsdDFKQ+e7MJ5dAoBKngHZW59Pew2vGpqCy/9UuqFrknC6wtgxk6jecgBt2kuxrUug4Wvg6UK3aqAWmOEzfvCkbkmibUoFBhRqiTDv0wBBeXJIxFOZgO8Ii14Wz3uqom+5YFoN5ZMP/8Xwc/0Rs6iWlz3f6xoffY4t9UBKUaWQsdrxgeedVq0zPEV5MLLuChwokVVYYSPufCGRsI70NhZu/kXWBLe6TXfGnJWoFet2MUrPASURmkN3alv7v0BXZiYqvD+viRdQf1Gz91I7itn7l+VgPmjZf2XbCZBMARGmXTzdqGeU4KOynTRbQ6UYeDfgHx2pWvMIfre2CEbtNSp5nvtFkBKPbLo/ZRvPkEfoYf+TwUaxOMln3em6n4JXwGhwDg7AxTUZIJF9RoKmhH7fjxQJAzoQHZ25u2cFvcH+/5DaLnNbb7dEH1ZXimJylayyLjxoy1o3Yr2Jk/z8VoQTjfRCdTkANNgtgOSH9+cJiAzVCPLwOdGJw5rZC4PI924WRptfABvM4iMdWuprFrCGdCzSv/YObyqKegdX7wkJJsXeSIMPn+Q9keBY/d1SeeoBcSaxpvTdC6AMHCTcdyWIVIKDiK5WpDFQ5HkFTGHamQGFye2er86SjpDcO73uwLq9PQWYuBtFaJn9PMkjLEmFGequCUoYidh+LlMtjEKk9pAlR2vm7Of/eyIqApr9UDn9g9Ecp3MNPQCTTW5PyKsPGNhFZQl0DY153RSQiCS7O5AHIfG57gSlcORq2N7fnq9h3267WBe7MTlCG908IxhYwT2nYXi46Qze4CZ0LoYUbekAKQt0ylFbi/luAAYNbwUp7s5cfaHHQY7L8l+4mnF3c9rO+p7fqhLrJzHowWXnRf0K6939Hru5XIWhfkl+Mhz362SpTId/vigOXFq7kxrjzzGkTKP41soJ43qJCiB14KleYHvQLqyRLDq0j/CSjJE7+wU7Eb/0w4TIhDNglA/RlkkVmuN0i5WufK1JZCgqHgOLQegrVqqdAYq5xi1FZHloF1+6SPsE8BAhElGNtW7JMkmnNhY/77UhUDLdXxOLl+zyh+0Hi4VHEWXlk7lkrXJBb3kDhiNcJLgEQ7DRJlK9Aqhqh+6/oWw5nnqTkuYMu+ZcrrA7ZtLae94Y5Xp7ZKHI5Xlxbs3wRSVkd6xRntD/3UfXnS8OoCliKYG1FaveYYHDLzxB5XKFn7Gz/RSYBo2GQhCjuK13svClWJaQauGfIu9OjWeXAeYNoITajatrKvFHa381LGHpI7HJULiQgt0UJz/BHdNd5Z1yUP/f6kkTUWUZCb6euSn1WgcBvh/VnO4hY4dM3XjPtbkHFvY/dCMMqCFe7D1fmp19BqxpeTd3CukLWo5HAUXDGjPLgZp5bPW/qr/131OQr4wcl+Q3qLyal2utMQOJtqdV04unM4Cv/IJ9K+orpJEmQclOlnJHDJZqnePlJUX5G48se64TmZ/OcF1bgWJ9m4iaY3p4VrrqiFCf3KZQQ3GwllWzLustl/ovc/8Mc4O4NuaNEIOLlDDqHH8NxBUWjjN33CuegLvZ7BInOvSmMmcgDUnq2ExboZmLc08qWEfncr4dmgjy0bFQ3uYldhwyva2pzzHQeaYxUb72HftyJAZsk1qNsWmPOkJBKDQaR8vK166a2xJ5JHXmIRSEEsKmLDBeUbGmiePuqwZJPnD3moqpEGjgFTj9bv9fl31e0toR0Oip+lIvfGoTpIuEF1LGhImF6uk2481TUm/N9CtpIODMtzzw+YXXfPBl1YjywqVfnxmzjLIdsOYcTl+L1LRgzXtydkXuON2xFPIQ2v1tSFo35gXjkPSMYo2zNB7f5JSwjqp2oY9mIRb8jpglXLDDd7Q032gw4yrvC9z+CmiMh0P6i6yJc/iZYzPOJV53aGrBSTKwH/PoExtxxYfzu+kKD+BscRg9SIiFajOX+ngm9btuUPBrf8JCQbqqJb/XEOoKffeT8NJ48Asyt3cT0PkGsTk83RFn0WynvzJwvqGJme78vK5D7vYaEXAhHzGAYA6BoysiWPOTaWxqa5F84yX1Qpsd8aNOANZPTl43L50NXbTxNEYagDwv2NtItyo6FE/uKGgj+7yy4bBtC/eKWljyIJPbjhyHRSSwSulHjRTOqRhykn+C9kYdIRTGvQvtqTjCgoDSW8MHAYGWsvrWfHUNT+5qyyY3k6ZQ1P4jhstJMBzqn77oLk6hdgQ0jjWEpsArMHXSmPAT3slvJfuazPsnpDZqGJEjN5tCP8Gqvr0djAJQ10VfVyt6Hu3gFcFhXme8Ghqj3CPlkNAxPu38EBnGgtLUawHn1qhw1Ah7HPmuo4lzOofv7bHz83UqxDWIY6C/Rg3LoCj8IWaJ4R/lJ6pY/jTWKjtRqoccnijjrbU2kP7J3R8tC8hZuAxkmzt3sO4j25m0iSdoISdEoXJd3NsSqN2ZdSpFzkhy7kPSF7aH1zJBN4hhZ59KuyyxHVB15nWhxppilMeswLbjdGtEFbFci2VxG891CiyDNkJuq5XAiv2I2rIOipL0P1/D6HM8BV99N4uuGjh+61P61QUuPgTubm+BxQBWIKM2SdVzNXFRgUCFXLukOILDI63502hSRsEHq+49tzCCUwCk8I4N1OklXkMjmtsgro8ED7LronCODlHcszguoy4672Joabv6ljAhXzTgwcojqS5wdHJZYS/mtLUIDDQrPpsuy9r7jZPqh42GlJirGuOcZNdXAWhziRO9zvS/TO9ehn1xZpJikgQideLcDuPu3dgmS4by4Pj4wEQ/pyWscXujWrm41nm6Zvzq6XplzIlj/dZPFDfiVRjzZpJgTNnOqXiNqz8+hofQG22WBeXJaNfgZOAzWJVVvF+2Kpz/vtAg8CLf2qMhcLusGRv32wwCnqMYsSu2nLF2g9tzHOQjcLRdZV4abfhiGr9F5Mzu4AoiJqvWhBmiRkTh/OGPMIj9IMVsVQDxsFcQ9VvUXqVQufgSPOkDFNcRW7IX6L2dQBA3JWh9JObgy2HDvQbsTipJ1Jio9u6iSTGOH6Rl1uNcylXb92hPjUau8p6DyMqmr9r7kFDyY1Iac4HyhRBkPojAolg3L983ap1v+yRC5pdLd/5vL4ydsKA80egVcaXGYHakBgIpkCeVchS1Binh7V8IvxuyrUNqfMwXkM/N46LHvYt97Fj+loIkOKkg8fN0+86uxNMv1iIYhrndvFoJO6N22r4VlPxERGLF8MQODV/9G2b3uCnlZ8T+6uYWm7STnKBhVdk9XXeF9aEW5qlH31IreFayoNOt3bmyul5GLv9ok8gyCIhJt6NURLOinkMRkNaw/G32HpgBe73l8DbrZnfoP/05L2VrELKYHkS/lwquqb3PnSKMuzp42+VT1DWbZwM+TEMnA9rJ3J9mAL74QjksARmkF3Ukqdu6rSl+5Fa7pLZ4wWCfIXmNHlm7LSOSFnwNOPfNXrVWetETduq33WsNMRXOnoG2L6xtjQxF2pf3Lmzo7ZxEmDuPy5/IHxlkbXQuegZ+6qeuENpLLMwPg5ac3faBCVGID+fto+3yyiHQwikgUjORjqdzIYMDB/mfWkFZAObPnfMzTUsjQNXgRCbwQGFLr83VmjhcO36MQGbaXMqEcxpO6eTXDAKl0VV2JB5W3vZnBzfZgktlSDRASOFmrU30mHZA47R9wUZuKTc5TNPZUctyXWRftPxrKhsGujOlTil4xCIgdqIwm+4EthS3fsyCjmfkAI2tWU5/ILeuWPlpU6qVUSyQKd3/ltsZJOVwEqTJqXScwvE4o/Ia1DL6gmfpCXFjC3eXph8QG1r+Nis74eRasY5gWyeLVdJ4kwLMjvZnHrdUqHjTaZ+j3GDJwGtGTz5pEmcsgF+oe9GGC8TTW1KtoqoeFFG+HiXpr2iXeq96ODF+U+45bqphQvSqjkUfkEKspHuIUfXY0lp0ja/9xU0g3Drjzn5lb88tEmUan7OdadlHZCUndQWXneVSqy+1QMrpzyhB4vW+hwT0Oft8CaZ7EuOP3N1cQ5A/NKChlWhxP/v+z7dNEBTQUoxgMX9Trmrgw0EMKMMElR7LcDqMs9LkeY/hFZDt4pFCNb1kahp0tkX/IDbEW11+6pqlXMA7aNcOl/lp10XiFM6HuZm/nnPtbz3t0GmUI6M/4MJxvYNoFO+P/PeaqbCrx0+kjE+A97XPzu2S3shGFq4pHtPrM/fx1e0Asf+K9LOKNRNQqzvx8fJnUpIqB2XpjvvdPp7C7xCGRIAoIMNDzL0B/UJpSnENnS1VFIa+ro6gU9YAg6SzYvhaSaiLMyxw0q6yjYBzFOV3cP9p2fjxW4ZbaB8gGK5cSfZtx5eh7E6xiFM3B388MEwISWfNHPYF1u2bvqj6uzoGHCZCD4kw+uRJTQhLGTWyU01udzi0q8QgRPfY/E7J3bYK3pbH9Asb4zjNVwtVV4YKxNL9I+8gSY00SQLKYfyZFSM7nmk+tQDPTIMucsQC83Vk2GJeiZyip6L5DaQ90Qw5G+FcC18oiiCsGME6xjFlMoi5uOmjiiHiceK04XAB6TUo35FLvvOiww7X4fd6Kmy9wfOdkG6aH6V61Zb6ulmw3A3T/M+/S2gHmiAZDqjlA3BQknOB6iKWin2C42Uv24F++6eIj8CgODihHKu5GA8jbNJBLwKXxn5aYfCgUgMiONVg8u1izDxyKFxfgHv+O2c2LWviREnCGauREnGnnICcACPTxZDTZte0sl8javrmEAtBX6vtczhM47qQkJ9TNM99GIIUtYJzfrdyRV8i2Z1284TZOOmMRffLOijP4pizt7HYt1CoOI7pzw+nUlIwPbUr0VnVnEGmdmWkDlO1CV+VY1nW1+5EvUpeksmy1NV0/3KqxdtZ2eMeUVlj3ER8KBX+FWYv9UJSYjq02Zcs5kZROn5yk4xWAJebdvPt0pR7OCKsvsgUXYiUQj5TgXlg7lGVrzbGAMumLKdLkh0VImpZuRk6aRnF3LjuUIW4FjxApB+1seRu+jjkXrA0VPcJzOwgnqkQsEX/quzc0ips9oWeIF6dLjwvrnWFpaGAR+kp8IP3OxjKibMhl+hs3aFu53/ydweTbmyGbAT21sNqvVVI2/PQalCIaQugi34f8M7u2apdQx6g+zg2g1u52VVEdMakwGMSDytyqYVUM+/LCwsTpoBjPWfcfNWb+veiWEi7Mt+7zZuT+3VZRfcv3yPHbg+/ATjWU/g3c4+amfHqFUcGGSwQu20O2FXzpOPb8imECKpBfuPMewsS6G8sAKcw43aSduwQ/pH75UZMdH7hRBl8Q6frnY8slcfEz0t89PNAX0wtnPd5IayRAV8C7C8c1QLeDxnYtpE5sIEgEd26cQW+i9nmqOGGEEqq5H+USusdBVEm5pUDlm7HXaUT0P2wZyy6EKG9XZtujwHI/6D2k3sz3KB7kV3nWUOaXDuKEypy25yJxbc7bS5Ni32zGuHfuqejRtjjg9dnqfMp37if5+JZ5yTNu+JdVK77a8/yZx5cI4039mwa0yfI6lNoyUPCJk60Bx+C09sDLwqRCKEuThu4d1m9BeKDY80mkgiSIPr4VbMltf23Ex7exvQeh1d4G6fh0bHQC1XawWu0ItWrc8lIL1BpOS1vyg4ykfMAN/Z37XALAfA+ci2Lc+ML7ANRbhUcGUtwsMqYHXicebACgQ5F8EXdKSF3bO86LB6c+42brm8aVXWVrYgVpWKKvk2Cfydu45CNkoRpu/IG3kBuZcV/zCCIseeOKy8ncQ89cYtMGoUi7k8qHiDXV6kat20EeO259ZMTdo5XG5g5L3zr7Cx0l8DmC1swuLfpDcXYfloF3M75oRzxEfdiCbZxIPgw89W5vyvHDr/Xa8PFS6b6NJVSGHlPAY+qGDAl6o1AeOSiDnKNnano8u941vc1i/wfwX4hQYh/iTwPsGxiwREL6gu5HLqfkrNWXMlLHuj34VxRSU8Q9n2gsmUObDCiz9nABtdJDd+2ezfXfVRoV4F+VJ4rYB8DTfDA1cwW3+vpYlZm6cn2Gdw6evXUkqPC5P9WvzHSqsNqN3kMKvx15TtuGq3oBorE99FQJmysIzUyBGWhXhWMhqDFgs9pln5BEXYyUXmfGVlfY6ALUKkAIZ49CnnnsCWwFuL3la+Nh1ofpVmKB0i1PRkeruI23+sDyf1IgDCCFGBeXGMKAjtnhvq2+zzS93utSkY8zBJM4cr4m1GoXMTjwQ6qrFf63yJUWyyNGO7VKeYFnWsjd/Fa/LnTxTkL8JbbeuBpBOABzVRn95x8lnw++oZUDIehE3we2HLvHylfjiosoIql0eKpDOxphcLtldPe7x8xSoZGiYWehR0zpkOceYXzTcGncW3/tK3zlutbMqUTXqx8n8t87/5w42Ql4Qpo1PoyfP06R/uOcOOg5wsztPeGOqJoVkaoMjLXxgw6CJ+GzHoz62qn8o8zJ014XL5bCFNij7F+JNB5ehSTzUT2lPbdBhl06mWATKfD3+bjMQQHmWUkR2QH5hcb4Q/jkRfbyfyYc1YN5E/NEmCg1Y5Zsslfyqo1P/ARg9Fs3jxechlktGEZ8BYbLmOVAHwEEb7xcJBn7SAHAYEJosakTxa2cbCS0nDYmgiVz/Qr63743fZOQKrK1y75BdZDlxN+DPgTrlKBEAEu1C/ZzFCqOgqLBssOsgOdnffIZI7/BdmOrCi8hhDbwoJAanwFK1TZF5uOh18WwNM9li+x13kKGjtRiGIMDanlHmUXx+6pK5S0eg6I4EOjhU/feg/GyksAjA9YSqIgwhtLkn3lmclw1rpTlMesuGFFzacu4MqsHk31mSOcxc8B7Z5zU7SkahgRgk5KHsK2W+S7MVj7/bwkPs1JbDLNuhcOns4LKvQYZqChoU41eyg8ystpdkqPqc4SGq5QCd/abFg5dMPI92QIeGpk98rZjYXKtyQNEDVW+oDqKdrRDdizXtOPgJJZueLlEvNuqGOs+zP9DTGZ4nnJZoymxojub1cZ9KeCcLd3CaKPtIrqEyRUDKnFK8KCMCY1rhROqGhHfXSiD03A2eYioGDeHVi5HpsTAF41wPpLFOTTj0zJMqYSSENMdzZ2HdbESK3grtjcyRiYL3wWFLqRcZmE+OkghwSER49kVJoYBxA+99vsQwWjy5dTTHHtnq9q/faNxUPWcmxrQzpQ5zfUpq3/9Pc9hVxn5Hti44uy9M+Rf0p0WrKl0w8Ytl+vEUkhJ/MA+xWs1rVjm1/qiMSkLpj/e1girmXcGhACdMzKlM1fwRVT+cOt6WonqgBhm54y0uzXOhngwMAUaxghDALeuq8nUBLDP8fiv0V1P6DViM+BkKpkpF/AhwWFRw0CBpl6J062v/i5mEGn4wyUqGUF5XNN0LX47OrDSJWGH7veYkx6icnCYULSkpK/xb2YL1WQw/A/m98Snr9/NIc7Kpx0hKw0rTEgnq3CxkeM5Y+Xc2ZJzN9oTELOSNTnWrjysFOiEGBPdSHSUbXoFeFdCzoL3cNbTvGHUcimnRrzm4pAhmBnrG4pU9UBN6n7v5s73eK8Aga5FdSDz46TJazCSNXmt6vJmuOf90X9MkCZg51jtt2iQ8OKNr6FuiRqVJAURkwqP1wnl1F81ykjWVqxNfvHjRBeu6cM1Tj4/CY1qVEc0OnCgsIujTn5+hXB5XAkTiHuC1HYWs+tOHHP5jLBHlaRI/Hxb41ip9Ig4FwaAar7bqJmOIlIOqaShQzHZo/+wzmJbjAoIu42GxtZoIImMEXo9mynz6CJlnQ0KxuysVXKmDBSAW1DHK2Fz8Jh2V3lKor9gITEYZAPSLCjP1phWg+ZV1DwGz/ElPdR5s52TI+Kyktj0gcipmetTx55Sws2OLbGTawN/To9ckZGnX/k1Gyfvc3G2y6CUIOzyRxW3K3GPL0J2YZZATfASa6GwPE4SmplE04sb4ORyuV32PLy3a8QF3ptRdTY+me3cNOWpQodwaHtNcmirHaoL561v1C10gGWcRt0RMg3/wyQDjggP5aGj2B4asVhUatORZUVP7EVYd+XKrABlc/8eIzYCW5WoIMQP5c1KwBG7LolFyHbBjNlQOUuet36jl41UWYM97X3zoE1ESrPebgELlgUMsAnGs6q4tsmO8Ax46q3+vesZIXzQn5Wmt2dI71hv+KHlMhlUC1YE94C04l9iUq19UsqWU1kl3xaKsL1mryfbXYfodLjvm8LAf+HA0gGfRC6ilipu4N1Az8O1c7qci8kzp07dw26t4ty7LD2+Lwkfe2+ZhdRD+ovaxpmvTCqS75oCB8cWZB0gQ5w1vsOlbDvQsXN9QlnJgCCGyIA94IVohhMoLa0uVj3tJ2vs8vIzA4GNCB2039O/AGa4cM0NRZ47obufagcs/Uy08lkSvUblgE2oltJLnve2aPTWkwPQ+7KaUXOla5Xnyz7gGmzvPvlO/iOPVmsO4jpn/4K8+/Pez4nkH2ktEu8YRp1hjJKt90CUjuJuYzlz9kl/93eeMu/aM84Omz9eY8brw7pekZ1ZHV+K7Lw3tyH39tDbf4st/onitCBbRIA2lS23J8DzE1pu5l4aLyl1rfp3jdOYQPAj86ATqibUl+pHxDWbqLUVb/3n58Hxpicu8QerQ6qTu0c15L3IMYxErYms8ZM0PDAyJvQwYCdx1dJECde6eoo90dApcuy5FOQw0cfFN2XccNOeJ0QYw8gchhkguV1PCPNyWUI7IFaVp+nDfIT/++Q0w5dY96CWqKGYqJC/3yj/urdj4Iy4gqm8rPCjZwxv84zgu+B/HzL6UEbYu2gWxGJ+bY8aSRdEqqC2NihavYJ8ec7ElyOm3RQvwxrqOKoijcGaR0XPtQ/Two7cRjvDdlzkUp9jpJZkoIcQE/DsSJ9PEXwYUkG7oVRRl0c5gFoILx1xOwu4walJlHqxA0TTqIi+uCaYMKrmX+QnfdQZysOJeKJy+2scTCR+tLPDU/+pK1br67HdTET9B3CSZJs/jOxZi6utMiviJHWc3+XdtKkz35IJ4lqlzyXU5r+DjUMk8AuZiWXWyGfy8qKr5XVL5jzy/IDKbgJVA3nRUEhTM6bYDTbUK+XGVsVVrGdy2iIJB4pwfwz62+L0iZclVpKutvZit/YHhMy5IN7MVmkQcdaXTTer4XpswyyUlZMSyJqsBONmSIzDnoMRYnkUKJS7Tx+69WAFuPXeB6N7wXvPdgNgI5avyT65lz75M6/iu29hmq2C0NTamXX6s+gjN4Uyzx2GMW2+vJfz+3NqchpEjCpf+A91w62g24Kn155OcrKQ3WaIpTFxQcvNECKZBOXmjHLIanaNOMfmxHsXQz1wq7iUQQ+7/atvP9Oxc52eFDA9iuVxnw97SOrPK54vecbZDq3LuizIOvXUwV/YBliEgQZoWu8cYW1sR3sLxmaRsy1VejhapXs/YV1ivWQe3DbZL56Rh0yo3m7LhADQL4EP9Hlo7ZBB7FfmH7n4FRzf6Qqe2b5jhR3Xi/hoQ+4qLiLmD6LBozkPl/yeiWO/B3eNE7AGio38rfhdRLUhNjdVVs9EMSgsTtfpZufuXacSyhYtjxSWY40zDBcqf91WN/OzQMATyqseskhQBWrm031/F2Y23Hsm+ofgIi+YMVPMHz8emjrf7lE4j7XV8SYi5lGjvZdrviwtwUTc2mV2h/hClx0lKdnQAE/MiLktJOrwu0j5GM5eUXKqeXVBqXX1uls7s216dh6XyPG+lBeP+sfLZk6CirHRUf4e4c5hsEgnOC42lmixlf8R+dlyLFTLO7RqsL16/d0aksjnbIwEL+/JW7EbMMV2MMhS2/HuvIVa6oKL0DudCFayZbjMekdGvsv+d+QyO/eKdEHvO8rDp+I8EizAQISKJa4CsG+BzaSA0wOvjKbhWsoEl2+J24Zhdykv8Jxd2+twGKSVDF4MUl+T/yY/V6vDULXah+hUf8HQgBGtZXzFLaNMd72LasgyPmRf/5LyH2XODFLIsGJclyb39OSsFfS6y9DvyYPoTZme0sVNlC+XKnjWEPSdU5o7M2XxXKgjsdZxzYlNFIba8t1ftWVElpwPP2M/sqgV9JgOoyDO1iUOYMVAPpot+DdQ2WDvLei8/vvBFY9c3xQxeg5M4iHMwhro/xSxuM3IT8Q6ymthW5UWcbp31qlI84milNtLZEgvxAdDFILb2lP9/DYzSwBYIeLLUCg9DHOmYqIvH0NAdPBfzuYI4XpujW5AWKmt4s1iMyh/XXPTu2dUH1hH1VmBG9wiqZmij+gM8uWmc1L3aVCoSZfbbdncbrPBvkGhwLbFqzON40YMW0tlhRin6Z4lElefbD7tDbaWvJ3N130d+S+rT6EYCiZVHOSLCP3RpaxgjX97A9MxF5bsfhNRKPo3mh5335XOEkD48ejvaAC1MIII4oLrcTyw1DTCB3dkVkoF1kzuU2FHRrZfF5bAelKRj+htlWmsc+3PA5K0bAQXwjeIweRgWUlfOzmNqtThKxLdrn9LU6mUgPsmEQ2nXIeTMUx5KuPX8vQOdnOWERkC5Q5FuRyWzmh8LYJeJjmrd5vfYbf6qYttNjnsogOSEj77FJU5Z2PKhDdWuZxY2y8dtocLXVbygjptDpTvDameELLragQHN/HCz6JOHViKBIdv2jv2Vt3O3k4x94+OQCoqYB0jKXbI+v9muUjsUTBLSg3RSwmzxr/iNXxBJx4TISOMWXY71Lm/1imyZJHeetWfVTgvyue94ZRFXN7yRU64qrF73CongVqxL+C08V79YdlnfdSOz0lsjQ2jbG+8K1Ue87MyaUn/CCweqSusDTBgPnpwHGX9IocWSQZkCVQtJW8zaD8cHbQu9tnHUS0ww4P71Orogh70FrLkLH3X8iXDYWYOxuPS434xZz32ofODnJHqVpuDsbU5UJaFJKytj39WUsjxwnc/O09bl7aQw3UThM5LulO4o8uHwVw0oKwA3CzMAVO6VzYW6yUH8NY1tS3iTHBi1Gwyvg5jdJTDueSvYsetF5zujcSwdcho0DlRYgdFwI8GUAom2h1w/3Hs71ChInFi7UtK6M8fnG9P+ZB2Wqe/Mg8RO4WelAjFMqn1xthGm2rf5/KWLBcCO2BJtVTY9I0CJ5vCpkLOctJGfO7tqhdhRB93UE885M3KyKXfOUzqbylb3gzmOkqlOjJpe+TTPowTOHNUpvfURQgQDaNvGQRFLHlVsk7X43YcjQkS+LeSwlQ7CsFtzPzrN4GjEzE+HmDI3pWFJv+todvuaMfY+Q3cHZ5TshD/bNgHKPUGQJrZb56HnI1xTXbewVvcEqS+56xsoApha3TJ6wh4BdgcgUUQiIvEinGqtlMPdNglFKNHqmw7GmA+3ZjCxdRlckfV45Vu90yJMGIfE0aSGNq784bMzwxVa3FBRH0HHuSz0hWxQHOXX7S14X2+sr1D/AlzSYe85zQpqR+/udYPaEdLMWb6VqC9pcyQNr6s3yGeBcYB0AX41fzUPn2PkJ1ByuXZldwwWkxRymS/aEOYmJYp69atSkOynxaMsPU30L21xRIlR7YkYKlQb7SBkwiAOav2NtQeuAqFMj2gt/WRZIYrEReI8sHaVFiBRzIA3YRF6JrlDtjv9KKmrM9DlfYnGI0aY+6WFM68KPk7iqc73FJcTPqfMLeKsNIWohJesNh5reD8GhddykRLo9eA80vdcOdM/dgqJlqclnq338Uk7rxKqXOtfDgcUUEZOupbjSzHmbzBh4LeMwmFH68E3meTEgF6EoPUYKKwmH7ZHj0qyqWJDvJ+bkWCUG3bB/7Vaz96c+2nr8XxCKzcfge31t0DyQfPz6a5VxciaLiQE+ybns96bj2exh8KlZDWuKCv2xzJEIh2pxOXDGqHpiii764E8SziFkdoIzKgM+BRzgWcQD4F0CzKZ3okOKv+btFM2NaJKt4OUF+KLAcKi6hhf1hb20NkxGbNHEZdRZO54UghJhYc+Tt0quZt83e8moK+KUfnupr29WgOO5exGvJutImUIaprX01ZkAuaOlnaf46Wme5NRW4Q6C6fEqaR/0FDzzfAiu3K5FVr8aqZ5XaU8OEuSh10wqHaLoNnYQo2kC+/Zyf75Aykue9JwgyT++5bqJeFyIYBWC+12KiViaRMHp+VjUHFRtqcumHS5C9iT7EwXXHJvtrjwAoAQCslDKF+W8ykoGqpUS0QE+RmubZuPWgL8mNpZgmZ5OLwXc4i91gtmXu7+rleJTVoSr/wGOiOEKu83DJ0w5/kAF14T4lvIoooehCbezAT1EtCNmUaPiKSdFMPAQAG8smsMo4+UyL5WFl/rWn/YDrgyu0SPClw2akdkRB1Lw8RICiokBzvYcx61ZDYF89PK3gZ53ocncKTute1WJQhg3bpJj5s4xQ1L/CpIf1Zk4pekKB/YdiEXLdpYzbDON+ChTkow1Q8i8MNDWaLF6KXHJ2FQ+/dmFRWPInefu37w7Vz4SKPo87tqsvQtPi3kDUByEozLSMgU+YNK0evGENzmhFzj2uTxFjv54m3+6ir0uUFIPZic1OUcrXxfNEQVFyBmRYCcmJshJQYgkpfBYLvBHkxmA4YMZaPCoiOP/CuLvKqDxvgQSkNPXXAcjB6C0/ihmqGO9PZEaYrSAkE+E5Ime8ilT5hc8vEgN/zaRZRIpWwKIvNzjarQRTExgxBhTxLXipv4JZ2lftB267OTWXo6CFc/PSdO91OMyHhIT2HwWOPd/3nH9r4V/bIjtBRgOjijp1ADrb6h1pyY3l//+m6OnidvB7JZsP982m6znBuIL/GgfaB5uW65a8A6DOJXauBtNTu2d0O5KegQ+o+1xTRH1dVyIffgz/TJztiWFCfVTXqkPMMRFINwXiT3ZBtl2gUcvYlmi+ROAuW4kZnL6lsmu52VhDTvmrkH6wKaLnRRIf5VovxDwn3F45GhyzBSKrfYNWAUB/YLkxj9qxiDulRrtWs5jJHYRaVPqjNLmg+kyaqF8B6oj0kuv/yH7rm7hjdNsNO3w+FV5WWckRQyK5kpWoqsIvyYIMG89ZCx9r/c779fBdBwfzFb6V11sRu2jnAu2vMF7O6F391AhOUI6h2S6HFbjTyHC64iI5wviyzkyhPAr70W/aRZQMekJOdUIKcinXXy6h+HQnVvK71WPGk5CEMMlj6DvGBojh93twuCVNh2fJ0dit1hJc5XJrJme+j9cAzCk86J4Dza3BqSkNL0ypnnvFGOQ6nhXK3B4mHlub3UIlVXzlwgyXlWOITzIJrhRhQkkqG//Y7WUxGdOe6oQGZu26B5FsW0M5QvKvfOCpiPcebCPG8KZ6KVK8R0hl69auclC71TOyROTlMhcf7zBmprNchpz9kRGAjeP8I13uteZqto3m9lu1lJO9NODZ9Av7CpF31l6PhA3xHws9YFLL1aRsAN4sxc+gVNL1+PN9RPzgWiJflu7bCewevbAm+r66t9rKazjq1kvU/8VWK9Rg3GpEAcZaDEJdDfu6PdMbuF2LolPOILphxJrFhiFOx+3XquqAI3r5GkKm2MXWf1MacT00vOICqH8lzzsNFA9oNkLpi6lWlNt6IioUfSOju+NINYht4M0aiJmM4+ymps5Hjb7wuVfFMCf8xns1FCBBGRqquH9pqg9i+KwB7l+4slqmnw4PtOoqpf5WLmmzqXKIy2E33W5a38ywK47fUu4OYMMD/GNd/hCGjc3NC4chbhpMkURSQu0DgKFkhrc1KPyXPrvAJZiR8YDcqelpww+588C6Fq94LH8JBEqdEdtrls1qabtrQdBCkoXtu1LccN4XSJPFgBP5ka+gQxMUOFlMIj7h45b7GOOKUmYhSVFOMxw/9tmJevipBi9DPBG9nd+m8fDK6PJwFE3Ko6niZGv8FskhxL4Efg6mC1QrG5v2NRla5ftsskH9yJnYZef26kHEr3rvEtpZlngeiEFXCy3GfW12U80XCvvQEVig/bI6A148A1JeSLTyIxnFgBu1wnVu9leWIs8U0nkOpsRABOOBlYMARqgFKPJW8jfBji0Sv4PsXRxylF7b8Ynz2/UiLESd2yzkRlcqdEtJXogi5W4PlZaP7Cw4dQEWHby6HAwBm9xSQEd9rNh5yR7mgdiaiYQXqXDogRFWPAT2OP6htC3LEiNOs98UIUmCYOt8+Lvq72Be2GDTGHwd+XFJOqdbyXwzLL9DmvAM4VP/jOwpICrCzwHHEQeQoD2sc2MjB11x4URKHg3orTiLiR17omQELizA7sGOKvYuw1JIe6fKVYjuhvlXzbBxrUMCopvupY3rnNVSZM8M5VvHXUn1y2182q1QeeuTbqF/9TYO7zESjpm4P7YssYzxyWPePhU5RJFWz3XqMg/zMAb4OJPhWwrGYnAsrNL3qDELw4sCDFrUS4/wUwcioHZpQBDhzyX22jbbMJowzOXIDPZAVMHx78TEmfor7vsJ2IPhrqJr29W4hCtmkjDXucM4aFFNpdaeQh3oClNnuCIPtPMu8iKKCJqRJG1CfOY5MBa/g6g6PASWNoyp7wHFkapzj9k+Ngn5pByDRJLtfDkSoyvdMHg1a3EvAtMGMvSgWe9Fsjw/x0cZgxU/eFzjo2Vdwdv+xWE0HODl8G4yk/33OALZaXbXz3K3kcK7pthXoyoCLOzRSmVVTIlPwNpmLl+D16PnDqo8AfhSqgJYOY5chX6tGeahaOWIHsAi3Fphzq70v3SBoq1opHH4iovyxkTAUyCO5H1PU06Y8EoKuGgioC826CV94N+J38ZWY53TfgqMjOIyNYfHyAoMXhaiKu3uy8iibsi/vMFTl7L5Ayq6vSBhbWOnYx1XhgfG2Pih8Nh2DhyWjifIdE7Hp67lJn+iKjlvR9vW3jq29G7DPf0DqNQAxSvXVo0MdK/HKBcaHtPesbog8DWXJt48FSvEhKU8ojZmkaTfTsrF+QGebrdn0K9KYrQ37jAKy3V6UZjuzD7lbyehGeCdoCmnV33ptSZYKUsIxVwkEzE/M7QYBC4JGE10W6TS1NV5uEj4lVNOjNAKGNY5nuG1SulJLFVSy/jhm0EwUZlSuKW8Kn0sM3x8KuGfk1ob2yWUOZNnB7cSVEENWTHwCV+wwgjaEq1JY5apSHps+XJgYRpaKga6yhZCAFJLNnAJodZsDI8jpRRIBoIN0wV6463hcNwDhQUlBeYMsxO6XYfXRDGdTMlbAyf1l5DaRx5qQD43tt4adBHy4rDGZfewbzJWsMC9d6f9PUk18fxwV5Nn3kskdKl7NRnpJ8DrZ7Q8jP/q7yehv7ysClV7wK6SA/zL+qayKmHWBpyTgP+y7hEgCvPW4Cjt/o/B0YktmigtPCwfWTRzTQcjCZLwiDOnfLbn9Sws/sOrpjNBJTG8/lyb8yWxoKwvT6iKcnftBSAWFZgNoS7KsAH8ovKOKAVhsq9qYZOSVYVCZTMYmSFfWTaaOj5V3Kc4A6hxHxshwHwaTCyvwwZyJNsM2QHDU75CkpT8OU3K6K4+NEAw8Xn9UES8+MnTIDIM1goglX3FzYegmyphztq1clA4gb88pXLVBVOHexPhnU0mozl+ED3XwJeXgco8g8vkY3/7G6JfRLb+bv+X7yLFYwxTZLpXUSGVi51NPEN/3ewQvgsj4dMGN5ueBjwOZfJsuiwBpoZBJv+sVLLPrCGz8EyablMhbY07IyAy0BTceYuO2pUkiPWayMx4dg98MVMKx/CcORRDDTAxlxo0chAq1BXQL5cTMFhLsq/uxKbxohlX7EF9GdsleQTZf+hrekOKMrePnYl6clXVfwgypxKwHgV92FSer0GJ1zwemh1rg24ehRWboCnlkGTdlvlAsLOABwYx6SZRWBLfGWgxYTfYexibFw4gWoP1q+6bjLvcU/dkVpCT40HeRGv0Mz4koy+t9zzcHQdjy6HbSSRB+rrguMcPtLdtIq4PSlO4aw9pXSMqqeGGaFQ9gVdB7KOfKAk8XIhL1IqPgIz5iir/iDw29ZozpBi3xZs4EYWuSbMahaixhsoey5aABjZGQhCs0l6wuauPmWAMpaZG9pfS3R18ED5VkQ3pmNoG7DeDinZA5XMgqaNRkIYTUhgVIVgsRM6X2SWPyJAsUcBt/Lhl9mYegVt292SlcNVkkFs7cSgHfbyAR1e8X+kpQATq+G0EuhXVIp/D7zyLMtfDjQCjhTI6GDtiCH17oQSBuFVaEm26zVRgs8yMFuu3jYwKUJZ54Uu7mZN9DZ28M9FyzLtLnHPDJZmPi10GBr+KO6ubGMYzzfWbK/7lstQEykShZnqL/ttvSNxFuwIMdfsfEWHDFCQ50DVE2hrmOkL/u23Ywi1ONRXj+nWW5heDx/u40ypx+cOy4SrcC7vgget4dOJr8MRVMrDznkq9qvf5LB4f0mzQfQksvHE0gPLszB/aem/NJogO2LKdPfD8V3d/6EwO5JeSzzNgMI+tN+CIEdmgIsqF0/x4wgOcldy7+eecV+DF7DheHxH/pJpAzBLz7/I4BVQV/hSboRRXN5iL5rJ3iV9algY7WgymtCzpGr8Hk9hgHPu4D9kUQaLW77fekgtj7sm0aU+yCnbHyhyQj9qwZVbUmrd5C7eekHIljeGQsFfjgxih2CYEkvsZsZDxKBcLjtsIk7XasxKYbOMqULFiPqkIkSWb/GbsAd2ymaRUeo6a6r+/XCM4jG0fHQPvnh1IADPxCptAmrVFWwHFdPkfrfD71PeLCnk9CXqPwkLOjhtwBLyc2ntT/oKa/nSC1Kcg1ZCX0W0xbFD31DCc6y2iYrJ92Vy/nMT/MY2+sPJ4JwLAdYIqu3VuTenQNjEVFYNEzowMi1wqTC9pcLr7h0A/d+whIUn0GZz69Mgpe93vKQkfi/0D3QoKcNDodIa/SCrtp5mp90QnpmNPNsQMYCnJb3GBS1mK+Z8JTgFP67YL1CWYDqNqcMx8LMApgLsIDcg0KeU6CJSqDAd9lDW8qYKGx1is9aitij2WGJf25LFR0gK/+AesC4Dt1lEPLoIFxX9CdiQn5vH5DmKLPb+sVuA/rUVjTAjXTjQFnkavEPxbDn+k5resMU8ImgfA1GbMRhbprTm8DCxW3W+KAJUqW/Nx+dgNcypukFd2OuwX4sAXhqKsebW09gyblR0nvgLC1eXBenjKHXhBd2fV3HeRATUFVlk6K4YZ88WRSv/zECDaBXiS5yj5UVHqkmXjA64eGWjUHWuQd3IksZLo2mxkOTo0IicyOdrjpeuita7HcyA3820EQGNrUTN+AawdOLe6LrVqOnpliDelnHGRKqItPDLqkt91mDRB+8AucaAn6qL99Rk1PSaxAKBQw1WvMgLw26d9e2WKJLQJK/669nXW8aiRXy1gBOqpHKF/aWjxG0slhWeapWbSDVtJp8XgRDcecCtGlQVZu50Jmy4Ddfsq2Hegk9hqMGoSAm1hpYE02TUbKNOJVKDwHE11VGxVlwHdpsgaOZnCiK/wNbpGme1cqhkn8AlIb/mHgCf9zMee3DGM7Zla+1yzBcktwa8EO5qy/EvDcnPDi7j78g3eItH7/Mn2nk/juuHpn7RWojId3LNmP+AwQG5bmKTiqqkkibAADq6oFD2EyKkUfHyCWf1bMWL5cfs0UTdFHaIELEkYVW35V91zRtDCU4ffBHiv9AgDm7wTEj63SLHMNGcPATyPtCUVBeEKBqqAC3oD3e8vt2Iwwgtw/SnnZ7BWqKt/7wR/DOaePH6mXtELMCfgZhcxYG+uu7MiZQm+fKV6l8+V/gJw/Rc/VN2QLN8rm4Cdulw8eaIMY4PKiwk4vHZw+YgjYGq4h8c10/n1OIfhw0/iA1OlisBSRdLYyrJrWZK6n6flAInV41+IjUFNcgv6wx5mnI1VbBHNuoMz1HacPM2FL16GluBgiMeq6yf4k69i0DBdJ0dpA8qDrqf1GMWkdbDXWlEHGUHUguqAV8eaVkEAiNL0HUjCB4GA85UDtxFyAStYampO9aJHqZy1aLdw5pqIm5IMTqPNY2Gx9IFHmtAMOaYIfFU6SS/ab3XJjWJFKjT8zKpGXowwnI4XH4KTWdX8vFflN3Qvqg7dCklvxtm0QLgda2+X0P0susVib2r2khxIjATjcXe5fesgC1RJuJZ1EUVGXmXGTp1J4QVUJnhIhrgs7IHMqafbhJBGtUlp0M98NIdokVB+r4CCRf7zDdYCnt9tmJ39mMbRicynfHI0XRi9jwW7clEuJO7puMXq0LYyctviNcR0NwqqtnZbuWfnanUUV83U0u/z1Us14O0juspzeIvDKdkfk/1RFgnkBgi7ZBqPo/cWHgUKXkNobXHiRvoYEXlKbLOnjJFCFe1B4MGahhXD/WbYqVl4zKnGsNa/mId+fT81E6TqWrfAugVaxazjmf93icHU8NxTysjFiGTihFhkQSD5hBWx8oLOkBed0zE4Y9nTkpIRf5Dwkj+Dg1ezq5PtajiJFsPHX1nB9Pf9JQyduFiztjSJnu0DdvIYr/JYQHbZcbMFllUayd+DBsEf3Ov87eeMxMQUXFvo/MsyMvcHOmJQrxAtzhjdzXo8fUd0mU3b8saKXE/34sY/x+iro9NFZ5ejJiZLaY3jOlxfpeBIovANynQfAcej6B11kzIC3PsaaHq5odjK9YZuQbixl66A3p2DnpVlO6WJZB8unP6NAJvfjOUpKAdKBuz649Bp+N96qDThu3rjPXrWZbEQk9FcxXKluReT9uxnmq6UICK7SxVduOP7KGN2Q2D53H74Cw2D6Xxu4yXOFMDkXVHqmYG0SK3uS3UCNMOkVrUkGA9KfCAItjyhCTtH16V50SCLHPV/TrSWeOXMs+BOUN+PpstWjiFCN9IWazQ3TbYailnxfa6/Ne+wXUcK6lrWsjPwxvMZj2yvHr3P/6Qexwu4eHAYI8sHz9QYERDvkD7kh12eIKzM3IA9f0Wb/Q/tgfKNf2R+z/1HV7B7CjcfotecpzBmBrFQPfwb6Rff8p3jfUp42itiAeZz1M7l7AzqAqgRwa/+y95h8sXiuQtOcMhfLlImnl0hqYk/fy8JriIQ2QrkhU0ZmKIjx8siGa2Bg6AftZ8Gs8G7jyzVzPlOLk0wGD5t4tv/R5bpmTZYNCbFga0tV7tWAzLUcMb7VLWzcWGVwtR6BKW7YvR5XBlWQ/2TOZLXABj8SjlYj8mdZE/XW1nsGWH/qE3BavkTfU0BkDXlqwMf171uD8Wux3UJbPg5cTGJ/ilGo/ZwqmNzbqU2n6P2VzLb61GnmHuaLpMt/4maKDnW1RvDAUir4fwGxgciASGTNNBZbj8BzWnwyJdENypob1anhUxeBY7+pLZg6xyyPR6HxkxAMcq85tZ8BV2L3DwkSfh3DZXHFR6CxeUhcqRkMvLIJ313Xy7HRfKRRqW55m5GMMHR6rKoesorS9ccZfZbRLJOfwhfrbSeNsJx1du7CvLIcIpJ8z+dKOvLoA+UvD4KmnEb4cTnrTdmWup+nlruGPDD6vD6wW/9EWAsQqw/cHy/7ArKsHEL6rFEctAtbLkkk1bFuINqKmOFHW5xV8tWSgftx7E4CTujJvF7dyIwb5QwHqz5EXVHsl9p+DhhbQTlsf1O5a+PsBFsKUOQ8xKOwb9U0/7KXRTiwwKMn2gn9JWNc/yQXjFT/VtVebUvPT7RGLSYH5LzSf5B2LuWPH4TnRxPd0otE224vSWskaVRk3AUKY+azpFG0HzVcacYH7yI5IRXA6ST4B9XjeuKwT2azwslEgZ4BQiyHA9sVC9up+OcTPZd+/tCGguufmrRg/2DbATE7clIRiseJK+OsbIi6XlLoG2WWcOvT1rfc1IEOJccYEZ95XP8HWRn6jzm8asofOndprmvc7vqMyooRZcTVOVzuIsQhERVsserAxcOBrESqfPCMJF8x4h6ktUnClD79X9r+X3moyNsMuW1XC9J1ASWYMaH1TxKeXJJ49YQzgyfilKDZVckcjcK4NrKc7dqh8iLpPYpKqhhLRs6mVML5T9zhqOlCMdoSqha3iPkRUTr7lTDfwnTbNetHJJlsY2+hnMhYsEiSu9NChX0xgTui7F5CJHjp9zo0tVlzkpZms52nompJ8oESi7ibWYnKblFfmrrCHCF3zufvKmSQrl1fMsuQtKqnZNmUtqKFGzd2SOAjmiOgJniKv9+MMmBhvW/wcjlWiX4BBDRZIj7Ft0eJLaZSUKRrXzChb8n6THfGuJDJgL7PKocqQLsCoSStxbEcymiPpXlto0sZPpa2yhV0+XTkKEGJsgsZUlszgl9ll2SdOrLY2mSPDBm9VQ1zpcSRw9uXhXhMhulQQ4XAVUsORHCkaxgPOzsFql4GuRaH2hS6pZI8N9+WnXpeOIEA2Pw0zNn5HDwtOEsbjHHivvphhZi3JyKm6sgyFc1b4S0OkaUWtc00RxuGnivBuFmw1FKDba3ZZcfkz4uQEIBkJxY6fkJtaFX+6B8GQaU7zXLNkxua1iSGiRj5YnFlSddyIDeiLRNSAhglc61gnwsgnH8InkGkQwP1gKZsmdH0jihKnC6ili6FdB2L7vBMNitnb+XAvatBiJk8yXfPiKlP6LEg/kIU8eLiGoj67OPSC7+7hxm7a+TQf/6Q3xPnGIh8abKVnfBOWcqCpeI6pnZ5SmzvH0ToTADH0ghCkWlTQYa0LWrbiPaJysYeNQJPVLLc1Rdt1qozcBcIFgo3mOF8+UbUA95tmVVzGOkfbs6FZE+n2dYdEEoMY8M7f9Vym3alFCsAhBvGOtbbA9JWclOZM1uxlfdujGcpUDvYSjfvxnNAcllBkeUjNubyEMjZBA7C5wlL2ej5JNRKV+95OoARn2OMjAvh4oAPO0yj3BO8+xCvwF3d7gkzO8Fz1fGcjtgpEZDpF5zaA2H8EFCBBs4JLm+zWOkn/YYvLWVSYC5ZuJqNVkM0TblYAWMreTEuzvVhovlnhQsPoG53QBniqLHqnAqqF98z+dx02mNm14dNRJLTTd5XtEcxIavj3vcaCfAOH+s3ye2p0RrfMJXqTCMZ1KfexYj3z/tKrD81S4lqx/n5HNTi9CmB4FiJMnHR338vSFjaIPQe1uT1tkx6vE1h8ZTT7jPIP+tUX/YFPCsmNg46wGAG7l98PmA7F7ocxuZr5/kHooUjcpzjtXFdXg0OokicS52YmvwigpIeBiaukMhpbP6PLRO1GUv1kiLRUa4MjHRcnmMWGeKeslZvIMDBnRfbxR2OpsUY7zZ/K/ul5MlxgqlhGw7p+e0iWO1qlOJgLxYnQ8HOrFl52uFxjyIvdIG5u1JANhMgmAIJOuoFSFnXk5i3lKgLpbfZYhFpeCg/rXfjKbF3a44+PXIwzk1kw8p9oGqeqrJCaEGtc04aMmfB874WFPR89SVri4V/r5Wue6SXX15bkivm5rXxWSkN5z1UXkYRTEkjkwYzN8soFxFGFOZfZiOAXF/tcw8kAjmyROf28H/alYiY2sMedVklecUxXhUfIEoHjUKPfBdGiSOroM2aVo8JCPtImmT1tDUf0q6d8ia2INOjkIzacvjC3qhS3hyJkiw75tm4L1QR/cb9cyNmXkns32TKu5/6tTjNi6JC64Ew2dg/yecfpyqLCCK7D/C7VDlfg/WehzqY8Oe6GP8sxOLkx9klh5EG9mF9H3+MnvyrVch9Ox22KY7cABp819fAjSm7uGuaSucCKFRqtzCbxpEG95Erk1Vb/5gpdjnHGPZGw7F9eMfNtqdjuiY2gvA4zaGeRsLUJM2pwcNFqY1shEdraohJ66upGJF1EykQaZ9QmBNBG4DCDZFrxAv+G/USDtbrU4Z3F8RuygujZytZoRz2JogJcbzDC0k5LJP6awAm5yERdR1QJDKxjB6fN6TxyCacoybovG0Bp1km0Xmko4KTGVfhp7gNsVnr6Wk9uCW+OLdtFaIaM1cFtPA+2m7c2Bsa7QbKJoAemaFJeG5ECTLNxnnS0DUp4vCvgtxVbj42x27rplRiC4/HD1nG6F/cIcGMtb4Qrx27bHJaUHx3+HfKGKBIUSwBAGbIeAZcX5Wx6mVL50v518UnCFT9/NMDcoS3Wqf/usRxv2SivKgtJHYSygCS+8UsHsLblNFrtNTu6LXwMr4s4b6Z3ZaunloQRg3wsCHiMhAc6N+tVH9JDpMwYAJfGggzsIDYcZX2J6iVPryv+uTiQERvbh8JvYf3o/AcUmcYELdisZLY02zsMg0IsBzPj+PSS0gddYvQ2Pf2OltdgodOeXTjBw/PyJ3l9eN5rzDH/1c81hxmWo9V1xlJynz4A2V5R9jCTSa4Vaw7F/JSiqIdotsvjNRTzLvR4aYCb9PbKf56EA7nuXD2OTgwVfk2seQbUGGTh6FFr+hVg4fYM7jtZNUMOBsGJ0eVtbD5cazQMacEChQmNLPYRv0W1ewa4Rh9Q/gNu4LE5r+vLskih8nSBzgpWNCMfHqMe7mrQzJ5mJPZOcAAzNEXjfqXH2XHa4E0rUBb/t/eOgajmiKWc6bwfsX7/TSQwsB9JYPepZOw1DeD+rMIXSXYpL5h8CIeo9g7+PYEShPEMTTYtR7uuycg0fk07xH5d3UPla4OAvgmmcBojslp9nsKxOLYFZIVwE7tP4lKPVV4Hf+JooMGhBoLntU9KgoiDdWwxTcVB1ef9IRvEV0zjg/FPdYoZpD8YT/LFFqDyVbaArZVeZQA1LjW2QIwdTowoOp+R7GxByA1Yc4BfWzzyALVDdibL9TRdWP4bygYPUG2HTrC6lcQfHmHygZIdtOstnk7awmZBbHUCF8IJ/JSLUdnrSttp5jgtOP5EgyUZxeXqqPfacyNJ7crxLFQ3l/lKEfBWvItqzbjvkzJE8l8tOlru3pGeLAAgN1/lYSScCyFIQcnmms1irvPF6jh5f9b6U+bLvsI/BsE1tySo0RWy0Oc50ZeNVgiayar7KOUNlT0gcDAW63VZFRahmvdFaZoAUn8mC5MmCgwtNp89ahrL4i2EMZfBGXopovAj3m/z+pygA1pI8r9qhDPTjoZaaqt9zJDIvAPJH69+slpoyaTFHppIapltM7LxKwNloJ2uyUmPuAf/zB7GJXOj7HTZKJLbtmJuzCMyEOqbfa39loAOPtffIUSxSyvxQ5/mx2g9HG9wmA03Hf4HL+lvIIYVQdgoW8hBgePDaJky/PJ500jGFi/lU6bcZSjsR7ePQecr7LQ4I6RoBdKjoY8jYRgBxYDl2oCSsN/cySGi/il34uijfYFi4oQBHcfZz3nYBArl9fC2qAbYSeFYag0nX8jj07eKzhmnntz7CvppNgRE905jL9wZBRTArxI/IxPXP5QOCmrZRqTr+pA2GCbyfUw4FW6RTFZ8Nri3XnjwjtTPRWeUEKzuyrPmaYB9q4YB5LxXO+T/6sCgde1ECD7murLxKucHCZykVlUJrS4mgUT9J84Bf1sYJihQzQPRhWTxvoSQwvCj77Pf65wlgS/KrTDHMoOiD0wyw+pGr77Hvv1O1XW5YVVpPqx90IHPTMAm97BAe1D4dSM7blAL01d9Gdbash6GtJA43PC8ngjJ8HM7/MWH+Aj1a7i5QBxuh2I7gdy0yYiEgYQV33+6am27fXlsk0erqQe5VuO8JF1pgHQGe9uTezArscK1ulpjqe52V0Gf7F+S5MXh7k+4mJ/UE60h3Nm9jEoAmm6VNi8cTdSfh3JCLaXYT8QM4CGR9YjEyZERVxZjw1sG+IbFeXqxYBv++x7COZL55SCAL68a5qXgdkCLG4K1tcTt5fvwYgEZJExysOe0PbI7DBEIJyA90CKsB64eYq86ck7i7BJkaR6i7mEF4UjPWmUHzRcV6MapVz1SI1tmuK6AoDHBTVnkbRFDGkm9uRzcAdQMYxpECftDjf+VAI/Ro4lBuZD84SiVjhi0IJIi+3DWVzAwn+qTMj2Z6npM0e+Ddw/NzCdoIWhiD2Hzb9XNyKHaBG6mYsARozc/7l6tQmPSAapSc8nqMwuGcmKHJvb4VyBqRkNaWzyAoaWwy9yvnIeDKR5PsGj4RIitGMwSKV+d+ns5usQuk3NkK+7uPkIgctucT25scHl2vhkKI1u4+tq4TPwzkJWq4EfhNaLO0lLkKlFtwwlMijFBZG3t7rR3oQeUHeC5WnZDSZdA8h4eX9qBF6JhW6dJmT9bUt5YxYl3VJa6YU6+kGoQkaCUTEfBG6Mln6sJ35HkK1uQfYxOEM4AE2xco/T/5ylZ5ukAgFKBDhYZ3/6PTQSZTBCCRelk/vR0UN8Fd4Lmx6/EoqAnd/2am/lfXPepGSX8Cz5qF8A4sXM8HQkqt+iaO1a3rE/7X5W7NYk5Ca8tGbONN5Jfg48CYf0OC27aGfU53ZzityIEEtCdBgmllKe7UsRwjvoEBRkPzmux9krcrQ2NbiRu2JsGtWXLVxMk4f863YC2c4+WGcGTPhY6jjKYJcmxiJqa9i5i6kba4ajBZyBCc0xSO/8nfl37HEL5XjxqtKtViAcbZNWCAvovgmV4Pmhui1P5SF+qmllU9N6nkKlHZVIu/4an0JXZi+X+9N8MVz0paAVXzMctZu72jMrbB8lNn3M6gYwnne1wAK2KyODAkvM3pkLZChXQZBL1xWQjkfhQN3yy5B3Q9XlHyKh9lFBYhxA1B0Nw2xuqo6+OjU+FIujj/ln2KGAZbuBGf9pLUrbBwwM/00Rr1IBn8W6HYh1/4MtcgN3Vgpz7pa8bFrNJmRocZF3GatFO0TNnEIRwOuj/AHlLxYPC5WWTuDdWtu6sA0OAoF4LgwCS2SCoK1hevhXPWWosOsCFd1VESUFM6zrEYZwWqUat7Su+2iws7GYvnDCH9aeirr8Wwkv2PJyWpfk4iJx16oEQDdcl/QAXq6i1hdXYM0Un2h0XqBUrd/I7ub32uA/l7CzNKulC4OnH7XaTrd1Kt7ow8z22gfEFuyzligyrbeS8nT9EywDEIIuhFcNppzoZPePFjHwg1sQC54WhR/AYpaCRmKmB0bMjzIrVfes+apUV4cZ+udL4owdrKxUoOgXieQYUAZEsmebj6aNPECyXm5RagD+QCPjhP07kzC8paTTKo+BinI59k8wqHf8+MtnmOn2+YW+F898joIM5fIqyuz96cjJO2Ztg070cqp5FYRgS8tYLiZ93DAr+XZXE3vh8Ychw0qzaQBzdHdxt0XOBf4iPO/o1YJtuVLg2kk3kqHYFgzo9hU4REsZhcvOks/qhhiqakEqKY3RDXVoKKsgIYdQ+Abf4OmsDonMXWVfizyt821mstspXF2s16GwnE0pNVA+ckV90Hn2UstX5xL/Q7IVWZofsidRUNyGQMHShuxhhR2autPpGbiUOy3dzm29X/WtsjvqbHgRDQBuGBZNRsd+ANZySh9IOwNB7iZIX/4Km1CeWQxLYlACGZFMsh8oAH8FfOrYql80nSK8PLadhE24D/WCgJq2e3q6ZZ16NHtxkpyi1PsoVe7IYox3J332XY9+7S1vo5JcmQX+3L3y7EzET2HvehqUtnSjP5/vo/kwL6n8G0vmyEUf18FEX8HZOlpjlfQI9LvxA7Zboz9T9L7weRG3ySq0+P2UF+6sNwgtaZX1YXcox9TQ2d6YkC3a7vugF7y4x38aSSI2V79cKHfVGhcblGdspvRl9S3KMV9qHEvR7jEkbCSKYtHStHYeP54Llz1ym8mEt/kB8mFXk9g34hFpzXVJPi6XSSRrotR0aua00MZNgnPu5CWqyCFhE1UPBosYtbP6FYpRTkRjp2awjq5ucFRCfJTvQbdtQOUIf4Q3GJ4KFOtE/qns+ZfCG91SIxx4I3UaO1xrhAiSXJIVJbDsR0KAe7KXrCK4H7xXZMX2CifyI1zubXjhnWX4EIi3TfMlvYf0kAR4eemNigv3th66vEhaprP4okhISc8YlNJYkLSkwZm9KZqAgXejhKex3Beh8i5YrUTZn2v4rUUK3qscBebBPePj84bEQm/axIEpnGYyZ6zQGAUQYqDnH9OhZQulgksd5WYjAInOfds4H9Dx1x9vPwEHWOdH2j686Xfsk3Q1OThpNeWnlyaEZg3674T+HHRBOHaUjimXPqD1nkUVqhJ67Ab2TPS+U10izFe7ykd5g2SdQbgHQ5NMnxuL2CrnWWs5TsMTf5kY+SXA9c2I/YoICneS6P8N8tO9xZjNhIzbqqgzQgvmQj7DBm8Z5El0TJ826m6D8DqCS8xIanpV5+GlhemzwG7pKUj2M+MJ+/AZ5c/3nYvXsCcCcdhRlRHmUViyOljr2WXdGqLqPpBUVUtIfrMVloG4HT4YVhn2Q7GgMOeqrq/XRv2E3AFMj7K6+cenL6Y/xlyaBhirFOtpTOwiauGSAMjJAwZAnw85GeJLt0S0vQze4GGRqu0xILpKHaXIjVJEG2ZkQ0AfbvVI+yiPoTBgIwh2UfpjFPuAdpr5/TOJOLlvrmdsGosop9SvgCxOk7yQU/ssbQjG87xsVpFDeQZhcvwJYnhxPNgwmSGL4NcJR17KJTXk1m3igAgUl2zAXpmgvj0acGZFsjDBgW+z6eAdtB3Bh1y1LmNYF1SJwBSAHloRX2CZ4Mp3H2+w+ncXxATDSLAxiTEXgchfRTlqYFz6h+ZP4Oq4Wf196kZ8NrL5PXMuLdA1NLWwL+U3tQM70R6W4Dgg0QaFjUqkqG47Srz+iBihK9oPC4ow9jm8h6RITcrYKi8zSgcf/YKbDuUQhBkAW61GoUT7uHlELWduXaYOd7BntwF4RM+eR0U2thg0FecLq6YI7VcZND0aSP1py9YL6qnXbZyRhAndSpajFlO6dY6VgCqOssMgherAaS6YyI+F2jhPRh14XrpY5BHUxMPLBr5/sKlRUciUwBP/PnhI3EXl6ohGKuJw3a2p1BLNiMURd12UYNaJHFalswCD4LDYncYtV3nrGpxmRBGXE+YijSQwuxlPjZSlTUnywCobY2/PA3cla58yUQRP1sDxSRuOho+eGDpuKO8E5jASqgp75mhtX53/Tv4H3YjJZv6LJNLilgZZedWe1Ug889R/UL4O7lmCoraLvDl0ujBN3ixHLvFHHAn9CSvHSnVIEGpIutN/r7y8XxRaaXcshxu4iF/68lI6ER0MDy2Da+9+EUnQJPrW4rfkJ9fD9fxiF2PnIZbNw9EjgJTitwvlS0n9dsDODD3UckO+MB9dq8DOKzBUw97GJpuq0nvw00P4GZ6dt4uWnhzUnsbWJYfaHNtomeNvQo5a6x/O6dQXRU+AbsRpVkb9O6aUj/8nJ5iMs0TXQRMDwJ3N5+l8Yz2TSjDICYSmt1n0gYkGbhGPZ/lDl5wbYptZXlVbU0pUqJTvncsPDf2ZuE6/vPNWYjY3EUFsFpYmlgAfFp6mDk/lHhTqZPLzzf00cL4eakdclOOX7CgEwN9Hi9jOLrBNkMgEBLo1u1AU9e6Wx/DanIjaxv4y+0yyRTJlJ6n5uyAs59079Utj9LWbumxaHdJvx8Z2Jfsm7iGCVWgafdVy5nkolYfeu8OKIb7IUOj4t/td3QLXRHfH74p/f4cDvXK0zMnEAA0zdyDpxcoms+y1u5w7wZZ6ZMbp9a+TOKiSaSMhaT6Ewnm0R5hSm1jfWBogOPjtplG3YRjjXIoQCF98u0LzYbQtu4o/emDatwFUjtN0NNqidTpIT2UgY0h6l0pfIMj0t/ZytvycU/b9vIKhbHVYjg1J2p9YwuiobX23Xyu/E/e7fs/8nW9yxk4mdzBFlSIggFGCTGpPt04m3wGna+BiPQQG7Qkbkv5CbZhWjp27uMyS4cy42618ZUUyTpPXS+Sl7HOrP83Q2m3raKarF0bkw6L5EL2F+WNVPEoLvZS5hGRuRZRuiJDAHVe9vRwFeckg0oIvc5OSRng5vuVN8GH4C1gw7Ds1UpkG5dKQSEXomosJ5JRSguopnhV5EWI5eWHvvBTbeWGHmmiTDiVuWo+QYu5cTMSGx04XCrWJnAqDmJBAoAv0iQSCBX+TancOot4kyoS+DXhyoStyw91BclrB+fkobcOii4pdqc48omqaVhph7P6uVHmEi5hVDVJQbl5wuq3YUWTP6O8GTVyQxxlUtJ0wVbCLn7+Wd65K0pzeaxbJl4XXFqMLLI7ATLoHB6NUNW0+scIcPdgtHDmCCig6/bMTaOEalq83UGPxzYCYJVy002uOF8zjTwYwm9K72TpblzZ8imiAWBZ4MY4MCcyw+tfFMNkq1QlTbbEQ85wq6U+KH8j3Erbmrcyn57oIMN3qeeCLRFaQbcj6ns9+7m/O3xVWg2hyV0TWOwEJiYsQE0x3yN0Gs0ZSNlNO+ger1cDlPH56QynmnfTUJCZFA2tiUncunumiIZBe4k8YW++R7FikYxziEUIAX6AhQs2JhRarBZ8gUV+lUwONdap2FRaBEsRjyGgm9h/L2Ty9+K4b8XWnrxw2ltMCMAkrLkmFBH1U8wRAPxmLHuqMrI8QDglAjfEbXdbiOB/w96v2sK+NFEOMxoYM5SeAOcPSAN2daxW3LD+BBeEs3YTmWS89HSJcmaZSifwhA9G4J+qBCjvo5SLEZxat1pFBsEEgaWM2IlH9Uh5xDnuO9Ng+WuFCNcI2YQRuTDSkLoBuFCnwO6gF7ynYOrQWNfgsJ/C9L8HAcnGDOZ3DvHuLAlSETXjj2nxmbsgmr6W+ldNwrwHUAdguB4D4jpK7swqOEAhZ/wn8R0WpibSs9P0eqbYYImpQx8vNlX+T9zSrdGNxFcbpYM/vwxraywln6+N6xSvPkCkZiod+mC/1eiYJfMSFoGi7V+28f+vRWTJ0r0hD89U3uB8mYLzcOwCERWu4kA90nsQ0ILCxOLTxcwtyMNdYZBHmKDHIl/e4J8fw2xtgVvwDqWIehSjyttEtmS4dWsyIwhnNQClCC5bUKtnXEqkhMHZtD6T7Qlm35okyNG2ab/NOaHzgMWojWDG1ccCyBTQoWWmOcAUo5m/1oA/6PHZyvqa8AMMaJfzYD+kzQ1yJrgSVvRyWhFKxfa7rnFh/XgrceFbAuBtWeLOGQA7p0GZ0PPvozFK0DdFlbdVZZGXg3DmwDcc9hnwgTRltNZTCv3eEISBzGPO3DEsEf6UWqFgVF/LU7z9a32xw8kEqSwCYSVFs2vW3K2QZHXEQZw/Yxoeti4t7lv6UBpAW6RV3zLnckm2p8cnG5IEUdoIO1C2qdyUEgTonQKUEXg017G4E3wKLhu5oRBxG3aP7L2OmacQjbjP/vrwChx5tHxTXijxD4tI/37XPoxfjurj7AMJ/Cq3orKO9L70jwwrsG+R3pNgGdrtDsZR8fI3JiXNRdFqzcdxWn7c1kd/lOXUSPQ9jG1grKb8s4xSv6dm7SLu7fCjS6ugwuZS2FSqD+fAmRvih7nYJU6PrKkhWrlOGRzEvcbLB2juCbPAhWeMt0MIqUrUzeaDgl24vVKoSX9uLMBh2GtS/YeLsQYkZ02IIuZybAjB4tyhX5QhQOs4TKZT4OL14J2Y8NmGKelV9SGXBv9gY6kT1Pv8wkcr1HZBvDRKC2ja+2Dgd6cztadBqO2LnapVCZtF/AUryYCmhmiU8MFUwnxhhhRKJyGK51d0dAl4VZ6yfeDMchDsK0nTd9Wt4U0a0pWXo9Ecqxq9cDLifGGYYlcvJtqTqm5wOroaYjKYTX7Ez2gihzjxRPzULokJ591dyAQtcSPGGzImlk+jAlm0SiW1CTxgXndtfgBT8gr239hHekGRJFMTvE5VjT+dUM8Meht4CcGxr2cV1/AKSWjCEOdE+PGVFp7C6EpGnRqKUTWNY2l1dlHZb+7Da4dhnLomRa47vwF36zEXOLX/tIkh0zu5vvxjEY18Cm7fHS/bY4SPMFIl9QD2rt4t0v3cANIjqlFf1PqfPhqWd3IIW6N3jLwQZ4AyUUFRQNYW2E67CN2sxM2h9Q177TaJ+lQTb41e+jALCpDRONaz/011D7SwggSUtglmb8puycV8zjSLNAu9DlKlS3X8vEbD3Io855XOjvDBBrSztAnr0LpkXAEEuIPNxZjKwxxP8R5eY1AnYzKZncBcWSSP/xg0EZJyq+uQXNGVYFOUmBjifa9vDp9bjSfbFo/9W2ZGCaRsJ3TVbC0xLvVODO2CRBihoHPgxOwg1vWn9dZFz1SmeuK5arAqdRcY1gfCKeLhGAoJFqiIZVnIgJ8rKUST/6miX1kWqjON3MG1Q4eEhj7cwM8WqQWPBahSM0Pm6Vrin2q5C9lXKXvpUfxFKNDOBfV/D1o5a057lda/dUuh6+4N+3qZep6FQM2DnrDVyFXEm0COHrJ6PDH9dGFI7KuWiZeQsiWMLZVOETaTI2FCEnBsiSJ7tPzI5mFf29TlFao5d6ZQhN0ilKZd9pAiXSy2VgBySIxJm0aPyqc8w4aOXTUsivP5fBXzWiFdqk2rL61vdELlUB0cSmGS1aoS7Y4cufdl69YViI6z3YbUrChpMhhlHpI3mAWn6Pg9iKslN1pv/LBB1Q7XCtEyVLTYKN36vHot9NgHR5nwbP2M3blkCLmTQUizlZzXunuuTiDcLL0b/nvdH3AgOFTdBWUMGLx3oqqpOkmPqJ6URoBiyztrQTCXw3kFS5Pq3vgJZhtss2+yr7NOaFuLuAa/RYP4AWzQXnaJeUyzLkbyg17uVyab7Oq2wTmct3LHGz40po+4qdMcpqdq7p8cup3vAZmMeQ2kNeAHqmIDrmD5DEgFq21b+/U44Nr9i0txo1uB5nTeYDzYLf/Uz51a4bTimg7M7cD67sqz34oI0jufzVUO4kupFgBDL70v/DaVuf0UiCySpGppcHxqxQsAkk0AAbpga7cJ0cQM+jZbfYuMVGqL/HnWo9irJ9pvnmnf1vNjSBa6T29qrQxGUXuQrr0BrCimBod/Aw5OKvikLnRrnSJrKn9+AD1zYWhOvhbVz3cHR1Lw4RMm6G71qH0TmSfvI9u0vvqyY17FfxA6/CNVFaMHnHDKYDzDRNqk7bOV3CJLsASDvMjrh4+c3w2VI5l/3oxtkyGj4zQWyZ6Z63pFCSxGite97gNMxFCyfIoFL7JxcfTWWE78ETBiGrv4WLLkcS94h1p+jJKvIa4t63hZqIF80pC7Q6+vqN/LW1UOLvheva+gSS6meUecDlXHIIK+eGpg9aE98qLqH0r3nVMPXZcpPm29BOoFxs6MlWC4o23AxPILaxx9U4B3vhDEkLYGm66F2/FbxjWa8ZuiTJw13X1FupqW69MKvb4DfNnoOR/XFUtlyRlyHyKfVaIZbQUOuGW2oqbCQwJancllcW/VRtHtAfjzOOG26c3YgCDBA1RDKlzYIwBwJIM2WFxC8w+USN6UQ+Xnt6sCm8Z05a321SlU6qZwJmhH4T+ts8mTSn5VuL4dPxOfoiYhPQQNj3ES+vWJb/3sE+XNUOqwNmSGZelR7cP8l6l374663YQpJobpa/1uIk9VKe2vAQfY4pXmS7kjieYxyWY62+HbVGz3qLReXWoDzpdIdF77iIIwMmaYgyWDBr2lr9qhE17zSFQBZbiKs11UwN+PwXVpWJENbCl/0vFXkrpH1QGfTVJGcCjFK/5hCFel0K3LqgtnCDy91jBlqmRJOI8NCLeSO5kQ+ptoUjMe0fAMcdHAlOshR2cfCexJFIRI3prVNE/kpfOuysRKumyL2EXCUaZJTsKqVXKDgkCYL4ObsifByixtH/iasDUElJCQFW++TXIppWFih2vIj4fPz+eKnVQnxLxyj+RvwPcRZqVBGDmB7Ucb94dGdXGCglSU5+mN0FvxAZt9nVl+uXWGy1g+IIb31QOg/3rP9kh2pcs+Y3g0t+dMIIlhfZ11cJmT7oVQiYU0wo++9bIw9RZEtxWysr8w17jKoy4Jtcuz8XAfujX+cjpqtyN+mJ0nGhmWVpl6IZSVHkNbqHxXunvQ8pYKXEkYeEjxnf0VludOGOlb25sLeKXgun8fuXAUldH9NUcFVqW67RdRzkdbN3ouUstKnZPZwGcrDbyOIcY1a32UfoGXESK0p7mnPtRPB8NLfCQrzsIXxguiwrsKuGHmVc9Zxse4+G83vJHbVVRDue88HlDwMWal4QbN2SyRGwAD78V2ACNDN4n74p+gTHOE/82VDnDQRaHcl+stsWFFxJatS3MCL9+ZE5YmQpS2kYJF2wxcuRn10kXbhUm3MYlfoGqJ/etQwU60cyw5TsfSdE+pXXHUp5CtUIRCdSvh3U6FQ6j+uq50GA8zeZTnldD0DKnZWBKeih3pD5EtGGaVvXeTLKYOEr8ls7n9M8W2JxgV1vFMi981beS4c4SqRiOp2xiZdwpdKTZEy7fO8u1uE8qjjHcZDmWFAEBexj0oyo/MaALkNXEgh88HZoP9EvxL4M23n+zbDD1UACQP2t/NQ9Xqb7AGDKQBPOkPpjnCSFsd8YPhcLZAFTZ1SKOjEE+GMZBanc1s1jrjD4Os3sqc1hV/PWufL+UVM84Scq0vlIDFmJn0BroTZa/PUr5fwZ9SXvWiKd/lAhS07JxPlqa9eLVAw20kYgblJ2W1f1eJKqnx9UvrM0dpv44rm6JeSGZtgsuwP/nB47YbiylRfQpijUkkRk+i1lFxuhYwtLe73o8sSoGCK62Cyh01MdqMPYUcy8Wm7S+Sf34zrmCdrfdTzv+/m/hqqRw6E509bXLlNggUJUlNz01hJUQ2EsdWRE7vddwfVzZFGgzq3P/71nk3d2g3P7OBvCcdnZ2/RkT+DXCYYFykTRiYmsEZ1l1NnifflHlnoHNKruh4fTGU2KK/qLH+36XiJS1tFqv2y1hAywcHlw3KwDEmEB6BjL7ZxD8Sl7YuwxKT+rxxeGHVnI/eQlHdAaFvZ3oeRgWXsPRMkwgR7W52zeyd7Mwl0R6xnddxw1oy69Dikn9kNj8EYUw6NkDxwEjjuUAj9tgk5jzDglA2Lf47YEfyT6Nr80tfpeh/0DrH7c5CgUN5Xdmagf2gmy49m5RsNpIZk+3oBTxBHMPqM0w9kiQskV3bqgz3sdXEGqTC5ZdNo8dOQq6u63SRassQ1V8IZyTbzel4W6dwLnnzF/+sLheZT5EXe3jT7uVqTb0ywyEkORNL0KM0lhqILffiKvwnGqf0oe5B6p8ZEoymBTgVQDEx/OQrr0oNl0Ct52nhHN5IggAElB3X4fFzAXbqg0za0xl/XOYQ1htnlqyI1Q/lp4LlIAt6MzaoeJt4bsnowrVKHbAwoyvZXlEBCjRCGG7z960L7fdVd3aQ2QQfc256n5Vi1w+htlKXbm4RjcdMjkKIZholnzrLC9dWOCX32Zz4BQWL/wDF+P6lRAR7lb/rmSPJAm50QopycvkjdmZroJHx0tSuJVuUqprjdJCV7onPEQr6Z34IeHCxw7tTBYR86Yttl12Oxc1t0sOaoSke4CwGNPWXmdK3aOgojNvrWMkoV24pfE5/1giAuKaT1XCR04GVHm0T2+iSh3ddw4FhuehOGgnZBByFcsEeIjnhXk1ldTm9wjNqNRRhlWRz+dJiHiZQmDgqEgyLKcK7s65jknnEm8OiketaG0ow79qmAUsJlQcC7NIyZoeI0H9AWpRMAed+Xs+iIQ/f68WzVrVP8xegMvF3KmKZko0dJoCzmkjgdw0C5ssVVEWfL3Zi4xuPQ9ina2j/AwwQiQeDxqqHtVkC7GrE6fqOEwGPjNNO9jq2qoJTk/eo4E1WKp1hoXg1X+AUjRVn79Uj9sZ8kyLxOEMQk/1ppgqeUwtqjuAK4zGS6FqDVlYl/xVj4wl+j22qzIFfj59V852fIoSRuDqq7HgLq2c/+uIXn3Ac8Cc34SFtWzhYGuuX+C0PR+2OeC+xCcms5FXr2EYQOXsv7uiw5bnkCz1FM4w/TIflbborOKDCV8wWP2TwwWV6iLoWWiAU4uTEa1MCKlmsG1khIf4euLLFqxxEjpqEOPZW5Y6j3p7DUSFEMJZZMbCm/8RLD7JGkOEpUM+CjajJyZl0BBDr33MjZkT/pe6Zk+usDp5NzGrmj72fsN7qA8RdrN7yGEcWnqws/EJQ5FKhFD37Y4AC9iVRu41gDqjldTBlLWji7OkG+uPDb+R/sN8j21laGARCA63YJvUGZn5tXFWU+Nurej6xakv+mNRojZez09ht7QIlvaI1o2dJGiZJaDTuDSj97IEtSHOL/VDm/kHj9pfuR1P3wqq2v65ZfKB/wA+dpcVgPYKagckoUL9b+h6vnKf4IgnXfA8kh2UnypHihc+/l222QJhVCFXAt95P/jCPgE4CLz7GKa7X3UJ1OCSddLd7vlDqsZT5BPCB/qAH5hfqCzi2GZ/qy7MYFd9DJr/7nnEBRIfuA6XnOfn+qyzuWXcQISnfWtv1WlYwsbcO4v6x82W183HAOETjgjhP7PDukaQcTOGSRb93f5NxMAu1AXheNoJdWXHGng3ne+4JTJ0vaQGkVBcK86/n5vaGHar7owWU1IZQ7WzPwjD1FUtJQT47jZxLntAHpBgsjoybIVp4XUVJ/4lrEPHzi7/V2DbnKQIeGYguDw44iPMckgxy/frH3uU/UzIbSNLgfdZ4KnVFe3PD2V+VcQR0TJl+u0GEuULOoVrflkXDgmR/hzxaNRHo6HjVraofxUbJ8D5NGA29++4QkUElSE0WFWGGVlz+2ArcNcTdLcPBl5VnDmwf1y8R+GI+0MXuWkz2nKvNJdMJoR75Lv8PIflBVKbP/0ebtNEbORREd1HhMENzmPMr/vpp2SIYGqzwSMKEJW9Qcf6stIQW5HrULrcouvNmO8QyXWUQqqtnZHUlFmzRYUNhLXmMd049uaXYpd0NJ125m4GtRf/ZHugsgWvUtAcSOeBaUN4Ce8cBKgq7GCCJ7KuH95Uet/aL0lcPBeF6rnrg9kmnrdw39XYyLrNG+28LxS8Ve4oPI/w3s7qA3vT4QyHDe5oceK6YxXi/9pCDoWjIT0h1vaG+tMs3MuBVSBUTjSsTtv5jPSRYSjgVAjTTwpziLftCgJI53IJ77UTYNwvWcvqWOV2HpicTbjs0gjQIcGkokowFJjSIK+Csxozx31ahxrpKilAPV544e8pxXnEosY3wPPgeaOUBRrVCJcdUjMFD4dz18cSrZx0R0eCJ7SWjVOVG29xtHbgiHC+D15/FoqLzyzAHJSjRO0jmrnSyyM+MnWAGQ6yxQ6zpsY9L1dCiDdCabyQAknfmcBBfE9cslnB9wEeic3SbE9yXIo0ziJg4ypnOvzQCk94/NnPMKsqxYnrR3GSCRQU6i2J6xxC08V+yFFcd5l+XKYFth7obHNXOBRuYjFObLWYTudolGPjOl3lv1tTAL2MHZJX13ujNpsT/nQXxYlwbDHLjbLAt14MdYlWUlND1OLKdNQuh3fH66GpcyNQFSJRgS+CWrhy4SQLMSw/6+4/G9iHrtZXs+hrDixdIJHyobD9GOZd8tSvw/jIkyziF4Gbapkc/VvI9MV4Fpw8duUDI/oj+naq5uTpGgfJ5n2DgNKuKTYnqW9zDKr1ziRkIhslrmVXfQ+22JkifDWGfU+woghfIUqR3lHjPX++nVj7+unhzgt9yZkMDuJ9H6thNcmtCIHsq08KhzUF5eZW715rN4YnA4erWsYSoNxxjOEuBjsXhbeLc9q2okdx80BX1dOYbc6Jn9uFXEn9x17aVCSXdOdBpBasrIvBGcpdLr//Akw0Fygohw/EJaFf1knobS+VtvjhDqmF3w1W0xRnzQyiDpFoFeUvmIGWOdizQwVLdkcJ6gEFGjAC6jxuE5kTH37R5g4PkK+XCkp+PZOBf5M7nL1Yas1K7VuXWGZbo5N5m7biKFkL1neck3LFZqgYXc6/3BiLTEz4vsnqCoBkhKUnSQuahS1RsSLonZSkJClqpHZ7hIBPYztPBI/VVJYuIPi5sBHTkdEYjWRwEv9qcv2TQUaJaYDQ5j/Ff/xWpsazNN0ZTiUyxhhS533ikTBk9F17dTHcdTUdnejXDEMNvyB090zigCCFkDjfzypBgkA8xh4RrygjXVNIlbbgSh/W+OiDjSAW+OYDb9LBym6Rb0rifrrHOFfXZm+HWQ4HqEjIjrP89KueS686yRT+ZAi79E2/jIjjGSSC5tvlF8Rk48b3zuGNtyUXxZEntABLgO15wTPgZ5Q==]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
